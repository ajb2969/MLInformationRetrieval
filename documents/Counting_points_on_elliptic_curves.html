<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1933">Counting points on elliptic curves</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Counting points on elliptic curves</h1>
<hr>An important aspect in the study of [[elliptic curves]] is devising effective ways of '''counting points on the curve'''. There have been several approaches to do so, and the [[algorithms]] devised have proved to be useful tools in the study of various fie
<p>lds such as <a href="number_theory" title="wikilink">number theory</a>, and more recently in <a class="uri" href="cryptography" title="wikilink">cryptography</a> and Digital Signature Authentication (See <a href="elliptic_curve_cryptography" title="wikilink">elliptic curve cryptography</a> and <a href="elliptic_curve_DSA" title="wikilink">elliptic curve DSA</a>). While in number theory they have important consequences in the solving of <a href="Diophantine_equations" title="wikilink">Diophantine equations</a>, with respect to cryptography, they enable us to make effective use of the difficulty of the <a href="discrete_logarithm_problem" title="wikilink">discrete logarithm problem</a> (DLP) for the group 

<math display="inline" id="Counting_points_on_elliptic_curves:0">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>ğ”½</mi>
     <mi>q</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>E</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ğ”½</ci>
     <ci>q</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E(\mathbb{F}_{q})
  </annotation>
 </semantics>
</math>

, of elliptic curves over a <a href="finite_field" title="wikilink">finite field</a> 

<math display="inline" id="Counting_points_on_elliptic_curves:1">
 <semantics>
  <msub>
   <mi>ğ”½</mi>
   <mi>q</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ğ”½</ci>
    <ci>q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{F}_{q}
  </annotation>
 </semantics>
</math>

, where <em>q</em>Â =Â <em>p</em><sup><em>k</em></sup> and <em>p</em> is a prime. The DLP, as it has come to be known, is a widely used approach to <a href="public_key_cryptography" title="wikilink">public key cryptography</a>, and the difficulty in solving this problem determines the level of security of the cryptosystem. This article covers algorithms to count points on elliptic curves over fields of large characteristic, in particular <em>p</em>Â &gt;Â 3. For curves over fields of small characteristic more efficient algorithms based on <em>p</em>-adic methods exist.</p>
<h2 id="approaches-to-counting-points-on-elliptic-curves">Approaches to counting points on elliptic curves</h2>

<p>There are several approaches to the problem. Beginning with the naive approach, we trace the developments up to Schoof's definitive work on the subject, while also listing the improvements to Schoof's algorithm made by Elkies (1990) and Atkin (1992).</p>

<p>Several algorithms make use of the fact that groups of the form 

<math display="inline" id="Counting_points_on_elliptic_curves:2">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>ğ”½</mi>
     <mi>q</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>E</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ğ”½</ci>
     <ci>q</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E(\mathbb{F}_{q})
  </annotation>
 </semantics>
</math>

 are subject to an important theorem due to Hasse, that bounds the number of points to be considered. The <a href="Hasse's_theorem_on_elliptic_curves" title="wikilink">Hasse's theorem</a> states that if <em>E</em> is an elliptic curve over the finite field 

<math display="inline" id="Counting_points_on_elliptic_curves:3">
 <semantics>
  <msub>
   <mi>ğ”½</mi>
   <mi>q</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ğ”½</ci>
    <ci>q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{F}_{q}
  </annotation>
 </semantics>
</math>

, then the <a class="uri" href="cardinality" title="wikilink">cardinality</a> of 

<math display="inline" id="Counting_points_on_elliptic_curves:4">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>ğ”½</mi>
     <mi>q</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>E</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ğ”½</ci>
     <ci>q</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E(\mathbb{F}_{q})
  </annotation>
 </semantics>
</math>

 satisfies</p>

<p>

<math display="block" id="Counting_points_on_elliptic_curves:5">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">|</mo>
     <mrow>
      <mrow>
       <mo stretchy="false">|</mo>
       <mrow>
        <mi>E</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>ğ”½</mi>
          <mi>q</mi>
         </msub>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">|</mo>
      </mrow>
      <mo>-</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>q</mi>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">|</mo>
    </mrow>
    <mo>â‰¤</mo>
    <mrow>
     <mn>2</mn>
     <msqrt>
      <mi>q</mi>
     </msqrt>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <abs></abs>
     <apply>
      <minus></minus>
      <apply>
       <abs></abs>
       <apply>
        <times></times>
        <ci>E</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>ğ”½</ci>
         <ci>q</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <plus></plus>
       <ci>q</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <cn type="integer">2</cn>
     <apply>
      <root></root>
      <ci>q</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ||E(\mathbb{F}_{q})|-(q+1)|\leq 2\sqrt{q}.\,
  </annotation>
 </semantics>
</math>

</p>
<h2 id="naive-approach">Naive approach</h2>

<p>The naive approach to counting points, which is the least sophisticated, involves running through all the elements of the field 

<math display="inline" id="Counting_points_on_elliptic_curves:6">
 <semantics>
  <msub>
   <mi>ğ”½</mi>
   <mi>q</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ğ”½</ci>
    <ci>q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{F}_{q}
  </annotation>
 </semantics>
</math>

 and testing which ones satisfy the Weierstrass form of the elliptic curve</p>

<p>

<math display="block" id="Counting_points_on_elliptic_curves:7">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>y</mi>
     <mn>2</mn>
    </msup>
    <mo>=</mo>
    <mrow>
     <msup>
      <mi>x</mi>
      <mn>3</mn>
     </msup>
     <mo>+</mo>
     <mrow>
      <mi>A</mi>
      <mi>x</mi>
     </mrow>
     <mo>+</mo>
     <mi>B</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>y</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <cn type="integer">3</cn>
     </apply>
     <apply>
      <times></times>
      <ci>A</ci>
      <ci>x</ci>
     </apply>
     <ci>B</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y^{2}=x^{3}+Ax+B.\,
  </annotation>
 </semantics>
</math>

</p>
<h3 id="example">Example</h3>

<p>Let <em>E</em> be the curve <em>y</em><sup>2</sup> = <em>x</em><sup>3</sup> + <em>x</em> + 1 over 

<math display="inline" id="Counting_points_on_elliptic_curves:8">
 <semantics>
  <msub>
   <mi>ğ”½</mi>
   <mn>5</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ğ”½</ci>
    <cn type="integer">5</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{F}_{5}
  </annotation>
 </semantics>
</math>

. To count points on <em>E</em>, we make a list of the possible values of <em>x</em>, then of <em>x</em><sup>3</sup> + <em>x</em> + 1 mod 5, then of the square roots <em>y</em> of <em>x</em><sup>3</sup> + <em>x</em> + 1 mod 5. This yields the points on <em>E</em>.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>

<math display="inline" id="Counting_points_on_elliptic_curves:9">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

</p></th>
<th style="text-align: left;">
<p>

<math display="inline" id="Counting_points_on_elliptic_curves:10">
 <semantics>
  <mrow>
   <msup>
    <mi>x</mi>
    <mn>3</mn>
   </msup>
   <mo>+</mo>
   <mi>x</mi>
   <mo>+</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <cn type="integer">3</cn>
    </apply>
    <ci>x</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{3}+x+1
  </annotation>
 </semantics>
</math>

</p></th>
<th style="text-align: left;">
<p>

<math display="inline" id="Counting_points_on_elliptic_curves:11">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

</p></th>
<th style="text-align: left;">
<p>Points</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>

<math display="inline" id="Counting_points_on_elliptic_curves:12">
 <semantics>
  <mpadded lspace="10pt" width="+10pt">
   <mn>0</mn>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">0</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \quad 0
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Counting_points_on_elliptic_curves:13">
 <semantics>
  <mn>1</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">1</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Counting_points_on_elliptic_curves:14">
 <semantics>
  <mrow>
   <mo>Â±</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">plus-or-minus</csymbol>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pm 1
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Counting_points_on_elliptic_curves:15">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mn>4</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <interval closure="open">
     <cn type="integer">0</cn>
     <cn type="integer">1</cn>
    </interval>
    <interval closure="open">
     <cn type="integer">0</cn>
     <cn type="integer">4</cn>
    </interval>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (0,1),(0,4)
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>

<math display="inline" id="Counting_points_on_elliptic_curves:16">
 <semantics>
  <mpadded lspace="10pt" width="+10pt">
   <mn>1</mn>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">1</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \quad 1
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Counting_points_on_elliptic_curves:17">
 <semantics>
  <mn>3</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">3</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   3
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Counting_points_on_elliptic_curves:18">
 <semantics>
  <mo>-</mo>
  <annotation-xml encoding="MathML-Content">
   <minus></minus>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   -
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Counting_points_on_elliptic_curves:19">
 <semantics>
  <mo>-</mo>
  <annotation-xml encoding="MathML-Content">
   <minus></minus>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   -
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>

<math display="inline" id="Counting_points_on_elliptic_curves:20">
 <semantics>
  <mpadded lspace="10pt" width="+10pt">
   <mn>2</mn>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">2</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \quad 2
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Counting_points_on_elliptic_curves:21">
 <semantics>
  <mn>1</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">1</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Counting_points_on_elliptic_curves:22">
 <semantics>
  <mrow>
   <mo>Â±</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">plus-or-minus</csymbol>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pm 1
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Counting_points_on_elliptic_curves:23">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>2</mn>
    <mo>,</mo>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>2</mn>
    <mo>,</mo>
    <mn>4</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <interval closure="open">
     <cn type="integer">2</cn>
     <cn type="integer">1</cn>
    </interval>
    <interval closure="open">
     <cn type="integer">2</cn>
     <cn type="integer">4</cn>
    </interval>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (2,1),(2,4)
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>

<math display="inline" id="Counting_points_on_elliptic_curves:24">
 <semantics>
  <mpadded lspace="10pt" width="+10pt">
   <mn>3</mn>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">3</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \quad 3
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Counting_points_on_elliptic_curves:25">
 <semantics>
  <mn>1</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">1</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Counting_points_on_elliptic_curves:26">
 <semantics>
  <mrow>
   <mo>Â±</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">plus-or-minus</csymbol>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pm 1
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Counting_points_on_elliptic_curves:27">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>3</mn>
    <mo>,</mo>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>3</mn>
    <mo>,</mo>
    <mn>4</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <interval closure="open">
     <cn type="integer">3</cn>
     <cn type="integer">1</cn>
    </interval>
    <interval closure="open">
     <cn type="integer">3</cn>
     <cn type="integer">4</cn>
    </interval>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (3,1),(3,4)
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>

<math display="inline" id="Counting_points_on_elliptic_curves:28">
 <semantics>
  <mpadded lspace="10pt" width="+10pt">
   <mn>4</mn>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">4</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \quad 4
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Counting_points_on_elliptic_curves:29">
 <semantics>
  <mn>4</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">4</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   4
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Counting_points_on_elliptic_curves:30">
 <semantics>
  <mrow>
   <mo>Â±</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">plus-or-minus</csymbol>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pm 2
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Counting_points_on_elliptic_curves:31">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>4</mn>
    <mo>,</mo>
    <mn>2</mn>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>4</mn>
    <mo>,</mo>
    <mn>3</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <interval closure="open">
     <cn type="integer">4</cn>
     <cn type="integer">2</cn>
    </interval>
    <interval closure="open">
     <cn type="integer">4</cn>
     <cn type="integer">3</cn>
    </interval>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (4,2),(4,3)
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
</tr>
</tbody>
</table>

<p>E.g. the last row is computed as follows: If you insert 

<math display="inline" id="Counting_points_on_elliptic_curves:32">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>=</mo>
   <mn>4</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>x</ci>
    <cn type="integer">4</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x=4
  </annotation>
 </semantics>
</math>

 in the equation 

<math display="inline" id="Counting_points_on_elliptic_curves:33">
 <semantics>
  <mrow>
   <msup>
    <mi>y</mi>
    <mn>2</mn>
   </msup>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>x</mi>
     <mn>3</mn>
    </msup>
    <mo>+</mo>
    <mi>x</mi>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>y</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <cn type="integer">3</cn>
     </apply>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y^{2}=x^{3}+x+1
  </annotation>
 </semantics>
</math>

 you get 

<math display="inline" id="Counting_points_on_elliptic_curves:34">
 <semantics>
  <mn>4</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">4</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   4
  </annotation>
 </semantics>
</math>

 as result (2nd column). This result can be achieved if 

<math display="inline" id="Counting_points_on_elliptic_curves:35">
 <semantics>
  <mrow>
   <mi>y</mi>
   <mo>=</mo>
   <mrow>
    <mo>Â±</mo>
    <mn>2</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>y</ci>
    <apply>
     <csymbol cd="latexml">plus-or-minus</csymbol>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y=\pm 2
  </annotation>
 </semantics>
</math>

. So the points for the last row are 

<math display="inline" id="Counting_points_on_elliptic_curves:36">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>4</mn>
    <mo>,</mo>
    <mn>2</mn>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>4</mn>
    <mo>,</mo>
    <mn>3</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <interval closure="open">
     <cn type="integer">4</cn>
     <cn type="integer">2</cn>
    </interval>
    <interval closure="open">
     <cn type="integer">4</cn>
     <cn type="integer">3</cn>
    </interval>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (4,2),(4,3)
  </annotation>
 </semantics>
</math>

 because 

<math display="inline" id="Counting_points_on_elliptic_curves:37">
 <semantics>
  <mn>4</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">4</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   4
  </annotation>
 </semantics>
</math>

 is fixed as it is the 

<math display="inline" id="Counting_points_on_elliptic_curves:38">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 result and 

<math display="inline" id="Counting_points_on_elliptic_curves:39">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mn>4</mn>
   <mo>,</mo>
   <mn>2</mn>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <cn type="integer">4</cn>
    <cn type="integer">2</cn>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (4,2)
  </annotation>
 </semantics>
</math>

 if 

<math display="inline" id="Counting_points_on_elliptic_curves:40">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

 is positive and 

<math display="inline" id="Counting_points_on_elliptic_curves:41">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mn>4</mn>
   <mo>,</mo>
   <mn>3</mn>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <cn type="integer">4</cn>
    <cn type="integer">3</cn>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (4,3)
  </annotation>
 </semantics>
</math>

 if 

<math display="inline" id="Counting_points_on_elliptic_curves:42">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

 is negative. Remember that 

<math display="inline" id="Counting_points_on_elliptic_curves:43">
 <semantics>
  <mrow>
   <mo>-</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   -2
  </annotation>
 </semantics>
</math>

 equals 

<math display="inline" id="Counting_points_on_elliptic_curves:44">
 <semantics>
  <mn>3</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">3</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   3
  </annotation>
 </semantics>
</math>

 over 

<math display="inline" id="Counting_points_on_elliptic_curves:45">
 <semantics>
  <msub>
   <mi>ğ”½</mi>
   <mn>5</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ğ”½</ci>
    <cn type="integer">5</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{F}_{5}
  </annotation>
 </semantics>
</math>

.</p>

<p>Therefore, 

<math display="inline" id="Counting_points_on_elliptic_curves:46">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>ğ”½</mi>
     <mn>5</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>E</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ğ”½</ci>
     <cn type="integer">5</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E(\mathbb{F}_{5})
  </annotation>
 </semantics>
</math>

 has <a class="uri" href="cardinality" title="wikilink">cardinality</a> of 9: the 8 points listed before and the point at infinity.</p>

<p>This algorithm requires running time <em>O</em>(<em>q</em>), because all the values of 

<math display="inline" id="Counting_points_on_elliptic_curves:47">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>âˆˆ</mo>
   <msub>
    <mi>ğ”½</mi>
    <mi>q</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>x</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ğ”½</ci>
     <ci>q</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\in\mathbb{F}_{q}
  </annotation>
 </semantics>
</math>

 must be considered.</p>
<h2 id="baby-step-giant-step">Baby-step giant-step</h2>

<p>An improvement in running time is obtained using a different approach: we pick an element 

<math display="inline" id="Counting_points_on_elliptic_curves:48">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>âˆˆ</mo>
   <mrow>
    <mi>E</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>ğ”½</mi>
      <mi>q</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>P</ci>
     <interval closure="open">
      <ci>x</ci>
      <ci>y</ci>
     </interval>
    </apply>
    <apply>
     <in></in>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>E</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ğ”½</ci>
       <ci>q</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P=(x,y)\in E(\mathbb{F}_{q})
  </annotation>
 </semantics>
</math>

 by selecting random values of 

<math display="inline" id="Counting_points_on_elliptic_curves:49">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 until 

<math display="inline" id="Counting_points_on_elliptic_curves:50">
 <semantics>
  <mrow>
   <msup>
    <mi>x</mi>
    <mn>3</mn>
   </msup>
   <mo>+</mo>
   <mrow>
    <mi>A</mi>
    <mi>x</mi>
   </mrow>
   <mo>+</mo>
   <mi>B</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <cn type="integer">3</cn>
    </apply>
    <apply>
     <times></times>
     <ci>A</ci>
     <ci>x</ci>
    </apply>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{3}+Ax+B
  </annotation>
 </semantics>
</math>

 is a square in 

<math display="inline" id="Counting_points_on_elliptic_curves:51">
 <semantics>
  <msub>
   <mi>ğ”½</mi>
   <mi>q</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ğ”½</ci>
    <ci>q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{F}_{q}
  </annotation>
 </semantics>
</math>

 and then computing the square root of this value in order to get 

<math display="inline" id="Counting_points_on_elliptic_curves:52">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

. Hasse's theorem tells us that 

<math display="inline" id="Counting_points_on_elliptic_curves:53">
 <semantics>
  <mrow>
   <mo stretchy="false">|</mo>
   <mrow>
    <mi>E</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>ğ”½</mi>
      <mi>q</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo stretchy="false">|</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <abs></abs>
    <apply>
     <times></times>
     <ci>E</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ğ”½</ci>
      <ci>q</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |E(\mathbb{F}_{q})|
  </annotation>
 </semantics>
</math>

 lies in the interval 

<math display="inline" id="Counting_points_on_elliptic_curves:54">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mrow>
     <mi>q</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mn>2</mn>
     <msqrt>
      <mi>q</mi>
     </msqrt>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>q</mi>
    <mo>+</mo>
    <mn>1</mn>
    <mo>+</mo>
    <mrow>
     <mn>2</mn>
     <msqrt>
      <mi>q</mi>
     </msqrt>
    </mrow>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <apply>
     <minus></minus>
     <apply>
      <plus></plus>
      <ci>q</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <apply>
       <root></root>
       <ci>q</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <ci>q</ci>
     <cn type="integer">1</cn>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <apply>
       <root></root>
       <ci>q</ci>
      </apply>
     </apply>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (q+1-2\sqrt{q},q+1+2\sqrt{q})
  </annotation>
 </semantics>
</math>

. Thus, by <a href="Lagrange's_theorem_(group_theory)" title="wikilink">Lagrange's theorem</a>, finding a unique 

<math display="inline" id="Counting_points_on_elliptic_curves:55">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 lying in this interval and satisfying 

<math display="inline" id="Counting_points_on_elliptic_curves:56">
 <semantics>
  <mrow>
   <mrow>
    <mi>M</mi>
    <mi>P</mi>
   </mrow>
   <mo>=</mo>
   <mi>O</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>M</ci>
     <ci>P</ci>
    </apply>
    <ci>O</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   MP=O
  </annotation>
 </semantics>
</math>

, results in finding the cardinality of 

<math display="inline" id="Counting_points_on_elliptic_curves:57">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>ğ”½</mi>
     <mi>q</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>E</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ğ”½</ci>
     <ci>q</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E(\mathbb{F}_{q})
  </annotation>
 </semantics>
</math>

. The algorithm fails if there exist two integers 

<math display="inline" id="Counting_points_on_elliptic_curves:58">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Counting_points_on_elliptic_curves:59">
 <semantics>
  <msup>
   <mi>M</mi>
   <mo>â€²</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>M</ci>
    <ci>normal-â€²</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M^{\prime}
  </annotation>
 </semantics>
</math>

 in the interval such that 

<math display="inline" id="Counting_points_on_elliptic_curves:60">
 <semantics>
  <mrow>
   <mrow>
    <mi>M</mi>
    <mi>P</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>M</mi>
     <mo>â€²</mo>
    </msup>
    <mi>P</mi>
   </mrow>
   <mo>=</mo>
   <mi>O</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>M</ci>
      <ci>P</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>M</ci>
       <ci>normal-â€²</ci>
      </apply>
      <ci>P</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <ci>O</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   MP=M^{\prime}P=O
  </annotation>
 </semantics>
</math>

. In such a case it usually suffices to repeat the algorithm with another randomly chosen point in 

<math display="inline" id="Counting_points_on_elliptic_curves:61">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>ğ”½</mi>
     <mi>q</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>E</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ğ”½</ci>
     <ci>q</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E(\mathbb{F}_{q})
  </annotation>
 </semantics>
</math>

.</p>

<p>Trying all values of 

<math display="inline" id="Counting_points_on_elliptic_curves:62">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 in order to find the one that satisfies 

<math display="inline" id="Counting_points_on_elliptic_curves:63">
 <semantics>
  <mrow>
   <mrow>
    <mi>M</mi>
    <mi>P</mi>
   </mrow>
   <mo>=</mo>
   <mi>O</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>M</ci>
     <ci>P</ci>
    </apply>
    <ci>O</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   MP=O
  </annotation>
 </semantics>
</math>

 takes around 

<math display="inline" id="Counting_points_on_elliptic_curves:64">
 <semantics>
  <mrow>
   <mn>4</mn>
   <msqrt>
    <mi>q</mi>
   </msqrt>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <cn type="integer">4</cn>
    <apply>
     <root></root>
     <ci>q</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   4\sqrt{q}
  </annotation>
 </semantics>
</math>

 steps.</p>

<p>However, by applying the <a href="baby-step_giant-step" title="wikilink">baby-step giant-step</a> algorithm to 

<math display="inline" id="Counting_points_on_elliptic_curves:65">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>ğ”½</mi>
     <mi>q</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>E</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ğ”½</ci>
     <ci>q</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E(\mathbb{F}_{q})
  </annotation>
 </semantics>
</math>

, we are able to speed this up to around 

<math display="inline" id="Counting_points_on_elliptic_curves:66">
 <semantics>
  <mrow>
   <mn>4</mn>
   <mroot>
    <mi>q</mi>
    <mn>4</mn>
   </mroot>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <cn type="integer">4</cn>
    <apply>
     <root></root>
     <degree>
      <cn type="integer">4</cn>
     </degree>
     <ci>q</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   4\sqrt[4]{q}
  </annotation>
 </semantics>
</math>

 steps. The algorithm is as follows.</p>
<h3 id="the-algorithm">The algorithm</h3>

<p><code>1.Â chooseÂ </code>

<math display="inline" id="Counting_points_on_elliptic_curves:67">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

<code>Â integer,Â </code>

<math display="inline" id="Counting_points_on_elliptic_curves:68">
 <semantics>
  <mrow>
   <mi>m</mi>
   <mo>></mo>
   <mroot>
    <mi>q</mi>
    <mn>4</mn>
   </mroot>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <ci>m</ci>
    <apply>
     <root></root>
     <degree>
      <cn type="integer">4</cn>
     </degree>
     <ci>q</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m>\sqrt[4]{q}
  </annotation>
 </semantics>
</math>

<br/>
<code>2.Â </code><strong><code>FOR</code></strong><code>{</code>

<math display="inline" id="Counting_points_on_elliptic_curves:69">
 <semantics>
  <mrow>
   <mi>j</mi>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>j</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   j=0
  </annotation>
 </semantics>
</math>

<code>Â toÂ </code>

<math display="inline" id="Counting_points_on_elliptic_curves:70">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

<code>}Â </code><strong><code>DO</code></strong><code>Â </code><br/>
<code>3.Â Â Â Â </code>

<math display="inline" id="Counting_points_on_elliptic_curves:71">
 <semantics>
  <mrow>
   <msub>
    <mi>P</mi>
    <mi>j</mi>
   </msub>
   <mo>â†</mo>
   <mrow>
    <mi>j</mi>
    <mi>P</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-â†</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>P</ci>
     <ci>j</ci>
    </apply>
    <apply>
     <times></times>
     <ci>j</ci>
     <ci>P</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{j}\leftarrow jP
  </annotation>
 </semantics>
</math>

<br/>
<code>4.Â </code><strong><code>ENDFOR</code></strong><br/>
<code>5.Â </code>

<math display="inline" id="Counting_points_on_elliptic_curves:72">
 <semantics>
  <mrow>
   <mi>L</mi>
   <mo>â†</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-â†</ci>
    <ci>L</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L\leftarrow 1
  </annotation>
 </semantics>
</math>

<br/>
<code>6.Â </code>

<math display="inline" id="Counting_points_on_elliptic_curves:73">
 <semantics>
  <mrow>
   <mi>Q</mi>
   <mo>â†</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>q</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>P</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-â†</ci>
    <ci>Q</ci>
    <apply>
     <times></times>
     <apply>
      <plus></plus>
      <ci>q</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>P</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q\leftarrow(q+1)P
  </annotation>
 </semantics>
</math>

<br/>
<code>7.Â </code><strong><code>REPEAT</code></strong><code>Â computeÂ theÂ pointsÂ </code>

<math display="inline" id="Counting_points_on_elliptic_curves:74">
 <semantics>
  <mrow>
   <mi>Q</mi>
   <mo>+</mo>
   <mrow>
    <mi>k</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mn>2</mn>
      <mi>m</mi>
      <mi>P</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>Q</ci>
    <apply>
     <times></times>
     <ci>k</ci>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <ci>m</ci>
      <ci>P</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q+k(2mP)
  </annotation>
 </semantics>
</math>

<br/>
<code>8.Â </code><strong><code>UNTIL</code></strong><code>Â </code>

<math display="inline" id="Counting_points_on_elliptic_curves:75">
 <semantics>
  <mrow>
   <mo>âˆƒ</mo>
   <mi>j</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <exists></exists>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \exists j
  </annotation>
 </semantics>
</math>



<math display="block" id="Counting_points_on_elliptic_curves:76">
 <semantics>
  <mrow>
   <mrow>
    <mi>Q</mi>
    <mo>+</mo>
    <mrow>
     <mi>k</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mn>2</mn>
       <mi>m</mi>
       <mi>P</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>Â±</mo>
    <msub>
     <mi>P</mi>
     <mi>j</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <ci>Q</ci>
     <apply>
      <times></times>
      <ci>k</ci>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>m</ci>
       <ci>P</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">plus-or-minus</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>P</ci>
      <ci>j</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q+k(2mP)=\pm P_{j}
  </annotation>
 </semantics>
</math>

<code>Â Â \\theÂ </code>

<math display="inline" id="Counting_points_on_elliptic_curves:77">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

<code>-coordinatesÂ areÂ compared</code><br/>
<code>9.Â </code>

<math display="inline" id="Counting_points_on_elliptic_curves:78">
 <semantics>
  <mrow>
   <mi>M</mi>
   <mo>â†</mo>
   <mrow>
    <mrow>
     <mi>q</mi>
     <mo>+</mo>
     <mn>1</mn>
     <mo>+</mo>
     <mrow>
      <mn>2</mn>
      <mi>m</mi>
      <mi>k</mi>
     </mrow>
    </mrow>
    <mo>âˆ“</mo>
    <mi>j</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-â†</ci>
    <ci>M</ci>
    <apply>
     <csymbol cd="latexml">minus-or-plus</csymbol>
     <apply>
      <plus></plus>
      <ci>q</ci>
      <cn type="integer">1</cn>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>m</ci>
       <ci>k</ci>
      </apply>
     </apply>
     <ci>j</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M\leftarrow q+1+2mk\mp j
  </annotation>
 </semantics>
</math>

<code>Â Â Â Â Â \\noteÂ </code>

<math display="inline" id="Counting_points_on_elliptic_curves:79">
 <semantics>
  <mrow>
   <mrow>
    <mi>M</mi>
    <mi>P</mi>
   </mrow>
   <mo>=</mo>
   <mi>O</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>M</ci>
     <ci>P</ci>
    </apply>
    <ci>O</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   MP=O
  </annotation>
 </semantics>
</math>

<br/>
<code>10.Â FactorÂ </code>

<math display="inline" id="Counting_points_on_elliptic_curves:80">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

<code>.Â LetÂ </code>

<math display="inline" id="Counting_points_on_elliptic_curves:81">
 <semantics>
  <mrow>
   <msub>
    <mi>p</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">â€¦</mi>
   <mo>,</mo>
   <msub>
    <mi>p</mi>
    <mi>r</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>p</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-â€¦</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>p</ci>
     <ci>r</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{1},\ldots,p_{r}
  </annotation>
 </semantics>
</math>

<code>Â beÂ theÂ distinctÂ primeÂ factorsÂ ofÂ </code>

<math display="inline" id="Counting_points_on_elliptic_curves:82">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

<code>.</code><br/>
<code>11.Â </code><strong><code>WHILE</code></strong><code>Â </code>

<math display="inline" id="Counting_points_on_elliptic_curves:83">
 <semantics>
  <mrow>
   <mi>i</mi>
   <mo>â‰¤</mo>
   <mi>r</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <ci>i</ci>
    <ci>r</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i\leq r
  </annotation>
 </semantics>
</math>

<code>Â </code><strong><code>DO</code></strong><br/>
<code>12.Â Â Â Â </code><strong><code>IF</code></strong><code>Â </code>

<math display="inline" id="Counting_points_on_elliptic_curves:84">
 <semantics>
  <mrow>
   <mrow>
    <mfrac>
     <mi>M</mi>
     <msub>
      <mi>p</mi>
      <mi>i</mi>
     </msub>
    </mfrac>
    <mi>P</mi>
   </mrow>
   <mo>=</mo>
   <mi>O</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <ci>M</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <ci>i</ci>
      </apply>
     </apply>
     <ci>P</ci>
    </apply>
    <ci>O</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{M}{p_{i}}P=O
  </annotation>
 </semantics>
</math>

<br/>
<code>13.Â Â Â Â Â Â Â </code><strong><code>THEN</code></strong><code>Â </code>

<math display="inline" id="Counting_points_on_elliptic_curves:85">
 <semantics>
  <mrow>
   <mi>M</mi>
   <mo>â†</mo>
   <mfrac>
    <mi>M</mi>
    <msub>
     <mi>p</mi>
     <mi>i</mi>
    </msub>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-â†</ci>
    <ci>M</ci>
    <apply>
     <divide></divide>
     <ci>M</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>p</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M\leftarrow\frac{M}{p_{i}}
  </annotation>
 </semantics>
</math>

<br/>
<code>14.Â Â Â Â Â Â Â </code><strong><code>ELSE</code></strong><code>Â </code>

<math display="inline" id="Counting_points_on_elliptic_curves:86">
 <semantics>
  <mrow>
   <mi>i</mi>
   <mo>â†</mo>
   <mrow>
    <mi>i</mi>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-â†</ci>
    <ci>i</ci>
    <apply>
     <plus></plus>
     <ci>i</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i\leftarrow i+1
  </annotation>
 </semantics>
</math>

<code>Â </code><br/>
<code>15.Â Â Â Â </code><strong><code>ENDIF</code></strong><br/>
<code>16.Â </code><strong><code>ENDWHILE</code></strong><br/>
<code>17.Â </code>

<math display="inline" id="Counting_points_on_elliptic_curves:87">
 <semantics>
  <mrow>
   <mi>L</mi>
   <mo>â†</mo>
   <mrow>
    <mo>lcm</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>L</mi>
     <mo>,</mo>
     <mi>M</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-â†</ci>
    <ci>L</ci>
    <apply>
     <ci>lcm</ci>
     <ci>L</ci>
     <ci>M</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L\leftarrow\operatorname{lcm}(L,M)
  </annotation>
 </semantics>
</math>

<code>Â Â Â Â Â \\noteÂ </code>

<math display="inline" id="Counting_points_on_elliptic_curves:88">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

<code>Â isÂ theÂ orderÂ ofÂ theÂ pointÂ </code>

<math display="inline" id="Counting_points_on_elliptic_curves:89">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

<br/>
<code>18.Â </code><strong><code>WHILE</code></strong><code>Â </code>

<math display="inline" id="Counting_points_on_elliptic_curves:90">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

<code>Â dividesÂ moreÂ thanÂ oneÂ integerÂ </code>

<math display="inline" id="Counting_points_on_elliptic_curves:91">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

<code>Â inÂ </code>

<math display="inline" id="Counting_points_on_elliptic_curves:92">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mrow>
     <mi>q</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mn>2</mn>
     <msqrt>
      <mi>q</mi>
     </msqrt>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>q</mi>
    <mo>+</mo>
    <mn>1</mn>
    <mo>+</mo>
    <mrow>
     <mn>2</mn>
     <msqrt>
      <mi>q</mi>
     </msqrt>
    </mrow>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <apply>
     <minus></minus>
     <apply>
      <plus></plus>
      <ci>q</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <apply>
       <root></root>
       <ci>q</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <ci>q</ci>
     <cn type="integer">1</cn>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <apply>
       <root></root>
       <ci>q</ci>
      </apply>
     </apply>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (q+1-2\sqrt{q},q+1+2\sqrt{q})
  </annotation>
 </semantics>
</math>

<br/>
<code>19.Â Â Â Â </code><strong><code>DO</code></strong><code>Â chooseÂ aÂ newÂ pointÂ </code>

<math display="inline" id="Counting_points_on_elliptic_curves:93">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

<code>Â andÂ goÂ toÂ 1.</code><br/>
<code>20.Â </code><strong><code>ENDWHILE</code></strong><br/>
<code>21.Â </code><strong><code>RETURN</code></strong><code>Â </code>

<math display="inline" id="Counting_points_on_elliptic_curves:94">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

<code>Â Â Â Â Â \\itÂ isÂ theÂ cardinalityÂ ofÂ </code>

<math display="inline" id="Counting_points_on_elliptic_curves:95">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>ğ”½</mi>
     <mi>q</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>E</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ğ”½</ci>
     <ci>q</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E(\mathbb{F}_{q})
  </annotation>
 </semantics>
</math>

</p>
<h3 id="notes-to-the-algorithm">Notes to the algorithm</h3>
<ul>
<li>In line 8. we assume the existence of a match. Indeed, the following lemma assures that such a match exists:</li>
</ul>
<dl>
<dd><dl>
<dd>Let 

<math display="inline" id="Counting_points_on_elliptic_curves:96">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 be an integer with 

<math display="inline" id="Counting_points_on_elliptic_curves:97">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">|</mo>
    <mi>a</mi>
    <mo stretchy="false">|</mo>
   </mrow>
   <mo>â‰¤</mo>
   <mrow>
    <mn>2</mn>
    <msup>
     <mi>m</mi>
     <mn>2</mn>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <abs></abs>
     <ci>a</ci>
    </apply>
    <apply>
     <times></times>
     <cn type="integer">2</cn>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>m</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |a|\leq 2m^{2}
  </annotation>
 </semantics>
</math>

. There exist integers 

<math display="inline" id="Counting_points_on_elliptic_curves:98">
 <semantics>
  <msub>
   <mi>a</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>a</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{0}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Counting_points_on_elliptic_curves:99">
 <semantics>
  <msub>
   <mi>a</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>a</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{1}
  </annotation>
 </semantics>
</math>

 with
</dd>
<dd><math>
</math></dd>
</dl>
</dd>
</dl>

<p>-m </p>
<ul>
<li>Computing 

<math display="inline" id="Counting_points_on_elliptic_curves:100">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>j</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi>P</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <plus></plus>
     <ci>j</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (j+1)P
  </annotation>
 </semantics>
</math>

 once 

<math display="inline" id="Counting_points_on_elliptic_curves:101">
 <semantics>
  <mrow>
   <mi>j</mi>
   <mi>P</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>j</ci>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   jP
  </annotation>
 </semantics>
</math>

 has been computed can be done by adding 

<math display="inline" id="Counting_points_on_elliptic_curves:102">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Counting_points_on_elliptic_curves:103">
 <semantics>
  <mrow>
   <mi>j</mi>
   <mi>P</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>j</ci>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   jP
  </annotation>
 </semantics>
</math>

 instead of computing the complete scalar multiplication anew. The complete computation thus requires 

<math display="inline" id="Counting_points_on_elliptic_curves:104">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

 additions. 

<math display="inline" id="Counting_points_on_elliptic_curves:105">
 <semantics>
  <mrow>
   <mn>2</mn>
   <mi>m</mi>
   <mi>P</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <cn type="integer">2</cn>
    <ci>m</ci>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2mP
  </annotation>
 </semantics>
</math>

 can be obtained with one doubling from 

<math display="inline" id="Counting_points_on_elliptic_curves:106">
 <semantics>
  <mrow>
   <mi>m</mi>
   <mi>P</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>m</ci>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   mP
  </annotation>
 </semantics>
</math>

. The computation of 

<math display="inline" id="Counting_points_on_elliptic_curves:107">
 <semantics>
  <mi>Q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q
  </annotation>
 </semantics>
</math>

 requires 

<math display="inline" id="Counting_points_on_elliptic_curves:108">
 <semantics>
  <mrow>
   <mi>log</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>q</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <log></log>
    <apply>
     <plus></plus>
     <ci>q</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \log(q+1)
  </annotation>
 </semantics>
</math>

 doublings and 

<math display="inline" id="Counting_points_on_elliptic_curves:109">
 <semantics>
  <mi>w</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>w</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w
  </annotation>
 </semantics>
</math>

 additions, where 

<math display="inline" id="Counting_points_on_elliptic_curves:110">
 <semantics>
  <mi>w</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>w</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w
  </annotation>
 </semantics>
</math>

 is the number of nonzero digits in the binary representation of 

<math display="inline" id="Counting_points_on_elliptic_curves:111">
 <semantics>
  <mrow>
   <mi>q</mi>
   <mo>+</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>q</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q+1
  </annotation>
 </semantics>
</math>

; note that knowledge of the 

<math display="inline" id="Counting_points_on_elliptic_curves:112">
 <semantics>
  <mrow>
   <mi>j</mi>
   <mi>P</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>j</ci>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   jP
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Counting_points_on_elliptic_curves:113">
 <semantics>
  <mrow>
   <mn>2</mn>
   <mi>m</mi>
   <mi>P</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <cn type="integer">2</cn>
    <ci>m</ci>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2mP
  </annotation>
 </semantics>
</math>

 allows us to reduce the number of doublings. Finally, to get from 

<math display="inline" id="Counting_points_on_elliptic_curves:114">
 <semantics>
  <mrow>
   <mi>Q</mi>
   <mo>+</mo>
   <mrow>
    <mi>k</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mn>2</mn>
      <mi>m</mi>
      <mi>P</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>Q</ci>
    <apply>
     <times></times>
     <ci>k</ci>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <ci>m</ci>
      <ci>P</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q+k(2mP)
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Counting_points_on_elliptic_curves:115">
 <semantics>
  <mrow>
   <mi>Q</mi>
   <mo>+</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>k</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mn>2</mn>
      <mi>m</mi>
      <mi>P</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>Q</ci>
    <apply>
     <times></times>
     <apply>
      <plus></plus>
      <ci>k</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <ci>m</ci>
      <ci>P</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q+(k+1)(2mP)
  </annotation>
 </semantics>
</math>

, simply add 

<math display="inline" id="Counting_points_on_elliptic_curves:116">
 <semantics>
  <mrow>
   <mn>2</mn>
   <mi>m</mi>
   <mi>P</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <cn type="integer">2</cn>
    <ci>m</ci>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2mP
  </annotation>
 </semantics>
</math>

 rather than recomputing everything.</li>
</ul>
<ul>
<li>We are assuming that we can factor 

<math display="inline" id="Counting_points_on_elliptic_curves:117">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

. If not, we can at least find all the small prime factors 

<math display="inline" id="Counting_points_on_elliptic_curves:118">
 <semantics>
  <msub>
   <mi>p</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>p</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{i}
  </annotation>
 </semantics>
</math>

 and check that 

<math display="inline" id="Counting_points_on_elliptic_curves:119">
 <semantics>
  <mrow>
   <mfrac>
    <mi>M</mi>
    <msub>
     <mi>p</mi>
     <mi>i</mi>
    </msub>
   </mfrac>
   <mo>â‰ </mo>
   <mi>O</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <neq></neq>
    <apply>
     <divide></divide>
     <ci>M</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>p</ci>
      <ci>i</ci>
     </apply>
    </apply>
    <ci>O</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{M}{p_{i}}\neq O
  </annotation>
 </semantics>
</math>

 for these. Then 

<math display="inline" id="Counting_points_on_elliptic_curves:120">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 will be a good candidate for the <a href="Order_(group_theory)" title="wikilink">order</a> of 

<math display="inline" id="Counting_points_on_elliptic_curves:121">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

.</li>
</ul>
<ul>
<li>The conclusion of step 17 can be proved using elementary group theory: since 

<math display="inline" id="Counting_points_on_elliptic_curves:122">
 <semantics>
  <mrow>
   <mrow>
    <mi>M</mi>
    <mi>P</mi>
   </mrow>
   <mo>=</mo>
   <mi>O</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>M</ci>
     <ci>P</ci>
    </apply>
    <ci>O</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   MP=O
  </annotation>
 </semantics>
</math>

, the order of 

<math display="inline" id="Counting_points_on_elliptic_curves:123">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 divides 

<math display="inline" id="Counting_points_on_elliptic_curves:124">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

. If no proper divisor 

<math display="inline" id="Counting_points_on_elliptic_curves:125">
 <semantics>
  <mover accent="true">
   <mi>M</mi>
   <mo stretchy="false">Â¯</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-Â¯</ci>
    <ci>M</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bar{M}
  </annotation>
 </semantics>
</math>

 of 

<math display="inline" id="Counting_points_on_elliptic_curves:126">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 realizes 

<math display="inline" id="Counting_points_on_elliptic_curves:127">
 <semantics>
  <mrow>
   <mrow>
    <mover accent="true">
     <mi>M</mi>
     <mo stretchy="false">Â¯</mo>
    </mover>
    <mi>P</mi>
   </mrow>
   <mo>=</mo>
   <mi>O</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <ci>normal-Â¯</ci>
      <ci>M</ci>
     </apply>
     <ci>P</ci>
    </apply>
    <ci>O</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bar{M}P=O
  </annotation>
 </semantics>
</math>

, then 

<math display="inline" id="Counting_points_on_elliptic_curves:128">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 is the order of 

<math display="inline" id="Counting_points_on_elliptic_curves:129">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

.</li>
</ul>

<p>One drawback of this method is that there is a need for too much memory when the group becomes large. In order to address this, it might be more efficient to store only the 

<math display="inline" id="Counting_points_on_elliptic_curves:130">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 coordinates of the points 

<math display="inline" id="Counting_points_on_elliptic_curves:131">
 <semantics>
  <mrow>
   <mi>j</mi>
   <mi>P</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>j</ci>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   jP
  </annotation>
 </semantics>
</math>

 (along with the corresponding integer 

<math display="inline" id="Counting_points_on_elliptic_curves:132">
 <semantics>
  <mi>j</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>j</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   j
  </annotation>
 </semantics>
</math>

). However, this leads to an extra scalar multiplication in order to choose between 

<math display="inline" id="Counting_points_on_elliptic_curves:133">
 <semantics>
  <mrow>
   <mo>-</mo>
   <mi>j</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   -j
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Counting_points_on_elliptic_curves:134">
 <semantics>
  <mrow>
   <mo>+</mo>
   <mi>j</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   +j
  </annotation>
 </semantics>
</math>

.</p>

<p>There are other generic algorithms for computing the order of a group element that are more space efficient, such as <a href="Pollard's_rho_algorithm_for_logarithms" title="wikilink">Pollard's rho algorithm</a> and the <a href="Pollard_kangaroo" title="wikilink">Pollard kangaroo</a> method. The Pollard kangaroo method allows one to search for a solution in a prescribed interval, yielding a running time of 

<math display="inline" id="Counting_points_on_elliptic_curves:135">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mroot>
     <mi>q</mi>
     <mn>4</mn>
    </mroot>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <root></root>
     <degree>
      <cn type="integer">4</cn>
     </degree>
     <ci>q</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(\sqrt[4]{q})
  </annotation>
 </semantics>
</math>

, using 

<math display="inline" id="Counting_points_on_elliptic_curves:136">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msup>
      <mi>log</mi>
      <mn>2</mn>
     </msup>
     <mi>q</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <log></log>
      <cn type="integer">2</cn>
     </apply>
     <ci>q</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(\log^{2}{q})
  </annotation>
 </semantics>
</math>

 space.</p>
<h2 id="schoofs-algorithm">Schoof's algorithm</h2>

<p>A theoretical breakthrough for the problem of computing the cardinality of groups of the type 

<math display="inline" id="Counting_points_on_elliptic_curves:137">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>ğ”½</mi>
     <mi>q</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>E</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ğ”½</ci>
     <ci>q</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E(\mathbb{F}_{q})
  </annotation>
 </semantics>
</math>

 was achieved by RenÃ© Schoof, who, in 1985, published the first deterministic polynomial time algorithm. Central to Schoof's algorithm are the use of <a href="division_polynomial" title="wikilink">division polynomials</a> and <a href="Hasse's_theorem_on_elliptic_curves" title="wikilink">Hasse's theorem</a>, along with the <a href="Chinese_remainder_theorem" title="wikilink">Chinese remainder theorem</a>.</p>

<p>Schoof's insight exploits the fact that, by Hasse's theorem, there is a finite range of possible values for 

<math display="inline" id="Counting_points_on_elliptic_curves:138">
 <semantics>
  <mrow>
   <mo stretchy="false">|</mo>
   <mrow>
    <mi>E</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>ğ”½</mi>
      <mi>q</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo stretchy="false">|</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <abs></abs>
    <apply>
     <times></times>
     <ci>E</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ğ”½</ci>
      <ci>q</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |E(\mathbb{F}_{q})|
  </annotation>
 </semantics>
</math>

. It suffices to compute 

<math display="inline" id="Counting_points_on_elliptic_curves:139">
 <semantics>
  <mrow>
   <mo stretchy="false">|</mo>
   <mrow>
    <mi>E</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>ğ”½</mi>
      <mi>q</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo stretchy="false">|</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <abs></abs>
    <apply>
     <times></times>
     <ci>E</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ğ”½</ci>
      <ci>q</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |E(\mathbb{F}_{q})|
  </annotation>
 </semantics>
</math>

 modulo an integer 

<math display="inline" id="Counting_points_on_elliptic_curves:140">
 <semantics>
  <mrow>
   <mi>N</mi>
   <mo>></mo>
   <mrow>
    <mn>4</mn>
    <msqrt>
     <mi>q</mi>
    </msqrt>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <ci>N</ci>
    <apply>
     <times></times>
     <cn type="integer">4</cn>
     <apply>
      <root></root>
      <ci>q</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N>4\sqrt{q}
  </annotation>
 </semantics>
</math>

. This is achieved by computing 

<math display="inline" id="Counting_points_on_elliptic_curves:141">
 <semantics>
  <mrow>
   <mo stretchy="false">|</mo>
   <mrow>
    <mi>E</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>ğ”½</mi>
      <mi>q</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo stretchy="false">|</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <abs></abs>
    <apply>
     <times></times>
     <ci>E</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ğ”½</ci>
      <ci>q</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |E(\mathbb{F}_{q})|
  </annotation>
 </semantics>
</math>

 modulo primes 

<math display="inline" id="Counting_points_on_elliptic_curves:142">
 <semantics>
  <mrow>
   <msub>
    <mi mathvariant="normal">â„“</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">â€¦</mi>
   <mo>,</mo>
   <msub>
    <mi mathvariant="normal">â„“</mi>
    <mi>s</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-â„“</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-â€¦</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-â„“</ci>
     <ci>s</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ell_{1},\ldots,\ell_{s}
  </annotation>
 </semantics>
</math>

 whose product exceeds 

<math display="inline" id="Counting_points_on_elliptic_curves:143">
 <semantics>
  <mrow>
   <mn>4</mn>
   <msqrt>
    <mi>q</mi>
   </msqrt>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <cn type="integer">4</cn>
    <apply>
     <root></root>
     <ci>q</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   4\sqrt{q}
  </annotation>
 </semantics>
</math>

, and then applying the Chinese remainder theorem. The key to the algorithm is using the division polynomial 

<math display="inline" id="Counting_points_on_elliptic_curves:144">
 <semantics>
  <msub>
   <mi>Ïˆ</mi>
   <mi mathvariant="normal">â„“</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>Ïˆ</ci>
    <ci>normal-â„“</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \psi_{\ell}
  </annotation>
 </semantics>
</math>

 to efficiently compute 

<math display="inline" id="Counting_points_on_elliptic_curves:145">
 <semantics>
  <mrow>
   <mo stretchy="false">|</mo>
   <mrow>
    <mi>E</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>ğ”½</mi>
      <mi>q</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo stretchy="false">|</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <abs></abs>
    <apply>
     <times></times>
     <ci>E</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ğ”½</ci>
      <ci>q</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |E(\mathbb{F}_{q})|
  </annotation>
 </semantics>
</math>

 modulo 

<math display="inline" id="Counting_points_on_elliptic_curves:146">
 <semantics>
  <mi mathvariant="normal">â„“</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-â„“</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ell
  </annotation>
 </semantics>
</math>

.</p>

<p>The running time of Schoof's Algorithm is polynomial in 

<math display="inline" id="Counting_points_on_elliptic_curves:147">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>=</mo>
   <mrow>
    <mi>log</mi>
    <mi>q</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>n</ci>
    <apply>
     <log></log>
     <ci>q</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n=\log{q}
  </annotation>
 </semantics>
</math>

, with an asymptotic complexity of 

<math display="inline" id="Counting_points_on_elliptic_curves:148">
 <semantics>
  <mrow>
   <mrow>
    <mi>O</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <msup>
        <mi>n</mi>
        <mn>2</mn>
       </msup>
       <mi>M</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msup>
         <mi>n</mi>
         <mn>3</mn>
        </msup>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>/</mo>
      <mrow>
       <mi>log</mi>
       <mi>n</mi>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>O</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>n</mi>
      <mrow>
       <mn>5</mn>
       <mo>+</mo>
       <mrow>
        <mi>o</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mn>1</mn>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>O</ci>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>n</ci>
        <cn type="integer">2</cn>
       </apply>
       <ci>M</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>n</ci>
        <cn type="integer">3</cn>
       </apply>
      </apply>
      <apply>
       <log></log>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>O</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>n</ci>
      <apply>
       <plus></plus>
       <cn type="integer">5</cn>
       <apply>
        <times></times>
        <ci>o</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n^{2}M(n^{3})/\log{n})=O(n^{5+o(1)})
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Counting_points_on_elliptic_curves:149">
 <semantics>
  <mrow>
   <mi>M</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>M</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M(n)
  </annotation>
 </semantics>
</math>

 denotes the <a href="Computational_complexity_of_mathematical_operations" title="wikilink">complexity of integer multiplication</a>. Its space complexity is 

<math display="inline" id="Counting_points_on_elliptic_curves:150">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>n</mi>
     <mn>3</mn>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>n</ci>
     <cn type="integer">3</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n^{3})
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="schoofelkiesatkin-algorithm">Schoofâ€“Elkiesâ€“Atkin algorithm</h2>

<p>In the 1990s, <a href="Noam_Elkies" title="wikilink">Noam Elkies</a>, followed by <a href="A._O._L._Atkin" title="wikilink">A. O. L. Atkin</a> devised improvements to Schoof's basic algorithm by making a distinction among the primes 

<math display="inline" id="Counting_points_on_elliptic_curves:151">
 <semantics>
  <mrow>
   <msub>
    <mi mathvariant="normal">â„“</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">â€¦</mi>
   <mo>,</mo>
   <msub>
    <mi mathvariant="normal">â„“</mi>
    <mi>s</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-â„“</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-â€¦</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-â„“</ci>
     <ci>s</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ell_{1},\ldots,\ell_{s}
  </annotation>
 </semantics>
</math>

 that are used. A prime 

<math display="inline" id="Counting_points_on_elliptic_curves:152">
 <semantics>
  <mi mathvariant="normal">â„“</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-â„“</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ell
  </annotation>
 </semantics>
</math>

 is called an Elkies prime if the characteristic equation of the Frobenius endomorphism, 

<math display="inline" id="Counting_points_on_elliptic_curves:153">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msup>
      <mi>Ï•</mi>
      <mn>2</mn>
     </msup>
     <mo>-</mo>
     <mrow>
      <mi>t</mi>
      <mi>Ï•</mi>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mi>q</mi>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>Ï•</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <times></times>
       <ci>t</ci>
       <ci>Ï•</ci>
      </apply>
     </apply>
     <ci>q</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi^{2}-t\phi+q=0
  </annotation>
 </semantics>
</math>

, splits over 

<math display="inline" id="Counting_points_on_elliptic_curves:154">
 <semantics>
  <msub>
   <mi>ğ”½</mi>
   <mi mathvariant="normal">â„“</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ğ”½</ci>
    <ci>normal-â„“</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{F}_{\ell}
  </annotation>
 </semantics>
</math>

. Otherwise 

<math display="inline" id="Counting_points_on_elliptic_curves:155">
 <semantics>
  <mi mathvariant="normal">â„“</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-â„“</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ell
  </annotation>
 </semantics>
</math>

 is called an Atkin prime. Elkies primes are the key to improving the asymptotic complexity of Schoof's algorithm. Information obtained from the Atkin primes permits a further improvement which is asymptotically negligible but can be quite important in practice. The modification of Schoof's algorithm to use Elkies and Atkin primes is known as the Schoofâ€“Elkiesâ€“Atkin (SEA) algorithm.</p>

<p>The status of a particular prime 

<math display="inline" id="Counting_points_on_elliptic_curves:156">
 <semantics>
  <mi mathvariant="normal">â„“</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-â„“</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ell
  </annotation>
 </semantics>
</math>

 depends on the elliptic curve 

<math display="inline" id="Counting_points_on_elliptic_curves:157">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mo>/</mo>
   <msub>
    <mi>ğ”½</mi>
    <mi>q</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <ci>E</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ğ”½</ci>
     <ci>q</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E/\mathbb{F}_{q}
  </annotation>
 </semantics>
</math>

, and can be determined using the <a href="Classical_modular_curve" title="wikilink">modular polynomial</a> 

<math display="inline" id="Counting_points_on_elliptic_curves:158">
 <semantics>
  <mrow>
   <msub>
    <mi mathvariant="normal">Î¨</mi>
    <mi mathvariant="normal">â„“</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo>,</mo>
    <mi>Y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-Î¨</ci>
     <ci>normal-â„“</ci>
    </apply>
    <interval closure="open">
     <ci>X</ci>
     <ci>Y</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Psi_{\ell}(X,Y)
  </annotation>
 </semantics>
</math>

. If the univariate polynomial 

<math display="inline" id="Counting_points_on_elliptic_curves:159">
 <semantics>
  <mrow>
   <msub>
    <mi mathvariant="normal">Î¨</mi>
    <mi mathvariant="normal">â„“</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo>,</mo>
    <mrow>
     <mi>j</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>E</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-Î¨</ci>
     <ci>normal-â„“</ci>
    </apply>
    <interval closure="open">
     <ci>X</ci>
     <apply>
      <times></times>
      <ci>j</ci>
      <ci>E</ci>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Psi_{\ell}(X,j(E))
  </annotation>
 </semantics>
</math>

 has a root in 

<math display="inline" id="Counting_points_on_elliptic_curves:160">
 <semantics>
  <msub>
   <mi>ğ”½</mi>
   <mi>q</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ğ”½</ci>
    <ci>q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{F}_{q}
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Counting_points_on_elliptic_curves:161">
 <semantics>
  <mrow>
   <mi>j</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>E</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>j</ci>
    <ci>E</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   j(E)
  </annotation>
 </semantics>
</math>

 denotes the <a class="uri" href="j-invariant" title="wikilink">j-invariant</a> of 

<math display="inline" id="Counting_points_on_elliptic_curves:162">
 <semantics>
  <mi>E</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>E</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E
  </annotation>
 </semantics>
</math>

, then 

<math display="inline" id="Counting_points_on_elliptic_curves:163">
 <semantics>
  <mi mathvariant="normal">â„“</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-â„“</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ell
  </annotation>
 </semantics>
</math>

 is an Elkies prime, and otherwise it is an Atkin prime. In the Elkies case, further computations involving modular polynomials are used to obtain a proper factor of the division polynomial 

<math display="inline" id="Counting_points_on_elliptic_curves:164">
 <semantics>
  <msub>
   <mi>Ïˆ</mi>
   <mi mathvariant="normal">â„“</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>Ïˆ</ci>
    <ci>normal-â„“</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \psi_{\ell}
  </annotation>
 </semantics>
</math>

. The degree of this factor is 

<math display="inline" id="Counting_points_on_elliptic_curves:165">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi mathvariant="normal">â„“</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <ci>normal-â„“</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(\ell)
  </annotation>
 </semantics>
</math>

, whereas 

<math display="inline" id="Counting_points_on_elliptic_curves:166">
 <semantics>
  <msub>
   <mi>Ïˆ</mi>
   <mi mathvariant="normal">â„“</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>Ïˆ</ci>
    <ci>normal-â„“</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \psi_{\ell}
  </annotation>
 </semantics>
</math>

 has degree 

<math display="inline" id="Counting_points_on_elliptic_curves:167">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi mathvariant="normal">â„“</mi>
     <mn>2</mn>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-â„“</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(\ell^{2})
  </annotation>
 </semantics>
</math>

.</p>

<p>Unlike Schoof's algorithm, the SEA algorithm is typically implemented as a <a href="Randomized_algorithm" title="wikilink">probabilistic algorithm</a> (of the <a href="Las_Vegas_algorithm" title="wikilink">Las Vegas</a> type), so that root-finding and other operations can be performed more efficiently. Its computational complexity is dominated by the cost of computing the modular polynomials 

<math display="inline" id="Counting_points_on_elliptic_curves:168">
 <semantics>
  <mrow>
   <msub>
    <mi mathvariant="normal">Î¨</mi>
    <mi mathvariant="normal">â„“</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo>,</mo>
    <mi>Y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-Î¨</ci>
     <ci>normal-â„“</ci>
    </apply>
    <interval closure="open">
     <ci>X</ci>
     <ci>Y</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Psi_{\ell}(X,Y)
  </annotation>
 </semantics>
</math>

, but as these do not depend on 

<math display="inline" id="Counting_points_on_elliptic_curves:169">
 <semantics>
  <mi>E</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>E</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E
  </annotation>
 </semantics>
</math>

, they may be computed once and reused. Under the heuristic assumption that there are sufficiently many small Elkies primes, and excluding the cost of computing modular polynomials, the asymptotic running time of the SEA algorithm is 

<math display="inline" id="Counting_points_on_elliptic_curves:170">
 <semantics>
  <mrow>
   <mrow>
    <mi>O</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <msup>
        <mi>n</mi>
        <mn>2</mn>
       </msup>
       <mi>M</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msup>
         <mi>n</mi>
         <mn>2</mn>
        </msup>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>/</mo>
      <mrow>
       <mi>log</mi>
       <mi>n</mi>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>O</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>n</mi>
      <mrow>
       <mn>4</mn>
       <mo>+</mo>
       <mrow>
        <mi>o</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mn>1</mn>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>O</ci>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>n</ci>
        <cn type="integer">2</cn>
       </apply>
       <ci>M</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>n</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <apply>
       <log></log>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>O</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>n</ci>
      <apply>
       <plus></plus>
       <cn type="integer">4</cn>
       <apply>
        <times></times>
        <ci>o</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n^{2}M(n^{2})/\log{n})=O(n^{4+o(1)})
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Counting_points_on_elliptic_curves:171">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>=</mo>
   <mrow>
    <mi>log</mi>
    <mi>q</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>n</ci>
    <apply>
     <log></log>
     <ci>q</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n=\log{q}
  </annotation>
 </semantics>
</math>

. Its space complexity is 

<math display="inline" id="Counting_points_on_elliptic_curves:172">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msup>
      <mi>n</mi>
      <mn>3</mn>
     </msup>
     <mrow>
      <mi>log</mi>
      <mi>n</mi>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>n</ci>
      <cn type="integer">3</cn>
     </apply>
     <apply>
      <log></log>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n^{3}\log{n})
  </annotation>
 </semantics>
</math>

, but when precomputed modular polynomials are used this increases to 

<math display="inline" id="Counting_points_on_elliptic_curves:173">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>n</mi>
     <mn>4</mn>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>n</ci>
     <cn type="integer">4</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n^{4})
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Schoof's_algorithm" title="wikilink">Schoof's algorithm</a></li>
<li><a href="Elliptic_curve_cryptography" title="wikilink">Elliptic curve cryptography</a></li>
<li><a href="Baby-step_giant-step" title="wikilink">Baby-step giant-step</a></li>
<li><a href="Public_key_cryptography" title="wikilink">Public key cryptography</a></li>
<li><a href="Schoofâ€“Elkiesâ€“Atkin_algorithm" title="wikilink">Schoofâ€“Elkiesâ€“Atkin algorithm</a></li>
<li><a href="Pollard_rho" title="wikilink">Pollard rho</a></li>
<li><a href="Pollard_kangaroo" title="wikilink">Pollard kangaroo</a></li>
<li><a href="Elliptic_curve_primality_proving" title="wikilink">Elliptic curve primality proving</a></li>
</ul>
<h2 id="bibliography">Bibliography</h2>
<ul>
<li>I. Blake, G. Seroussi, and N. Smart: <em>Elliptic Curves in Cryptography</em>, Cambridge University Press, 1999.</li>
<li>A. Enge: <em>Elliptic Curves and their Applications to Cryptography: An Introduction</em>. Kluwer Academic Publishers, Dordrecht, 1999.</li>
<li>G. Musiker: Schoof's Algorithm for Counting Points on 

<math display="inline" id="Counting_points_on_elliptic_curves:174">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>ğ”½</mi>
     <mi>q</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>E</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ğ”½</ci>
     <ci>q</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E(\mathbb{F}_{q})
  </annotation>
 </semantics>
</math>

. Available at <a class="uri" href="http://www.math.umn.edu/~musiker/schoof.pdf">http://www.math.umn.edu/~musiker/schoof.pdf</a></li>
<li>R. Schoof: Counting Points on Elliptic Curves over Finite Fields. J. Theor. Nombres Bordeaux 7:219-254, 1995. Available at <a class="uri" href="http://www.mat.uniroma2.it/~schoof/ctg.pdf">http://www.mat.uniroma2.it/~schoof/ctg.pdf</a></li>
<li>L. C. Washington: Elliptic Curves: Number Theory and Cryptography. Chapman \&amp; Hall/CRC, New York, 2003.</li>
</ul>
<h2 id="references">References</h2>
<references>
</references>

<p>"</p>

<p><a href="Category:Elliptic_curves" title="wikilink">Category:Elliptic curves</a></p>
</hr></body>
</html>
