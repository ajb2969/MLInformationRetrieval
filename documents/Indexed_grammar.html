<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1996">Indexed grammar</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Indexed grammar</h1>
<hr/>

<p><strong>Indexed grammars</strong> are a generalization of <a href="context-free_grammars" title="wikilink">context-free grammars</a> in that <a href="nonterminal" title="wikilink">nonterminals</a> are equipped with lists of <em>flags</em>, or <em>index symbols</em>. The language produced by an indexed grammar is called an <strong><a href="indexed_language" title="wikilink">indexed language</a></strong>.</p>
<h2 id="definition">Definition</h2>
<h3 id="modern-definition-by-hopcroft-and-ullman">Modern definition by Hopcroft and Ullman</h3>

<p>In contemporary publications following Hopcroft and Ullman (1979), <mtpl></mtpl> an indexed grammar is formally defined a 5-tuple <em>G</em> = ⟨<em>N</em>,<em>T</em>,<em>F</em>,<em>P</em>,<em>S</em>⟩ where</p>
<ul>
<li><em>N</em> is a set of variables or <a href="Nonterminal" title="wikilink">nonterminal symbols</a>,</li>
<li><em>T</em> is a set ("<a href="alphabet_(formal_languages)" title="wikilink">alphabet</a>") of terminal symbols,</li>
<li><em>F</em> is a set of so-called <em>index symbols</em>, or <em>indices</em>,</li>
<li><em>S</em> ∈ <em>N</em> is the <em><a href="start_symbol_(formal_languages)" title="wikilink">start symbol</a></em>, and</li>
<li><em>P</em> is a finite set of <em><a href="Production_(formal_languages)" title="wikilink">productions</a></em>.</li>
</ul>

<p>In productions as well as in derivations of indexed grammars, a string ("stack") σ ∈ <em>F</em><a href="Kleene_star" title="wikilink"><sup>*</sup></a> of index symbols is attached to every nonterminal symbol <em>A</em> ∈ <em>N</em>, denoted by <em>A</em>[σ].<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> Terminal symbols may not be followed by index stacks. For an index stack σ ∈ <em>F</em><sup>*</sup> and a string α ∈ (<em>N</em> ∪ <em>T</em>)<sup>*</sup> of nonterminal and terminal symbols, α[σ] denotes the result of attaching [σ] to every nonterminal in α; for example if α equals  with <em>a</em>,<em>d</em> ∈ <em>T</em> terminal, and <em>B</em>,<em>D</em>,<em>E</em> ∈ <em>N</em> nonterminal symbols, then α[σ] denotes  Using this notation, each production in <em>P</em> has to be of the form</p>
<ol>
<li><em>A</em>[σ] → α[σ],</li>
<li><em>A</em>[σ] → <em>B</em>[<em>f</em>σ], or</li>
<li><em>A</em>[<em>f</em>σ] → α[σ],</li>
</ol>

<p>where <em>A</em>, <em>B</em> ∈ <em>N</em> are nonterminal symbols, <em>f</em> ∈ <em>F</em> is an index, σ ∈ <em>F</em><sup>*</sup> is a string of index symbols, and α ∈ (<em>N</em> ∪ <em>T</em>)<sup>*</sup> is a string of nonterminal and terminal symbols. Some authors write ".." instead of "σ" for the index stack in production rules; the rule of type 1, 2, and 3 then reads <em>A</em>[..]→α[..],   <em>A</em>[..]→<em>B</em>[<em>f</em>..], and <em>A</em>[<em>f</em>..]→α[..], respectively.</p>

<p>Derivations are similar to those in a <a href="context-free_grammar#Rule_application" title="wikilink">context-free grammar</a> except for the index stack attached to each nonterminal symbol. When a production like e.g. <em>A</em>[σ] → <em>B</em>[σ]<em>C</em>[σ] is applied, the index stack of <em>A</em> is copied to both <em>B</em> and <em>C</em>. Moreover, a rule can push an index symbol onto the stack, or pop its "topmost" (i.e., leftmost) index symbol.</p>

<p>Formally, the relation ⇒ ("direct derivation") is defined on the set (<em>N</em>[<em>F</em><sup>*</sup>]∪<em>T</em>)<sup>*</sup> of "sentential forms" as follows:</p>
<ol>
<li>If <em>A</em>[σ] → α[σ] is a production of type 1, then β <em>A</em>[φ] γ ⇒ β α[φ] γ, using the above definition. That is, the rule's left hand side's index stack φ is copied to each nonterminal of the right hand side.</li>
<li>If <em>A</em>[σ] → <em>B</em>[<em>f</em>σ] is a production of type 2, then β <em>A</em>[φ] γ ⇒ β <em>B</em>[<em>f</em>φ] γ. That is, the right hand side's index stack is obtained from the left hand side's stack φ by pushing <em>f</em> onto it.</li>
<li>If <em>A</em>[<em>f</em>σ] → α[σ] is a production of type 3, then β <em>A</em>[<em>f</em>φ] γ ⇒ β α[φ] γ, using again the definition of α[σ]. That is, the first index <em>f</em> is popped from the left hand side's stack, which is then distributed to each nonterminal of the right hand side.</li>
</ol>

<p>As usual, the derivation relation ⇒<a href="reflexive_transitive_closure" title="wikilink"><sup>*</sup></a> is defined as the <a href="reflexive_transitive_closure" title="wikilink">reflexive transitive closure</a> of direct derivation ⇒. The language <em>L</em>(<em>G</em>) = { w ∈ <em>T</em><sup>*</sup>: <em>S</em> ⇒<sup>*</sup> w } is the set of all strings of terminal symbols derivable from the start symbol.</p>
<h3 id="original-definition-by-aho">Original definition by Aho</h3>

<p>Historically, indexed grammar were introduced by Aho (1968)<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> using a different formalism. Aho defined an indexed grammar to be a 5-tuple (<em>N</em>,<em>T</em>,<em>F</em>,<em>P</em>,<em>S</em>) where</p>
<ol>
<li><em>N</em> is a finite <a class="uri" href="alphabet" title="wikilink">alphabet</a> of variables or <a href="Nonterminal" title="wikilink">nonterminal symbols</a></li>
<li><em>T</em> is a finite alphabet of terminal symbols</li>
<li><em>F</em> ⊆ <a href="power_set" title="wikilink">2</a><sup><em>N</em> × (<em>N</em> ∪ <em>T</em>)<a href="Kleene_star" title="wikilink"><sup>*</sup></a></sup> is the finite set of so-called <em>flags</em> (each flag is itself a set of so-called <em>index productions</em>)</li>
<li><em>P</em> ⊆ <em>N</em> × (<em>NF</em><sup>*</sup> ∪ <em>T</em>)<sup>*</sup> is the finite set of <em><a href="Production_(computer_science)" title="wikilink">productions</a></em></li>
<li><em>S</em> ∈ <em>N</em> is the <em>start symbol</em></li>
</ol>

<p>Direct derivations were as follows:</p>
<ul>
<li>A production <em>p</em> = (<em>A</em> → <em>X</em><sub>1</sub>η<sub>1</sub>…<em>X</em><sub><em>k</em></sub>η<sub><em>k</em></sub>) from <em>P</em> matches a nonterminal <em>A</em> ∈ <em>N</em> followed by its (possibly empty) string of flags ζ ∈ F<sup>*</sup>. In context, γ <em>A</em>ζ δ, via <em>p</em>, derives to γ <em>X</em><sub>1</sub>θ<sub>1</sub>…<em>X</em><sub><em>k</em></sub>θ<sub><em>k</em></sub> δ, where θ<sub><em>i</em></sub> = η<sub><em>i</em></sub>ζ if <em>X</em><sub><em>i</em></sub> was a nonterminal and the empty word otherwise. The old flags of <em>A</em> are therefore <em>copied</em> to each new nonterminal produced by <em>p</em>. Each such production can be simulated by appropriate productions of type 1 and 2 in the Hopcroft/Ullman formalism.</li>
<li>An index production <em>p</em> = (<em>A</em> → <em>X</em><sub>1</sub>…<em>X</em><sub><em>k</em></sub>) ∈ <em>f</em> matches <em>Af</em>ζ (the flag <em>f</em> it comes from must match the first symbol following the nonterminal <em>A</em>) and copies the remaining index string ζ to each new nonterminal: γ <em>Af</em>ζ δ derives to γ <em>X</em><sub>1</sub>θ<sub>1</sub>…<em>X</em><sub><em>k</em></sub>θ<sub><em>k</em></sub> δ, where θ<sub><em>i</em></sub> is the empty word when <em>X</em><sub><em>i</em></sub> is a nonterminal and ζ otherwise. Each such production corresponds to a production of type 3 in the Hopcroft/Ullman formalism.</li>
</ul>

<p>This formalism is e.g. used by Hayashi (1973, p. 65-66).<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>
<h2 id="examples">Examples</h2>

<p>In practice, stacks of indices can count and remember what rules were applied and in which order. For example, indexed grammars can describe the context-sensitive language of word triples { <em>www</em> : <em>w</em> ∈ {<em>a</em>,<em>b</em>}<sup>*</sup> }:</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p><em>S</em>[σ]</p></td>
<td style="text-align: left;">
<p>→</p></td>
<td style="text-align: left;">
<p><em>S</em>[<em>f</em>σ]</p></td>
<td style="text-align: left;">
<p><em>T</em>[<em>f</em>σ]</p></td>
<td style="text-align: left;">
<p>→</p></td>
<td style="text-align: left;">
<p><em>a</em> <em>T</em>[σ]</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><em>S</em>[σ]</p></td>
<td style="text-align: left;">
<p>→</p></td>
<td style="text-align: left;">
<p><em>S</em>[<em>g</em>σ]</p></td>
<td style="text-align: left;">
<p><em>T</em>[<em>g</em>σ]</p></td>
<td style="text-align: left;">
<p>→</p></td>
<td style="text-align: left;">
<p><em>b</em> <em>T</em>[σ]</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><em>S</em>[σ]</p></td>
<td style="text-align: left;">
<p>→</p></td>
<td style="text-align: left;">
<p><em>T</em>[σ] <em>T</em>[σ] <em>T</em>[σ]      </p></td>
<td style="text-align: left;">
<p><em>T</em>[]</p></td>
<td style="text-align: left;">
<p>→</p></td>
<td style="text-align: left;">
<p>ε</p></td>
</tr>
</tbody>
</table>

<p>A derivation of <em>abbabbabb</em> is then</p>
<dl>
<dd>

<p>⇒  ⇒  ⇒  ⇒  ⇒  ⇒  ⇒  ⇒  ⇒  ⇒  ⇒  ⇒ .</p>
</dd>
</dl>

<p>As another example, the grammar <em>G</em> = ⟨ {<em>S</em>,<em>T</em>,<em>A</em>,<em>B</em>,<em>C</em>}, {<em>a</em>,<em>b</em>,<em>c</em>}, {<em>f</em>,<em>g</em>}, <em>P</em>, <em>S</em> ⟩ produces the language { <em>a</em><sup><em>n</em></sup><em>b</em><sup><em>n</em></sup><em>c</em><sup><em>n</em></sup>: <em>n</em> ≥ 1 }, where the production set <em>P</em> consists of</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p><em>S</em>[σ] → <em>T</em>[<em>g</em>σ]</p></td>
<td style="text-align: left;">
<p><em>A</em>[<em>f</em>σ] → <em>a</em> <em>A</em>[σ]</p></td>
<td style="text-align: left;">
<p><em>A</em>[<em>g</em>σ] → <em>a</em></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><em>T</em>[σ] → <em>T</em>[<em>f</em>σ]</p></td>
<td style="text-align: left;">
<p><em>B</em>[<em>f</em>σ] → <em>b</em> <em>B</em>[σ]</p></td>
<td style="text-align: left;">
<p><em>B</em>[<em>g</em>σ] → <em>b</em></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><em>T</em>[σ] → <em>A</em>[σ] <em>B</em>[σ] <em>C</em>[σ]      </p></td>
<td style="text-align: left;">
<p><em>C</em>[<em>f</em>σ] → <em>c</em> <em>C</em>[σ]      </p></td>
<td style="text-align: left;">
<p><em>C</em>[<em>g</em>σ] → <em>c</em></p></td>
</tr>
</tbody>
</table>

<p>An example derivation is</p>
<dl>
<dd>

<p>⇒  ⇒  ⇒  ⇒  ⇒  ⇒  ⇒  ⇒  ⇒ .</p>
</dd>
</dl>

<p>Both example languages are <a href="Pumping_lemma_for_context-free_languages#Usage_of_the_lemma" title="wikilink">known</a> to be not context-free.</p>
<h2 id="properties">Properties</h2>

<p><a href="John_Hopcroft" title="wikilink">Hopcroft</a> and <a href="Jeffrey_Ullman" title="wikilink">Ullman</a> tend to consider indexed languages as a "natural" class, since they are generated by several formalisms other than indexed grammars, viz.<mtpl></mtpl></p>
<ul>
<li><a href="Alfred_Aho" title="wikilink">Aho</a>'s one-way <a href="nested_stack_automata" title="wikilink">nested stack automata</a><a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></li>
<li><a href="Michael_J._Fischer" title="wikilink">Fischer</a>'s macro grammars<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></li>
<li><a href="Sheila_Greibach" title="wikilink">Greibach</a>'s automata with stacks of stacks<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></li>
<li><a href="Tom_Maibaum" title="wikilink">Maibaum</a>'s algebraic characterization<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></li>
</ul>

<p>Hayashi<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> generalized the <a href="Pumping_lemma_for_context-free_languages" title="wikilink">pumping lemma</a> to indexed grammars. Conversely, Gilman<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a><a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> gives a "shrinking lemma" for indexed languages.</p>
<h2 id="linear-indexed-grammars">Linear indexed grammars</h2>

<p><a href="Gerald_Gazdar" title="wikilink">Gerald Gazdar</a> has defined a second class, the <strong>linear indexed grammars</strong> (LIG),<mtpl></mtpl> by requiring that at most one nonterminal in each production be specified as receiving the stack,<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> whereas in an ordinary indexed grammar, all nonterminals receive copies of the stack. Formally, a linear indexed grammar is defined similar to an ordinary indexed grammar, but the production's form requirements are modified to:</p>
<ol>
<li><em>A</em>[σ] → α[] <em>B</em>[σ] β[],</li>
<li><em>A</em>[σ] → α[] <em>B</em>[<em>f</em>σ] β[],</li>
<li><em>A</em>[<em>f</em>σ] → α[] <em>B</em>[σ] β[],</li>
</ol>

<p>where <em>A</em>, <em>B</em>, <em>f</em>, σ, α are used as <a href="#Modern_definition_by_Hopcroft_and_Ullman" title="wikilink">above</a>, and β ∈ (<em>N</em> ∪ <em>T</em>)<sup>*</sup> is a string of nonterminal and terminal symbols like α.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> Also, the direct derivation relation ⇒ is defined similar to above. This new class of grammars defines a strictly smaller class of languages,<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> which belongs to the <a href="mildly_context-sensitive_language" title="wikilink">mildly context-sensitive</a> classes.</p>

<p>The language { <em>www</em> : <em>w</em> ∈ {<em>a</em>,<em>b</em>}<sup>*</sup> } is generable by an indexed grammar, but not by a linear indexed grammar, while { <em>a</em><sup><em>n</em></sup> <em>b</em><sup><em>n</em></sup> <em>c</em><sup><em>n</em></sup> : n ≥ 1 } is generable by a linear indexed grammar.</p>

<p>If both the original and the modified production rules are admitted, the language class remains the indexed languages.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a></p>
<h3 id="example">Example</h3>

<p>Letting σ denote an arbitrary collection of stack symbols, we can define a grammar for the language <em>L</em> = {<em>a</em><sup><em>n</em></sup> <em>b</em><sup><em>n</em></sup> <em>c</em><sup><em>n</em></sup> | <em>n</em> ≥ 1 }<mtpl></mtpl> as</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p><em>S</em>[σ]</p></td>
<td style="text-align: left;">
<p>→</p></td>
<td style="text-align: left;">
<p><em>a S</em>[<em>f</em>σ] <em>c</em></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><em>S</em>[σ]</p></td>
<td style="text-align: left;">
<p>→</p></td>
<td style="text-align: left;">
<p><em>T</em>[σ]</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><em>T</em>[<em>f</em>σ]</p></td>
<td style="text-align: left;">
<p>→</p></td>
<td style="text-align: left;">
<p><em>T</em>[σ] <em>b</em></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><em>T</em>[]</p></td>
<td style="text-align: left;">
<p>→</p></td>
<td style="text-align: left;">
<p>ε</p></td>
</tr>
</tbody>
</table>

<p>To derive the string <em>abc</em> we have the steps <em>S</em>[] ⇒ <em>aS</em>[<em>f</em>]<em>c</em> ⇒ <em>aT</em>[<em>f</em>]<em>c</em> ⇒ <em>aT</em>[]<em>bc</em> ⇒ <em>abc</em>.</p>

<p>Similarly: <em>S</em>[] ⇒ <em>aS</em>[<em>f</em>]<em>c</em> ⇒ <em>aaS</em>[<em>ff</em>]<em>cc</em> ⇒ <em>aaT</em>[<em>ff</em>]<em>cc</em> ⇒ <em>aaT</em>[<em>f</em>]<em>bcc</em> ⇒ <em>aaT</em>[]<em>bbcc</em> ⇒ <em>aabbcc</em>.</p>
<h3 id="computational-power">Computational Power</h3>

<p>The linearly indexed languages are a subset of the indexed languages, and thus all LIGs can be recoded as IGs, making the LIGs strictly less powerful than the IGs. A conversion from a LIG to an IG is relatively simple.<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a> LIG rules in general look approximately like 

<math display="inline" id="Indexed_grammar:0">
 <semantics>
  <mrow>
   <mrow>
    <mi>X</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>σ</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mi>α</mi>
    <mi>Y</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>σ</mi>
     <mo stretchy="false">]</mo>
    </mrow>
    <mi>β</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <times></times>
     <ci>X</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>σ</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>α</ci>
     <ci>Y</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>σ</ci>
     </apply>
     <ci>β</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X[\sigma]\to\alpha Y[\sigma]\beta
  </annotation>
 </semantics>
</math>

, modulo the push/pop part of a rewrite rule. The symbols 

<math display="inline" id="Indexed_grammar:1">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Indexed_grammar:2">
 <semantics>
  <mi>β</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>β</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta
  </annotation>
 </semantics>
</math>

 represent strings of terminal and/or non-terminal symbols, and any non-terminal symbol in either must have an empty stack, by the definition of a LIG. This is, of course, counter to how IGs are defined: in an IG, the non-terminals whose stacks are not being pushed to or popped from must have exactly the same stack as the rewritten non-terminal. Thus, somehow, we need to have non-terminals in 

<math display="inline" id="Indexed_grammar:3">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Indexed_grammar:4">
 <semantics>
  <mi>β</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>β</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta
  </annotation>
 </semantics>
</math>

 which, despite having non-empty stacks, behave as if they had empty stacks.</p>

<p>Let's consider the rule 

<math display="inline" id="Indexed_grammar:5">
 <semantics>
  <mrow>
   <mrow>
    <mi>X</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>σ</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mi>Y</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mo stretchy="false">]</mo>
    </mrow>
    <mi>Z</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mi>σ</mi>
      <mi>f</mi>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <times></times>
     <ci>X</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>σ</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>Y</ci>
     <list></list>
     <ci>Z</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <apply>
       <times></times>
       <ci>σ</ci>
       <ci>f</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X[\sigma]\to Y[]Z[\sigma f]
  </annotation>
 </semantics>
</math>

 as an example case. In converting this to an IG, the replacement for 

<math display="inline" id="Indexed_grammar:6">
 <semantics>
  <mrow>
   <mi>Y</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>Y</ci>
    <list></list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y[]
  </annotation>
 </semantics>
</math>

 must be some 

<math display="inline" id="Indexed_grammar:7">
 <semantics>
  <mrow>
   <msup>
    <mi>Y</mi>
    <mo>′</mo>
   </msup>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>σ</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>Y</ci>
     <ci>normal-′</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>σ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y^{\prime}[\sigma]
  </annotation>
 </semantics>
</math>

 that behaves exactly like 

<math display="inline" id="Indexed_grammar:8">
 <semantics>
  <mrow>
   <mi>Y</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>Y</ci>
    <list></list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y[]
  </annotation>
 </semantics>
</math>

 regardless of what 

<math display="inline" id="Indexed_grammar:9">
 <semantics>
  <mi>σ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma
  </annotation>
 </semantics>
</math>

 is. To achieve this, we can simply have a pair of rules that takes any 

<math display="inline" id="Indexed_grammar:10">
 <semantics>
  <mrow>
   <msup>
    <mi>Y</mi>
    <mo>′</mo>
   </msup>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>σ</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>Y</ci>
     <ci>normal-′</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>σ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y^{\prime}[\sigma]
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Indexed_grammar:11">
 <semantics>
  <mi>σ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma
  </annotation>
 </semantics>
</math>

 is not empty, and pops symbols from the stack. Then, when the stack is empty, it can be rewritten as 

<math display="inline" id="Indexed_grammar:12">
 <semantics>
  <mrow>
   <mi>Y</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>Y</ci>
    <list></list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y[]
  </annotation>
 </semantics>
</math>

.</p>

<p>

<math display="inline" id="Indexed_grammar:13">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>Y</mi>
     <mo>′</mo>
    </msup>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mi>σ</mi>
      <mi>f</mi>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>→</mo>
   <mrow>
    <msup>
     <mi>Y</mi>
     <mo>′</mo>
    </msup>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>σ</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>Y</ci>
      <ci>normal-′</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <apply>
       <times></times>
       <ci>σ</ci>
       <ci>f</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>Y</ci>
      <ci>normal-′</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>σ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y^{\prime}[\sigma f]\to Y^{\prime}[\sigma]
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Indexed_grammar:14">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>Y</mi>
     <mo>′</mo>
    </msup>
    <mrow>
     <mo stretchy="false">[</mo>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mi>Y</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>Y</ci>
      <ci>normal-′</ci>
     </apply>
     <list></list>
    </apply>
    <apply>
     <times></times>
     <ci>Y</ci>
     <list></list>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y^{\prime}[]\to Y[]
  </annotation>
 </semantics>
</math>

</p>

<p>We can apply this in general to derive an IG from an LIG. So for example if the LIG for the language 

<math display="inline" id="Indexed_grammar:15">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mrow>
    <msup>
     <mi>a</mi>
     <mi>n</mi>
    </msup>
    <msup>
     <mi>b</mi>
     <mi>n</mi>
    </msup>
    <msup>
     <mi>c</mi>
     <mi>n</mi>
    </msup>
    <msup>
     <mi>d</mi>
     <mi>m</mi>
    </msup>
   </mrow>
   <mo stretchy="false">|</mo>
   <mrow>
    <mrow>
     <mi>n</mi>
     <mo>≥</mo>
     <mn>1</mn>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mi>m</mi>
     <mo>≥</mo>
     <mn>1</mn>
    </mrow>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">conditional-set</csymbol>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>a</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>b</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>c</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>d</ci>
      <ci>m</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">formulae-sequence</csymbol>
     <apply>
      <geq></geq>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <geq></geq>
      <ci>m</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{a^{n}b^{n}c^{n}d^{m}|n\geq 1,m\geq 1\}
  </annotation>
 </semantics>
</math>

 is as follows:</p>

<p>

<math display="inline" id="Indexed_grammar:16">
 <semantics>
  <mrow>
   <mrow>
    <mi>S</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>σ</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mi>T</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>σ</mi>
     <mo stretchy="false">]</mo>
    </mrow>
    <mi>V</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <times></times>
     <ci>S</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>σ</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>T</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>σ</ci>
     </apply>
     <ci>V</ci>
     <list></list>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S[\sigma]\to T[\sigma]V[]
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Indexed_grammar:17">
 <semantics>
  <mrow>
   <mi>V</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>→</mo>
   <mpadded width="+3.3pt">
    <mi>d</mi>
   </mpadded>
   <mo rspace="5.8pt" stretchy="false">|</mo>
   <mi>d</mi>
   <mi>V</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">V</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <ci>normal-]</ci>
    </cerror>
    <ci>normal-→</ci>
    <csymbol cd="unknown">d</csymbol>
    <ci>normal-|</ci>
    <csymbol cd="unknown">d</csymbol>
    <csymbol cd="unknown">V</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V[]\to d~{}|~{}dV[]
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Indexed_grammar:18">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>σ</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>→</mo>
   <mi>a</mi>
   <mi>T</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>σ</mi>
    <mi>f</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mpadded width="+3.3pt">
    <mi>c</mi>
   </mpadded>
   <mo rspace="5.8pt" stretchy="false">|</mo>
   <mi>U</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>σ</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">T</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">σ</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <ci>normal-→</ci>
    <csymbol cd="unknown">a</csymbol>
    <csymbol cd="unknown">T</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">σ</csymbol>
     <csymbol cd="unknown">f</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <csymbol cd="unknown">c</csymbol>
    <ci>normal-|</ci>
    <csymbol cd="unknown">U</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">σ</csymbol>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T[\sigma]\to aT[\sigma f]c~{}|~{}U[\sigma]
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Indexed_grammar:19">
 <semantics>
  <mrow>
   <mrow>
    <mi>U</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mi>σ</mi>
      <mi>f</mi>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mi>b</mi>
    <mi>U</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>σ</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <times></times>
     <ci>U</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <apply>
       <times></times>
       <ci>σ</ci>
       <ci>f</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>b</ci>
     <ci>U</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>σ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U[\sigma f]\to bU[\sigma]
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Indexed_grammar:20">
 <semantics>
  <mrow>
   <mrow>
    <mi>U</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>→</mo>
   <mi>ϵ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <times></times>
     <ci>U</ci>
     <list></list>
    </apply>
    <ci>ϵ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U[]\to\epsilon
  </annotation>
 </semantics>
</math>

</p>

<p>The sentential rule here is not an IG rule, but using the above conversion algorithm, we can define new rules for 

<math display="inline" id="Indexed_grammar:21">
 <semantics>
  <msup>
   <mi>V</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>V</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V^{\prime}
  </annotation>
 </semantics>
</math>

, changing the grammar to:</p>

<p>

<math display="inline" id="Indexed_grammar:22">
 <semantics>
  <mrow>
   <mrow>
    <mi>S</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>σ</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mi>T</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>σ</mi>
     <mo stretchy="false">]</mo>
    </mrow>
    <msup>
     <mi>V</mi>
     <mo>′</mo>
    </msup>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>σ</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <times></times>
     <ci>S</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>σ</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>T</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>σ</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>V</ci>
      <ci>normal-′</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>σ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S[\sigma]\to T[\sigma]V^{\prime}[\sigma]
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Indexed_grammar:23">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>V</mi>
     <mo>′</mo>
    </msup>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mi>σ</mi>
      <mi>f</mi>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>→</mo>
   <mrow>
    <msup>
     <mi>V</mi>
     <mo>′</mo>
    </msup>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>σ</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>V</ci>
      <ci>normal-′</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <apply>
       <times></times>
       <ci>σ</ci>
       <ci>f</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>V</ci>
      <ci>normal-′</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>σ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V^{\prime}[\sigma f]\to V^{\prime}[\sigma]
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Indexed_grammar:24">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>V</mi>
     <mo>′</mo>
    </msup>
    <mrow>
     <mo stretchy="false">[</mo>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mi>V</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>V</ci>
      <ci>normal-′</ci>
     </apply>
     <list></list>
    </apply>
    <apply>
     <times></times>
     <ci>V</ci>
     <list></list>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V^{\prime}[]\to V[]
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Indexed_grammar:25">
 <semantics>
  <mrow>
   <mi>V</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>→</mo>
   <mpadded width="+3.3pt">
    <mi>d</mi>
   </mpadded>
   <mo rspace="5.8pt" stretchy="false">|</mo>
   <mi>d</mi>
   <mi>V</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">V</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <ci>normal-]</ci>
    </cerror>
    <ci>normal-→</ci>
    <csymbol cd="unknown">d</csymbol>
    <ci>normal-|</ci>
    <csymbol cd="unknown">d</csymbol>
    <csymbol cd="unknown">V</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V[]\to d~{}|~{}dV[]
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Indexed_grammar:26">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>σ</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>→</mo>
   <mi>a</mi>
   <mi>T</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>σ</mi>
    <mi>f</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mpadded width="+3.3pt">
    <mi>c</mi>
   </mpadded>
   <mo rspace="5.8pt" stretchy="false">|</mo>
   <mi>U</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>σ</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">T</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">σ</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <ci>normal-→</ci>
    <csymbol cd="unknown">a</csymbol>
    <csymbol cd="unknown">T</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">σ</csymbol>
     <csymbol cd="unknown">f</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <csymbol cd="unknown">c</csymbol>
    <ci>normal-|</ci>
    <csymbol cd="unknown">U</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">σ</csymbol>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T[\sigma]\to aT[\sigma f]c~{}|~{}U[\sigma]
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Indexed_grammar:27">
 <semantics>
  <mrow>
   <mrow>
    <mi>U</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mi>σ</mi>
      <mi>f</mi>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mi>b</mi>
    <mi>U</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>σ</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <times></times>
     <ci>U</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <apply>
       <times></times>
       <ci>σ</ci>
       <ci>f</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>b</ci>
     <ci>U</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>σ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U[\sigma f]\to bU[\sigma]
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Indexed_grammar:28">
 <semantics>
  <mrow>
   <mrow>
    <mi>U</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>→</mo>
   <mi>ϵ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <times></times>
     <ci>U</ci>
     <list></list>
    </apply>
    <ci>ϵ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U[]\to\epsilon
  </annotation>
 </semantics>
</math>

</p>

<p>Each rule now fits the definition of an IG, in which all the non-terminals in the right hand side of a rewrite rule receive a copy of the rewritten symbol's stack. The indexed grammars are therefore able to describe all the languages that linearly indexed grammars can describe.</p>
<h3 id="relation-to-other-formalism">Relation to other formalism</h3>

<p>Vijay-Shanker and Weir (1994)<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a> demonstrates that Linear Indexed Grammars, <a href="Combinatory_categorial_grammar" title="wikilink">Combinatory Categorial Grammars</a>, <a href="Tree-adjoining_grammar" title="wikilink">Tree-adjoining Grammars</a>, and <a href="Head_grammar" title="wikilink">Head Grammars</a> all define the same class of string languages. Their formal definition of linear indexed grammars<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a> differs from the <a href="#Linear_indexed_grammars" title="wikilink">above</a>.</p>

<p>LIGs (and their <a href="Equivalence_(formal_languages)" title="wikilink">weakly equivalents</a>) are strictly less expressive (meaning they generate a proper subset) than the languages generated by another family of weakly equivalent formalism, which include: <a class="uri" href="LCFRS" title="wikilink">LCFRS</a>, <a class="uri" href="MCTAG" title="wikilink">MCTAG</a>, <a class="uri" href="MCFG" title="wikilink">MCFG</a> and <a href="minimalist_grammar" title="wikilink">minimalist grammars</a> (MGs). The latter family can (also) be parsed in <a href="polynomial_time" title="wikilink">polynomial time</a>.<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a></p>
<h2 id="distributed-index-di-grammars">Distributed Index (DI) grammars</h2>

<p>Another form of indexed grammars, introduced by Staudacher (1993),<a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a> is the class of Distributed Index grammars (DIGs). What distinguishes DIGs from Aho's Indexed Grammars is the propagation of indexes. Unlike Aho's IGs, which distribute the whole symbol stack to all non-terminals during a rewrite operation, DIGs divide the stack into substacks and distributes the substacks to selected non-terminals.</p>

<p>The general rule schema for a binarily distributing rule of DIG is the form</p>

<p><em>X</em>[<em>f</em><sub>1</sub>...<em>f</em><sub><em>i</em></sub><em>f</em><sub><em>i</em>+1</sub>...<em>f</em><sub><em>n</em></sub>] → α <em>Y</em>[f<sub>1</sub>...<em>f</em><sub><em>i</em></sub>] β <em>Z</em>[<em>f</em><sub><em>i</em>+1</sub>...<em>f</em><sub><em>n</em></sub>] γ</p>

<p>Where α, β, and γ are arbitrary terminal strings. For a ternarily distributing string:</p>

<p><em>X</em>[<em>f</em><sub>1</sub>...<em>f</em><sub><em>i</em></sub><em>f</em><sub><em>i</em>+1</sub>...<em>f</em><sub><em>j</em></sub><em>f</em><sub><em>j</em>+1</sub>...<em>f</em><sub><em>n</em></sub>] → α <em>Y</em>[f<sub>1</sub>...<em>f</em><sub><em>i</em></sub>] β <em>Z</em>[<em>f</em><sub><em>i</em>+1</sub>...<em>f</em><sub><em>j</em></sub>] γ <em>W</em>[<em>f</em><sub><em>j</em>+1</sub>...<em>f</em><sub><em>n</em></sub>] η</p>

<p>And so forth for higher numbers of non-terminals in the right hand side of the rewrite rule. In general, if there are <em>m</em> non-terminals in the right hand side of a rewrite rule, the stack is partitioned <em>m</em> ways and distributed amongst the new non-terminals. Notice that there is a special case where a partition is empty, which effectively makes the rule a LIG rule. The Distributed Index languages are therefore a superset of the Linearly Indexed languages.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Chomsky_hierarchy" title="wikilink">Chomsky hierarchy</a></li>
<li><a href="Indexed_language" title="wikilink">Indexed language</a></li>
</ul>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.cogs.susx.ac.uk/research/nlp/gazdar/nlp-in-prolog/ch04/chapter-04-sh-1.6.3.html#sh-1.6.3">"NLP in Prolog" chapter on indexed grammars and languages</a></li>
</ul>

<p>"</p>

<p><a href="Category:Formal_languages" title="wikilink">Category:Formal languages</a> <a href="Category:Grammar_frameworks" title="wikilink">Category:Grammar frameworks</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">"[" and "]" are meta symbols to indicate the stack.<a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
<li id="fn8"></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
<li id="fn10"><a href="#fnref10">↩</a></li>
<li id="fn11">all other nonterminals receive an empty stack<a href="#fnref11">↩</a></li>
<li id="fn12">In order to generate any string at all, some productions must be admitted having no nonterminal symbol on their right hand side. However, Gazdar didn't discuss this issue.<a href="#fnref12">↩</a></li>
<li id="fn13"><a href="#fnref13">↩</a></li>
<li id="fn14">Gazdar (1988), Appendix, p.89<a href="#fnref14">↩</a></li>
<li id="fn15">Gazdar 1988, Appendix, p.89-91<a href="#fnref15">↩</a></li>
<li id="fn16"><a href="#fnref16">↩</a></li>
<li id="fn17">p.517-518<a href="#fnref17">↩</a></li>
<li id="fn18"><a href="#fnref18">↩</a></li>
<li id="fn19"><a href="#fnref19">↩</a></li>
</ol>
</section>
</body>
</html>
