   Noncommutative signal-flow graph      Noncommutative signal-flow graph   (Figure)  A multi-input, multi-output system represented as a noncommutative matrix signal-flow graph.   In automata theory and control theory , branches of mathematics , theoretical computer science and systems engineering , a noncommutative signal-flow graph is a tool for modeling interconnected systems and state machines by mapping the edges of a directed graph to a ring or semiring .  A single edge weight might represent an array of impulse responses of a complex system (see figure to the right), or a character from an alphabet picked off the input tape of a finite automaton, while the graph might represent the flow of information or state transitions.  As diverse as these applications are, they share much of the same underlying theory.  Definition  (Figure)  Signal-flow graph fragment.   Consider n equations involving n +1 variables { x 0 , x 1 ,..., x n }.         x  i   =    ∑   j  =  0   n     a   i  j     x  j      ,   1  ≤  i  ≤  n    ,     formulae-sequence     subscript  x  i     superscript   subscript     j  0    n      subscript  a    i  j     subscript  x  j          1  i       n      x_{i}=\sum_{j=0}^{n}a_{ij}x_{j},\;\;\;1\leq i\leq n,     with a ij elements in a ring or semiring R . The free variable x 0 corresponds to a source vertex v 0 , thus having no defining equation. Each equation corresponds to a fragment of a directed graph  G =( V , E ) as show in the figure.  The edge weights define a function f from E to R . Finally fix an output vertex v m . A signal-flow graph is the collection of this data S = ( G =( V , E ), v 0 , v m    ∈     \in    V , f : E → R ). The equations may not have a solution, but when they do,        x  m   =   T   x  0     ,       subscript  x  m     T   subscript  x  0      x_{m}=Tx_{0},     with T an element of R called the gain .  Successive Elimination  Return Loop Method  There exist several noncommutative generalizations of Mason's rule . The most common is the return loop method (sometimes called the forward return loop method (FRL) , having a dual backward return loop method (BRL) ). The first rigorous proof is attributed to Riegle, so it is sometimes called Riegle's rule .  As with Mason's rule, these gain expressions combine terms in a graph-theoretic manner (loop-gains, path products, etc). They are known to hold over an arbitrary noncommutative ring and over the semiring of regular expressions.  Formal Description  The method starts by enumerating all paths from input to output, indexed by j    ∈     \in    J . We use the following definitions:   The j -th path product is (by abuse of notation) a tuple of k j edge weights along it:           p  j   =   (   w   k  j    (  j  )    ,  …  ,   w  2   (  j  )    ,   w  1   (  j  )    )    .       subscript  p  j     subscript   superscript  w  j    subscript  k  j    normal-…   subscript   superscript  w  j   2    subscript   superscript  w  j   1      p_{j}=(w^{(j)}_{k_{j}},\ldots,w^{(j)}_{2},w^{(j)}_{1}).         To split a vertex v is to replace it with a source and sink respecting the original incidence and weights (this is the inverse of the graph morphism taking source and sink to v ).  The loop gain of a vertex v w.r.t. a subgraph H is the gain from source to sink of the signal-flow graph split at v after removing all vertices not in H .  Each path defines an ordering of vertices along it. The along path j , the i -th FRL (BRL) node factor is (1- S i (j) ) −1 where S i (j) is the loop gain of the i -th vertex along the j -th w.r.t. the subgraph obtained by removing v 0 and all vertices ahead of (behind) it.   The contribution of the j -th path to the gain is the product along the path, alternating between the path product weights and the node factors:        T  j   =    ∏   i  =   k  j    1      (   1  -   S  i   (  j  )     )    -  1     w  i   (  j  )       ,       subscript  T  j     superscript   subscript  product    i   subscript  k  j     1      superscript    1   subscript   superscript  S  j   i      1     subscript   superscript  w  j   i       T_{j}=\prod_{i=k_{j}}^{1}(1-S^{(j)}_{i})^{-1}w^{(j)}_{i},     so the total gain is       T  =    ∑   j  ∈  J     T  j     .      T    subscript     j  J     subscript  T  j      T=\sum_{j\in J}T_{j}.     An Example  (Figure)  A noncommutative signal-flow graph from x to z   Consider the signal-flow graph shown. From x to z , there are two path products: ( d ) and ( e,a ). Along ( d ), the FRL and BRL contributions coincide as both share same loop gain (whose split reappears in the upper right of the table below):       f  +   e    (   1  -  b   )    -  1    c    ,      f    e   superscript    1  b     1    c     f+e(1-b)^{-1}c,     Multiplying its node factor and path weight, its gain contribution is        T  d   =     [   1  -  f  -   e    (   1  -  b   )    -  1    c    ]    -  1    d    .       subscript  T  d      superscript   delimited-[]    1  f    e   superscript    1  b     1    c       1    d     T_{d}=\left[1-f-e(1-b)^{-1}c\right]^{-1}d.     Along path ( e,a ), FRL and BRL differ slightly, each having distinct splits of vertices y and z as shown in the following table.      Adding to T d , the alternating product of node factors and path weights, we obtain two gain expressions:        T   (   F  R  L   )    =      [   1  -  f  -   e    (   1  -  b   )    -  1    c    ]    -  1    d   +     [   1  -  f  -   e    (   1  -  b   )    -  1    c    ]    -  1    e    (   1  -  b   )    -  1    a     ,       superscript  T    F  R  L         superscript   delimited-[]    1  f    e   superscript    1  b     1    c       1    d      superscript   delimited-[]    1  f    e   superscript    1  b     1    c       1    e   superscript    1  b     1    a      T^{(FRL)}=\left[1-f-e(1-b)^{-1}c\right]^{-1}d+\left[1-f-e(1-b)^{-1}c\right]^{-%
 1}e(1-b)^{-1}a,     and        T   (   B  R  L   )    =      [   1  -  f  -   e    (   1  -  b   )    -  1    c    ]    -  1    d   +     (   1  -  f   )    -  1    e    [   1  -  b  -   c    (   1  -  f   )   e     ]    -  1    a     ,       superscript  T    B  R  L         superscript   delimited-[]    1  f    e   superscript    1  b     1    c       1    d      superscript    1  f     1    e   superscript   delimited-[]    1  b    c   superscript    1  f   e        1    a      T^{(BRL)}=\left[1-f-e(1-b)^{-1}c\right]^{-1}d+(1-f)^{-1}e\left[1-b-c(1-f)^{e}%
 \right]^{-1}a,     These values are easily seen to be the same using identities ( ab ) −1 = b −1 a −1 and a (1- ba ) −1 =(1- ab ) −1 a .  Applications  Matrix Signal-Flow Graphs  Consider equations       y  i   =     ∑   j  =  1   2     a   i  j     x  j     +    ∑   j  =  1   2     b   i  j     y  j           subscript  y  i       superscript   subscript     j  1    2      subscript  a    i  j     subscript  x  j       superscript   subscript     j  1    2      subscript  b    i  j     subscript  y  j        y_{i}=\sum_{j=1}^{2}a_{ij}x_{j}+\sum_{j=1}^{2}b_{ij}y_{j}     and        z  i   =    ∑   j  =  1   2     c   i  j     y  j      ,       subscript  z  i     superscript   subscript     j  1    2      subscript  c    i  j     subscript  y  j       z_{i}=\sum_{j=1}^{2}c_{ij}y_{j},     This system could be modeled as scalar signal-flow graph with multiple inputs and outputs. But, the variables naturally fall into layers, which can be collected into vectors x =( x 1 , x 2 ) t  y =( y 1 , y 2 ) t and z =( z 1 , z 2 ) t . This results in much simpler matrix signal-flow graph as shown in the figure at the top of the article.  Applying the forward return loop method is trivial as there's a single path product ( C , A ) with a single loop-gain B at y . Thus as a matrix, this system has a very compact representation of its input-output map       T  =   C    (   1  -  B   )    -  1    A    .      T    C   superscript    1  B     1    A     T=C(1-B)^{-1}A.     Finite Automata  (Figure)  Representation of a finite automaton as a (noncommutative) signal flow graph over a semiring.   An important kind of noncommutative signal-flow graph is a finite state automaton over an alphabet   Σ   normal-Σ   \Sigma   .  Serial connections correspond to the concatenation of words, which can be extended to subsets of the free monoid     Σ  *     superscript  normal-Σ     \Sigma^{*}   . For A , B      ⊆   Σ  *       absent   superscript  normal-Σ      \subseteq\Sigma^{*}           A  ⋅  B   =   {   a  b   ∣    a  ∈  A   ,   b  ∈  B    }    .       normal-⋅  A  B    conditional-set    a  b    formulae-sequence    a  A     b  B       A\cdot B=\{ab\mid a\in A,b\in B\}.     Parallel connections correspond to set union , which in this context is often written A + B .  Finally, self-loops naturally correspond to the Kleene closure        A  *   =    {  λ  }   +  A  +   A  A   +   A  A  A   +  ⋯    ,       superscript  A       λ   A    A  A     A  A  A   normal-⋯     A^{*}=\{\lambda\}+A+AA+AAA+\cdots,     where   λ   λ   \lambda   is the empty word . The similarity to the infinite geometric series         (   1  -  x   )    -  1    =   1  +  x  +   x  2   +    x  3   ⋯     ,       superscript    1  x     1      1  x   superscript  x  2      superscript  x  3   normal-⋯      (1-x)^{-1}=1+x+x^{2}+x^{3}\cdots,     is more than superficial, as expressions of this form serve as 'inversion' in this semiring .  In this way, the subsets of    Σ  *     superscript  normal-Σ     \Sigma^{*}   built of from finitely many of these three operations can be identified with the semiring of regular expressions . Similarly, finite graphs whose edges are weighted by subsets of    Σ  *     superscript  normal-Σ     \Sigma^{*}   can be identified with finite automata, though generally that theory starts with singleton sets as in the figure.  This automaton is deterministic so we can unambiguously enumerate paths via words. Using the return loop method, path contributions are:   path ab , has node factors ( c * ,   λ   λ   \lambda   ), yielding gain contribution          a   c  *   b   ,      a   superscript  c    b    ac^{*}b,         path ada , has node factors ( c * , c * ,   λ   λ   \lambda   ), yielding gain contribution          a   c  *   d   c  *   a   ,      a   superscript  c    d   superscript  c    a    ac^{*}dc^{*}a,         path ba , has node factors ( c * ,   λ   λ   \lambda   ), yielding gain contribution          b   c  *   a   .      b   superscript  c    a    bc^{*}a.        Thus the language accepted by this automaton (the gain of its signal-flow graph) is the sum of these terms       L  =    a   c  *   b   +   a   c  *   d   c  *   a   +   b   c  *   a     .      L      a   superscript  c    b     a   superscript  c    d   superscript  c    a     b   superscript  c    a      L=ac^{*}b+ac^{*}dc^{*}a+bc^{*}a.     Historical Notes  See also   Signal-flow graph  Mason's rule  Finite automata  Regular expressions   Notes  References            "  Category:Control theory  Category:Automata theory   