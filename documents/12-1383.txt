


Correlation attack




Correlation attack

In cryptography, correlation attacks are a class of known plaintext attacks for breaking stream ciphers whose keystream is generated by combining the output of several linear feedback shift registers (called LFSRs for the rest of this article) using a Boolean function. Correlation attacks exploit a statistical weakness that arises from a poor choice of the Boolean function â€“ it is possible to select a function which avoids correlation attacks, so this type of cipher is not inherently insecure. It is simply essential to consider susceptibility to correlation attacks when designing stream ciphers of this type.
Explanation
Correlation attacks are possible when there is a significant correlation between the output state of one individual LFSR in the keystream generator and the output of the Boolean function that combines the output state of all of the LFSRs. Combined with partial knowledge of the keystream (which is easily derived from partial knowledge of the plaintext, as the two are simply XORed together), this allows an attacker to brute-force the key for that individual LFSR and the rest of the system separately. For instance, if, in a keystream generator in which four 8-bit LFSRs are combined to produce the keystream, and one of the registers is correlated to the Boolean function output, we may brute force it first and then the remaining three, for a total attack complexity of 28 + 224. Compared to the cost of launching a brute force attack on the entire system, with complexity 232, this represents an attack effort saving factor of just under 256, which is substantial. If a second register is correlated with the function, we may repeat this process and drop the attack complexity to 28 + 28 + 216 for an effort saving factor of just under 65028. In this sense, correlation attacks can be considered divide and conquer algorithms.
Example
Breaking the Geffe generator
Correlation attacks are perhaps best explained via example. We will consider the case of the Geffe keystream generator. The Geffe generator consists of three LFSRs: LFSR-1, LFSR-2 and LFSR-3. If we denote the outputs of these registers by 
 
 
 
 , 
 
 
 
  and 
 
 
 
 , respectively, then the Boolean function that combines the three registers to provide the generator output is given by 
 
 
 
 
  (i.e. (
 
 
 
  AND 
 
 
 
 ) XOR (NOT 
 
 
 
  AND 
 
 
 
 )). There are 23 = 8 possible values for the outputs of the three registers, and the value of this combining function for each of them is shown in the table below:




Boolean function output table









0



0



0



0



1



1



1



1



Let us consider the output of the third register, 
 
 
 
 . The table above makes it clear that of the 8 possible outputs of 
 
 
 
 . 6 of them are equal to the corresponding value of the generator output, 
 
 
 
 , i.e. 
 
 
 
  in 75% of all possible cases. Thus we say that LFSR-3 is correlated with the generator. This is a weakness we may exploit as follows:
Suppose we intercept the ciphertext 
 
 
 
 
  of a plaintext 
 
 
 
  which has been encrypted by a stream cipher using a Geffe generator as its keystream generator, i.e. 
 
 
 
  for 
 
 
 
 , where 
 
 
 
  is the output of LFSR-1 at time 
 
 
 
 
 , etc. Suppose further that we know some part of the plaintext, e.g. we know 
 
 
 
 , the first 32 bits of the plaintext (corresponding to 4 ASCII characters of text). This is not as improbable as it may seem: if we know the plaintext is a valid XML file, for instance, we know that the first 4 ASCII characters must be "c_1, c_2, c_3, \ldots, c_{32}
and our known/guessed 
 
 
 
 , we may easily find 
 
 
 
  for 
 
 
 
  by XORing the two together. We now know 32 consecutive bits of the generator output.
Now we may begin a brute force search of the space of possible keys (initial values) for LFSR-3 (assuming we know the tapped bits of LFSR-3, an assumption which is in line with Kerckhoffs' principle). For any given key in the keyspace, we may quickly generate the first 32 bits of LFSR-3's output and compare these to our recovered 32 bits of the entire generator's output. Because we have established earlier that there is a 75% correlation between the output of LFSR-3 and the generator, we know that if we have correctly guessed the key for LFSR-3, approximately 24 of the first 32 bits of LFSR-3 output will match up with the corresponding bits of generator output. If we have guessed incorrectly, we should expect roughly half, or 16, of the first 32 bits of these two sequences to match. Thus we may recover the key for LFSR-3 independently of the keys of LFSR-1 and LFSR-2. At this stage we have reduced the problem of brute forcing a system of 3 LFSRs to the problem of brute forcing a single LFSR and then a system of 2 LFSRs. The amount of effort saved here depends on the length of the LFSRs. For realistic values, it is a very substantial saving and can make brute force attacks very practical.
We do not need to stop here. Observe in the table above that 
 
 
 
 
  also agrees with the generator output 6 times out of 8, again a correlation of 75% correlation between 
 
 
 
  and the generator output. We may begin a brute force attack against LFSR-2 independently of the keys of LFSR-1 and LFSR-3, leaving only LFSR-1 unbroken. Thus, we are able to break the Geffe generator with as much effort as required to brute force 3 entirely independent LFSRs, meaning that the Geffe generator is a very weak generator and should never be used to generate stream cipher keystreams.
Note from the table above that 
 
 
 
  agrees with the generator output 4 times out of 8 - a 50% correlation. We cannot use this to brute force LFSR-1 independently of the others: the correct key will yield output which agrees with the generator output 50% of the time, but on average so will an incorrect key. This represents the ideal situation from a security perspective - the combining function 
 
 
 
  should be chosen so that the correlation between each variable and the combining function's output is as close as possible to 50%. In practice it may be difficult to find a function which achieves this without sacrificing other design criteria, e.g. period length, so a compromise may be necessary.
Clarifying the statistical nature of the attack
While the above example illustrates well the relatively simple concepts behind correlation attacks, it perhaps simplifies the explanation of precisely how the brute forcing of individual LFSRs proceeds. We make the statement that incorrectly guessed keys will generate LFSR output which agrees with the generator output roughly 50% of the time, because given two random bit sequences of a given length, the probability of agreement between the sequences at any particular bit is 0.5. However, specific individual incorrect keys may well generate LFSR output which agrees with the generator output more or less often than exactly 50% of the time. This is particularly salient in the case of LFSRs whose correlation with the generator is not especially strong; for small enough correlations it is certainly not outside the realm of possibility that an incorrectly guessed key will also lead to LFSR output that agrees with the desired number of bits of the generator output. Thus we may not be able to find the key for that LFSR uniquely and with certainty. We may instead find a number of possible keys, although this is still a significant breach of the cipher's security. If we had, say, a megabyte of known plaintext, the situation would be substantially different. An incorrect key may generate LFSR output that agrees with more than 512 kilobytes of the generator output, but not likely to generate output that agrees with as much as 768 kilobytes of the generator output like a correctly guessed key would. As a rule, the weaker the correlation between an individual register and the generator output, the more known plaintext is required to find that register's key with a high degree of confidence. Readers with a background in probability theory should be able to see easily how to formalise this argument and obtain estimates of the length of known plaintext required for a given correlation using the binomial distribution.
Higher order correlations
Definition
The correlations which were exploited in the example attack on the Geffe generator are examples of what are called first order correlations: they are correlations between the value of the generator output and an individual LFSR. It is possible to define higher order correlations in addition to these. For instance, it may be possible that while a given Boolean function has no strong correlations with any of the individual registers it combines, a significant correlation may exist between some Boolean function of two of the registers, e.g. 
 
 
 
 . This would be an example of a second order correlation. We can define third order correlations and so on in the obvious way.
Higher order correlation attacks can be more powerful than single order correlation attacks, however this effect is subject to a "law of limiting returns". The table below shows a measure of the computational cost for various attacks on a keystream generator consisting of eight 8-bit LFSRs combined by a single Boolean function. Understanding the calculation of cost is relatively straightforward: the leftmost term of the sum represents the size of the keyspace for the correlated generators, and the rightmost term represents the size of the keyspace for the remaining generators.




Generator attack effort



Attack



Brute force



Single 1st order correlation attack



Single 2nd order correlation attack



Single 3rd order correlation attack



Single 4th order correlation attack



Single 5th order correlation attack



Single 6th order correlation attack



Single 7th order correlation attack



While higher order correlations lead to more powerful attacks, they are also more difficult to find, as the space of available Boolean functions to correlate against the generator output increases as the number of arguments to the function does.
Terminology
A Boolean function 
 
 
 
 
  of n variables is said to be "m-th order correlation immune" or to have "m-th order correlation immunity" for some integer m if no significant correlation exists between the function's output and any Boolean function of m of its inputs. For example, a Boolean function which has no first order or second order correlations but which does have a third order correlation exhibits 2nd order correlation immunity. Obviously, higher correlation immunity makes a function more suitable for use in a keystream generator (although this is not the only thing which needs to be considered).
Siegenthaler showed that the correlation immunity m of a Boolean function of algebraic degree d of n variables satisfies mÂ +Â dÂ â‰¤Â n; for a given set of input variables, this means that a high algebraic degree will restrict the maximum possible correlation immunity. Furthermore, if the function is balanced then mÂ +Â dÂ â‰¤Â nÂ âˆ’Â 1.1
It follows that it is impossible for a function of n variables to be n-th order correlation immune. This also follows from the fact that any such function can be written using a Reed-Muller basis as a combination of XORs of the input functions.
Cipher design implications
Given the possibly extreme severity of a correlation attack's impact on a stream cipher's security, it should be considered essential to test a candidate Boolean combination function for correlation immunity before deciding to use it in a stream cipher. However, it is important to note that high correlation immunity is a necessary but not sufficient condition for a Boolean function to be appropriate for use in a keystream generator. There are other issues to consider, e.g. whether or not the function is balanced - whether it outputs as many or roughly as many 1's as it does 0's when all possible inputs are considered.
Research has been conducted into methods for easily generating Boolean functions of a given size which are guaranteed to have at least some particular order of correlation immunity. This research has uncovered links between correlation immune Boolean functions and error correcting codes.2 
See also

Topics in cryptography

References

Bruce Schneier. Applied Cryptography: Protocols, Algorithms and Source Code in C, Second Edition. John Wiley & Sons, Inc. 1996. ISBN 0-471-12845-7. Page 382 of section 16.4: Stream Ciphers Using LFSRs.



External links

The Online Database of Boolean Functions allows visitors to search a database of Boolean factors in several ways, including by correlation immunity.

"
Category:Cryptographic attacks




Chuan-Kun Wu and Ed Dawson, Construction of Correlation Immune Boolean Functions, ICICS97


