<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1945">Normal invariant</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Normal invariant</h1>
<hr>In mathematics, a '''nor
<p>mal map''' is a concept in <a href="geometric_topology" title="wikilink">geometric topology</a> due to <a href="William_Browder_(mathematician)" title="wikilink">William Browder</a> which is of fundamental importance in <a href="surgery_theory" title="wikilink">surgery theory</a>. Given a <a href="Poincaré_complex" title="wikilink">Poincaré complex</a> <em>X</em> (more geometrically a <a href="Poincaré_space" title="wikilink">Poincaré space</a>), a normal map on <em>X</em> endows the space, roughly speaking, with some of the homotopy-theoretic global structure of a closed manifold. In particular, <em>X</em> has a good candidate for a <a href="stable_normal_bundle" title="wikilink">stable normal bundle</a> and a <a href="René_Thom" title="wikilink">Thom</a> collapse map, which is equivalent to there being a map from a manifold <em>M</em> to <em>X</em> matching the fundamental classes and preserving normal bundle information. If the dimension of <em>X</em> is 

<math display="inline" id="Normal_invariant:0">
 <semantics>
  <mo>≥</mo>
  <annotation-xml encoding="MathML-Content">
   <geq></geq>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \geq
  </annotation>
 </semantics>
</math>

 5 there is then only the algebraic topology <a href="surgery_obstruction" title="wikilink">surgery obstruction</a> due to <a href="C._T._C._Wall" title="wikilink">C. T. C. Wall</a> to <em>X</em> actually being <a href="homotopy_equivalent" title="wikilink">homotopy equivalent</a> to a closed manifold. Normal maps also apply to the study of the uniqueness of manifold structures within a homotopy type, which was pioneered by <a href="Sergei_Novikov_(mathematician)" title="wikilink">Sergei Novikov</a>.</p>

<p>The <a class="uri" href="cobordism" title="wikilink">cobordism</a> classes of normal maps on <em>X</em> are called <strong>normal invariants</strong>. Depending on the category of manifolds (differentiable, piecewise-linear, or topological), there are similarly defined, but inequivalent, concepts of normal maps and normal invariants.</p>

<p>It is possible to perform <a href="Surgery_theory#Surgery_on_a_manifold" title="wikilink">surgery</a> on normal maps, meaning surgery on the domain manifold, and preserving the map. Surgery on normal maps allows one to systematically kill elements in the relative homotopy groups by representing them as embeddings <em>with trivial normal bundle</em>.</p>
<h2 id="definition">Definition</h2>

<p>There are two equivalent definitions of normal maps, depending on whether one uses normal bundles or tangent bundles of manifolds. Hence it is possible to switch between the definitions which turns out to be quite convenient.</p>

<p>1. Given a Poincaré complex <em>X</em> (i.e. a <a class="uri" href="CW-complex" title="wikilink">CW-complex</a> whose cellular chain complex satisfies <a href="Poincaré_duality" title="wikilink">Poincaré duality</a>) of formal dimension 

<math display="inline" id="Normal_invariant:1">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

, a normal map on <em>X</em> consists of</p>
<ul>
<li>a map 

<math display="inline" id="Normal_invariant:2">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mo>:</mo>
   <mrow>
    <mi>M</mi>
    <mo>→</mo>
    <mi>X</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>f</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>M</ci>
     <ci>X</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f\colon M\to X
  </annotation>
 </semantics>
</math>

 from some closed <em>n</em>-dimensional manifold <em>M</em>,</li>
<li>a bundle 

<math display="inline" id="Normal_invariant:3">
 <semantics>
  <mi>ξ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ξ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \xi
  </annotation>
 </semantics>
</math>

 over <em>X</em>, and a stable map from the <a href="stable_normal_bundle" title="wikilink">stable normal bundle</a> 

<math display="inline" id="Normal_invariant:4">
 <semantics>
  <msub>
   <mi>ν</mi>
   <mi>M</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ν</ci>
    <ci>M</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \nu_{M}
  </annotation>
 </semantics>
</math>

 of 

<math display="inline" id="Normal_invariant:5">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Normal_invariant:6">
 <semantics>
  <mi>ξ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ξ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \xi
  </annotation>
 </semantics>
</math>

, and</li>
<li>usually the normal map is supposed to be of <strong>degree one</strong>. That means that the fundamental class of 

<math display="inline" id="Normal_invariant:7">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 should be mapped under 

<math display="inline" id="Normal_invariant:8">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 to the fundamental class of 

<math display="inline" id="Normal_invariant:9">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>



<math display="block" id="Normal_invariant:10">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>f</mi>
     <mo>*</mo>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>M</mi>
      <mo stretchy="false">]</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>X</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>∈</mo>
   <mrow>
    <msub>
     <mi>H</mi>
     <mi>n</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>f</ci>
       <times></times>
      </apply>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <ci>M</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>X</ci>
     </apply>
    </apply>
    <apply>
     <in></in>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>H</ci>
       <ci>n</ci>
      </apply>
      <ci>X</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{*}([M])=[X]\in H_{n}(X)
  </annotation>
 </semantics>
</math>

.</li>
</ul>

<p>2. Given a Poincaré complex 

<math display="inline" id="Normal_invariant:11">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

 (i.e. a <a class="uri" href="CW-complex" title="wikilink">CW-complex</a> whose cellular chain complex satisfies <a href="Poincaré_duality" title="wikilink">Poincaré duality</a>) of formal dimension 

<math display="inline" id="Normal_invariant:12">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

, a normal map on 

<math display="inline" id="Normal_invariant:13">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

 (with respect to the tangent bundle) consists of</p>
<ul>
<li>a map 

<math display="inline" id="Normal_invariant:14">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mo>:</mo>
   <mrow>
    <mi>M</mi>
    <mo>→</mo>
    <mi>X</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>f</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>M</ci>
     <ci>X</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f\colon M\to X
  </annotation>
 </semantics>
</math>

 from some closed 

<math display="inline" id="Normal_invariant:15">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

-dimensional manifold 

<math display="inline" id="Normal_invariant:16">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

,</li>
<li>a bundle 

<math display="inline" id="Normal_invariant:17">
 <semantics>
  <mi>ξ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ξ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \xi
  </annotation>
 </semantics>
</math>

 over 

<math display="inline" id="Normal_invariant:18">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

, and a stable map from the stable <a href="tangent_bundle" title="wikilink">tangent bundle</a> 

<math display="inline" id="Normal_invariant:19">
 <semantics>
  <mrow>
   <msub>
    <mi>τ</mi>
    <mi>M</mi>
   </msub>
   <mo>⊕</mo>
   <msup>
    <mi>ε</mi>
    <mi>k</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">direct-sum</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>τ</ci>
     <ci>M</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ε</ci>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau_{M}\oplus\varepsilon^{k}
  </annotation>
 </semantics>
</math>

 of 

<math display="inline" id="Normal_invariant:20">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Normal_invariant:21">
 <semantics>
  <mi>ξ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ξ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \xi
  </annotation>
 </semantics>
</math>

, and</li>
<li>similarly as above it is required that the fundamental class of 

<math display="inline" id="Normal_invariant:22">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 should be mapped under 

<math display="inline" id="Normal_invariant:23">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 to the fundamental class of 

<math display="inline" id="Normal_invariant:24">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>



<math display="block" id="Normal_invariant:25">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>f</mi>
     <mo>*</mo>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>M</mi>
      <mo stretchy="false">]</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>X</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>∈</mo>
   <mrow>
    <msub>
     <mi>H</mi>
     <mi>n</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>f</ci>
       <times></times>
      </apply>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <ci>M</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>X</ci>
     </apply>
    </apply>
    <apply>
     <in></in>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>H</ci>
       <ci>n</ci>
      </apply>
      <ci>X</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{*}([M])=[X]\in H_{n}(X)
  </annotation>
 </semantics>
</math>

.</li>
</ul>

<p>Two normal maps are equivalent if there exists a normal bordism between them.</p>
<h2 id="role-in-surgery-theory">Role in surgery theory</h2>
<h3 id="surgery-on-maps-versus-surgery-on-normal-maps">Surgery on maps versus surgery on normal maps</h3>

<p>Consider the question:</p>
<dl>
<dd>Is the Poincaré complex <em>X</em> of formal dimension <em>n</em> homotopy-equivalent to a closed <em>n</em>-manifold?
</dd>
</dl>

<p>A naive surgery approach to this question would be: start with some map 

<math display="inline" id="Normal_invariant:26">
 <semantics>
  <mrow>
   <mi>M</mi>
   <mo>→</mo>
   <mi>X</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>M</ci>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M\to X
  </annotation>
 </semantics>
</math>

 from some manifold 

<math display="inline" id="Normal_invariant:27">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Normal_invariant:28">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

, and try to do surgery on it to make a homotopy equivalence out of it. Notice the following: Since our starting map was arbitrarily chosen, and surgery always produces cobordant maps, this procedure has to be performed (in the worst case) for all cobordism classes of maps 

<math display="inline" id="Normal_invariant:29">
 <semantics>
  <mrow>
   <mi>M</mi>
   <mo>→</mo>
   <mi>X</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>M</ci>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M\to X
  </annotation>
 </semantics>
</math>

. This kind of cobordism theory is a homology theory whose coefficients have been calculated by <a class="uri" href="Thom" title="wikilink">Thom</a>: therefore the cobordism classes of such maps are computable at least in theory for all spaces 

<math display="inline" id="Normal_invariant:30">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

.</p>

<p>However, it turns out that it is very difficult to decide whether it is possible to make a homotopy equivalence out of the map by means of surgery, whereas the same question is much easier when the map comes with the extra structure of a normal map. Therefore, in the classical surgery approach to our question, one starts with a normal map 

<math display="inline" id="Normal_invariant:31">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mo>:</mo>
   <mrow>
    <mi>M</mi>
    <mo>→</mo>
    <mi>X</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>f</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>M</ci>
     <ci>X</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f\colon M\to X
  </annotation>
 </semantics>
</math>

 (suppose there exists any), and performs surgery on it. This has several advantages:</p>
<ul>
<li>The map being of degree one implies that the homology of 

<math display="inline" id="Normal_invariant:32">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 splits as a direct sum of the homology of 

<math display="inline" id="Normal_invariant:33">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

 and the so-called <strong>surgery kernel</strong> 

<math display="inline" id="Normal_invariant:34">
 <semantics>
  <mrow>
   <msub>
    <mi>K</mi>
    <mo>*</mo>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>M</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mi>k</mi>
   <mi>e</mi>
   <mi>r</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>f</mi>
     <mo>*</mo>
    </msub>
    <mo>:</mo>
    <msub>
     <mi>H</mi>
     <mo>*</mo>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>M</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>→</mo>
    <msub>
     <mi>H</mi>
     <mo>*</mo>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>K</ci>
     <times></times>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">M</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">k</csymbol>
    <csymbol cd="unknown">e</csymbol>
    <csymbol cd="unknown">r</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <times></times>
     </apply>
     <ci>normal-:</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>H</ci>
      <times></times>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">M</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>H</ci>
      <times></times>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">X</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K_{*}(M)=ker(f_{*}\colon H_{*}(M)\to H_{*}(X))
  </annotation>
 </semantics>
</math>

, that is 

<math display="inline" id="Normal_invariant:35">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>H</mi>
     <mo>*</mo>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>M</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>K</mi>
      <mo>*</mo>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>M</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>⊕</mo>
    <mrow>
     <msub>
      <mi>H</mi>
      <mo>*</mo>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>X</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>H</ci>
      <times></times>
     </apply>
     <ci>M</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">direct-sum</csymbol>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>K</ci>
       <times></times>
      </apply>
      <ci>M</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>H</ci>
       <times></times>
      </apply>
      <ci>X</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{*}(M)=K_{*}(M)\oplus H_{*}(X)
  </annotation>
 </semantics>
</math>

. (Here we suppose that 

<math display="inline" id="Normal_invariant:36">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 induces an isomorphism of fundamental groups and use homology with local coefficients in 

<math display="inline" id="Normal_invariant:37">
 <semantics>
  <mrow>
   <mi>Z</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mrow>
     <msub>
      <mi>π</mi>
      <mn>1</mn>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>X</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>Z</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>π</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>X</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z[\pi_{1}(X)]
  </annotation>
 </semantics>
</math>

.)</li>
</ul>

<p>By <a href="Whitehead's_theorem" title="wikilink">Whitehead's theorem</a>, the map 

<math display="inline" id="Normal_invariant:38">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 is a homotopy equivalence if and only if the surgery kernel is zero.</p>
<ul>
<li>The bundle data implies the following: Suppose that an element 

<math display="inline" id="Normal_invariant:39">
 <semantics>
  <mrow>
   <mi>α</mi>
   <mo>∈</mo>
   <mrow>
    <msub>
     <mi>π</mi>
     <mrow>
      <mi>p</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>f</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>α</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>π</ci>
      <apply>
       <plus></plus>
       <ci>p</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>f</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha\in\pi_{p+1}(f)
  </annotation>
 </semantics>
</math>

 (the relative homotopy group of 

<math display="inline" id="Normal_invariant:40">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

) can be represented by an <a class="uri" href="embedding" title="wikilink">embedding</a> 

<math display="inline" id="Normal_invariant:41">
 <semantics>
  <mrow>
   <mi>ϕ</mi>
   <mo>:</mo>
   <mrow>
    <msup>
     <mi>S</mi>
     <mi>p</mi>
    </msup>
    <mo>→</mo>
    <mi>M</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>ϕ</ci>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>S</ci>
      <ci>p</ci>
     </apply>
     <ci>M</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi:S^{p}\to M
  </annotation>
 </semantics>
</math>

 (or more generally an <a class="uri" href="immersion" title="wikilink">immersion</a>) with a null-homotopy of 

<math display="inline" id="Normal_invariant:42">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mo>∘</mo>
    <mi>ϕ</mi>
   </mrow>
   <mo>:</mo>
   <mrow>
    <msup>
     <mi>S</mi>
     <mi>p</mi>
    </msup>
    <mo>→</mo>
    <mi>X</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <compose></compose>
     <ci>f</ci>
     <ci>ϕ</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>S</ci>
      <ci>p</ci>
     </apply>
     <ci>X</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f\circ\phi:S^{p}\to X
  </annotation>
 </semantics>
</math>

. Then it can be represented by an embedding (or immersion) whose normal bundle is stably trivial. This observation is important since surgery is only possible on embeddings with a trivial normal bundle. For example, if 

<math display="inline" id="Normal_invariant:43">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 is less than half the dimension of 

<math display="inline" id="Normal_invariant:44">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

, every map 

<math display="inline" id="Normal_invariant:45">
 <semantics>
  <mrow>
   <msup>
    <mi>S</mi>
    <mi>p</mi>
   </msup>
   <mo>→</mo>
   <mi>X</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>S</ci>
     <ci>p</ci>
    </apply>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S^{p}\to X
  </annotation>
 </semantics>
</math>

 is homotopic to an embedding by a theorem of <a class="uri" href="Whitney" title="wikilink">Whitney</a>. On the other hand, every stably trivial normal bundle of such an embedding is automatically trivial, since 

<math display="inline" id="Normal_invariant:46">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>π</mi>
     <mi>p</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>B</mi>
      <mi>O</mi>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mi>B</mi>
      <msub>
       <mi>O</mi>
       <mi>k</mi>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>π</ci>
      <ci>p</ci>
     </apply>
     <interval closure="open">
      <apply>
       <times></times>
       <ci>B</ci>
       <ci>O</ci>
      </apply>
      <apply>
       <times></times>
       <ci>B</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>O</ci>
        <ci>k</ci>
       </apply>
      </apply>
     </interval>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi_{p}(BO,BO_{k})=0
  </annotation>
 </semantics>
</math>

 for 

<math display="inline" id="Normal_invariant:47">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>></mo>
   <mi>p</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <ci>k</ci>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k>p
  </annotation>
 </semantics>
</math>

. Therefore, surgery on normal maps can always be done below the middle dimension. This is not true for arbitrary maps.</li>
</ul>

<p>Notice that this new approach makes it necessary to classify the bordism classes of normal maps, which are the normal invariants. Contrarily to cobordism classes of maps, the normal invariants are a <em>cohomology theory</em>. Its coefficients are known in the case of topological manifolds. For the case of smooth manifolds, the coefficients of the theory are much more complicated.</p>
<h3 id="normal-invariants-versus-structure-set">Normal invariants versus structure set</h3>

<p>There are two reasons why it is important to study the set 

<math display="inline" id="Normal_invariant:48">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">𝒩</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>𝒩</ci>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{N}(X)
  </annotation>
 </semantics>
</math>

. Recall that the main goal of surgery theory is to answer the questions:</p>

<p>1. Given a finite Poincaré complex 

<math display="inline" id="Normal_invariant:49">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

 is there an 

<math display="inline" id="Normal_invariant:50">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

-manifold homotopy equivalent to 

<math display="inline" id="Normal_invariant:51">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

?</p>

<p>2. Given two homotopy equivalences 

<math display="inline" id="Normal_invariant:52">
 <semantics>
  <mrow>
   <msub>
    <mi>f</mi>
    <mi>i</mi>
   </msub>
   <mo>:</mo>
   <mrow>
    <msub>
     <mi>M</mi>
     <mi>i</mi>
    </msub>
    <mo>→</mo>
    <mi>X</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>f</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>M</ci>
      <ci>i</ci>
     </apply>
     <ci>X</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{i}\colon M_{i}\rightarrow X
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Normal_invariant:53">
 <semantics>
  <mrow>
   <mi>i</mi>
   <mo>=</mo>
   <mrow>
    <mn>0</mn>
    <mo>,</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>i</ci>
    <list>
     <cn type="integer">0</cn>
     <cn type="integer">1</cn>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i=0,1
  </annotation>
 </semantics>
</math>

 is there a diffeomorphism 

<math display="inline" id="Normal_invariant:54">
 <semantics>
  <mrow>
   <mi>h</mi>
   <mo>:</mo>
   <mrow>
    <msub>
     <mi>M</mi>
     <mn>0</mn>
    </msub>
    <mo>→</mo>
    <msub>
     <mi>M</mi>
     <mn>1</mn>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>h</ci>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>M</ci>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>M</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h\colon M_{0}\rightarrow M_{1}
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Normal_invariant:55">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>f</mi>
     <mn>1</mn>
    </msub>
    <mo>∘</mo>
    <mi>h</mi>
   </mrow>
   <mo>≃</mo>
   <msub>
    <mi>f</mi>
    <mn>0</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">similar-to-or-equals</csymbol>
    <apply>
     <compose></compose>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>h</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>f</ci>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{1}\circ h\simeq f_{0}
  </annotation>
 </semantics>
</math>

?</p>

<p>Notice that if the answer to these questions should be positive then it is a necessary condition that the answer to the following two questions is positive</p>

<p>1.' Given a finite Poincaré complex 

<math display="inline" id="Normal_invariant:56">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

 is there a degree one normal map 

<math display="inline" id="Normal_invariant:57">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>f</mi>
    <mo>,</mo>
    <mi>b</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>:</mo>
   <mrow>
    <mi>M</mi>
    <mo>→</mo>
    <mi>X</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <interval closure="open">
     <ci>f</ci>
     <ci>b</ci>
    </interval>
    <apply>
     <ci>normal-→</ci>
     <ci>M</ci>
     <ci>X</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (f,b)\colon M\rightarrow X
  </annotation>
 </semantics>
</math>

?</p>

<p>2.' Given two homotopy equivalences 

<math display="inline" id="Normal_invariant:58">
 <semantics>
  <mrow>
   <msub>
    <mi>f</mi>
    <mi>i</mi>
   </msub>
   <mo>:</mo>
   <mrow>
    <msub>
     <mi>M</mi>
     <mi>i</mi>
    </msub>
    <mo>→</mo>
    <mi>X</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>f</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>M</ci>
      <ci>i</ci>
     </apply>
     <ci>X</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{i}\colon M_{i}\rightarrow X
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Normal_invariant:59">
 <semantics>
  <mrow>
   <mi>i</mi>
   <mo>=</mo>
   <mrow>
    <mn>0</mn>
    <mo>,</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>i</ci>
    <list>
     <cn type="integer">0</cn>
     <cn type="integer">1</cn>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i=0,1
  </annotation>
 </semantics>
</math>

 is there a normal cobordism 

<math display="inline" id="Normal_invariant:60">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>F</mi>
    <mo>,</mo>
    <mi>B</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>W</mi>
     <mo>,</mo>
     <mi>M</mi>
     <mo>,</mo>
     <msup>
      <mi>M</mi>
      <mo>′</mo>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>→</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>M</mi>
      <mo>×</mo>
      <mi>I</mi>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mi>M</mi>
      <mo>×</mo>
      <mn>0</mn>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mi>M</mi>
      <mo>×</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <interval closure="open">
     <ci>F</ci>
     <ci>B</ci>
    </interval>
    <apply>
     <ci>normal-→</ci>
     <vector>
      <ci>W</ci>
      <ci>M</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>M</ci>
       <ci>normal-′</ci>
      </apply>
     </vector>
     <vector>
      <apply>
       <times></times>
       <ci>M</ci>
       <ci>I</ci>
      </apply>
      <apply>
       <times></times>
       <ci>M</ci>
       <cn type="integer">0</cn>
      </apply>
      <apply>
       <times></times>
       <ci>M</ci>
       <cn type="integer">1</cn>
      </apply>
     </vector>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (F,B)\colon(W,M,M^{\prime})\to(M\times I,M\times 0,M\times 1)
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Normal_invariant:61">
 <semantics>
  <mrow>
   <mrow>
    <mo>∂</mo>
    <msub>
     <mi>F</mi>
     <mn>0</mn>
    </msub>
   </mrow>
   <mo>=</mo>
   <msub>
    <mi>f</mi>
    <mn>0</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <partialdiff></partialdiff>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>F</ci>
      <cn type="integer">0</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>f</ci>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \partial F_{0}=f_{0}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Normal_invariant:62">
 <semantics>
  <mrow>
   <mrow>
    <mo>∂</mo>
    <msub>
     <mi>F</mi>
     <mn>1</mn>
    </msub>
   </mrow>
   <mo>=</mo>
   <msub>
    <mi>f</mi>
    <mn>1</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <partialdiff></partialdiff>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>F</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>f</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \partial F_{1}=f_{1}
  </annotation>
 </semantics>
</math>

?</p>

<p>This is of course an almost trivial observation, but it is important because it turns out that there is an effective theory which answers question 1.' and also an effective theory which answers question 1. provided the answer to 1.' is yes. Similarly for questions 2. and 2.' Notice also that we can phrase the questions as follows:</p>

<p>1.' Is 

<math display="inline" id="Normal_invariant:63">
 <semantics>
  <mrow>
   <mrow>
    <mi class="ltx_font_mathcaligraphic">𝒩</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≠</mo>
   <mi mathvariant="normal">∅</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <neq></neq>
    <apply>
     <times></times>
     <ci>𝒩</ci>
     <ci>X</ci>
    </apply>
    <emptyset></emptyset>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{N}(X)\neq\emptyset
  </annotation>
 </semantics>
</math>

?</p>

<p>2.' Is 

<math display="inline" id="Normal_invariant:64">
 <semantics>
  <mrow>
   <msub>
    <mi>f</mi>
    <mn>0</mn>
   </msub>
   <mo>=</mo>
   <msub>
    <mi>f</mi>
    <mn>1</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>f</ci>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>f</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{0}=f_{1}
  </annotation>
 </semantics>
</math>

 in 

<math display="inline" id="Normal_invariant:65">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">𝒩</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>𝒩</ci>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{N}(X)
  </annotation>
 </semantics>
</math>

?</p>

<p>Hence studying 

<math display="inline" id="Normal_invariant:66">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">𝒩</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>𝒩</ci>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{N}(X)
  </annotation>
 </semantics>
</math>

 is really a first step in trying to understand the surgery structure set 

<math display="inline" id="Normal_invariant:67">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">𝒮</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>𝒮</ci>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{S}(X)
  </annotation>
 </semantics>
</math>

 which is the main goal in surgery theory. The point is that 

<math display="inline" id="Normal_invariant:68">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">𝒩</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>𝒩</ci>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{N}(X)
  </annotation>
 </semantics>
</math>

 is much more accessible from the point of view of algebraic topology as is explained below.</p>
<h2 id="homotopy-theory">Homotopy theory</h2>

<p>1.' Let <em>X</em> be a finite <em>n</em>-dimensional Poincaré complex. It is useful to use the definition of 

<math display="inline" id="Normal_invariant:69">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">𝒩</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>𝒩</ci>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{N}(X)
  </annotation>
 </semantics>
</math>

 with normal bundles. Recall that a (smooth) manifold has a unique tangent bundle and a unique stable normal bundle. But a finite Poincaré complex does not possess such a unique bundle. Nevertheless, it possesses a substitute - a unique in some sense spherical fibration - the so-called Spivak normal fibration. This has a property that if 

<math display="inline" id="Normal_invariant:70">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

 is homotopy equivalent to a manifold then the spherical fibration associated to the pullback of the normal bundle of that manifold is isomorphic to the Spivak normal fibration. So it follows that if 

<math display="inline" id="Normal_invariant:71">
 <semantics>
  <mrow>
   <mrow>
    <mi class="ltx_font_mathcaligraphic">𝒩</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≠</mo>
   <mi mathvariant="normal">∅</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <neq></neq>
    <apply>
     <times></times>
     <ci>𝒩</ci>
     <ci>X</ci>
    </apply>
    <emptyset></emptyset>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{N}(X)\neq\emptyset
  </annotation>
 </semantics>
</math>

 then the Spivak normal fibration has a bundle reduction. By the <a href="Pontrjagin-Thom_construction" title="wikilink">Pontrjagin-Thom construction</a> the converse is also true.</p>

<p>This can be formulated in terms of homotopy theory. Recall 

<math display="inline" id="Normal_invariant:72">
 <semantics>
  <mrow>
   <mi>B</mi>
   <mi>G</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>B</ci>
    <ci>G</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   BG
  </annotation>
 </semantics>
</math>

 the classifying space for stable spherical fibrations, 

<math display="inline" id="Normal_invariant:73">
 <semantics>
  <mrow>
   <mi>B</mi>
   <mi>O</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>B</ci>
    <ci>O</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   BO
  </annotation>
 </semantics>
</math>

 the classifying space for stable vector bundles and the map 

<math display="inline" id="Normal_invariant:74">
 <semantics>
  <mrow>
   <mi>J</mi>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mi>B</mi>
     <mi>O</mi>
    </mrow>
    <mo>→</mo>
    <mrow>
     <mi>B</mi>
     <mi>G</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>J</ci>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <times></times>
      <ci>B</ci>
      <ci>O</ci>
     </apply>
     <apply>
      <times></times>
      <ci>B</ci>
      <ci>G</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   J\colon BO\rightarrow BG
  </annotation>
 </semantics>
</math>

 which is induced by the inclusion 

<math display="inline" id="Normal_invariant:75">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mo>↪</mo>
   <mi>G</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-↪</ci>
    <ci>O</ci>
    <ci>G</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O\hookrightarrow G
  </annotation>
 </semantics>
</math>

 and which corresponds to taking the associated spherical fibration of a vector bundle. In fact we have a fibration sequence 

<math display="inline" id="Normal_invariant:76">
 <semantics>
  <mrow>
   <mrow>
    <mi>B</mi>
    <mi>O</mi>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mi>B</mi>
    <mi>G</mi>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mi>B</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>G</mi>
      <mo>/</mo>
      <mi>O</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <times></times>
      <ci>B</ci>
      <ci>O</ci>
     </apply>
     <apply>
      <times></times>
      <ci>B</ci>
      <ci>G</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>B</ci>
      <apply>
       <divide></divide>
       <ci>G</ci>
       <ci>O</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   BO\rightarrow BG\rightarrow B(G/O)
  </annotation>
 </semantics>
</math>

. The Spivak normal fibration is classified by a map 

<math display="inline" id="Normal_invariant:77">
 <semantics>
  <mrow>
   <msub>
    <mi>ν</mi>
    <mi>X</mi>
   </msub>
   <mo>:</mo>
   <mrow>
    <mi>X</mi>
    <mo>→</mo>
    <mrow>
     <mi>B</mi>
     <mi>G</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ν</ci>
     <ci>X</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <ci>X</ci>
     <apply>
      <times></times>
      <ci>B</ci>
      <ci>G</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \nu_{X}\colon X\rightarrow BG
  </annotation>
 </semantics>
</math>

. It has a vector bundle reduction if and only if 

<math display="inline" id="Normal_invariant:78">
 <semantics>
  <msub>
   <mi>ν</mi>
   <mi>X</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ν</ci>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \nu_{X}
  </annotation>
 </semantics>
</math>

 has a lift 

<math display="inline" id="Normal_invariant:79">
 <semantics>
  <mrow>
   <msub>
    <mover accent="true">
     <mi>ν</mi>
     <mo stretchy="false">~</mo>
    </mover>
    <mi>X</mi>
   </msub>
   <mo>:</mo>
   <mrow>
    <mi>X</mi>
    <mo>→</mo>
    <mrow>
     <mi>B</mi>
     <mi>O</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <ci>normal-~</ci>
      <ci>ν</ci>
     </apply>
     <ci>X</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <ci>X</ci>
     <apply>
      <times></times>
      <ci>B</ci>
      <ci>O</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tilde{\nu}_{X}\colon X\rightarrow BO
  </annotation>
 </semantics>
</math>

. This is equivalent to requiring that the composition 

<math display="inline" id="Normal_invariant:80">
 <semantics>
  <mrow>
   <mi>X</mi>
   <mo>→</mo>
   <mrow>
    <mi>B</mi>
    <mi>G</mi>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mi>B</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>G</mi>
      <mo>/</mo>
      <mi>O</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-→</ci>
     <ci>X</ci>
     <apply>
      <times></times>
      <ci>B</ci>
      <ci>G</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>B</ci>
      <apply>
       <divide></divide>
       <ci>G</ci>
       <ci>O</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X\rightarrow BG\rightarrow B(G/O)
  </annotation>
 </semantics>
</math>

 is null-homotopic.</p>

<p>Note that the homotopy groups of 

<math display="inline" id="Normal_invariant:81">
 <semantics>
  <mrow>
   <mi>B</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>G</mi>
     <mo>/</mo>
     <mi>O</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>B</ci>
    <apply>
     <divide></divide>
     <ci>G</ci>
     <ci>O</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B(G/O)
  </annotation>
 </semantics>
</math>

 are known in certain low-dimensions and are non-trivial which suggests the possibility that the above condition can fail for some 

<math display="inline" id="Normal_invariant:82">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

. There are in fact such finite Poincaré complexes, and the first example was obtained by <a href="Samuel_Gitler_Hammer" title="wikilink">Gitler</a> and <a href="Jim_Stasheff" title="wikilink">Stasheff</a>, yielding thus an example of a Poincaré complex not homotopy equivalent to a manifold.</p>

<p>2.' Relativizing the above considerations one obtains an (unnatural) bijection</p>

<p>

<math display="inline" id="Normal_invariant:83">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi class="ltx_font_mathcaligraphic">𝒩</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>X</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>≅</mo>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>X</mi>
     <mo>,</mo>
     <mrow>
      <mi>G</mi>
      <mo>/</mo>
      <mi>O</mi>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <apply>
     <times></times>
     <ci>𝒩</ci>
     <ci>X</ci>
    </apply>
    <interval closure="closed">
     <ci>X</ci>
     <apply>
      <divide></divide>
      <ci>G</ci>
      <ci>O</ci>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{N}(X)\cong[X,G/O].
  </annotation>
 </semantics>
</math>

</p>
<h2 id="different-categories">Different categories</h2>

<p>The above bijection gives 

<math display="inline" id="Normal_invariant:84">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">𝒩</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>𝒩</ci>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{N}(X)
  </annotation>
 </semantics>
</math>

 a structure of an abelian group since the space 

<math display="inline" id="Normal_invariant:85">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mo>/</mo>
   <mi>O</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <ci>G</ci>
    <ci>O</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G/O
  </annotation>
 </semantics>
</math>

 is a loop space and in fact an infinite loop space so the normal invariants are a zeroth cohomology group of an extraordinary cohomology theory defined by that inifinite loop space. Note that similar ideas apply in the other categories of manifolds and one has bijections</p>

<p>

<math display="block" id="Normal_invariant:86">
 <semantics>
  <mrow>
   <mrow>
    <mi class="ltx_font_mathcaligraphic">𝒩</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≅</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>X</mi>
    <mo>,</mo>
    <mrow>
     <mi>G</mi>
     <mo>/</mo>
     <mi>O</mi>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <apply>
     <times></times>
     <ci>𝒩</ci>
     <ci>X</ci>
    </apply>
    <interval closure="closed">
     <ci>X</ci>
     <apply>
      <divide></divide>
      <ci>G</ci>
      <ci>O</ci>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{N}(X)\cong[X,G/O]
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="Normal_invariant:87">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi class="ltx_font_mathcaligraphic">𝒩</mi>
     <mrow>
      <mi>P</mi>
      <mi>L</mi>
     </mrow>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≅</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>X</mi>
    <mo>,</mo>
    <mrow>
     <mrow>
      <mi>G</mi>
      <mo>/</mo>
      <mi>P</mi>
     </mrow>
     <mi>L</mi>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>𝒩</ci>
      <apply>
       <times></times>
       <ci>P</ci>
       <ci>L</ci>
      </apply>
     </apply>
     <ci>X</ci>
    </apply>
    <interval closure="closed">
     <ci>X</ci>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <ci>G</ci>
       <ci>P</ci>
      </apply>
      <ci>L</ci>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{N}^{PL}(X)\cong[X,G/PL]
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="Normal_invariant:88">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msup>
      <mi class="ltx_font_mathcaligraphic">𝒩</mi>
      <mrow>
       <mi>T</mi>
       <mi>O</mi>
       <mi>P</mi>
      </mrow>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>X</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>≅</mo>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>X</mi>
     <mo>,</mo>
     <mrow>
      <mrow>
       <mi>G</mi>
       <mo>/</mo>
       <mi>T</mi>
      </mrow>
      <mi>O</mi>
      <mi>P</mi>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>𝒩</ci>
      <apply>
       <times></times>
       <ci>T</ci>
       <ci>O</ci>
       <ci>P</ci>
      </apply>
     </apply>
     <ci>X</ci>
    </apply>
    <interval closure="closed">
     <ci>X</ci>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <ci>G</ci>
       <ci>T</ci>
      </apply>
      <ci>O</ci>
      <ci>P</ci>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{N}^{TOP}(X)\cong[X,G/TOP].
  </annotation>
 </semantics>
</math>

</p>

<p>It is well known that the spaces</p>

<p>

<math display="block" id="Normal_invariant:89">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mo>/</mo>
   <mi>O</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <ci>G</ci>
    <ci>O</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G/O
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Normal_invariant:90">
 <semantics>
  <mrow>
   <mrow>
    <mi>G</mi>
    <mo>/</mo>
    <mi>P</mi>
   </mrow>
   <mi>L</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <ci>G</ci>
     <ci>P</ci>
    </apply>
    <ci>L</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G/PL
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Normal_invariant:91">
 <semantics>
  <mrow>
   <mrow>
    <mi>G</mi>
    <mo>/</mo>
    <mi>T</mi>
   </mrow>
   <mi>O</mi>
   <mi>P</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <ci>G</ci>
     <ci>T</ci>
    </apply>
    <ci>O</ci>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G/TOP
  </annotation>
 </semantics>
</math>

</p>

<p>are mutually not homotopy equivalent and hence one obtains three different cohomology theories.</p>

<p>Sullivan analyzed the cases 

<math display="inline" id="Normal_invariant:92">
 <semantics>
  <mrow>
   <mrow>
    <mi>G</mi>
    <mo>/</mo>
    <mi>P</mi>
   </mrow>
   <mi>L</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <ci>G</ci>
     <ci>P</ci>
    </apply>
    <ci>L</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G/PL
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Normal_invariant:93">
 <semantics>
  <mrow>
   <mrow>
    <mi>G</mi>
    <mo>/</mo>
    <mi>T</mi>
   </mrow>
   <mi>O</mi>
   <mi>P</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <ci>G</ci>
     <ci>T</ci>
    </apply>
    <ci>O</ci>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G/TOP
  </annotation>
 </semantics>
</math>

. He showed that these spaces possess alternative inifinite loop space structures which are in fact better from the following point of view: Recall that there is a surgery obstruction map from normal invariants to the L-group. With the above described groups structure on the normal invariants this map is NOT a homomorphism. However, with the group structure from Sullivan's theorem it becomes a homomorphism in the categories 

<math display="inline" id="Normal_invariant:94">
 <semantics>
  <mrow>
   <mrow>
    <mi>C</mi>
    <mi>A</mi>
    <mi>T</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>P</mi>
    <mi>L</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>C</ci>
     <ci>A</ci>
     <ci>T</ci>
    </apply>
    <apply>
     <times></times>
     <ci>P</ci>
     <ci>L</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   CAT=PL
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="Normal_invariant:95">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mi>O</mi>
   <mi>P</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>T</ci>
    <ci>O</ci>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   TOP
  </annotation>
 </semantics>
</math>

. His theorem also links these new group structures to the well-known cohomology theories: the singular cohomology and real K-theory.</p>
<h2 id="references">References</h2>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Surgery_theory" title="wikilink">Category:Surgery theory</a></p>
</hr></body>
</html>
