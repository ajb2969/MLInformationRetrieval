   Lattice problem      Lattice problem   In computer science , lattice problems are a class of optimization problems on lattices . The conjectured intractability of such problems is central to construction of secure lattice-based  cryptosystems . For applications in such cryptosystems, lattices over vector spaces (often    ℚ  n     superscript  ℚ  n    \mathbb{Q}^{n}   ) or free modules (often    ℤ  n     superscript  ℤ  n    \mathbb{Z}^{n}   ) are generally considered.  For all the problems below, assume that we are given (in addition to other more specific inputs) a basis for the vector space V and a norm  N . The norms usually considered are L 2 . However, other norms (such as L p ) are also considered and show up in a variety of results. 1 Let    λ   (  L  )       λ  L    \lambda(L)   denote the length of the shortest non-zero vector in the lattice L , that is,       λ   (  L  )    =    min   v  ∈   L  ∖   {  𝟎  }        ∥  v  ∥   N          λ  L      subscript     v    L   0       subscript   norm  v   N      \lambda(L)=\min_{v\in L\setminus\{\mathbf{0}\}}\|v\|_{N}   .  Shortest vector problem (SVP)  In SVP, a basis of a vector space  V and a norm  N (often L 2 ) are given for a lattice L and one must find the shortest non-zero vector in V , as measured by N , in L . In other words, the algorithm should output a non-zero vector v such that     N   (  v  )    =   λ   (  L  )          N  v     λ  L     N(v)=\lambda(L)   .  In the   γ   γ   \gamma   -approximation version    S  V   P  γ       S  V   subscript  P  γ     SVP_{\gamma}   , one must find a non-zero lattice vector of length at most    γ  λ   (  L  )       γ  λ  L    \gamma\lambda(L)   .  Known results  The exact version of the problem is only known to be NP-hard for randomized reductions. 2 3  By contrast, the equivalent problem with respect to the uniform norm is known to be NP-hard  4  Approach techniques: Lenstra–Lenstra–Lovász lattice basis reduction algorithm produces a "relatively short vector" in polynomial time, but does not solve the problem. Kannan's HKZ basis reduction algorithm solves the problem in    n    n   2  e    +   o   (  n  )        superscript  n      n    2  e      o  n      n^{\frac{n}{2e}+o(n)}   time where n is the dimension. Lastly, Schnorr presented a technique that interpolates between LLL and HKZ called Block Reduction. Block reduction works with HKZ bases and if the number of blocks is chosen to be larger than the dimension, the resulting algorithm Kannan's full HKZ basis reduction.  GapSVP  The problem    G  a  p  S  V   P  β       G  a  p  S  V   subscript  P  β     GapSVP_{\beta}   consists of differentiating between the instances of SVP in which the answer is at most 1 or larger than   β   β   \beta   , where   β   β   \beta   can be a fixed function of   n   n   n   , the number of vectors. Given a basis for the lattice, the algorithm must decide whether     λ   (  L  )    ≤  1        λ  L   1    \lambda(L)\leq 1   or     λ   (  L  )    >  β        λ  L   β    \lambda(L)>\beta   . Like other promise problems , the algorithm is allowed to err on all other cases.  Yet another version of the problem is    G  a  p  S  V   P   ζ  ,  γ        G  a  p  S  V   subscript  P   ζ  γ      GapSVP_{\zeta,\gamma}   for some functions    ζ  ,  γ     ζ  γ    \zeta,\gamma   . The input to the algorithm is a basis   B   B   B   and a number   d   d   d   . It is assured that all the vectors in the Gram–Schmidt orthogonalization are of length at least 1, and that     λ   (   L   (  B  )    )    ≤   ζ   (  n  )          λ    L  B      ζ  n     \lambda(L(B))\leq\zeta(n)   and that    1  ≤  d  ≤     ζ   (  n  )    /  γ    (  n  )          1  d             ζ  n   γ   n      1\leq d\leq\zeta(n)/\gamma(n)   where   n   n   n   is the dimension. The algorithm must accept if     λ   (   L   (  B  )    )    ≤  d        λ    L  B    d    \lambda(L(B))\leq d   , and reject if      λ   (   L   (  B  )    )    ≥   γ   (  n  )     .  d     formulae-sequence      λ    L  B      γ  n    d    \lambda(L(B))\geq\gamma(n).d   . For large   ζ   ζ   \zeta   (     ζ   (  n  )    >   2   n  /  2          ζ  n    superscript  2    n  2      \zeta(n)>2^{n/2}   ), the problem is equivalent to    G  a  p  S  V   P  γ       G  a  p  S  V   subscript  P  γ     GapSVP_{\gamma}   because 5 a preprocessing done using the LLL algorithm makes the second condition (and hence,   ζ   ζ   \zeta   ) redundant.  Closest vector problem (CVP)  Image:Svp09.png|The SVP by example Image:Cvp3.png|The CVP by example  In CVP, a basis of a vector space V and a metric  M (often L 2 ) are given for a lattice L , as well as a vector v in V but not necessarily in L . It is desired to find the vector in L closest to v (as measured by M ). In the   γ   γ   \gamma   -approximation version    C  V   P  γ       C  V   subscript  P  γ     CVP_{\gamma}   , one must find a lattice vector at distance at most   γ   γ   \gamma   .  Relationship with SVP  The closest vector problem is a generalization of the shortest vector problem. It is easy to show that given an oracle for    C  V   P  γ       C  V   subscript  P  γ     CVP_{\gamma}   (defined below), one can solve    S  V   P  γ       S  V   subscript  P  γ     SVP_{\gamma}   by making some queries to the oracle. 6 The naive method to find the shortest vector by calling the    C  V   P  γ       C  V   subscript  P  γ     CVP_{\gamma}   oracle to find the closest vector to 0 does not work because 0 is itself a lattice vector and the algorithm could potentially output 0.  The reduction from    S  V   P  γ       S  V   subscript  P  γ     SVP_{\gamma}   to    C  V   P  γ       C  V   subscript  P  γ     CVP_{\gamma}   is as follows: Suppose that the input to the    S  V   P  γ       S  V   subscript  P  γ     SVP_{\gamma}   problem is the basis for lattice    B  =   [   b  1   ,   b  2   ,  …  ,   b  n   ]       B    subscript  b  1    subscript  b  2   normal-…   subscript  b  n      B=[b_{1},b_{2},\ldots,b_{n}]   . Consider the basis     B  i   =   [   b  1   ,  …  ,   2   b  i    ,  …  ,   b  n   ]        superscript  B  i     subscript  b  1   normal-…    2   subscript  b  i    normal-…   subscript  b  n      B^{i}=[b_{1},\ldots,2b_{i},\ldots,b_{n}]   and let    x  i     subscript  x  i    x_{i}   be the vector returned by    C  V   P  γ    (   B  i   ,   b  i   )       C  V   subscript  P  γ     superscript  B  i    subscript  b  i      CVP_{\gamma}(B^{i},b_{i})   . The claim is that the shortest vector in the set    {    x  i   -   b  i    }        subscript  x  i    subscript  b  i      \{x_{i}-b_{i}\}   is the shortest vector in the given lattice.  Known results  Goldreich et al. showed that any hardness of SVP implies the same hardness for CVP. 7 Using PCP tools, Arora et al. showed that CVP is hard to approximate within factor    2    log   1  -  ϵ     (  n  )       superscript  2    superscript     1  ϵ    n     2^{\log^{1-\epsilon}(n)}   unless    NP  ⊆   DTIME   (   2   p  o  l  y   (   log  n   )     )        NP   DTIME   superscript  2    p  o  l  y    n        \operatorname{NP}\subseteq\operatorname{DTIME}(2^{poly(\log n)})   . 8 Dinur et al. strengthened this by giving a NP-hardness result with    ϵ  =    (   log   log  n    )   c       ϵ   superscript      n    c     \epsilon=(\log\log n)^{c}   for    c  <   1  /  2       c    1  2     c<1/2   . 9  Sphere decoding  The algorithm for CVP, especially the Fincke and Pohst variant, 10 have been used for data detection in multiple-input multiple-output ( MIMO ) wireless communication systems (for coded and uncoded signals). 11 12 In this context it is called sphere decoding due to the radius used internal to many CVP solutions. 13  It has been applied in the field of the integer ambiguity resolution of carrier-phase GNSS (GPS). 14 It is called LAMBDA method in that field.  GapCVP  This problem is similar to the GapSVP problem. For    G  a  p  C  V   P  β       G  a  p  C  V   subscript  P  β     GapCVP_{\beta}   , the input consists of a lattice basis and a vector   v   v   v   and the algorithm must answer whether   there is a lattice vector such that the distance between it and   v   v   v   is at most 1.  every lattice vector is at a distance greater than   β   β   \beta   away from   v   v   v   .   Known results  The problem is trivially contained in NP for any approximation factor.  Schnorr , in 1987, showed that deterministic polynomial time algorithms can solve the problem for    β  =   2   O   (    n    (   log   log  n    )   2    /   log  n    )         β   superscript  2    O      n   superscript      n    2      n        \beta=2^{O(n(\log\log n)^{2}/\log n)}   . 15 Ajtai et al. showed that probabilistic algorithms can achieve a slightly better approximation factor of    β  =   2   O   (   n   log   log   n  /   log  n       )         β   superscript  2    O    n        n    n           \beta=2^{O(n\log\log n/\log n)}   . 16  In 1993, Banaszczyk showed that    G  a  p  C  V   P  n       G  a  p  C  V   subscript  P  n     GapCVP_{n}   is in     N  P   ∩   c  o  N  P         N  P     c  o  N  P     NP\cap coNP   . 17 In 2000, Goldreich and Goldwasser showed that    β  =    n  /   log  n         β      n    n       \beta=\sqrt{n/\log n}   puts the problem in both NP and coAM . 18 In 2005, Aharonov and Regev showed that for some constant   c   c   c   , the problem with    β  =   c   n        β    c    n      \beta=c\sqrt{n}   is in     N  P   ∩   c  o  N  P         N  P     c  o  N  P     NP\cap coNP   . 19  For lower bounds, Dinur et al. showed in 1998 that the problem is NP-hard for    β  =   n   o   (   1  /   log   log  n     )         β   superscript  n    o    1      n         \beta=n^{o(1/\log{\log{n}})}   . 20  Shortest independent vectors problem (SIVP)  Given a lattice L of dimension n, the algorithm must output n linearly independent      v  1   ,   v  2   ,  …  ,   v  n       subscript  v  1    subscript  v  2   normal-…   subscript  v  n     v_{1},v_{2},\ldots,v_{n}   so that     max   ∥   v  i   ∥    <    max  B    ∥   b  i   ∥           norm   subscript  v  i       subscript   B    norm   subscript  b  i       \max\|v_{i}\|<\max_{B}\|b_{i}\|   where the right hand side considers all basis    B  =   {   b  1   ,  …  ,   b  n   }       B    subscript  b  1   normal-…   subscript  b  n      B=\{b_{1},\ldots,b_{n}\}   of the lattice.  In the   γ   γ   \gamma   -approximate version, given a lattice L with dimension n, find n linearly independent vectors     v  1   ,   v  2   ,  …  ,   v  n       subscript  v  1    subscript  v  2   normal-…   subscript  v  n     v_{1},v_{2},\ldots,v_{n}   of length max ||    v  i     subscript  v  i    v_{i}   || ≤    γ   λ  n    (  L  )       γ   subscript  λ  n   L    \gamma\lambda_{n}(L)   , where     λ  n    (  L  )        subscript  λ  n   L    \lambda_{n}(L)   is the   n   n   n   'th successive minimum of   L   L   L   .  Bounded distance decoding  This problem is similar to CVP. Given a vector such that its distance from the lattice is at most     λ   (  L  )    /  2        λ  L   2    \lambda(L)/2   , the algorithm must output the closest lattice vector to it.  Covering radius problem  Given a basis for the lattice, the algorithm must find the largest distance (or in some versions, its approximation) from any vector to the lattice.  Shortest basis problem  Many problems become easier if the input basis consists of short vectors. An algorithm that solves the Shortest Basis Problem (SBP) must, given a lattice basis   B   B   B   , output an equivalent basis    B  ′     superscript  B  normal-′    B^{\prime}   such that the length of the longest vector in    B  ′     superscript  B  normal-′    B^{\prime}   is as short as possible.  The approximation version    S  B   P  γ       S  B   subscript  P  γ     SBP_{\gamma}   problem consist of finding a basis whose longest vector is at most   γ   γ   \gamma   times longer than the longest vector in the shortest basis.  Use in cryptography  Average case hardness of problems forms a basis for proofs-of-security for most cryptographic schemes. However, experimental evidence suggests that most NP-hard problems lack this property: they are probably only worst case hard. Many lattice problems have been conjectured or proven to be average-case hard, making them an attractive class of problems to base cryptographic schemes on. Moreover, worst-case hardness of some lattice problems have been used to create secure cryptographic schemes. The use of worst-case hardness in such schemes makes them among the very few schemes that are very likely secure even against quantum computers .  The above lattice problems are easy to solve if the algorithm is provided with a "good" basis. Lattice reduction algorithms aim, given a basis for a lattice, to output a new basis consisting of relatively short, nearly orthogonal vectors. The Lenstra–Lenstra–Lovász lattice basis reduction algorithm (LLL) was an early efficient algorithm for this problem which could output an almost reduced lattice basis in polynomial time. 21 This algorithm and its further refinements were used to break several cryptographic schemes, establishing its status as a very important tool in cryptanalysis. The success of LLL on experimental data led to a belief that lattice reduction might be an easy problem in practice. However, this belief was challenged when in the late 1990s, several new results on the hardness of lattice problems were obtained, starting with the result of Ajtai . 22  In his seminal papers, Ajtai showed that the SVP problem was NP-hard and discovered some connections between the worst-case complexity and average-case complexity of some lattice problems. 23 24 Building on these results, Ajtai and Dwork created a public-key cryptosystem whose security could be proven using only the worst case hardness of a certain version of SVP, 25 thus making it the first result to have used worst-case hardness to create secure systems. 26  See also   Learning with errors   References  Further reading       "  Category:Computational hardness assumptions  Category:Lattice-based cryptography  Category:Mathematical problems     ↩   ↩  ↩  ↩  ↩  ↩  ↩  ↩  ↩  ↩  ↩  ↩  ↩  ↩  ↩  ↩  ↩  ↩  ↩  ↩  ↩   ↩  ↩  ↩     