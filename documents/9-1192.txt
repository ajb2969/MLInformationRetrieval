   History monoid      History monoid   In mathematics and computer science , a history monoid is a way of representing the histories of concurrently running computer processes as a collection of strings , each string representing the individual history of a process. The history monoid provides a set of synchronization primitives (such as locks , mutexes or thread joins ) for providing rendezvous points between a set of independently executing processes or threads .  History monoids occur in the theory of concurrent computation , and provide a low-level mathematical foundation for process calculi , such as CSP the language of communicating sequential processes , or CCS, the calculus of communicating systems . History monoids were first presented by M.W. Shields. 1  History monoids are isomorphic to trace monoids (free partially commutative monoids) and to the monoid of dependency graphs . As such, they are free objects and are universal . The history monoid is a type of semi-abelian categorical product in the category of monoids.  Product monoids and projection  Let      A  =   (   Œ£  1   ,   Œ£  2   ,  ‚Ä¶  ,   Œ£  n   )       A    subscript  normal-Œ£  1    subscript  normal-Œ£  2   normal-‚Ä¶   subscript  normal-Œ£  n      A=(\Sigma_{1},\Sigma_{2},\ldots,\Sigma_{n})     denote an n -tuple of alphabets     Œ£  k     subscript  normal-Œ£  k    \Sigma_{k}   . Let    P   (  A  )       P  A    P(A)   denote all possible combinations of finite-length strings from the alphabets:       P   (  A  )    =    Œ£  1  *   √ó   Œ£  2  *   √ó  ‚ãØ  √ó   Œ£  n  *          P  A      superscript   subscript  normal-Œ£  1      superscript   subscript  normal-Œ£  2     normal-‚ãØ   superscript   subscript  normal-Œ£  n        P(A)=\Sigma_{1}^{*}\times\Sigma_{2}^{*}\times\cdots\times\Sigma_{n}^{*}     (In more formal language,    P   (  A  )       P  A    P(A)   is the Cartesian product of the free monoids of the    Œ£  k     subscript  normal-Œ£  k    \Sigma_{k}   . The superscript star is the Kleene star .) Composition in the product monoid is component-wise, so that, for      ùï¶  =   (   u  1   ,   u  2   ,  ‚Ä¶  ,   u  n   )       ùï¶    subscript  u  1    subscript  u  2   normal-‚Ä¶   subscript  u  n      \mathbb{u}=(u_{1},u_{2},\ldots,u_{n})\,     and      ùïß  =   (   v  1   ,   v  2   ,  ‚Ä¶  ,   v  n   )       ùïß    subscript  v  1    subscript  v  2   normal-‚Ä¶   subscript  v  n      \mathbb{v}=(v_{1},v_{2},\ldots,v_{n})\,     then       ùï¶  ùïß   =   (    u  1    v  1    ,    u  2    v  2    ,  ‚Ä¶  ,    u  n    v  n    )         ùï¶  ùïß       subscript  u  1    subscript  v  1       subscript  u  2    subscript  v  2    normal-‚Ä¶     subscript  u  n    subscript  v  n       \mathbb{uv}=(u_{1}v_{1},u_{2}v_{2},\ldots,u_{n}v_{n})\,     for all    ùï¶  ,  ùïß     ùï¶  ùïß    \mathbb{u},\mathbb{v}   in    P   (  A  )       P  A    P(A)   . Define the union alphabet to be       Œ£  =    Œ£  1   ‚à™   Œ£  2   ‚à™  ‚ãØ  ‚à™   Œ£  n     .      normal-Œ£     subscript  normal-Œ£  1    subscript  normal-Œ£  2   normal-‚ãØ   subscript  normal-Œ£  n      \Sigma=\Sigma_{1}\cup\Sigma_{2}\cup\cdots\cup\Sigma_{n}.\,     (The union here is the set union , not the disjoint union .) Given any string    w  ‚àà   Œ£  *       w   superscript  normal-Œ£      w\in\Sigma^{*}   , we can pick out just the letters in some    Œ£  k  *     superscript   subscript  normal-Œ£  k      \Sigma_{k}^{*}   using the corresponding string projection      œÄ  k   :    Œ£  *   ‚Üí   Œ£  k  *       normal-:   subscript  œÄ  k    normal-‚Üí   superscript  normal-Œ£     superscript   subscript  normal-Œ£  k        \pi_{k}:\Sigma^{*}\to\Sigma_{k}^{*}   . A distribution     œÄ  :    Œ£  *   ‚Üí   P   (  A  )        normal-:  œÄ   normal-‚Üí   superscript  normal-Œ£      P  A      \pi:\Sigma^{*}\to P(A)   is the mapping that operates on    w  ‚àà   Œ£  *       w   superscript  normal-Œ£      w\in\Sigma^{*}   with all of the    œÄ  k     subscript  œÄ  k    \pi_{k}   , separating it into components in each free monoid:        œÄ   (  w  )    ‚Ü¶   (    œÄ  1    (  w  )    ,    œÄ  2    (  w  )    ,  ‚Ä¶  ,    œÄ  n    (  w  )    )    .     maps-to    œÄ  w       subscript  œÄ  1   w      subscript  œÄ  2   w   normal-‚Ä¶     subscript  œÄ  n   w      \pi(w)\mapsto(\pi_{1}(w),\pi_{2}(w),\ldots,\pi_{n}(w)).\,     Histories  For every    a  ‚àà  Œ£      a  normal-Œ£    a\in\Sigma   , the tuple    œÄ   (  a  )       œÄ  a    \pi(a)   is called the elementary history of a . It serves as an indicator function for the inclusion of a letter a in an alphabet    Œ£  k     subscript  normal-Œ£  k    \Sigma_{k}   . That is,       œÄ   (  a  )    =   (   a  1   ,   a  2   ,  ‚Ä¶  ,   a  n   )         œÄ  a     subscript  a  1    subscript  a  2   normal-‚Ä¶   subscript  a  n      \pi(a)=(a_{1},a_{2},\ldots,a_{n})     where       a  k   =   {       a  if  a   ‚àà   Œ£  k           Œµ  otherwise   .             subscript  a  k    cases      a  if  a    subscript  normal-Œ£  k    otherwise    Œµ  otherwise   otherwise     a_{k}=\begin{cases}a\mbox{ if }a\in\Sigma_{k}\\
 \varepsilon\mbox{ otherwise }.\end{cases}     Here,   Œµ   Œµ   \varepsilon   denotes the empty string . The history monoid     H   (  A  )       H  A    H(A)   is the submonoid of the product monoid    P   (  A  )       P  A    P(A)   generated by the elementary histories. The elements of    H   (  A  )       H  A    H(A)   are called global histories , and the projections of a global history are called individual histories .  Connection to computer science  The use of the word history in this context, and the connection to concurrent computing, can be understood as follows. An individual history is a record of the sequence of states of a process (or thread or machine ); the alphabet    Œ£  k     subscript  normal-Œ£  k    \Sigma_{k}   is the set of states of the process.  A letter that occurs in two or more alphabets serves as a synchronization primitive between the various individual histories. That is, if such a letter occurs in one individual history, it must also occur in another history, and serves to "tie" or "rendezvous" them together.  Consider, for example,     Œ£  1   =   {  a  ,  b  ,  c  }        subscript  normal-Œ£  1    a  b  c     \Sigma_{1}=\{a,b,c\}   and     Œ£  2   =   {  a  ,  d  ,  e  }        subscript  normal-Œ£  2    a  d  e     \Sigma_{2}=\{a,d,e\}   . The union alphabet is of course    Œ£  =   {  a  ,  b  ,  c  ,  d  ,  e  }       normal-Œ£   a  b  c  d  e     \Sigma=\{a,b,c,d,e\}   . The elementary histories are    (  a  ,  a  )     a  a    (a,a)   ,    (  b  ,  Œµ  )     b  Œµ    (b,\varepsilon)   ,    (  c  ,  Œµ  )     c  Œµ    (c,\varepsilon)   ,    (  Œµ  ,  d  )     Œµ  d    (\varepsilon,d)   and    (  Œµ  ,  e  )     Œµ  e    (\varepsilon,e)   . In this example, an individual history of the first process might be    b  c  b  c  c      b  c  b  c  c    bcbcc   while the individual history of the second machine might be    d  d  d  e  d      d  d  d  e  d    ddded   . Both of these individual histories are represented by the global history    b  c  b  d  d  d  c  c  e  d      b  c  b  d  d  d  c  c  e  d    bcbdddcced   , since the projection of this string onto the individual alphabets yields the individual histories. In the global history, the letter   b   b   b   can be considered to commute with the letters   d   d   d   and   e   e   e   , in that these can be rearranged without changing the individual histories. Such commutation is simply a statement that the first and second processes are running concurrently, and are unordered with respect to each other; they have not (yet) exchanged any messages or performed any synchronization.  The letter   a   a   a   serves as a synchronization primitive, as its occurrence marks a spot in both the global and individual histories, that cannot be commuted across. Thus, while the letters   b   b   b   and   c   c   c   can be re-ordered past   d   d   d   and   e   e   e   , they cannot be reordered past   a   a   a   . Thus, the global history    b  c  d  a  b  e      b  c  d  a  b  e    bcdabe   and the global history    b  d  c  a  e  b      b  d  c  a  e  b    bdcaeb   both have as individual histories    b  c  a  b      b  c  a  b    bcab   and    d  a  e      d  a  e    dae   , indicating that the execution of   d   d   d   may happen before or after   c   c   c   . However, the letter   a   a   a   is synchronizing, so that   e   e   e   is guaranteed to happen after   c   c   c   , even though   e   e   e   is in a different process than   c   c   c   .  Properties  The history monoid is isomorphic to the trace monoid , and as such, is a type of semi-abelian categorical product in the category of monoids. In particular, the history monoid    H   (   Œ£  1   ,   Œ£  2   ,  ‚Ä¶  ,   Œ£  n   )       H    subscript  normal-Œ£  1    subscript  normal-Œ£  2   normal-‚Ä¶   subscript  normal-Œ£  n      H(\Sigma_{1},\Sigma_{2},\ldots,\Sigma_{n})   is isomorphic to the trace monoid    ùïÑ   (  D  )       ùïÑ  D    \mathbb{M}(D)   with the dependency relation given by       D  =    (    Œ£  1   √ó   Œ£  1    )   ‚à™   (    Œ£  2   √ó   Œ£  2    )   ‚à™  ‚ãØ  ‚à™   (    Œ£  n   √ó   Œ£  n    )     .      D       subscript  normal-Œ£  1    subscript  normal-Œ£  1       subscript  normal-Œ£  2    subscript  normal-Œ£  2    normal-‚ãØ     subscript  normal-Œ£  n    subscript  normal-Œ£  n       D=\left(\Sigma_{1}\times\Sigma_{1}\right)\cup\left(\Sigma_{2}\times\Sigma_{2}%
 \right)\cup\cdots\cup\left(\Sigma_{n}\times\Sigma_{n}\right).     In simple terms, this is just the formal statement of the informal discussion given above: the letters in an alphabet    Œ£  k     subscript  normal-Œ£  k    \Sigma_{k}   can be commutatively re-ordered past the letters in an alphabet    Œ£  j     subscript  normal-Œ£  j    \Sigma_{j}   , unless they are letters that occur in both alphabets. Thus, traces are exactly global histories, and vice versa.  Notes    References   Antoni Mazurkiewicz, "Introduction to Trace Theory", pp 3‚Äì41, in The Book of Traces , V. Diekert, G. Rozenberg, eds. (1995) World Scientific, Singapore ISBN 981-02-2058-8  Volker Diekert, Yves M√©tivier, " Partial Commutation and Traces ", In G. Rozenberg and A. Salomaa, editors, Handbook of Formal Languages , Vol. 3 , Beyond Words, pages 457‚Äì534. Springer-Verlag, Berlin, 1997.   "  Category:Concurrency (computer science)  Category:Semigroup theory  Category:Formal languages  Category:Free algebraic structures     M.W. Shields "Concurrent Machines", Computer Journal , (1985) 28 pp.¬†449‚Äì465. ‚Ü©     