   Constructing skill trees      Constructing skill trees   Constructing skill trees (CST) is a hierarchical reinforcement learning algorithm which can build skill trees from a set of sample solution trajectories obtained from demonstration. CST uses an incremental MAP( maximum a posteriori ) change point detection algorithm to segment each demonstration trajectory into skills and integrate the results into a skill tree. CST was introduced by George Konidaris , Scott Kuindersma , Andrew Barto and Roderic Grupen in 2010.  Algorithm  CST consists of mainly three parts;change point detection, alignment and merging. The main focus of CST is online change-point detection. The change-point detection algorithm is used to segment data into skills and uses the sum of discounted reward    R  t     subscript  R  t    R_{t}   as the target regression variable. Each skill is assigned an appropriate abstraction. A particle filter is used to control the computational complexity of CST.  The change point detection algorithm is implemented as follows. The data for times    t  ∈  T      t  T    t\in T   and models Q with prior    p   (  q  ∈  Q  )      fragments  p   fragments  normal-(  q   Q  normal-)     p(q\in Q)   are given. The algorithm is assumed to be able to fit a segment from time    j  +  1      j  1    j+1   to   t   t   t   using model   q   q   q   with the fit probability    P   (  j  ,  t  ,  q  )       P   j  t  q     P(j,t,q)   . A linear regression model with Gaussian noise is used to compute    P   (  j  ,  t  ,  q  )       P   j  t  q     P(j,t,q)   . The Gaussian noise prior has mean zero, and variance which follows    I  n  v  e  r  s  e  G  a  m  m  a   (   v  2   ,   u  2   )       I  n  v  e  r  s  e  G  a  m  m  a     v  2     u  2      InverseGamma(\frac{v}{2},\frac{u}{2})   . The prior for each weight follows    N  o  r  m  a  l   (  0  ,    σ  2   δ   )       N  o  r  m  a  l   0     superscript  σ  2   δ      Normal(0,\sigma^{2}\delta)   .  The fit probability    P   (  j  ,  t  ,  q  )       P   j  t  q     P(j,t,q)   is computed by the following equation.       P   (  j  ,  t  ,  q  )    =     π   -   n  2      δ  m      |    (   A  +  D   )    -  1    |    1  2      u   v  2      (   y  +  u   )     u  +  v   2       Γ   (    n  +  v   2   )     Γ   (   v  2   )            P   j  t  q         superscript  π      n  2      superscript  δ  m     superscript     superscript    A  D     1       1  2       superscript  u    v  2     superscript    y  u       u  v   2         normal-Γ      n  v   2      normal-Γ    v  2        P(j,t,q)=\frac{\pi^{-\frac{n}{2}}}{\delta^{m}}\left|(A+D)^{-1}\right|^{\frac{1%
 }{2}}\frac{u^{\frac{v}{2}}}{(y+u)^{\frac{u+v}{2}}}\frac{\Gamma(\frac{n+v}{2})}%
 {\Gamma({\frac{v}{2}})}     Then, CST compute the probability of the changepoint at time j with model q,     P  t    (  j  ,  q  )        subscript  P  t    j  q     P_{t}(j,q)   and    P  j   M  A  P      subscript   superscript  P    M  A  P    j    P^{MAP}_{j}   using an Viterbi algorithm .        P  t    (  j  ,  q  )    =    (   1  -   G   (   t  -  j  -  1   )     )   P   (  j  ,  t  ,  q  )   p   (  q  )    P  j   M  A  P            subscript  P  t    j  q        1    G    t  j  1     P   j  t  q   p  q   subscript   superscript  P    M  A  P    j      P_{t}(j,q)=(1-G(t-j-1))P(j,t,q)p(q)P^{MAP}_{j}       Φ   (   x  i   )       normal-Φ   subscript  x  i     \Phi(x_{i})       x  i     subscript  x  i    x_{i}   : a vector of m basis functions evaluated at state    y  =    (    ∑   i  =  j   t    R  i  2    )   -    b  T     (   A  +  D   )    -  1    b        y      subscript   superscript   t     i  j     subscript   superscript  R  2   i       superscript  b  T    superscript    A  D     1    b      y=(\sum^{t}_{i=j}R^{2}_{i})-b^{T}(A+D)^{-1}b       b  =    ∑   i  =  j   t     R  i   Φ   (   x  i   )         b    subscript   superscript   t     i  j       subscript  R  i   normal-Φ   subscript  x  i       b=\sum^{t}_{i=j}R_{i}\Phi(x_{i})        R  i   =    ∑   j  =  i   T     γ   j  -  i     r  j          subscript  R  i     subscript   superscript   T     j  i       superscript  γ    j  i     subscript  r  j       R_{i}=\sum^{T}_{j=i}\gamma^{j-i}r_{j}      Γ   normal-Γ   \Gamma       n  =   t  -  j       n    t  j     n=t-j   : Gamma function     m   m   m      D   D   D   : The number of basis functions q has.      δ   -  1      superscript  δ    1     \delta^{-1}   : an m by m matrix with   l   l   l   on the diagonal and zeros else where  The skill length     g   (  l  )    =     (   1  -  p   )    l  -  1    p         g  l      superscript    1  p     l  1    p     g(l)=(1-p)^{l-1}p   is assumed to follow a Geometric distribution with parameter p       G   (  l  )    =   (   1  -    (   1  -  p   )   l    )         G  l     1   superscript    1  p   l      G(l)=(1-(1-p)^{l})       p  =   1  k       p    1  k     p=\frac{1}{k}       k  :      normal-:  k  absent    k:       O   (   N  L   )       O    N  L     O(NL)   Expected skill length  Using the method above, CST can segment data into a skill chain. The time complexity of the change point detection is    O   (   N  c   )       O    N  c     O(Nc)   and storage size is   N   N   N   , where   L   L   L   is the number of particles,    P   (  j  ,  t  ,  q  )       P   j  t  q     P(j,t,q)   is the time of computing    O   (  c  )       O  c    O(c)   , and there are    P   (  j  ,  t  ,  q  )       P   j  t  q     P(j,t,q)   change points.  Next step is alignment. CST needs to align the component skills because the change-point does not occur in the exactly same places. Thus, when segmenting second trajectory after segmenting the first trajectory, it has a bias on the location of change point in the second trajectory. This bias follows a mixture of gaussians.  The last step is merging. CST merges skill chains into a skill tree. CST merges a pair of trajectory segments by allocating the same skill. All trajectories have the same goal and it merges two chains by starting at their final segments. If two segments are statistically similar, it merges them. This procedure is repeated until it fails to merge a pair of skill segments.    p  ∈   p  a  r  t  i  c  l  e  s       p    p  a  r  t  i  c  l  e  s     p\in particles   are used to determine whether a pair of trajectories are modeled better as one skill or as two different skills.  Pseudocode  The following pseudocode describes the change point detection algorithm:  particles = [];  Process each incoming data point  for t=1:T  //Compute fit probabilities for all particles  for     max  p     subscript   p    \max_{p}      p_tjq=(1-G(t-p.pos-1))*p.fit_prob*model_prior(p.model)*p.prev_MAP  p.MAP=p_tjq*g(t-p.pos)/(1-G(t-p.pos-1))  end  //Filter if necessary  if the number of particles >= N  particles=particle_filter(p.MAP, M)  end  //Determine the Viterbi path  for t==1  max_path=[]  max_MAP=1/|Q|  else  max_particle=    ∪     \cup    p.MAP  max_path=max_particle.path     q  ∈  Q      q  Q    q\in Q    max_particle  max_MAP=max_particle.MAP  end  //Create new particles for a changepoint at time t  for    ∪     \cup     new_p=create_particle(model=q, pos=t, prev_MAP=max_MAP, path=max_path)  p=p     p  ∈  P      p  P    p\in P    new_p  end  //Update all particles  for     Φ  t     subscript  normal-Φ  t    \Phi_{t}     particles=update_particle(current_state, current_reward,p)  end  end  //Return the most likely path to the final point  return max_path  function update_particle(current_state, current_reward, particle);  p=particle  r_t=current_reward  //Initialization  if t==0  p.A=zero matrix(p.m,p.m)  p.b=zero vector(p.m)  p.z=zero vector(p.m)  p.sum r=0  p.tr1=0  p.tr2=0  end  //Compute the basis function vector for the current state      Φ   normal-Φ   \Phi    =p.      Φ  t    Φ  t  T        subscript  normal-Φ  t    superscript   subscript  normal-Φ  t   T     \Phi_{t}\Phi_{t}^{T}    (current state)  //Update sufficient statistics  p.A=p.A+    γ   γ   \gamma     p.z=     Φ  t     subscript  normal-Φ  t    \Phi_{t}    p.z+     r  t     subscript  r  t    r_{t}     p.b=p.b+     γ  2     superscript  γ  2    \gamma^{2}    p.z  p.tr1=1+     r  t  2     superscript   subscript  r  t   2    r_{t}^{2}    p.tr1  p.sum r=sum p.r+     γ   r  t       γ   subscript  r  t     \gamma r_{t}    p.tr1+2    γ   γ   \gamma    p.tr2  p.tr2=     r  t     subscript  r  t    r_{t}    p.tr2+    γ   γ   \gamma    p.tr1  p.fit_prob=compute_fit_prob(p,v,u,delta, $\gamma$ )  Assumptions  CTS assume that the demonstrated skills form a tree, the domain reward function is known and the best model for merging a pair of skills is the model selected for representing both individually.  Advantages  CTS is much faster learning algorithm than skill chaining . CTS can be applied to learning higher dimensional policies. Even unsuccessful episode can improve skills. Skills acquired using agent-centric features can be used for other problems.  Uses  CST has been used to acquire skills from human demonstration in the PinBall domain. It has been also used to acquire skills from human demonstration on a mobile manipulator.  References           "  Category:Machine learning algorithms   