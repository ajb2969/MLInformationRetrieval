<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="282">Integrating ADC</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Integrating ADC</h1>
<hr/>

<p>An <strong>integrating ADC</strong> is a type of <a href="analog-to-digital_converter" title="wikilink">analog-to-digital converter</a> that converts an unknown input voltage into a digital representation through the use of an <a href="operational_amplifier_applications#Inverting_integrator" title="wikilink">integrator</a>. In its most basic implementation, the unknown input voltage is applied to the input of the integrator and allowed to ramp for a fixed time period (the run-up period). Then a known reference voltage of opposite polarity is applied to the integrator and is allowed to ramp until the integrator output returns to zero (the run-down period). The input voltage is computed as a function of the reference voltage, the constant run-up time period, and the measured run-down time period. The run-down time measurement is usually made in units of the converter's clock, so longer integration times allow for higher resolutions. Likewise, the speed of the converter can be improved by sacrificing resolution.</p>

<p>Converters of this type can achieve high resolution, but often do so at the expense of speed. For this reason, these converters are not found in audio or signal processing applications. Their use is typically limited to digital voltmeters and other instruments requiring highly accurate measurements.</p>
<h2 id="basic-design">Basic design</h2>
<figure><b>(Figure)</b>
<figcaption>Basic integrator of a Dual-slope Integrating ADC. The comparator, the timer, and the controller are not shown.</figcaption>
</figure>

<p>The basic integrating ADC circuit consists of an integrator, a switch to select between the voltage to be measured and the reference voltage, a timer that determines how long to integrate the unknown and measures how long the reference integration took, a comparator to detect zero crossing, and a controller. Depending on the implementation, a switch may also be present in parallel with the integrator capacitor to allow the integrator to be reset (by discharging the integrator capacitor). The switches will be controlled electrically by means of the converter's controller (a microprocessor or dedicated control logic). Inputs to the controller include a clock (used to measure time) and the output of a comparator used to detect when the integrator's output reaches zero.</p>

<p>The conversion takes place in two phases: the run-up phase, where the input to the integrator is the voltage to be measured, and the run-down phase, where the input to the integrator is a known reference voltage. During the run-up phase, the switch selects the measured voltage as the input to the integrator. The integrator is allowed to ramp for a fixed period of time to allow a charge to build on the integrator capacitor. During the run-down phase, the switch selects the reference voltage as the input to the integrator. The time that it takes for the integrator's output to return to zero is measured during this phase.</p>

<p>In order for the reference voltage to ramp the integrator voltage down, the reference voltage needs to have a polarity opposite to that of the input voltage. In most cases, for positive input voltages, this means that the reference voltage will be negative. To handle both positive and negative input voltages, a positive and negative reference voltage is required. The selection of which reference to use during the run-down phase would be based on the polarity of the integrator output at the end of the run-up phase. That is, if the integrator's output were negative at the end of the run-up phase, a negative reference voltage would be required. If the integrator's output were positive, a positive reference voltage would be required.</p>
<figure><b>(Figure)</b>
<figcaption>Integrator output voltage in a basic dual-slope integrating ADC</figcaption>
</figure>

<p>The basic equation for the output of the integrator (assuming a constant input) is:</p>

<p>

<math display="block" id="Integrating_ADC:0">
 <semantics>
  <mrow>
   <msub>
    <mi>V</mi>
    <mrow>
     <mi>o</mi>
     <mi>u</mi>
     <mi>t</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo>-</mo>
     <mrow>
      <mfrac>
       <msub>
        <mi>V</mi>
        <mrow>
         <mi>i</mi>
         <mi>n</mi>
        </mrow>
       </msub>
       <mrow>
        <mi>R</mi>
        <mi>C</mi>
       </mrow>
      </mfrac>
      <msub>
       <mi>t</mi>
       <mrow>
        <mi>i</mi>
        <mi>n</mi>
        <mi>t</mi>
       </mrow>
      </msub>
     </mrow>
    </mrow>
    <mo>+</mo>
    <msub>
     <mi>V</mi>
     <mrow>
      <mi>i</mi>
      <mi>n</mi>
      <mi>i</mi>
      <mi>t</mi>
      <mi>i</mi>
      <mi>a</mi>
      <mi>l</mi>
     </mrow>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>V</ci>
     <apply>
      <times></times>
      <ci>o</ci>
      <ci>u</ci>
      <ci>t</ci>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>V</ci>
         <apply>
          <times></times>
          <ci>i</ci>
          <ci>n</ci>
         </apply>
        </apply>
        <apply>
         <times></times>
         <ci>R</ci>
         <ci>C</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>t</ci>
        <apply>
         <times></times>
         <ci>i</ci>
         <ci>n</ci>
         <ci>t</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>V</ci>
      <apply>
       <times></times>
       <ci>i</ci>
       <ci>n</ci>
       <ci>i</ci>
       <ci>t</ci>
       <ci>i</ci>
       <ci>a</ci>
       <ci>l</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V_{out}=-\dfrac{V_{in}}{RC}t_{int}+V_{initial}
  </annotation>
 </semantics>
</math>

</p>

<p>Assuming that the initial integrator voltage at the start of each conversion is zero and that the integrator voltage at the end of the run down period will be zero, we have the following two equations that cover the integrator's output during the two phases of the conversion:</p>

<p>

<math display="block" id="Integrating_ADC:1">
 <semantics>
  <mrow>
   <msub>
    <mi>V</mi>
    <mrow>
     <mrow>
      <mi>o</mi>
      <mi>u</mi>
      <mi>t</mi>
     </mrow>
     <mo>-</mo>
     <mrow>
      <mi>u</mi>
      <mi>p</mi>
     </mrow>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <mrow>
     <mfrac>
      <msub>
       <mi>V</mi>
       <mrow>
        <mi>i</mi>
        <mi>n</mi>
       </mrow>
      </msub>
      <mrow>
       <mi>R</mi>
       <mi>C</mi>
      </mrow>
     </mfrac>
     <msub>
      <mi>t</mi>
      <mi>u</mi>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>V</ci>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>o</ci>
       <ci>u</ci>
       <ci>t</ci>
      </apply>
      <apply>
       <times></times>
       <ci>u</ci>
       <ci>p</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>V</ci>
        <apply>
         <times></times>
         <ci>i</ci>
         <ci>n</ci>
        </apply>
       </apply>
       <apply>
        <times></times>
        <ci>R</ci>
        <ci>C</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>t</ci>
       <ci>u</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V_{out-up}=-\dfrac{V_{in}}{RC}t_{u}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Integrating_ADC:2">
 <semantics>
  <mrow>
   <msub>
    <mi>V</mi>
    <mrow>
     <mrow>
      <mi>o</mi>
      <mi>u</mi>
      <mi>t</mi>
     </mrow>
     <mo>-</mo>
     <mrow>
      <mi>d</mi>
      <mi>o</mi>
      <mi>w</mi>
      <mi>n</mi>
     </mrow>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo>-</mo>
     <mrow>
      <mfrac>
       <msub>
        <mi>V</mi>
        <mrow>
         <mi>r</mi>
         <mi>e</mi>
         <mi>f</mi>
        </mrow>
       </msub>
       <mrow>
        <mi>R</mi>
        <mi>C</mi>
       </mrow>
      </mfrac>
      <msub>
       <mi>t</mi>
       <mi>d</mi>
      </msub>
     </mrow>
    </mrow>
    <mo>+</mo>
    <msub>
     <mi>V</mi>
     <mrow>
      <mrow>
       <mi>o</mi>
       <mi>u</mi>
       <mi>t</mi>
      </mrow>
      <mo>-</mo>
      <mrow>
       <mi>u</mi>
       <mi>p</mi>
      </mrow>
     </mrow>
    </msub>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>V</ci>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <ci>o</ci>
        <ci>u</ci>
        <ci>t</ci>
       </apply>
       <apply>
        <times></times>
        <ci>d</ci>
        <ci>o</ci>
        <ci>w</ci>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <apply>
         <divide></divide>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>V</ci>
          <apply>
           <times></times>
           <ci>r</ci>
           <ci>e</ci>
           <ci>f</ci>
          </apply>
         </apply>
         <apply>
          <times></times>
          <ci>R</ci>
          <ci>C</ci>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>t</ci>
         <ci>d</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>V</ci>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <ci>o</ci>
         <ci>u</ci>
         <ci>t</ci>
        </apply>
        <apply>
         <times></times>
         <ci>u</ci>
         <ci>p</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V_{out-down}=-\dfrac{V_{ref}}{RC}t_{d}+V_{out-up}=0
  </annotation>
 </semantics>
</math>

</p>

<p>The two equations can be combined and solved for 

<math display="inline" id="Integrating_ADC:3">
 <semantics>
  <msub>
   <mi>V</mi>
   <mrow>
    <mi>i</mi>
    <mi>n</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>V</ci>
    <apply>
     <times></times>
     <ci>i</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V_{in}
  </annotation>
 </semantics>
</math>

, the unknown input voltage:</p>

<p>

<math display="block" id="Integrating_ADC:4">
 <semantics>
  <mrow>
   <msub>
    <mi>V</mi>
    <mrow>
     <mi>i</mi>
     <mi>n</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <mrow>
     <msub>
      <mi>V</mi>
      <mrow>
       <mi>r</mi>
       <mi>e</mi>
       <mi>f</mi>
      </mrow>
     </msub>
     <mfrac>
      <msub>
       <mi>t</mi>
       <mi>d</mi>
      </msub>
      <msub>
       <mi>t</mi>
       <mi>u</mi>
      </msub>
     </mfrac>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>V</ci>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>V</ci>
       <apply>
        <times></times>
        <ci>r</ci>
        <ci>e</ci>
        <ci>f</ci>
       </apply>
      </apply>
      <apply>
       <divide></divide>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>t</ci>
        <ci>d</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>t</ci>
        <ci>u</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V_{in}=-V_{ref}\dfrac{t_{d}}{t_{u}}
  </annotation>
 </semantics>
</math>

</p>

<p>From the equation, one of the benefits of the dual-slope integrating ADC becomes apparent: the measurement is independent of the values of the circuit elements (R and C). This does not mean, however, that the values of R and C are unimportant in the design of a dual-slope integrating ADC (as will be explained below).</p>

<p>Note that in the graph to the right, the voltage is shown as going up during the run-up phase and down during the run-down phase. In reality, because the integrator uses the op-amp in a negative feedback configuration, applying a positive 

<math display="inline" id="Integrating_ADC:5">
 <semantics>
  <msub>
   <mi>V</mi>
   <mrow>
    <mi>i</mi>
    <mi>n</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>V</ci>
    <apply>
     <times></times>
     <ci>i</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V_{in}
  </annotation>
 </semantics>
</math>

 will cause the output of the integrator to go <em>down</em>. The <em>up</em> and <em>down</em> more accurately refer to the process of adding charge to the integrator capacitor during the run-up phase and removing charge during the run-down phase.</p>

<p>The resolution of the dual-slope integrating ADC is determined primarily by the length of the run-down period and by the time measurement resolution (i.e., the frequency of the controller's clock). The required resolution (in number of bits) dictates the minimum length of the run-down period for a full-scale input (

<math display="inline" id="Integrating_ADC:6">
 <semantics>
  <mrow>
   <msub>
    <mi>V</mi>
    <mrow>
     <mi>i</mi>
     <mi>n</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <msub>
     <mi>V</mi>
     <mrow>
      <mi>r</mi>
      <mi>e</mi>
      <mi>f</mi>
     </mrow>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>V</ci>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>V</ci>
      <apply>
       <times></times>
       <ci>r</ci>
       <ci>e</ci>
       <ci>f</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V_{in}=-V_{ref}
  </annotation>
 </semantics>
</math>

):</p>

<p>

<math display="block" id="Integrating_ADC:7">
 <semantics>
  <mrow>
   <msub>
    <mi>t</mi>
    <mi>d</mi>
   </msub>
   <mo>=</mo>
   <mfrac>
    <msup>
     <mn>2</mn>
     <mi>r</mi>
    </msup>
    <msub>
     <mi>f</mi>
     <mrow>
      <mi>c</mi>
      <mi>l</mi>
      <mi>k</mi>
     </mrow>
    </msub>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>t</ci>
     <ci>d</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <ci>r</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <apply>
       <times></times>
       <ci>c</ci>
       <ci>l</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t_{d}=\dfrac{2^{r}}{f_{clk}}
  </annotation>
 </semantics>
</math>

</p>

<p>During the measurement of a full-scale input, the slope of the integrator's output will be the same during the run-up and run-down phases. This also implies that the time of the run-up period and run-down period will be equal (

<math display="inline" id="Integrating_ADC:8">
 <semantics>
  <mrow>
   <msub>
    <mi>t</mi>
    <mi>u</mi>
   </msub>
   <mo>=</mo>
   <msub>
    <mi>t</mi>
    <mi>d</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>t</ci>
     <ci>u</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>t</ci>
     <ci>d</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t_{u}=t_{d}
  </annotation>
 </semantics>
</math>

) and that the total measurement time will be 

<math display="inline" id="Integrating_ADC:9">
 <semantics>
  <mrow>
   <mn>2</mn>
   <msub>
    <mi>t</mi>
    <mi>d</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <cn type="integer">2</cn>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>t</ci>
     <ci>d</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2t_{d}
  </annotation>
 </semantics>
</math>

. Therefore, the total measurement time for a full-scale input will be based on the desired resolution and the frequency of the controller's clock:</p>

<p>

<math display="block" id="Integrating_ADC:10">
 <semantics>
  <mrow>
   <msub>
    <mi>t</mi>
    <mi>m</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mn>2</mn>
    <mfrac>
     <msup>
      <mn>2</mn>
      <mi>r</mi>
     </msup>
     <msub>
      <mi>f</mi>
      <mrow>
       <mi>c</mi>
       <mi>l</mi>
       <mi>k</mi>
      </mrow>
     </msub>
    </mfrac>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>t</ci>
     <ci>m</ci>
    </apply>
    <apply>
     <times></times>
     <cn type="integer">2</cn>
     <apply>
      <divide></divide>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">2</cn>
       <ci>r</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>f</ci>
       <apply>
        <times></times>
        <ci>c</ci>
        <ci>l</ci>
        <ci>k</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t_{m}=2\dfrac{2^{r}}{f_{clk}}
  </annotation>
 </semantics>
</math>

</p>

<p>If a resolution of 16 bits is required with a controller clock of 10 MHz, the measurement time will be 13.1 milliseconds (or a sampling rate of just 76 samples per second). However, the sampling time can be improved by sacrificing resolution. If the resolution requirement is reduced to 10 bits, the measurement time is also reduced to only 0.2 milliseconds (almost 4900 samples per second).</p>
<h3 id="limitations">Limitations</h3>

<p>There are limits to the maximum resolution of the dual-slope integrating ADC. It is not possible to increase the resolution of the basic dual-slope ADC to arbitrarily high values by using longer measurement times or faster clocks. Resolution is limited by:</p>
<ul>
<li>The range of the integrating amplifier. The voltage rails on an op-amp limit the output voltage of the integrator. An input left connected to the integrator for too long will eventually cause the op amp to limit its output to some maximum value, making any calculation based on the run-down time meaningless. The integrator's resistor and capacitor are therefore chosen carefully based on the voltage rails of the op-amp, the reference voltage and expected full-scale input, and the longest run-up time needed to achieve the desired resolution.</li>
<li>The accuracy of the comparator used as the null detector. Wideband circuit noise limits the ability of the comparator to identify exactly when the output of the integrator has reached zero. Goerke suggests a typical limit is a comparator resolution of 1 millivolt.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></li>
<li>The quality of the integrator's capacitor. Although the integrating capacitor need not be perfectly linear, it does need to be time-invariant. <a href="Dielectric_absorption" title="wikilink">Dielectric absorption</a> causes errors.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></li>
</ul>
<h2 id="enhancements">Enhancements</h2>

<p>The basic design of the dual-slope integrating ADC has a limitations in both conversion speed and resolution. A number of modifications to the basic design have been made to overcome both of these to some degree.</p>
<h3 id="run-up-improvements">Run-up improvements</h3>
<h4 id="enhanced-dual-slope">Enhanced dual-slope</h4>
<figure><b>(Figure)</b>
<figcaption>Enhanced run-up dual-slope integrating ADC</figcaption>
</figure>

<p>The run-up phase of the basic dual-slope design integrates the input voltage for a fixed period of time. That is, it allows an unknown amount of charge to build up on the integrator's capacitor. The run-down phase is then used to measure this unknown charge to determine the unknown voltage. For a full-scale input, half of the measurement time is spent in the run-up phase. For smaller inputs, an even larger percentage of the total measurement time is spent in the run-up phase. Reducing the amount of time spent in the run-up phase can significantly reduce the total measurement time.</p>

<p>A simple way to reduce the run-up time is to increase the rate that charge accumulates on the integrator capacitor by reducing the size of the resistor used on the input, a method referred to as enhanced dual-slope. This still allows the same total amount of charge accumulation, but it does so over a smaller period of time. Using the same algorithm for the run-down phase results in the following equation for the calculation of the unknown input voltage (

<math display="inline" id="Integrating_ADC:11">
 <semantics>
  <msub>
   <mi>V</mi>
   <mrow>
    <mi>i</mi>
    <mi>n</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>V</ci>
    <apply>
     <times></times>
     <ci>i</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V_{in}
  </annotation>
 </semantics>
</math>

):</p>

<p>

<math display="block" id="Integrating_ADC:12">
 <semantics>
  <mrow>
   <msub>
    <mi>V</mi>
    <mrow>
     <mi>i</mi>
     <mi>n</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <mrow>
     <msub>
      <mi>V</mi>
      <mrow>
       <mi>r</mi>
       <mi>e</mi>
       <mi>f</mi>
      </mrow>
     </msub>
     <mfrac>
      <msub>
       <mi>R</mi>
       <mi>a</mi>
      </msub>
      <msub>
       <mi>R</mi>
       <mi>b</mi>
      </msub>
     </mfrac>
     <mfrac>
      <msub>
       <mi>t</mi>
       <mi>d</mi>
      </msub>
      <msub>
       <mi>t</mi>
       <mi>u</mi>
      </msub>
     </mfrac>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>V</ci>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>V</ci>
       <apply>
        <times></times>
        <ci>r</ci>
        <ci>e</ci>
        <ci>f</ci>
       </apply>
      </apply>
      <apply>
       <divide></divide>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>R</ci>
        <ci>a</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>R</ci>
        <ci>b</ci>
       </apply>
      </apply>
      <apply>
       <divide></divide>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>t</ci>
        <ci>d</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>t</ci>
        <ci>u</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V_{in}=-V_{ref}\dfrac{R_{a}}{R_{b}}\dfrac{t_{d}}{t_{u}}
  </annotation>
 </semantics>
</math>

</p>

<p>Note that this equation, unlike the equation for the basic dual-slope converter, has a dependence on the values of the integrator resistors. Or, more importantly, it has a dependence on the <em>ratio</em> of the two resistance values. This modification does nothing to improve the resolution of the converter (since it doesn't address either of the resolution limitations noted above).</p>
<h4 id="multi-slope-run-up">Multi-slope run-up</h4>
<figure><b>(Figure)</b>
<figcaption>Circuit diagram for a multi-slope run-up converter</figcaption>
</figure>

<p>One method to improve the resolution of the converter is to artificially increase the range of the integrating amplifier during the run-up phase. As mentioned above, the purpose of the run-up phase is to add an unknown amount of charge to the integrator to be later measured during the run-down phase. Having the ability to add larger quantities of charge allows for more higher-resolution measurements. For example, assume that we are capable of measuring the charge on the integrator during the run-down phase to a granularity of 1 coulomb. If our integrator amplifier limits us to being able to add only up to 16 coulombs of charge to the integrator during the run-up phase, our total measurement will be limited to 4 bits (16 possible values). If we can increase the range of the integrator to allow us to add up to 32 coulombs, our measurement resolution is increased to 5 bits.</p>

<p>One method to increase the integrator capacity is by periodically adding or subtracting known quantities of charge during the run-up phase in order to keep the integrator's output within the range of the integrator amplifier. Then, the total amount of artificially-accumulated charge is the charge introduced by the unknown input voltage plus the sum of the known charges that were added or subtracted.</p>

<p>The circuit diagram shown to the right is an example of how multi-slope run-up could be implemented. The concept is that the unknown input voltage, 

<math display="inline" id="Integrating_ADC:13">
 <semantics>
  <msub>
   <mi>V</mi>
   <mrow>
    <mi>i</mi>
    <mi>n</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>V</ci>
    <apply>
     <times></times>
     <ci>i</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V_{in}
  </annotation>
 </semantics>
</math>

, is always applied to the integrator. Positive and negative reference voltages controlled by the two independent switches add and subtract charge as needed to keep the output of the integrator within its limits. The reference resistors, 

<math display="inline" id="Integrating_ADC:14">
 <semantics>
  <msub>
   <mi>R</mi>
   <mi>p</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>R</ci>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{p}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Integrating_ADC:15">
 <semantics>
  <msub>
   <mi>R</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>R</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{n}
  </annotation>
 </semantics>
</math>

 are necessarily smaller than 

<math display="inline" id="Integrating_ADC:16">
 <semantics>
  <msub>
   <mi>R</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>R</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{i}
  </annotation>
 </semantics>
</math>

 to ensure that the references can overcome the charge introduced by the input. A <a class="uri" href="comparator" title="wikilink">comparator</a> is connected to the output to compare the integrator's voltage with a threshold voltage. The output of the comparator is used by the converter's controller to decide which reference voltage should be applied. This can be a relatively simple algorithm: if the integrator's output above the threshold, enable the positive reference (to cause the output to go down); if the integrator's output is below the threshold, enable the negative reference (to cause the output to go up). The controller keeps track of how often each switch is turned on in order to estimate how much additional charge was placed onto (or removed from) the integrator capacitor as a result of the reference voltages.</p>
<figure><b>(Figure)</b>
<figcaption>Output from multi-slope run-up</figcaption>
</figure>

<p>To the right is a graph of sample output from the integrator during a multi-slope run-up. Each dashed vertical line represents a decision point by the controller where it samples the polarity of the output and chooses to apply either the positive or negative reference voltage to the input. Ideally, the output voltage of the integrator at the end of the run-up period can be represented by the following equation:</p>

<p>

<math display="block" id="Integrating_ADC:17">
 <semantics>
  <mrow>
   <msub>
    <mi>V</mi>
    <mrow>
     <mi>o</mi>
     <mi>u</mi>
     <mi>t</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <mfrac>
     <mrow>
      <mrow>
       <mstyle displaystyle="true">
        <mfrac>
         <mrow>
          <mi>N</mi>
          <msub>
           <mi>V</mi>
           <mrow>
            <mi>i</mi>
            <mi>n</mi>
           </mrow>
          </msub>
          <msub>
           <mi>t</mi>
           <mi mathvariant="normal">Δ</mi>
          </msub>
         </mrow>
         <msub>
          <mi>R</mi>
          <mi>i</mi>
         </msub>
        </mfrac>
       </mstyle>
       <mo>+</mo>
       <mstyle displaystyle="true">
        <mfrac>
         <mrow>
          <msub>
           <mi>N</mi>
           <mi>p</mi>
          </msub>
          <msub>
           <mi>V</mi>
           <mrow>
            <mi>r</mi>
            <mi>e</mi>
            <mi>f</mi>
           </mrow>
          </msub>
          <msub>
           <mi>t</mi>
           <mi mathvariant="normal">Δ</mi>
          </msub>
         </mrow>
         <msub>
          <mi>R</mi>
          <mi>p</mi>
         </msub>
        </mfrac>
       </mstyle>
      </mrow>
      <mo>-</mo>
      <mstyle displaystyle="true">
       <mfrac>
        <mrow>
         <msub>
          <mi>N</mi>
          <mi>n</mi>
         </msub>
         <msub>
          <mi>V</mi>
          <mrow>
           <mi>r</mi>
           <mi>e</mi>
           <mi>f</mi>
          </mrow>
         </msub>
         <msub>
          <mi>t</mi>
          <mi mathvariant="normal">Δ</mi>
         </msub>
        </mrow>
        <msub>
         <mi>R</mi>
         <mi>n</mi>
        </msub>
       </mfrac>
      </mstyle>
     </mrow>
     <mi>C</mi>
    </mfrac>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>V</ci>
     <apply>
      <times></times>
      <ci>o</ci>
      <ci>u</ci>
      <ci>t</ci>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <divide></divide>
      <apply>
       <minus></minus>
       <apply>
        <plus></plus>
        <apply>
         <divide></divide>
         <apply>
          <times></times>
          <ci>N</ci>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>V</ci>
           <apply>
            <times></times>
            <ci>i</ci>
            <ci>n</ci>
           </apply>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>t</ci>
           <ci>normal-Δ</ci>
          </apply>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>R</ci>
          <ci>i</ci>
         </apply>
        </apply>
        <apply>
         <divide></divide>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>N</ci>
           <ci>p</ci>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>V</ci>
           <apply>
            <times></times>
            <ci>r</ci>
            <ci>e</ci>
            <ci>f</ci>
           </apply>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>t</ci>
           <ci>normal-Δ</ci>
          </apply>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>R</ci>
          <ci>p</ci>
         </apply>
        </apply>
       </apply>
       <apply>
        <divide></divide>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>N</ci>
          <ci>n</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>V</ci>
          <apply>
           <times></times>
           <ci>r</ci>
           <ci>e</ci>
           <ci>f</ci>
          </apply>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>t</ci>
          <ci>normal-Δ</ci>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>R</ci>
         <ci>n</ci>
        </apply>
       </apply>
      </apply>
      <ci>C</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V_{out}=-\dfrac{\dfrac{NV_{in}t_{\Delta}}{R_{i}}+\dfrac{N_{p}V_{ref}t_{\Delta}%
}{R_{p}}-\dfrac{N_{n}V_{ref}t_{\Delta}}{R_{n}}}{C}
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Integrating_ADC:18">
 <semantics>
  <msub>
   <mi>t</mi>
   <mi mathvariant="normal">Δ</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>t</ci>
    <ci>normal-Δ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t_{\Delta}
  </annotation>
 </semantics>
</math>

 is the sampling period, 

<math display="inline" id="Integrating_ADC:19">
 <semantics>
  <msub>
   <mi>N</mi>
   <mi>p</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>N</ci>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N_{p}
  </annotation>
 </semantics>
</math>

 is the number of periods in which the positive reference is switched in, 

<math display="inline" id="Integrating_ADC:20">
 <semantics>
  <msub>
   <mi>N</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>N</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N_{n}
  </annotation>
 </semantics>
</math>

 is the number of periods in which the negative reference is switched in, and 

<math display="inline" id="Integrating_ADC:21">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

 is the total number of periods in the run-up phase.</p>

<p>The resolution obtained during the run-up period can be determined by making the assumption that the integrator output at the end of the run-up phase is zero. This allows us to relate the unknown input, 

<math display="inline" id="Integrating_ADC:22">
 <semantics>
  <msub>
   <mi>V</mi>
   <mrow>
    <mi>i</mi>
    <mi>n</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>V</ci>
    <apply>
     <times></times>
     <ci>i</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V_{in}
  </annotation>
 </semantics>
</math>

, to just the references and the 

<math display="inline" id="Integrating_ADC:23">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

 values:</p>

<p>

<math display="block" id="Integrating_ADC:24">
 <semantics>
  <mrow>
   <mfrac>
    <mrow>
     <mi>N</mi>
     <msub>
      <mi>V</mi>
      <mrow>
       <mi>i</mi>
       <mi>n</mi>
      </mrow>
     </msub>
    </mrow>
    <msub>
     <mi>R</mi>
     <mi>i</mi>
    </msub>
   </mfrac>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mfrac>
       <mrow>
        <msub>
         <mi>N</mi>
         <mi>p</mi>
        </msub>
        <msub>
         <mi>V</mi>
         <mrow>
          <mi>r</mi>
          <mi>e</mi>
          <mi>f</mi>
         </mrow>
        </msub>
       </mrow>
       <msub>
        <mi>R</mi>
        <mi>p</mi>
       </msub>
      </mfrac>
      <mo>-</mo>
      <mfrac>
       <mrow>
        <msub>
         <mi>N</mi>
         <mi>n</mi>
        </msub>
        <msub>
         <mi>V</mi>
         <mrow>
          <mi>r</mi>
          <mi>e</mi>
          <mi>f</mi>
         </mrow>
        </msub>
       </mrow>
       <msub>
        <mi>R</mi>
        <mi>n</mi>
       </msub>
      </mfrac>
     </mrow>
     <mo>)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <ci>N</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>V</ci>
       <apply>
        <times></times>
        <ci>i</ci>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>R</ci>
      <ci>i</ci>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <minus></minus>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>N</ci>
         <ci>p</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>V</ci>
         <apply>
          <times></times>
          <ci>r</ci>
          <ci>e</ci>
          <ci>f</ci>
         </apply>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>R</ci>
        <ci>p</ci>
       </apply>
      </apply>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>N</ci>
         <ci>n</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>V</ci>
         <apply>
          <times></times>
          <ci>r</ci>
          <ci>e</ci>
          <ci>f</ci>
         </apply>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>R</ci>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \dfrac{NV_{in}}{R_{i}}=-\left(\dfrac{N_{p}V_{ref}}{R_{p}}-\dfrac{N_{n}V_{ref}}%
{R_{n}}\right)
  </annotation>
 </semantics>
</math>

</p>

<p>The resolution can be expressed in terms of the difference between single steps of the converter's output. In this case, if we solve the above equation for 

<math display="inline" id="Integrating_ADC:25">
 <semantics>
  <msub>
   <mi>V</mi>
   <mrow>
    <mi>i</mi>
    <mi>n</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>V</ci>
    <apply>
     <times></times>
     <ci>i</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V_{in}
  </annotation>
 </semantics>
</math>

 using 

<math display="inline" id="Integrating_ADC:26">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>N</mi>
     <mi>p</mi>
    </msub>
    <mo>=</mo>
    <mn>0</mn>
   </mrow>
   <mo>,</mo>
   <mrow>
    <msub>
     <mi>N</mi>
     <mi>n</mi>
    </msub>
    <mo>=</mo>
    <mi>N</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>N</ci>
      <ci>p</ci>
     </apply>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>N</ci>
      <ci>n</ci>
     </apply>
     <ci>N</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N_{p}=0,N_{n}=N
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Integrating_ADC:27">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>N</mi>
     <mi>p</mi>
    </msub>
    <mo>=</mo>
    <mn>1</mn>
   </mrow>
   <mo>,</mo>
   <mrow>
    <msub>
     <mi>N</mi>
     <mi>n</mi>
    </msub>
    <mo>=</mo>
    <mrow>
     <mi>N</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>N</ci>
      <ci>p</ci>
     </apply>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>N</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <minus></minus>
      <ci>N</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N_{p}=1,N_{n}=N-1
  </annotation>
 </semantics>
</math>

 (the sum of 

<math display="inline" id="Integrating_ADC:28">
 <semantics>
  <msub>
   <mi>N</mi>
   <mi>p</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>N</ci>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N_{p}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Integrating_ADC:29">
 <semantics>
  <msub>
   <mi>N</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>N</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N_{n}
  </annotation>
 </semantics>
</math>

 must always equal 

<math display="inline" id="Integrating_ADC:30">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

), the difference will equal the smallest resolvable quantity. This results in an equation for the resolution of the multi-slope run-up phase (in bits) of:</p>

<p>

<math display="block" id="Integrating_ADC:31">
 <semantics>
  <mrow>
   <mi>r</mi>
   <mo>=</mo>
   <mrow>
    <mi>l</mi>
    <mi>o</mi>
    <msub>
     <mi>g</mi>
     <mn>2</mn>
    </msub>
    <mfrac>
     <mrow>
      <msub>
       <mi>R</mi>
       <mi>i</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <msub>
         <mi>R</mi>
         <mi>p</mi>
        </msub>
        <mo>+</mo>
        <msub>
         <mi>R</mi>
         <mi>n</mi>
        </msub>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mrow>
      <mi>N</mi>
      <msub>
       <mi>R</mi>
       <mi>n</mi>
      </msub>
      <msub>
       <mi>R</mi>
       <mi>p</mi>
      </msub>
     </mrow>
    </mfrac>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>r</ci>
    <apply>
     <times></times>
     <ci>l</ci>
     <ci>o</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>g</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>R</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <plus></plus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>R</ci>
         <ci>p</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>R</ci>
         <ci>n</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>N</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>R</ci>
        <ci>n</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>R</ci>
        <ci>p</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r=log_{2}\dfrac{R_{i}(R_{p}+R_{n})}{NR_{n}R_{p}}
  </annotation>
 </semantics>
</math>

</p>

<p>Using typical values of the reference resistors 

<math display="inline" id="Integrating_ADC:32">
 <semantics>
  <msub>
   <mi>R</mi>
   <mi>p</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>R</ci>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{p}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Integrating_ADC:33">
 <semantics>
  <msub>
   <mi>R</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>R</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{n}
  </annotation>
 </semantics>
</math>

 of 10k ohms and an input resistor of 50k ohms, we can achieve a 16 bit resolution during the run-up phase with 655360 periods (65.5 milliseconds with a 10 MHz clock).</p>

<p>While it is possible to continue the multi-slope run-up indefinitely, it is not possible to increase the resolution of the converter to arbitrarily high levels just by using a longer run-up time. Error is introduced into the multi-slope run-up through the action of the switches controlling the references, cross-coupling between the switches, unintended switch charge injection, mismatches in the references, and timing errors.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>

<p>Some of this error can be reduced by careful operation of the switches.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> In particular, during the run-up period, each switch should be activated a constant number of times. The algorithm explained above does not do this and just toggles switches as needed to keep the integrator output within the limits. Activating each switch a constant number of times makes the error related to switching approximately constant. Any output offset that is a result of the switching error can be measured and then subtracted from the result.</p>
<h3 id="run-down-improvements">Run-down improvements</h3>
<h4 id="multi-slope-run-down">Multi-slope run-down</h4>
<figure><b>(Figure)</b>
<figcaption>Multi-slope run-down integrating ADC</figcaption>
</figure>

<p>The simple, single-slope run-down is slow. Typically, the run down time is measured in clock ticks, so to get four digit resolution, the rundown time may take as long as 10,000 clock cycles. A multi-slope run-down can speed the measurement up without sacrificing accuracy. By using 4 slope rates that are each a power of ten more gradual than the previous, four digit resolution can be achieved in roughly 40 or fewer clock ticks—a huge speed improvement.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>

<p>The circuit shown to the right is an example of a multi-slope run-down circuit with four run-down slopes with each being ten times more gradual than the previous. The switches control which slope is selected. The switch containing 

<math display="inline" id="Integrating_ADC:34">
 <semantics>
  <mrow>
   <msub>
    <mi>R</mi>
    <mi>d</mi>
   </msub>
   <mo>/</mo>
   <mn>1000</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>R</ci>
     <ci>d</ci>
    </apply>
    <cn type="integer">1000</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{d}/1000
  </annotation>
 </semantics>
</math>

 selects the steepest slope (i.e., will cause the integrator output to move toward zero the fastest). At the start of the run-down interval, the unknown input is removed from the circuit by opening the switch connected to 

<math display="inline" id="Integrating_ADC:35">
 <semantics>
  <msub>
   <mi>V</mi>
   <mrow>
    <mi>i</mi>
    <mi>n</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>V</ci>
    <apply>
     <times></times>
     <ci>i</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V_{in}
  </annotation>
 </semantics>
</math>

 and closing the 

<math display="inline" id="Integrating_ADC:36">
 <semantics>
  <mrow>
   <msub>
    <mi>R</mi>
    <mi>d</mi>
   </msub>
   <mo>/</mo>
   <mn>1000</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>R</ci>
     <ci>d</ci>
    </apply>
    <cn type="integer">1000</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{d}/1000
  </annotation>
 </semantics>
</math>

 switch. Once the integrator's output reaches zero (and the run-down time measured), the 

<math display="inline" id="Integrating_ADC:37">
 <semantics>
  <mrow>
   <msub>
    <mi>R</mi>
    <mi>d</mi>
   </msub>
   <mo>/</mo>
   <mn>1000</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>R</ci>
     <ci>d</ci>
    </apply>
    <cn type="integer">1000</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{d}/1000
  </annotation>
 </semantics>
</math>

 switch is opened and the next slope is selected by closing the 

<math display="inline" id="Integrating_ADC:38">
 <semantics>
  <mrow>
   <msub>
    <mi>R</mi>
    <mi>d</mi>
   </msub>
   <mo>/</mo>
   <mn>100</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>R</ci>
     <ci>d</ci>
    </apply>
    <cn type="integer">100</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{d}/100
  </annotation>
 </semantics>
</math>

 switch. This repeats until the final slope of 

<math display="inline" id="Integrating_ADC:39">
 <semantics>
  <msub>
   <mi>R</mi>
   <mi>d</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>R</ci>
    <ci>d</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{d}
  </annotation>
 </semantics>
</math>

 has reached zero. The combination of the run-down times for each of the slopes determines the value of the unknown input. In essence, each slope adds one digit of resolution to the result.</p>

<p>In the example circuit, the slope resistors differ by a factor of 10. This value, known as the <em>base</em> (

<math display="inline" id="Integrating_ADC:40">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

), can be any value. As explained below, the choice of the base affects the speed of the converter and determines the number of slopes needed to achieve the desired resolution.</p>
<figure><b>(Figure)</b>
<figcaption>Output of the multi-slope run-down integrating ADC</figcaption>
</figure>

<p>The basis of this design is the assumption that there will always be overshoot when trying to find the zero crossing at the end of a run-down interval. This will necessarily be true given any hysteresis in the output of the comparator measuring the zero crossing and due to the periodic sampling of the comparator based on the converter's clock. If we assume that the converter switches from one slope to the next in a single clock cycle (which may or may not be possible), the maximum amount of overshoot for a given slope would be the largest integrator output change in one clock period:</p>

<p>

<math display="block" id="Integrating_ADC:41">
 <semantics>
  <mrow>
   <msub>
    <mi>V</mi>
    <mi mathvariant="normal">Δ</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <msub>
      <mi>V</mi>
      <mrow>
       <mi>r</mi>
       <mi>e</mi>
       <mi>f</mi>
      </mrow>
     </msub>
     <mrow>
      <mi>R</mi>
      <mi>C</mi>
     </mrow>
    </mfrac>
    <mfrac>
     <mn>1</mn>
     <msub>
      <mi>f</mi>
      <mrow>
       <mi>c</mi>
       <mi>l</mi>
       <mi>k</mi>
      </mrow>
     </msub>
    </mfrac>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>V</ci>
     <ci>normal-Δ</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>V</ci>
       <apply>
        <times></times>
        <ci>r</ci>
        <ci>e</ci>
        <ci>f</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>R</ci>
       <ci>C</ci>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>f</ci>
       <apply>
        <times></times>
        <ci>c</ci>
        <ci>l</ci>
        <ci>k</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V_{\Delta}=\dfrac{V_{ref}}{RC}\dfrac{1}{f_{clk}}
  </annotation>
 </semantics>
</math>

</p>

<p>To overcome this overshoot, the next slope would require no more than 

<math display="inline" id="Integrating_ADC:42">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

 clock cycles, which helps to place a bound on the total time of the run-down. The time for the first-run down (using the steepest slope) is dependent on the unknown input (i.e., the amount of charge placed on the integrator capacitor during the run-up phase). At most, this will be:</p>

<p>

<math display="block" id="Integrating_ADC:43">
 <semantics>
  <mrow>
   <msub>
    <mi>T</mi>
    <mrow>
     <mi>f</mi>
     <mi>i</mi>
     <mi>r</mi>
     <mi>s</mi>
     <mi>t</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo>⌈</mo>
    <mfrac>
     <mrow>
      <msub>
       <mi>V</mi>
       <mrow>
        <mi>m</mi>
        <mi>a</mi>
        <mi>x</mi>
       </mrow>
      </msub>
      <mi>C</mi>
      <msub>
       <mi>R</mi>
       <mrow>
        <mi>s</mi>
        <mn>1</mn>
       </mrow>
      </msub>
      <msub>
       <mi>f</mi>
       <mrow>
        <mi>c</mi>
        <mi>l</mi>
        <mi>k</mi>
       </mrow>
      </msub>
     </mrow>
     <msub>
      <mi>V</mi>
      <mrow>
       <mi>r</mi>
       <mi>e</mi>
       <mi>f</mi>
      </mrow>
     </msub>
    </mfrac>
    <mo>⌉</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>T</ci>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>i</ci>
      <ci>r</ci>
      <ci>s</ci>
      <ci>t</ci>
     </apply>
    </apply>
    <apply>
     <ceiling></ceiling>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>V</ci>
        <apply>
         <times></times>
         <ci>m</ci>
         <ci>a</ci>
         <ci>x</ci>
        </apply>
       </apply>
       <ci>C</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>R</ci>
        <apply>
         <times></times>
         <ci>s</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>f</ci>
        <apply>
         <times></times>
         <ci>c</ci>
         <ci>l</ci>
         <ci>k</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>V</ci>
       <apply>
        <times></times>
        <ci>r</ci>
        <ci>e</ci>
        <ci>f</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T_{first}=\left\lceil\dfrac{V_{max}CR_{s1}f_{clk}}{V_{ref}}\right\rceil
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Integrating_ADC:44">
 <semantics>
  <msub>
   <mi>T</mi>
   <mrow>
    <mi>f</mi>
    <mi>i</mi>
    <mi>r</mi>
    <mi>s</mi>
    <mi>t</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>T</ci>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>i</ci>
     <ci>r</ci>
     <ci>s</ci>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T_{first}
  </annotation>
 </semantics>
</math>

 is the maximum number of clock periods for the first slope, 

<math display="inline" id="Integrating_ADC:45">
 <semantics>
  <msub>
   <mi>V</mi>
   <mrow>
    <mi>m</mi>
    <mi>a</mi>
    <mi>x</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>V</ci>
    <apply>
     <times></times>
     <ci>m</ci>
     <ci>a</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V_{max}
  </annotation>
 </semantics>
</math>

 is the maximum integrator voltage at the start of the run-down phase, and 

<math display="inline" id="Integrating_ADC:46">
 <semantics>
  <msub>
   <mi>R</mi>
   <mrow>
    <mi>s</mi>
    <mn>1</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>R</ci>
    <apply>
     <times></times>
     <ci>s</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{s1}
  </annotation>
 </semantics>
</math>

 is the resistor used for the first slope.</p>

<p>The remainder of the slopes have a limited duration based on the selected base, so the remaining time of the conversion (in converter clock periods) is:</p>

<p>

<math display="block" id="Integrating_ADC:47">
 <semantics>
  <mrow>
   <msub>
    <mi>T</mi>
    <mi>d</mi>
   </msub>
   <mo>≤</mo>
   <mrow>
    <mi>B</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>N</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>T</ci>
     <ci>d</ci>
    </apply>
    <apply>
     <times></times>
     <ci>B</ci>
     <apply>
      <minus></minus>
      <ci>N</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T_{d}\leq B(N-1)
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Integrating_ADC:48">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

 is the number of slopes.</p>

<p>Converting the measured time intervals during the multi-slope run-down into a measured voltage is similar to the charge-balancing method used in the multi-slope run-up enhancement. Each slope adds or subtracts known amounts of charge to/from the integrator capacitor. The run-up will have added some unknown amount of charge to the integrator. Then, during the run-down, the first slope subtracts a large amount of charge, the second slope adds a smaller amount of charge, etc. with each subsequent slope moving a smaller amount in the opposite direction of the previous slope with the goal of reaching closer and closer to zero. Each slope adds or subtracts a quantity of charge proportional to the slope's resistor and the duration of the slope:</p>

<p>

<math display="block" id="Integrating_ADC:49">
 <semantics>
  <mrow>
   <msub>
    <mi>C</mi>
    <mrow>
     <mi>s</mi>
     <mi>l</mi>
     <mi>o</mi>
     <mi>p</mi>
     <mi>e</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo>±</mo>
    <mfrac>
     <mrow>
      <msub>
       <mi>V</mi>
       <mrow>
        <mi>r</mi>
        <mi>e</mi>
        <mi>f</mi>
       </mrow>
      </msub>
      <msub>
       <mi>T</mi>
       <mrow>
        <mi>s</mi>
        <mi>l</mi>
        <mi>o</mi>
        <mi>p</mi>
        <mi>e</mi>
       </mrow>
      </msub>
     </mrow>
     <mrow>
      <msub>
       <mi>R</mi>
       <mrow>
        <mi>s</mi>
        <mi>l</mi>
        <mi>o</mi>
        <mi>p</mi>
        <mi>e</mi>
       </mrow>
      </msub>
      <msub>
       <mi>f</mi>
       <mrow>
        <mi>c</mi>
        <mi>l</mi>
        <mi>k</mi>
       </mrow>
      </msub>
     </mrow>
    </mfrac>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <apply>
      <times></times>
      <ci>s</ci>
      <ci>l</ci>
      <ci>o</ci>
      <ci>p</ci>
      <ci>e</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">plus-or-minus</csymbol>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>V</ci>
        <apply>
         <times></times>
         <ci>r</ci>
         <ci>e</ci>
         <ci>f</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>T</ci>
        <apply>
         <times></times>
         <ci>s</ci>
         <ci>l</ci>
         <ci>o</ci>
         <ci>p</ci>
         <ci>e</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>R</ci>
        <apply>
         <times></times>
         <ci>s</ci>
         <ci>l</ci>
         <ci>o</ci>
         <ci>p</ci>
         <ci>e</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>f</ci>
        <apply>
         <times></times>
         <ci>c</ci>
         <ci>l</ci>
         <ci>k</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{slope}=\pm\dfrac{V_{ref}T_{slope}}{R_{slope}f_{clk}}
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Integrating_ADC:50">
 <semantics>
  <msub>
   <mi>T</mi>
   <mrow>
    <mi>c</mi>
    <mi>l</mi>
    <mi>o</mi>
    <mi>c</mi>
    <mi>k</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>T</ci>
    <apply>
     <times></times>
     <ci>c</ci>
     <ci>l</ci>
     <ci>o</ci>
     <ci>c</ci>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T_{clock}
  </annotation>
 </semantics>
</math>

 is necessarily an integer and will be less than or equal to 

<math display="inline" id="Integrating_ADC:51">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

 for the second and subsequent slopes. Using the circuit above as an example, the second slope, 

<math display="inline" id="Integrating_ADC:52">
 <semantics>
  <mrow>
   <msub>
    <mi>R</mi>
    <mi>d</mi>
   </msub>
   <mo>/</mo>
   <mn>100</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>R</ci>
     <ci>d</ci>
    </apply>
    <cn type="integer">100</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{d}/100
  </annotation>
 </semantics>
</math>

, can contribute the following charge, 

<math display="inline" id="Integrating_ADC:53">
 <semantics>
  <msub>
   <mi>C</mi>
   <mrow>
    <mi>s</mi>
    <mi>l</mi>
    <mi>o</mi>
    <mi>p</mi>
    <mi>e</mi>
    <mn>2</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>C</ci>
    <apply>
     <times></times>
     <ci>s</ci>
     <ci>l</ci>
     <ci>o</ci>
     <ci>p</ci>
     <ci>e</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{slope2}
  </annotation>
 </semantics>
</math>

, to the integrator:</p>

<p>

<math display="block" id="Integrating_ADC:54">
 <semantics>
  <mrow>
   <mfrac>
    <mrow>
     <mn>100</mn>
     <msub>
      <mi>V</mi>
      <mrow>
       <mi>r</mi>
       <mi>e</mi>
       <mi>f</mi>
      </mrow>
     </msub>
    </mrow>
    <mrow>
     <msub>
      <mi>R</mi>
      <mi>d</mi>
     </msub>
     <msub>
      <mi>f</mi>
      <mrow>
       <mi>c</mi>
       <mi>l</mi>
       <mi>k</mi>
      </mrow>
     </msub>
    </mrow>
   </mfrac>
   <mo>≤</mo>
   <msub>
    <mi>C</mi>
    <mrow>
     <mi>s</mi>
     <mi>l</mi>
     <mi>o</mi>
     <mi>p</mi>
     <mi>e</mi>
     <mn>2</mn>
    </mrow>
   </msub>
   <mo>≤</mo>
   <mfrac>
    <mrow>
     <mn>1000</mn>
     <msub>
      <mi>V</mi>
      <mrow>
       <mi>r</mi>
       <mi>e</mi>
       <mi>f</mi>
      </mrow>
     </msub>
    </mrow>
    <mrow>
     <msub>
      <mi>R</mi>
      <mi>d</mi>
     </msub>
     <msub>
      <mi>f</mi>
      <mrow>
       <mi>c</mi>
       <mi>l</mi>
       <mi>k</mi>
      </mrow>
     </msub>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <cn type="integer">100</cn>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>V</ci>
        <apply>
         <times></times>
         <ci>r</ci>
         <ci>e</ci>
         <ci>f</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>R</ci>
        <ci>d</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>f</ci>
        <apply>
         <times></times>
         <ci>c</ci>
         <ci>l</ci>
         <ci>k</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>C</ci>
      <apply>
       <times></times>
       <ci>s</ci>
       <ci>l</ci>
       <ci>o</ci>
       <ci>p</ci>
       <ci>e</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <cn type="integer">1000</cn>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>V</ci>
        <apply>
         <times></times>
         <ci>r</ci>
         <ci>e</ci>
         <ci>f</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>R</ci>
        <ci>d</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>f</ci>
        <apply>
         <times></times>
         <ci>c</ci>
         <ci>l</ci>
         <ci>k</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \dfrac{100V_{ref}}{R_{d}f_{clk}}\leq C_{slope2}\leq\dfrac{1000V_{ref}}{R_{d}f_%
{clk}}
  </annotation>
 </semantics>
</math>

 in steps of 

<math display="inline" id="Integrating_ADC:55">
 <semantics>
  <mstyle displaystyle="true">
   <mfrac>
    <mrow>
     <mn>100</mn>
     <msub>
      <mi>V</mi>
      <mrow>
       <mi>r</mi>
       <mi>e</mi>
       <mi>f</mi>
      </mrow>
     </msub>
    </mrow>
    <mrow>
     <msub>
      <mi>R</mi>
      <mi>d</mi>
     </msub>
     <msub>
      <mi>f</mi>
      <mrow>
       <mi>c</mi>
       <mi>l</mi>
       <mi>k</mi>
      </mrow>
     </msub>
    </mrow>
   </mfrac>
  </mstyle>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <times></times>
     <cn type="integer">100</cn>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>V</ci>
      <apply>
       <times></times>
       <ci>r</ci>
       <ci>e</ci>
       <ci>f</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>R</ci>
      <ci>d</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <apply>
       <times></times>
       <ci>c</ci>
       <ci>l</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \dfrac{100V_{ref}}{R_{d}f_{clk}}
  </annotation>
 </semantics>
</math>

</p>

<p>That is, 

<math display="inline" id="Integrating_ADC:56">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

 possible values with the largest equal to the first slope's smallest step, or one (base 10) digit of resolution per slope. Generalizing this, we can represent the number of slopes, 

<math display="inline" id="Integrating_ADC:57">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

, in terms of the base and the required resolution, 

<math display="inline" id="Integrating_ADC:58">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

:</p>

<p>

<math display="block" id="Integrating_ADC:59">
 <semantics>
  <mrow>
   <mi>N</mi>
   <mo>=</mo>
   <mrow>
    <mi>l</mi>
    <mi>o</mi>
    <msub>
     <mi>g</mi>
     <mi>B</mi>
    </msub>
    <mi>M</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>N</ci>
    <apply>
     <times></times>
     <ci>l</ci>
     <ci>o</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>g</ci>
      <ci>B</ci>
     </apply>
     <ci>M</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N=log_{B}M
  </annotation>
 </semantics>
</math>

</p>

<p>Substituting this back into the equation representing the run-down time required for the second and subsequent slopes gives us this:</p>

<p>

<math display="block" id="Integrating_ADC:60">
 <semantics>
  <mrow>
   <msub>
    <mi>T</mi>
    <mi>d</mi>
   </msub>
   <mo>≤</mo>
   <mrow>
    <mi>B</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mi>l</mi>
       <mi>o</mi>
       <msub>
        <mi>g</mi>
        <mi>B</mi>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>M</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>T</ci>
     <ci>d</ci>
    </apply>
    <apply>
     <times></times>
     <ci>B</ci>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>l</ci>
       <ci>o</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>g</ci>
        <ci>B</ci>
       </apply>
       <ci>M</ci>
      </apply>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T_{d}\leq B(log_{B}(M)-1)
  </annotation>
 </semantics>
</math>

</p>

<p>Which, when evaluated, shows that the minimum run-down time can be achieved using a base of <a href="E_(mathematical_constant)" title="wikilink">e</a>. This base may be difficult to use both in terms of complexity in the calculation of the result and of finding an appropriate resistor network, so a base of 2 or 4 would be more common.</p>
<h4 id="residue-adc">Residue ADC</h4>

<p>When using run-up enhancements like the multi-slope run-up, where a portion of the converter's resolution is resolved during the run-up phase, it is possible to eliminate the run-down phase altogether by using a second type of analog-to-digital converter.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> At the end of the run-up phase of a multi-slope run-up conversion, there will still be an unknown amount of charge remaining on the integrator's capacitor. Instead of using a traditional run-down phase to determine this unknown charge, the unknown voltage can be converted directly by a second converter and combined with the result from the run-up phase to determine the unknown input voltage.</p>

<p>Assuming that multi-slope run-up as described above is being used, the unknown input voltage can be related to the multi-slope run-up counters, 

<math display="inline" id="Integrating_ADC:61">
 <semantics>
  <msub>
   <mi>N</mi>
   <mi>p</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>N</ci>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N_{p}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Integrating_ADC:62">
 <semantics>
  <msub>
   <mi>N</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>N</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N_{n}
  </annotation>
 </semantics>
</math>

, and the measured integrator output voltage, 

<math display="inline" id="Integrating_ADC:63">
 <semantics>
  <msub>
   <mi>V</mi>
   <mrow>
    <mi>o</mi>
    <mi>u</mi>
    <mi>t</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>V</ci>
    <apply>
     <times></times>
     <ci>o</ci>
     <ci>u</ci>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V_{out}
  </annotation>
 </semantics>
</math>

 using the following equation (derived from the multi-slope run-up output equation):</p>

<p>

<math display="block" id="Integrating_ADC:64">
 <semantics>
  <mrow>
   <msub>
    <mi>V</mi>
    <mrow>
     <mi>i</mi>
     <mi>n</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <msub>
      <mi>R</mi>
      <mi>i</mi>
     </msub>
     <mrow>
      <mo>(</mo>
      <mrow>
       <mrow>
        <mrow>
         <mo>-</mo>
         <mstyle displaystyle="true">
          <mfrac>
           <mrow>
            <msub>
             <mi>N</mi>
             <mi>p</mi>
            </msub>
            <msub>
             <mi>V</mi>
             <mrow>
              <mi>r</mi>
              <mi>e</mi>
              <mi>f</mi>
             </mrow>
            </msub>
            <msub>
             <mi>t</mi>
             <mi mathvariant="normal">Δ</mi>
            </msub>
           </mrow>
           <msub>
            <mi>R</mi>
            <mi>p</mi>
           </msub>
          </mfrac>
         </mstyle>
        </mrow>
        <mo>+</mo>
        <mstyle displaystyle="true">
         <mfrac>
          <mrow>
           <msub>
            <mi>N</mi>
            <mi>n</mi>
           </msub>
           <msub>
            <mi>V</mi>
            <mrow>
             <mi>r</mi>
             <mi>e</mi>
             <mi>f</mi>
            </mrow>
           </msub>
           <msub>
            <mi>t</mi>
            <mi mathvariant="normal">Δ</mi>
           </msub>
          </mrow>
          <msub>
           <mi>R</mi>
           <mi>n</mi>
          </msub>
         </mfrac>
        </mstyle>
       </mrow>
       <mo>-</mo>
       <mrow>
        <mi>C</mi>
        <msub>
         <mi>V</mi>
         <mrow>
          <mi>o</mi>
          <mi>u</mi>
          <mi>t</mi>
         </mrow>
        </msub>
       </mrow>
      </mrow>
      <mo>)</mo>
     </mrow>
    </mrow>
    <mrow>
     <mi>N</mi>
     <msub>
      <mi>t</mi>
      <mi mathvariant="normal">Δ</mi>
     </msub>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>V</ci>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>R</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <minus></minus>
       <apply>
        <plus></plus>
        <apply>
         <minus></minus>
         <apply>
          <divide></divide>
          <apply>
           <times></times>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>N</ci>
            <ci>p</ci>
           </apply>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>V</ci>
            <apply>
             <times></times>
             <ci>r</ci>
             <ci>e</ci>
             <ci>f</ci>
            </apply>
           </apply>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>t</ci>
            <ci>normal-Δ</ci>
           </apply>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>R</ci>
           <ci>p</ci>
          </apply>
         </apply>
        </apply>
        <apply>
         <divide></divide>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>N</ci>
           <ci>n</ci>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>V</ci>
           <apply>
            <times></times>
            <ci>r</ci>
            <ci>e</ci>
            <ci>f</ci>
           </apply>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>t</ci>
           <ci>normal-Δ</ci>
          </apply>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>R</ci>
          <ci>n</ci>
         </apply>
        </apply>
       </apply>
       <apply>
        <times></times>
        <ci>C</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>V</ci>
         <apply>
          <times></times>
          <ci>o</ci>
          <ci>u</ci>
          <ci>t</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>N</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>t</ci>
       <ci>normal-Δ</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V_{in}=\dfrac{R_{i}\left(-\dfrac{N_{p}V_{ref}t_{\Delta}}{R_{p}}+\dfrac{N_{n}V_%
{ref}t_{\Delta}}{R_{n}}-CV_{out}\right)}{Nt_{\Delta}}
  </annotation>
 </semantics>
</math>

</p>

<p>This equation represents the theoretical calculation of the input voltage assuming ideal components. Since the equation depends on nearly all of the circuit's parameters, any variances in reference currents, the integrator capacitor, or other values will introduce errors in the result. A calibration factor is typically included in the 

<math display="inline" id="Integrating_ADC:65">
 <semantics>
  <mrow>
   <mi>C</mi>
   <msub>
    <mi>V</mi>
    <mrow>
     <mi>o</mi>
     <mi>u</mi>
     <mi>t</mi>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>C</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>V</ci>
     <apply>
      <times></times>
      <ci>o</ci>
      <ci>u</ci>
      <ci>t</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   CV_{out}
  </annotation>
 </semantics>
</math>

 term to account for measured errors (or, as described in the referenced patent, to convert the residue ADC's output into the units of the run-up counters).</p>

<p>Instead of being used to eliminate the run-down phase completely, the residue ADC can also be used to make the run-down phase more accurate than would otherwise be possible.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> With a traditional run-down phase, the run-down time measurement period ends with the integrator output crossing through zero volts. There is a certain amount of error involved in detecting the zero crossing using a comparator (one of the short-comings of the basic dual-slope design as explained above). By using the residue ADC to rapidly sample the integrator output (synchronized with the converter controller's clock, for example), a voltage reading can be taken both immediately before and immediately after the zero crossing (as measured with a comparator). As the slope of the integrator voltage is constant during the run-down phase, the two voltage measurements can be used as inputs to an interpolation function that more accurately determines the time of the zero-crossing (i.e., with a much higher resolution than the controller's clock alone would allow).</p>
<h3 id="other-improvements">Other improvements</h3>
<h4 id="continuously-integrating-converter">Continuously-integrating converter</h4>

<p>By combining some of these enhancements to the basic dual-slope design (namely multi-slope run-up and the residue ADC), it is possible to construct an integrating analog-to-digital converter that is capable of operating continuously without the need for a run-down interval.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> Conceptually, the multi-slope run-up algorithm is allowed to operate continuously. To start a conversion, two things happen simultaneously: the residue ADC is used to measure the approximate charge currently on the integrator capacitor and the counters monitoring the multi-slope run-up are reset. At the end of a conversion period, another residue ADC reading is taken and the values of the multi-slope run-up counters are noted.</p>

<p>The unknown input is calculated using a similar equation as used for the residue ADC, except that two output voltages are included (

<math display="inline" id="Integrating_ADC:66">
 <semantics>
  <msub>
   <mi>V</mi>
   <mrow>
    <mi>o</mi>
    <mi>u</mi>
    <mi>t</mi>
    <mn>1</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>V</ci>
    <apply>
     <times></times>
     <ci>o</ci>
     <ci>u</ci>
     <ci>t</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V_{out1}
  </annotation>
 </semantics>
</math>

 representing the measured integrator voltage at the start of the conversion, and 

<math display="inline" id="Integrating_ADC:67">
 <semantics>
  <msub>
   <mi>V</mi>
   <mrow>
    <mi>o</mi>
    <mi>u</mi>
    <mi>t</mi>
    <mn>2</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>V</ci>
    <apply>
     <times></times>
     <ci>o</ci>
     <ci>u</ci>
     <ci>t</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V_{out2}
  </annotation>
 </semantics>
</math>

 representing the measured integrator voltage at the end of the conversion.</p>

<p>

<math display="block" id="Integrating_ADC:68">
 <semantics>
  <mrow>
   <msub>
    <mi>V</mi>
    <mrow>
     <mi>i</mi>
     <mi>n</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <msub>
      <mi>R</mi>
      <mi>i</mi>
     </msub>
     <mrow>
      <mo>(</mo>
      <mrow>
       <mrow>
        <mrow>
         <mo>-</mo>
         <mstyle displaystyle="true">
          <mfrac>
           <mrow>
            <msub>
             <mi>N</mi>
             <mi>p</mi>
            </msub>
            <msub>
             <mi>V</mi>
             <mrow>
              <mi>r</mi>
              <mi>e</mi>
              <mi>f</mi>
             </mrow>
            </msub>
            <msub>
             <mi>t</mi>
             <mi mathvariant="normal">Δ</mi>
            </msub>
           </mrow>
           <msub>
            <mi>R</mi>
            <mi>p</mi>
           </msub>
          </mfrac>
         </mstyle>
        </mrow>
        <mo>+</mo>
        <mstyle displaystyle="true">
         <mfrac>
          <mrow>
           <msub>
            <mi>N</mi>
            <mi>n</mi>
           </msub>
           <msub>
            <mi>V</mi>
            <mrow>
             <mi>r</mi>
             <mi>e</mi>
             <mi>f</mi>
            </mrow>
           </msub>
           <msub>
            <mi>t</mi>
            <mi mathvariant="normal">Δ</mi>
           </msub>
          </mrow>
          <msub>
           <mi>R</mi>
           <mi>n</mi>
          </msub>
         </mfrac>
        </mstyle>
       </mrow>
       <mo>-</mo>
       <mrow>
        <mi>C</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <msub>
           <mi>V</mi>
           <mrow>
            <mi>o</mi>
            <mi>u</mi>
            <mi>t</mi>
            <mn>2</mn>
           </mrow>
          </msub>
          <mo>-</mo>
          <msub>
           <mi>V</mi>
           <mrow>
            <mi>o</mi>
            <mi>u</mi>
            <mi>t</mi>
            <mn>1</mn>
           </mrow>
          </msub>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
      <mo>)</mo>
     </mrow>
    </mrow>
    <mrow>
     <mi>N</mi>
     <msub>
      <mi>t</mi>
      <mi mathvariant="normal">Δ</mi>
     </msub>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>V</ci>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>R</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <minus></minus>
       <apply>
        <plus></plus>
        <apply>
         <minus></minus>
         <apply>
          <divide></divide>
          <apply>
           <times></times>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>N</ci>
            <ci>p</ci>
           </apply>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>V</ci>
            <apply>
             <times></times>
             <ci>r</ci>
             <ci>e</ci>
             <ci>f</ci>
            </apply>
           </apply>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>t</ci>
            <ci>normal-Δ</ci>
           </apply>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>R</ci>
           <ci>p</ci>
          </apply>
         </apply>
        </apply>
        <apply>
         <divide></divide>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>N</ci>
           <ci>n</ci>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>V</ci>
           <apply>
            <times></times>
            <ci>r</ci>
            <ci>e</ci>
            <ci>f</ci>
           </apply>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>t</ci>
           <ci>normal-Δ</ci>
          </apply>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>R</ci>
          <ci>n</ci>
         </apply>
        </apply>
       </apply>
       <apply>
        <times></times>
        <ci>C</ci>
        <apply>
         <minus></minus>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>V</ci>
          <apply>
           <times></times>
           <ci>o</ci>
           <ci>u</ci>
           <ci>t</ci>
           <cn type="integer">2</cn>
          </apply>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>V</ci>
          <apply>
           <times></times>
           <ci>o</ci>
           <ci>u</ci>
           <ci>t</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>N</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>t</ci>
       <ci>normal-Δ</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V_{in}=\dfrac{R_{i}\left(-\dfrac{N_{p}V_{ref}t_{\Delta}}{R_{p}}+\dfrac{N_{n}V_%
{ref}t_{\Delta}}{R_{n}}-C(V_{out2}-V_{out1})\right)}{Nt_{\Delta}}
  </annotation>
 </semantics>
</math>

</p>

<p>Such a continuously-integrating converter is very similar to a <a href="delta-sigma_modulation" title="wikilink">delta-sigma analog-to-digital converter</a>.</p>
<h2 id="calibration">Calibration</h2>

<p>In most variants of the dual-slope integrating converter, the converter's performance is dependent on one or more of the circuit parameters. In the case of the basic design, the output of the converter is in terms of the reference voltage. In more advanced designs, there are also dependencies on one or more resistors used in the circuit or on the integrator capacitor being used. In all cases, even using expensive precision components there may be other effects that are not accounted for in the general dual-slope equations (dielectric effect on the capacitor or frequency or temperature dependencies on any of the components). Any of these variations result in error in the output of the converter. In the best case, this is simply gain and/or offset error. In the worst case, nonlinearity or nonmonotonicity could result.</p>

<p>Some calibration can be performed internal to the converter (i.e., not requiring any special external input). This type of calibration would be performed every time the converter is turned on, periodically while the converter is running, or only when a special calibration mode is entered. Another type of calibration requires external inputs of known quantities (e.g., <a href="Voltage_reference" title="wikilink">voltage standards</a> or precision resistance references) and would typically be performed infrequently (every year for equipment used in normal conditions, more often when being used in <a class="uri" href="metrology" title="wikilink">metrology</a> applications).</p>

<p>Of these types of error, offset error is the simplest to correct (assuming that there is a constant offset over the entire range of the converter). This is often done internal to the converter itself by periodically taking measurements of the ground potential. Ideally, measuring the ground should always result in a zero output. Any non-zero output indicates the offset error in the converter. That is, if the measurement of ground resulted in an output of 0.001 volts, one can assume that all measurements will be offset by the same amount and can subtract 0.001 from all subsequent results.</p>

<p>Gain error can similarly be measured and corrected internally (again assuming that there is a constant gain error over the entire output range). The voltage reference (or some voltage derived directly from the reference) can be used as the input to the converter. If the assumption is made that the voltage reference is accurate (to within the tolerances of the converter) or that the voltage reference has been externally calibrated against a voltage standard, any error in the measurement would be a gain error in the converter. If, for example, the measurement of a converter's 5 volt reference resulted in an output of 5.3 volts (after accounting for any offset error), a gain multiplier of 0.94 (5 / 5.3) can be applied to any subsequent measurement results.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Analog-to-digital_converter" title="wikilink">Analog-to-digital converter</a></li>
<li><a class="uri" href="Voltmeter" title="wikilink">Voltmeter</a></li>
</ul>
<h2 id="footnotes">Footnotes</h2>
<h2 id="references">References</h2>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Measuring_instruments" title="wikilink">Category:Measuring instruments</a> <a href="Category:Electronic_test_equipment" title="wikilink">Category:Electronic test equipment</a> <a href="Category:Electronic_circuits" title="wikilink">Category:Electronic circuits</a> <a href="Category:Analog_circuits" title="wikilink">Category:Analog circuits</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Goeke, HP Journal, page 9<a href="#fnref1">↩</a></li>
<li id="fn2">Hewlett-Packard Catalog, 1981, page 49, stating, "For small inputs, noise becomes a problem and for large inputs, the dielectric absorption of the capacitor becomes a problem."<a href="#fnref2">↩</a></li>
<li id="fn3">Eng 1994<a href="#fnref3">↩</a></li>
<li id="fn4">Eng 1994, Goeke 1989<a href="#fnref4">↩</a></li>
<li id="fn5">HP Journal, page 9, stating, "Multislope rundown reduces the time to perform rundown."<a href="#fnref5">↩</a></li>
<li id="fn6">Riedel 1992<a href="#fnref6">↩</a></li>
<li id="fn7">Regier 2001<a href="#fnref7">↩</a></li>
<li id="fn8">Goeke 1992<a href="#fnref8">↩</a></li>
</ol>
</section>
</body>
</html>
