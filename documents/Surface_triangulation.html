<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="812">Surface triangulation</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Surface triangulation</h1>
<hr/>

<p> </p>

<p><strong>Triangulation</strong> of a <a class="uri" href="surface" title="wikilink">surface</a> means</p>
<dl>
<dd>a) a <em>net</em> of triangles, which covers a given surface partly or totally <em>or</em>
</dd>
<dd>b) the <em>procedure</em> of generating the points and triangles of such a net of triangles.
</dd>
</dl>

<p>In this article the generation of a net of triangles will be described. In literature there are contributions which deal with the optimization of a given net.</p>

<p>Surface triangulations are important for</p>
<ul>
<li><a href="Visualization_(computer_graphics)" title="wikilink">visualizing</a> surfaces and</li>
<li>the application of <a href="finite_element_method" title="wikilink">finite element methods</a>.</li>
</ul>

<p>The triangulation of a <em>parametrically</em> defined surface is an easy task. You just triangulate the area of definition (s. 2. picture). But the images of these triangles in object space may vary in shape and extension, which may be a drawback. This drawback can be minimized by adaptive methods, which use 3D-informations (step width) while triangulating the parameter area.</p>

<p>To triangulate an <em>implicit surface</em> (defined by one or more equations) is more difficult. There exist essentially two methods: a) One method divides the 3D-area of consideration into cubes and determines the intersections of the surface with the edges of the cubes in order to get polygons on the surface, which thereafter have to be triangulated (<em>cutting cube method</em>),.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a><a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> The expenditure for managing the data is great. b) The second and more simple concept is the idea of the <em>marching method</em>,<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a><a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a><a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> The triangulation starts with a triangulated hexagon at a starting point. Step by step there will be added new triangles following given rules until the surface of consideration is triangulated. If the surface consists of several components, the algorithm has to be started several times using suitable starting points. The cutting cube algorithm determines at the same time all components of the surface within the surrounding starting cube depending on prescribed limit parameters. An advantage of the marching method is the possibility to prescribe boundaries (s. picture).</p>

<p><strong>Polygonizing</strong> a surface means to generate a <a href="polygon_mesh" title="wikilink">polygon mesh</a>.</p>

<p>The triangulation of a surface should not be confused with the triangulation of a <a href="Discrete_mathematics" title="wikilink">discrete</a> prescribed plane <em>set of points</em>. See <a href="Delaunay_triangulation" title="wikilink">Delaunay triangulation</a>. {{-}}</p>

<p><a class="uri" href="File:Triang-cyl-sph4.png|Triangulation">File:Triang-cyl-sph4.png|Triangulation</a>: cylinder, surface 

<math display="inline" id="Surface_triangulation:0">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>x</mi>
     <mn>4</mn>
    </msup>
    <mo>+</mo>
    <msup>
     <mi>y</mi>
     <mn>4</mn>
    </msup>
    <mo>+</mo>
    <msup>
     <mi>z</mi>
     <mn>4</mn>
    </msup>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <cn type="integer">4</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>y</ci>
      <cn type="integer">4</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>z</ci>
      <cn type="integer">4</cn>
     </apply>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{4}+y^{4}+z^{4}=1
  </annotation>
 </semantics>
</math>

 <a class="uri" href="File:Triang-cyl-sph4-pov.png|Triangulation">File:Triang-cyl-sph4-pov.png|Triangulation</a>: cylinder, surface 

<math display="inline" id="Surface_triangulation:1">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>x</mi>
     <mn>4</mn>
    </msup>
    <mo>+</mo>
    <msup>
     <mi>y</mi>
     <mn>4</mn>
    </msup>
    <mo>+</mo>
    <msup>
     <mi>z</mi>
     <mn>4</mn>
    </msup>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <cn type="integer">4</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>y</ci>
      <cn type="integer">4</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>z</ci>
      <cn type="integer">4</cn>
     </apply>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{4}+y^{4}+z^{4}=1
  </annotation>
 </semantics>
</math>

, <a class="uri" href="povray" title="wikilink">povray</a>-image</p>

<p><a class="uri" href="File:Torus-triang.png|Torus">File:Torus-triang.png|Torus</a>: triangulated by the marching method <a class="uri" href="File:Torus-cutting-cube.png|Torus">File:Torus-cutting-cube.png|Torus</a>: polygonized by the cutting cube method</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Computer-aided_design" title="wikilink">Computer-aided design</a></li>
<li><a href="Tessellation_(computer_graphics)" title="wikilink">Tessellation (computer graphics)</a></li>
</ul>
<h2 id="references">References</h2>
<references>
</references>
<h2 id="external-links">External links</h2>
<ul>
<li>Tasso Karkanis &amp; A. James Stewart: <em>Curvature-Dependent Triangulation of Implicit Surfaces</em> <a href="http://cs.queensu.ca/~jstewart/papers/cga01.html">1</a></li>
</ul>

<p>"</p>

<p><a class="uri" href="Category:Surfaces" title="wikilink">Category:Surfaces</a> <a href="Category:Computer-aided_design" title="wikilink">Category:Computer-aided design</a> <a href="Category:Finite_element_method" title="wikilink">Category:Finite element method</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">M. Schmidt: <em>Cutting Cubes – visualizing implicit surfaces by adaptive polygonization</em>. Visual Computer (1993) 10, pp. 101–115<a href="#fnref1">↩</a></li>
<li id="fn2">J. Bloomenthal: Polygonization of implicit surfaces, Computer Aided Geometric Design (1988), pp. 341–355<a href="#fnref2">↩</a></li>
<li id="fn3"><a href="http://www.mathematik.tu-darmstadt.de/~ehartmann/cdgen0104.pdf">E. Hartmann: <em>Geometry and Algorithms for COMPUTER AIDED DESIGN</em></a>, p. 81<a href="#fnref3">↩</a></li>
<li id="fn4">E. Hartmann: <em>A marching method for the triangulation of surfaces</em>, The Visual Computer (1998), 14, pp. 95–108<a href="#fnref4">↩</a></li>
<li id="fn5">S. Akkouche &amp; E Galin: <em>Adaptive Implicit Surface Polygonization Using Marching Triangles</em>, COMPUTER GRAPHICS forum (2001), Vol. 20, pp. 67–80<a href="#fnref5">↩</a></li>
</ol>
</section>
</body>
</html>
