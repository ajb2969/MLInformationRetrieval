   Discrete Fourier transform (general)      Discrete Fourier transform (general)   This article is about the discrete Fourier transform (DFT) over any ring , commonly called a number-theoretic transform (NTT) in the case of finite fields . For specific information on the discrete Fourier transform over the complex numbers , see discrete Fourier transform .  Definition  Let   R   R   R   be any ring , let    n  â‰¥  1      n  1    n\geq 1   be an integer, and let    Î±  âˆˆ  R      Î±  R    \alpha\in R   be a principal n th root of unity, defined by: 1        Î±  n   =  1       superscript  Î±  n   1    \alpha^{n}=1           âˆ‘   j  =  0    n  -  1     Î±   j  k     =  0        superscript   subscript     j  0      n  1     superscript  Î±    j  k     0    \sum_{j=0}^{n-1}\alpha^{jk}=0   for     1  â‰¤  k  <  n    (  1  )      formulae-sequence      1  k       n    1    1\leq k      The discrete Fourier transform maps an n-tuple     (   v  0   ,  â€¦  ,   v   n  -  1    )      subscript  v  0   normal-â€¦   subscript  v    n  1      (v_{0},\ldots,v_{n-1})   of elements of   R   R   R   to another n-tuple    (   f  0   ,  â€¦  ,   f   n  -  1    )      subscript  f  0   normal-â€¦   subscript  f    n  1      (f_{0},\ldots,f_{n-1})   of elements of   R   R   R   according to the following formula:       f  k   =   âˆ‘   j  =  0    n  -  1     v  j    Î±   j  k    .   (  2  )      fragments   subscript  f  k     superscript   subscript     j  0      n  1     subscript  v  j    superscript  Î±    j  k    normal-.  italic-   fragments  normal-(  2  normal-)     f_{k}=\sum_{j=0}^{n-1}v_{j}\alpha^{jk}.\qquad(2)     By convention, the tuple    (   v  0   ,  â€¦  ,   v   n  -  1    )      subscript  v  0   normal-â€¦   subscript  v    n  1      (v_{0},\ldots,v_{n-1})   is said to be in the time domain and the index   j   j   j   is called time . The tuple    (   f  0   ,  â€¦  ,   f   n  -  1    )      subscript  f  0   normal-â€¦   subscript  f    n  1      (f_{0},\ldots,f_{n-1})   is said to be in the frequency domain and the index   k   k   k   is called frequency . The tuple    (   f  0   ,  â€¦  ,   f   n  -  1    )      subscript  f  0   normal-â€¦   subscript  f    n  1      (f_{0},\ldots,f_{n-1})   is also called the spectrum of    (   v  0   ,  â€¦  ,   v   n  -  1    )      subscript  v  0   normal-â€¦   subscript  v    n  1      (v_{0},\ldots,v_{n-1})   . This terminology derives from the applications of Fourier transforms in signal processing .  If   R   R   R   is an integral domain (which includes fields ), it is sufficient to choose   Î±   Î±   \alpha   as a primitive n th root of unity , which replaces the condition (1) by: 2       Î±  k   â‰   1       superscript  Î±  k   1    \alpha^{k}\neq 1   for    1  â‰¤  k  <  n        1  k       n     1\leq k     Proof: take    Î²  =   Î±  k       Î²   superscript  Î±  k     \beta=\alpha^{k}   with    1  â‰¤  k  <  n        1  k       n     1\leq k   . Since     Î±  n   =  1       superscript  Î±  n   1    \alpha^{n}=1   ,     Î²  n   =    (   Î±  n   )   k   =  1         superscript  Î²  n    superscript   superscript  Î±  n   k        1     \beta^{n}=(\alpha^{n})^{k}=1   , giving:        Î²  n   -  1   =    (   Î²  -  1   )    (    âˆ‘   j  =  0    n  -  1     Î²  j    )    =  0           superscript  Î²  n   1       Î²  1     superscript   subscript     j  0      n  1     superscript  Î²  j          0     \beta^{n}-1=(\beta-1)\left(\sum_{j=0}^{n-1}\beta^{j}\right)=0   where the sum matches (1). Since   Î±   Î±   \alpha   is a primitive root of unity,     Î²  -  1   â‰   0        Î²  1   0    \beta-1\neq 0   . Since   R   R   R   is an integral domain, the sum must be zero. âˆŽ  Another simple condition applies in the case where n is a power of two: (1) may be replaced by     Î±   n  /  2    =   -  1        superscript  Î±    n  2      1     \alpha^{n/2}=-1   . 3  Inverse  The inverse of the discrete Fourier transform is given as:       v  j   =   1  n    âˆ‘   k  =  0    n  -  1     f  k    Î±   -   j  k     .   (  3  )      fragments   subscript  v  j      1  n    superscript   subscript     k  0      n  1     subscript  f  k    superscript  Î±      j  k     normal-.  italic-   fragments  normal-(  3  normal-)     v_{j}=\frac{1}{n}\sum_{k=0}^{n-1}f_{k}\alpha^{-jk}.\qquad(3)     where    1  /  n      1  n    1/n   is the multiplicative inverse of   n   n   n   in   R   R   R   (if this inverse does not exist, the DFT cannot be inverted).  Proof: Substituting (2) into the right-hand-side of (3), we get        1  n       âˆ‘   k  =  0    n  -  1       f  k    Î±   -   j  k             1  n     superscript   subscript     k  0      n  1       subscript  f  k    superscript  Î±      j  k         \displaystyle\frac{1}{n}\sum_{k=0}^{n-1}f_{k}\alpha^{-jk}     This is exactly equal to    v  j     subscript  v  j    v_{j}   , because      âˆ‘   k  =  0    n  -  1     Î±    (    j  â€²   -  j   )   k     =  0        superscript   subscript     k  0      n  1     superscript  Î±       superscript  j  normal-â€²   j   k     0    \sum_{k=0}^{n-1}\alpha^{(j^{\prime}-j)k}=0   when     j  â€²   â‰   j       superscript  j  normal-â€²   j    j^{\prime}\neq j   (by (1) with    k  =    j  â€²   -  j       k     superscript  j  normal-â€²   j     k=j^{\prime}-j   ), and      âˆ‘   k  =  0    n  -  1     Î±    (    j  â€²   -  j   )   k     =  n        superscript   subscript     k  0      n  1     superscript  Î±       superscript  j  normal-â€²   j   k     n    \sum_{k=0}^{n-1}\alpha^{(j^{\prime}-j)k}=n   when     j  â€²   =  j       superscript  j  normal-â€²   j    j^{\prime}=j   . âˆŽ  Matrix formulation  Since the discrete Fourier transform is a linear operator , it can be described by matrix multiplication . In matrix notation, the discrete Fourier transform is expressed as follows:        [      f  0        f  1       â‹®       f   n  -  1       ]   =    [     1    1    1    â‹¯    1      1    Î±     Î±  2     â‹¯     Î±   n  -  1        1     Î±  2      Î±  4     â‹¯     Î±   2   (   n  -  1   )         â‹®    â‹®    â‹®       â‹®      1     Î±   n  -  1       Î±   2   (   n  -  1   )       â‹¯     Î±    (   n  -  1   )    (   n  -  1   )        ]    [      v  0        v  1       â‹®       v   n  -  1       ]     .         subscript  f  0      subscript  f  1     normal-â‹®     subscript  f    n  1          1  1  1  normal-â‹¯  1    1  Î±   superscript  Î±  2   normal-â‹¯   superscript  Î±    n  1      1   superscript  Î±  2    superscript  Î±  4   normal-â‹¯   superscript  Î±    2    n  1       normal-â‹®  normal-â‹®  normal-â‹®  absent  normal-â‹®    1   superscript  Î±    n  1     superscript  Î±    2    n  1     normal-â‹¯   superscript  Î±      n  1     n  1          subscript  v  0      subscript  v  1     normal-â‹®     subscript  v    n  1         \begin{bmatrix}f_{0}\\
 f_{1}\\
 \vdots\\
 f_{n-1}\end{bmatrix}=\begin{bmatrix}1&1&1&\cdots&1\\
 1&\alpha&\alpha^{2}&\cdots&\alpha^{n-1}\\
 1&\alpha^{2}&\alpha^{4}&\cdots&\alpha^{2(n-1)}\\
 \vdots&\vdots&\vdots&&\vdots\\
 1&\alpha^{n-1}&\alpha^{2(n-1)}&\cdots&\alpha^{(n-1)(n-1)}\\
 \end{bmatrix}\begin{bmatrix}v_{0}\\
 v_{1}\\
 \vdots\\
 v_{n-1}\end{bmatrix}.   The matrix for this transformation is called the DFT matrix .  Similarly, the matrix notation for the inverse Fourier transform is        [      v  0        v  1       â‹®       v   n  -  1       ]   =    1  n    [     1    1    1    â‹¯    1      1     Î±   -  1       Î±   -  2      â‹¯     Î±   -   (   n  -  1   )         1     Î±   -  2       Î±   -  4      â‹¯     Î±   -   2   (   n  -  1   )          â‹®    â‹®    â‹®       â‹®      1     Î±   -   (   n  -  1   )        Î±   -   2   (   n  -  1   )        â‹¯     Î±   -    (   n  -  1   )    (   n  -  1   )         ]    [      f  0        f  1       â‹®       f   n  -  1       ]     .         subscript  v  0      subscript  v  1     normal-â‹®     subscript  v    n  1          1  n     1  1  1  normal-â‹¯  1    1   superscript  Î±    1     superscript  Î±    2    normal-â‹¯   superscript  Î±      n  1       1   superscript  Î±    2     superscript  Î±    4    normal-â‹¯   superscript  Î±      2    n  1        normal-â‹®  normal-â‹®  normal-â‹®  absent  normal-â‹®    1   superscript  Î±      n  1      superscript  Î±      2    n  1      normal-â‹¯   superscript  Î±        n  1     n  1           subscript  f  0      subscript  f  1     normal-â‹®     subscript  f    n  1         \begin{bmatrix}v_{0}\\
 v_{1}\\
 \vdots\\
 v_{n-1}\end{bmatrix}=\frac{1}{n}\begin{bmatrix}1&1&1&\cdots&1\\
 1&\alpha^{-1}&\alpha^{-2}&\cdots&\alpha^{-(n-1)}\\
 1&\alpha^{-2}&\alpha^{-4}&\cdots&\alpha^{-2(n-1)}\\
 \vdots&\vdots&\vdots&&\vdots\\
 1&\alpha^{-(n-1)}&\alpha^{-2(n-1)}&\cdots&\alpha^{-(n-1)(n-1)}\end{bmatrix}%
 \begin{bmatrix}f_{0}\\
 f_{1}\\
 \vdots\\
 f_{n-1}\end{bmatrix}.     Polynomial formulation 4  Sometimes it is convenient to identify an   n   n   n   -tuple    (   v  0   ,  â€¦  ,   v   n  -  1    )      subscript  v  0   normal-â€¦   subscript  v    n  1      (v_{0},\ldots,v_{n-1})   with a formal polynomial         p  v    (  x  )    =    v  0   +    v  1   x   +    v  2    x  2    +  â‹¯  +    v   n  -  1     x   n  -  1       .         subscript  p  v   x      subscript  v  0      subscript  v  1   x      subscript  v  2    superscript  x  2    normal-â‹¯     subscript  v    n  1     superscript  x    n  1        p_{v}(x)=v_{0}+v_{1}x+v_{2}x^{2}+\cdots+v_{n-1}x^{n-1}.\,     By writing out the summation in the definition of the discrete Fourier transform (2), we obtain:        f  k   =    v  0   +    v  1    Î±  k    +    v  2    Î±   2  k     +  â‹¯  +    v   n  -  1     Î±    (   n  -  1   )   k       .       subscript  f  k      subscript  v  0      subscript  v  1    superscript  Î±  k       subscript  v  2    superscript  Î±    2  k     normal-â‹¯     subscript  v    n  1     superscript  Î±      n  1   k        f_{k}=v_{0}+v_{1}\alpha^{k}+v_{2}\alpha^{2k}+\cdots+v_{n-1}\alpha^{(n-1)k}.\,     This means that    f  k     subscript  f  k    f_{k}   is just the value of the polynomial     p  v    (  x  )        subscript  p  v   x    p_{v}(x)   for    x  =   Î±  k       x   superscript  Î±  k     x=\alpha^{k}   , i.e.,        f  k   =    p  v    (   Î±  k   )     .       subscript  f  k      subscript  p  v    superscript  Î±  k      f_{k}=p_{v}(\alpha^{k}).\,     The Fourier transform can therefore be seen to relate the coefficients and the values of a polynomial: the coefficients are in the time-domain, and the values are in the frequency domain. Here, of course, it is important that the polynomial is evaluated at the   n   n   n   th roots of unity, which are exactly the powers of   Î±   Î±   \alpha   .  Similarly, the definition of the inverse Fourier transform (3) can be written:       v  j   =   1  n    (   f  0   +   f  1    Î±   -  j    +   f  2    Î±   -   2  j     +  â‹¯  +   f   n  -  1     Î±   -    (   n  -  1   )   j     )   .   (  5  )      fragments   subscript  v  j      1  n    fragments  normal-(   subscript  f  0     subscript  f  1    superscript  Î±    j      subscript  f  2    superscript  Î±      2  j      normal-â‹¯    subscript  f    n  1     superscript  Î±        n  1   j     normal-)   normal-.  italic-   fragments  normal-(  5  normal-)     v_{j}=\frac{1}{n}(f_{0}+f_{1}\alpha^{-j}+f_{2}\alpha^{-2j}+\cdots+f_{n-1}%
 \alpha^{-(n-1)j}).\qquad(5)     With         p  f    (  x  )    =    f  0   +    f  1   x   +    f  2    x  2    +  â‹¯  +    f   n  -  1     x   n  -  1       ,         subscript  p  f   x      subscript  f  0      subscript  f  1   x      subscript  f  2    superscript  x  2    normal-â‹¯     subscript  f    n  1     superscript  x    n  1        p_{f}(x)=f_{0}+f_{1}x+f_{2}x^{2}+\cdots+f_{n-1}x^{n-1},     this means that        v  j   =    1  n    p  f    (   Î±   -  j    )     .       subscript  v  j       1  n    subscript  p  f    superscript  Î±    j       v_{j}=\frac{1}{n}p_{f}(\alpha^{-j}).     We can summarize this as follows: if the values of    p   (  x  )       p  x    p(x)   are the coefficients of    q   (  x  )       q  x    q(x)   , then the values of    q   (  x  )       q  x    q(x)   are the coefficients of    p   (  x  )       p  x    p(x)   , up to a scalar factor and reordering.  Special cases  Complex numbers  If    F  =  â„‚      F  â„‚    F={\mathbb{C}}   is the field of complex numbers, then the   n   n   n   th roots of unity can be visualized as points on the unit circle of the complex plane . In this case, one usually takes       Î±  =   e    -   2  Ï€  i    n     ,      Î±   superscript  e        2  Ï€  i    n      \alpha=e^{\frac{-2\pi i}{n}},     which yields the usual formula for the complex discrete Fourier transform :        f  k   =    âˆ‘   j  =  0    n  -  1      v  j    e     -   2  Ï€  i    n   j  k       .       subscript  f  k     superscript   subscript     j  0      n  1       subscript  v  j    superscript  e          2  Ï€  i    n   j  k        f_{k}=\sum_{j=0}^{n-1}v_{j}e^{\frac{-2\pi i}{n}jk}.     Over the complex numbers, it is often customary to normalize the formulas for the DFT and inverse DFT by using the scalar factor    1   n       1    n     \frac{1}{\sqrt{n}}   in both formulas, rather than   1   1   1   in the formula for the DFT and    1  n      1  n    \frac{1}{n}   in the formula for the inverse DFT. With this normalization, the DFT matrix is then unitary. Note that    n      n    \sqrt{n}   does not make sense in an arbitrary field.  Finite fields  If    F  =   G  F   (  q  )        F    G  F  q     F=GF(q)   is a finite field , where   q   q   q   is a prime power, then the existence of a primitive   n   n   n   th root automatically implies that   n   n   n    divides     q  -  1      q  1    q-1   (because the multiplicative order of each element must divide the size of the multiplicative group of   F   F   F   , which is    q  -  1      q  1    q-1   ). This in particular ensures that    n  =     1  +  1  +  â‹¯  +  1   âŸ     n   times        n   subscript   normal-âŸ    1  1  normal-â‹¯  1      n  times      n=\underbrace{1+1+\cdots+1}_{n\ \rm times}   is invertible, so that the notation    1  n      1  n    \frac{1}{n}   in (3) makes sense.  An application of the discrete Fourier transform over    G  F   (  q  )       G  F  q    GF(q)   is the reduction of Reedâ€“Solomon codes to BCH codes in coding theory . Such transform can be carried out efficiently with proper fast algorithms, for example, cyclotomic fast Fourier transform .  Number-theoretic transform  The number-theoretic transform (NTT) is obtained by specializing the discrete Fourier transform to    F  =   â„¤  /  p       F    â„¤  p     F={\mathbb{Z}}/p   , the integers modulo a prime   p   p   p    . This is a finite field , and primitive   n   n   n   th roots of unity exist whenever   n   n   n   divides    p  -  1      p  1    p-1   , so we have    p  =    Î¾  n   +  1       p      Î¾  n   1     p=\xi n+1   for a positive integer   Î¾   Î¾   \xi   . Specifically, let   Ï‰   Ï‰   \omega   be a primitive    (   p  -  1   )      p  1    (p-1)   th root of unity, then an   n   n   n   th root of unity   Î±   Î±   \alpha   can be found by letting    Î±  =   Ï‰  Î¾       Î±   superscript  Ï‰  Î¾     \alpha=\omega^{\xi}   .  e.g  for    p  =  5      p  5    p=5   ,    Î±  =  2      Î±  2    \alpha=2        2  1   =   2   (   m  o  d  5   )         superscript  2  1     2    m  o  d  5      2^{1}=2(mod5)   ,     2  2   =   4   (   m  o  d  5   )         superscript  2  2     4    m  o  d  5      2^{2}=4(mod5)   ,     2  3   =   3   (   m  o  d  5   )         superscript  2  3     3    m  o  d  5      2^{3}=3(mod5)   ,     2  4   =   1   (   m  o  d  5   )         superscript  2  4     1    m  o  d  5      2^{4}=1(mod5)     when    N  =  4      N  4    N=4          [      F   (  0  )         F   (  1  )         F   (  2  )         F   (  3  )       ]   =    [     1    1    1    1      1    2    4    3      1    4    1    4      1    3    4    2     ]    [      f   (  0  )         f   (  1  )         f   (  2  )         f   (  3  )       ]            F  0       F  1       F  2       F  3         1  1  1  1    1  2  4  3    1  4  1  4    1  3  4  2        f  0       f  1       f  2       f  3        \begin{bmatrix}F(0)\\
 F(1)\\
 F(2)\\
 F(3)\end{bmatrix}=\begin{bmatrix}1&1&1&1\\
 1&2&4&3\\
 1&4&1&4\\
 1&3&4&2\end{bmatrix}\begin{bmatrix}f(0)\\
 f(1)\\
 f(2)\\
 f(3)\end{bmatrix}     The number theoretic transform may be meaningful in the ring     â„¤  /  m      â„¤  m    \mathbb{Z}/m   , even when the modulus   m   m   m   is not prime, provided a principal root of order n exists. Special cases of the number theoretic transform such as the Fermat Number Transform ( m = 2 k +1), used by the SchÃ¶nhageâ€“Strassen algorithm , or Mersenne Number Transform ( m = 2 k âˆ’Â 1) use a composite modulus.  Discrete weighted transform  The discrete weighted transform (DWT) is a variation on the discrete Fourier transform over arbitrary rings involving weighting the input before transforming it by multiplying elementwise by a weight vector, then weighting the result by another vector. 5 The Irrational base discrete weighted transform is a special case of this.  Properties  Most of the important attributes of the complex DFT , including the inverse transform, the convolution theorem , and most fast Fourier transform (FFT) algorithms, depend only on the property that the kernel of the transform is a principal root of unity. These properties also hold, with identical proofs, over arbitrary rings. In the case of fields, this analogy can be formalized by the field with one element , considering any field with a primitive n th root of unity as an algebra over the extension field     ð…   1  n    .     subscript  ð…   superscript  1  n     \mathbf{F}_{1^{n}}.     In particular, the applicability of    O   (   n   log  n    )       O    n    n      O(n\log n)    fast Fourier transform algorithms to compute the NTT, combined with the convolution theorem, mean that the number-theoretic transform gives an efficient way to compute exact convolutions of integer sequences. While the complex DFT can perform the same task, it is susceptible to round-off error in finite-precision floating point arithmetic; the NTT has no round-off because it deals purely with fixed-size integers that can be exactly represented.  Fast algorithms  For the implementation of a "fast" algorithm (similar to how FFT computes the DFT ), it is often desirable that the transform length is also highly composite, e.g., a power of two . However, there are specialized fast Fourier transform algorithms for finite fields, such as Wang and Zhu's algorithm, 6 that are efficient regardless of whether the transform length factors.  See also   Discrete Fourier transform (complex)  Gauss sum  Convolution  Multiplication algorithm   References    External links   http://www.apfloat.org/ntt.html   "  Category:Fourier analysis     Martin FÃ¼rer, " Faster integer multiplication ", STOC 2007 Proceedings, pp. 57â€“66. Section 2: The Discrete Fourier Transform. â†©    R. Lidl and G. Pilz. Applied Abstract Algebra, 2nd edition. Wiley, 1999, pp. 217-219. â†©  â†©  Yao Wang and Xuelong Zhu, "A fast algorithm for the Fourier transform over finite fields and its VLSI implementation", IEEE Journal on Selected Areas in Communications 6(3)572â€“577, 1988 â†©     