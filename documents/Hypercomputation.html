<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="707">Hypercomputation</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Hypercomputation</h1>
<hr>'''Hypercomputation''' or '''super-Turing computation''' refers to models of computation that go beyond, or are incomparable to, Turing computability. This includes various hypothetical methods for the [[computation]] of non-[[Computable function|Turing-computable function]]s, following [[super-recursive algorithm]]s (see also [[supertask]]). The term "super-Turing computation" first appeared in a 1990 talk<ref name="Sta90">Mike Stannett, ''[https://www.researchgate.net/publication/258
<p>848388_1990_Super-Turing_Computation Super-Turing Computation]''. Seminar presentation (scans of original slides), Department of Computer Science, University of Sheffield, 1990. and 1991 technical report<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> by <a href="http://www.dcs.shef.ac.uk/cgi-bin/makeperson?M.Stannett">Mike Stannett</a>, and a 1995 <em><a href="Science_(journal)" title="wikilink">Science</a></em> paper by <a href="Hava_Siegelmann" title="wikilink">Hava Siegelmann</a>. The term "hypercomputation" was introduced in 1999 by <a href="Jack_Copeland" title="wikilink">Jack Copeland</a> and <a href="Diane_Proudfoot" title="wikilink">Diane Proudfoot</a>.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>

<p>The terms are not quite synonymous: "super-Turing computation" usually implies that the proposed model is supposed to be physically realizable, while "hypercomputation" does not.</p>

<p>Technical arguments against the physical realizability of hypercomputations have been presented.</p>
<h2 id="history">History</h2>

<p>A computational model going beyond Turing machines was introduced by <a href="Alan_Turing" title="wikilink">Alan Turing</a> in his 1938 PhD dissertation <em><a href="Systems_of_Logic_Based_on_Ordinals" title="wikilink">Systems of Logic Based on Ordinals</a></em>.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> This paper investigated mathematical systems in which an <a href="Oracle_machine" title="wikilink">oracle</a> was available, which could compute a single arbitrary (non-recursive) function from <a href="Natural_number" title="wikilink">naturals</a> to naturals. He used this device to prove that even in those more powerful systems, <a href="Undecidable_problem" title="wikilink">undecidability</a> is still present. Turing's oracle machines are mathematical abstractions, and are not physically realizable.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>
<h2 id="hypercomputation-and-the-churchturing-thesis">Hypercomputation and the Church–Turing thesis</h2>

<p>The <a href="Church–Turing_thesis" title="wikilink">Church–Turing thesis</a> states that any function that is algorithmically computable can be computed by a Turing machine. Hypercomputers compute functions that a Turing machine cannot and which are, hence, not computable in the Church-Turing sense.</p>

<p>An example of a problem a Turing machine cannot solve is the <a href="halting_problem" title="wikilink">halting problem</a>. A Turing machine cannot decide if an arbitrary program halts or runs forever. Some proposed hypercomputers can simulate the program for an infinite number of steps and tell the user whether the program halted.</p>
<h2 id="hypercomputer-proposals">Hypercomputer proposals</h2>
<ul>
<li>A Turing machine that can <em>complete</em> infinitely many steps. Simply being able to run for an unbounded number of steps does not suffice. One mathematical model is the <a href="Zeno_machine" title="wikilink">Zeno machine</a> (inspired by <a href="Zeno's_paradox" title="wikilink">Zeno's paradox</a>). The Zeno machine performs its first computation step in (say) 1 minute, the second step in ½ minute, the third step in ¼ minute, etc. By summing <a href="1/2_+_1/4_+_1/8_+_1/16_+_·_·_·" title="wikilink">1+½+¼+...</a> (a <a href="geometric_series" title="wikilink">geometric series</a>) we see that the machine performs infinitely many steps in a total of 2 minutes. According to Shagrir, Zeno machines introduce physical paradoxes and its state is logically undefined outside of one-side open period of [0, 2), thus undefined exactly at 2 minutes after beginning of the computation.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></li>
<li>Turing's original oracle machines, defined by Turing in 1939.</li>
<li>In mid 1960s, <a href="E_Mark_Gold" title="wikilink">E Mark Gold</a> and <a href="Hilary_Putnam" title="wikilink">Hilary Putnam</a> independently proposed models of <a href="inductive_inference" title="wikilink">inductive inference</a> (the "limiting recursive functionals"<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> and "trial-and-error predicates",<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> respectively). These models enable some nonrecursive sets of numbers or languages (including all <a href="recursively_enumerable" title="wikilink">recursively enumerable</a> sets of languages) to be "learned in the limit"; whereas, by definition, only recursive sets of numbers or languages could be identified by a Turing machine. While the machine will stabilize to the correct answer on any learnable set in some finite time, it can only identify it as correct if it is recursive; otherwise, the correctness is established only by running the machine forever and noting that it never revises its answer. Putnam identified this new interpretation as the class of "empirical" predicates, stating: "if we always 'posit' that the most recently generated answer is correct, we will make a finite number of mistakes, but we will eventually get the correct answer. (Note, however, that even if we have gotten to the correct answer (the end of the finite sequence) we are never <em>sure</em> that we have the correct answer.)"<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> <a href="L._K._Schubert" title="wikilink">L. K. Schubert</a>'s 1974 paper "Iterated Limiting Recursion and the Program Minimization Problem" <a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> studied the effects of iterating the limiting procedure; this allows any <a href="arithmetic_hierarchy" title="wikilink">arithmetic</a> predicate to be computed. Schubert wrote, "Intuitively, iterated limiting identification might be regarded as higher-order inductive inference performed collectively by an ever-growing community of lower order inductive inference machines."</li>
<li>A <a href="real_computer" title="wikilink">real computer</a> (a sort of idealized <a href="analog_computer" title="wikilink">analog computer</a>) can perform hypercomputation<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> if physics admits general <a href="real_number" title="wikilink">real</a> variables (not just <a href="computable_number" title="wikilink">computable reals</a>), and these are in some way "harnessable" for computation. This might require quite bizarre laws of physics (for example, a measurable <a href="physical_constant" title="wikilink">physical constant</a> with an oracular value, such as <a href="Chaitin's_constant" title="wikilink">Chaitin's constant</a>), and would at minimum require the ability to measure a real-valued physical value to arbitrary precision despite <a href="thermal_noise" title="wikilink">thermal noise</a> and <a href="quantum_mechanics" title="wikilink">quantum</a> effects.</li>
<li>A proposed technique known as <a href="fair_nondeterminism" title="wikilink">fair nondeterminism</a> or <a href="unbounded_nondeterminism" title="wikilink">unbounded nondeterminism</a> may allow the computation of noncomputable functions.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> There is dispute in the literature over whether this technique is coherent, and whether it actually allows noncomputable functions to be "computed".</li>
<li>It seems natural that the possibility of time travel (existence of <a href="closed_timelike_curve" title="wikilink">closed timelike curves</a> (CTCs)) makes hypercomputation possible by itself. However, this is not so since a CTC does not provide (by itself) the unbounded amount of storage that an infinite computation would require. Nevertheless, there are spacetimes in which the CTC region can be used for relativistic hypercomputation.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> Access to a CTC may allow the rapid solution to <a class="uri" href="PSPACE-complete" title="wikilink">PSPACE-complete</a> problems, a complexity class which while Turing-decidable is generally considered computationally intractable.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a><a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a></li>
<li>According to a 1992 paper,<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a> a computer operating in a <a href="Malament-Hogarth_spacetime" title="wikilink">Malament-Hogarth spacetime</a> or in orbit around a rotating <a href="black_hole" title="wikilink">black hole</a><a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a> could theoretically perform non-Turing computations.<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a><a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a></li>
<li>In 1994, <a href="Hava_Siegelmann" title="wikilink">Hava Siegelmann</a> proved that her new (1991) computational model, the Artificial Recurrent Neural Network (ARNN), could perform hypercomputation (using infinite precision real weights for the synapses). It is based on evolving an artificial neural network through a discrete, infinite succession of states.<a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a></li>
<li>The <strong>infinite time Turing machine</strong> is a generalization of the Zeno machine, that can perform infinitely long computations whose steps are enumerated by potentially transfinite <a href="ordinal_number" title="wikilink">ordinal numbers</a>. It models an otherwise-ordinary Turing machine for which non-halting computations are completed by entering a special state reserved for reaching a <a href="limit_ordinal" title="wikilink">limit ordinal</a> and to which the results of the preceding infinite computation are available.<a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a></li>
<li><a href="Jan_van_Leeuwen" title="wikilink">Jan van Leeuwen</a> and Jiří Wiedermann wrote a paper<a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a> suggesting that the Internet should be modeled as a nonuniform computing system equipped with an <a href="advice_(complexity)" title="wikilink">advice</a> function representing the ability of computers to be upgraded.</li>
<li>A symbol sequence is <em>computable in the limit</em> if there is a finite, possibly non-halting program on a <a href="universal_Turing_machine" title="wikilink">universal Turing machine</a> that incrementally outputs every symbol of the sequence. This includes the dyadic expansion of π and of every other <a href="computable_real" title="wikilink">computable real</a>, but still excludes all noncomputable reals. Traditional Turing machines cannot edit their previous outputs; generalized Turing machines, as defined by <a href="Jürgen_Schmidhuber" title="wikilink">Jürgen Schmidhuber</a>, can. He defines the constructively describable symbol sequences as those that have a finite, non-halting program running on a generalized Turing machine, such that any output symbol eventually converges; that is, it does not change any more after some finite initial time interval. Due to limitations first exhibited by <a href="Kurt_Gödel" title="wikilink">Kurt Gödel</a> (1931), it may be impossible to predict the convergence time itself by a halting program, otherwise the <a href="halting_problem" title="wikilink">halting problem</a> could be solved. Schmidhuber (<a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a><a class="footnoteRef" href="#fn23" id="fnref23"><sup>23</sup></a>) uses this approach to define the set of formally describable or constructively computable universes or constructive <a href="theory_of_everything" title="wikilink">theories of everything</a>. Generalized Turing machines can solve the halting problem by evaluating a <a href="Specker_sequence" title="wikilink">Specker sequence</a>.</li>
<li>A <a href="Quantum_mechanics" title="wikilink">quantum mechanical</a> system which somehow uses an infinite superposition of states to compute a non-<a href="computable_function" title="wikilink">computable function</a>.<ref>There have been some claims to this effect; see  or  and the ensuing literature. For a retort see .</ref></li>
</ul>

<p> This is not possible using the standard <a class="uri" href="qubit" title="wikilink">qubit</a>-model <a href="quantum_computer" title="wikilink">quantum computer</a>, because it is proven that a regular quantum computer is <a href="PSPACE-reduction" title="wikilink">PSPACE-reducible</a> (a quantum computer running in <a href="polynomial_time" title="wikilink">polynomial time</a> can be simulated by a classical computer running in <a href="polynomial_space" title="wikilink">polynomial space</a>).<a class="footnoteRef" href="#fn24" id="fnref24"><sup>24</sup></a></p>
<ul>
<li>In 1970, E.S. Santos defined a class of <a href="fuzzy_logic" title="wikilink">fuzzy logic</a>-based "fuzzy algorithms" and "fuzzy Turing machines".<a class="footnoteRef" href="#fn25" id="fnref25"><sup>25</sup></a> Subsequently, L. Biacino and G. Gerla showed that such a definition would allow the computation of nonrecursive languages; they suggested an alternative set of definitions without this difficulty.<a class="footnoteRef" href="#fn26" id="fnref26"><sup>26</sup></a> Jiří Wiedermann analyzed the capabilities of Santos' original proposal in 2004.<a class="footnoteRef" href="#fn27" id="fnref27"><sup>27</sup></a></li>
<li>Dmytro Taranovsky has proposed a <a href="finitism" title="wikilink">finitistic</a> model of traditionally non-finitistic branches of analysis, built around a Turing machine equipped with a rapidly increasing function as its oracle. By this and more complicated models he was able to give an interpretation of second-order arithmetic.<a class="footnoteRef" href="#fn28" id="fnref28"><sup>28</sup></a></li>
</ul>
<h2 id="analysis-of-capabilities">Analysis of capabilities</h2>

<p>Many hypercomputation proposals amount to alternative ways to read an <a href="oracle_machine" title="wikilink">oracle</a> or <a href="advice_(complexity)" title="wikilink">advice function</a> embedded into an otherwise classical machine. Others allow access to some higher level of the <a href="arithmetic_hierarchy" title="wikilink">arithmetic hierarchy</a>. For example, supertasking Turing machines, under the usual assumptions, would be able to compute any predicate in the <a href="truth-table_reduction" title="wikilink">truth-table degree</a> containing 

<math display="inline" id="Hypercomputation:0">
 <semantics>
  <msubsup>
   <mi mathvariant="normal">Σ</mi>
   <mn>1</mn>
   <mn>0</mn>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-Σ</ci>
     <cn type="integer">0</cn>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma^{0}_{1}
  </annotation>
 </semantics>
</math>

 or 

<math display="inline" id="Hypercomputation:1">
 <semantics>
  <msubsup>
   <mi mathvariant="normal">Π</mi>
   <mn>1</mn>
   <mn>0</mn>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-Π</ci>
     <cn type="integer">0</cn>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Pi^{0}_{1}
  </annotation>
 </semantics>
</math>

. Limiting-recursion, by contrast, can compute any predicate or function in the corresponding <a href="Turing_degree" title="wikilink">Turing degree</a>, which is known to be 

<math display="inline" id="Hypercomputation:2">
 <semantics>
  <msubsup>
   <mi mathvariant="normal">Δ</mi>
   <mn>2</mn>
   <mn>0</mn>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-Δ</ci>
     <cn type="integer">0</cn>
    </apply>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta^{0}_{2}
  </annotation>
 </semantics>
</math>

. Gold further showed that limiting partial recursion would allow the computation of precisely the 

<math display="inline" id="Hypercomputation:3">
 <semantics>
  <msubsup>
   <mi mathvariant="normal">Σ</mi>
   <mn>2</mn>
   <mn>0</mn>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-Σ</ci>
     <cn type="integer">0</cn>
    </apply>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma^{0}_{2}
  </annotation>
 </semantics>
</math>

 predicates.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>Model</p></th>
<th style="text-align: left;">
<p>Computable predicates</p></th>
<th style="text-align: left;">
<p>Notes</p></th>
<th style="text-align: left;">
<p>Refs</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>supertasking</p></td>
<td style="text-align: left;">
<p>tt(

<math display="inline" id="Hypercomputation:4">
 <semantics>
  <mrow>
   <msubsup>
    <mi mathvariant="normal">Σ</mi>
    <mn>1</mn>
    <mn>0</mn>
   </msubsup>
   <mo>,</mo>
   <msubsup>
    <mi mathvariant="normal">Π</mi>
    <mn>1</mn>
    <mn>0</mn>
   </msubsup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>normal-Σ</ci>
      <cn type="integer">0</cn>
     </apply>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>normal-Π</ci>
      <cn type="integer">0</cn>
     </apply>
     <cn type="integer">1</cn>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma^{0}_{1},\Pi^{0}_{1}
  </annotation>
 </semantics>
</math>

)</p></td>
<td style="text-align: left;">
<p>dependent on outside observer</p></td>
<td style="text-align: left;">
<p><a class="footnoteRef" href="#fn29" id="fnref29"><sup>29</sup></a></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>limiting/trial-and-error</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Hypercomputation:5">
 <semantics>
  <msubsup>
   <mi mathvariant="normal">Δ</mi>
   <mn>2</mn>
   <mn>0</mn>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-Δ</ci>
     <cn type="integer">0</cn>
    </apply>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta^{0}_{2}
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p><a class="footnoteRef" href="#fn30" id="fnref30"><sup>30</sup></a></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>iterated limiting (<em>k</em> times)</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Hypercomputation:6">
 <semantics>
  <msubsup>
   <mi mathvariant="normal">Δ</mi>
   <mrow>
    <mi>k</mi>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
   <mn>0</mn>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-Δ</ci>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <plus></plus>
     <ci>k</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta^{0}_{k+1}
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p><a class="footnoteRef" href="#fn31" id="fnref31"><sup>31</sup></a></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><a href="Blum-Shub-Smale_machine" title="wikilink">Blum-Shub-Smale machine</a></p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>incomparable with traditional <a href="computable_real" title="wikilink">computable real</a> functions</p></td>
<td style="text-align: left;">
<p><a class="footnoteRef" href="#fn32" id="fnref32"><sup>32</sup></a></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><a href="Malament-Hogarth_spacetime" title="wikilink">Malament-Hogarth spacetime</a></p></td>
<td style="text-align: left;">
<p><strong><a href="Hyperarithmetic_hierarchy" title="wikilink">HYP</a></strong></p></td>
<td style="text-align: left;">
<p>dependent on spacetime structure</p></td>
<td style="text-align: left;">
<p><a class="footnoteRef" href="#fn33" id="fnref33"><sup>33</sup></a></p></td>
</tr>
<tr class="even">
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>analog recurrent neural network</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Hypercomputation:7">
 <semantics>
  <mrow>
   <msubsup>
    <mi mathvariant="normal">Δ</mi>
    <mn>1</mn>
    <mn>0</mn>
   </msubsup>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>f</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>normal-Δ</ci>
      <cn type="integer">0</cn>
     </apply>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>f</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta^{0}_{1}[f]
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p><em>f</em> is an advice function giving connection weights; size is bounded by runtime</p></td>
<td style="text-align: left;">
<p><a class="footnoteRef" href="#fn34" id="fnref34"><sup>34</sup></a><a class="footnoteRef" href="#fn35" id="fnref35"><sup>35</sup></a></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>infinite time Turing machine</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Hypercomputation:8">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>≥</mo>
   <mrow>
    <mi>T</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msubsup>
      <mi mathvariant="normal">Σ</mi>
      <mn>1</mn>
      <mn>1</mn>
     </msubsup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <csymbol cd="latexml">absent</csymbol>
    <apply>
     <times></times>
     <ci>T</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>normal-Σ</ci>
       <cn type="integer">1</cn>
      </apply>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \geq T(\Sigma^{1}_{1})
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p><a class="footnoteRef" href="#fn36" id="fnref36"><sup>36</sup></a></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>classical fuzzy Turing machine</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Hypercomputation:9">
 <semantics>
  <mrow>
   <msubsup>
    <mi mathvariant="normal">Σ</mi>
    <mn>1</mn>
    <mn>0</mn>
   </msubsup>
   <mo>∪</mo>
   <msubsup>
    <mi mathvariant="normal">Π</mi>
    <mn>1</mn>
    <mn>0</mn>
   </msubsup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <union></union>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>normal-Σ</ci>
      <cn type="integer">0</cn>
     </apply>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>normal-Π</ci>
      <cn type="integer">0</cn>
     </apply>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma^{0}_{1}\cup\Pi^{0}_{1}
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>for any computable <a href="T-norm_fuzzy_logics" title="wikilink">t-norm</a></p></td>
<td style="text-align: left;">
<p><a class="footnoteRef" href="#fn37" id="fnref37"><sup>37</sup></a></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>increasing function oracle</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Hypercomputation:10">
 <semantics>
  <msubsup>
   <mi mathvariant="normal">Δ</mi>
   <mn>1</mn>
   <mn>1</mn>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-Δ</ci>
     <cn type="integer">1</cn>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta^{1}_{1}
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>for the one-sequence model; 

<math display="inline" id="Hypercomputation:11">
 <semantics>
  <msubsup>
   <mi mathvariant="normal">Π</mi>
   <mn>1</mn>
   <mn>1</mn>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-Π</ci>
     <cn type="integer">1</cn>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Pi^{1}_{1}
  </annotation>
 </semantics>
</math>

 are r.e.</p></td>
<td style="text-align: left;">
<p><a class="footnoteRef" href="#fn38" id="fnref38"><sup>38</sup></a></p></td>
</tr>
</tbody>
</table>
<h2 id="taxonomy-of-super-recursive-computation-methodologies">Taxonomy of "super-recursive" computation methodologies</h2>

<p><a href="Mark_Burgin" title="wikilink">Mark Burgin</a> has collected a list of what he calls "super-recursive algorithms" (from Burgin 2005: 132):</p>
<ul>
<li><strong>limiting recursive functions</strong> and <strong>limiting partial recursive functions</strong> (E. M. Gold<a class="footnoteRef" href="#fn39" id="fnref39"><sup>39</sup></a>)</li>
<li><strong>trial and error predicates</strong> (<a href="Hilary_Putnam" title="wikilink">Hilary Putnam</a><a class="footnoteRef" href="#fn40" id="fnref40"><sup>40</sup></a>)</li>
<li><strong><a href="inductive_inference" title="wikilink">inductive inference</a> machines</strong> (<a href="Carl_Herbert_Smith" title="wikilink">Carl Herbert Smith</a>)</li>
<li><strong>inductive Turing machines</strong> (one of Burgin's own models)</li>
<li><strong>limit Turing machines</strong> (another of Burgin's models)</li>
<li><strong>trial-and-error machines</strong> (Ja. Hintikka and A. Mutanen<a class="footnoteRef" href="#fn41" id="fnref41"><sup>41</sup></a>)</li>
<li><strong>general Turing machines</strong> (J. Schmidhuber<a class="footnoteRef" href="#fn42" id="fnref42"><sup>42</sup></a>)</li>
<li><strong>Internet machines</strong> (<a href="Jan_van_Leeuwen" title="wikilink">van Leeuwen, J.</a> and Wiedermann, J.<a class="footnoteRef" href="#fn43" id="fnref43"><sup>43</sup></a>)</li>
<li><strong>evolutionary computers</strong>, which use DNA to produce the value of a function (Darko Roglic<a class="footnoteRef" href="#fn44" id="fnref44"><sup>44</sup></a>)</li>
<li><strong>fuzzy computation</strong> (Jiří Wiedermann<a class="footnoteRef" href="#fn45" id="fnref45"><sup>45</sup></a>)</li>
<li><strong>evolutionary Turing machines</strong> (Eugene Eberbach<a class="footnoteRef" href="#fn46" id="fnref46"><sup>46</sup></a>)</li>
</ul>

<p>In the same book, he presents also a list of "algorithmic schemes":</p>
<ul>
<li><strong>Turing machines with arbitrary <a href="Oracle_(computer_science)" title="wikilink">oracles</a></strong> (Alan Turing)</li>
<li><strong>transrecursive operators</strong> (Borodyanskii and Burgin<ref></ref></li>
</ul>

<p>)</p>
<ul>
<li><strong><a href="Real_computation" title="wikilink">machines that compute with real numbers</a></strong> (L. Blum, F. Cucker, M. Shub, and S. Smale)</li>
<li><strong>neural networks based on real numbers</strong> (Hava Siegelmann)</li>
</ul>
<h2 id="criticism">Criticism</h2>

<p><a href="Martin_Davis" title="wikilink">Martin Davis</a>, in his writings on hypercomputation<a class="footnoteRef" href="#fn47" id="fnref47"><sup>47</sup></a><a class="footnoteRef" href="#fn48" id="fnref48"><sup>48</sup></a> refers to this subject as "a myth" and offers counter-arguments to the physical realizability of hypercomputation. As for its theory, he argues against the claims that this is a new field founded in the 1990s. This point of view relies on the history of computability theory (degrees of unsolvability, computability over functions, real numbers and ordinals), as also mentioned above. In his argument he makes a remark that all of hypercomputation is trivial as : "'' if non computable inputs are permitted then non computable outputs are attainable.''"</p>

<p><a href="Andrew_Hodges" title="wikilink">Andrew Hodges</a> wrote a critical commentary<a class="footnoteRef" href="#fn49" id="fnref49"><sup>49</sup></a> on Copeland and Proudfoot's article.<a class="footnoteRef" href="#fn50" id="fnref50"><sup>50</sup></a></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a class="uri" href="Computation" title="wikilink">Computation</a></li>
<li><a href="Digital_physics" title="wikilink">Digital physics</a></li>
<li><a class="uri" href="Supertask" title="wikilink">Supertask</a></li>
</ul>
<h2 id="references">References</h2>
<h2 id="further-reading">Further reading</h2>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li><a href="Hava_Siegelmann" title="wikilink">Hava Siegelmann</a>. <em>Neural Networks and Analog Computation: Beyond the Turing Limit</em> 1998 Boston: Birkhäuser (Book).</li>
<li><a href="Mike_Stannett" title="wikilink">Mike Stannett</a>, <em><a href="http://research.cs.queensu.ca/home/akl/cisc879/papers/PAPERS_FROM_APPLIED_MATHEMATICS_AND_COMPUTATION/Special_Issue_on_Hypercomputation/stannett%5b1%5d.pdf">The case for hypercomputation</a></em>, Applied Mathematics and Computation, Volume 178, Issue 1, 1 July 2006, Pages 8–24, Special Issue on Hypercomputation</li>
</ul>
<ul>
<li>Keith Douglas. <em><a href="http://www.philosopher-animal.com/papers/take6c.PDF">Super-Turing Computation: a Case Study Analysis</a></em> (<a href="Portable_Document_Format" title="wikilink">PDF</a>), M.S. Thesis, Carnegie Mellon University, 2003.</li>
<li>L. Blum, F. Cucker, M. Shub, S. Smale, <em>Complexity and Real Computation</em>, Springer-Verlag 1997. General development of complexity theory for <a href="abstract_machine" title="wikilink">abstract machines</a> that compute on <a href="real_computation" title="wikilink">real numbers</a> instead of bits.</li>
</ul>
<ul>
<li><a href="ftp://ftp.cs.cuhk.hk/pub/neuro/papers/jcss1.ps.Z">On the computational power of neural nets</a></li>
<li>Toby Ord. <a href="http://arxiv.org/abs/math/0209332"><em>Hypercomputation: Computing more than the Turing machine can compute</em></a>: A survey article on various forms of hypercomputation.</li>
<li>Apostolos Syropoulos (2008), <em><a href="http://www.springer.com/computer/foundations/book/978-0-387-30886-9">Hypercomputation: Computing Beyond the Church-Turing Barrier</a></em> (<a href="http://books.google.com/books?id=5gVOf_OQa04C">preview</a>), Springer. ISBN 978-0-387-30886-9</li>
<li>Burgin, M. S. (1983) Inductive Turing Machines, <em>Notices of the Academy of Sciences of the USSR</em>, v. 270, No. 6, pp. 1289–1293</li>
<li>Mark Burgin (2005), <em>Super-recursive algorithms</em>, Monographs in computer science, Springer. ISBN 0-387-95569-0</li>
<li>Cockshott, P. and Michaelson, G. Are there new Models of Computation? Reply to Wegner and Eberbach, <em>The computer Journal</em>, 2007</li>
<li></li>
<li></li>
<li>Copeland, J. (2002) <em><a href="http://research.cs.queensu.ca/home/akl/cisc879/papers/PAPERS_FROM_MINDS_AND_MACHINES/VOLUME_12_NO_4/NV6361035557Q678.pdf">Hypercomputation</a></em>, Minds and machines, v. 12, pp. 461–502</li>
<li>Martin Davis (2006), "<a href="http://people.cs.uchicago.edu/~simon/TEACH/28000/DavisUniversal.pdf">The Church–Turing Thesis: Consensus and opposition</a>". Proceedings, Computability in Europe 2006. <em>The requested URL /~simon/TEACH/28000/DavisUniversal.pdf was not found on this server.</em> Lecture notes in computer science, 3988 pp. 125–132</li>
<li>Hagar, A. and Korolev, A., <em><a href="http://philsci-archive.pitt.edu/archive/00003180/">Quantum Hypercomputation—Hype or Computation?</a></em>, (2007)</li>
<li>Rogers, H. (1987) Theory of Recursive Functions and Effective Computability, MIT Press, Cambridge Massachusetts</li>
<li>Volkmar Putz and Karl Svozil, <em><a href="http://arxiv.org/abs/1003.1238">Can a computer be "pushed" to perform faster-than-light?</a></em>, (2010)</li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.hypercomputation.net/">Hypercomputation Research Network</a></li>
<li><a href="http://www.hypercomputation.blogspot.com/">Hypercomputation</a></li>
<li><a href="http://arxiv.org/abs/math/0209332">Toby Ord, <em>Hypercomputation: computing more than the Turing machine</em></a></li>
<li><a href="http://www.amirrorclear.net/academic/papers/many-forms.pdf">Toby Ord, <em>The many forms of hypercomputation</em></a></li>
<li><a href="http://citeseer.ist.psu.edu/cotogno03hypercomputation.html">Paolo Cotogno, <em>Hypercomputation and the Physical Church-Turing thesis</em></a></li>
<li><a href="Gualtiero_Piccinini" title="wikilink">Gualtiero Piccinini</a>, <a href="http://plato.stanford.edu/entries/computation-physicalsystems/"><em>Computation in Physical Systems</em></a></li>
</ul>

<p>"</p>

<p><a href="Category:Theory_of_computation" title="wikilink">Category:Theory of computation</a> <a href="Category:Hypercomputation" title="wikilink"> </a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Mike Stannett, <em><a href="https://www.researchgate.net/publication/236852111_An_Introduction_to_post-Newtonian_and_super-Turing_computation">An Introduction to post-Newtonian and super-Turing computation</a></em>. Technical Report CS-91-02, Department of Computer Science, University of Sheffield, 1991.<a href="#fnref1">↩</a></li>
<li id="fn2">Copeland and Proudfoot, <em><a href="http://www.sciamdigital.com/index.cfm?fa=Products.ViewIssuePreview&amp;ARTICLEID;_CHAR=94B166BF-E481-47FA-80C8-112C6BAF404">Alan Turing's forgotten ideas in computer science</a></em>. <a href="Scientific_American" title="wikilink">Scientific American</a>, April 1999<a href="#fnref2">↩</a></li>
<li id="fn3">Alan Turing, 1939, <em>Systems of Logic Based on Ordinals</em> Proceedings London Mathematical Society Volumes 2–45, Issue 1, pp. 161–228.<a href="http://plms.oxfordjournals.org/content/s2-45/1/161.extract">1</a><a href="#fnref3">↩</a></li>
<li id="fn4">"Let us suppose that we are supplied with some unspecified means of solving number-theoretic problems; a kind of oracle as it were. We shall not go any further into the nature of this oracle apart from saying that it cannot be a machine" (Undecidable p. 167, a reprint of Turing's paper <em>Systems of Logic Based On Ordinals</em>)<a href="#fnref4">↩</a></li>
<li id="fn5">These models have been independently developed by many different authors, including ; the model is discussed in  and in <a href="#fnref5">↩</a></li>
<li id="fn6">, <a href="#fnref6">↩</a></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
<li id="fn8"></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
<li id="fn10"><a href="Arnold_Schönhage" title="wikilink">Arnold Schönhage</a>, "On the power of random access machines", in <em>Proc. Intl. Colloquium on Automata, Languages, and Programming (ICALP)</em>, pages 520-529, 1979. Source of citation: <a href="Scott_Aaronson" title="wikilink">Scott Aaronson</a>, "NP-complete Problems and Physical Reality"<a href="http://www.scottaaronson.com/papers/npcomplete.pdf">2</a> p. 12<a href="#fnref10">↩</a></li>
<li id="fn11"><a href="#fnref11">↩</a></li>
<li id="fn12">Hajnal Andréka, István Németi and Gergely Székely, <em>Closed Timelike Curves in Relativistic Computation</em> Parallel Process. Lett. 22, 1240010 (2012).<a href="http://arxiv.org/abs/1105.0047">3</a><a href="#fnref12">↩</a></li>
<li id="fn13">Todd A. Brun, <em>Computers with closed timelike curves can solve hard problems</em>, Found.Phys.Lett. 16 (2003) 245-253.<a href="http://arxiv.org/abs/gr-qc/0209061">4</a><a href="#fnref13">↩</a></li>
<li id="fn14"><a href="Scott_Aaronson" title="wikilink">S. Aaronson</a> and J. Watrous. Closed Timelike Curves Make Quantum and Classical Computing Equivalent <a href="http://scottaaronson.com/papers/ctc.pdf">5</a><a href="#fnref14">↩</a></li>
<li id="fn15">Hogarth, M., 1992, 'Does General Relativity Allow an Observer to View an Eternity in a Finite Time?', Foundations of Physics Letters, 5, 173–181.<a href="#fnref15">↩</a></li>
<li id="fn16"><a href="#fnref16">↩</a></li>
<li id="fn17">Etesi, G., and Nemeti, I., 2002 'Non-Turing computations via Malament-Hogarth space-times', Int.J.Theor.Phys. 41 (2002) 341–370, <a href="http://lanl.arxiv.org/abs/gr-qc/0104023">Non-Turing Computations via Malament-Hogarth Space-Times:</a>.<a href="#fnref17">↩</a></li>
<li id="fn18">Earman, J. and Norton, J., 1993, 'Forever is a Day: Supertasks in Pitowsky and Malament-Hogarth Spacetimes', Philosophy of Science, 5, 22–42.<a href="#fnref18">↩</a></li>
<li id="fn19"><a href="http://www.cs.math.ist.utl.pt/ftp/pub/CostaJF/01-RCS-iwann.pdf">Verifying Properties of Neural Networks</a> p.6<a href="#fnref19">↩</a></li>
<li id="fn20"><a href="Joel_David_Hamkins" title="wikilink">Joel David Hamkins</a> and <a href="Andy_Lewis_(mathematician)" title="wikilink">Andy Lewis</a>, Infinite time Turing machines, <em>Journal of Symbolic Logic</em>, 65(2):567-604, 2000.<a href="http://jdh.hamkins.org/Publications/2000e">6</a><a href="#fnref20">↩</a></li>
<li id="fn21"><a href="#fnref21">↩</a></li>
<li id="fn22"><a href="#fnref22">↩</a></li>
<li id="fn23"></li>
<li id="fn24">Bernstein and Vazirani, Quantum complexity theory, <a href="SIAM_Journal_on_Computing" title="wikilink">SIAM Journal on Computing</a>, 26(5):1411-1473, 1997. <a href="http://www.cs.berkeley.edu/~vazirani/bv.ps">7</a><a href="#fnref24">↩</a></li>
<li id="fn25"><a href="#fnref25">↩</a></li>
<li id="fn26"><a href="#fnref26">↩</a></li>
<li id="fn27"><a href="#fnref27">↩</a></li>
<li id="fn28"><a href="#fnref28">↩</a></li>
<li id="fn29"><a href="#fnref29">↩</a></li>
<li id="fn30"></li>
<li id="fn31"></li>
<li id="fn32"><a href="#fnref32">↩</a></li>
<li id="fn33"><a href="#fnref33">↩</a></li>
<li id="fn34"><a href="#fnref34">↩</a></li>
<li id="fn35"><a href="#fnref35">↩</a></li>
<li id="fn36"><a href="#fnref36">↩</a></li>
<li id="fn37"><a href="#fnref37">↩</a></li>
<li id="fn38"></li>
<li id="fn39"></li>
<li id="fn40"></li>
<li id="fn41"><a href="#fnref41">↩</a></li>
<li id="fn42"><a href="#fnref42">↩</a></li>
<li id="fn43"></li>
<li id="fn44"><a href="#fnref44">↩</a></li>
<li id="fn45"></li>
<li id="fn46"><a href="#fnref46">↩</a></li>
<li id="fn47"><a href="#fnref47">↩</a></li>
<li id="fn48"><a href="#fnref48">↩</a></li>
<li id="fn49"><a href="#fnref49">↩</a></li>
<li id="fn50"></li>
</ol>
</section>
</ref></hr></body>
</html>
