<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="246">FOSD Program Cubes</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>FOSD Program Cubes</h1>
<hr/>

<p>A program in <a href="Feature_Oriented_Programming" title="wikilink"><strong><em>Feature Oriented Software Development (FOSD)</em></strong></a> is a composition of functions (program transformations): a base program (modeled by a nullary function) is composed with increments in program functionality, called <strong><em>features</em></strong> (which are unary functions), to produce a complex program. A <strong><em>software product line (SPL)</em></strong> is a family of related programs. Suppose product line PL has F<sub>0</sub> as a base program, and F<sub>1</sub>..F<sub>n</sub> as features that could be added to F<sub>0</sub>. Different compositions of these functions/transformations yield different programs. For this discussion, let + denote function composition. A program P in PL might have the following expression:</p>

<p><code>¬†¬†</code>

<math display="inline" id="FOSD_Program_Cubes:0">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>F</mi>
     <mn>8</mn>
    </msub>
    <mo>+</mo>
    <msub>
     <mi>F</mi>
     <mn>4</mn>
    </msub>
    <mo>+</mo>
    <msub>
     <mi>F</mi>
     <mn>2</mn>
    </msub>
    <mo>+</mo>
    <msub>
     <mi>F</mi>
     <mn>1</mn>
    </msub>
    <mo>+</mo>
    <msub>
     <mi>F</mi>
     <mn>0</mn>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>P</ci>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>F</ci>
      <cn type="integer">8</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>F</ci>
      <cn type="integer">4</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>F</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>F</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>F</ci>
      <cn type="integer">0</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P=F_{8}+F_{4}+F_{2}+F_{1}+F_{0}
  </annotation>
 </semantics>
</math>

</p>

<p>That is, P extends program F<sub>0</sub> with features F<sub>1</sub>, F<sub>2</sub>, F<sub>4</sub>, and F<sub>8</sub> in this order.</p>

<p>We can recast P in terms of a projection and contraction of a 1-dimensional array. Let <strong>F</strong><sub>i</sub> = [F<sub>0</sub> .. F<sub>n</sub>] denote the array of transformations that define PL. A projection of <strong>F</strong><sub>i</sub> eliminates unneeded transformations, yielding a shorter array (call it) <strong>G</strong><sub>i</sub>. A contraction of <strong>G</strong><sub>i</sub> composes each transformation of <strong>G</strong><sub>i</sub> in a specific order, to yield a scalar expression. The expression for P becomes:</p>

<p><code>¬†¬†¬†¬†</code>

<math display="inline" id="FOSD_Program_Cubes:1">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mo>=</mo>
   <mrow>
    <msub>
     <mo largeop="true" symmetric="true">‚àë</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mn>0</mn>
       <mo>,</mo>
       <mn>1</mn>
       <mo>,</mo>
       <mn>2</mn>
       <mo>,</mo>
       <mn>4</mn>
       <mo>,</mo>
       <mn>8</mn>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </msub>
    <msub>
     <mi>ùêÖ</mi>
     <mi>i</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>P</ci>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <eq></eq>
       <ci>i</ci>
       <vector>
        <cn type="integer">0</cn>
        <cn type="integer">1</cn>
        <cn type="integer">2</cn>
        <cn type="integer">4</cn>
        <cn type="integer">8</cn>
       </vector>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ùêÖ</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P=\sum_{i=(0,1,2,4,8)}\mathbf{F}_{i}
  </annotation>
 </semantics>
</math>

</p>

<p>where the index values accomplish projection and summation is array contraction. This idea generalizes to n-dimensional arrays that model multi-dimensional product lines.</p>
<h2 id="multi-dimensional-product-lines">Multi-Dimensional Product Lines</h2>
<figure><b>(Figure)</b>
<figcaption>A 2-D Product Line (or Kube)</figcaption>
</figure>

<p>A <strong><em>multi-dimensional product line</em></strong> is described by multiple interacting sets of features. <a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> <a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> <a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> <a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> As an elementary 2D example, it is easy to create a product line of calculators, where variants offer different sets of operations. Another variation might offer different presentation front ends to calculators, one with no GUI, another with a Java GUI, a third with a web GUI. These variations interact: each GUI representation references a specific calculator operation, so each GUI feature cannot be designed independently of its calculator feature. Such a design leads to a matrix: columns represent increments in calculator functionality, and rows represent different presentation front-ends. Such a matrix M is shown to the right: columns allow one to pair basic calculator functionality (base) with optional logarithmic/exponentiation (lx) and trigonometric (tg) features. Rows allow one to pair core functionality with no front-end (core), with optional GUI (gui) and web-based (web) front-ends.</p>

<p>An element M<sub>ij</sub> implements the interaction of column feature i and row feature j. For example, the element labeled cb is a base program that implements the core functionality of a calculator. Element gb adds code that displays the core functionality as a GUI; element wb adds code that displays the core functionality via the web. Similarly, element ct adds trigonometric code to the core calculator functionality; elements gt and wt add code to display the trigonometric functionality as a GUI and web front-ends.</p>

<p>A calculator is uniquely specified by two sequences of features: one sequence defining the calculator functionality, the other the front-end. For example, calculator C that offers both base and trig functionality in a web format is defined by the expression:</p>

<p><code>¬†¬†</code>

<math display="inline" id="FOSD_Program_Cubes:2">
 <semantics>
  <mrow>
   <mi>C</mi>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>M</mi>
     <mrow>
      <mi>c</mi>
      <mi>b</mi>
     </mrow>
    </msub>
    <mo>+</mo>
    <msub>
     <mi>M</mi>
     <mrow>
      <mi>c</mi>
      <mi>t</mi>
     </mrow>
    </msub>
    <mo>+</mo>
    <msub>
     <mi>M</mi>
     <mrow>
      <mi>w</mi>
      <mi>b</mi>
     </mrow>
    </msub>
    <mo>+</mo>
    <msub>
     <mi>M</mi>
     <mrow>
      <mi>w</mi>
      <mi>t</mi>
     </mrow>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>C</ci>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>M</ci>
      <apply>
       <times></times>
       <ci>c</ci>
       <ci>b</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>M</ci>
      <apply>
       <times></times>
       <ci>c</ci>
       <ci>t</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>M</ci>
      <apply>
       <times></times>
       <ci>w</ci>
       <ci>b</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>M</ci>
      <apply>
       <times></times>
       <ci>w</ci>
       <ci>t</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C=M_{cb}+M_{ct}+M_{wb}+M_{wt}
  </annotation>
 </semantics>
</math>

</p>
<dl>
<dd>Note: Each dimension is a collection of base programs and features. Not all of their compositions are meaningful. A <a href="Feature_Model" title="wikilink">feature model</a> defines the legal combinations of features. Thus, each dimension would have its own <a href="Feature_Model" title="wikilink">feature model</a>. It is possible that selected features along one dimension may preclude or require features along other dimensions. In any case, these feature models define the legal combinations of features in a multi-dimensional product line.
</dd>
</dl>
<h2 id="kubes">Kubes</h2>

<p>In general, a <strong><em>kube</em></strong> is an n-dimensional array. The rank of a kube is its dimensionality. A scalar is a kube of rank 0, a vector is a kube of rank 1, and a matrix is rank 2. Following tensor notation: the number of indices a kube has designates its rank. A scalar S is rank 0 (it has no indices), V<sub>k</sub> is a vector (rank 1), M<sub>ij</sub> is a matrix (rank 2), C<sub>ijk</sub> is a cube (rank 3).</p>

<p><strong><em>Program Cubes</em></strong> or <strong><em>program kubes</em></strong> are n-dimensional arrays of functions (program transformations) that represent n-dimensional product lines. The values along each axis of a kube denote either a base program or a feature that could elaborate a base program. The rank of a product line is the rank of its kube.</p>
<dl>
<dd>Note: program kubes are inspired by <a href="tensor" title="wikilink">tensors</a> and <a href="OLAP_cube" title="wikilink">data cubes</a> in databases. The primary difference is that data cube elements are numerical values that are added during kube contraction; program kube elements are transformations that are composed. Both use <a class="uri" href="tensor" title="wikilink">tensor</a> notations and terminology, although kubes satisfy few algebraic properties of tensors.
</dd>
</dl>

<p>A program in an n-dimensional SPL is uniquely specified by n sequences of features S<sub>1</sub>..S<sub>n</sub>, one per dimension. The <strong><em>design</em></strong> of a program is a scalar (expression) that is formed by (1) projecting the kube of its unneeded elements, and (2) contracting the resultant kube to a scalar:</p>

<p><code>¬†¬†</code>

<math display="inline" id="FOSD_Program_Cubes:3">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mo>=</mo>
   <mrow>
    <msub>
     <mo largeop="true" symmetric="true">‚àë</mo>
     <mrow>
      <msub>
       <mi>i</mi>
       <mn>1</mn>
      </msub>
      <mo>=</mo>
      <msub>
       <mi>S</mi>
       <mn>1</mn>
      </msub>
      <mo>,</mo>
      <msub>
       <mi>i</mi>
       <mn>2</mn>
      </msub>
      <mo>=</mo>
      <msub>
       <mi>S</mi>
       <mn>2</mn>
      </msub>
      <mo>,</mo>
      <mo>.</mo>
      <mo>.</mo>
      <msub>
       <mi>i</mi>
       <mi>n</mi>
      </msub>
      <mo>=</mo>
      <msub>
       <mi>S</mi>
       <mi>n</mi>
      </msub>
     </mrow>
    </msub>
    <msub>
     <mi>K</mi>
     <mrow>
      <msub>
       <mi>i</mi>
       <mn>1</mn>
      </msub>
      <msub>
       <mi>i</mi>
       <mn>2</mn>
      </msub>
      <mo>.</mo>
      <mo>.</mo>
      <msub>
       <mi>i</mi>
       <mi>n</mi>
      </msub>
     </mrow>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>P</ci>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
       <eq></eq>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>S</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>normal-,</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>i</ci>
        <cn type="integer">2</cn>
       </apply>
       <eq></eq>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>S</ci>
        <cn type="integer">2</cn>
       </apply>
       <ci>normal-,</ci>
       <ci>normal-.</ci>
       <ci>normal-.</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>i</ci>
        <ci>n</ci>
       </apply>
       <eq></eq>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>S</ci>
        <ci>n</ci>
       </apply>
      </cerror>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>K</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>i</ci>
        <cn type="integer">2</cn>
       </apply>
       <ci>normal-.</ci>
       <ci>normal-.</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>i</ci>
        <ci>n</ci>
       </apply>
      </cerror>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P=\sum_{i_{1}=S_{1},i_{2}=S_{2},..i_{n}=S_{n}}K_{i_{1}i_{2}..i_{n}}
  </annotation>
 </semantics>
</math>


</p>

<p>Program <strong><em>synthesis</em></strong> is evaluating the scalar expression to produce program P.</p>

<p>An interesting property of kube design is that the order in which dimensions are contracted does not matter‚Äîany permutation of dimensions during contraction will result in a different scalar expression (i.e. a different program design), but all expressions produce the same value (program). For example, another expression (design) to produce calculator C contracts dimensions in the opposite order from its original specification:</p>

<p>

<math display="inline" id="FOSD_Program_Cubes:4">
 <semantics>
  <mrow>
   <mi>C</mi>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>M</mi>
     <mrow>
      <mi>c</mi>
      <mi>b</mi>
     </mrow>
    </msub>
    <mo>+</mo>
    <msub>
     <mi>M</mi>
     <mrow>
      <mi>w</mi>
      <mi>b</mi>
     </mrow>
    </msub>
    <mo>+</mo>
    <msub>
     <mi>M</mi>
     <mrow>
      <mi>c</mi>
      <mi>t</mi>
     </mrow>
    </msub>
    <mo>+</mo>
    <msub>
     <mi>M</mi>
     <mrow>
      <mi>w</mi>
      <mi>t</mi>
     </mrow>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>C</ci>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>M</ci>
      <apply>
       <times></times>
       <ci>c</ci>
       <ci>b</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>M</ci>
      <apply>
       <times></times>
       <ci>w</ci>
       <ci>b</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>M</ci>
      <apply>
       <times></times>
       <ci>c</ci>
       <ci>t</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>M</ci>
      <apply>
       <times></times>
       <ci>w</ci>
       <ci>t</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C=M_{cb}+M_{wb}+M_{ct}+M_{wt}
  </annotation>
 </semantics>
</math>

</p>

<p>Or more generally:</p>

<p><code>¬†¬†</code>

<math display="inline" id="FOSD_Program_Cubes:5">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mo>=</mo>
   <mrow>
    <msub>
     <mo largeop="true" symmetric="true">‚àë</mo>
     <mrow>
      <msub>
       <mi>i</mi>
       <mi>n</mi>
      </msub>
      <mo>=</mo>
      <msub>
       <mi>S</mi>
       <mi>n</mi>
      </msub>
      <mo>,</mo>
      <mo>.</mo>
      <mo>.</mo>
      <msub>
       <mi>i</mi>
       <mn>2</mn>
      </msub>
      <mo>=</mo>
      <msub>
       <mi>S</mi>
       <mn>2</mn>
      </msub>
      <mo>,</mo>
      <msub>
       <mi>i</mi>
       <mn>1</mn>
      </msub>
      <mo>=</mo>
      <msub>
       <mi>S</mi>
       <mn>1</mn>
      </msub>
     </mrow>
    </msub>
    <msub>
     <mi>K</mi>
     <mrow>
      <msub>
       <mi>i</mi>
       <mn>1</mn>
      </msub>
      <msub>
       <mi>i</mi>
       <mn>2</mn>
      </msub>
      <mo>.</mo>
      <mo>.</mo>
      <msub>
       <mi>i</mi>
       <mi>n</mi>
      </msub>
     </mrow>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>P</ci>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>i</ci>
        <ci>n</ci>
       </apply>
       <eq></eq>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>S</ci>
        <ci>n</ci>
       </apply>
       <ci>normal-,</ci>
       <ci>normal-.</ci>
       <ci>normal-.</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>i</ci>
        <cn type="integer">2</cn>
       </apply>
       <eq></eq>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>S</ci>
        <cn type="integer">2</cn>
       </apply>
       <ci>normal-,</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
       <eq></eq>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>S</ci>
        <cn type="integer">1</cn>
       </apply>
      </cerror>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>K</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>i</ci>
        <cn type="integer">2</cn>
       </apply>
       <ci>normal-.</ci>
       <ci>normal-.</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>i</ci>
        <ci>n</ci>
       </apply>
      </cerror>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P=\sum_{i_{n}=S_{n},..i_{2}=S_{2},i_{1}=S_{1}}K_{i_{1}i_{2}..i_{n}}
  </annotation>
 </semantics>
</math>

</p>
<dl>
<dd>Note: Underlying kube designs is a <a href="Commutative_diagram" title="wikilink">commuting diagram</a>, such that there are an exponential number of paths from the empty program 0 to program P. Each path denotes a particular contraction of a kube, and corresponds to a unique incremental design of P. Included among these paths are kube aggregations that contract kubes using different dimensional orders.
</dd>
</dl>

<p>The significance of program kubes is that it provides a structured way in which to express and build multi-dimensional models of SPLs. Further, it provides scalable specifications. If each dimension has k values, an n-kube specification of a program requires O(kn) terms, as opposed to O(k<sup>n</sup>) kube elements that would otherwise have to be identified and then composed. In general, kubes provide a compact way to specify complex programs.</p>
<h2 id="applications">Applications</h2>

<p>The <strong><em>expression problem<strong>'' (</strong></em>EP</strong>''; a.k.a. the <strong><em>extensibility problem</em></strong>) is a fundamental problem in programming languages aimed at type systems that can add new classes and methods to a program in a type-safe manner.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a><a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a><a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a><a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> It is also a fundamental problem in multi-dimensional SPL design. The expression problem is an example of an SPL of rank 2. The following applications either explain/illustrate the expression problem or show how it scales to product lines of large programs. EP is really a SPL of ~30 line programs; the applications below show how these ideas scale to programs of &gt;30K lines (a 10<sup>3</sup> increase in size).</p>
<ul>
<li><a href="ftp://ftp.cs.utexas.edu/pub/predator/ECOOP2005.pdf">Expression Problem</a></li>
<li><a href="http://www.cs.utexas.edu/users/schwartz/ATS/EPL/index.html">Illustration of Small Expression Problem</a></li>
<li><a href="ftp://ftp.cs.utexas.edu/pub/predator/Origami.pdf">Extensible IDEs</a></li>
<li><a href="ftp://ftp.cs.utexas.edu/pub/predator/OrigamiMDSC.pdf">Multi-Dimensional Separation of Concerns</a></li>
<li><a href="ftp://ftp.cs.utexas.edu/pub/predator/TSE-AHEAD.pdf">Calculator Product Line</a></li>
</ul>

<p>Also, <a href="FOSD_metamodels" title="wikilink">FOSD metamodels</a> can be viewed as special cases of program kubes.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Feature_Oriented_Programming" title="wikilink">Feature Oriented Programming</a>‚Äîbasic overview</li>
<li><a href="FOSD_metamodels" title="wikilink">FOSD Metamodels</a>‚Äîproduct lines of product lines</li>
<li><a href="FOSD_Feature_Algebras" title="wikilink">FOSD Feature Algebras</a>‚Äîoperations from which FOSD features (0-ary and 1-ary) functions are defined</li>
<li><a href="FOSD_Feature_Interactions" title="wikilink">FOSD Feature Interactions</a>‚Äîgeneral concepts for feature interactions</li>
</ul>
<h2 id="references">References</h2>
<references>
</references>

<p>"</p>

<p><a href="Category:Feature-oriented_programming" title="wikilink">Category:Feature-oriented programming</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">‚Ü©</a></li>
<li id="fn2"><a href="#fnref2">‚Ü©</a></li>
<li id="fn3"><a href="#fnref3">‚Ü©</a></li>
<li id="fn4"><a href="#fnref4">‚Ü©</a></li>
<li id="fn5"><a href="#fnref5">‚Ü©</a></li>
<li id="fn6"><a href="#fnref6">‚Ü©</a></li>
<li id="fn7"><a href="#fnref7">‚Ü©</a></li>
<li id="fn8"><a href="#fnref8">‚Ü©</a></li>
</ol>
</section>
</body>
</html>
