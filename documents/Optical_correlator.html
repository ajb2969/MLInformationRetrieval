<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="589">Optical correlator</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Optical correlator</h1>
<hr/>

<p>An <strong>optical correlator</strong> is a device for comparing two signals by utilising the <a href="Fourier_Transform" title="wikilink">Fourier transforming</a> properties of a <a href="lens_(optics)" title="wikilink">lens</a>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> It is commonly used in <a class="uri" href="optics" title="wikilink">optics</a> for target tracking and identification.</p>
<h2 id="introduction">Introduction</h2>

<p>The correlator has an input signal which is multiplied by some filter in the Fourier domain. An example filter is the <a href="matched_filter" title="wikilink">matched filter</a> which uses the <a href="cross_correlation" title="wikilink">cross correlation</a> of the two signals.</p>

<p>The cross correlation or correlation plane, 

<math display="inline" id="Optical_correlator:0">
 <semantics>
  <mrow>
   <mi>c</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>c</ci>
    <interval closure="open">
     <ci>x</ci>
     <ci>y</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c(x,y)
  </annotation>
 </semantics>
</math>

 of a 2D signal 

<math display="inline" id="Optical_correlator:1">
 <semantics>
  <mrow>
   <mi>i</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>i</ci>
    <interval closure="open">
     <ci>x</ci>
     <ci>y</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i(x,y)
  </annotation>
 </semantics>
</math>

 with 

<math display="inline" id="Optical_correlator:2">
 <semantics>
  <mrow>
   <mi>h</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>h</ci>
    <interval closure="open">
     <ci>x</ci>
     <ci>y</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h(x,y)
  </annotation>
 </semantics>
</math>

 is</p>

<p>

<math display="inline" id="Optical_correlator:3">
 <semantics>
  <mrow>
   <mrow>
    <mi>c</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <mi>i</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo>,</mo>
       <mi>y</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>⊗</mo>
     <msup>
      <mi>h</mi>
      <mo>*</mo>
     </msup>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo>-</mo>
      <mi>x</mi>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mo>-</mo>
      <mi>y</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>c</ci>
     <interval closure="open">
      <ci>x</ci>
      <ci>y</ci>
     </interval>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <apply>
       <times></times>
       <ci>i</ci>
       <interval closure="open">
        <ci>x</ci>
        <ci>y</ci>
       </interval>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>h</ci>
       <times></times>
      </apply>
     </apply>
     <interval closure="open">
      <apply>
       <minus></minus>
       <ci>x</ci>
      </apply>
      <apply>
       <minus></minus>
       <ci>y</ci>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c(x,y)=i(x,y)\otimes h^{*}(-x,-y)
  </annotation>
 </semantics>
</math>


</p>

<p>This can be re-expressed in Fourier space as</p>

<p>

<math display="inline" id="Optical_correlator:4">
 <semantics>
  <mrow>
   <mrow>
    <mi>C</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>ξ</mi>
     <mo>,</mo>
     <mi>η</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>I</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>ξ</mi>
     <mo>,</mo>
     <mi>η</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <msup>
     <mi>H</mi>
     <mo>*</mo>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo>-</mo>
      <mi>ξ</mi>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mo>-</mo>
      <mi>η</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>C</ci>
     <interval closure="open">
      <ci>ξ</ci>
      <ci>η</ci>
     </interval>
    </apply>
    <apply>
     <times></times>
     <ci>I</ci>
     <interval closure="open">
      <ci>ξ</ci>
      <ci>η</ci>
     </interval>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>H</ci>
      <times></times>
     </apply>
     <interval closure="open">
      <apply>
       <minus></minus>
       <ci>ξ</ci>
      </apply>
      <apply>
       <minus></minus>
       <ci>η</ci>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C(\xi,\eta)=I(\xi,\eta)H^{*}(-\xi,-\eta)
  </annotation>
 </semantics>
</math>

</p>

<p>where the capital letters denote the Fourier transform of what the lower case letter denotes. So the correlation can then be calculated by inverse Fourier transforming the result.</p>
<h2 id="implementation">Implementation</h2>

<p>According to <a href="Fresnel_Diffraction" title="wikilink">Fresnel Diffraction</a> theory a <a href="convex_lens" title="wikilink">convex lens</a> of <a href="focal_length" title="wikilink">focal length</a> 

<math display="inline" id="Optical_correlator:5">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 will produce the exact Fourier transform at a distance 

<math display="inline" id="Optical_correlator:6">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 behind the lens of an object placed 

<math display="inline" id="Optical_correlator:7">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 distance in front of the lens. So that <a href="complex_amplitudes" title="wikilink">complex amplitudes</a> are multiplied, the light source must be <a href="Coherence_(physics)" title="wikilink">coherent</a> and is typically from a <a class="uri" href="laser" title="wikilink">laser</a>. The input signal and filter are commonly written onto a <a href="spatial_light_modulator" title="wikilink">spatial light modulator</a> (SLM).</p>

<p>A typical arrangement is the <a href="Fourier_optics#4F_Correlator" title="wikilink">4f correlator</a>. The input signal is written to an SLM which is illuminated with a laser. This is Fourier transformed with a lens and this is then modulated with a second SLM containing the filter. The resultant is again Fourier transformed with a second lens and the correlation result is captured on a camera.</p>
<h2 id="filter-design">Filter design</h2>

<p>Many filters have been designed to be used with an optical correlator. Some have been proposed to address hardware limitations, others were developed to optimize a merit function or to be invariant under a certain transformation.</p>
<h3 id="matched-filter">Matched filter</h3>

<p>The matched filter maximizes the signal-to-noise ratio and is simply obtained by using as a filter the Fourier transform of the reference signal 

<math display="inline" id="Optical_correlator:8">
 <semantics>
  <mrow>
   <mi>r</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>r</ci>
    <interval closure="open">
     <ci>x</ci>
     <ci>y</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r(x,y)
  </annotation>
 </semantics>
</math>


.</p>

<p>

<math display="inline" id="Optical_correlator:9">
 <semantics>
  <mrow>
   <mrow>
    <mi>H</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>ξ</mi>
     <mo>,</mo>
     <mi>η</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>R</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>ξ</mi>
     <mo>,</mo>
     <mi>η</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>H</ci>
     <interval closure="open">
      <ci>ξ</ci>
      <ci>η</ci>
     </interval>
    </apply>
    <apply>
     <times></times>
     <ci>R</ci>
     <interval closure="open">
      <ci>ξ</ci>
      <ci>η</ci>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H(\xi,\eta)=R(\xi,\eta)
  </annotation>
 </semantics>
</math>

</p>
<h3 id="phase-only-filter">Phase-only filter</h3>

<p>The phase-only filter<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> is easier to implement due to limitation of many SLMs and has been shown to be more discriminant than the matched filter.</p>

<p>

<math display="inline" id="Optical_correlator:10">
 <semantics>
  <mrow>
   <mrow>
    <mi>H</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>ξ</mi>
     <mo>,</mo>
     <mi>η</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mi>R</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>ξ</mi>
      <mo>,</mo>
      <mi>η</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mrow>
     <mo>|</mo>
     <mrow>
      <mi>R</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>ξ</mi>
       <mo>,</mo>
       <mi>η</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>|</mo>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>H</ci>
     <interval closure="open">
      <ci>ξ</ci>
      <ci>η</ci>
     </interval>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <ci>R</ci>
      <interval closure="open">
       <ci>ξ</ci>
       <ci>η</ci>
      </interval>
     </apply>
     <apply>
      <abs></abs>
      <apply>
       <times></times>
       <ci>R</ci>
       <interval closure="open">
        <ci>ξ</ci>
        <ci>η</ci>
       </interval>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H(\xi,\eta)=\frac{R(\xi,\eta)}{\left|R(\xi,\eta)\right|}
  </annotation>
 </semantics>
</math>

</p>
<h2 id="references">References</h2>

<p>"</p>

<p><a class="uri" href="Category:Optics" title="wikilink">Category:Optics</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">A. VanderLugt, <em><a href="http://deepblue.lib.umich.edu/bitstream/2027.42/8080/5/bad4575.0001.001.pdf">Signal detection by complex spatial filtering</a>,</em> IEEE Transactions on Information Theory, vol. 10, 1964, pp. 139-145.<a href="#fnref1">↩</a></li>
<li id="fn2">J. L. Horner and P. D. Gianino, <em>Phase-only matched filtering</em>, Appl. Opt. 23, 1984, 812-816<a href="#fnref2">↩</a></li>
</ol>
</section>
</body>
</html>
