<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1882">Markov chain</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Markov chain</h1>
<hr/>

<p> A <strong>Markov chain</strong> (<strong>discrete-time Markov chain</strong> or <strong>DTMC</strong><a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a>), named after <a href="Andrey_Markov" title="wikilink">Andrey Markov</a>, is a <a href="stochastic_process" title="wikilink">random process</a> that undergoes transitions from one state to another on a <a href="state_space" title="wikilink">state space</a>. It must possess a property that is usually characterized as <a href="Memorylessness" title="wikilink">"memoryless"</a>: the probability distribution of the next state depends only on the current state and not on the sequence of events that preceded it. This specific kind of "memorylessness" is called the <a href="Markov_property" title="wikilink">Markov property</a>. Markov chains have many applications as <a href="statistical_modeling" title="wikilink">statistical models</a> of real-world processes.</p>
<h2 id="introduction">Introduction</h2>

<p> A Markov chain is a <a href="stochastic_process" title="wikilink">stochastic process</a> with the <a href="Markov_property" title="wikilink">Markov property</a>. The term "Markov chain" refers to the sequence of random variables such a process moves through, with the Markov property defining <a href="serial_dependence" title="wikilink">serial dependence</a> only between adjacent periods (as in a "chain"). It can thus be used for describing systems that follow a chain of linked events, where what happens next depends only on the current state of the system.</p>

<p>In the literature, different kinds of <a href="Markov_process" title="wikilink">Markov process</a> are designated as "Markov chains". Usually the term is reserved for a process with a discrete set of times, i.e. a <a class="uri" href="discrete-time" title="wikilink">discrete-time</a> Markov chain (DTMC).<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> On the other hand, a few authors use the term "Markov process" to refer to a <a href="continuous-time_Markov_chain" title="wikilink">continuous-time Markov chain</a> without explicit mention.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a><a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>

<p>While the time parameter is usually discrete, the <a href="state_space" title="wikilink">state space</a> of a Markov chain does not have any generally agreed-on restrictions: the term may refer to a process on an arbitrary state space.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> However, many applications of Markov chains employ finite or <a href="countable" title="wikilink">countably infinite</a> (that is, <a href="Discrete_space" title="wikilink">discrete</a>) state spaces, which have a more straightforward statistical analysis. Besides time-index and state-space parameters, there are many other variations, extensions and generalisations (see <a href="#Variations" title="wikilink">Variations</a>). For simplicity, most of this article concentrates on the discrete-time, discrete state-space case, unless mentioned otherwise.</p>

<p>The changes of state of the system are called transitions. The probabilities associated with various state changes are called transition probabilities. The process is characterized by a state space, a <a href="transition_matrix" title="wikilink">transition matrix</a> describing the probabilities of particular transitions, and an initial state (or initial distribution) across the state space. By convention, we assume all possible states and transitions have been included in the definition of the process, so there is always a next state, and the process does not terminate.</p>

<p>A discrete-time random process involves a system which is in a certain state at each step, with the state changing randomly between steps. The steps are often thought of as moments in time, but they can equally well refer to physical distance or any other discrete measurement. Formally, the steps are the <a class="uri" href="integers" title="wikilink">integers</a> or <a href="natural_numbers" title="wikilink">natural numbers</a>, and the random process is a mapping of these to states. The Markov property states that the <a href="conditional_probability_distribution" title="wikilink">conditional probability distribution</a> for the system at the next step (and in fact at all future steps) depends only on the current state of the system, and not additionally on the state of the system at previous steps.</p>

<p>Since the system changes randomly, it is generally impossible to predict with certainty the state of a Markov chain at a given point in the future. However, the statistical properties of the system's future can be predicted. In many applications, it is these statistical properties that are important.</p>

<p>A famous Markov chain is the so-called "drunkard's walk", a <a href="random_walk" title="wikilink">random walk</a> on the <a href="number_line" title="wikilink">number line</a> where, at each step, the position may change by +1 or −1 with equal probability. From any position there are two possible transitions, to the next or previous integer. The transition probabilities depend only on the current position, not on the manner in which the position was reached. For example, the transition probabilities from 5 to 4 and 5 to 6 are both 0.5, and all other transition probabilities from 5 are 0. These probabilities are independent of whether the system was previously in 4 or 6.</p>

<p>Another example is the dietary habits of a creature who eats only grapes, cheese, or lettuce, and whose dietary habits conform to the following rules:</p>
<ul>
<li>It eats exactly once a day.</li>
<li>If it ate cheese today, tomorrow it will eat lettuce or grapes with equal probability.</li>
<li>If it ate grapes today, tomorrow it will eat grapes with probability 1/10, cheese with probability 4/10 and lettuce with probability 5/10.</li>
<li>If it ate lettuce today, tomorrow it will eat grapes with probability 4/10 or cheese with probability 6/10. It will not eat lettuce again tomorrow.</li>
</ul>

<p>This creature's eating habits can be modeled with a Markov chain since its choice tomorrow depends solely on what it ate today, not what it ate yesterday or any other time in the past. One statistical property that could be calculated is the expected percentage, over a long period, of the days on which the creature will eat grapes.</p>

<p>A series of independent events (for example, a series of coin flips) satisfies the formal definition of a Markov chain. However, the theory is usually applied only when the probability distribution of the next step depends non-trivially on the current state.</p>

<p>Many other <a href="examples_of_Markov_chains" title="wikilink">examples of Markov chains</a> exist.</p>
<h2 id="formal-definition">Formal definition</h2>

<p>A Markov chain is a sequence of <a href="random_variable" title="wikilink">random variables</a> <em>X</em><sub>1</sub>, <em>X</em><sub>2</sub>, <em>X</em><sub>3</sub>, ... with the Markov property, namely that, given the present state, the future and past states are independent. Formally,</p>

<p>
<math display="block" id="Markov_chain:0">
<semantics>
<mrow>
<mrow>
<mi>Pr</mi>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<msub>
<mi>X</mi>
<mrow>
<mi>n</mi>
<mo>+</mo>
<mn>1</mn>
</mrow>
</msub>
<mo>=</mo>
<mi>x</mi>
</mrow>
<mo>∣</mo>
<mrow>
<msub>
<mi>X</mi>
<mn>1</mn>
</msub>
<mo>=</mo>
<msub>
<mi>x</mi>
<mn>1</mn>
</msub>
</mrow>
<mo>,</mo>
<mrow>
<msub>
<mi>X</mi>
<mn>2</mn>
</msub>
<mo>=</mo>
<msub>
<mi>x</mi>
<mn>2</mn>
</msub>
</mrow>
<mo>,</mo>
<mi mathvariant="normal">…</mi>
<mo>,</mo>
<mrow>
<msub>
<mi>X</mi>
<mi>n</mi>
</msub>
<mo>=</mo>
<msub>
<mi>x</mi>
<mi>n</mi>
</msub>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<mi>Pr</mi>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<msub>
<mi>X</mi>
<mrow>
<mi>n</mi>
<mo>+</mo>
<mn>1</mn>
</mrow>
</msub>
<mo>=</mo>
<mi>x</mi>
</mrow>
<mo>∣</mo>
<mrow>
<msub>
<mi>X</mi>
<mi>n</mi>
</msub>
<mo>=</mo>
<msub>
<mi>x</mi>
<mi>n</mi>
</msub>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<ci>Pr</ci>
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>X</ci>
<apply>
<plus></plus>
<ci>n</ci>
<cn type="integer">1</cn>
</apply>
</apply>
<ci>x</ci>
</apply>
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>X</ci>
<cn type="integer">1</cn>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<cn type="integer">1</cn>
</apply>
</apply>
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>X</ci>
<cn type="integer">2</cn>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<cn type="integer">2</cn>
</apply>
</apply>
<ci>normal-…</ci>
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>X</ci>
<ci>n</ci>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<ci>n</ci>
</apply>
</apply>
</apply>
<apply>
<ci>Pr</ci>
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>X</ci>
<apply>
<plus></plus>
<ci>n</ci>
<cn type="integer">1</cn>
</apply>
</apply>
<ci>x</ci>
</apply>
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>X</ci>
<ci>n</ci>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<ci>n</ci>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \Pr(X_{n+1}=x\mid X_{1}=x_{1},X_{2}=x_{2},\ldots,X_{n}=x_{n})=\Pr(X_{n+1}=x%
\mid X_{n}=x_{n})
  </annotation>
</semantics>
</math>

, if both <a href="conditional_probability" title="wikilink">conditional probabilities</a> are well defined, i.e. if 

<math display="inline" id="Markov_chain:1">
<semantics>
<mrow>
<mrow>
<mi>Pr</mi>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<msub>
<mi>X</mi>
<mn>1</mn>
</msub>
<mo>=</mo>
<msub>
<mi>x</mi>
<mn>1</mn>
</msub>
</mrow>
<mo>,</mo>
<mi mathvariant="normal">…</mi>
<mo>,</mo>
<mrow>
<msub>
<mi>X</mi>
<mi>n</mi>
</msub>
<mo>=</mo>
<msub>
<mi>x</mi>
<mi>n</mi>
</msub>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>&gt;</mo>
<mn>0</mn>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<gt></gt>
<apply>
<ci>Pr</ci>
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>X</ci>
<cn type="integer">1</cn>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<cn type="integer">1</cn>
</apply>
</apply>
<ci>normal-…</ci>
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>X</ci>
<ci>n</ci>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<ci>n</ci>
</apply>
</apply>
</apply>
<cn type="integer">0</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \Pr(X_{1}=x_{1},...,X_{n}=x_{n})&gt;0
  </annotation>
</semantics>
</math>

.</p>

<p>The possible values of <em>X</em><sub><em>i</em></sub> form a <a href="countable_set" title="wikilink">countable set</a> <em>S</em> called the <strong>state space</strong> of the chain.</p>

<p>Markov chains are often described by a sequence of <a href="directed_graph" title="wikilink">directed graphs</a>, where the edges of graph <em>n</em> are labeled by the probabilities of going from one state at time <em>n</em> to the other states at time <em>n+1</em>, 

<math display="inline" id="Markov_chain:2">
<semantics>
<mrow>
<mi>Pr</mi>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<msub>
<mi>X</mi>
<mrow>
<mi>n</mi>
<mo>+</mo>
<mn>1</mn>
</mrow>
</msub>
<mo>=</mo>
<mi>x</mi>
</mrow>
<mo>∣</mo>
<mrow>
<msub>
<mi>X</mi>
<mi>n</mi>
</msub>
<mo>=</mo>
<msub>
<mi>x</mi>
<mi>n</mi>
</msub>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<ci>Pr</ci>
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>X</ci>
<apply>
<plus></plus>
<ci>n</ci>
<cn type="integer">1</cn>
</apply>
</apply>
<ci>x</ci>
</apply>
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>X</ci>
<ci>n</ci>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<ci>n</ci>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \Pr(X_{n+1}=x\mid X_{n}=x_{n})
  </annotation>
</semantics>
</math>

. The same information is represented by the <a href="transition_matrix" title="wikilink">transition matrix</a> from time <em>n</em> to time <em>n+1</em>. However, Markov chains are frequently assumed to be time-homogeneous (see variations below), in which case the graph and matrix are independent of <em>n</em> and so are not presented as sequences.</p>

<p>These descriptions highlight the structure of the Markov chain that is independent of the initial distribution 

<math display="inline" id="Markov_chain:3">
<semantics>
<mrow>
<mi>Pr</mi>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<msub>
<mi>X</mi>
<mn>1</mn>
</msub>
<mo>=</mo>
<msub>
<mi>x</mi>
<mn>1</mn>
</msub>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<ci>Pr</ci>
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>X</ci>
<cn type="integer">1</cn>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<cn type="integer">1</cn>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \Pr(X_{1}=x_{1})
  </annotation>
</semantics>
</math>

. When time-homogeneous, the chain can be interpreted as a state machine assigning a probability of hopping from each vertex or state to an adjacent one. The probability 

<math display="inline" id="Markov_chain:4">
<semantics>
<mrow>
<mi>Pr</mi>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<msub>
<mi>X</mi>
<mi>n</mi>
</msub>
<mo>=</mo>
<mi>x</mi>
</mrow>
<mo stretchy="false">|</mo>
<mrow>
<msub>
<mi>X</mi>
<mn>1</mn>
</msub>
<mo>=</mo>
<msub>
<mi>x</mi>
<mn>1</mn>
</msub>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<ci>Pr</ci>
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>X</ci>
<ci>n</ci>
</apply>
<ci>x</ci>
</apply>
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>X</ci>
<cn type="integer">1</cn>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<cn type="integer">1</cn>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \Pr(X_{n}=x|X_{1}=x_{1})
  </annotation>
</semantics>
</math>

 of the machine's state can be analyzed as the statistical behavior of the machine with an element 

<math display="inline" id="Markov_chain:5">
<semantics>
<msub>
<mi>x</mi>
<mn>1</mn>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<cn type="integer">1</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   x_{1}
  </annotation>
</semantics>
</math>

 of the state space as input, or as the behavior of the machine with the initial distribution 

<math display="inline" id="Markov_chain:6">
<semantics>
<mrow>
<mi>Pr</mi>
<mrow>
<mo stretchy="false">(</mo>
<msub>
<mi>X</mi>
<mn>1</mn>
</msub>
<mo>=</mo>
<mi>y</mi>
<mo stretchy="false">)</mo>
</mrow>
<mo>=</mo>
<mrow>
<mo stretchy="false">[</mo>
<msub>
<mi>x</mi>
<mn>1</mn>
</msub>
<mo>=</mo>
<mi>y</mi>
<mo stretchy="false">]</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>Pr</ci>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>X</ci>
<cn type="integer">1</cn>
</apply>
<eq></eq>
<csymbol cd="unknown">y</csymbol>
<ci>normal-)</ci>
</cerror>
<eq></eq>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-[</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<cn type="integer">1</cn>
</apply>
<eq></eq>
<csymbol cd="unknown">y</csymbol>
<ci>normal-]</ci>
</cerror>
</cerror>
</annotation-xml>
<annotation encoding="application/x-tex">
   \Pr(X_{1}=y)=[x_{1}=y]
  </annotation>
</semantics>
</math>

 of states as input, where 

<math display="inline" id="Markov_chain:7">
<semantics>
<mrow>
<mo stretchy="false">[</mo>
<mi>P</mi>
<mo stretchy="false">]</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="latexml">delimited-[]</csymbol>
<ci>P</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   [P]
  </annotation>
</semantics>
</math>

 is the <a href="Iverson_bracket" title="wikilink">Iverson bracket</a>.</p>

<p>The fact that some sequences of states might have zero probability of occurring corresponds to graph that has multiple <a href="Connected_component_(graph_theory)" title="wikilink">connected components</a>, where we suppress edges that carry a 0 transition probability. For example, if <em>a</em> has a nonzero probability of going to <em>b</em>, but <em>a</em> and <em>x</em> lie in different connected components of the graph, then 

<math display="inline" id="Markov_chain:8">
<semantics>
<mrow>
<mi>Pr</mi>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<msub>
<mi>X</mi>
<mrow>
<mi>n</mi>
<mo>+</mo>
<mn>1</mn>
</mrow>
</msub>
<mo>=</mo>
<mi>b</mi>
</mrow>
<mo stretchy="false">|</mo>
<mrow>
<msub>
<mi>X</mi>
<mi>n</mi>
</msub>
<mo>=</mo>
<mi>a</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<ci>Pr</ci>
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>X</ci>
<apply>
<plus></plus>
<ci>n</ci>
<cn type="integer">1</cn>
</apply>
</apply>
<ci>b</ci>
</apply>
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>X</ci>
<ci>n</ci>
</apply>
<ci>a</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \Pr(X_{n+1}=b|X_{n}=a)
  </annotation>
</semantics>
</math>

 is defined, while 

<math display="inline" id="Markov_chain:9">
<semantics>
<mrow>
<mi>Pr</mi>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<msub>
<mi>X</mi>
<mrow>
<mi>n</mi>
<mo>+</mo>
<mn>1</mn>
</mrow>
</msub>
<mo>=</mo>
<mi>b</mi>
</mrow>
<mo stretchy="false">|</mo>
<mrow>
<msub>
<mi>X</mi>
<mn>1</mn>
</msub>
<mo>=</mo>
<mi>x</mi>
</mrow>
<mo>,</mo>
<mi mathvariant="normal">…</mi>
<mo>,</mo>
<mrow>
<msub>
<mi>X</mi>
<mi>n</mi>
</msub>
<mo>=</mo>
<mi>a</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<ci>Pr</ci>
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>X</ci>
<apply>
<plus></plus>
<ci>n</ci>
<cn type="integer">1</cn>
</apply>
</apply>
<ci>b</ci>
</apply>
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>X</ci>
<cn type="integer">1</cn>
</apply>
<ci>x</ci>
</apply>
<ci>normal-…</ci>
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>X</ci>
<ci>n</ci>
</apply>
<ci>a</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \Pr(X_{n+1}=b|X_{1}=x,...,X_{n}=a)
  </annotation>
</semantics>
</math>

 is not.</p>
<h3 id="variations">Variations</h3>
<ul>
<li><a href="Continuous-time_Markov_process" title="wikilink">Continuous-time Markov processes</a> have a continuous index.</li>
<li>

<p><strong>Time-homogeneous Markov chains</strong> (or <strong>stationary Markov chains</strong>) are processes where</p></li>
</ul>
<dl>
<dd><dl>
<dd>
<math display="inline" id="Markov_chain:10">
<semantics>
<mrow>
<mrow>
<mi>Pr</mi>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<msub>
<mi>X</mi>
<mrow>
<mi>n</mi>
<mo>+</mo>
<mn>1</mn>
</mrow>
</msub>
<mo>=</mo>
<mi>x</mi>
</mrow>
<mo>∣</mo>
<mrow>
<msub>
<mi>X</mi>
<mi>n</mi>
</msub>
<mo>=</mo>
<mi>y</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<mi>Pr</mi>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<msub>
<mi>X</mi>
<mi>n</mi>
</msub>
<mo>=</mo>
<mi>x</mi>
</mrow>
<mo>∣</mo>
<mrow>
<msub>
<mi>X</mi>
<mrow>
<mi>n</mi>
<mo>-</mo>
<mn>1</mn>
</mrow>
</msub>
<mo>=</mo>
<mi>y</mi>
</mrow>
<mo rspace="4.2pt" stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<ci>Pr</ci>
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>X</ci>
<apply>
<plus></plus>
<ci>n</ci>
<cn type="integer">1</cn>
</apply>
</apply>
<ci>x</ci>
</apply>
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>X</ci>
<ci>n</ci>
</apply>
<ci>y</ci>
</apply>
</apply>
<apply>
<ci>Pr</ci>
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>X</ci>
<ci>n</ci>
</apply>
<ci>x</ci>
</apply>
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>X</ci>
<apply>
<minus></minus>
<ci>n</ci>
<cn type="integer">1</cn>
</apply>
</apply>
<ci>y</ci>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \Pr(X_{n+1}=x\mid X_{n}=y)=\Pr(X_{n}=x\mid X_{n-1}=y)\,
  </annotation>
</semantics>
</math>
</dd>
</dl>
</dd>
</dl>
<dl>
<dd>for all <em>n</em>. The probability of the transition is independent of <em>n</em>.
</dd>
</dl>
<ul>
<li>A '''Markov chain of order <em>m</em> ''' (or a Markov chain with memory <em>m</em>), where <em>m</em> is finite, is a process satisfying</li>
</ul>
<dl>
<dd><dl>
<dd><math>
</math></dd>
</dl>
</dd>
</dl>

<p>\begin{align} {} &amp;\Pr(X_n=x_n\mid X_{n-1}=x_{n-1}, X_{n-2}=x_{n-2}, \dots , X_1=x_1) \\</p>
<h1 id="prx_n">&amp;\Pr(X_n</h1>

<p>x_n\mid X_{n-1}=x_{n-1}, X_{n-2}=x_{n-2}, \dots, X_{n-m}=x_{n-m}) \text{ for }n &gt; m \end{align} </p>
<dl>
<dd>In other words, the future state depends on the past <em>m</em> states. It is possible to construct a chain (<em>Y<sub>n</sub></em>) from (<em>X<sub>n</sub></em>) which has the 'classical' Markov property by taking as state space the ordered <em>m</em>-tuples of <em>X</em> values, ie. <em>Y<sub>n</sub></em> = (<em>X<sub>n</sub></em>, <em>X</em><sub><em>n</em>−1</sub>, ..., <em>X</em><sub><em>n</em>−<em>m</em>+1</sub>).
</dd>
</dl>
<h3 id="example">Example</h3>

<p> A <a href="state_diagram" title="wikilink">state diagram</a> for a simple example is shown in the figure on the right, using a directed graph to picture the <a href="state_transition" title="wikilink">state transitions</a>. The states represent whether a hypothetical stock market is exhibiting a <a href="Market_trend#Bull_market" title="wikilink">bull market</a>, <a href="Market_trend#Bear_market" title="wikilink">bear market</a>, or stagnant market trend during a given week. According to the figure, a bull week is followed by another bull week 90% of the time, a bear week 7.5% of the time, and a stagnant week the other 2.5% of the time. Labelling the state space {1 = bull, 2 = bear, 3 = stagnant} the <a href="transition_matrix" title="wikilink">transition matrix</a> for this example is</p>

<p>
<math display="block" id="Markov_chain:11">
<semantics>
<mrow>
<mrow>
<mi>P</mi>
<mo>=</mo>
<mrow>
<mo>[</mo>
<mtable displaystyle="true">
<mtr>
<mtd columnalign="center">
<mn>0.9</mn>
</mtd>
<mtd columnalign="center">
<mn>0.075</mn>
</mtd>
<mtd columnalign="center">
<mn>0.025</mn>
</mtd>
</mtr>
<mtr>
<mtd columnalign="center">
<mn>0.15</mn>
</mtd>
<mtd columnalign="center">
<mn>0.8</mn>
</mtd>
<mtd columnalign="center">
<mn>0.05</mn>
</mtd>
</mtr>
<mtr>
<mtd columnalign="center">
<mn>0.25</mn>
</mtd>
<mtd columnalign="center">
<mn>0.25</mn>
</mtd>
<mtd columnalign="center">
<mn>0.5</mn>
</mtd>
</mtr>
</mtable>
<mo>]</mo>
</mrow>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<ci>P</ci>
<matrix>
<matrixrow>
<cn type="float">0.9</cn>
<cn type="float">0.075</cn>
<cn type="float">0.025</cn>
</matrixrow>
<matrixrow>
<cn type="float">0.15</cn>
<cn type="float">0.8</cn>
<cn type="float">0.05</cn>
</matrixrow>
<matrixrow>
<cn type="float">0.25</cn>
<cn type="float">0.25</cn>
<cn type="float">0.5</cn>
</matrixrow>
</matrix>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   P=\begin{bmatrix}0.9&amp;0.075&amp;0.025\\
0.15&amp;0.8&amp;0.05\\
0.25&amp;0.25&amp;0.5\end{bmatrix}.
  </annotation>
</semantics>
</math>

 The distribution over states can be written as a <a href="stochastic_row_vector" title="wikilink">stochastic row vector</a> <em>x</em> with the relation <em>x</em><sup>(<em>n</em> + 1)</sup> = <em>x</em><sup>(<em>n</em>)</sup><em>P</em>. So if at time <em>n</em> the system is in state 2 (bear), then three time periods later, at time <em>n</em> + 3 the distribution is</p>

<p>
<math display="inline" id="Markov_chain:12">
<semantics>
<msup>
<mi>x</mi>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>n</mi>
<mo>+</mo>
<mn>3</mn>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</msup>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>x</ci>
<apply>
<plus></plus>
<ci>n</ci>
<cn type="integer">3</cn>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \displaystyle x^{(n+3)}
  </annotation>
</semantics>
</math>


 Using the transition matrix it is possible to calculate, for example, the long-term fraction of weeks during which the market is stagnant, or the average number of weeks it will take to go from a stagnant to a bull market. Using the transition probabilities, the steady-state probabilities indicate that 62.5% of weeks will be in a bull market, 31.25% of weeks will be in a bear market and 6.25% of weeks will be stagnant, since:</p>

<p>
<math display="inline" id="Markov_chain:13">
<semantics>
<mrow>
<mrow>
<mpadded width="+1.7pt">
<msub>
<mo>lim</mo>
<mrow>
<mi>N</mi>
<mo>→</mo>
<mi mathvariant="normal">∞</mi>
</mrow>
</msub>
</mpadded>
<msup>
<mi>P</mi>
<mi>N</mi>
</msup>
</mrow>
<mo>=</mo>
<mrow>
<mo>[</mo>
<mtable>
<mtr>
<mtd columnalign="center">
<mn>0.625</mn>
</mtd>
<mtd columnalign="center">
<mn>0.3125</mn>
</mtd>
<mtd columnalign="center">
<mn>0.0625</mn>
</mtd>
</mtr>
<mtr>
<mtd columnalign="center">
<mn>0.625</mn>
</mtd>
<mtd columnalign="center">
<mn>0.3125</mn>
</mtd>
<mtd columnalign="center">
<mn>0.0625</mn>
</mtd>
</mtr>
<mtr>
<mtd columnalign="center">
<mn>0.625</mn>
</mtd>
<mtd columnalign="center">
<mn>0.3125</mn>
</mtd>
<mtd columnalign="center">
<mn>0.0625</mn>
</mtd>
</mtr>
</mtable>
<mo>]</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<limit></limit>
<apply>
<ci>normal-→</ci>
<ci>N</ci>
<infinity></infinity>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>P</ci>
<ci>N</ci>
</apply>
</apply>
<matrix>
<matrixrow>
<cn type="float">0.625</cn>
<cn type="float">0.3125</cn>
<cn type="float">0.0625</cn>
</matrixrow>
<matrixrow>
<cn type="float">0.625</cn>
<cn type="float">0.3125</cn>
<cn type="float">0.0625</cn>
</matrixrow>
<matrixrow>
<cn type="float">0.625</cn>
<cn type="float">0.3125</cn>
<cn type="float">0.0625</cn>
</matrixrow>
</matrix>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \lim_{N\to\infty}\,P^{N}=\begin{bmatrix}0.625&amp;0.3125&amp;0.0625\\
0.625&amp;0.3125&amp;0.0625\\
0.625&amp;0.3125&amp;0.0625\\
\end{bmatrix}
  </annotation>
</semantics>
</math>
</p>

<p>A thorough development and many examples can be found in the on-line monograph Meyn &amp; Tweedie 2005.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>

<p>A <a href="finite_state_machine" title="wikilink">finite state machine</a> can be used as a representation of a Markov chain. Assuming a sequence of <a href="Independent_and_identically_distributed_random_variables" title="wikilink">independent and identically distributed</a> input signals (for example, symbols from a binary alphabet chosen by coin tosses), if the machine is in state <em>y</em> at time <em>n</em>, then the probability that it moves to state <em>x</em> at time <em>n</em> + 1 depends only on the current state.</p>
<h2 id="transient-evolution">Transient evolution</h2>

<p>The probability of going from state <em>i</em> to state <em>j</em> in <em>n</em> time steps is</p>

<p>
<math display="block" id="Markov_chain:14">
<semantics>
<mrow>
<msubsup>
<mi>p</mi>
<mrow>
<mi>i</mi>
<mi>j</mi>
</mrow>
<mrow>
<mo stretchy="false">(</mo>
<mi>n</mi>
<mo stretchy="false">)</mo>
</mrow>
</msubsup>
<mo>=</mo>
<mrow>
<mi>Pr</mi>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<msub>
<mi>X</mi>
<mi>n</mi>
</msub>
<mo>=</mo>
<mi>j</mi>
</mrow>
<mo>∣</mo>
<mrow>
<msub>
<mi>X</mi>
<mn>0</mn>
</msub>
<mo>=</mo>
<mi>i</mi>
</mrow>
<mo rspace="4.2pt" stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>p</ci>
<apply>
<times></times>
<ci>i</ci>
<ci>j</ci>
</apply>
</apply>
<ci>n</ci>
</apply>
<apply>
<ci>Pr</ci>
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>X</ci>
<ci>n</ci>
</apply>
<ci>j</ci>
</apply>
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>X</ci>
<cn type="integer">0</cn>
</apply>
<ci>i</ci>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   p_{ij}^{(n)}=\Pr(X_{n}=j\mid X_{0}=i)\,
  </annotation>
</semantics>
</math>
</p>

<p>and the single-step transition is</p>

<p>
<math display="block" id="Markov_chain:15">
<semantics>
<mrow>
<mrow>
<msub>
<mi>p</mi>
<mrow>
<mi>i</mi>
<mi>j</mi>
</mrow>
</msub>
<mo>=</mo>
<mrow>
<mi>Pr</mi>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<msub>
<mi>X</mi>
<mn>1</mn>
</msub>
<mo>=</mo>
<mi>j</mi>
</mrow>
<mo>∣</mo>
<mrow>
<msub>
<mi>X</mi>
<mn>0</mn>
</msub>
<mo>=</mo>
<mi>i</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>p</ci>
<apply>
<times></times>
<ci>i</ci>
<ci>j</ci>
</apply>
</apply>
<apply>
<ci>Pr</ci>
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>X</ci>
<cn type="integer">1</cn>
</apply>
<ci>j</ci>
</apply>
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>X</ci>
<cn type="integer">0</cn>
</apply>
<ci>i</ci>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   p_{ij}=\Pr(X_{1}=j\mid X_{0}=i).\,
  </annotation>
</semantics>
</math>
</p>

<p>For a time-homogeneous Markov chain:</p>

<p>
<math display="block" id="Markov_chain:16">
<semantics>
<mrow>
<msubsup>
<mi>p</mi>
<mrow>
<mi>i</mi>
<mi>j</mi>
</mrow>
<mrow>
<mo stretchy="false">(</mo>
<mi>n</mi>
<mo stretchy="false">)</mo>
</mrow>
</msubsup>
<mo>=</mo>
<mrow>
<mi>Pr</mi>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<msub>
<mi>X</mi>
<mrow>
<mi>k</mi>
<mo>+</mo>
<mi>n</mi>
</mrow>
</msub>
<mo>=</mo>
<mi>j</mi>
</mrow>
<mo>∣</mo>
<mrow>
<msub>
<mi>X</mi>
<mi>k</mi>
</msub>
<mo>=</mo>
<mi>i</mi>
</mrow>
<mo rspace="4.2pt" stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>p</ci>
<apply>
<times></times>
<ci>i</ci>
<ci>j</ci>
</apply>
</apply>
<ci>n</ci>
</apply>
<apply>
<ci>Pr</ci>
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>X</ci>
<apply>
<plus></plus>
<ci>k</ci>
<ci>n</ci>
</apply>
</apply>
<ci>j</ci>
</apply>
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>X</ci>
<ci>k</ci>
</apply>
<ci>i</ci>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   p_{ij}^{(n)}=\Pr(X_{k+n}=j\mid X_{k}=i)\,
  </annotation>
</semantics>
</math>
</p>

<p>and</p>

<p>
<math display="block" id="Markov_chain:17">
<semantics>
<mrow>
<mrow>
<msub>
<mi>p</mi>
<mrow>
<mi>i</mi>
<mi>j</mi>
</mrow>
</msub>
<mo>=</mo>
<mrow>
<mi>Pr</mi>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<msub>
<mi>X</mi>
<mrow>
<mi>k</mi>
<mo>+</mo>
<mn>1</mn>
</mrow>
</msub>
<mo>=</mo>
<mi>j</mi>
</mrow>
<mo>∣</mo>
<mrow>
<msub>
<mi>X</mi>
<mi>k</mi>
</msub>
<mo>=</mo>
<mi>i</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>p</ci>
<apply>
<times></times>
<ci>i</ci>
<ci>j</ci>
</apply>
</apply>
<apply>
<ci>Pr</ci>
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>X</ci>
<apply>
<plus></plus>
<ci>k</ci>
<cn type="integer">1</cn>
</apply>
</apply>
<ci>j</ci>
</apply>
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>X</ci>
<ci>k</ci>
</apply>
<ci>i</ci>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   p_{ij}=\Pr(X_{k+1}=j\mid X_{k}=i).\,
  </annotation>
</semantics>
</math>
</p>

<p>The <em>n</em>-step transition probabilities satisfy the <a href="Chapman–Kolmogorov_equation" title="wikilink">Chapman–Kolmogorov equation</a>, that for any <em>k</em> such that 0 p_{ij}^{(n)} = \sum_{r \in S} p_{ir}^{(k)} p_{rj}^{(n-k)}</p>

<p>where <em>S</em> is the state space of the Markov chain.</p>

<p>The <a href="marginal_distribution" title="wikilink">marginal distribution</a> Pr(<em>X</em><sub><em>n</em></sub> = <em>x</em>) is the distribution over states at time <em>n</em>. The initial distribution is Pr(<em>X</em><sub>0</sub> = <em>x</em>). The evolution of the process through one time step is described by</p>

<p>
<math display="block" id="Markov_chain:18">
<semantics>
<mrow>
<mrow>
<mrow>
<mi>Pr</mi>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<msub>
<mi>X</mi>
<mi>n</mi>
</msub>
<mo>=</mo>
<mi>j</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<munder>
<mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
<mrow>
<mi>r</mi>
<mo>∈</mo>
<mi>S</mi>
</mrow>
</munder>
<mrow>
<msub>
<mi>p</mi>
<mrow>
<mi>r</mi>
<mi>j</mi>
</mrow>
</msub>
<mrow>
<mi>Pr</mi>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<msub>
<mi>X</mi>
<mrow>
<mi>n</mi>
<mo>-</mo>
<mn>1</mn>
</mrow>
</msub>
<mo>=</mo>
<mi>r</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<munder>
<mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
<mrow>
<mi>r</mi>
<mo>∈</mo>
<mi>S</mi>
</mrow>
</munder>
<mrow>
<msubsup>
<mi>p</mi>
<mrow>
<mi>r</mi>
<mi>j</mi>
</mrow>
<mrow>
<mo stretchy="false">(</mo>
<mi>n</mi>
<mo stretchy="false">)</mo>
</mrow>
</msubsup>
<mrow>
<mi>Pr</mi>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<msub>
<mi>X</mi>
<mn>0</mn>
</msub>
<mo>=</mo>
<mi>r</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
</mrow>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<and></and>
<apply>
<eq></eq>
<apply>
<ci>Pr</ci>
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>X</ci>
<ci>n</ci>
</apply>
<ci>j</ci>
</apply>
</apply>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<sum></sum>
<apply>
<in></in>
<ci>r</ci>
<ci>S</ci>
</apply>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>p</ci>
<apply>
<times></times>
<ci>r</ci>
<ci>j</ci>
</apply>
</apply>
<apply>
<ci>Pr</ci>
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>X</ci>
<apply>
<minus></minus>
<ci>n</ci>
<cn type="integer">1</cn>
</apply>
</apply>
<ci>r</ci>
</apply>
</apply>
</apply>
</apply>
</apply>
<apply>
<eq></eq>
<share href="#.cmml">
</share>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<sum></sum>
<apply>
<in></in>
<ci>r</ci>
<ci>S</ci>
</apply>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>p</ci>
<apply>
<times></times>
<ci>r</ci>
<ci>j</ci>
</apply>
</apply>
<ci>n</ci>
</apply>
<apply>
<ci>Pr</ci>
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>X</ci>
<cn type="integer">0</cn>
</apply>
<ci>r</ci>
</apply>
</apply>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \Pr(X_{n}=j)=\sum_{r\in S}p_{rj}\Pr(X_{n-1}=r)=\sum_{r\in S}p_{rj}^{(n)}\Pr(X_%
{0}=r).
  </annotation>
</semantics>
</math>
</p>

<p>Note: The superscript (<em>n</em>) is an <a href="Indexed_family" title="wikilink">index</a> and not an <a class="uri" href="exponent" title="wikilink">exponent</a>.</p>
<h2 id="properties">Properties</h2>
<h3 id="reducibility">Reducibility</h3>

<p>A state <em>j</em> is said to be <strong>accessible</strong> from a state <em>i</em> (written <em>i</em> → <em>j</em>) if a system started in state <em>i</em> has a non-zero probability of transitioning into state <em>j</em> at some point. Formally, state <em>j</em> is accessible from state <em>i</em> if there exists an integer <em>n<sub>ij</sub></em> ≥ 0 such that</p>

<p>
<math display="block" id="Markov_chain:19">
<semantics>
<mrow>
<mrow>
<mi>Pr</mi>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<msub>
<mi>X</mi>
<msub>
<mi>n</mi>
<mrow>
<mi>i</mi>
<mi>j</mi>
</mrow>
</msub>
</msub>
<mo>=</mo>
<mi>j</mi>
</mrow>
<mo>∣</mo>
<mrow>
<msub>
<mi>X</mi>
<mn>0</mn>
</msub>
<mo>=</mo>
<mi>i</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<msubsup>
<mi>p</mi>
<mrow>
<mi>i</mi>
<mi>j</mi>
</mrow>
<mrow>
<mo stretchy="false">(</mo>
<msub>
<mi>n</mi>
<mrow>
<mi>i</mi>
<mi>j</mi>
</mrow>
</msub>
<mo stretchy="false">)</mo>
</mrow>
</msubsup>
<mo>&gt;</mo>
<mpadded width="+1.7pt">
<mn>0.</mn>
</mpadded>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<and></and>
<apply>
<eq></eq>
<apply>
<ci>Pr</ci>
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>X</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>n</ci>
<apply>
<times></times>
<ci>i</ci>
<ci>j</ci>
</apply>
</apply>
</apply>
<ci>j</ci>
</apply>
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>X</ci>
<cn type="integer">0</cn>
</apply>
<ci>i</ci>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>p</ci>
<apply>
<times></times>
<ci>i</ci>
<ci>j</ci>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>n</ci>
<apply>
<times></times>
<ci>i</ci>
<ci>j</ci>
</apply>
</apply>
</apply>
</apply>
<apply>
<gt></gt>
<share href="#.cmml">
</share>
<cn type="float">0.</cn>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \Pr(X_{n_{ij}}=j\mid X_{0}=i)=p_{ij}^{(n_{ij})}&gt;0.\,
  </annotation>
</semantics>
</math>
</p>

<p>This integer is allowed to be different for each pair of states, hence the subscripts in n<sub>ij</sub>. Allowing <em>n</em> to be zero means that every state is defined to be accessible from itself.</p>

<p>A state <em>i</em> is said to <strong>communicate</strong> with state <em>j</em> (written <em>i</em> ↔ <em>j</em>) if both <em>i</em> → <em>j</em> and <em>j</em> → <em>i</em>. A set of states <em>C</em> is a <strong>communicating class</strong> if every pair of states in <em>C</em> communicates with each other, and no state in <em>C</em> is communicating with any state not in <em>C</em>. It can be shown that communication in this sense is an <a href="equivalence_relation" title="wikilink">equivalence relation</a> and thus that communicating classes are the <a href="equivalence_classes" title="wikilink">equivalence classes</a> of this relation. A communicating class is <strong>closed</strong> if the probability of leaving the class is zero, namely that if <em>i</em> is in <em>C</em> but <em>j</em> is not, then <em>j</em> is not accessible from <em>i</em>.</p>

<p>The set of communicating classes forms a <a href="Directed_acyclic_graph" title="wikilink">directed, acyclic graph</a> by inheriting the arrows from the original state space. A communicating class is closed if and only if it has no outgoing arrows in this graph.</p>

<p>A state <em>i</em> is said to be <strong>essential</strong> or <strong>final</strong> if for all <em>j</em> such that <em>i</em> → <em>j</em> it is also true that <em>j</em> → <em>i</em>. A state <em>i</em> is <strong>inessential</strong> if it is not essential.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> A state is final if and only if its communicating class is closed.</p>

<p>A Markov chain is said to be <strong>irreducible</strong> if its state space is a single communicating class; in other words, if it is possible to get to any state from any state.</p>
<h3 id="periodicity">Periodicity</h3>

<p>A state <em>i</em> has <strong>period</strong> <em>k</em> if any return to state <em>i</em> must occur in multiples of <em>k</em> time steps. Formally, the <a href="Periodic_function" title="wikilink">period</a> of a state is defined as</p>

<p>
<math display="block" id="Markov_chain:20">
<semantics>
<mrow>
<mi>k</mi>
<mo>=</mo>
<mrow>
<mi>gcd</mi>
<mrow>
<mo stretchy="false">{</mo>
<mrow>
<mrow>
<mi>n</mi>
<mo>&gt;</mo>
<mn>0</mn>
</mrow>
<mo>:</mo>
<mrow>
<mrow>
<mi>Pr</mi>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<msub>
<mi>X</mi>
<mi>n</mi>
</msub>
<mo>=</mo>
<mi>i</mi>
</mrow>
<mo>∣</mo>
<mrow>
<msub>
<mi>X</mi>
<mn>0</mn>
</msub>
<mo>=</mo>
<mi>i</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>&gt;</mo>
<mn>0</mn>
</mrow>
</mrow>
<mo stretchy="false">}</mo>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<ci>k</ci>
<apply>
<gcd></gcd>
<apply>
<ci>normal-:</ci>
<apply>
<gt></gt>
<ci>n</ci>
<cn type="integer">0</cn>
</apply>
<apply>
<gt></gt>
<apply>
<ci>Pr</ci>
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>X</ci>
<ci>n</ci>
</apply>
<ci>i</ci>
</apply>
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>X</ci>
<cn type="integer">0</cn>
</apply>
<ci>i</ci>
</apply>
</apply>
<cn type="integer">0</cn>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   k=\gcd\{n&gt;0:\Pr(X_{n}=i\mid X_{0}=i)&gt;0\}
  </annotation>
</semantics>
</math>
</p>

<p>(where "gcd" is the <a href="greatest_common_divisor" title="wikilink">greatest common divisor</a>) provided that this set is not empty. Otherwise the period is not defined. Note that even though a state has period <em>k</em>, it may not be possible to reach the state in <em>k</em> steps. For example, suppose it is possible to return to the state in {6, 8, 10, 12, ...} time steps; <em>k</em> would be 2, even though 2 does not appear in this list.</p>

<p>If <em>k</em> = 1, then the state is said to be <strong>aperiodic</strong>: returns to state <em>i</em> can occur at irregular times. It can be demonstrated that a state <em>i</em> is <strong>aperiodic</strong> if there exists <em>n</em> such that for all <em>n' ≥ n</em>,</p>

<p>
<math display="block" id="Markov_chain:21">
<semantics>
<mrow>
<mrow>
<mi>Pr</mi>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<msub>
<mi>X</mi>
<msup>
<mi>n</mi>
<mo>′</mo>
</msup>
</msub>
<mo>=</mo>
<mi>i</mi>
</mrow>
<mo>∣</mo>
<mrow>
<msub>
<mi>X</mi>
<mn>0</mn>
</msub>
<mo>=</mo>
<mi>i</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>&gt;</mo>
<mn>0.</mn>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<gt></gt>
<apply>
<ci>Pr</ci>
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>X</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>n</ci>
<ci>normal-′</ci>
</apply>
</apply>
<ci>i</ci>
</apply>
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>X</ci>
<cn type="integer">0</cn>
</apply>
<ci>i</ci>
</apply>
</apply>
<cn type="float">0.</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \Pr(X_{n^{\prime}}=i\mid X_{0}=i)&gt;0.
  </annotation>
</semantics>
</math>
</p>

<p>Otherwise (<em>k</em> &gt; 1), the state is said to be <strong>periodic with period <em>k</em></strong>. A Markov chain is aperiodic if every state is aperiodic. An irreducible Markov chain only needs one aperiodic state to imply all states are aperiodic.</p>

<p>Every state of a <a href="bipartite_graph" title="wikilink">bipartite graph</a> has an even <strong>period</strong>.</p>
<h3 id="transience">Transience</h3>

<p>A state <em>i</em> is said to be <strong>transient</strong> if, given that we start in state <em>i</em>, there is a non-zero probability that we will never return to <em>i</em>. Formally, let the <a href="random_variable" title="wikilink">random variable</a> <em>T<sub>i</sub></em> be the first return time to state <em>i</em> (the <strong>"hitting time"</strong>):</p>

<p>
<math display="block" id="Markov_chain:22">
<semantics>
<mrow>
<msub>
<mi>T</mi>
<mi>i</mi>
</msub>
<mo>=</mo>
<mo movablelimits="false">inf</mo>
<mrow>
<mo stretchy="false">{</mo>
<mi>n</mi>
<mo>≥</mo>
<mn>1</mn>
<mo>:</mo>
<msub>
<mi>X</mi>
<mi>n</mi>
</msub>
<mo>=</mo>
<mi>i</mi>
<mo>∣</mo>
<msub>
<mi>X</mi>
<mn>0</mn>
</msub>
<mo>=</mo>
<mi>i</mi>
<mo stretchy="false">}</mo>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>T</ci>
<ci>i</ci>
</apply>
<eq></eq>
<csymbol cd="latexml">infimum</csymbol>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-{</ci>
<csymbol cd="unknown">n</csymbol>
<geq></geq>
<cn type="integer">1</cn>
<ci>normal-:</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>X</ci>
<ci>n</ci>
</apply>
<eq></eq>
<csymbol cd="unknown">i</csymbol>
<ci>normal-∣</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>X</ci>
<cn type="integer">0</cn>
</apply>
<eq></eq>
<csymbol cd="unknown">i</csymbol>
<ci>normal-}</ci>
</cerror>
<ci>normal-.</ci>
</cerror>
</annotation-xml>
<annotation encoding="application/x-tex">
   T_{i}=\inf\{n\geq 1:X_{n}=i\mid X_{0}=i\}.
  </annotation>
</semantics>
</math>
</p>

<p>The number</p>

<p>
<math display="block" id="Markov_chain:23">
<semantics>
<mrow>
<msubsup>
<mi>f</mi>
<mrow>
<mi>i</mi>
<mi>i</mi>
</mrow>
<mrow>
<mo stretchy="false">(</mo>
<mi>n</mi>
<mo stretchy="false">)</mo>
</mrow>
</msubsup>
<mo>=</mo>
<mrow>
<mi>Pr</mi>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<msub>
<mi>T</mi>
<mi>i</mi>
</msub>
<mo>=</mo>
<mi>n</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>f</ci>
<apply>
<times></times>
<ci>i</ci>
<ci>i</ci>
</apply>
</apply>
<ci>n</ci>
</apply>
<apply>
<ci>Pr</ci>
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>T</ci>
<ci>i</ci>
</apply>
<ci>n</ci>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   f_{ii}^{(n)}=\Pr(T_{i}=n)
  </annotation>
</semantics>
</math>
</p>

<p>is the probability that we return to state <em>i</em> for the first time after <em>n</em> steps. Therefore, state <em>i</em> is transient if</p>

<p>
<math display="block" id="Markov_chain:24">
<semantics>
<mrow>
<mrow>
<mi>Pr</mi>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<msub>
<mi>T</mi>
<mi>i</mi>
</msub>
<mo>&lt;</mo>
<mi mathvariant="normal">∞</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<munderover>
<mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
<mrow>
<mi>n</mi>
<mo>=</mo>
<mn>1</mn>
</mrow>
<mi mathvariant="normal">∞</mi>
</munderover>
<msubsup>
<mi>f</mi>
<mrow>
<mi>i</mi>
<mi>i</mi>
</mrow>
<mrow>
<mo stretchy="false">(</mo>
<mi>n</mi>
<mo stretchy="false">)</mo>
</mrow>
</msubsup>
</mrow>
<mo>&lt;</mo>
<mn>1.</mn>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<and></and>
<apply>
<eq></eq>
<apply>
<ci>Pr</ci>
<apply>
<lt></lt>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>T</ci>
<ci>i</ci>
</apply>
<infinity></infinity>
</apply>
</apply>
<apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<sum></sum>
<apply>
<eq></eq>
<ci>n</ci>
<cn type="integer">1</cn>
</apply>
</apply>
<infinity></infinity>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>f</ci>
<apply>
<times></times>
<ci>i</ci>
<ci>i</ci>
</apply>
</apply>
<ci>n</ci>
</apply>
</apply>
</apply>
<apply>
<lt></lt>
<share href="#.cmml">
</share>
<cn type="float">1.</cn>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \Pr(T_{i}&lt;{\infty})=\sum_{n=1}^{\infty}f_{ii}^{(n)}&lt;1.
  </annotation>
</semantics>
</math>
</p>

<p>State <em>i</em> is <strong>recurrent</strong> (or <strong>persistent</strong>) if it is not transient. Recurrent states are guaranteed (with probability 1) to have a finite hitting time. Recurrence and transience are class properties, that is, they either hold or do not hold equally for all members of a communicating class.</p>
<h4 id="mean-recurrence-time">Mean recurrence time</h4>

<p>Even if the hitting time is finite with probability <em>1</em>, it needs not have a finite <a href="Expected_value" title="wikilink">expectation</a>. The <strong>mean recurrence time</strong> at state <em>i</em> is the expected return time <em>M<sub>i</sub></em>:</p>

<p>
<math display="block" id="Markov_chain:25">
<semantics>
<mrow>
<mrow>
<msub>
<mi>M</mi>
<mi>i</mi>
</msub>
<mo>=</mo>
<mrow>
<mi>E</mi>
<mrow>
<mo stretchy="false">[</mo>
<msub>
<mi>T</mi>
<mi>i</mi>
</msub>
<mo stretchy="false">]</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<munderover>
<mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
<mrow>
<mi>n</mi>
<mo>=</mo>
<mn>1</mn>
</mrow>
<mi mathvariant="normal">∞</mi>
</munderover>
<mrow>
<mi>n</mi>
<mo>⋅</mo>
<msubsup>
<mi>f</mi>
<mrow>
<mi>i</mi>
<mi>i</mi>
</mrow>
<mrow>
<mo stretchy="false">(</mo>
<mi>n</mi>
<mo stretchy="false">)</mo>
</mrow>
</msubsup>
</mrow>
</mrow>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<and></and>
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>M</ci>
<ci>i</ci>
</apply>
<apply>
<times></times>
<ci>E</ci>
<apply>
<csymbol cd="latexml">delimited-[]</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>T</ci>
<ci>i</ci>
</apply>
</apply>
</apply>
</apply>
<apply>
<eq></eq>
<share href="#.cmml">
</share>
<apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<sum></sum>
<apply>
<eq></eq>
<ci>n</ci>
<cn type="integer">1</cn>
</apply>
</apply>
<infinity></infinity>
</apply>
<apply>
<ci>normal-⋅</ci>
<ci>n</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>f</ci>
<apply>
<times></times>
<ci>i</ci>
<ci>i</ci>
</apply>
</apply>
<ci>n</ci>
</apply>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   M_{i}=E[T_{i}]=\sum_{n=1}^{\infty}n\cdot f_{ii}^{(n)}.\,
  </annotation>
</semantics>
</math>
</p>

<p>State <em>i</em> is <strong>positive recurrent</strong> (or <strong>non-null persistent</strong>) if <em>M<sub>i</sub></em> is finite; otherwise, state <em>i</em> is <strong>null recurrent</strong> (or <strong>null persistent</strong>).</p>
<h4 id="expected-number-of-visits">Expected number of visits</h4>

<p>It can be shown that a state <em>i</em> is recurrent <a href="if_and_only_if" title="wikilink">if and only if</a> the expected number of visits to this state is infinite, i.e.,</p>

<p>
<math display="block" id="Markov_chain:26">
<semantics>
<mrow>
<mrow>
<mrow>
<munderover>
<mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
<mrow>
<mi>n</mi>
<mo>=</mo>
<mn>0</mn>
</mrow>
<mi mathvariant="normal">∞</mi>
</munderover>
<msubsup>
<mi>p</mi>
<mrow>
<mi>i</mi>
<mi>i</mi>
</mrow>
<mrow>
<mo stretchy="false">(</mo>
<mi>n</mi>
<mo stretchy="false">)</mo>
</mrow>
</msubsup>
</mrow>
<mo>=</mo>
<mi mathvariant="normal">∞</mi>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<sum></sum>
<apply>
<eq></eq>
<ci>n</ci>
<cn type="integer">0</cn>
</apply>
</apply>
<infinity></infinity>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>p</ci>
<apply>
<times></times>
<ci>i</ci>
<ci>i</ci>
</apply>
</apply>
<ci>n</ci>
</apply>
</apply>
<infinity></infinity>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \sum_{n=0}^{\infty}p_{ii}^{(n)}=\infty.
  </annotation>
</semantics>
</math>
</p>
<h4 id="absorbing-states">Absorbing states</h4>

<p>A state <em>i</em> is called <strong>absorbing</strong> if it is impossible to leave this state. Therefore, the state <em>i</em> is absorbing if and only if</p>

<p>
<math display="block" id="Markov_chain:27">
<semantics>
<mrow>
<mrow>
<msub>
<mi>p</mi>
<mrow>
<mi>i</mi>
<mi>i</mi>
</mrow>
</msub>
<mo>=</mo>
<mrow>
<mn>1</mn>
<mtext>and</mtext>
<msub>
<mi>p</mi>
<mrow>
<mi>i</mi>
<mi>j</mi>
</mrow>
</msub>
</mrow>
<mo>=</mo>
<mrow>
<mn>0</mn>
<mtext>for</mtext>
<mi>i</mi>
</mrow>
<mo>≠</mo>
<mi>j</mi>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<and></and>
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>p</ci>
<apply>
<times></times>
<ci>i</ci>
<ci>i</ci>
</apply>
</apply>
<apply>
<times></times>
<cn type="integer">1</cn>
<mtext>and</mtext>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>p</ci>
<apply>
<times></times>
<ci>i</ci>
<ci>j</ci>
</apply>
</apply>
</apply>
</apply>
<apply>
<eq></eq>
<share href="#.cmml">
</share>
<apply>
<times></times>
<cn type="integer">0</cn>
<mtext>for</mtext>
<ci>i</ci>
</apply>
</apply>
<apply>
<neq></neq>
<share href="#.cmml">
</share>
<ci>j</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   p_{ii}=1\text{ and }p_{ij}=0\text{ for }i\not=j.
  </annotation>
</semantics>
</math>
</p>

<p>If every state can reach an absorbing state, then the Markov chain is an <a href="absorbing_Markov_chain" title="wikilink">absorbing Markov chain</a>.</p>
<h3 id="ergodicity">Ergodicity</h3>

<p>A state <em>i</em> is said to be <strong><a href="ergodic_theory" title="wikilink">ergodic</a></strong> if it is aperiodic and positive recurrent. In other words, a state <em>i</em> is ergodic if it is recurrent, has a period of <em>1</em> and it has finite mean recurrence time. If all states in an irreducible Markov chain are ergodic, then the chain is said to be ergodic.</p>

<p>It can be shown that a finite state irreducible Markov chain is ergodic if it has an aperiodic state. A model has the ergodic property if there's a finite number <em>N</em> such that any state can be reached from any other state in exactly <em>N</em> steps. In case of a fully connected transition matrix where all transitions have a non-zero probability, this condition is fulfilled with <em>N</em>=1. A model with more than one state and just one out-going transition per state cannot be ergodic.</p>
<h3 id="steady-state-analysis-and-limiting-distributions">Steady-state analysis and limiting distributions</h3>

<p>If the Markov chain is a <a href="time-homogeneous_Markov_chain" title="wikilink">time-homogeneous Markov chain</a>, so that the process is described by a single, <a href="time-independent_matrix" title="wikilink">time-independent matrix</a>
<math display="inline" id="Markov_chain:28">
<semantics>
<msub>
<mi>p</mi>
<mrow>
<mi>i</mi>
<mi>j</mi>
</mrow>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>p</ci>
<apply>
<times></times>
<ci>i</ci>
<ci>j</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   p_{ij}
  </annotation>
</semantics>
</math>

, then the vector 

<math display="inline" id="Markov_chain:29">
<semantics>
<mi>𝝅</mi>
<annotation-xml encoding="MathML-Content">
<ci>𝝅</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \boldsymbol{\pi}
  </annotation>
</semantics>
</math>

 is called a <strong>stationary distribution</strong> (or <strong><a href="invariant_measure" title="wikilink">invariant measure</a></strong>) if 

<math display="inline" id="Markov_chain:30">
<semantics>
<mrow>
<mrow>
<mo>∀</mo>
<mi>j</mi>
</mrow>
<mo>∈</mo>
<mi>S</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<in></in>
<apply>
<csymbol cd="latexml">for-all</csymbol>
<ci>j</ci>
</apply>
<ci>S</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \forall j\in S
  </annotation>
</semantics>
</math>

 it satisfies</p>

<p>
<math display="block" id="Markov_chain:31">
<semantics>
<mrow>
<mn>0</mn>
<mo>≤</mo>
<msub>
<mi>π</mi>
<mi>j</mi>
</msub>
<mo>≤</mo>
<mn>1.</mn>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<and></and>
<apply>
<leq></leq>
<cn type="integer">0</cn>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>π</ci>
<ci>j</ci>
</apply>
</apply>
<apply>
<leq></leq>
<share href="#.cmml">
</share>
<cn type="float">1.</cn>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   0\leq\pi_{j}\leq 1.
  </annotation>
</semantics>
</math>
</p>

<p>
<math display="block" id="Markov_chain:32">
<semantics>
<mrow>
<mrow>
<munder>
<mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
<mrow>
<mi>j</mi>
<mo>∈</mo>
<mi>S</mi>
</mrow>
</munder>
<msub>
<mi>π</mi>
<mi>j</mi>
</msub>
</mrow>
<mo>=</mo>
<mn>1.</mn>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<sum></sum>
<apply>
<in></in>
<ci>j</ci>
<ci>S</ci>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>π</ci>
<ci>j</ci>
</apply>
</apply>
<cn type="float">1.</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \sum_{j\in S}\pi_{j}=1.
  </annotation>
</semantics>
</math>
</p>

<p>
<math display="block" id="Markov_chain:33">
<semantics>
<mrow>
<mrow>
<msub>
<mi>π</mi>
<mi>j</mi>
</msub>
<mo>=</mo>
<mrow>
<munder>
<mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
<mrow>
<mi>i</mi>
<mo>∈</mo>
<mi>S</mi>
</mrow>
</munder>
<mrow>
<msub>
<mi>π</mi>
<mi>i</mi>
</msub>
<msub>
<mi>p</mi>
<mrow>
<mi>i</mi>
<mi>j</mi>
</mrow>
</msub>
</mrow>
</mrow>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>π</ci>
<ci>j</ci>
</apply>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<sum></sum>
<apply>
<in></in>
<ci>i</ci>
<ci>S</ci>
</apply>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>π</ci>
<ci>i</ci>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>p</ci>
<apply>
<times></times>
<ci>i</ci>
<ci>j</ci>
</apply>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \pi_{j}=\sum_{i\in S}\pi_{i}p_{ij}.
  </annotation>
</semantics>
</math>
</p>

<p>An irreducible chain has a stationary distribution if and only if all of its states are positive recurrent.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> In that case, <em>π</em> is unique and is related to the expected return time:</p>

<p>
<math display="block" id="Markov_chain:34">
<semantics>
<mrow>
<mrow>
<msub>
<mi>π</mi>
<mi>j</mi>
</msub>
<mo>=</mo>
<mpadded width="+1.7pt">
<mfrac>
<mi>C</mi>
<msub>
<mi>M</mi>
<mi>j</mi>
</msub>
</mfrac>
</mpadded>
</mrow>
<mo>,</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>π</ci>
<ci>j</ci>
</apply>
<apply>
<divide></divide>
<ci>C</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>M</ci>
<ci>j</ci>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \pi_{j}=\frac{C}{M_{j}}\,,
  </annotation>
</semantics>
</math>
</p>

<p>where 

<math display="inline" id="Markov_chain:35">
<semantics>
<mi>C</mi>
<annotation-xml encoding="MathML-Content">
<ci>C</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   C
  </annotation>
</semantics>
</math>

 is the normalizing constant. Further, if the positive recurrent chain is both irreducible and aperiodic, it is said to have a <em>limiting</em> distribution; for any <em>i</em> and <em>j</em>,</p>

<p>
<math display="block" id="Markov_chain:36">
<semantics>
<mrow>
<mrow>
<mrow>
<munder>
<mo movablelimits="false">lim</mo>
<mrow>
<mi>n</mi>
<mo>→</mo>
<mi mathvariant="normal">∞</mi>
</mrow>
</munder>
<msubsup>
<mi>p</mi>
<mrow>
<mi>i</mi>
<mi>j</mi>
</mrow>
<mrow>
<mo stretchy="false">(</mo>
<mi>n</mi>
<mo stretchy="false">)</mo>
</mrow>
</msubsup>
</mrow>
<mo>=</mo>
<mfrac>
<mi>C</mi>
<msub>
<mi>M</mi>
<mi>j</mi>
</msub>
</mfrac>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<limit></limit>
<apply>
<ci>normal-→</ci>
<ci>n</ci>
<infinity></infinity>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>p</ci>
<apply>
<times></times>
<ci>i</ci>
<ci>j</ci>
</apply>
</apply>
<ci>n</ci>
</apply>
</apply>
<apply>
<divide></divide>
<ci>C</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>M</ci>
<ci>j</ci>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \lim_{n\rightarrow\infty}p_{ij}^{(n)}=\frac{C}{M_{j}}.
  </annotation>
</semantics>
</math>
</p>

<p>Note that there is no assumption on the starting distribution; the chain converges to the stationary distribution regardless of where it begins. Such <em>
<math display="inline" id="Markov_chain:37">
<semantics>
<mi>π</mi>
<annotation-xml encoding="MathML-Content">
<ci>π</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \pi
  </annotation>
</semantics>
</math>
</em> is called the <strong>equilibrium distribution</strong> of the chain.</p>

<p>If a chain has more than one closed communicating class, its stationary distributions will not be unique (consider any <a href="#Reducibility" title="wikilink">closed communicating class</a>
<math display="inline" id="Markov_chain:38">
<semantics>
<msub>
<mi>C</mi>
<mi>i</mi>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>C</ci>
<ci>i</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   C_{i}
  </annotation>
</semantics>
</math>

 in the chain; each one will have its own unique stationary distribution 

<math display="inline" id="Markov_chain:39">
<semantics>
<msub>
<mi>π</mi>
<mi>i</mi>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>π</ci>
<ci>i</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \pi_{i}
  </annotation>
</semantics>
</math>

. Extending these distributions to the overall chain, setting all values to zero outside the communication class, yields that the set of invariant measures of the original chain is the set of all convex combinations of the 

<math display="inline" id="Markov_chain:40">
<semantics>
<msub>
<mi>π</mi>
<mi>i</mi>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>π</ci>
<ci>i</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \pi_{i}
  </annotation>
</semantics>
</math>

's). However, if a state <em>j</em> is aperiodic, then</p>

<p>
<math display="block" id="Markov_chain:41">
<semantics>
<mrow>
<mrow>
<munder>
<mo movablelimits="false">lim</mo>
<mrow>
<mi>n</mi>
<mo>→</mo>
<mi mathvariant="normal">∞</mi>
</mrow>
</munder>
<msubsup>
<mi>p</mi>
<mrow>
<mi>j</mi>
<mi>j</mi>
</mrow>
<mrow>
<mo stretchy="false">(</mo>
<mi>n</mi>
<mo stretchy="false">)</mo>
</mrow>
</msubsup>
</mrow>
<mo>=</mo>
<mfrac>
<mi>C</mi>
<msub>
<mi>M</mi>
<mi>j</mi>
</msub>
</mfrac>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<limit></limit>
<apply>
<ci>normal-→</ci>
<ci>n</ci>
<infinity></infinity>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>p</ci>
<apply>
<times></times>
<ci>j</ci>
<ci>j</ci>
</apply>
</apply>
<ci>n</ci>
</apply>
</apply>
<apply>
<divide></divide>
<ci>C</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>M</ci>
<ci>j</ci>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \lim_{n\rightarrow\infty}p_{jj}^{(n)}=\frac{C}{M_{j}}
  </annotation>
</semantics>
</math>
</p>

<p>and for any other state <em>i</em>, let <em>f<sub>ij</sub></em> be the probability that the chain ever visits state <em>j</em> if it starts at <em>i</em>,</p>

<p>
<math display="block" id="Markov_chain:42">
<semantics>
<mrow>
<mrow>
<mrow>
<munder>
<mo movablelimits="false">lim</mo>
<mrow>
<mi>n</mi>
<mo>→</mo>
<mi mathvariant="normal">∞</mi>
</mrow>
</munder>
<msubsup>
<mi>p</mi>
<mrow>
<mi>i</mi>
<mi>j</mi>
</mrow>
<mrow>
<mo stretchy="false">(</mo>
<mi>n</mi>
<mo stretchy="false">)</mo>
</mrow>
</msubsup>
</mrow>
<mo>=</mo>
<mrow>
<mi>C</mi>
<mfrac>
<msub>
<mi>f</mi>
<mrow>
<mi>i</mi>
<mi>j</mi>
</mrow>
</msub>
<msub>
<mi>M</mi>
<mi>j</mi>
</msub>
</mfrac>
</mrow>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<limit></limit>
<apply>
<ci>normal-→</ci>
<ci>n</ci>
<infinity></infinity>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>p</ci>
<apply>
<times></times>
<ci>i</ci>
<ci>j</ci>
</apply>
</apply>
<ci>n</ci>
</apply>
</apply>
<apply>
<times></times>
<ci>C</ci>
<apply>
<divide></divide>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>f</ci>
<apply>
<times></times>
<ci>i</ci>
<ci>j</ci>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>M</ci>
<ci>j</ci>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \lim_{n\rightarrow\infty}p_{ij}^{(n)}=C\frac{f_{ij}}{M_{j}}.
  </annotation>
</semantics>
</math>
</p>

<p>If a state <em>i</em> is periodic with period <em>k</em> &gt; 1 then the limit</p>

<p>
<math display="block" id="Markov_chain:43">
<semantics>
<mrow>
<munder>
<mo movablelimits="false">lim</mo>
<mrow>
<mi>n</mi>
<mo>→</mo>
<mi mathvariant="normal">∞</mi>
</mrow>
</munder>
<msubsup>
<mi>p</mi>
<mrow>
<mi>i</mi>
<mi>i</mi>
</mrow>
<mrow>
<mo stretchy="false">(</mo>
<mi>n</mi>
<mo stretchy="false">)</mo>
</mrow>
</msubsup>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<limit></limit>
<apply>
<ci>normal-→</ci>
<ci>n</ci>
<infinity></infinity>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>p</ci>
<apply>
<times></times>
<ci>i</ci>
<ci>i</ci>
</apply>
</apply>
<ci>n</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \lim_{n\rightarrow\infty}p_{ii}^{(n)}
  </annotation>
</semantics>
</math>
</p>

<p>does not exist, although the limit</p>

<p>
<math display="block" id="Markov_chain:44">
<semantics>
<mrow>
<munder>
<mo movablelimits="false">lim</mo>
<mrow>
<mi>n</mi>
<mo>→</mo>
<mi mathvariant="normal">∞</mi>
</mrow>
</munder>
<msubsup>
<mi>p</mi>
<mrow>
<mi>i</mi>
<mi>i</mi>
</mrow>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mrow>
<mi>k</mi>
<mi>n</mi>
</mrow>
<mo>+</mo>
<mi>r</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</msubsup>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<limit></limit>
<apply>
<ci>normal-→</ci>
<ci>n</ci>
<infinity></infinity>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>p</ci>
<apply>
<times></times>
<ci>i</ci>
<ci>i</ci>
</apply>
</apply>
<apply>
<plus></plus>
<apply>
<times></times>
<ci>k</ci>
<ci>n</ci>
</apply>
<ci>r</ci>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \lim_{n\rightarrow\infty}p_{ii}^{(kn+r)}
  </annotation>
</semantics>
</math>
</p>

<p>does exist for every integer <em>r</em>.</p>
<h4 id="steady-state-analysis-and-the-time-inhomogeneous-markov-chain">Steady-state analysis and the time-inhomogeneous Markov chain</h4>

<p>A Markov chain need not necessarily be time-homogeneous to have an equilibrium distribution. If there is a probability distribution over states 

<math display="inline" id="Markov_chain:45">
<semantics>
<mi>𝝅</mi>
<annotation-xml encoding="MathML-Content">
<ci>𝝅</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \boldsymbol{\pi}
  </annotation>
</semantics>
</math>

 such that</p>

<p>
<math display="block" id="Markov_chain:46">
<semantics>
<mrow>
<msub>
<mi>π</mi>
<mi>j</mi>
</msub>
<mo>=</mo>
<mrow>
<munder>
<mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
<mrow>
<mi>i</mi>
<mo>∈</mo>
<mi>S</mi>
</mrow>
</munder>
<mrow>
<mpadded width="+1.7pt">
<msub>
<mi>π</mi>
<mi>i</mi>
</msub>
</mpadded>
<mrow>
<mi>Pr</mi>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<msub>
<mi>X</mi>
<mrow>
<mi>n</mi>
<mo>+</mo>
<mn>1</mn>
</mrow>
</msub>
<mo>=</mo>
<mi>j</mi>
</mrow>
<mo>∣</mo>
<mrow>
<msub>
<mi>X</mi>
<mi>n</mi>
</msub>
<mo>=</mo>
<mi>i</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>π</ci>
<ci>j</ci>
</apply>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<sum></sum>
<apply>
<in></in>
<ci>i</ci>
<ci>S</ci>
</apply>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>π</ci>
<ci>i</ci>
</apply>
<apply>
<ci>Pr</ci>
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>X</ci>
<apply>
<plus></plus>
<ci>n</ci>
<cn type="integer">1</cn>
</apply>
</apply>
<ci>j</ci>
</apply>
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>X</ci>
<ci>n</ci>
</apply>
<ci>i</ci>
</apply>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \pi_{j}=\sum_{i\in S}\pi_{i}\,\Pr(X_{n+1}=j\mid X_{n}=i)
  </annotation>
</semantics>
</math>

 for every state <em>j</em> and every time <em>n</em> then 

<math display="inline" id="Markov_chain:47">
<semantics>
<mi>𝝅</mi>
<annotation-xml encoding="MathML-Content">
<ci>𝝅</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \boldsymbol{\pi}
  </annotation>
</semantics>
</math>

 is an equilibrium distribution of the Markov chain. Such can occur in <a href="Markov_chain_Monte_Carlo" title="wikilink">Markov chain Monte Carlo (MCMC)</a> methods in situations where a number of different transition matrices are used, because each is efficient for a particular kind of mixing, but each matrix respects a shared equilibrium distribution.</p>
<h2 id="finite-state-space">Finite state space</h2>

<p>If the state space is <a href="finite_set" title="wikilink">finite</a>, the transition probability distribution can be represented by a <a href="matrix_(mathematics)" title="wikilink">matrix</a>, called the <strong>transition matrix</strong>, with the (<em>i</em>, <em>j</em>)th <a href="Element_(mathematics)" title="wikilink">element</a> of <strong>P</strong> equal to</p>

<p>
<math display="block" id="Markov_chain:48">
<semantics>
<mrow>
<mrow>
<msub>
<mi>p</mi>
<mrow>
<mi>i</mi>
<mi>j</mi>
</mrow>
</msub>
<mo>=</mo>
<mrow>
<mi>Pr</mi>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<msub>
<mi>X</mi>
<mrow>
<mi>n</mi>
<mo>+</mo>
<mn>1</mn>
</mrow>
</msub>
<mo>=</mo>
<mi>j</mi>
</mrow>
<mo>∣</mo>
<mrow>
<msub>
<mi>X</mi>
<mi>n</mi>
</msub>
<mo>=</mo>
<mi>i</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>p</ci>
<apply>
<times></times>
<ci>i</ci>
<ci>j</ci>
</apply>
</apply>
<apply>
<ci>Pr</ci>
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>X</ci>
<apply>
<plus></plus>
<ci>n</ci>
<cn type="integer">1</cn>
</apply>
</apply>
<ci>j</ci>
</apply>
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>X</ci>
<ci>n</ci>
</apply>
<ci>i</ci>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   p_{ij}=\Pr(X_{n+1}=j\mid X_{n}=i).\,
  </annotation>
</semantics>
</math>
</p>

<p>Since each row of <strong>P</strong> sums to one and all elements are non-negative, <strong>P</strong> is a <a href="right_stochastic_matrix" title="wikilink">right stochastic matrix</a>.</p>
<h3 id="stationary-distribution-relation-to-eigenvectors-and-simplices">Stationary distribution relation to eigenvectors and simplices</h3>

<p>A stationary distribution <strong>π</strong> is a (row) vector, whose entries are non-negative and sum to 1, is unchanged by the operation of transition matrix <strong>P</strong> on it and so is defined by</p>

<p>
<math display="block" id="Markov_chain:49">
<semantics>
<mrow>
<mrow>
<mrow>
<mi>π</mi>
<mi>𝐏</mi>
</mrow>
<mo>=</mo>
<mi>π</mi>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<times></times>
<ci>π</ci>
<ci>𝐏</ci>
</apply>
<ci>π</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \pi\mathbf{P}=\pi.\,
  </annotation>
</semantics>
</math>
</p>

<p>By comparing this definition with that of an <a class="uri" href="eigenvector" title="wikilink">eigenvector</a> we see that the two concepts are related and that</p>

<p>
<math display="block" id="Markov_chain:50">
<semantics>
<mrow>
<mi>π</mi>
<mo>=</mo>
<mfrac>
<mi>e</mi>
<mrow>
<msub>
<mo largeop="true" symmetric="true">∑</mo>
<mi>i</mi>
</msub>
<msub>
<mi>e</mi>
<mi>i</mi>
</msub>
</mrow>
</mfrac>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<ci>π</ci>
<apply>
<divide></divide>
<ci>e</ci>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<sum></sum>
<ci>i</ci>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>e</ci>
<ci>i</ci>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \pi=\frac{e}{\sum_{i}{e_{i}}}
  </annotation>
</semantics>
</math>
</p>

<p>is a normalized (

<math display="inline" id="Markov_chain:51">
<semantics>
<mrow>
<mrow>
<msub>
<mo largeop="true" symmetric="true">∑</mo>
<mi>i</mi>
</msub>
<msub>
<mi>π</mi>
<mi>i</mi>
</msub>
</mrow>
<mo>=</mo>
<mn>1</mn>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<sum></sum>
<ci>i</ci>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>π</ci>
<ci>i</ci>
</apply>
</apply>
<cn type="integer">1</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \textstyle\sum_{i}\pi_{i}=1
  </annotation>
</semantics>
</math>

) multiple of a left eigenvector <strong>e</strong> of the transition matrix <strong>P</strong> with an <a class="uri" href="eigenvalue" title="wikilink">eigenvalue</a> of 1. If there is more than one unit eigenvector then a weighted sum of the corresponding stationary states is also a stationary state. But for a Markov chain one is usually more interested in a stationary state that is the limit of the sequence distributions for some initial distribution.</p>

<p>The values of stationary distribution 

<math display="inline" id="Markov_chain:52">
<semantics>
<msub>
<mi>π</mi>
<mi>i</mi>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>π</ci>
<ci>i</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \textstyle\pi_{i}
  </annotation>
</semantics>
</math>

 are associated with the state space of <strong>P</strong> and its eigenvectors have their relative proportions preserved. Since the components of <strong>π</strong> are positive and the constraint that their sum is unity can be rewritten as 

<math display="inline" id="Markov_chain:53">
<semantics>
<mrow>
<mrow>
<msub>
<mo largeop="true" symmetric="true">∑</mo>
<mi>i</mi>
</msub>
<mrow>
<mn>1</mn>
<mo>⋅</mo>
<msub>
<mi>π</mi>
<mi>i</mi>
</msub>
</mrow>
</mrow>
<mo>=</mo>
<mn>1</mn>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<sum></sum>
<ci>i</ci>
</apply>
<apply>
<ci>normal-⋅</ci>
<cn type="integer">1</cn>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>π</ci>
<ci>i</ci>
</apply>
</apply>
</apply>
<cn type="integer">1</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \textstyle\sum_{i}1\cdot\pi_{i}=1
  </annotation>
</semantics>
</math>

 we see that the dot product of <strong>π</strong> with a vector whose components are all 1 is unity and that <strong>π</strong> lies on a <a href="Simplex#The_standard_simplex" title="wikilink">simplex</a>.</p>
<h3 id="time-homogeneous-markov-chain-with-a-finite-state-space">Time-homogeneous Markov chain with a finite state space</h3>

<p>If the Markov chain is time-homogeneous, then the transition matrix <strong>P</strong> is the same after each step, so the <em>k</em>-step transition probability can be computed as the <em>k</em>-th power of the transition matrix, <strong>P</strong><sup><em>k</em></sup>.</p>

<p>If the Markov chain is irreducible and aperiodic, then there is a unique stationary distribution <strong>π</strong>. Additionally, in this case <strong>P</strong><sup><em>k</em></sup> converges to a rank-one matrix in which each row is the stationary distribution <strong>π</strong>, that is,</p>

<p>
<math display="block" id="Markov_chain:54">
<semantics>
<mrow>
<mrow>
<munder>
<mo movablelimits="false">lim</mo>
<mrow>
<mi>k</mi>
<mo>→</mo>
<mi mathvariant="normal">∞</mi>
</mrow>
</munder>
<msup>
<mi>𝐏</mi>
<mi>k</mi>
</msup>
</mrow>
<mo>=</mo>
<mrow>
<mn>𝟏</mn>
<mi>π</mi>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<limit></limit>
<apply>
<ci>normal-→</ci>
<ci>k</ci>
<infinity></infinity>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>𝐏</ci>
<ci>k</ci>
</apply>
</apply>
<apply>
<times></times>
<cn type="integer">1</cn>
<ci>π</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \lim_{k\rightarrow\infty}\mathbf{P}^{k}=\mathbf{1}\pi
  </annotation>
</semantics>
</math>
</p>

<p>where <strong>1</strong> is the column vector with all entries equal to 1. This is stated by the <a href="Perron–Frobenius_theorem" title="wikilink">Perron–Frobenius theorem</a>. If, by whatever means, 

<math display="inline" id="Markov_chain:55">
<semantics>
<mrow>
<msub>
<mo>lim</mo>
<mrow>
<mi>k</mi>
<mo>→</mo>
<mi mathvariant="normal">∞</mi>
</mrow>
</msub>
<msup>
<mi>𝐏</mi>
<mi>k</mi>
</msup>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<limit></limit>
<apply>
<ci>normal-→</ci>
<ci>k</ci>
<infinity></infinity>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>𝐏</ci>
<ci>k</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \scriptstyle\lim_{k\to\infty}\mathbf{P}^{k}
  </annotation>
</semantics>
</math>

 is found, then the stationary distribution of the Markov chain in question can be easily determined for any starting distribution, as will be explained below.</p>

<p>For some stochastic matrices <strong>P</strong>, the limit 

<math display="inline" id="Markov_chain:56">
<semantics>
<mrow>
<munder>
<mo movablelimits="false">lim</mo>
<mrow>
<mi>k</mi>
<mo>→</mo>
<mi mathvariant="normal">∞</mi>
</mrow>
</munder>
<msup>
<mi>𝐏</mi>
<mi>k</mi>
</msup>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<limit></limit>
<apply>
<ci>normal-→</ci>
<ci>k</ci>
<infinity></infinity>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>𝐏</ci>
<ci>k</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \scriptstyle\lim\limits_{k\to\infty}\mathbf{P}^{k}
  </annotation>
</semantics>
</math>

 does not exist while the stationary distribution does, as shown by this example:</p>

<p>
<math display="block" id="Markov_chain:57">
<semantics>
<mrow>
<mrow>
<mi>𝐏</mi>
<mo>=</mo>
<mrow>
<mo>(</mo>
<mtable displaystyle="true">
<mtr>
<mtd columnalign="center">
<mn>0</mn>
</mtd>
<mtd columnalign="center">
<mn>1</mn>
</mtd>
</mtr>
<mtr>
<mtd columnalign="center">
<mn>1</mn>
</mtd>
<mtd columnalign="center">
<mn>0</mn>
</mtd>
</mtr>
</mtable>
<mo>)</mo>
</mrow>
</mrow>
<mrow>
<mrow>
<msup>
<mi>𝐏</mi>
<mrow>
<mn>2</mn>
<mi>k</mi>
</mrow>
</msup>
<mo>=</mo>
<mi>I</mi>
</mrow>
<mrow>
<msup>
<mi>𝐏</mi>
<mrow>
<mrow>
<mn>2</mn>
<mi>k</mi>
</mrow>
<mo>+</mo>
<mn>1</mn>
</mrow>
</msup>
<mo>=</mo>
<mi>𝐏</mi>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">formulae-sequence</csymbol>
<apply>
<eq></eq>
<ci>𝐏</ci>
<matrix>
<matrixrow>
<cn type="integer">0</cn>
<cn type="integer">1</cn>
</matrixrow>
<matrixrow>
<cn type="integer">1</cn>
<cn type="integer">0</cn>
</matrixrow>
</matrix>
</apply>
<apply>
<csymbol cd="ambiguous">formulae-sequence</csymbol>
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>𝐏</ci>
<apply>
<times></times>
<cn type="integer">2</cn>
<ci>k</ci>
</apply>
</apply>
<ci>I</ci>
</apply>
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>𝐏</ci>
<apply>
<plus></plus>
<apply>
<times></times>
<cn type="integer">2</cn>
<ci>k</ci>
</apply>
<cn type="integer">1</cn>
</apply>
</apply>
<ci>𝐏</ci>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mathbf{P}=\begin{pmatrix}0&amp;1\\
1&amp;0\end{pmatrix}\qquad\mathbf{P}^{2k}=I\qquad\mathbf{P}^{2k+1}=\mathbf{P}
  </annotation>
</semantics>
</math>
</p>

<p>
<math display="block" id="Markov_chain:58">
<semantics>
<mrow>
<mrow>
<mrow>
<mo>(</mo>
<mtable displaystyle="true">
<mtr>
<mtd columnalign="center">
<mstyle displaystyle="false">
<mfrac>
<mn>1</mn>
<mn>2</mn>
</mfrac>
</mstyle>
</mtd>
<mtd columnalign="center">
<mstyle displaystyle="false">
<mfrac>
<mn>1</mn>
<mn>2</mn>
</mfrac>
</mstyle>
</mtd>
</mtr>
</mtable>
<mo>)</mo>
</mrow>
<mrow>
<mo>(</mo>
<mtable displaystyle="true">
<mtr>
<mtd columnalign="center">
<mn>0</mn>
</mtd>
<mtd columnalign="center">
<mn>1</mn>
</mtd>
</mtr>
<mtr>
<mtd columnalign="center">
<mn>1</mn>
</mtd>
<mtd columnalign="center">
<mn>0</mn>
</mtd>
</mtr>
</mtable>
<mo>)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<mo>(</mo>
<mtable displaystyle="true">
<mtr>
<mtd columnalign="center">
<mstyle displaystyle="false">
<mfrac>
<mn>1</mn>
<mn>2</mn>
</mfrac>
</mstyle>
</mtd>
<mtd columnalign="center">
<mstyle displaystyle="false">
<mfrac>
<mn>1</mn>
<mn>2</mn>
</mfrac>
</mstyle>
</mtd>
</mtr>
</mtable>
<mo>)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<times></times>
<matrix>
<matrixrow>
<apply>
<divide></divide>
<cn type="integer">1</cn>
<cn type="integer">2</cn>
</apply>
<apply>
<divide></divide>
<cn type="integer">1</cn>
<cn type="integer">2</cn>
</apply>
</matrixrow>
</matrix>
<matrix>
<matrixrow>
<cn type="integer">0</cn>
<cn type="integer">1</cn>
</matrixrow>
<matrixrow>
<cn type="integer">1</cn>
<cn type="integer">0</cn>
</matrixrow>
</matrix>
</apply>
<matrix>
<matrixrow>
<apply>
<divide></divide>
<cn type="integer">1</cn>
<cn type="integer">2</cn>
</apply>
<apply>
<divide></divide>
<cn type="integer">1</cn>
<cn type="integer">2</cn>
</apply>
</matrixrow>
</matrix>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \begin{pmatrix}\frac{1}{2}&amp;\frac{1}{2}\end{pmatrix}\begin{pmatrix}0&amp;1\\
1&amp;0\end{pmatrix}=\begin{pmatrix}\frac{1}{2}&amp;\frac{1}{2}\end{pmatrix}
  </annotation>
</semantics>
</math>
</p>

<p>Note that this example illustrates a periodic Markov chain.</p>

<p>Because there are a number of different special cases to consider, the process of finding this limit if it exists can be a lengthy task. However, there are many techniques that can assist in finding this limit. Let <strong>P</strong> be an <em>n</em>×<em>n</em> matrix, and define 

<math display="inline" id="Markov_chain:59">
<semantics>
<mrow>
<mrow>
<mi>𝐐</mi>
<mo>=</mo>
<mrow>
<msub>
<mo>lim</mo>
<mrow>
<mi>k</mi>
<mo>→</mo>
<mi mathvariant="normal">∞</mi>
</mrow>
</msub>
<msup>
<mi>𝐏</mi>
<mi>k</mi>
</msup>
</mrow>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<ci>𝐐</ci>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<limit></limit>
<apply>
<ci>normal-→</ci>
<ci>k</ci>
<infinity></infinity>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>𝐏</ci>
<ci>k</ci>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \scriptstyle\mathbf{Q}=\lim_{k\to\infty}\mathbf{P}^{k}.
  </annotation>
</semantics>
</math>
</p>

<p>It is always true that</p>

<p>
<math display="block" id="Markov_chain:60">
<semantics>
<mrow>
<mrow>
<mi>𝐐𝐏</mi>
<mo>=</mo>
<mi>𝐐</mi>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<ci>𝐐𝐏</ci>
<ci>𝐐</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mathbf{QP}=\mathbf{Q}.
  </annotation>
</semantics>
</math>
</p>

<p>Subtracting <strong>Q</strong> from both sides and factoring then yields</p>

<p>
<math display="block" id="Markov_chain:61">
<semantics>
<mrow>
<mrow>
<mrow>
<mi>𝐐</mi>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>𝐏</mi>
<mo>-</mo>
<msub>
<mi>𝐈</mi>
<mi>n</mi>
</msub>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<msub>
<mn>𝟎</mn>
<mrow>
<mi>n</mi>
<mo>,</mo>
<mi>n</mi>
</mrow>
</msub>
</mrow>
<mo>,</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<times></times>
<ci>𝐐</ci>
<apply>
<minus></minus>
<ci>𝐏</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>𝐈</ci>
<ci>n</ci>
</apply>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<cn type="integer">0</cn>
<list>
<ci>n</ci>
<ci>n</ci>
</list>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mathbf{Q}(\mathbf{P}-\mathbf{I}_{n})=\mathbf{0}_{n,n},
  </annotation>
</semantics>
</math>
</p>

<p>where <strong>I</strong><sub><em>n</em></sub> is the <a href="identity_matrix" title="wikilink">identity matrix</a> of size <em>n</em>, and <strong>0</strong><sub><em>n</em>,<em>n</em></sub> is the <a href="zero_matrix" title="wikilink">zero matrix</a> of size <em>n</em>×<em>n</em>. Multiplying together stochastic matrices always yields another stochastic matrix, so <strong>Q</strong> must be a <a href="stochastic_matrix" title="wikilink">stochastic matrix</a> (see the definition above). It is sometimes sufficient to use the matrix equation above and the fact that <strong>Q</strong> is a stochastic matrix to solve for <strong>Q</strong>. Including the fact that the sum of each the rows in <strong>P</strong> is 1, there are <em>n+1</em> equations for determining <em>n</em> unknowns, so it is computationally easier if on the one hand one selects one row in <strong>Q</strong> and substitute each of its elements by one, and on the other one substitute the corresponding element (the one in the same column) in the vector <strong>0</strong>, and next left-multiply this latter vector by the inverse of transformed former matrix to find <strong>Q</strong>.</p>

<p>Here is one method for doing so: first, define the function <em>f</em>(<strong>A</strong>) to return the matrix <strong>A</strong> with its right-most column replaced with all 1's. If [<em>f</em>(<strong>P</strong> − <strong>I</strong><sub>n</sub>)]<sup>−1</sup> exists then</p>

<p>
<math display="block" id="Markov_chain:62">
<semantics>
<mrow>
<mrow>
<mi>𝐐</mi>
<mo>=</mo>
<mrow>
<mi>f</mi>
<mrow>
<mo stretchy="false">(</mo>
<msub>
<mn>𝟎</mn>
<mrow>
<mi>n</mi>
<mo>,</mo>
<mi>n</mi>
</mrow>
</msub>
<mo stretchy="false">)</mo>
</mrow>
<msup>
<mrow>
<mo stretchy="false">[</mo>
<mrow>
<mi>f</mi>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>𝐏</mi>
<mo>-</mo>
<msub>
<mi>𝐈</mi>
<mi>n</mi>
</msub>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo stretchy="false">]</mo>
</mrow>
<mrow>
<mo>-</mo>
<mn>1</mn>
</mrow>
</msup>
</mrow>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<ci>𝐐</ci>
<apply>
<times></times>
<ci>f</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<cn type="integer">0</cn>
<list>
<ci>n</ci>
<ci>n</ci>
</list>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="latexml">delimited-[]</csymbol>
<apply>
<times></times>
<ci>f</ci>
<apply>
<minus></minus>
<ci>𝐏</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>𝐈</ci>
<ci>n</ci>
</apply>
</apply>
</apply>
</apply>
<apply>
<minus></minus>
<cn type="integer">1</cn>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mathbf{Q}=f(\mathbf{0}_{n,n})[f(\mathbf{P}-\mathbf{I}_{n})]^{-1}.
  </annotation>
</semantics>
</math>
</p>
<dl>
<dd>Explain: The original matrix equation is equivalent to a <a href="System_of_linear_equations" title="wikilink">system of n×n linear equations</a> in n×n variables. And there are n more linear equations from the fact that Q is a right <a href="stochastic_matrix" title="wikilink">stochastic matrix</a> whose each row sums to 1. So it needs any n×n independent linear equations of the (n×n+n) equations to solve for the n×n variables. In this example, the n equations from “Q multiplied by the right-most column of (P-In)” have been replaced by the n stochastic ones.
</dd>
</dl>

<p>One thing to notice is that if <strong>P</strong> has an element <strong>P</strong><sub><em>i</em>,<em>i</em></sub> on its main diagonal that is equal to 1 and the <em>i</em>th row or column is otherwise filled with 0's, then that row or column will remain unchanged in all of the subsequent powers <strong>P</strong><sup><em>k</em></sup>. Hence, the <em>i</em>th row or column of <strong>Q</strong> will have the 1 and the 0's in the same positions as in <strong>P</strong>.</p>
<h3 id="convergence-speed-to-the-stationary-distribution">Convergence speed to the stationary distribution</h3>

<p>As stated earlier, from the equation 

<math display="inline" id="Markov_chain:63">
<semantics>
<mrow>
<mi>π</mi>
<mo>=</mo>
<mrow>
<mi>π</mi>
<mi>𝐏</mi>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<ci>π</ci>
<apply>
<times></times>
<ci>π</ci>
<ci>𝐏</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mathbf{\pi}=\mathbf{\pi P}
  </annotation>
</semantics>
</math>

, (if exists) the stationary (or steady state) distribution <strong>π</strong> is a left eigenvector of row <a href="stochastic_matrix" title="wikilink">stochastic matrix</a> <strong>P</strong>. Then assuming that <strong>P</strong> is diagonalizable or equivalently that <strong>P</strong> has n linearly independent eigenvectors, speed of convergence is elaborated as follows. For non-diagonalizable matrices, one may start with "Jordan Canonical Form" (<em>almost</em> diagonal form) of <strong>P</strong> and proceed with a bit more involved set of arguments in a similar way.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></p>

<p>Let <strong>U</strong> be the matrix of eigenvectors (each normalized to having an L2 norm equal to 1) where each column is a left eigenvector of <strong>P</strong> and let <strong>Σ</strong> be the diagonal matrix of left eigenvalues of <strong>P</strong>, i.e. <strong>Σ</strong> = diag(<em>λ</em><sub>1</sub>,<em>λ</em><sub>2</sub>,<em>λ</em><sub>3</sub>,...,<em>λ</em><sub><em>n</em></sub>). Then by <a class="uri" href="eigendecomposition" title="wikilink">eigendecomposition</a></p>

<p>
<math display="block" id="Markov_chain:64">
<semantics>
<mrow>
<mrow>
<mi>𝐏</mi>
<mo>=</mo>
<mrow>
<mi>𝐔</mi>
<mi>𝚺</mi>
<msup>
<mi>𝐔</mi>
<mrow>
<mo>-</mo>
<mn>1</mn>
</mrow>
</msup>
</mrow>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<ci>𝐏</ci>
<apply>
<times></times>
<ci>𝐔</ci>
<ci>𝚺</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>𝐔</ci>
<apply>
<minus></minus>
<cn type="integer">1</cn>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mathbf{P}=\mathbf{U\Sigma U}^{-1}.
  </annotation>
</semantics>
</math>
</p>

<p>Let the eigenvalues be enumerated such that 1 = |<em>λ</em><sub>1</sub>| &gt; |<em>λ</em><sub>2</sub>| ≥ |<em>λ</em><sub>3</sub>| ≥ ... ≥ |<em>λ</em><sub><em>n</em></sub>|. Since <strong>P</strong> is a row stochastic matrix, its largest left eigenvalue is 1. If there is a unique stationary distribution, then the largest eigenvalue and the corresponding eigenvector is unique too (because there is no other <strong>π</strong> which solves the stationary distribution equation above). Let <strong>u</strong><sub><em>i</em></sub> be the <em>i</em>th column of <strong>U</strong> matrix, i.e. <strong>u</strong><sub><em>i</em></sub> is the left eigenvector of <strong>P</strong> corresponding to λ<sub><em>i</em></sub>. Also let <strong>x</strong> be a length n row vector that represents a valid probability distribution; since the eigenvectors <strong>u</strong><sub><em>i</em></sub> span <strong>R</strong><sup><em>n</em></sup>, we can write</p>

<p>
<math display="block" id="Markov_chain:65">
<semantics>
<mrow>
<msup>
<mi>𝐱</mi>
<mi>T</mi>
</msup>
<mo>=</mo>
<mrow>
<munderover>
<mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
<mrow>
<mi>i</mi>
<mo>=</mo>
<mn>1</mn>
</mrow>
<mi>n</mi>
</munderover>
<mrow>
<msub>
<mi>a</mi>
<mi>i</mi>
</msub>
<msub>
<mi>𝐮</mi>
<mi>i</mi>
</msub>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>𝐱</ci>
<ci>T</ci>
</apply>
<apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<sum></sum>
<apply>
<eq></eq>
<ci>i</ci>
<cn type="integer">1</cn>
</apply>
</apply>
<ci>n</ci>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>a</ci>
<ci>i</ci>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>𝐮</ci>
<ci>i</ci>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mathbf{x}^{T}=\sum_{i=1}^{n}a_{i}\mathbf{u}_{i}
  </annotation>
</semantics>
</math>
</p>

<p>for some set of <em>a</em><sub><em>i</em></sub>∈ℝ. If we start multiplying <strong>P</strong> with <strong>x</strong> from left and continue this operation with the results, in the end we get the stationary distribution <strong>π</strong>. In other words <strong>π</strong> = <strong>u</strong><sub><em>i</em></sub> ← <strong>xPPP</strong>...<strong>P</strong> = <strong>xP</strong><sup><em>k</em></sup> as <em>k</em> goes to infinity. That means</p>

<p>
<math display="block" id="Markov_chain:66">
<semantics>
<mrow>
<msup>
<mi>π</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>k</mi>
<mo stretchy="false">)</mo>
</mrow>
</msup>
<mo>=</mo>
<mrow>
<mi>𝐱</mi>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>𝐔</mi>
<mi>𝚺</mi>
<msup>
<mi>𝐔</mi>
<mrow>
<mo>-</mo>
<mn>1</mn>
</mrow>
</msup>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>𝐔</mi>
<mi>𝚺</mi>
<msup>
<mi>𝐔</mi>
<mrow>
<mo>-</mo>
<mn>1</mn>
</mrow>
</msup>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mi mathvariant="normal">⋯</mi>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>𝐔</mi>
<mi>𝚺</mi>
<msup>
<mi>𝐔</mi>
<mrow>
<mo>-</mo>
<mn>1</mn>
</mrow>
</msup>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>π</ci>
<ci>k</ci>
</apply>
<apply>
<times></times>
<ci>𝐱</ci>
<apply>
<times></times>
<ci>𝐔</ci>
<ci>𝚺</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>𝐔</ci>
<apply>
<minus></minus>
<cn type="integer">1</cn>
</apply>
</apply>
</apply>
<apply>
<times></times>
<ci>𝐔</ci>
<ci>𝚺</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>𝐔</ci>
<apply>
<minus></minus>
<cn type="integer">1</cn>
</apply>
</apply>
</apply>
<ci>normal-⋯</ci>
<apply>
<times></times>
<ci>𝐔</ci>
<ci>𝚺</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>𝐔</ci>
<apply>
<minus></minus>
<cn type="integer">1</cn>
</apply>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mathbf{\pi}^{(k)}=\mathbf{x}(\mathbf{U\Sigma U}^{-1})(\mathbf{U\Sigma U}^{-1}%
)\cdots(\mathbf{U\Sigma U}^{-1})
  </annotation>
</semantics>
</math>
</p>

<p>
<math display="block" id="Markov_chain:67">
<semantics>
<mrow>
<mi></mi>
<mo>=</mo>
<mrow>
<mi>𝐱𝐔</mi>
<msup>
<mi>𝚺</mi>
<mi>k</mi>
</msup>
<msup>
<mi>𝐔</mi>
<mrow>
<mo>-</mo>
<mn>1</mn>
</mrow>
</msup>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<csymbol cd="latexml">absent</csymbol>
<apply>
<times></times>
<ci>𝐱𝐔</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>𝚺</ci>
<ci>k</ci>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>𝐔</ci>
<apply>
<minus></minus>
<cn type="integer">1</cn>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   =\mathbf{xU\Sigma}^{k}\mathbf{U}^{-1}
  </annotation>
</semantics>
</math>

 since <strong>UU</strong><sup>−1</sup> = <strong>I</strong> the identity matrix and power of a diagonal matrix is also a diagonal matrix where each entry is taken to that power.</p>

<p>
<math display="block" id="Markov_chain:68">
<semantics>
<mrow>
<mrow>
<mi></mi>
<mo>=</mo>
<mrow>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mrow>
<msub>
<mi>a</mi>
<mn>1</mn>
</msub>
<msubsup>
<mi>𝐮</mi>
<mn>1</mn>
<mi>T</mi>
</msubsup>
</mrow>
<mo>+</mo>
<mrow>
<msub>
<mi>a</mi>
<mn>2</mn>
</msub>
<msubsup>
<mi>𝐮</mi>
<mn>2</mn>
<mi>T</mi>
</msubsup>
</mrow>
<mo>+</mo>
<mi mathvariant="normal">⋯</mi>
<mo>+</mo>
<mrow>
<msub>
<mi>a</mi>
<mi>n</mi>
</msub>
<msubsup>
<mi>𝐮</mi>
<mi>n</mi>
<mi>T</mi>
</msubsup>
</mrow>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mi>𝐔</mi>
<msup>
<mi>𝚺</mi>
<mi>k</mi>
</msup>
<msup>
<mi>𝐔</mi>
<mrow>
<mo>-</mo>
<mn>1</mn>
</mrow>
</msup>
</mrow>
</mrow>
<mo>,</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<csymbol cd="latexml">absent</csymbol>
<apply>
<times></times>
<apply>
<plus></plus>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>a</ci>
<cn type="integer">1</cn>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>𝐮</ci>
<cn type="integer">1</cn>
</apply>
<ci>T</ci>
</apply>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>a</ci>
<cn type="integer">2</cn>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>𝐮</ci>
<cn type="integer">2</cn>
</apply>
<ci>T</ci>
</apply>
</apply>
<ci>normal-⋯</ci>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>a</ci>
<ci>n</ci>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>𝐮</ci>
<ci>n</ci>
</apply>
<ci>T</ci>
</apply>
</apply>
</apply>
<ci>𝐔</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>𝚺</ci>
<ci>k</ci>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>𝐔</ci>
<apply>
<minus></minus>
<cn type="integer">1</cn>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   =(a_{1}\mathbf{u}_{1}^{T}+a_{2}\mathbf{u}_{2}^{T}+\cdots+a_{n}\mathbf{u}_{n}^{%
T})\mathbf{U\Sigma}^{k}\mathbf{U}^{-1},
  </annotation>
</semantics>
</math>
</p>

<p>
<math display="block" id="Markov_chain:69">
<semantics>
<mrow>
<mrow>
<mi></mi>
<mo>=</mo>
<mrow>
<mrow>
<msub>
<mi>a</mi>
<mn>1</mn>
</msub>
<msubsup>
<mi>λ</mi>
<mn>1</mn>
<mi>k</mi>
</msubsup>
<msub>
<mi>𝐮</mi>
<mn>1</mn>
</msub>
</mrow>
<mo>+</mo>
<mrow>
<msub>
<mi>a</mi>
<mn>2</mn>
</msub>
<msubsup>
<mi>λ</mi>
<mn>2</mn>
<mi>k</mi>
</msubsup>
<msub>
<mi>𝐮</mi>
<mn>2</mn>
</msub>
</mrow>
<mo>+</mo>
<mi mathvariant="normal">⋯</mi>
<mo>+</mo>
<mrow>
<msub>
<mi>a</mi>
<mi>n</mi>
</msub>
<msubsup>
<mi>λ</mi>
<mi>n</mi>
<mi>k</mi>
</msubsup>
<msub>
<mi>𝐮</mi>
<mi>n</mi>
</msub>
</mrow>
</mrow>
</mrow>
<mo>,</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<csymbol cd="latexml">absent</csymbol>
<apply>
<plus></plus>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>a</ci>
<cn type="integer">1</cn>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>λ</ci>
<cn type="integer">1</cn>
</apply>
<ci>k</ci>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>𝐮</ci>
<cn type="integer">1</cn>
</apply>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>a</ci>
<cn type="integer">2</cn>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>λ</ci>
<cn type="integer">2</cn>
</apply>
<ci>k</ci>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>𝐮</ci>
<cn type="integer">2</cn>
</apply>
</apply>
<ci>normal-⋯</ci>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>a</ci>
<ci>n</ci>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>λ</ci>
<ci>n</ci>
</apply>
<ci>k</ci>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>𝐮</ci>
<ci>n</ci>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   =a_{1}\lambda_{1}^{k}\mathbf{u}_{1}+a_{2}\lambda_{2}^{k}\mathbf{u}_{2}+\cdots+%
a_{n}\lambda_{n}^{k}\mathbf{u}_{n},
  </annotation>
</semantics>
</math>

 since the eigenvectors are <a class="uri" href="orthonormal" title="wikilink">orthonormal</a>. Then<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a></p>

<p>
<math display="block" id="Markov_chain:70">
<semantics>
<mrow>
<mrow>
<mi></mi>
<mo>=</mo>
<mrow>
<msubsup>
<mi>λ</mi>
<mn>1</mn>
<mi>k</mi>
</msubsup>
<mrow>
<mo>{</mo>
<mrow>
<mrow>
<msub>
<mi>a</mi>
<mn>1</mn>
</msub>
<msub>
<mi>𝐮</mi>
<mn>1</mn>
</msub>
</mrow>
<mo>+</mo>
<mrow>
<msub>
<mi>a</mi>
<mn>2</mn>
</msub>
<msup>
<mrow>
<mo>(</mo>
<mfrac>
<msub>
<mi>λ</mi>
<mn>2</mn>
</msub>
<msub>
<mi>λ</mi>
<mn>1</mn>
</msub>
</mfrac>
<mo>)</mo>
</mrow>
<mi>k</mi>
</msup>
<msub>
<mi>𝐮</mi>
<mn>2</mn>
</msub>
</mrow>
<mo>+</mo>
<mrow>
<msub>
<mi>a</mi>
<mn>3</mn>
</msub>
<msup>
<mrow>
<mo>(</mo>
<mfrac>
<msub>
<mi>λ</mi>
<mn>3</mn>
</msub>
<msub>
<mi>λ</mi>
<mn>1</mn>
</msub>
</mfrac>
<mo>)</mo>
</mrow>
<mi>k</mi>
</msup>
<msub>
<mi>𝐮</mi>
<mn>3</mn>
</msub>
</mrow>
<mo>+</mo>
<mi mathvariant="normal">⋯</mi>
<mo>+</mo>
<mrow>
<msub>
<mi>a</mi>
<mi>n</mi>
</msub>
<msup>
<mrow>
<mo>(</mo>
<mfrac>
<msub>
<mi>λ</mi>
<mi>n</mi>
</msub>
<msub>
<mi>λ</mi>
<mn>1</mn>
</msub>
</mfrac>
<mo>)</mo>
</mrow>
<mi>k</mi>
</msup>
<msub>
<mi>𝐮</mi>
<mi>n</mi>
</msub>
</mrow>
</mrow>
<mo>}</mo>
</mrow>
</mrow>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<csymbol cd="latexml">absent</csymbol>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>λ</ci>
<cn type="integer">1</cn>
</apply>
<ci>k</ci>
</apply>
<set>
<apply>
<plus></plus>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>a</ci>
<cn type="integer">1</cn>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>𝐮</ci>
<cn type="integer">1</cn>
</apply>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>a</ci>
<cn type="integer">2</cn>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<divide></divide>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>λ</ci>
<cn type="integer">2</cn>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>λ</ci>
<cn type="integer">1</cn>
</apply>
</apply>
<ci>k</ci>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>𝐮</ci>
<cn type="integer">2</cn>
</apply>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>a</ci>
<cn type="integer">3</cn>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<divide></divide>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>λ</ci>
<cn type="integer">3</cn>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>λ</ci>
<cn type="integer">1</cn>
</apply>
</apply>
<ci>k</ci>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>𝐮</ci>
<cn type="integer">3</cn>
</apply>
</apply>
<ci>normal-⋯</ci>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>a</ci>
<ci>n</ci>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<divide></divide>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>λ</ci>
<ci>n</ci>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>λ</ci>
<cn type="integer">1</cn>
</apply>
</apply>
<ci>k</ci>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>𝐮</ci>
<ci>n</ci>
</apply>
</apply>
</apply>
</set>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   =\lambda_{1}^{k}\left\{a_{1}\mathbf{u}_{1}+a_{2}\left(\frac{\lambda_{2}}{%
\lambda_{1}}\right)^{k}\mathbf{u}_{2}+a_{3}\left(\frac{\lambda_{3}}{\lambda_{1%
}}\right)^{k}\mathbf{u}_{3}+\cdots+a_{n}\left(\frac{\lambda_{n}}{\lambda_{1}}%
\right)^{k}\mathbf{u}_{n}\right\}.
  </annotation>
</semantics>
</math>
</p>

<p>Since <strong>π</strong> = <strong>u</strong><sub>1</sub>, <strong>π</strong><sup>(<em>k</em>)</sup> approaches to <strong>π</strong> as <em>k</em> goes to infinity with a speed in the order of <em>λ</em><sub>2</sub>/<em>λ</em><sub>1</sub> exponentially. This follows because |<em>λ</em><sub>2</sub>| ≥ |<em>λ</em><sub>3</sub>| ≥ ... ≥ |<em>λ</em><sub><em>n</em></sub>|, hence <em>λ</em><sub>2</sub>/<em>λ</em><sub>1</sub> is the dominant term. Random noise in the state distribution <strong>π</strong> can also speed up this convergence to the stationary distribution.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a></p>
<h2 id="reversible-markov-chain">Reversible Markov chain</h2>

<p>A Markov chain is said to be <strong>reversible</strong> if there is a probability distribution over states, <strong>π</strong>, such that</p>

<p>
<math display="block" id="Markov_chain:71">
<semantics>
<mrow>
<mrow>
<msub>
<mi>π</mi>
<mi>i</mi>
</msub>
<mrow>
<mi>Pr</mi>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<msub>
<mi>X</mi>
<mrow>
<mi>n</mi>
<mo>+</mo>
<mn>1</mn>
</mrow>
</msub>
<mo>=</mo>
<mi>j</mi>
</mrow>
<mo>∣</mo>
<mrow>
<msub>
<mi>X</mi>
<mi>n</mi>
</msub>
<mo>=</mo>
<mi>i</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<msub>
<mi>π</mi>
<mi>j</mi>
</msub>
<mrow>
<mi>Pr</mi>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<msub>
<mi>X</mi>
<mrow>
<mi>n</mi>
<mo>+</mo>
<mn>1</mn>
</mrow>
</msub>
<mo>=</mo>
<mi>i</mi>
</mrow>
<mo>∣</mo>
<mrow>
<msub>
<mi>X</mi>
<mi>n</mi>
</msub>
<mo>=</mo>
<mi>j</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>π</ci>
<ci>i</ci>
</apply>
<apply>
<ci>Pr</ci>
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>X</ci>
<apply>
<plus></plus>
<ci>n</ci>
<cn type="integer">1</cn>
</apply>
</apply>
<ci>j</ci>
</apply>
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>X</ci>
<ci>n</ci>
</apply>
<ci>i</ci>
</apply>
</apply>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>π</ci>
<ci>j</ci>
</apply>
<apply>
<ci>Pr</ci>
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>X</ci>
<apply>
<plus></plus>
<ci>n</ci>
<cn type="integer">1</cn>
</apply>
</apply>
<ci>i</ci>
</apply>
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>X</ci>
<ci>n</ci>
</apply>
<ci>j</ci>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \pi_{i}\Pr(X_{n+1}=j\mid X_{n}=i)=\pi_{j}\Pr(X_{n+1}=i\mid X_{n}=j)
  </annotation>
</semantics>
</math>

 for all times <em>n</em> and all states <em>i</em> and <em>j</em>. This condition is also known as the <strong><a href="detailed_balance" title="wikilink">detailed balance</a></strong> condition (some books refer the local balance equation). With a time-homogeneous Markov chain, Pr(<em>X</em><sub><em>n</em>+1</sub> = <em>j</em> | <em>X</em><sub><em>n</em></sub> = <em>i</em>) does not change with time <em>n</em> and it can be written more simply as 

<math display="inline" id="Markov_chain:72">
<semantics>
<msub>
<mi>p</mi>
<mrow>
<mi>i</mi>
<mi>j</mi>
</mrow>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>p</ci>
<apply>
<times></times>
<ci>i</ci>
<ci>j</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   p_{ij}
  </annotation>
</semantics>
</math>

. In this case, the detailed balance equation can be written more compactly as</p>

<p>
<math display="block" id="Markov_chain:73">
<semantics>
<mrow>
<mrow>
<mrow>
<msub>
<mi>π</mi>
<mi>i</mi>
</msub>
<msub>
<mi>p</mi>
<mrow>
<mi>i</mi>
<mi>j</mi>
</mrow>
</msub>
</mrow>
<mo>=</mo>
<mrow>
<msub>
<mi>π</mi>
<mi>j</mi>
</msub>
<mpadded width="+1.7pt">
<msub>
<mi>p</mi>
<mrow>
<mi>j</mi>
<mi>i</mi>
</mrow>
</msub>
</mpadded>
</mrow>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>π</ci>
<ci>i</ci>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>p</ci>
<apply>
<times></times>
<ci>i</ci>
<ci>j</ci>
</apply>
</apply>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>π</ci>
<ci>j</ci>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>p</ci>
<apply>
<times></times>
<ci>j</ci>
<ci>i</ci>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \pi_{i}p_{ij}=\pi_{j}p_{ji}\,.
  </annotation>
</semantics>
</math>
</p>

<p>Summing the original equation over <em>i</em> gives</p>

<p>
<math display="inline" id="Markov_chain:74">
<semantics>
<mrow>
<mstyle displaystyle="true">
<munder>
<mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
<mi>i</mi>
</munder>
</mstyle>
<mrow>
<msub>
<mi>π</mi>
<mi>i</mi>
</msub>
<mrow>
<mi>Pr</mi>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<msub>
<mi>X</mi>
<mrow>
<mi>n</mi>
<mo>+</mo>
<mn>1</mn>
</mrow>
</msub>
<mo>=</mo>
<mi>j</mi>
</mrow>
<mo>∣</mo>
<mrow>
<msub>
<mi>X</mi>
<mi>n</mi>
</msub>
<mo>=</mo>
<mi>i</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<sum></sum>
<ci>i</ci>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>π</ci>
<ci>i</ci>
</apply>
<apply>
<ci>Pr</ci>
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>X</ci>
<apply>
<plus></plus>
<ci>n</ci>
<cn type="integer">1</cn>
</apply>
</apply>
<ci>j</ci>
</apply>
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>X</ci>
<ci>n</ci>
</apply>
<ci>i</ci>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \displaystyle\sum_{i}\pi_{i}\Pr(X_{n+1}=j\mid X_{n}=i)
  </annotation>
</semantics>
</math>


 so, for reversible Markov chains, <strong>π</strong> is always a steady-state distribution of Pr(<em>X</em><sub>n+1</sub> = <em>j</em> | <em>X</em><sub>n</sub> = <em>i</em>) for every <em>n</em>.</p>

<p>If the Markov chain begins in the steady-state distribution, <em>i.e.</em>, if Pr(<em>X</em><sub>0</sub> = <em>i</em>) = π<sub><em>i</em></sub>, then Pr(<em>X</em><sub><em>n</em></sub> = <em>i</em>) = π<sub><em>i</em></sub> for all <em>n</em> and the detailed balance equation can be written as</p>

<p>
<math display="block" id="Markov_chain:75">
<semantics>
<mrow>
<mrow>
<mrow>
<mi>Pr</mi>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<msub>
<mi>X</mi>
<mi>n</mi>
</msub>
<mo>=</mo>
<mi>i</mi>
</mrow>
<mo>,</mo>
<mrow>
<msub>
<mi>X</mi>
<mrow>
<mi>n</mi>
<mo>+</mo>
<mn>1</mn>
</mrow>
</msub>
<mo>=</mo>
<mi>j</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<mi>Pr</mi>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<msub>
<mi>X</mi>
<mrow>
<mi>n</mi>
<mo>+</mo>
<mn>1</mn>
</mrow>
</msub>
<mo>=</mo>
<mi>i</mi>
</mrow>
<mo>,</mo>
<mrow>
<msub>
<mi>X</mi>
<mi>n</mi>
</msub>
<mo>=</mo>
<mi>j</mi>
</mrow>
<mo rspace="4.2pt" stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<ci>Pr</ci>
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>X</ci>
<ci>n</ci>
</apply>
<ci>i</ci>
</apply>
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>X</ci>
<apply>
<plus></plus>
<ci>n</ci>
<cn type="integer">1</cn>
</apply>
</apply>
<ci>j</ci>
</apply>
</apply>
<apply>
<ci>Pr</ci>
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>X</ci>
<apply>
<plus></plus>
<ci>n</ci>
<cn type="integer">1</cn>
</apply>
</apply>
<ci>i</ci>
</apply>
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>X</ci>
<ci>n</ci>
</apply>
<ci>j</ci>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \Pr(X_{n}=i,X_{n+1}=j)=\Pr(X_{n+1}=i,X_{n}=j)\,.
  </annotation>
</semantics>
</math>
</p>

<p>The left- and right-hand sides of this last equation are identical except for a reversing of the time indices <em>n</em> and <em>n</em> + 1.</p>

<p><a href="Kolmogorov's_criterion" title="wikilink">Kolmogorov's criterion</a> gives a necessary and sufficient condition for a Markov chain to be reversible directly from the transition matrix probabilities. The criterion requires that the products of probabilities around every closed loop are the same in both directions around the loop.</p>

<p>Reversible Markov chains are common in <a href="Markov_chain_Monte_Carlo" title="wikilink">Markov chain Monte Carlo (MCMC)</a> approaches because the detailed balance equation for a desired distribution <strong>π</strong> necessarily implies that the Markov chain has been constructed so that <strong>π</strong> is a steady-state distribution. Even with time-inhomogeneous Markov chains, where multiple transition matrices are used, if each such transition matrix exhibits detailed balance with the desired <strong>π</strong> distribution, this necessarily implies that <strong>π</strong> is a steady-state distribution of the Markov chain.</p>
<h2 id="bernoulli-scheme">Bernoulli scheme</h2>

<p>A <a href="Bernoulli_scheme" title="wikilink">Bernoulli scheme</a> is a special case of a Markov chain where the transition probability matrix has identical rows, which means that the next state is even independent of the current state (in addition to being independent of the past states). A Bernoulli scheme with only two possible states is known as a <a href="Bernoulli_process" title="wikilink">Bernoulli process</a>.</p>
<h2 id="general-state-space">General state space</h2>

<p>Many results for Markov chains with finite state space can be generalized to chains with uncountable state space through <a href="Harris_chain" title="wikilink">Harris chains</a>. The main idea is to see if there is a point in the state space that the chain hits with probability one. Generally, it is not true for continuous state space, however, we can define sets <em>A</em> and <em>B</em> along with a positive number <em>ε</em> and a probability measure <em>ρ</em>, such that</p>
<ol>
<li>
<math display="inline" id="Markov_chain:76">
<semantics>
<mrow>
<mtext>If</mtext>
<msub>
<mi>τ</mi>
<mi>A</mi>
</msub>
<mo>=</mo>
<mo>inf</mo>
<mrow>
<mo stretchy="false">{</mo>
<mi>n</mi>
<mo>≥</mo>
<mn>0</mn>
<mo>:</mo>
<msub>
<mi>X</mi>
<mi>n</mi>
</msub>
<mo>∈</mo>
<mi>A</mi>
<mo stretchy="false">}</mo>
</mrow>
<mo>,</mo>
<mtext>then</mtext>
<msub>
<mi>P</mi>
<mi>z</mi>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<msub>
<mi>τ</mi>
<mi>A</mi>
</msub>
<mo>&lt;</mo>
<mi mathvariant="normal">∞</mi>
<mo stretchy="false">)</mo>
</mrow>
<mo>&gt;</mo>
<mn>0</mn>
<mtext>for all</mtext>
<mi>z</mi>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<mtext>If</mtext>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>τ</ci>
<ci>A</ci>
</apply>
<eq></eq>
<csymbol cd="latexml">infimum</csymbol>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-{</ci>
<csymbol cd="unknown">n</csymbol>
<geq></geq>
<cn type="integer">0</cn>
<ci>normal-:</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>X</ci>
<ci>n</ci>
</apply>
<in></in>
<csymbol cd="unknown">A</csymbol>
<ci>normal-}</ci>
</cerror>
<ci>normal-,</ci>
<mtext>then</mtext>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>P</ci>
<ci>z</ci>
</apply>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>τ</ci>
<ci>A</ci>
</apply>
<lt></lt>
<infinity></infinity>
<ci>normal-)</ci>
</cerror>
<gt></gt>
<cn type="integer">0</cn>
<mtext>for all</mtext>
<csymbol cd="unknown">z</csymbol>
<ci>normal-.</ci>
</cerror>
</annotation-xml>
<annotation encoding="application/x-tex">
   \text{If }\tau_{A}=\inf\{n\geq 0:X_{n}\in A\},\text{ then }P_{z}(\tau_{A}&lt;%
\infty)&gt;0\text{ for all }z.
  </annotation>
</semantics>
</math>
</li>
<li>
<math display="inline" id="Markov_chain:77">
<semantics>
<mrow>
<mrow>
<mrow>
<mrow>
<mtext>If</mtext>
<mi>x</mi>
</mrow>
<mo>∈</mo>
<mrow>
<mi>A</mi>
<mtext>and</mtext>
<mi>C</mi>
</mrow>
<mo>⊂</mo>
<mi>B</mi>
</mrow>
<mo>,</mo>
<mrow>
<mrow>
<mtext>then</mtext>
<mi>p</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>x</mi>
<mo>,</mo>
<mi>C</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>≥</mo>
<mrow>
<mi>ε</mi>
<mi>ρ</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>C</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">formulae-sequence</csymbol>
<apply>
<and></and>
<apply>
<in></in>
<apply>
<times></times>
<mtext>If</mtext>
<ci>x</ci>
</apply>
<apply>
<times></times>
<ci>A</ci>
<mtext>and</mtext>
<ci>C</ci>
</apply>
</apply>
<apply>
<subset></subset>
<share href="#.cmml">
</share>
<ci>B</ci>
</apply>
</apply>
<apply>
<geq></geq>
<apply>
<times></times>
<mtext>then</mtext>
<ci>p</ci>
<interval closure="open">
<ci>x</ci>
<ci>C</ci>
</interval>
</apply>
<apply>
<times></times>
<ci>ε</ci>
<ci>ρ</ci>
<ci>C</ci>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \text{If }x\in A\text{ and }C\subset B,\text{ then }p(x,C)\geq\varepsilon\rho(%
C).
  </annotation>
</semantics>
</math>
</li>
</ol>

<p>Then we could collapse the sets into an auxiliary point <em>α</em>, and a recurrent <a href="Harris_chain" title="wikilink">Harris chain</a> can be modified to contain <em>α</em>. Lastly, the collection of <a href="Harris_chain" title="wikilink">Harris chains</a> is a comfortable level of generality, which is broad enough to contain a large number of interesting examples, yet restrictive enough to allow for a rich theory.</p>

<p>The use of Markov chains in <a href="Markov_chain_Monte_Carlo" title="wikilink">Markov chain Monte Carlo</a> methods covers cases where the process follows a continuous state space.</p>
<h3 id="locally-interacting-markov-chains">Locally interacting Markov chains</h3>

<p>Considering a collection of Markov chains whose evolution takes in account the state of other Markov chains, is related to the notion of <a href="locally_interacting_Markov_chains" title="wikilink">locally interacting Markov chains</a>. This corresponds to the situation when the state space has a (Cartesian-) product form. See <a href="interacting_particle_system" title="wikilink">interacting particle system</a> and <a href="stochastic_cellular_automata" title="wikilink">stochastic cellular automata</a>. See for instance <em>Interaction of Markov Processes</em><a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> or<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a></p>
<h2 id="applications">Applications</h2>

<p>Research has reported the application and usefulness of Markov chains in a wide range of topics such as physics, chemistry, medicine, music, game theory and sports.</p>
<h3 id="physics">Physics</h3>

<p>Markovian systems appear extensively in <a class="uri" href="thermodynamics" title="wikilink">thermodynamics</a> and <a href="statistical_mechanics" title="wikilink">statistical mechanics</a>, whenever probabilities are used to represent unknown or unmodelled details of the system, if it can be assumed that the dynamics are time-invariant, and that no relevant history need be considered which is not already included in the state description.</p>
<h3 id="chemistry">Chemistry</h3>

<p> Markov chains and continuous-time Markov processes are useful in chemistry when physical systems closely approximate the Markov property. The classical model of enzyme activity, <a href="Michaelis–Menten_kinetics" title="wikilink">Michaelis–Menten kinetics</a>, can be viewed as a Markov chain, where at each time step the reaction proceeds in some direction. While Michaelis-Menten is fairly straightforward, far more complicated reaction networks can also be modeled with Markov chains.</p>

<p>An algorithm based on a Markov chain was also used to focus the fragment-based growth of chemicals <a href="in_silico" title="wikilink">in silico</a> towards a desired class of compounds such as drugs or natural products.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a> As a molecule is grown, a fragment is selected from the nascent molecule as the "current" state. It is not aware of its past (i.e., it is not aware of what is already bonded to it). It then transitions to the next state when a fragment is attached to it. The transition probabilities are trained on databases of authentic classes of compounds.</p>

<p>Also, the growth (and composition) of <a href="copolymer" title="wikilink">copolymers</a> may be modeled using Markov chains. Based on the reactivity ratios of the monomers that make up the growing polymer chain, the chain's composition may be calculated (e.g., whether monomers tend to add in alternating fashion or in long runs of the same monomer). Due to <a href="steric_effects" title="wikilink">steric effects</a>, second-order Markov effects may also play a role in the growth of some polymer chains.</p>

<p>Similarly, it has been suggested that the crystallization and growth of some epitaxial <a class="uri" href="superlattice" title="wikilink">superlattice</a> oxide materials can be accurately described by Markov chains.<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a></p>
<h3 id="testing">Testing</h3>

<p>Several theorists have proposed the idea of the Markov chain statistical test (MCST), a method of conjoining Markov chains to form a "<a href="Markov_blanket" title="wikilink">Markov blanket</a>", arranging these chains in several recursive layers ("wafering") and producing more efficient test sets—samples—as a replacement for exhaustive testing. MCSTs also have uses in temporal state-based networks; Chilukuri et al.'s paper entitled "Temporal Uncertainty Reasoning Networks for Evidence Fusion with Applications to Object Detection and Tracking" (ScienceDirect) gives a background and case study for applying MCSTs to a wider range of applications.</p>
<h3 id="speech-recognition">Speech Recognition</h3>

<p><a href="Hidden_Markov_models" title="wikilink">Hidden Markov models</a> are the basis for most modern <a href="Speech_recognition#Algorithms" title="wikilink">automatic speech recognition</a> systems.</p>
<h3 id="information-sciences">Information sciences</h3>

<p>Markov chains are used throughout information processing. <a href="Claude_Shannon" title="wikilink">Claude Shannon's</a> famous 1948 paper <em><a href="A_Mathematical_Theory_of_Communication" title="wikilink">A Mathematical Theory of Communication</a></em>, which in a single step created the field of <a href="information_theory" title="wikilink">information theory</a>, opens by introducing the concept of <a href="information_entropy" title="wikilink">entropy</a> through Markov modeling of the English language. Such idealized models can capture many of the statistical regularities of systems. Even without describing the full structure of the system perfectly, such signal models can make possible very effective <a href="data_compression" title="wikilink">data compression</a> through <a href="entropy_encoding" title="wikilink">entropy encoding</a> techniques such as <a href="arithmetic_coding" title="wikilink">arithmetic coding</a>. They also allow effective <a href="state_estimation" title="wikilink">state estimation</a> and <a href="pattern_recognition" title="wikilink">pattern recognition</a>. Markov chains also play an important role in <a href="reinforcement_learning" title="wikilink">reinforcement learning</a>.</p>

<p>Markov chains are also the basis for <a href="hidden_Markov_model" title="wikilink">hidden Markov models</a>, which are an important tool in such diverse fields as telephone networks (which use the <a href="Viterbi_algorithm" title="wikilink">Viterbi algorithm</a> for error correction), speech recognition and <a class="uri" href="bioinformatics" title="wikilink">bioinformatics</a> (such as in rearrangements detection <a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a>).</p>

<p>The <a href="Lempel–Ziv–Markov_chain_algorithm" title="wikilink">LZMA</a> lossless data compression algorithm combines Markov chains with Lempel-Ziv compression to achieve very high compression ratios.</p>
<h3 id="queueing-theory">Queueing theory</h3>

<p>Markov chains are the basis for the analytical treatment of queues (<a href="queueing_theory" title="wikilink">queueing theory</a>). <a href="Agner_Krarup_Erlang" title="wikilink">Agner Krarup Erlang</a> initiated the subject in 1917.<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a> This makes them critical for optimizing the performance of telecommunications networks, where messages must often compete for limited resources (such as bandwidth).<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a></p>
<h3 id="internet-applications">Internet applications</h3>

<p>The <a class="uri" href="PageRank" title="wikilink">PageRank</a> of a webpage as used by <a class="uri" href="Google" title="wikilink">Google</a> is defined by a Markov chain.<a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a> It is the probability to be at page 

<math display="inline" id="Markov_chain:78">
<semantics>
<mi>i</mi>
<annotation-xml encoding="MathML-Content">
<ci>i</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   i
  </annotation>
</semantics>
</math>

 in the stationary distribution on the following Markov chain on all (known) webpages. If 

<math display="inline" id="Markov_chain:79">
<semantics>
<mi>N</mi>
<annotation-xml encoding="MathML-Content">
<ci>N</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   N
  </annotation>
</semantics>
</math>

 is the number of known webpages, and a page 

<math display="inline" id="Markov_chain:80">
<semantics>
<mi>i</mi>
<annotation-xml encoding="MathML-Content">
<ci>i</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   i
  </annotation>
</semantics>
</math>

 has 

<math display="inline" id="Markov_chain:81">
<semantics>
<msub>
<mi>k</mi>
<mi>i</mi>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>k</ci>
<ci>i</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   k_{i}
  </annotation>
</semantics>
</math>

 links to it then it has transition probability 

<math display="inline" id="Markov_chain:82">
<semantics>
<mrow>
<mfrac>
<mi>α</mi>
<msub>
<mi>k</mi>
<mi>i</mi>
</msub>
</mfrac>
<mo>+</mo>
<mfrac>
<mrow>
<mn>1</mn>
<mo>-</mo>
<mi>α</mi>
</mrow>
<mi>N</mi>
</mfrac>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<plus></plus>
<apply>
<divide></divide>
<ci>α</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>k</ci>
<ci>i</ci>
</apply>
</apply>
<apply>
<divide></divide>
<apply>
<minus></minus>
<cn type="integer">1</cn>
<ci>α</ci>
</apply>
<ci>N</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \frac{\alpha}{k_{i}}+\frac{1-\alpha}{N}
  </annotation>
</semantics>
</math>

 for all pages that are linked to and 

<math display="inline" id="Markov_chain:83">
<semantics>
<mfrac>
<mrow>
<mn>1</mn>
<mo>-</mo>
<mi>α</mi>
</mrow>
<mi>N</mi>
</mfrac>
<annotation-xml encoding="MathML-Content">
<apply>
<divide></divide>
<apply>
<minus></minus>
<cn type="integer">1</cn>
<ci>α</ci>
</apply>
<ci>N</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \frac{1-\alpha}{N}
  </annotation>
</semantics>
</math>

 for all pages that are not linked to. The parameter 

<math display="inline" id="Markov_chain:84">
<semantics>
<mi>α</mi>
<annotation-xml encoding="MathML-Content">
<ci>α</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \alpha
  </annotation>
</semantics>
</math>

 is taken to be about 0.85.<a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a></p>

<p>Markov models have also been used to analyze web navigation behavior of users. A user's web link transition on a particular website can be modeled using first- or second-order Markov models and can be used to make predictions regarding future navigation and to personalize the web page for an individual user.</p>
<h3 id="statistics">Statistics</h3>

<p>Markov chain methods have also become very important for generating sequences of random numbers to accurately reflect very complicated desired probability distributions, via a process called <a href="Markov_chain_Monte_Carlo" title="wikilink">Markov chain Monte Carlo</a> (MCMC). In recent years this has revolutionized the practicability of <a href="Bayesian_inference" title="wikilink">Bayesian inference</a> methods, allowing a wide range of <a href="posterior_distribution" title="wikilink">posterior distributions</a> to be simulated and their parameters found numerically.</p>
<h3 id="economics-and-finance">Economics and finance</h3>

<p>Markov chains are used in finance and economics to model a variety of different phenomena, including asset prices and market crashes. The first financial model to use a Markov chain was from Prasad <em>et al.</em> in 1974.<a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a> Another was the regime-switching model of <a href="James_D._Hamilton" title="wikilink">James D. Hamilton</a> (1989), in which a Markov chain is used to model switches between periods of high volatility and low volatility of asset returns.<a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a> A more recent example is the <a href="Markov_Switching_Multifractal" title="wikilink">Markov Switching Multifractal</a> model of <a href="Laurent_E._Calvet" title="wikilink">Laurent E. Calvet</a> and Adlai J. Fisher, which builds upon the convenience of earlier regime-switching models.<a class="footnoteRef" href="#fn23" id="fnref23"><sup>23</sup></a><a class="footnoteRef" href="#fn24" id="fnref24"><sup>24</sup></a> It uses an arbitrarily large Markov chain to drive the level of volatility of asset returns.</p>

<p>Dynamic macroeconomics heavily uses Markov chains. An example is using Markov chains to exogenously model prices of equity (stock) in a <a href="general_equilibrium" title="wikilink">general equilibrium</a> setting.<a class="footnoteRef" href="#fn25" id="fnref25"><sup>25</sup></a></p>

<p>Credit ratings agencies produce annual tables of the transition probabilities for bonds of different credit ratings.<a class="footnoteRef" href="#fn26" id="fnref26"><sup>26</sup></a></p>
<h3 id="social-sciences">Social sciences</h3>

<p>Markov chains are generally used in describing <a class="uri" href="path-dependent" title="wikilink">path-dependent</a> arguments, where current structural configurations condition future outcomes. An example is the reformulation of the idea, originally due to <a href="Karl_Marx" title="wikilink">Karl Marx</a>'s <a href="Das_Kapital" title="wikilink">Das Kapital</a>, tying <a href="economic_development" title="wikilink">economic development</a> to the rise of <a class="uri" href="capitalism" title="wikilink">capitalism</a>. In current research, it is common to use a Markov chain to model how once a country reaches a specific level of economic development, the configuration of structural factors, such as size of the commercial <a class="uri" href="bourgeoisie" title="wikilink">bourgeoisie</a>, the ratio of urban to rural residence, the rate of <a class="uri" href="political" title="wikilink">political</a> mobilization, etc., will generate a higher probability of transitioning from <a class="uri" href="authoritarian" title="wikilink">authoritarian</a> to <a class="uri" href="democratic" title="wikilink">democratic</a> regime.<a class="footnoteRef" href="#fn27" id="fnref27"><sup>27</sup></a></p>
<h3 id="mathematical-biology">Mathematical biology</h3>

<p>Markov chains also have many applications in biological modelling, particularly <a href="population_process" title="wikilink">population processes</a>, which are useful in modelling processes that are (at least) analogous to biological populations. The <a href="Leslie_matrix" title="wikilink">Leslie matrix</a> is one such example, though some of its entries are not probabilities (they may be greater than 1). Another example is the modeling of cell shape in dividing sheets of <a href="epithelial_cells" title="wikilink">epithelial cells</a>.<a class="footnoteRef" href="#fn28" id="fnref28"><sup>28</sup></a> Yet another example is the state of <a href="ion_channel" title="wikilink">ion channels</a> in cell membranes.</p>

<p>Markov chains are also used in simulations of brain function, such as the simulation of the mammalian neocortex.<a class="footnoteRef" href="#fn29" id="fnref29"><sup>29</sup></a></p>
<h3 id="genetics">Genetics</h3>

<p>Markov chains have been used in <a href="population_genetics" title="wikilink">population genetics</a> in order to describe the change in gene frequencies in small populations affected by <a href="genetic_drift" title="wikilink">genetic drift</a>, for example in <a href="diffusion_equation" title="wikilink">diffusion equation</a> method described by <a href="Motoo_Kimura" title="wikilink">Motoo Kimura</a>.<a class="footnoteRef" href="#fn30" id="fnref30"><sup>30</sup></a></p>
<h3 id="games">Games</h3>

<p>Markov chains can be used to model many games of chance. The children's games <a href="Snakes_and_Ladders" title="wikilink">Snakes and Ladders</a> and "<a href="Hi_Ho!_Cherry-O" title="wikilink">Hi Ho! Cherry-O</a>", for example, are represented exactly by Markov chains. At each turn, the player starts in a given state (on a given square) and from there has fixed odds of moving to certain other states (squares).</p>
<h3 id="music">Music</h3>

<p>Markov chains are employed in <a href="algorithmic_composition" title="wikilink">algorithmic music composition</a>, particularly in <a class="uri" href="software" title="wikilink">software</a> such as <a class="uri" href="CSound" title="wikilink">CSound</a>, <a href="Max_(software)" title="wikilink">Max</a> and <a class="uri" href="SuperCollider" title="wikilink">SuperCollider</a>. In a first-order chain, the states of the system become note or pitch values, and a <a href="probability_vector" title="wikilink">probability vector</a> for each note is constructed, completing a transition probability matrix (see below). An algorithm is constructed to produce output note values based on the transition matrix weightings, which could be <a class="uri" href="MIDI" title="wikilink">MIDI</a> note values, frequency (<a href="Hertz" title="wikilink">Hz</a>), or any other desirable metric.<a class="footnoteRef" href="#fn31" id="fnref31"><sup>31</sup></a></p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">

<p>1st-order matrix</p></td>
<td style="text-align: left;">

<p>Note</p></td>
<td style="text-align: left;">

<p>A</p></td>
<td style="text-align: left;">

<p>C</p></td>
<td style="text-align: left;">

<p>E</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">

<p>A</p></td>
<td style="text-align: left;">

<p>0.1</p></td>
<td style="text-align: left;">

<p>0.6</p></td>
<td style="text-align: left;">

<p>0.3</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">

<p>C</p></td>
<td style="text-align: left;">

<p>0.25</p></td>
<td style="text-align: left;">

<p>0.05</p></td>
<td style="text-align: left;">

<p>0.7</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">

<p>E</p></td>
<td style="text-align: left;">

<p>0.7</p></td>
<td style="text-align: left;">

<p>0.3</p></td>
<td style="text-align: left;">

<p>0</p></td>
</tr>
</tbody>
</table>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">

<p>2nd-order matrix</p></td>
<td style="text-align: left;">

<p>Notes</p></td>
<td style="text-align: left;">

<p>A</p></td>
<td style="text-align: left;">

<p>D</p></td>
<td style="text-align: left;">

<p>G</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">

<p>AA</p></td>
<td style="text-align: left;">

<p>0.18</p></td>
<td style="text-align: left;">

<p>0.6</p></td>
<td style="text-align: left;">

<p>0.22</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">

<p>AD</p></td>
<td style="text-align: left;">

<p>0.5</p></td>
<td style="text-align: left;">

<p>0.5</p></td>
<td style="text-align: left;">

<p>0</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">

<p>AG</p></td>
<td style="text-align: left;">

<p>0.15</p></td>
<td style="text-align: left;">

<p>0.75</p></td>
<td style="text-align: left;">

<p>0.1</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">

<p>DD</p></td>
<td style="text-align: left;">

<p>0</p></td>
<td style="text-align: left;">

<p>0</p></td>
<td style="text-align: left;">

<p>1</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">

<p>DA</p></td>
<td style="text-align: left;">

<p>0.25</p></td>
<td style="text-align: left;">

<p>0</p></td>
<td style="text-align: left;">

<p>0.75</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">

<p>DG</p></td>
<td style="text-align: left;">

<p>0.9</p></td>
<td style="text-align: left;">

<p>0.1</p></td>
<td style="text-align: left;">

<p>0</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">

<p>GG</p></td>
<td style="text-align: left;">

<p>0.4</p></td>
<td style="text-align: left;">

<p>0.4</p></td>
<td style="text-align: left;">

<p>0.2</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">

<p>GA</p></td>
<td style="text-align: left;">

<p>0.5</p></td>
<td style="text-align: left;">

<p>0.25</p></td>
<td style="text-align: left;">

<p>0.25</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">

<p>GD</p></td>
<td style="text-align: left;">

<p>1</p></td>
<td style="text-align: left;">

<p>0</p></td>
<td style="text-align: left;">

<p>0</p></td>
</tr>
<tr class="odd">
</tr>
</tbody>
</table>

<p>A second-order Markov chain can be introduced by considering the current state <em>and</em> also the previous state, as indicated in the second table. Higher, <em>n</em>th-order chains tend to "group" particular notes together, while 'breaking off' into other patterns and sequences occasionally. These higher-order chains tend to generate results with a sense of <a href="Phrase_(music)" title="wikilink">phrasal</a> structure, rather than the 'aimless wandering' produced by a first-order system.<a class="footnoteRef" href="#fn32" id="fnref32"><sup>32</sup></a></p>

<p>Markov chains can be used structurally, as in Xenakis's Analogique A and B.<a class="footnoteRef" href="#fn33" id="fnref33"><sup>33</sup></a> Markov chains are also used in systems which use a Markov model to react interactively to music input.<a class="footnoteRef" href="#fn34" id="fnref34"><sup>34</sup></a></p>

<p>Usually musical systems need to enforce speciﬁc control constraints on the ﬁnite-length sequences they generate, but control constraints are not compatible with Markov models, since they induce long-range dependencies that violate the Markov hypothesis of limited memory. In order to overcome this limitation, a new approach has been proposed.<a class="footnoteRef" href="#fn35" id="fnref35"><sup>35</sup></a></p>
<h3 id="baseball">Baseball</h3>

<p>Markov chain models have been used in advanced baseball analysis since 1960, although their use is still rare. Each half-inning of a baseball game fits the Markov chain state when the number of runners and outs are considered. During any at-bat, there are 24 possible combinations of number of outs and position of the runners. Mark Pankin shows that Markov chain models can be used to evaluate runs created for both individual players as well as a team.<a class="footnoteRef" href="#fn36" id="fnref36"><sup>36</sup></a> He also discusses various kinds of strategies and play conditions: how Markov chain models have been used to analyze statistics for game situations such as <a href="bunt_(baseball)" title="wikilink">bunting</a> and <a href="base_stealing" title="wikilink">base stealing</a> and differences when playing on grass vs. <a class="uri" href="astroturf" title="wikilink">astroturf</a>.<a class="footnoteRef" href="#fn37" id="fnref37"><sup>37</sup></a></p>
<h3 id="markov-text-generators">Markov text generators</h3>

<p>Markov processes can also be used to generate superficially real-looking text given a sample document: they are used in a variety of recreational "<a href="parody_generator" title="wikilink">parody generator</a>" software (see <a href="dissociated_press" title="wikilink">dissociated press</a>, Jeff Harrison,<a class="footnoteRef" href="#fn38" id="fnref38"><sup>38</sup></a> <a href="Mark_V_Shaney" title="wikilink">Mark V Shaney</a><a class="footnoteRef" href="#fn39" id="fnref39"><sup>39</sup></a><a class="footnoteRef" href="#fn40" id="fnref40"><sup>40</sup></a> ).</p>

<p>These processes are also used by <a href="E-mail_spam" title="wikilink">spammers</a> to inject real-looking hidden paragraphs into <a href="unsolicited_email" title="wikilink">unsolicited email</a> and <a href="spam_in_blogs" title="wikilink">post comments</a> in an attempt to get these messages past <a href="spam_filter" title="wikilink">spam filters</a>.</p>

<p>In the <a class="uri" href="bioinformatics" title="wikilink">bioinformatics</a> field, they can be used to simulate DNA sequences.<a class="footnoteRef" href="#fn41" id="fnref41"><sup>41</sup></a></p>
<h2 id="fitting">Fitting</h2>

<p>When fitting a Markov chain to data, situations where parameters poorly describe the situation may highlight interesting trends.<a class="footnoteRef" href="#fn42" id="fnref42"><sup>42</sup></a><a class="footnoteRef" href="#fn43" id="fnref43"><sup>43</sup></a> <a href="http://www.eng.tau.ac.il/~bengal/VOM_EST.pdf">1</a></p>
<h2 id="history">History</h2>

<p><a href="Andrey_Markov" title="wikilink">Andrey Markov</a> produced the first results (1906) for these processes, purely theoretically. A generalization to countably infinite state spaces was given by <a href="Andrey_Nikolaevich_Kolmogorov" title="wikilink">Kolmogorov</a> (1936). Markov chains are related to <a href="Brownian_motion" title="wikilink">Brownian motion</a> and the <a href="ergodic_hypothesis" title="wikilink">ergodic hypothesis</a>, two topics in physics which were important in the early years of the twentieth century. However, Markov first pursued this in 1906 as part of his argument against Pavel Nekrasov, in particular to make the case that the <a href="law_of_large_numbers" title="wikilink">law of large numbers</a> can be extended to dependent events.<a class="footnoteRef" href="#fn44" id="fnref44"><sup>44</sup></a> In 1913, he applied his findings to the first 20,000 letters of Pushkin's <em><a href="Eugene_Onegin" title="wikilink">Eugene Onegin</a></em>.<a class="footnoteRef" href="#fn45" id="fnref45"><sup>45</sup></a> By 1917, more practical application of his work was made by <a href="Agner_Krarup_Erlang" title="wikilink">Erlang</a> to obtain formulas for call loss and waiting time in telephone networks.<a class="footnoteRef" href="#fn46" id="fnref46"><sup>46</sup></a></p>

<p>Seneta provides an account of Markov's motivations and the theory's early development.<a class="footnoteRef" href="#fn47" id="fnref47"><sup>47</sup></a> The term "chain" was used by Markov (1906) to suggest a sequence of pairwise dependent variables.<a class="footnoteRef" href="#fn48" id="fnref48"><sup>48</sup></a></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Hidden_Markov_model" title="wikilink">Hidden Markov model</a></li>
<li><a href="Markov_blanket" title="wikilink">Markov blanket</a></li>
<li><a href="Markov_chain_geostatistics" title="wikilink">Markov chain geostatistics</a></li>
<li><a href="Markov_chain_mixing_time" title="wikilink">Markov chain mixing time</a></li>
<li><a href="Markov_chain_Monte_Carlo" title="wikilink">Markov chain Monte Carlo</a></li>
<li><a href="Markov_decision_process" title="wikilink">Markov decision process</a></li>
<li><a href="Markov_information_source" title="wikilink">Markov information source</a></li>
<li><a href="Markov_network" title="wikilink">Markov network</a></li>
<li><a href="Markov_process" title="wikilink">Markov process</a></li>
<li><a href="Quantum_Markov_chain" title="wikilink">Quantum Markov chain</a></li>
<li><a href="Semi-Markov_process" title="wikilink">Semi-Markov process</a></li>
<li><a href="Telescoping_Markov_chain" title="wikilink">Telescoping Markov chain</a></li>
<li><a href="Variable-order_Markov_model" title="wikilink">Variable-order Markov model</a></li>
</ul>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<ul>
<li>A.A. Markov. "Rasprostranenie zakona bol'shih chisel na velichiny, zavisyaschie drug ot druga". <em>Izvestiya Fiziko-matematicheskogo obschestva pri Kazanskom universitete</em>, 2-ya seriya, tom 15, pp. 135–156, 1906.</li>
<li>A.A. Markov. "Extension of the limit theorems of probability theory to a sum of variables connected in a chain". reprinted in Appendix B of: R. Howard. <em>Dynamic Probabilistic Systems, volume 1: Markov Chains</em>. John Wiley and Sons, 1971.</li>
<li>Classical Text in Translation: A. A. Markov, An Example of Statistical Investigation of the Text Eugene Onegin Concerning the Connection of Samples in Chains, trans. David Link. Science in Context 19.4 (2006): 591–600. Online: <a class="uri" href="http://journals.cambridge.org/production/action/cjoGetFulltext?fulltextid=637500">http://journals.cambridge.org/production/action/cjoGetFulltext?fulltextid=637500</a></li>
<li>Leo Breiman. <em>Probability</em>. Original edition published by Addison-Wesley, 1968; reprinted by Society for Industrial and Applied Mathematics, 1992. ISBN 0-89871-296-3. <em>(See Chapter 7.)</em></li>
<li>J.L. Doob. <em>Stochastic Processes</em>. New York: John Wiley and Sons, 1953. ISBN 0-471-52369-0.</li>
<li>S. P. Meyn and R. L. Tweedie. <em>Markov Chains and Stochastic Stability</em>. London: Springer-Verlag, 1993. ISBN 0-387-19832-6. online: <a class="uri" href="https://netfiles.uiuc.edu/meyn/www/spm_files/book.html">https://netfiles.uiuc.edu/meyn/www/spm_files/book.html</a> . Second edition to appear, Cambridge University Press, 2009.</li>
<li>S. P. Meyn. <em>Control Techniques for Complex Networks</em>. Cambridge University Press, 2007. ISBN 978-0-521-88441-9. Appendix contains abridged Meyn &amp; Tweedie. online: <a class="uri" href="https://netfiles.uiuc.edu/meyn/www/spm_files/CTCN/CTCN.html">https://netfiles.uiuc.edu/meyn/www/spm_files/CTCN/CTCN.html</a></li>
<li>

<p>Extensive, wide-ranging book meant for specialists, written for both theoretical computer scientists as well as electrical engineers. With detailed explanations of state minimization techniques, FSMs, Turing machines, Markov processes, and undecidability. Excellent treatment of Markov processes pp. 449ff. Discusses Z-transforms, D transforms in their context.</p></li>
<li>

<p>Classical text. cf Chapter 6 <em>Finite Markov Chains</em> pp. 384ff.</p></li>
<li>E. Nummelin. "General irreducible Markov chains and non-negative operators". Cambridge University Press, 1984, 2004. ISBN 0-521-60494-X</li>
<li>Seneta, E. <em>Non-negative matrices and Markov chains</em>. 2nd rev. ed., 1981, XVI, 288 p., Softcover Springer Series in Statistics. (Originally published by Allen &amp; Unwin Ltd., London, 1973) ISBN 978-0-387-29765-1</li>
<li>Kishor S. Trivedi, <em>Probability and Statistics with Reliability, Queueing, and Computer Science Applications</em>, John Wiley &amp; Sons, Inc. New York, 2002. ISBN 0-471-33341-7.</li>
<li>K.S.Trivedi and R.A.Sahner, <em>SHARPE at the age of twenty-two</em>, vol. 36, no. 4, pp.-52-57, ACM SIGMETRICS Performance Evaluation Review, 2009.</li>
<li>R.A.Sahner, K.S.Trivedi and A. Puliafito, <em>Performance and reliability analysis of computer systems: an example-based approach using the SHARPE software package</em>, Kluwer Academic Publishers, 1996. ISBN 0-7923-9650-2.</li>
<li>G.Bolch, S.Greiner, H.de Meer and K.S.Trivedi, <em>Queueing Networks and Markov Chains</em>, John Wiley, 2nd edition, 2006. ISBN 978-0-7923-9650-5.</li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li></li>
<li></li>
<li><a href="http://jasss.soc.surrey.ac.uk/12/1/6.html">Techniques to Understand Computer Simulations: Markov Chain Analysis</a></li>
<li><a href="http://www.dartmouth.edu/~chance/teaching_aids/books_articles/probability_book/Chapter11.pdf">Markov Chains chapter in American Mathematical Society's introductory probability book</a>(pdf)</li>
<li><a href="http://setosa.io/blog/2014/07/26/markov-chains/index.html">A beautiful visual explanation of Markov Chains</a></li>
<li><a href="http://www.math.rutgers.edu/courses/338/coursenotes/chapter5.pdf">Chapter 5: Markov Chain Models</a></li>
<li><a href="http://rarlindseysmash.com/posts/2009-11-21-making-sense-and-nonsense-of-markov-chains">Making Sense and Nonsense of Markov Chains</a></li>
</ul>

<p>"</p>

<p><a href="Category:Markov_processes" title="wikilink">Category:Markov processes</a> <a href="Category:Markov_models" title="wikilink">Category:Markov models</a> <a href="Category:Graph_theory" title="wikilink">Category:Graph theory</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2">Everitt,B.S. (2002) <em>The Cambridge Dictionary of Statistics</em>. CUP. ISBN 0-521-81099-X<a href="#fnref2">↩</a></li>
<li id="fn3">Parzen, E. (1962) <em>Stochastic Processes</em>, Holden-Day. ISBN 0-8162-6664-6 (Table 6.1))<a href="#fnref3">↩</a></li>
<li id="fn4">Dodge, Y. (2003) <em>The Oxford Dictionary of Statistical Terms</em>, OUP. ISBN 0-19-920613-9 (entry for "Markov chain")<a href="#fnref4">↩</a></li>
<li id="fn5">Meyn, S. Sean P., and Richard L. Tweedie. (2009) <em>Markov chains and stochastic stability</em>. Cambridge University Press. (Preface, p. iii)<a href="#fnref5">↩</a></li>
<li id="fn6">S. P. Meyn and R.L. Tweedie, 2005. <a href="http://probability.ca/MT/BOOK.pdf">Markov Chains and Stochastic Stability</a><a href="#fnref6">↩</a></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
<li id="fn8">.<a href="#fnref8">↩</a></li>
<li id="fn9">Florian Schmitt and Franz Rothlauf, "On the Mean of the Second Largest Eigenvalue on the Convergence Rate of Genetic Algorithms", Working Paper 1/2001, Working Papers in Information Systems, 2001. <a class="uri" href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.28.6191">http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.28.6191</a><a href="#fnref9">↩</a></li>
<li id="fn10">Gene H. Golub, Charles F. Van Loan, "Matrix computations", Third Edition, The Johns Hopkins University Press, Baltimore and London, 1996.<a href="#fnref10">↩</a></li>
<li id="fn11"><a href="#fnref11">↩</a></li>
<li id="fn12"><a href="#fnref12">↩</a></li>
<li id="fn13"><a href="#fnref13">↩</a></li>
<li id="fn14"><a href="#fnref14">↩</a></li>
<li id="fn15"><a href="#fnref15">↩</a></li>
<li id="fn16"><a href="#fnref16">↩</a></li>
<li id="fn17"><a href="#fnref17">↩</a></li>
<li id="fn18">S. P. Meyn, 2007. <a href="http://www.meyn.ece.ufl.edu/archive/spm_files/CTCN/MonographTocBib.pdf">Control Techniques for Complex Networks</a>, Cambridge University Press, 2007.<a href="#fnref18">↩</a></li>
<li id="fn19"><a href="#fnref19">↩</a></li>
<li id="fn20"><a href="#fnref20">↩</a></li>
<li id="fn21"><a href="#fnref21">↩</a></li>
<li id="fn22"><a href="#fnref22">↩</a></li>
<li id="fn23"><a href="#fnref23">↩</a></li>
<li id="fn24"><a href="#fnref24">↩</a></li>
<li id="fn25"><a href="#fnref25">↩</a></li>
<li id="fn26"><a href="http://www.columbia.edu/~ww2040/4106S11/MC_BondRating.pdf">A Markov Chain Example in Credit Risk Modelling Columbia University lectures</a><a href="#fnref26">↩</a></li>
<li id="fn27"><a href="#fnref27">↩</a></li>
<li id="fn28"><a href="#fnref28">↩</a></li>
<li id="fn29"><a href="#fnref29">↩</a></li>
<li id="fn30">Watterson, G. (1996). "Motoo Kimura's Use of Diffusion Theory in Population Genetics". Theoretical Population Biology 49 (2): 154–188. <a class="uri" href="doi:10.1006/tpbi.1996.0010">doi:10.1006/tpbi.1996.0010</a>. PMID 8813021.<a href="#fnref30">↩</a></li>
<li id="fn31"><a href="#fnref31">↩</a></li>
<li id="fn32"><a href="#fnref32">↩</a></li>
<li id="fn33">Xenakis, Iannis; Kanach, Sharon (1992) <em>Formalized Music: Mathematics and Thought in Composition</em>, Pendragon Press. ISBN 1576470792<a href="#fnref33">↩</a></li>
<li id="fn34"><a href="http://www.csl.sony.fr/~pachet/">Continuator</a><a href="#fnref34">↩</a></li>
<li id="fn35">Pachet, F.; Roy, P.; Barbieri, G. (2011) <a href="http://www.csl.sony.fr/downloads/papers/2011/pachet-11b.pdf">"Finite-Length Markov Processes with Constraints"</a>, <em>Proceedings of the 22nd International Joint Conference on Artificial Intelligence</em>, IJCAI, pages 635-642,Barcelona, Spain, July 2011<a href="#fnref35">↩</a></li>
<li id="fn36"><a href="#fnref36">↩</a></li>
<li id="fn37"><a href="#fnref37">↩</a></li>
<li id="fn38">[<a class="uri" href="http://www.fieralingue.it/modules.php?name=Content&amp;pa">http://www.fieralingue.it/modules.php?name=Content&amp;pa;</a>;=list_pages_categories&amp;cid;=111 Poet's Corner – Fieralingue]<a href="#fnref38">↩</a></li>
<li id="fn39"><a href="#fnref39">↩</a></li>
<li id="fn40"><a href="#fnref40">↩</a></li>
<li id="fn41"><a href="#fnref41">↩</a></li>
<li id="fn42"><a href="#fnref42">↩</a></li>
<li id="fn43"><a href="#fnref43">↩</a></li>
<li id="fn44"><a href="#fnref44">↩</a></li>
<li id="fn45"></li>
<li id="fn46"></li>
<li id="fn47"><a href="#fnref47">↩</a></li>
<li id="fn48"><a href="#fnref48">↩</a></li>
</ol>
</section>
</body>
</html>
