<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="699">Promise problem</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Promise problem</h1>
<hr/>

<p>In <a href="computational_complexity_theory" title="wikilink">computational complexity theory</a>, a <strong>promise problem</strong> is a generalization of a <a href="decision_problem" title="wikilink">decision problem</a> where the input is promised to belong to a subset of all possible inputs.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> Unlike decision problems, the <em>yes</em> instances (the inputs for which an algorithm must return <em>yes</em>) and <em>no</em> instances do not exhaust the set of all inputs. Intuitively, the algorithm has been <em>promised</em> that the input does indeed belong to set of <em>yes</em> instances or <em>no</em> instances. There may be inputs which are neither <em>yes</em> or <em>no</em>. If such an input is given to an algorithm for solving a promise problem, the algorithm is allowed to output anything, and may even not halt.</p>
<h2 id="formal-definition">Formal definition</h2>

<p>A decision problem can be associated with a language 

<math display="inline" id="Promise_problem:0">
 <semantics>
  <mrow>
   <mi>L</mi>
   <mo>⊆</mo>
   <msup>
    <mrow>
     <mo stretchy="false">{</mo>
     <mn>0</mn>
     <mo>,</mo>
     <mn>1</mn>
     <mo stretchy="false">}</mo>
    </mrow>
    <mo>*</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <ci>L</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <set>
      <cn type="integer">0</cn>
      <cn type="integer">1</cn>
     </set>
     <times></times>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L\subseteq\{0,1\}^{*}
  </annotation>
 </semantics>
</math>

, where the problem is to accept all inputs in 

<math display="inline" id="Promise_problem:1">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

 and reject all inputs not in 

<math display="inline" id="Promise_problem:2">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

. For a promise problem, there are two languages, 

<math display="inline" id="Promise_problem:3">
 <semantics>
  <msub>
   <mi>L</mi>
   <mtext>YES</mtext>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>L</ci>
    <mtext>YES</mtext>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L_{\text{YES}}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Promise_problem:4">
 <semantics>
  <msub>
   <mi>L</mi>
   <mtext>NO</mtext>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>L</ci>
    <mtext>NO</mtext>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L_{\text{NO}}
  </annotation>
 </semantics>
</math>

, which must be <a href="Disjoint_sets" title="wikilink">disjoint</a>, which means 

<math display="inline" id="Promise_problem:5">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>L</mi>
     <mtext>YES</mtext>
    </msub>
    <mo>∩</mo>
    <msub>
     <mi>L</mi>
     <mtext>NO</mtext>
    </msub>
   </mrow>
   <mo>=</mo>
   <mi mathvariant="normal">∅</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <intersect></intersect>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>L</ci>
      <mtext>YES</mtext>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>L</ci>
      <mtext>NO</mtext>
     </apply>
    </apply>
    <emptyset></emptyset>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L_{\text{YES}}\cap L_{\text{NO}}=\varnothing
  </annotation>
 </semantics>
</math>

, such that all the inputs in 

<math display="inline" id="Promise_problem:6">
 <semantics>
  <msub>
   <mi>L</mi>
   <mtext>YES</mtext>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>L</ci>
    <mtext>YES</mtext>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L_{\text{YES}}
  </annotation>
 </semantics>
</math>

 are to be accepted and all inputs in 

<math display="inline" id="Promise_problem:7">
 <semantics>
  <msub>
   <mi>L</mi>
   <mtext>NO</mtext>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>L</ci>
    <mtext>NO</mtext>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L_{\text{NO}}
  </annotation>
 </semantics>
</math>

 are to be rejected. The set 

<math display="inline" id="Promise_problem:8">
 <semantics>
  <mrow>
   <msub>
    <mi>L</mi>
    <mtext>YES</mtext>
   </msub>
   <mo>∪</mo>
   <msub>
    <mi>L</mi>
    <mtext>NO</mtext>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <union></union>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>L</ci>
     <mtext>YES</mtext>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>L</ci>
     <mtext>NO</mtext>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L_{\text{YES}}\cup L_{\text{NO}}
  </annotation>
 </semantics>
</math>

 is called the <em>promise</em>. There are no requirements on the output if the input does not belong to the promise. If the promise equals 

<math display="inline" id="Promise_problem:9">
 <semantics>
  <msup>
   <mrow>
    <mo stretchy="false">{</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mn>1</mn>
    <mo stretchy="false">}</mo>
   </mrow>
   <mo>*</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <set>
     <cn type="integer">0</cn>
     <cn type="integer">1</cn>
    </set>
    <times></times>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{0,1\}^{*}
  </annotation>
 </semantics>
</math>

, then this is also a decision problem, and the promise is said to be trivial.</p>
<h2 id="examples">Examples</h2>

<p>Many natural problems are actually promise problems. For instance, consider the following problem: Given a <a href="directed_acyclic_graph" title="wikilink">directed acyclic graph</a>, determine if the graph has a <a href="path_(graph_theory)" title="wikilink">path</a> of length 10. The <em>yes</em> instances are directed acyclic graphs with a path of length 10, whereas the <em>no</em> instances are directed acyclic graphs with no path of length 10. The promise is the set of directed acyclic graphs. In this example, the promise is easy to check. In particular, it is very easy to check if a given graph is cyclic. However, the promised property could be difficult to evaluate. For instance, consider the problem "Given a <a href="Hamiltonian_graph" title="wikilink">Hamiltonian graph</a>, determine if the graph has a <a href="cycle_(graph_theory)" title="wikilink">cycle</a> of size 4." Now the promise is <a class="uri" href="NP-hard" title="wikilink">NP-hard</a> to evaluate, yet the promise problem is easy to solve since checking for cycles of size 4 can be done in polynomial time.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Computational_problem" title="wikilink">Computational problem</a></li>
<li><a href="Decision_problem" title="wikilink">Decision problem</a></li>
<li><a href="Optimization_problem" title="wikilink">Optimization problem</a></li>
<li><a href="Search_problem" title="wikilink">Search problem</a></li>
<li><a href="Counting_problem_(complexity)" title="wikilink">Counting problem (complexity)</a></li>
<li><a href="Function_problem" title="wikilink">Function problem</a></li>
</ul>
<h2 id="references">References</h2>
<h3 id="surveys">Surveys</h3>
<ul>
<li></li>
<li></li>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Computational_problems" title="wikilink">Category:Computational problems</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
</ol>
</section>
</body>
</html>
