<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="989">Protein design</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Protein design</h1>
<hr/>
<dl>
<dd>''This article refers to rational protein design. For the broader engineering of proteins see <a href="protein_engineering" title="wikilink">protein engineering</a>.
</dd>
</dl>

<p><strong>Protein design</strong> is the <a href="rational_design" title="wikilink">rational design</a> of new <a class="uri" href="protein" title="wikilink">protein</a> molecules to fold to a target <a href="protein_structure" title="wikilink">protein structure</a>, with the ultimate goal of designing novel function and/or behavior. Proteins can be designed from scratch (<em>de novo</em> design) or by making calculated variations on a known protein structure and its sequence (known as <em>protein redesign</em>). Rational protein design approaches make protein-sequence predictions that will fold to specific structures. These predicted sequences can then be validated experimentally through methods such as <a href="peptide_synthesis" title="wikilink">peptide synthesis</a>, <a href="site-directed_mutagenesis" title="wikilink">site-directed mutagenesis</a>, or <a href="artificial_gene_synthesis" title="wikilink">artificial gene synthesis</a>.</p>

<p>Rational protein design dates back to the mid-1970s, although initial protein design approaches were based mostly on sequence composition and did not account for specific interactions between side-chains at the atomic level.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> Recently, however, improvements in molecular force fields, protein design algorithms, and <a href="structural_bioinformatics" title="wikilink">structural bioinformatics</a>, such as <a href="Conformational_isomerism#Protein_rotamer_libraries" title="wikilink">libraries of amino acid conformations</a>, have enabled the development of advanced computational protein design tools. These computational tools can make complex calculations on protein energetics and flexibility, and perform searches over enormous <a href="configuration_space" title="wikilink">configuration spaces</a>, which would be unfeasible to perform manually. Thanks to the development of computational protein design programs and important successes in the field (e.g., see <a href="Protein_design#Applications_and_examples_of_designed_proteins" title="wikilink">examples</a> below), rational protein design has become one of the most important tools in <a href="protein_engineering" title="wikilink">protein engineering</a>.</p>
<h2 id="overview-and-history">Overview and history</h2>

<p>The goal in rational protein design is to predict <a href="amino_acid" title="wikilink">amino acid</a> <a href="Protein_primary_structure" title="wikilink">sequences</a> that will <a href="protein_folding" title="wikilink">fold</a> to a specific protein structure. Although the number of possible protein sequences is enormous, growing exponentially with the size of the protein chain, only a subset of them will fold reliably and quickly to a single <a href="native_state" title="wikilink">native state</a>. Protein design involves identifying novel sequences within this subset. The native state of a protein is the conformational <a href="Thermodynamic_free_energy" title="wikilink">free energy</a> minimum for the chain. Therefore, protein design is the search for sequences that have the chosen structure as a free energy minimum. In a sense, it is the reverse of <a href="protein_structure_prediction" title="wikilink">structure prediction</a>: In design, a <a href="Protein_tertiary_structure" title="wikilink">tertiary structure</a> is specified, and a sequence that will fold to it is identified. Hence, it is also referred to as <em>inverse folding</em>. Protein design is then an optimization problem: using some scoring criteria, an optimized sequence that will fold to the desired structure is chosen.</p>

<p>When the first proteins were rationally designed during the 1970s and 1980s, the sequence for these was optimized manually based on analyses of other known proteins, the sequence composition, amino acid charges, and the geometry of the desired structure.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> The first designed proteins are attributed to Bernd Gutte, who designed a reduced version of a known catalyst, bovine ribonuclease, as well as tertiary structures consisting of beta-sheets and alpha-helices, including a binder of <a class="uri" href="DDT" title="wikilink">DDT</a>. Urry and colleagues later designed <a class="uri" href="elastin" title="wikilink">elastin</a>-like <a href="fibrous_protein" title="wikilink">fibrous</a> peptides based on rules on sequence composition. Richardson and co-workers designed a 79-residue protein with no sequence homology to any known protein.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> In the 1990s, the advent of powerful computers, <a href="Conformational_isomerism#Protein_rotamer_libraries" title="wikilink">libraries of amino acid conformations</a>, and force fields developed primarily for <a href="molecular_dynamics" title="wikilink">molecular dynamics</a> simulations enabled the development of structure-based computational protein design tools. Following the development of these computational tools, enormous success has been achieved over the last 30 years in protein design. The first protein successfully designed completely <em>de novo</em> was done by Stephen Mayo and co-workers in 1997,<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> and, shortly after, in 1999 <a href="Peter_S._Kim" title="wikilink">Peter S. Kim</a> and co-workers designed dimers, trimers, and tetramers of unnatural right-handed <a href="coiled_coil" title="wikilink">coiled coils</a>.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a><a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> In 2003, <a href="David_Baker_(biochemist)" title="wikilink">David Baker</a>'s laboratory designed a full protein to a fold never seen before in nature.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> Later, in 2008, Baker's group computationally designed enzymes for two different reactions.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> In 2010, one of the most powerful broadly neutralizing antibodies was isolated from patient serum using a computationally designed protein probe.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> Thanks to these and other successes (e.g., see <a href="Protein_design#Applications_and_examples_of_designed_proteins" title="wikilink">examples</a> below), protein design has become one of the most important tools available for <a href="protein_engineering" title="wikilink">protein engineering</a>. There is great hope that the design of new proteins, small and large, will have applications in <a href="Biomedicine" title="wikilink">medicine</a> and <a class="uri" href="bioengineering" title="wikilink">bioengineering</a>.</p>
<h2 id="underlying-models-of-protein-structure-and-function">Underlying models of protein structure and function</h2>

<p>Protein design programs use <a href="bioinformatics" title="wikilink">computer models</a> of the molecular forces that drive proteins in <em><a href="in_vivo" title="wikilink">in vivo</a></em> environments. In order to make the problem tractable, these forces are simplified by protein design models. Although protein design programs vary greatly, they have to address four main modeling questions: What is the target structure of the design, what flexibility is allowed on the target structure, which sequences are included in the search, and which force field will be used to score sequences and structures.</p>
<h3 id="target-structure">Target structure</h3>
<figure><b>(Figure)</b>
<figcaption>The <a class="uri" href="Top7" title="wikilink">Top7</a> protein was one of the first proteins designed for a fold that had never been seen before in nature <a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> </figcaption>
</figure>

<p>Protein function is heavily dependent on protein structure, and rational protein design uses this relationship to design function by designing proteins that have a target structure or fold. Thus, by definition, in rational protein design the target structure or ensemble of structures must be known beforehand. This contrasts with other forms of protein engineering, such as <a href="directed_evolution" title="wikilink">directed evolution</a>, where a variety of methods are used to find proteins that achieve a specific function, and with <a href="protein_structure_prediction" title="wikilink">protein structure prediction</a> where the sequence is known, but the structure is unknown.</p>

<p>Most frequently, the target structure is based on a known structure of another protein. However, novel folds not seen in nature have been made increasingly possible. Peter S. Kim and co-workers designed trimers and tetramers of unnatural coiled coils, which had not been seen before in nature.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a><a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> The protein Top7, developed in <a href="David_Baker_(biochemist)" title="wikilink">David Baker</a>'s lab, was designed completely using protein design algorithms, to a completely novel fold.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> More recently, Baker and co-workers developed a series of principles to design ideal <a href="globular_protein" title="wikilink">globular-protein</a> structures based on <a href="folding_funnel" title="wikilink">protein folding funnels</a> that bridge between secondary structure prediction and tertiary structures. These principles, which build on both protein structure prediction and protein design, were used to design five different novel protein topologies.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a></p>
<h3 id="sequence-space">Sequence space</h3>
<figure><b>(Figure)</b>
<figcaption>FSD-1 (shown in blue, PDB id: 1FSV) was the first <em>de novo</em> computational design of a full protein.<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a> The target fold was that of the zinc finger in residues 33-60 of the structure of protein Zif268 (shown in red, PDB id: 1ZAA). The designed sequence had very little sequence identity with any know protein sequence.</figcaption>
</figure>

<p>In rational protein design proteins can be redesigned from the sequence and structure of a known protein, or completely from scratch in <em>de novo</em> protein design. In protein redesign, most of the residues in the sequence are maintained as their wild-type amino-acid while a few are allowed to mutate. In <em>de novo</em> design the entire sequence is designed anew, based on no previous sequence.</p>

<p>Both <em>de novo</em> designs and protein redesigns can establish rules on the <a href="Sequence_space_(evolution)" title="wikilink">sequence space</a>: the specific amino acids that are allowed at each mutable residue position. For example, the composition of the surface of the <a href="#Protein_resurfacing" title="wikilink">RSC3 probe</a> to select HIV-broadly neutralizing antibodies was restricted based on evolutionary data and charge balancing. In fact, many of the earliest attempts on protein design were heavily based on empirical "rules" on the sequence space.<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a> Moreover, the design of <a href="#fibrous_proteins" title="wikilink">fibrous proteins</a>, usually follows strict rules on the sequence space. <a class="uri" href="Collagen" title="wikilink">Collagen</a>-based designed proteins, for example, are often composed of Gly-Pro-X repeating patterns.<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a> With the advent of computational techniques, however, the design of proteins with no human intervention in sequence selection has become possible.<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a></p>
<h3 id="structural-flexibility">Structural flexibility</h3>
<figure><b>(Figure)</b>
<figcaption>Common protein design programs use rotamer libraries to simplify the conformational space of protein side chains. This animation loops through all the rotamers of the isoleucine amino acid based on the Penultimate Rotamer Library.<a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a></figcaption>
</figure>

<p>In protein design, the target structure (or structures) of the protein are known. However, a rational protein design approach must model some <em>flexibility</em> on the target structure in order to increase the number of sequences that can be designed for that structure and to minimize the chance of a sequence folding to a different structure. For example, in a protein redesign of a single, small amino acid (such as alanine) in the tightly packed core of a protein, very few mutants would be predicted by a rational design approach to fold to the target structure, if the surrounding side-chains are not allowed to be repacked.</p>

<p>Thus, an essential parameter of any design process is the amount of flexibility that is allowed for both the side-chains and the backbone. In the simplest models, the protein backbone is kept rigid while some of the protein side-chains are allowed to change conformations. Protein side-chains, however, can have many degrees of freedom in their bond lengths, bond angles, and <a href="Dihedral_angle#Dihedral_angles_of_biological_molecules" title="wikilink"><var>χ</var> dihedral angles</a>. To simplify this space, protein design methods use rotamer libraries that assume ideal values for bond lengths and bond angles, while restricting <var>χ</var> dihedral angles to a few frequently observed low-energy conformations known as <a href="Conformational_isomerism" title="wikilink">rotamers</a>.</p>

<p>Rotamer libraries describe rotamers based on an analysis of many protein structures. Backbone-independent rotamer libraries describe all rotamers.<a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a> Backbone-dependent rotamer libraries, in contrast, describe the rotamers as how likely they are to appear depending on the protein backbone arrangement around the side chain.<a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a> The rotamers described by rotamer libraries are usually regions in space. Most protein design programs use a single conformation (e.g., the modal value for rotamer dihedrals in space) or several points in the region described by the rotamer; the <a href="#Software" title="wikilink">OSPREY</a> protein design program, in contrast, models the entire continuous region.<a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a></p>

<p>Although rational protein design must preserve the general backbone fold a protein, allowing some backbone flexibility can significantly increase the number of sequences that fold to the structure while maintaining the general fold of the protein.<a class="footnoteRef" href="#fn23" id="fnref23"><sup>23</sup></a> Backbone flexibility is especially important in protein redesign because sequence mutations often result in small changes to the backbone structure. Moreover, backbone flexibility can be essential for more advanced applications of protein design, such as binding prediction and enzyme design. Some models of protein design backbone flexibility include small and continuous global backbone movements, discrete backbone samples around the target fold, backrub motions, and protein loop flexibility.<a class="footnoteRef" href="#fn24" id="fnref24"><sup>24</sup></a><a class="footnoteRef" href="#fn25" id="fnref25"><sup>25</sup></a></p>
<h3 id="energy-function">Energy function</h3>
<figure><b>(Figure)</b>
<figcaption>Comparison of various potential energy functions. The most accurate energy are those that use quantum mechanical calculations, but these are too slow for protein design. On the other extreme, heuristic energy functions, are based on statistical terms and are very fast. In the middle are molecular mechanics energy functions that are physically-based but are not as computationally expensive as quantum mechanical simulations.<a class="footnoteRef" href="#fn26" id="fnref26"><sup>26</sup></a></figcaption>
</figure>

<p>Rational protein design techniques must be able to discriminate sequences that will be stable under the target fold from those that would prefer other low-energy competing states. Thus, protein design requires accurate <a href="force_field_(chemistry)" title="wikilink">energy functions</a> that can rank and score sequences by how well they fold to the target structure. At the same time, however, these energy functions must consider the computational <a href="#Protein_Design_as_an_Optimization_Problem" title="wikilink">challenges</a> behind protein design. One of the most challenging requirements for successful design is an energy function that is both accurate and simple for computational calculations.</p>

<p>The most accurate energy functions are those based on quantum mechanical simulations. These simulations, however, are too slow and typically impractical for protein design. Many protein design algorithms, instead, use either physics-based energy functions adapted from <a href="molecular_mechanics" title="wikilink">molecular mechanics</a> simulation programs, <a href="statistical_potential" title="wikilink">knowledge based energy-functions</a>, or a hybrid combination of both. However, the trend has been toward using more physics-based potential energy functions.<a class="footnoteRef" href="#fn27" id="fnref27"><sup>27</sup></a></p>

<p>Physics-based energy functions, such as <a class="uri" href="AMBER" title="wikilink">AMBER</a> and <a class="uri" href="CHARMM" title="wikilink">CHARMM</a>, are typically derived from quantum mechanical simulations, as well as thermodynamic, crystallographic, and spectroscopic data from experimental data.<a class="footnoteRef" href="#fn28" id="fnref28"><sup>28</sup></a> These energy functions typically simplify physical energy function and make them pairwise decomposable, meaning that the total energy of a protein conformation can be calculated by adding the pairwise energy between each atom pair, which makes them attractive for optimization algorithms. Physics-based energy functions typically model an attractive-repulsive <a class="uri" href="Lennard-Jones" title="wikilink">Lennard-Jones</a> term between atoms and a pairwise <a class="uri" href="electrostatics" title="wikilink">electrostatics</a> coulombic term<a class="footnoteRef" href="#fn29" id="fnref29"><sup>29</sup></a> between non-bonded atoms.</p>
<figure><b>(Figure)</b>
<figcaption>Water-mediated hydrogen bonds play a key role in protein-protein binding. One such interaction is shown between residues D457, S365 in the heavy chain of the HIV-broadly-neutralizing antibody VRC01 (green) and residues N58 and Y59 in the HIV envelope protein GP120 (purple).<a class="footnoteRef" href="#fn30" id="fnref30"><sup>30</sup></a></figcaption>
</figure>

<p>Statistical potentials, in contrast to physics-based potentials, have the advantage of being fast to compute, of accounting implicitly of complex effects and being less sensitive to small changes in the protein structure.<a class="footnoteRef" href="#fn31" id="fnref31"><sup>31</sup></a> These energy functions are <a href=":Image:knowledge_based_potential.png" title="wikilink">based on deriving energy values</a> from frequency of appearance on a structural database.</p>

<p>Protein design, however, has requirements that can sometimes be limited in molecular mechanics force-fields. Molecular mechanics force-fields, which have been used mostly in molecular dynamics simulations, are optimized for the simulation of single sequences, but protein design searches through many conformations of many sequences. Thus, molecular mechanics force-fields must be tailored for protein design. In practice, protein design energy functions frequently incorporate both statistical terms and physics-based terms. For example, the Rosetta energy function, one of the most-used energy functions, incorporates physics-based energy terms originating in the CHARMM energy function, as well as statistical energy terms, such as rotamer probability and knowledge-based electrostatics. Typically, energy functions are highly customized between laboratories, and specifically tailored for every design.<a class="footnoteRef" href="#fn32" id="fnref32"><sup>32</sup></a></p>
<h4 id="challenges-for-effective-protein-design-energy-functions">Challenges for effective protein design energy functions</h4>

<p>Water makes up a majority of the molecules surrounding proteins and is the main driver of protein structure. Thus, modeling of the interaction between water and protein is a necessity in protein design. The number of water molecules that interact with a protein at any given time, however, is enormous and each one has a large number of degrees of freedom and interaction partners. Protein design programs, instead, model the majority of water molecules as a continuum, modeling both the hydrophobic effect and solvation polarization.<a class="footnoteRef" href="#fn33" id="fnref33"><sup>33</sup></a></p>

<p>Individual water molecules, however, can sometimes have a crucial structural role in the core of proteins, as well as in protein-protein or protein-ligand interactions. Failing to model such waters can result in mispredictions of the optimal sequence of a protein-protein interface. As an alternative, water molecules can be added to rotamers.<a class="footnoteRef" href="#fn34" id="fnref34"><sup>34</sup></a></p>
<h2 id="protein-design-as-an-optimization-problem">Protein design as an optimization problem</h2>
<figure><b>(Figure)</b>
<figcaption>This animation illustrates the complexity of a protein design search. A typical protein design search compares all the rotamer-conformations from all possible mutations at all residues. In this example, the residues Phe36 and His 106 are allowed to mutate to, respectively, the amino acids Tyr and Asn. Phe and Tyr have 4 rotamers each in the rotamer library, while Asn and His have 7 and 8 rotamers, respectively, in the rotamer library (from the Richardson's penultimate rotamer library<a class="footnoteRef" href="#fn35" id="fnref35"><sup>35</sup></a>) . The animation loops through all (4 + 4) x (7 + 8) = 120 possibilities. The structure shown is that of myoglobin, PDB id: 1mbn.</figcaption>
</figure>

<p>The goal of protein design is to find a protein sequence that will fold to a target structure. A protein design algorithm must, therefore, search all the conformations of each sequence, with respect to the target fold, and rank sequences according to the lowest-energy conformation of each one, as determined by the protein design energy function. Thus, a typical input to the protein design algorithm is the target fold, the sequence space, the structural flexibility, and the energy function, while the output is one or more sequences that are predicted to fold stably to the target structure.</p>

<p>The number of candidate protein sequences, however, grows exponentially with the number of protein residues; for example, there are 20<sup>100</sup> protein sequences of length 100. Furthermore, even if amino acid side-chain conformations are limited to a few rotamers (see <a href="#Structural_flexibility" title="wikilink">#Structural flexibility</a>), this results in an exponential number of conformations for each sequence. Thus, in our 100 residue protein, and assuming that each amino acid has exactly 10 rotamers, a search algorithm that searches this space will have to search over 200<sup>100</sup> protein conformations.</p>

<p>The most common energy functions can be decomposed into pairwise terms between rotamers and amino acid types, which casts the problem as a combinatorial one, and powerful optimization algorithms can be used to solve it. In those cases, the total energy of each conformation belonging to each sequence can be formulated as a sum of individual and pairwise terms between residue positions. If a designer is interested only in the best sequence, the protein design algorithm only requires the lowest-energy conformation of the lowest-energy sequence. In these cases, the amino acid identity of each rotamer can be ignored and all rotamers belonging to different amino acids can be treated the same. Let <var>r</var><sub><var>i</var></sub> be a rotamer at residue position <var>i</var> in the protein chain, and <var>E(<var>r</var><sub><var>i</var></sub>)</var> the potential energy between the internal atoms of the rotamer. Let <var>E</var>(<var>r</var><sub><var>i</var></sub>, <var>r</var><sub><var>j</var></sub>) be the potential energy between <var>r</var><sub><var>i</var></sub> and rotamer <var>r</var><sub><var>j</var></sub> at residue position <var>j</var>. Then, we define the optimization problem as one of finding the conformation of minimum energy (<var>E</var><sub><var>T</var></sub>):</p>

<p>The problem of minimizing <var>E<sub>T</sub></var> is an <a class="uri" href="NP-hard" title="wikilink">NP-hard</a> problem.<a class="footnoteRef" href="#fn36" id="fnref36"><sup>36</sup></a><a class="footnoteRef" href="#fn37" id="fnref37"><sup>37</sup></a><a class="footnoteRef" href="#fn38" id="fnref38"><sup>38</sup></a> Even though the class of problems is NP-hard, in practice many instances of protein design can be solved exactly or optimized satisfactorily through heuristic methods.</p>
<h2 id="algorithms">Algorithms</h2>

<p>Several algorithms have been developed specifically for the protein design problem. These algorithms can be divided into two broad classes: exact algorithms, such as <a href="Dead-end_elimination" title="wikilink">Dead-end elimination</a>, that do not have <a href="Run_time_(program_lifecycle_phase)" title="wikilink">runtime</a> guarantees but guarantee the quality of the solution; and <a href="Heuristic_(computer_science)" title="wikilink">heuristic</a> algorithms, such as Monte Carlo, that are faster than exact algorithms but have no guarantees on the optimality of the results. Exact algorithms guarantee that the optimization process produced the optimal according to the protein design model. Thus, if the predictions of exact algorithms fail when these are experimentally validated, then the source of error can be attributed to the energy function, the allowed flexibility, the sequence space or the target structure (e.g., if it cannot be designed for) <a class="footnoteRef" href="#fn39" id="fnref39"><sup>39</sup></a></p>

<p>Some protein design algorithms are listed below. Although these algorithms address only the most basic formulation of the protein design problem, Equation (), when the optimization goal changes because designers introduce improvements and extensions to the protein design model, such as improvements to the structural flexibility allowed (e.g., protein backbone flexibility) or the incorporation of sophisticated energy terms, many of the extensions on protein design that improve modeling are built on top of these algorithms. For example, Rosetta Design incorporates sophisticated energy terms, as well as backbone flexibility using Monte Carlo as the underlying optimization algorithm. OSPREY's algorithms build upon the Dead-End Elimination algorithm and A* to incorporate continuous backbone and side-chain movements. Therefore, these algorithms provide a good perspective on the different kinds of algorithms available for protein design.</p>
<h3 id="algorithms-with-mathematical-guarantees">Algorithms with mathematical guarantees</h3>
<h4 id="dead-end-elimination-dee">Dead-end elimination (DEE)</h4>

<p>'' Main article: <a href="Dead-end_elimination" title="wikilink">Dead-end elimination</a>''</p>

<p>The dead-end elimination algorithm reduces the search space of the problem iteratively by removing rotamers that that can be provably shown to not be part of the global lowest energy conformation (GMEC). On each iteration, the dead-end elimination algorithm compares all possible pairs of rotamers at each residue position, and removes each rotamer <var>r′<sub>i</sub></var> that can be shown to always be of higher energy than another rotamer <var>r<sub>i</sub></var> and is therefore not part of the GMEC:</p>

<p>

<math display="inline" id="Protein_design:0">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>E</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msubsup>
       <mi>r</mi>
       <mi>i</mi>
       <mo>′</mo>
      </msubsup>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msub>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <mi>j</mi>
       <mo>≠</mo>
       <mi>i</mi>
      </mrow>
     </msub>
     <mrow>
      <mrow>
       <msub>
        <mi>min</mi>
        <msub>
         <mi>r</mi>
         <mi>j</mi>
        </msub>
       </msub>
       <mi>E</mi>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <msubsup>
        <mi>r</mi>
        <mi>i</mi>
        <mo>′</mo>
       </msubsup>
       <mo>,</mo>
       <msub>
        <mi>r</mi>
        <mi>j</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>></mo>
   <mrow>
    <mrow>
     <mi>E</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>r</mi>
       <mi>i</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msub>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <mi>j</mi>
       <mo>≠</mo>
       <mi>i</mi>
      </mrow>
     </msub>
     <mrow>
      <mrow>
       <msub>
        <mi>max</mi>
        <msub>
         <mi>r</mi>
         <mi>j</mi>
        </msub>
       </msub>
       <mi>E</mi>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>r</mi>
        <mi>i</mi>
       </msub>
       <mo>,</mo>
       <msub>
        <mi>r</mi>
        <mi>j</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>E</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>r</ci>
        <ci>normal-′</ci>
       </apply>
       <ci>i</ci>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <neq></neq>
        <ci>j</ci>
        <ci>i</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <min></min>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>r</ci>
          <ci>j</ci>
         </apply>
        </apply>
        <ci>E</ci>
       </apply>
       <interval closure="open">
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>r</ci>
          <ci>normal-′</ci>
         </apply>
         <ci>i</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>r</ci>
         <ci>j</ci>
        </apply>
       </interval>
      </apply>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>E</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>r</ci>
       <ci>i</ci>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <neq></neq>
        <ci>j</ci>
        <ci>i</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <max></max>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>r</ci>
          <ci>j</ci>
         </apply>
        </apply>
        <ci>E</ci>
       </apply>
       <interval closure="open">
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>r</ci>
         <ci>i</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>r</ci>
         <ci>j</ci>
        </apply>
       </interval>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E(r^{\prime}_{i})+\sum_{j\neq i}\min_{r_{j}}E(r^{\prime}_{i},r_{j})>E(r_{i})+%
\sum_{j\neq i}\max_{r_{j}}E(r_{i},r_{j})
  </annotation>
 </semantics>
</math>

</p>

<p>Other powerful extensions to the Dead-End Elimination algorithm include the <a href="Dead-end_elimination#Pairs_elimination_criterion" title="wikilink">Pairs elimination criterion</a>, and the <a href="Dead-end_elimination#Generalization" title="wikilink">Generalized dead-end elimination criterion.</a> This algorithm has also been extended to handle continuous rotamers with provable guarantees.</p>

<p>Although the Dead-end elimination algorithm runs in polynomial time on each iteration, it cannot guarantee convergence. If, after a certain number of iterations, the dead-end elimination algorithm does not prune any more rotamers, then either rotamers have to be merged or another search algorithm must be used to search the remaining search space. In such cases, the dead-end elimination acts as a pre-filtering algorithm to reduce the search space, while other algorithms, such as A*, Monte Carlo, Linear Programming, or FASTER are used to search the remaining search space.<a class="footnoteRef" href="#fn40" id="fnref40"><sup>40</sup></a></p>
<h4 id="branch-and-bound-algorithms">Branch-and-bound algorithms</h4>

<p>The protein design conformational space can be represented as a <a href="Tree_(data_structure)" title="wikilink">tree</a>, where the protein residues are ordered in an arbitrary way, and the tree branches at each of the rotamers in a residue. <a href="Branch_and_bound" title="wikilink">Branch and bound</a> algorithms use this representation to efficiently explore the conformation tree: At each <em>branching</em>, branch and bound algorithms <em>bound</em> the conformation space and explore only the promising branches.<a class="footnoteRef" href="#fn41" id="fnref41"><sup>41</sup></a><a class="footnoteRef" href="#fn42" id="fnref42"><sup>42</sup></a><a class="footnoteRef" href="#fn43" id="fnref43"><sup>43</sup></a></p>

<p>A popular search algorithm for protein design is the <a href="A*_search_algorithm" title="wikilink">A* search algorithm</a>.<a class="footnoteRef" href="#fn44" id="fnref44"><sup>44</sup></a><a class="footnoteRef" href="#fn45" id="fnref45"><sup>45</sup></a> A* computes a lower-bound score on each partial tree path that lower bounds (with guarantees) the energy of each of the expanded rotamers. Each partial conformation is added to a priority queue and at each iteration the partial path with the lowest lower bound is popped from the queue and expanded. The algorithm stops once a full conformation has been enumerated and guarantees that the conformation is the optimal.</p>

<p>The A* score <var>f</var> in protein design consists of two parts, <var>f=g+h</var>. <var>g</var> is the exact energy of the rotamers that have already been assigned in the partial conformation. <var>h</var> is a lower bound on the energy of the rotamers that have not yet been assigned. Each is designed as follows, where <var>d</var> is the index of the last assigned residue in the partial conformation.</p>

<p>

<math display="inline" id="Protein_design:1">
 <semantics>
  <mrow>
   <mi>g</mi>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∑</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>d</mi>
    </msubsup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mi>E</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>r</mi>
         <mi>i</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>+</mo>
      <mrow>
       <msubsup>
        <mo largeop="true" symmetric="true">∑</mo>
        <mrow>
         <mi>j</mi>
         <mo>=</mo>
         <mrow>
          <mi>i</mi>
          <mo>+</mo>
          <mn>1</mn>
         </mrow>
        </mrow>
        <mi>d</mi>
       </msubsup>
       <mrow>
        <mi>E</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>r</mi>
          <mi>i</mi>
         </msub>
         <mo>,</mo>
         <msub>
          <mi>r</mi>
          <mi>j</mi>
         </msub>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>g</ci>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>d</ci>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>E</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>r</ci>
        <ci>i</ci>
       </apply>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <ci>j</ci>
          <apply>
           <plus></plus>
           <ci>i</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
        </apply>
        <ci>d</ci>
       </apply>
       <apply>
        <times></times>
        <ci>E</ci>
        <interval closure="open">
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>r</ci>
          <ci>i</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>r</ci>
          <ci>j</ci>
         </apply>
        </interval>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g=\sum_{i=1}^{d}(E(r_{i})+\sum_{j=i+1}^{d}E(r_{i},r_{j}))
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Protein_design:2">
 <semantics>
  <mrow>
   <mi>h</mi>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∑</mo>
     <mrow>
      <mi>j</mi>
      <mo>=</mo>
      <mrow>
       <mi>d</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </mrow>
     <mi>n</mi>
    </msubsup>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <msub>
       <mi>min</mi>
       <msub>
        <mi>r</mi>
        <mi>j</mi>
       </msub>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mrow>
         <mi>E</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <msub>
           <mi>r</mi>
           <mi>j</mi>
          </msub>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>+</mo>
        <mrow>
         <msubsup>
          <mo largeop="true" symmetric="true">∑</mo>
          <mrow>
           <mi>i</mi>
           <mo>=</mo>
           <mn>1</mn>
          </mrow>
          <mi>d</mi>
         </msubsup>
         <mrow>
          <mi>E</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <msub>
            <mi>r</mi>
            <mi>i</mi>
           </msub>
           <mo>,</mo>
           <msub>
            <mi>r</mi>
            <mi>j</mi>
           </msub>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
        </mrow>
        <mo>+</mo>
        <mrow>
         <msubsup>
          <mo largeop="true" symmetric="true">∑</mo>
          <mrow>
           <mi>k</mi>
           <mo>=</mo>
           <mrow>
            <mi>j</mi>
            <mo>+</mo>
            <mn>1</mn>
           </mrow>
          </mrow>
          <mi>n</mi>
         </msubsup>
         <mrow>
          <mrow>
           <msub>
            <mi>min</mi>
            <msub>
             <mi>r</mi>
             <mi>k</mi>
            </msub>
           </msub>
           <mi>E</mi>
          </mrow>
          <mrow>
           <mo stretchy="false">(</mo>
           <msub>
            <mi>r</mi>
            <mi>j</mi>
           </msub>
           <mo>,</mo>
           <msub>
            <mi>r</mi>
            <mi>k</mi>
           </msub>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>h</ci>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>j</ci>
        <apply>
         <plus></plus>
         <ci>d</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
      <ci>n</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <min></min>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>r</ci>
         <ci>j</ci>
        </apply>
       </apply>
       <apply>
        <plus></plus>
        <apply>
         <times></times>
         <ci>E</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>r</ci>
          <ci>j</ci>
         </apply>
        </apply>
        <apply>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <sum></sum>
           <apply>
            <eq></eq>
            <ci>i</ci>
            <cn type="integer">1</cn>
           </apply>
          </apply>
          <ci>d</ci>
         </apply>
         <apply>
          <times></times>
          <ci>E</ci>
          <interval closure="open">
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>r</ci>
            <ci>i</ci>
           </apply>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>r</ci>
            <ci>j</ci>
           </apply>
          </interval>
         </apply>
        </apply>
        <apply>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <sum></sum>
           <apply>
            <eq></eq>
            <ci>k</ci>
            <apply>
             <plus></plus>
             <ci>j</ci>
             <cn type="integer">1</cn>
            </apply>
           </apply>
          </apply>
          <ci>n</ci>
         </apply>
         <apply>
          <times></times>
          <apply>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <min></min>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <ci>r</ci>
             <ci>k</ci>
            </apply>
           </apply>
           <ci>E</ci>
          </apply>
          <interval closure="open">
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>r</ci>
            <ci>j</ci>
           </apply>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>r</ci>
            <ci>k</ci>
           </apply>
          </interval>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h=\sum_{j=d+1}^{n}[\min_{r_{j}}(E(r_{j})+\sum_{i=1}^{d}E(r_{i},r_{j})+\sum_{k=%
j+1}^{n}\min_{r_{k}}E(r_{j},r_{k}))]
  </annotation>
 </semantics>
</math>

</p>
<h4 id="optimization-as-an-integer-linear-program">Optimization as an integer linear program</h4>

<p>The problem of optimizing <var>E<sub>T</sub></var> (Equation ()) can be easily formulated as an <a href="integer_linear_program" title="wikilink">Integer programming</a> (ILP).<a class="footnoteRef" href="#fn46" id="fnref46"><sup>46</sup></a> One of the most powerful formulations uses binary variables to represent the presence of a rotamer and edges in the final solution, and constraints the solution to have exactly one rotamer for each residue and one pairwise interaction for each pair of residues:</p>

<p>

<math display="inline" id="Protein_design:3">
 <semantics>
  <mrow>
   <mrow>
    <mpadded lspace="5pt" width="+5pt">
     <mi>min</mi>
    </mpadded>
    <mrow>
     <msub>
      <mo largeop="true" symmetric="true">∑</mo>
      <mi>i</mi>
     </msub>
     <mrow>
      <msub>
       <mo largeop="true" symmetric="true">∑</mo>
       <msub>
        <mi>r</mi>
        <mi>i</mi>
       </msub>
      </msub>
      <mrow>
       <msub>
        <mi>E</mi>
        <mi>i</mi>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>r</mi>
         <mi>i</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
       <msub>
        <mi>q</mi>
        <mi>i</mi>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>r</mi>
         <mi>i</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>+</mo>
   <mrow>
    <msub>
     <mo largeop="true" symmetric="true">∑</mo>
     <mrow>
      <mi>j</mi>
      <mo>≠</mo>
      <mi>i</mi>
     </mrow>
    </msub>
    <mrow>
     <msub>
      <mo largeop="true" symmetric="true">∑</mo>
      <msub>
       <mi>r</mi>
       <mi>j</mi>
      </msub>
     </msub>
     <mrow>
      <msub>
       <mi>E</mi>
       <mrow>
        <mi>i</mi>
        <mi>j</mi>
       </mrow>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>r</mi>
        <mi>i</mi>
       </msub>
       <mo>,</mo>
       <msub>
        <mi>r</mi>
        <mi>j</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
      <msub>
       <mi>q</mi>
       <mrow>
        <mi>i</mi>
        <mi>j</mi>
       </mrow>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>r</mi>
        <mi>i</mi>
       </msub>
       <mo>,</mo>
       <msub>
        <mi>r</mi>
        <mi>j</mi>
       </msub>
       <mo rspace="4.2pt" stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <times></times>
     <min></min>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <ci>i</ci>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>r</ci>
         <ci>i</ci>
        </apply>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>E</ci>
         <ci>i</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>r</ci>
         <ci>i</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>q</ci>
         <ci>i</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>r</ci>
         <ci>i</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <neq></neq>
       <ci>j</ci>
       <ci>i</ci>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>r</ci>
        <ci>j</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>E</ci>
        <apply>
         <times></times>
         <ci>i</ci>
         <ci>j</ci>
        </apply>
       </apply>
       <interval closure="open">
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>r</ci>
         <ci>i</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>r</ci>
         <ci>j</ci>
        </apply>
       </interval>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>q</ci>
        <apply>
         <times></times>
         <ci>i</ci>
         <ci>j</ci>
        </apply>
       </apply>
       <interval closure="open">
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>r</ci>
         <ci>i</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>r</ci>
         <ci>j</ci>
        </apply>
       </interval>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ \min\sum_{i}\sum_{r_{i}}E_{i}(r_{i})q_{i}(r_{i})+\sum_{j\neq i}\sum_{r_{j}}E%
_{ij}(r_{i},r_{j})q_{ij}(r_{i},r_{j})\,
  </annotation>
 </semantics>
</math>

</p>

<p>s.t.</p>

<p>

<math display="inline" id="Protein_design:4">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mo largeop="true" symmetric="true">∑</mo>
     <msub>
      <mi>r</mi>
      <mi>i</mi>
     </msub>
    </msub>
    <mrow>
     <msub>
      <mi>q</mi>
      <mi>i</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>r</mi>
       <mi>i</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mo rspace="7.5pt">,</mo>
    <mrow>
     <mo>∀</mo>
     <mi>i</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>r</ci>
       <ci>i</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>q</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>r</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
    <list>
     <cn type="integer">1</cn>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <ci>i</ci>
     </apply>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{r_{i}}q_{i}(r_{i})=1,\ \forall i
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Protein_design:5">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mo largeop="true" symmetric="true">∑</mo>
     <msub>
      <mi>r</mi>
      <mi>j</mi>
     </msub>
    </msub>
    <mrow>
     <msub>
      <mi>q</mi>
      <mrow>
       <mi>i</mi>
       <mi>j</mi>
      </mrow>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>r</mi>
       <mi>i</mi>
      </msub>
      <mo>,</mo>
      <msub>
       <mi>r</mi>
       <mi>j</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>q</mi>
      <mi>i</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>r</mi>
       <mi>i</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mo>∀</mo>
     <mi>i</mi>
    </mrow>
    <mo>,</mo>
    <msub>
     <mi>r</mi>
     <mi>i</mi>
    </msub>
    <mo>,</mo>
    <mi>j</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>r</ci>
       <ci>j</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>q</ci>
       <apply>
        <times></times>
        <ci>i</ci>
        <ci>j</ci>
       </apply>
      </apply>
      <interval closure="open">
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>r</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>r</ci>
        <ci>j</ci>
       </apply>
      </interval>
     </apply>
    </apply>
    <list>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>q</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>r</ci>
       <ci>i</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>r</ci>
      <ci>i</ci>
     </apply>
     <ci>j</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{r_{j}}q_{ij}(r_{i},r_{j})=q_{i}(r_{i}),\forall i,r_{i},j
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Protein_design:6">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>q</mi>
     <mi>i</mi>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>q</mi>
     <mrow>
      <mi>i</mi>
      <mi>j</mi>
     </mrow>
    </msub>
   </mrow>
   <mo>∈</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mn>1</mn>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <list>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>q</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>q</ci>
      <apply>
       <times></times>
       <ci>i</ci>
       <ci>j</ci>
      </apply>
     </apply>
    </list>
    <set>
     <cn type="integer">0</cn>
     <cn type="integer">1</cn>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q_{i},q_{ij}\in\{0,1\}
  </annotation>
 </semantics>
</math>

</p>

<p>ILP solvers, such as <a class="uri" href="CPLEX" title="wikilink">CPLEX</a>, can compute the exact optimal solution for large instances of protein design problems. These solvers use a <a href="linear_programming_relaxation" title="wikilink">linear programming relaxation</a> of the problem, where <var>q<sub>i</sub></var> and <var>q<sub>ij</sub></var> are allowed to take continuous values, in combination with a <a href="branch_and_cut" title="wikilink">branch and cut</a> algorithm to search only a small portion of the conformation space for the optimal solution. ILP solvers have been shown to solve many instances of the side-chain placement problem.<a class="footnoteRef" href="#fn47" id="fnref47"><sup>47</sup></a></p>
<h4 id="message-passing-based-approximations-to-the-linear-programming-dual">Message-passing based approximations to the linear programming dual</h4>

<p>ILP solvers depend on linear programming (LP) algorithms, such as the <a href="Simplex_algorithm" title="wikilink">Simplex</a> or <a href="barrier_function" title="wikilink">barrier</a>-based methods to perform the LP relaxation at each branch. These LP algorithms were developed as general-purpose optimization methods and are not optimized for the protein design problem (Equation ()). In consequence, the LP relaxation becomes the bottleneck of ILP solvers when the problem size is large.<a class="footnoteRef" href="#fn48" id="fnref48"><sup>48</sup></a> Recently, several alternatives based on <a href="belief_propagation" title="wikilink">message-passing algorithms</a> have been designed specifically for the optimization of the LP relaxation of the protein design problem. These algorithms can approximate both the <a href="Duality_(optimization)" title="wikilink">dual</a> or the <a href="Duality_(optimization)" title="wikilink">primal</a> instances of the integer programming, but in order to maintain guarantees on optimality, they are most useful when used to approximate the dual of the protein design problem, because approximating the dual guarantees that no solutions are missed. Message-passing based approximations include the <em>tree reweighted max-product message passing</em> algorithm,<a class="footnoteRef" href="#fn49" id="fnref49"><sup>49</sup></a><a class="footnoteRef" href="#fn50" id="fnref50"><sup>50</sup></a> and the <em>message passing linear programming</em> algorithm.<a class="footnoteRef" href="#fn51" id="fnref51"><sup>51</sup></a></p>
<h3 id="optimization-algorithms-without-guarantees">Optimization algorithms without guarantees</h3>
<h4 id="monte-carlo-and-simulated-annealing">Monte Carlo and simulated annealing</h4>

<p>Monte Carlo is one of the most widely used algorithms for protein design. In its simplest form, a Monte Carlo algorithm selects a residue at random, and in that residue a randomly chosen rotamer (of any amino acid) is evaluated.<a class="footnoteRef" href="#fn52" id="fnref52"><sup>52</sup></a> The new energy of the protein, <var>E</var><sub>new</sub> is compared against the old energy <var>E</var><sub>old</sub> and the new rotamer is <em>accepted</em> with a probability of:</p>

<p>

<math display="inline" id="Protein_design:7">
 <semantics>
  <mrow>
   <mrow>
    <mi>p</mi>
    <mo>=</mo>
    <msup>
     <mi>e</mi>
     <mrow>
      <mo>-</mo>
      <mi>β</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>E</mi>
        <mtext>new</mtext>
       </msub>
       <mo>-</mo>
       <msub>
        <mi>E</mi>
        <mtext>old</mtext>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </msup>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>p</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>e</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <minus></minus>
      <csymbol cd="unknown">β</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>E</ci>
        <mtext>new</mtext>
       </apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>E</ci>
        <mtext>old</mtext>
       </apply>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p=e^{-\beta(E_{\text{new}}-E_{\text{old}}))},
  </annotation>
 </semantics>
</math>

</p>

<p>where <var>β</var> is the <a href="Boltzmann_constant" title="wikilink">Boltzmann constant</a> and the temperature <var>T</var> can be chosen such that in the initial rounds it is high and it is slowly <a href="simulated_annealing" title="wikilink">annealed</a> to overcome local minima.<a class="footnoteRef" href="#fn53" id="fnref53"><sup>53</sup></a></p>
<h4 id="faster">FASTER</h4>

<p>The FASTER algorithm uses a combination of deterministic and stochastic criteria to optimize amino acid sequences. FASTER first uses DEE to eliminate rotamers that are not part of the optimal solution. Then, a series of iterative steps optimize the rotamer assignment.<a class="footnoteRef" href="#fn54" id="fnref54"><sup>54</sup></a><a class="footnoteRef" href="#fn55" id="fnref55"><sup>55</sup></a></p>
<h4 id="belief-propagation-for-protein-design">Belief propagation for protein design</h4>

<p>In <a href="belief_propagation" title="wikilink">belief propagation</a> for protein design, the algorithm exchanges messages that describe the <em>belief</em> that each residue has about the probability of each rotamer in neighboring residues. The algorithm updates messages on every iteration and iterates until convergence or until a fixed number of iterations. Convergence is not guaranteed in protein design. The message <var>m</var><sub><var>i→ j</var></sub><var>(r<sub>j</sub></var> that a residue <var>i</var> sends to every rotamer <var>(r<sub>j</sub></var> at neighboring residue <var>j</var> is defined as:</p>

<p>

<math display="inline" id="Protein_design:8">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>m</mi>
     <mrow>
      <mi>i</mi>
      <mo>→</mo>
      <mi>j</mi>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>r</mi>
      <mi>j</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>max</mi>
      <msub>
       <mi>r</mi>
       <mi>i</mi>
      </msub>
     </msub>
     <mrow>
      <mo maxsize="160%" minsize="160%">(</mo>
      <msup>
       <mi>e</mi>
       <mfrac>
        <mrow>
         <mrow>
          <mo>-</mo>
          <mrow>
           <msub>
            <mi>E</mi>
            <mi>i</mi>
           </msub>
           <mrow>
            <mo stretchy="false">(</mo>
            <msub>
             <mi>r</mi>
             <mi>i</mi>
            </msub>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
         </mrow>
         <mo>-</mo>
         <mrow>
          <msub>
           <mi>E</mi>
           <mrow>
            <mi>i</mi>
            <mi>j</mi>
           </mrow>
          </msub>
          <mrow>
           <mo stretchy="false">(</mo>
           <msub>
            <mi>r</mi>
            <mi>i</mi>
           </msub>
           <mo>,</mo>
           <msub>
            <mi>r</mi>
            <mi>j</mi>
           </msub>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
        </mrow>
        <mi>T</mi>
       </mfrac>
      </msup>
      <mo maxsize="160%" minsize="160%">)</mo>
     </mrow>
    </mrow>
    <mrow>
     <msub>
      <mo largeop="true" symmetric="true">∏</mo>
      <mrow>
       <mi>k</mi>
       <mo>∈</mo>
       <mrow>
        <mrow>
         <mi>N</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>i</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>\</mo>
        <mi>j</mi>
       </mrow>
      </mrow>
     </msub>
     <msub>
      <mi>m</mi>
      <mrow>
       <mi>k</mi>
       <mo>→</mo>
       <mrow>
        <mi>i</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>r</mi>
          <mi>i</mi>
         </msub>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>m</ci>
      <apply>
       <ci>normal-→</ci>
       <ci>i</ci>
       <ci>j</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>r</ci>
      <ci>j</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <max></max>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>r</ci>
        <ci>i</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>e</ci>
       <apply>
        <divide></divide>
        <apply>
         <minus></minus>
         <apply>
          <minus></minus>
          <apply>
           <times></times>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>E</ci>
            <ci>i</ci>
           </apply>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>r</ci>
            <ci>i</ci>
           </apply>
          </apply>
         </apply>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>E</ci>
           <apply>
            <times></times>
            <ci>i</ci>
            <ci>j</ci>
           </apply>
          </apply>
          <interval closure="open">
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>r</ci>
            <ci>i</ci>
           </apply>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>r</ci>
            <ci>j</ci>
           </apply>
          </interval>
         </apply>
        </apply>
        <ci>T</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <csymbol cd="latexml">product</csymbol>
       <apply>
        <in></in>
        <ci>k</ci>
        <apply>
         <ci>normal-\</ci>
         <apply>
          <times></times>
          <ci>N</ci>
          <ci>i</ci>
         </apply>
         <ci>j</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>m</ci>
       <apply>
        <ci>normal-→</ci>
        <ci>k</ci>
        <apply>
         <times></times>
         <ci>i</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>r</ci>
          <ci>i</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m_{i\to j}(r_{j})=\max_{r_{i}}\Big(e^{\frac{-E_{i}(r_{i})-E_{ij}(r_{i},r_{j})}%
{T}}\Big)\prod_{k\in N(i)\backslash j}m_{k\to i(r_{i})}
  </annotation>
 </semantics>
</math>

</p>

<p>Both max-product and sum-product belief propagation have been used to optimize protein design.</p>
<h2 id="applications-and-examples-of-designed-proteins">Applications and examples of designed proteins</h2>
<h3 id="enzyme-design">Enzyme design</h3>

<p>The design of new <a class="uri" href="enzymes" title="wikilink">enzymes</a> is an application of protein design with enormous bioengineering and biomedical applications. In general, designing a protein structure can be different from designing an enzyme, because the design of enzymes must consider many states involved in the <a href="enzyme_catalysis" title="wikilink">catalytic mechanism</a>. Protein design, however, is a prerequisite of <em>de novo</em> enzyme design because, at the very least, the design of catalysts requires a scaffold in which the catalytic mechanism can be inserted.<a class="footnoteRef" href="#fn56" id="fnref56"><sup>56</sup></a></p>

<p>Enormous progress in <em>de novo</em> enzyme design and enzyme redesign was made during the first decade of the 21st century. In three major studies, David Baker and co-workers <em>de novo</em> designed enzymes for the <a href="aldol_reaction" title="wikilink">retro-Aldol</a> reaction,<a class="footnoteRef" href="#fn57" id="fnref57"><sup>57</sup></a> a Kemp-elimination reaction,<a class="footnoteRef" href="#fn58" id="fnref58"><sup>58</sup></a> and for the <a href="Diels-Alder_reaction" title="wikilink">Diels-Alder reaction</a>.<a class="footnoteRef" href="#fn59" id="fnref59"><sup>59</sup></a> Furthermore, Stephen Mayo and co-workers developed an iterative method to design the most efficient known enzyme for the Kemp-elimination reaction.<a class="footnoteRef" href="#fn60" id="fnref60"><sup>60</sup></a> In addition, in the laboratory of <a href="Bruce_Donald" title="wikilink">Bruce Donald</a>, computational protein design was used to switch the specificity of one of the <a href="protein_domain" title="wikilink">protein domains</a> of the <a href="nonribosomal_peptide" title="wikilink">nonribosomal peptide synthetase</a> that produces <a href="Gramicidin_S" title="wikilink">Gramicidin S</a>, from its natural substrate <a href="phe" title="wikilink">phenylalanine</a> to other noncognate substrates including charged amino acids; the redesigned enzymes had activities close to those of the wild-type.<a class="footnoteRef" href="#fn61" id="fnref61"><sup>61</sup></a></p>
<h3 id="design-for-affinity">Design for affinity</h3>

<p><a href="Protein–protein_interaction" title="wikilink">Protein–protein interactions</a> are involved in most biological processes. Many of the most difficult-to-treat diseases, such as <a class="uri" href="Alzheimer" title="wikilink">Alzheimer</a>'s, many forms of <a href="p53" title="wikilink">cancer</a> and <a class="uri" href="HIV" title="wikilink">HIV</a> infection involve protein-protein interactions. To treat these diseases, it is, therefore, desirable to design protein or protein-like therapeutics that bind one of the partners of the interaction and, therefore, disrupt the disease-causing interaction. This requires the design of protein-therapeutics for <em>affinity</em> toward its partner.</p>

<p>Protein-protein interactions can be designed using protein design algorithms because the principles that rule protein stability also rule protein-protein binding. Protein-protein interaction design, however, presents challenges not commonly present in protein design. One of the most important challenges is that, in general, the interfaces between proteins are more polar than protein cores, and binding involves a tradeoff between desolvation and hydrogen bond formation.<a class="footnoteRef" href="#fn62" id="fnref62"><sup>62</sup></a> To overcome this challenge, Bruce Tidor and co-workers developed a method to improve the affinity of antibodies by focusing on electrostatic contributions. They found that, for the antibodies designed in the study, reducing the desolvation costs of the residues in the interface increased the affinity of the binding pair.<a class="footnoteRef" href="#fn63" id="fnref63"><sup>63</sup></a><a class="footnoteRef" href="#fn64" id="fnref64"><sup>64</sup></a><a class="footnoteRef" href="#fn65" id="fnref65"><sup>65</sup></a></p>

<p>The design of protein-protein interfaces for affinity has become a productive area of protein design research. Brian Kuhlman and co-workers redesigned a native monomeric protein into a homodimeric protein by designing beta-sheets between the two proteins.<a class="footnoteRef" href="#fn66" id="fnref66"><sup>66</sup></a><a class="footnoteRef" href="#fn67" id="fnref67"><sup>67</sup></a> In 2010 Chris Floudas and co-workers computationally designed peptide inhibitors of HIV entry and successfully validated their inhibitory capacity in cell cultures.<a class="footnoteRef" href="#fn68" id="fnref68"><sup>68</sup></a> The Donald laboratory designed peptide inhibitors of a protein-protein interaction involved in <a href="cystic_fibrosis" title="wikilink">cystic fibrosis</a>, with potential therapeutic applications; these inhibitors formed a beta-sheet with the pdz-binding domain of the inhibited protein.<a class="footnoteRef" href="#fn69" id="fnref69"><sup>69</sup></a> Recently, Amit Jaiswal and others have developed 30 designer peptides based on the affinity of amino-acids for each other, in order to inhibit telomerase recruitment towards telomeres.<a class="footnoteRef" href="#fn70" id="fnref70"><sup>70</sup></a></p>
<h4 id="scoring-binding-predictions">Scoring binding predictions</h4>

<p>Protein design energy functions must be adapted to score binding predictions because binding involves a trade-off between the lowest-<a href="Thermodynamic_free_energy" title="wikilink">energy</a> conformations of the free proteins (<var>E<sub>P</sub></var> and <var>E<sub>L</sub></var>) and the lowest-energy conformation of the bound complex (<var>E<sub>PL</sub></var>):</p>

<p>

<math display="inline" id="Protein_design:9">
 <semantics>
  <mrow>
   <msub>
    <mi mathvariant="normal">Δ</mi>
    <mi>G</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>E</mi>
     <mrow>
      <mi>P</mi>
      <mi>L</mi>
     </mrow>
    </msub>
    <mo>-</mo>
    <msub>
     <mi>E</mi>
     <mi>P</mi>
    </msub>
    <mo>-</mo>
    <msub>
     <mi>E</mi>
     <mi>L</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-Δ</ci>
     <ci>G</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>E</ci>
      <apply>
       <times></times>
       <ci>P</ci>
       <ci>L</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>E</ci>
      <ci>P</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>E</ci>
      <ci>L</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta_{G}=E_{PL}-E_{P}-E_{L}
  </annotation>
 </semantics>
</math>

.</p>

<p>The K* algorithm approximates the binding constant of the algorithm by including conformational entropy into the free energy calculation. The K* algorithm considers only the lowest-energy conformations of the free and bound complexes (denoted by the sets <var>P</var>, <var>L</var>, and <var>PL</var>) to approximate the partition functions of each complex:<a class="footnoteRef" href="#fn71" id="fnref71"><sup>71</sup></a> 

<math display="inline" id="Protein_design:10">
 <semantics>
  <mrow>
   <msup>
    <mi>K</mi>
    <mo>*</mo>
   </msup>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mstyle displaystyle="false">
      <munder>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mrow>
        <mi>x</mi>
        <mo>∈</mo>
        <mrow>
         <mi>P</mi>
         <mi>L</mi>
        </mrow>
       </mrow>
      </munder>
     </mstyle>
     <msup>
      <mi>e</mi>
      <mrow>
       <mo>-</mo>
       <mrow>
        <mrow>
         <mrow>
          <mi>E</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>x</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo>/</mo>
         <mi>R</mi>
        </mrow>
        <mi>T</mi>
       </mrow>
      </mrow>
     </msup>
    </mrow>
    <mrow>
     <mstyle displaystyle="false">
      <munder>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mrow>
        <mi>x</mi>
        <mo>∈</mo>
        <mi>P</mi>
       </mrow>
      </munder>
     </mstyle>
     <mrow>
      <msup>
       <mi>e</mi>
       <mrow>
        <mo>-</mo>
        <mrow>
         <mrow>
          <mrow>
           <mi>E</mi>
           <mrow>
            <mo stretchy="false">(</mo>
            <mi>x</mi>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
          <mo>/</mo>
          <mi>R</mi>
         </mrow>
         <mi>T</mi>
        </mrow>
       </mrow>
      </msup>
      <mrow>
       <mstyle displaystyle="false">
        <munder>
         <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
         <mrow>
          <mi>x</mi>
          <mo>∈</mo>
          <mi>L</mi>
         </mrow>
        </munder>
       </mstyle>
       <msup>
        <mi>e</mi>
        <mrow>
         <mo>-</mo>
         <mrow>
          <mrow>
           <mrow>
            <mi>E</mi>
            <mrow>
             <mo stretchy="false">(</mo>
             <mi>x</mi>
             <mo stretchy="false">)</mo>
            </mrow>
           </mrow>
           <mo>/</mo>
           <mi>R</mi>
          </mrow>
          <mi>T</mi>
         </mrow>
        </mrow>
       </msup>
      </mrow>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>K</ci>
     <times></times>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <in></in>
        <ci>x</ci>
        <apply>
         <times></times>
         <ci>P</ci>
         <ci>L</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>e</ci>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <apply>
          <divide></divide>
          <apply>
           <times></times>
           <ci>E</ci>
           <ci>x</ci>
          </apply>
          <ci>R</ci>
         </apply>
         <ci>T</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <in></in>
        <ci>x</ci>
        <ci>P</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>e</ci>
        <apply>
         <minus></minus>
         <apply>
          <times></times>
          <apply>
           <divide></divide>
           <apply>
            <times></times>
            <ci>E</ci>
            <ci>x</ci>
           </apply>
           <ci>R</ci>
          </apply>
          <ci>T</ci>
         </apply>
        </apply>
       </apply>
       <apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <in></in>
          <ci>x</ci>
          <ci>L</ci>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>e</ci>
         <apply>
          <minus></minus>
          <apply>
           <times></times>
           <apply>
            <divide></divide>
            <apply>
             <times></times>
             <ci>E</ci>
             <ci>x</ci>
            </apply>
            <ci>R</ci>
           </apply>
           <ci>T</ci>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K^{*}=\frac{\sum\limits_{x\in PL}e^{-E(x)/RT}}{\sum\limits_{x\in P}e^{-E(x)/RT%
}\sum\limits_{x\in L}e^{-E(x)/RT}}
  </annotation>
 </semantics>
</math>

</p>
<h3 id="design-for-specificity">Design for specificity</h3>

<p>The design of protein-protein interactions must be highly specific because proteins can interact with a large number of proteins; successful design requires selective binders. Thus, protein design algorithms must be able to distinguish between on-target (or <em>positive design</em>) and off-target binding (or <em>negative design</em>).<a class="footnoteRef" href="#fn72" id="fnref72"><sup>72</sup></a><a class="footnoteRef" href="#fn73" id="fnref73"><sup>73</sup></a> One of the most prominent examples of design for specificity is the design of specific <a href="bZIP_domain" title="wikilink">bZIP</a>-binding peptides by Amy Keating and co-workers for 19 out of the 20 bZIP families; 8 of these peptides were specific for their intended partner over competing peptides.<a class="footnoteRef" href="#fn74" id="fnref74"><sup>74</sup></a><a class="footnoteRef" href="#fn75" id="fnref75"><sup>75</sup></a><a class="footnoteRef" href="#fn76" id="fnref76"><sup>76</sup></a> In addition, positive and negative design was also used by Anderson and co-workers to predict mutations in the active site of a drug target that conferred resistance to a new drug; positive design was used to maintain wild-type activity, while negative design was used to disrupt binding of the drug.<a class="footnoteRef" href="#fn77" id="fnref77"><sup>77</sup></a> Recent computational redesign by Costas Maranas and co-workers was also capable of experimentally switching the <a href="cofactor_(biochemistry)" title="wikilink">cofactor</a> specificity of <em>Candida boidinii</em> xylose reductase from <a href="Nicotinamide_adenine_dinucleotide_phosphate" title="wikilink">NADPH</a> to <a href="Nicotinamide_adenine_dinucleotide" title="wikilink">NADH</a>.<a class="footnoteRef" href="#fn78" id="fnref78"><sup>78</sup></a></p>
<h3 id="protein-resurfacing">Protein resurfacing</h3>

<p>Protein resurfacing consists of designing a protein's surface while preserving the overall fold, core, and boundary regions of the protein intact. Protein resurfacing is especially useful to alter the binding of a protein to other proteins. One of the most important applications of protein resurfacing was the design of the RSC3 probe to select broadly neutralizing HIV antibodies at the NIH Vaccine Research Center. First, residues outside of the binding interface between the gp120 HIV envelope protein and the previously discovered b12-antibody were selected to be designed. Then, the sequence spaced was selected based on evolutionary information, solubility, similarity with the wild-type, and other considerations. Then the RosettaDesign software was used to find optimal sequences in the selected sequence space. RSC3 was later used to discover the broadly neutralizing antibody VRC01 in the serum of a long-term HIV-infected non-progressor individual.<a class="footnoteRef" href="#fn79" id="fnref79"><sup>79</sup></a></p>
<h3 id="design-of-globular-proteins">Design of globular proteins</h3>

<p><a href="Globular_protein" title="wikilink">Globular proteins</a> are proteins that contain a hydrophobic core and a hydrophilic surface. Globular proteins frequently assume a stable structure, unlike <a href="fibrous_protein" title="wikilink">fibrous proteins</a>, which have multiple conformations. The three-dimensional structure of globular proteins is typically easier to determine through <a href="X-ray_crystallography" title="wikilink">X-ray crystallography</a> and <a href="nuclear_magnetic_resonance" title="wikilink">nuclear magnetic resonance</a> than both fibrous proteins and <a href="membrane_protein" title="wikilink">membrane proteins</a>, which makes globular proteins more attractive for protein design than the other types of proteins. In fact, most successful protein designs have involved globular proteins. Both <a href="#Sequence_space" title="wikilink">RSD-1</a>, and <a href="#Target_structure" title="wikilink">Top7</a> were <em>de novo</em> designs of globular proteins. Five more protein structures were designed, synthesized, and verified in 2012 by the Baker group. These new proteins serve no biological function, but the structures are intended to act as building-blocks that can be expanded to incorporate functional active sites. The structures were found computationally by using new heuristics based on analyzing the connecting loops between parts of the sequence that specify secondary structures.<a class="footnoteRef" href="#fn80" id="fnref80"><sup>80</sup></a></p>
<h3 id="design-of-transmembrane-proteins">Design of transmembrane proteins</h3>

<p>Membrane proteins are inherently hard to design, in large part because it is hard to validate the designs experimentally for several reasons. Membrane proteins are hard to purify. Their structure is hard to characterize because they adopt their native conformation only in the presence of a membrane. Crystallization is inherently hard, and NMR studies of membrane proteins can fail because of their size.</p>
<h3 id="design-of-fibrous-proteins">Design of fibrous proteins</h3>

<p><a href="Scleroprotein" title="wikilink">Fibrous proteins</a>, such as <a class="uri" href="elastin" title="wikilink">elastin</a> or <a class="uri" href="collagen" title="wikilink">collagen</a>, typically have no single structure. It is believed, however, that the fibrous proteins do not have random folds, and instead they have folds defined within an ensemble of structures. This ensemble defines their behavior. Therefore, in theory it is possible to rationally design fibrous proteins by selecting a sequence that will populate a specific ensemble.</p>
<h3 id="other-applications">Other applications</h3>

<p>One of the most desirable applications for protein design is for <a class="uri" href="biosensors" title="wikilink">biosensors</a>, proteins that will sense the presence of specific compounds. Some attempts in the design of biosensors include sensors for unnatural molecules including <a class="uri" href="TNT" title="wikilink">TNT</a>.<a class="footnoteRef" href="#fn81" id="fnref81"><sup>81</sup></a> More recently, Kuhlman and co-workers designed a biosensor of the <a href="p21_activated_kinase" title="wikilink">PAK1</a>.<a class="footnoteRef" href="#fn82" id="fnref82"><sup>82</sup></a></p>
<h2 id="role-of-other-protein-engineering-tools-in-protein-design">Role of other protein engineering tools in protein design</h2>

<p>Protein design is one of the tools available for protein engineering. When proteins are designed using rational protein design, it is frequently the case that other protein engineering tools are used as part of the process. For example, when David Baker and co-workers designed <em>de novo</em> enzymes for the Kemp-elimination catalysis, these enzymes were then optimized using <a href="directed_evolution" title="wikilink">directed evolution</a> to optimize the catalysts.<a class="footnoteRef" href="#fn83" id="fnref83"><sup>83</sup></a> In fact, directed evolution is considered by Baker's group to be a necessary part of enzyme design, in order to identify sequence features missed by the protein design algorithms.<a class="footnoteRef" href="#fn84" id="fnref84"><sup>84</sup></a></p>
<h2 id="software">Software</h2>

<p><strong>EGAD: A Genetic Algorithm for protein Design</strong>.<a class="footnoteRef" href="#fn85" id="fnref85"><sup>85</sup></a> A free, open-source software package for protein design and prediction of <a class="uri" href="mutation" title="wikilink">mutation</a> effects on protein-folding stabilities and binding affinities. EGAD can also consider multiple structures simultaneously for designing specific binding proteins or locking proteins into specific conformational states. In addition to natural protein residues, EGAD can also consider free-moving ligands with or without rotatable bonds. EGAD can be used with single or multiple processors.</p>

<p><a href="http://onlinelibrary.wiley.com/doi/10.1002/pro.227/abstract"><strong>Iterative Protein Redesign and Optimization</strong></a>. IPRO redesigns proteins to increase or give specificity to native or novel substrates and cofactors. This is done by repeatedly randomly perturbing the backbones of the proteins around specified design positions, identifying the lowest-energy combination of rotamers, and determining whether the new design has a lower binding energy than previous ones. The iterative nature of this process allows IPRO to make additive mutations to the protein sequence that collectively improve the specificity toward the desired substrates and/or cofactors. Experimental testing of predictions by IPRO successfully switched the cofactor preference of <em>Candida boidinii</em> xylose reductase from NADPH to NADH.<a class="footnoteRef" href="#fn86" id="fnref86"><sup>86</sup></a></p>

<p><a href="http://www.cs.duke.edu/donaldlab/osprey.php"><strong>OSPREY</strong></a> A free, open-source, actively developed protein design program with an emphasis on continuous protein flexibility for the side-chains and backbone, modeling of proteins as thermodynamic ensembles and algorithms with mathematical guarantees on the input. OSPREY has been used in several prospective applications with biomedical relevance, including: enzymes-redesign toward non-cognate substrates,<a class="footnoteRef" href="#fn87" id="fnref87"><sup>87</sup></a> prospective prediction of resistance mutations against novel drugs,<a class="footnoteRef" href="#fn88" id="fnref88"><sup>88</sup></a> drug design to treat leukemia,<a class="footnoteRef" href="#fn89" id="fnref89"><sup>89</sup></a> peptide-drug design to treat <a href="cystic_fibrosis" title="wikilink">cystic fibrosis</a>,<a class="footnoteRef" href="#fn90" id="fnref90"><sup>90</sup></a> and the design of probes of broadly neutralizing HIV antibodies.<a class="footnoteRef" href="#fn91" id="fnref91"><sup>91</sup></a></p>

<p><a href="http://soft.synth-bio.org/protdes.html"><strong>PROTDES</strong></a> software for protein design based on CHARMM molecular mechanics package.</p>

<p><a href="http://rosettadesign.med.unc.edu/"><strong>RosettaDesign</strong></a>. A software package, under active development and free for academic use, that has seen extensive successful use.<a class="footnoteRef" href="#fn92" id="fnref92"><sup>92</sup></a><a class="footnoteRef" href="#fn93" id="fnref93"><sup>93</sup></a><a class="footnoteRef" href="#fn94" id="fnref94"><sup>94</sup></a><a class="footnoteRef" href="#fn95" id="fnref95"><sup>95</sup></a><a class="footnoteRef" href="#fn96" id="fnref96"><sup>96</sup></a><a class="footnoteRef" href="#fn97" id="fnref97"><sup>97</sup></a><a class="footnoteRef" href="#fn98" id="fnref98"><sup>98</sup></a> RosettaDesign is accessible via a web server.<a class="footnoteRef" href="#fn99" id="fnref99"><sup>99</sup></a></p>

<p><a href="http://www.sharp-n.com"><strong>SHARPEN</strong></a>. A permissive open-source library for protein design and structure prediction. SHARPEN offers a variety of combinatorial optimization methods (e.g., Monte Carlo, Simulated Annealing, FASTER<a class="footnoteRef" href="#fn100" id="fnref100"><sup>100</sup></a>) and can score proteins using the successful Rosetta all-atom <a href="Force_field_(chemistry)" title="wikilink">force field</a> or molecular mechanics force fields (<a href="OPLS" title="wikilink">OPLSaa</a>). In addition to the protein modeling library, SHARPEN includes tools for scalable distributed computing.</p>

<p><strong><a href="WHAT_IF_software" title="wikilink">WHAT IF software</a></strong> for protein modelling, design, validation, and visualisation.</p>

<p><a href="http://www.proteinwisdom.org"><strong>Protein WISDOM</strong></a>. Protein WISDOM <a class="footnoteRef" href="#fn101" id="fnref101"><sup>101</sup></a> is a workbench for In silico De novo Design of BioMolecules. It is an optimization-driven approach to design new sequences for improved stability or binding affinity. The sequence selection stage designs novel protein and peptide sequences based upon a rigid or flexible design template uploaded by the user. Once sequences are generated, they can be validated by either fold specificity or approximate binding affinity calculations.</p>

<p><strong><a href="Abalone_(molecular_mechanics)" title="wikilink">Abalone</a></strong> program for protein modelling, <a href="molecular_dynamics" title="wikilink">molecular dynamics</a> folding and visualisation.<a class="footnoteRef" href="#fn102" id="fnref102"><sup>102</sup></a></p>

<p><a href="http://www.dezyme.com"><strong>PoPMuSiC</strong></a>. Very popular among academics, with more than 400 registered users, PoPMuSiC is a fast and accurate program to design proteins with modified stability.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Molecular_design_software" title="wikilink">Molecular design software</a></li>
<li><a href="Protein_engineering" title="wikilink">Protein engineering</a></li>
<li><a href="Protein_structure_prediction_software" title="wikilink">Protein structure prediction software</a></li>
<li><a href="List_of_software_for_molecular_mechanics_modeling" title="wikilink">Software for molecular modeling</a></li>
</ul>
<h2 id="references">References</h2>
<h2 id="further-reading">Further reading</h2>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Protein_structure" title="wikilink">Category:Protein structure</a> <a href="Category:Protein_engineering" title="wikilink">Category:Protein engineering</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"></li>
<li id="fn3"></li>
<li id="fn4"></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
<li id="fn10"><a href="#fnref10">↩</a></li>
<li id="fn11"></li>
<li id="fn12"></li>
<li id="fn13"></li>
<li id="fn14"><a href="#fnref14">↩</a></li>
<li id="fn15"><a href="#fnref15">↩</a></li>
<li id="fn16"></li>
<li id="fn17"></li>
<li id="fn18"></li>
<li id="fn19"></li>
<li id="fn20"><a href="#fnref20">↩</a></li>
<li id="fn21"><a href="#fnref21">↩</a></li>
<li id="fn22"></li>
<li id="fn23"><a href="#fnref23">↩</a></li>
<li id="fn24"></li>
<li id="fn25"></li>
<li id="fn26"></li>
<li id="fn27"><a href="#fnref27">↩</a></li>
<li id="fn28"><a href="#fnref28">↩</a></li>
<li id="fn29"><a href="#fnref29">↩</a></li>
<li id="fn30"><a href="#fnref30">↩</a></li>
<li id="fn31"><a href="#fnref31">↩</a></li>
<li id="fn32"></li>
<li id="fn33"></li>
<li id="fn34"></li>
<li id="fn35"></li>
<li id="fn36"><a href="#fnref36">↩</a></li>
<li id="fn37"><a href="#fnref37">↩</a></li>
<li id="fn38"><a href="#fnref38">↩</a></li>
<li id="fn39"><a href="#fnref39">↩</a></li>
<li id="fn40"></li>
<li id="fn41"></li>
<li id="fn42"><a href="#fnref42">↩</a></li>
<li id="fn43"><a href="#fnref43">↩</a></li>
<li id="fn44"></li>
<li id="fn45"></li>
<li id="fn46"></li>
<li id="fn47"><a href="#fnref47">↩</a></li>
<li id="fn48"><a href="#fnref48">↩</a></li>
<li id="fn49"><a href="#fnref49">↩</a></li>
<li id="fn50"><a href="#fnref50">↩</a></li>
<li id="fn51"><a href="#fnref51">↩</a></li>
<li id="fn52"></li>
<li id="fn53"><a href="#fnref53">↩</a></li>
<li id="fn54"><a href="#fnref54">↩</a></li>
<li id="fn55"><a href="#fnref55">↩</a></li>
<li id="fn56"><a href="#fnref56">↩</a></li>
<li id="fn57"><a href="#fnref57">↩</a></li>
<li id="fn58"><a href="#fnref58">↩</a></li>
<li id="fn59"><a href="#fnref59">↩</a></li>
<li id="fn60"><a href="#fnref60">↩</a></li>
<li id="fn61"></li>
<li id="fn62"><a href="#fnref62">↩</a></li>
<li id="fn63"></li>
<li id="fn64"><a href="#fnref64">↩</a></li>
<li id="fn65"><a href="#fnref65">↩</a></li>
<li id="fn66"><a href="#fnref66">↩</a></li>
<li id="fn67"><a href="#fnref67">↩</a></li>
<li id="fn68"><a href="#fnref68">↩</a></li>
<li id="fn69"></li>
<li id="fn70"><a href="#fnref70">↩</a></li>
<li id="fn71"></li>
<li id="fn72"></li>
<li id="fn73"></li>
<li id="fn74"></li>
<li id="fn75"><a href="#fnref75">↩</a></li>
<li id="fn76"><a href="#fnref76">↩</a></li>
<li id="fn77"></li>
<li id="fn78"><a href="#fnref78">↩</a></li>
<li id="fn79"><a href="#fnref79">↩</a></li>
<li id="fn80"><a href="#fnref80">↩</a></li>
<li id="fn81"><a href="#fnref81">↩</a></li>
<li id="fn82"><a href="#fnref82">↩</a></li>
<li id="fn83"></li>
<li id="fn84"></li>
<li id="fn85"><a href="#fnref85">↩</a></li>
<li id="fn86"></li>
<li id="fn87"><a href="#fnref87">↩</a></li>
<li id="fn88"><a href="#fnref88">↩</a></li>
<li id="fn89"><a href="#fnref89">↩</a></li>
<li id="fn90"><a href="#fnref90">↩</a></li>
<li id="fn91"><a href="#fnref91">↩</a></li>
<li id="fn92"></li>
<li id="fn93"></li>
<li id="fn94"></li>
<li id="fn95"><a href="#fnref95">↩</a></li>
<li id="fn96"><a href="#fnref96">↩</a></li>
<li id="fn97"><a href="#fnref97">↩</a></li>
<li id="fn98"><a href="#fnref98">↩</a></li>
<li id="fn99"><a class="uri" href="http://rosettadesign.med.unc.edu/">http://rosettadesign.med.unc.edu/</a><a href="#fnref99">↩</a></li>
<li id="fn100"><a href="#fnref100">↩</a></li>
<li id="fn101"><a href="#fnref101">↩</a></li>
<li id="fn102"><a href="http://www.layruoru.com/dokuwiki/doku.php/problem_of_protein_folding">Example of protein folding by molecular dynamics</a><a href="#fnref102">↩</a></li>
</ol>
</section>
</body>
</html>
