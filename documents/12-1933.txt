   Counting points on elliptic curves      Counting points on elliptic curves  An important aspect in the study of [[elliptic curves]] is devising effective ways of '''counting points on the curve'''. There have been several approaches to do so, and the [[algorithms]] devised have proved to be useful tools in the study of various fie lds such as number theory , and more recently in cryptography and Digital Signature Authentication (See elliptic curve cryptography and elliptic curve DSA ). While in number theory they have important consequences in the solving of Diophantine equations , with respect to cryptography, they enable us to make effective use of the difficulty of the discrete logarithm problem (DLP) for the group    E   (   𝔽  q   )       E   subscript  𝔽  q     E(\mathbb{F}_{q})   , of elliptic curves over a finite field     𝔽  q     subscript  𝔽  q    \mathbb{F}_{q}   , where q = p k and p is a prime. The DLP, as it has come to be known, is a widely used approach to public key cryptography , and the difficulty in solving this problem determines the level of security of the cryptosystem. This article covers algorithms to count points on elliptic curves over fields of large characteristic, in particular p > 3. For curves over fields of small characteristic more efficient algorithms based on p -adic methods exist.  Approaches to counting points on elliptic curves  There are several approaches to the problem. Beginning with the naive approach, we trace the developments up to Schoof's definitive work on the subject, while also listing the improvements to Schoof's algorithm made by Elkies (1990) and Atkin (1992).  Several algorithms make use of the fact that groups of the form    E   (   𝔽  q   )       E   subscript  𝔽  q     E(\mathbb{F}_{q})   are subject to an important theorem due to Hasse, that bounds the number of points to be considered. The Hasse's theorem states that if E is an elliptic curve over the finite field    𝔽  q     subscript  𝔽  q    \mathbb{F}_{q}   , then the cardinality of    E   (   𝔽  q   )       E   subscript  𝔽  q     E(\mathbb{F}_{q})   satisfies        |    |   E   (   𝔽  q   )    |   -   (   q  +  1   )    |   ≤   2   q     .              E   subscript  𝔽  q       q  1       2    q      ||E(\mathbb{F}_{q})|-(q+1)|\leq 2\sqrt{q}.\,     Naive approach  The naive approach to counting points, which is the least sophisticated, involves running through all the elements of the field    𝔽  q     subscript  𝔽  q    \mathbb{F}_{q}   and testing which ones satisfy the Weierstrass form of the elliptic curve        y  2   =    x  3   +   A  x   +  B    .       superscript  y  2      superscript  x  3     A  x   B     y^{2}=x^{3}+Ax+B.\,     Example  Let E be the curve y 2 = x 3 + x + 1 over    𝔽  5     subscript  𝔽  5    \mathbb{F}_{5}   . To count points on E , we make a list of the possible values of x , then of x 3 + x + 1 mod 5, then of the square roots y of x 3 + x + 1 mod 5. This yields the points on E .         x   x   x           x  3   +  x  +  1       superscript  x  3   x  1    x^{3}+x+1         y   y   y      Points           0    0   \quad 0         1   1   1          ±  1     plus-or-minus  1    \pm 1           (  0  ,  1  )   ,   (  0  ,  4  )       0  1    0  4     (0,1),(0,4)            1    1   \quad 1         3   3   3         -     -         -     -            2    2   \quad 2         1   1   1          ±  1     plus-or-minus  1    \pm 1           (  2  ,  1  )   ,   (  2  ,  4  )       2  1    2  4     (2,1),(2,4)            3    3   \quad 3         1   1   1          ±  1     plus-or-minus  1    \pm 1           (  3  ,  1  )   ,   (  3  ,  4  )       3  1    3  4     (3,1),(3,4)            4    4   \quad 4         4   4   4          ±  2     plus-or-minus  2    \pm 2           (  4  ,  2  )   ,   (  4  ,  3  )       4  2    4  3     (4,2),(4,3)          E.g. the last row is computed as follows: If you insert    x  =  4      x  4    x=4   in the equation     y  2   =    x  3   +  x  +  1        superscript  y  2      superscript  x  3   x  1     y^{2}=x^{3}+x+1   you get   4   4   4   as result (2nd column). This result can be achieved if    y  =   ±  2       y   plus-or-minus  2     y=\pm 2   . So the points for the last row are     (  4  ,  2  )   ,   (  4  ,  3  )       4  2    4  3     (4,2),(4,3)   because   4   4   4   is fixed as it is the   x   x   x   result and    (  4  ,  2  )     4  2    (4,2)   if   y   y   y   is positive and    (  4  ,  3  )     4  3    (4,3)   if   y   y   y   is negative. Remember that    -  2      2    -2   equals   3   3   3   over    𝔽  5     subscript  𝔽  5    \mathbb{F}_{5}   .  Therefore,    E   (   𝔽  5   )       E   subscript  𝔽  5     E(\mathbb{F}_{5})   has cardinality of 9: the 8 points listed before and the point at infinity.  This algorithm requires running time O ( q ), because all the values of    x  ∈   𝔽  q       x   subscript  𝔽  q     x\in\mathbb{F}_{q}   must be considered.  Baby-step giant-step  An improvement in running time is obtained using a different approach: we pick an element    P  =   (  x  ,  y  )   ∈   E   (   𝔽  q   )          P   x  y          E   subscript  𝔽  q       P=(x,y)\in E(\mathbb{F}_{q})   by selecting random values of   x   x   x   until     x  3   +   A  x   +  B       superscript  x  3     A  x   B    x^{3}+Ax+B   is a square in    𝔽  q     subscript  𝔽  q    \mathbb{F}_{q}   and then computing the square root of this value in order to get   y   y   y   . Hasse's theorem tells us that    |   E   (   𝔽  q   )    |        E   subscript  𝔽  q      |E(\mathbb{F}_{q})|   lies in the interval    (    q  +  1   -   2   q     ,   q  +  1  +   2   q     )         q  1     2    q       q  1    2    q       (q+1-2\sqrt{q},q+1+2\sqrt{q})   . Thus, by Lagrange's theorem , finding a unique   M   M   M   lying in this interval and satisfying     M  P   =  O        M  P   O    MP=O   , results in finding the cardinality of    E   (   𝔽  q   )       E   subscript  𝔽  q     E(\mathbb{F}_{q})   . The algorithm fails if there exist two integers   M   M   M   and    M  ′     superscript  M  normal-′    M^{\prime}   in the interval such that     M  P   =    M  ′   P   =  O          M  P      superscript  M  normal-′   P        O     MP=M^{\prime}P=O   . In such a case it usually suffices to repeat the algorithm with another randomly chosen point in    E   (   𝔽  q   )       E   subscript  𝔽  q     E(\mathbb{F}_{q})   .  Trying all values of   M   M   M   in order to find the one that satisfies     M  P   =  O        M  P   O    MP=O   takes around    4   q       4    q     4\sqrt{q}   steps.  However, by applying the baby-step giant-step algorithm to    E   (   𝔽  q   )       E   subscript  𝔽  q     E(\mathbb{F}_{q})   , we are able to speed this up to around    4   q  4       4     4   q     4\sqrt[4]{q}   steps. The algorithm is as follows.  The algorithm  1. choose    m   m   m    integer,     m  >   q  4       m     4   q     m>\sqrt[4]{q}     2. FOR {     j  =  0      j  0    j=0    to    m   m   m    } DO   3.      P  j   ←   j  P      normal-←   subscript  P  j     j  P     P_{j}\leftarrow jP     4. ENDFOR  5.     L  ←  1     normal-←  L  1    L\leftarrow 1     6.     Q  ←    (   q  +  1   )   P      normal-←  Q      q  1   P     Q\leftarrow(q+1)P     7. REPEAT compute the points     Q  +   k   (   2  m  P   )        Q    k    2  m  P      Q+k(2mP)     8. UNTIL      ∃  j      j    \exists j        Q  +   k   (   2  m  P   )     =   ±   P  j          Q    k    2  m  P      plus-or-minus   subscript  P  j      Q+k(2mP)=\pm P_{j}    \\the    x   x   x    -coordinates are compared  9.     M  ←    q  +  1  +   2  m  k    ∓  j      normal-←  M   minus-or-plus    q  1    2  m  k    j     M\leftarrow q+1+2mk\mp j    \\note      M  P   =  O        M  P   O    MP=O     10. Factor    M   M   M    . Let      p  1   ,  …  ,   p  r       subscript  p  1   normal-…   subscript  p  r     p_{1},\ldots,p_{r}    be the distinct prime factors of    M   M   M    .  11. WHILE      i  ≤  r      i  r    i\leq r     DO  12. IF        M   p  i    P   =  O          M   subscript  p  i    P   O    \frac{M}{p_{i}}P=O     13. THEN      M  ←   M   p  i       normal-←  M    M   subscript  p  i      M\leftarrow\frac{M}{p_{i}}     14. ELSE      i  ←   i  +  1      normal-←  i    i  1     i\leftarrow i+1      15. ENDIF  16. ENDWHILE  17.     L  ←   lcm   (  L  ,  M  )       normal-←  L   lcm  L  M     L\leftarrow\operatorname{lcm}(L,M)    \\note    M   M   M    is the order of the point    P   P   P     18. WHILE     L   L   L    divides more than one integer    N   N   N    in     (    q  +  1   -   2   q     ,   q  +  1  +   2   q     )         q  1     2    q       q  1    2    q       (q+1-2\sqrt{q},q+1+2\sqrt{q})     19. DO choose a new point    P   P   P    and go to 1.  20. ENDWHILE  21. RETURN     N   N   N    \\it is the cardinality of     E   (   𝔽  q   )       E   subscript  𝔽  q     E(\mathbb{F}_{q})     Notes to the algorithm   In line 8. we assume the existence of a match. Indeed, the following lemma assures that such a match exists:     Let   a   a   a   be an integer with     |  a  |   ≤   2   m  2          a     2   superscript  m  2      |a|\leq 2m^{2}   . There exist integers    a  0     subscript  a  0    a_{0}   and    a  1     subscript  a  1    a_{1}   with       -m   Computing     (   j  +  1   )   P        j  1   P    (j+1)P   once    j  P      j  P    jP   has been computed can be done by adding   P   P   P   to    j  P      j  P    jP   instead of computing the complete scalar multiplication anew. The complete computation thus requires   m   m   m   additions.    2  m  P      2  m  P    2mP   can be obtained with one doubling from    m  P      m  P    mP   . The computation of   Q   Q   Q   requires    log   (   q  +  1   )         q  1     \log(q+1)   doublings and   w   w   w   additions, where   w   w   w   is the number of nonzero digits in the binary representation of    q  +  1      q  1    q+1   ; note that knowledge of the    j  P      j  P    jP   and    2  m  P      2  m  P    2mP   allows us to reduce the number of doublings. Finally, to get from    Q  +   k   (   2  m  P   )        Q    k    2  m  P      Q+k(2mP)   to    Q  +    (   k  +  1   )    (   2  m  P   )        Q      k  1     2  m  P      Q+(k+1)(2mP)   , simply add    2  m  P      2  m  P    2mP   rather than recomputing everything.    We are assuming that we can factor   M   M   M   . If not, we can at least find all the small prime factors    p  i     subscript  p  i    p_{i}   and check that     M   p  i    ≠  O        M   subscript  p  i    O    \frac{M}{p_{i}}\neq O   for these. Then   M   M   M   will be a good candidate for the order of   P   P   P   .    The conclusion of step 17 can be proved using elementary group theory: since     M  P   =  O        M  P   O    MP=O   , the order of   P   P   P   divides   M   M   M   . If no proper divisor    M  ¯     normal-¯  M    \bar{M}   of   M   M   M   realizes      M  ¯   P   =  O         normal-¯  M   P   O    \bar{M}P=O   , then   M   M   M   is the order of   P   P   P   .   One drawback of this method is that there is a need for too much memory when the group becomes large. In order to address this, it might be more efficient to store only the   x   x   x   coordinates of the points    j  P      j  P    jP   (along with the corresponding integer   j   j   j   ). However, this leads to an extra scalar multiplication in order to choose between    -  j      j    -j   and    +  j      j    +j   .  There are other generic algorithms for computing the order of a group element that are more space efficient, such as Pollard's rho algorithm and the Pollard kangaroo method. The Pollard kangaroo method allows one to search for a solution in a prescribed interval, yielding a running time of    O   (   q  4   )       O     4   q     O(\sqrt[4]{q})   , using    O   (    log  2   q   )       O    superscript   2   q     O(\log^{2}{q})   space.  Schoof's algorithm  A theoretical breakthrough for the problem of computing the cardinality of groups of the type    E   (   𝔽  q   )       E   subscript  𝔽  q     E(\mathbb{F}_{q})   was achieved by René Schoof, who, in 1985, published the first deterministic polynomial time algorithm. Central to Schoof's algorithm are the use of division polynomials and Hasse's theorem , along with the Chinese remainder theorem .  Schoof's insight exploits the fact that, by Hasse's theorem, there is a finite range of possible values for    |   E   (   𝔽  q   )    |        E   subscript  𝔽  q      |E(\mathbb{F}_{q})|   . It suffices to compute    |   E   (   𝔽  q   )    |        E   subscript  𝔽  q      |E(\mathbb{F}_{q})|   modulo an integer    N  >   4   q        N    4    q      N>4\sqrt{q}   . This is achieved by computing    |   E   (   𝔽  q   )    |        E   subscript  𝔽  q      |E(\mathbb{F}_{q})|   modulo primes     ℓ  1   ,  …  ,   ℓ  s       subscript  normal-ℓ  1   normal-…   subscript  normal-ℓ  s     \ell_{1},\ldots,\ell_{s}   whose product exceeds    4   q       4    q     4\sqrt{q}   , and then applying the Chinese remainder theorem. The key to the algorithm is using the division polynomial    ψ  ℓ     subscript  ψ  normal-ℓ    \psi_{\ell}   to efficiently compute    |   E   (   𝔽  q   )    |        E   subscript  𝔽  q      |E(\mathbb{F}_{q})|   modulo   ℓ   normal-ℓ   \ell   .  The running time of Schoof's Algorithm is polynomial in    n  =   log  q       n    q     n=\log{q}   , with an asymptotic complexity of     O   (     n  2   M   (   n  3   )    /   log  n    )    =   O   (   n   5  +   o   (  1  )      )          O       superscript  n  2   M   superscript  n  3      n       O   superscript  n    5    o  1        O(n^{2}M(n^{3})/\log{n})=O(n^{5+o(1)})   , where    M   (  n  )       M  n    M(n)   denotes the complexity of integer multiplication . Its space complexity is    O   (   n  3   )       O   superscript  n  3     O(n^{3})   .  Schoof–Elkies–Atkin algorithm  In the 1990s, Noam Elkies , followed by A. O. L. Atkin devised improvements to Schoof's basic algorithm by making a distinction among the primes     ℓ  1   ,  …  ,   ℓ  s       subscript  normal-ℓ  1   normal-…   subscript  normal-ℓ  s     \ell_{1},\ldots,\ell_{s}   that are used. A prime   ℓ   normal-ℓ   \ell   is called an Elkies prime if the characteristic equation of the Frobenius endomorphism,       ϕ  2   -   t  ϕ    +  q   =  0           superscript  ϕ  2     t  ϕ    q   0    \phi^{2}-t\phi+q=0   , splits over    𝔽  ℓ     subscript  𝔽  normal-ℓ    \mathbb{F}_{\ell}   . Otherwise   ℓ   normal-ℓ   \ell   is called an Atkin prime. Elkies primes are the key to improving the asymptotic complexity of Schoof's algorithm. Information obtained from the Atkin primes permits a further improvement which is asymptotically negligible but can be quite important in practice. The modification of Schoof's algorithm to use Elkies and Atkin primes is known as the Schoof–Elkies–Atkin (SEA) algorithm.  The status of a particular prime   ℓ   normal-ℓ   \ell   depends on the elliptic curve    E  /   𝔽  q       E   subscript  𝔽  q     E/\mathbb{F}_{q}   , and can be determined using the modular polynomial      Ψ  ℓ    (  X  ,  Y  )        subscript  normal-Ψ  normal-ℓ    X  Y     \Psi_{\ell}(X,Y)   . If the univariate polynomial     Ψ  ℓ    (  X  ,   j   (  E  )    )        subscript  normal-Ψ  normal-ℓ    X    j  E      \Psi_{\ell}(X,j(E))   has a root in    𝔽  q     subscript  𝔽  q    \mathbb{F}_{q}   , where    j   (  E  )       j  E    j(E)   denotes the j-invariant of   E   E   E   , then   ℓ   normal-ℓ   \ell   is an Elkies prime, and otherwise it is an Atkin prime. In the Elkies case, further computations involving modular polynomials are used to obtain a proper factor of the division polynomial    ψ  ℓ     subscript  ψ  normal-ℓ    \psi_{\ell}   . The degree of this factor is    O   (  ℓ  )       O  normal-ℓ    O(\ell)   , whereas    ψ  ℓ     subscript  ψ  normal-ℓ    \psi_{\ell}   has degree    O   (   ℓ  2   )       O   superscript  normal-ℓ  2     O(\ell^{2})   .  Unlike Schoof's algorithm, the SEA algorithm is typically implemented as a probabilistic algorithm (of the Las Vegas type), so that root-finding and other operations can be performed more efficiently. Its computational complexity is dominated by the cost of computing the modular polynomials     Ψ  ℓ    (  X  ,  Y  )        subscript  normal-Ψ  normal-ℓ    X  Y     \Psi_{\ell}(X,Y)   , but as these do not depend on   E   E   E   , they may be computed once and reused. Under the heuristic assumption that there are sufficiently many small Elkies primes, and excluding the cost of computing modular polynomials, the asymptotic running time of the SEA algorithm is     O   (     n  2   M   (   n  2   )    /   log  n    )    =   O   (   n   4  +   o   (  1  )      )          O       superscript  n  2   M   superscript  n  2      n       O   superscript  n    4    o  1        O(n^{2}M(n^{2})/\log{n})=O(n^{4+o(1)})   , where    n  =   log  q       n    q     n=\log{q}   . Its space complexity is    O   (    n  3    log  n    )       O     superscript  n  3     n      O(n^{3}\log{n})   , but when precomputed modular polynomials are used this increases to    O   (   n  4   )       O   superscript  n  4     O(n^{4})   .  See also   Schoof's algorithm  Elliptic curve cryptography  Baby-step giant-step  Public key cryptography  Schoof–Elkies–Atkin algorithm  Pollard rho  Pollard kangaroo  Elliptic curve primality proving   Bibliography   I. Blake, G. Seroussi, and N. Smart: Elliptic Curves in Cryptography , Cambridge University Press, 1999.  A. Enge: Elliptic Curves and their Applications to Cryptography: An Introduction . Kluwer Academic Publishers, Dordrecht, 1999.  G. Musiker: Schoof's Algorithm for Counting Points on    E   (   𝔽  q   )       E   subscript  𝔽  q     E(\mathbb{F}_{q})   . Available at http://www.math.umn.edu/~musiker/schoof.pdf  R. Schoof: Counting Points on Elliptic Curves over Finite Fields. J. Theor. Nombres Bordeaux 7:219-254, 1995. Available at http://www.mat.uniroma2.it/~schoof/ctg.pdf  L. C. Washington: Elliptic Curves: Number Theory and Cryptography. Chapman \& Hall/CRC, New York, 2003.   References    "  Category:Elliptic curves   