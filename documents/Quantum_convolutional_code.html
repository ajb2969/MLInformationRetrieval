<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1425">Quantum convolutional code</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Quantum convolutional code</h1>
<hr/>

<p><a href="Stabilizer_code" title="wikilink">Quantum block codes</a> are useful in <a href="quantum_computing" title="wikilink">quantum computing</a> and in <a href="quantum_communication" title="wikilink">quantum communications</a>. The encoding circuit for a large block code typically has a high complexity although those for modern codes do have lower complexity.</p>

<p>Quantum convolutional coding theory offers a different paradigm for coding quantum information. The convolutional structure is useful for a <a href="quantum_communication" title="wikilink">quantum communication</a> scenario where a sender possesses a stream of <a href="qubit" title="wikilink">qubits</a> to send to a receiver. The encoding circuit for a quantum convolutional code has a much lower complexity than an encoding circuit needed for a large block code. It also has a repetitive pattern so that the same physical devices or the same routines can manipulate the stream of quantum information.</p>

<p>Quantum convolutional stabilizer codes borrow heavily from the structure of their <a href="convolutional_code" title="wikilink">classical counterparts</a>. Quantum convolutional codes are similar because some of the qubits feed back into a repeated encoding unitary and give the code a memory structure like that of a classical convolutional code. The quantum codes feature online encoding and decoding of qubits. This feature gives quantum convolutional codes both their low encoding and decoding complexity and their ability to correct a larger set of errors than a block code with similar parameters.</p>
<h2 id="definition">Definition</h2>

<p>A quantum convolutional stabilizer code acts on a <a href="Hilbert_space" title="wikilink">Hilbert space</a> 

<math display="inline" id="Quantum_convolutional_code:0">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">ℋ</mi>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <ci>ℋ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{H},
  </annotation>
 </semantics>
</math>

 which is a <a href="countably_infinite" title="wikilink">countably infinite</a> <a href="tensor_product" title="wikilink">tensor product</a> of two-dimensional <a class="uri" href="qubit" title="wikilink">qubit</a> <a href="Hilbert_space" title="wikilink">Hilbert spaces</a> indexed over integers ≥ 0 

<math display="inline" id="Quantum_convolutional_code:1">
 <semantics>
  <msub>
   <mrow>
    <mo>{</mo>
    <msub>
     <mi class="ltx_font_mathcaligraphic">ℋ</mi>
     <mi>i</mi>
    </msub>
    <mo>}</mo>
   </mrow>
   <mrow>
    <mi>i</mi>
    <mo>∈</mo>
    <msup>
     <mi>ℤ</mi>
     <mo>+</mo>
    </msup>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <set>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ℋ</ci>
      <ci>i</ci>
     </apply>
    </set>
    <apply>
     <in></in>
     <ci>i</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ℤ</ci>
      <plus></plus>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left\{\mathcal{H}_{i}\right\}_{i\in\mathbb{Z}^{+}}
  </annotation>
 </semantics>
</math>

:</p>

<p>

<math display="block" id="Quantum_convolutional_code:2">
 <semantics>
  <mrow>
   <mrow>
    <mi class="ltx_font_mathcaligraphic">ℋ</mi>
    <mo>=</mo>
    <mrow>
     <mpadded width="+5pt">
      <munderover>
       <mo largeop="true" mathsize="160%" movablelimits="false" stretchy="false" symmetric="true">⊗</mo>
       <mrow>
        <mi>i</mi>
        <mo>=</mo>
        <mn>0</mn>
       </mrow>
       <mi mathvariant="normal">∞</mi>
      </munderover>
     </mpadded>
     <msub>
      <mi class="ltx_font_mathcaligraphic">ℋ</mi>
      <mi>i</mi>
     </msub>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>ℋ</ci>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <csymbol cd="latexml">tensor-product</csymbol>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <infinity></infinity>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ℋ</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{H}={\displaystyle\bigotimes\limits_{i=0}^{\infty}}\ \mathcal{H}_{i}.
  </annotation>
 </semantics>
</math>

 A sequence 

<math display="inline" id="Quantum_convolutional_code:3">
 <semantics>
  <mi>𝐀</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐀</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{A}
  </annotation>
 </semantics>
</math>

 of <a href="Pauli_matrices" title="wikilink">Pauli matrices</a> 

<math display="inline" id="Quantum_convolutional_code:4">
 <semantics>
  <msub>
   <mrow>
    <mo>{</mo>
    <msub>
     <mi>A</mi>
     <mi>i</mi>
    </msub>
    <mo>}</mo>
   </mrow>
   <mrow>
    <mi>i</mi>
    <mo>∈</mo>
    <msup>
     <mi>ℤ</mi>
     <mo>+</mo>
    </msup>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <set>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <ci>i</ci>
     </apply>
    </set>
    <apply>
     <in></in>
     <ci>i</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ℤ</ci>
      <plus></plus>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left\{A_{i}\right\}_{i\in\mathbb{Z}^{+}}
  </annotation>
 </semantics>
</math>

, where</p>

<p>

<math display="block" id="Quantum_convolutional_code:5">
 <semantics>
  <mrow>
   <mrow>
    <mi>𝐀</mi>
    <mo>=</mo>
    <mrow>
     <mpadded width="+5pt">
      <munderover>
       <mo largeop="true" mathsize="160%" movablelimits="false" stretchy="false" symmetric="true">⊗</mo>
       <mrow>
        <mi>i</mi>
        <mo>=</mo>
        <mn>0</mn>
       </mrow>
       <mi mathvariant="normal">∞</mi>
      </munderover>
     </mpadded>
     <msub>
      <mi>A</mi>
      <mi>i</mi>
     </msub>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>𝐀</ci>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <csymbol cd="latexml">tensor-product</csymbol>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <infinity></infinity>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{A}={\displaystyle\bigotimes\limits_{i=0}^{\infty}}\ A_{i},
  </annotation>
 </semantics>
</math>

 can act on states in 

<math display="inline" id="Quantum_convolutional_code:6">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ℋ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℋ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{H}
  </annotation>
 </semantics>
</math>


. Let 

<math display="inline" id="Quantum_convolutional_code:7">
 <semantics>
  <msup>
   <mi mathvariant="normal">Π</mi>
   <msup>
    <mi>ℤ</mi>
    <mo>+</mo>
   </msup>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>normal-Π</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ℤ</ci>
     <plus></plus>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Pi^{\mathbb{Z}^{+}}
  </annotation>
 </semantics>
</math>

 denote the set of all Pauli sequences. The support supp

<math display="inline" id="Quantum_convolutional_code:8">
 <semantics>
  <mrow>
   <mo>(</mo>
   <mi>𝐀</mi>
   <mo>)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐀</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left(\mathbf{A}\right)
  </annotation>
 </semantics>
</math>

 of a Pauli sequence 

<math display="inline" id="Quantum_convolutional_code:9">
 <semantics>
  <mi>𝐀</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐀</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{A}
  </annotation>
 </semantics>
</math>

 is the set of indices of the entries in 

<math display="inline" id="Quantum_convolutional_code:10">
 <semantics>
  <mi>𝐀</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐀</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{A}
  </annotation>
 </semantics>
</math>

 that are not equal to the identity. The weight of a sequence 

<math display="inline" id="Quantum_convolutional_code:11">
 <semantics>
  <mi>𝐀</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐀</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{A}
  </annotation>
 </semantics>
</math>


 is the size 

<math display="inline" id="Quantum_convolutional_code:12">
 <semantics>
  <mrow>
   <mo>|</mo>
   <mrow>
    <mtext>supp</mtext>
    <mrow>
     <mo>(</mo>
     <mi>𝐀</mi>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>|</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <abs></abs>
    <apply>
     <times></times>
     <mtext>supp</mtext>
     <ci>𝐀</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left|\text{supp}\left(\mathbf{A}\right)\right|
  </annotation>
 </semantics>
</math>

 of its support. The delay del

<math display="inline" id="Quantum_convolutional_code:13">
 <semantics>
  <mrow>
   <mo>(</mo>
   <mi>𝐀</mi>
   <mo>)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐀</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left(\mathbf{A}\right)
  </annotation>
 </semantics>
</math>

 of a sequence 

<math display="inline" id="Quantum_convolutional_code:14">
 <semantics>
  <mi>𝐀</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐀</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{A}
  </annotation>
 </semantics>
</math>

 is the smallest index for an entry not equal to the identity. The degree deg

<math display="inline" id="Quantum_convolutional_code:15">
 <semantics>
  <mrow>
   <mo>(</mo>
   <mi>𝐀</mi>
   <mo>)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐀</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left(\mathbf{A}\right)
  </annotation>
 </semantics>
</math>

 of a sequence 

<math display="inline" id="Quantum_convolutional_code:16">
 <semantics>
  <mi>𝐀</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐀</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{A}
  </annotation>
 </semantics>
</math>

 is the largest index for an entry not equal to the identity. E.g., the following Pauli sequence</p>

<p>

<math display="block" id="Quantum_convolutional_code:17">
 <semantics>
  <mrow>
   <mtable displaystyle="true">
    <mtr>
     <mtd columnalign="center">
      <mi>I</mi>
     </mtd>
     <mtd columnalign="center">
      <mi>X</mi>
     </mtd>
     <mtd columnalign="center">
      <mi>I</mi>
     </mtd>
     <mtd columnalign="center">
      <mi>Y</mi>
     </mtd>
     <mtd columnalign="center">
      <mi>Z</mi>
     </mtd>
     <mtd columnalign="center">
      <mi>I</mi>
     </mtd>
     <mtd columnalign="center">
      <mi>I</mi>
     </mtd>
     <mtd columnalign="center">
      <mi mathvariant="normal">⋯</mi>
     </mtd>
    </mtr>
   </mtable>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <ci>I</ci>
     <ci>X</ci>
     <ci>I</ci>
     <ci>Y</ci>
     <ci>Z</ci>
     <ci>I</ci>
     <ci>I</ci>
     <ci>normal-⋯</ci>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{array}[c]{cccccccc}I&X&I&Y&Z&I&I&\cdots\end{array},
  </annotation>
 </semantics>
</math>

 has support 

<math display="inline" id="Quantum_convolutional_code:18">
 <semantics>
  <mrow>
   <mo>{</mo>
   <mn>1</mn>
   <mo>,</mo>
   <mn>3</mn>
   <mo>,</mo>
   <mn>4</mn>
   <mo>}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <cn type="integer">1</cn>
    <cn type="integer">3</cn>
    <cn type="integer">4</cn>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left\{1,3,4\right\}
  </annotation>
 </semantics>
</math>

, weight three, delay one, and degree four. A sequence has finite support if its weight is finite. Let 

<math display="inline" id="Quantum_convolutional_code:19">
 <semantics>
  <mrow>
   <mi>F</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi mathvariant="normal">Π</mi>
     <msup>
      <mi>ℤ</mi>
      <mo>+</mo>
     </msup>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>F</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-Π</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ℤ</ci>
      <plus></plus>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F(\Pi^{\mathbb{Z}^{+}})
  </annotation>
 </semantics>
</math>

 denote the set of Pauli sequences with finite support. The following definition for a quantum convolutional code utilizes the set 

<math display="inline" id="Quantum_convolutional_code:20">
 <semantics>
  <mrow>
   <mi>F</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi mathvariant="normal">Π</mi>
     <msup>
      <mi>ℤ</mi>
      <mo>+</mo>
     </msup>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>F</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-Π</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ℤ</ci>
      <plus></plus>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F(\Pi^{\mathbb{Z}^{+}})
  </annotation>
 </semantics>
</math>


 in its description.</p>

<p>A rate 

<math display="inline" id="Quantum_convolutional_code:21">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>/</mo>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <ci>k</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k/n
  </annotation>
 </semantics>
</math>

-convolutional stabilizer code with 

<math display="inline" id="Quantum_convolutional_code:22">
 <semantics>
  <mrow>
   <mn>0</mn>
   <mo>≤</mo>
   <mi>k</mi>
   <mo>≤</mo>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <cn type="integer">0</cn>
     <ci>k</ci>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0\leq k\leq n
  </annotation>
 </semantics>
</math>

 is a commuting set 

<math display="inline" id="Quantum_convolutional_code:23">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒢</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒢</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{G}
  </annotation>
 </semantics>
</math>

 of all 

<math display="inline" id="Quantum_convolutional_code:24">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

-qubit shifts of a basic generator set 

<math display="inline" id="Quantum_convolutional_code:25">
 <semantics>
  <msub>
   <mi class="ltx_font_mathcaligraphic">𝒢</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝒢</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{G}_{0}
  </annotation>
 </semantics>
</math>

. The basic generator set 

<math display="inline" id="Quantum_convolutional_code:26">
 <semantics>
  <msub>
   <mi class="ltx_font_mathcaligraphic">𝒢</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝒢</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{G}_{0}
  </annotation>
 </semantics>
</math>

 has 

<math display="inline" id="Quantum_convolutional_code:27">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>-</mo>
   <mi>k</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>n</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n-k
  </annotation>
 </semantics>
</math>

 Pauli sequences of finite support:</p>

<p>

<math display="block" id="Quantum_convolutional_code:28">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi class="ltx_font_mathcaligraphic">𝒢</mi>
     <mn>0</mn>
    </msub>
    <mo>=</mo>
    <mrow>
     <mo>{</mo>
     <mrow>
      <msub>
       <mi>𝐆</mi>
       <mi>i</mi>
      </msub>
      <mo>∈</mo>
      <mrow>
       <mi>F</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msup>
         <mi mathvariant="normal">Π</mi>
         <msup>
          <mi>ℤ</mi>
          <mo>+</mo>
         </msup>
        </msup>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo>:</mo>
     <mrow>
      <mn>1</mn>
      <mo>≤</mo>
      <mi>i</mi>
      <mo>≤</mo>
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mi>k</mi>
      </mrow>
     </mrow>
     <mo>}</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝒢</ci>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <apply>
      <in></in>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐆</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <times></times>
       <ci>F</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>normal-Π</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>ℤ</ci>
         <plus></plus>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <and></and>
      <apply>
       <leq></leq>
       <cn type="integer">1</cn>
       <ci>i</ci>
      </apply>
      <apply>
       <leq></leq>
       <share href="#.cmml">
       </share>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <ci>k</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{G}_{0}=\left\{\mathbf{G}_{i}\in F(\Pi^{\mathbb{Z}^{+}}):1\leq i\leq n%
-k\right\}.
  </annotation>
 </semantics>
</math>

 The constraint length 

<math display="inline" id="Quantum_convolutional_code:29">
 <semantics>
  <mi>ν</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ν</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \nu
  </annotation>
 </semantics>
</math>

 of the code is the maximum degree of the generators in 

<math display="inline" id="Quantum_convolutional_code:30">
 <semantics>
  <msub>
   <mi class="ltx_font_mathcaligraphic">𝒢</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝒢</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{G}_{0}
  </annotation>
 </semantics>
</math>

. A frame of the code consists of 

<math display="inline" id="Quantum_convolutional_code:31">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 qubits.</p>

<p>A quantum convolutional code admits an equivalent definition in terms of the delay transform or 

<math display="inline" id="Quantum_convolutional_code:32">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>

-transform. The 

<math display="inline" id="Quantum_convolutional_code:33">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>

-transform captures shifts of the basic generator set 

<math display="inline" id="Quantum_convolutional_code:34">
 <semantics>
  <msub>
   <mi class="ltx_font_mathcaligraphic">𝒢</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝒢</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{G}_{0}
  </annotation>
 </semantics>
</math>

. Let us define the 

<math display="inline" id="Quantum_convolutional_code:35">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

-qubit delay operator 

<math display="inline" id="Quantum_convolutional_code:36">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>

 acting on any Pauli sequence 

<math display="inline" id="Quantum_convolutional_code:37">
 <semantics>
  <mrow>
   <mi>𝐀</mi>
   <mo>∈</mo>
   <msup>
    <mi mathvariant="normal">Π</mi>
    <msup>
     <mi>ℤ</mi>
     <mo>+</mo>
    </msup>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>𝐀</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-Π</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ℤ</ci>
      <plus></plus>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{A}\in\Pi^{\mathbb{Z}^{+}}
  </annotation>
 </semantics>
</math>

 as follows:</p>

<p>

<math display="block" id="Quantum_convolutional_code:38">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>D</mi>
     <mrow>
      <mo>(</mo>
      <mi>𝐀</mi>
      <mo>)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msup>
      <mi>I</mi>
      <mrow>
       <mi></mi>
       <mo>⊗</mo>
       <mi>n</mi>
      </mrow>
     </msup>
     <mo>⊗</mo>
     <mi>𝐀</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>D</ci>
     <ci>𝐀</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">tensor-product</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>I</ci>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <csymbol cd="latexml">absent</csymbol>
       <ci>n</ci>
      </apply>
     </apply>
     <ci>𝐀</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D\left(\mathbf{A}\right)=I^{\otimes n}\otimes\mathbf{A.}
  </annotation>
 </semantics>
</math>

 We can write 

<math display="inline" id="Quantum_convolutional_code:39">
 <semantics>
  <mi>j</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>j</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   j
  </annotation>
 </semantics>
</math>

 repeated applications of 

<math display="inline" id="Quantum_convolutional_code:40">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>

 as a power of 

<math display="inline" id="Quantum_convolutional_code:41">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>

:</p>

<p>

<math display="block" id="Quantum_convolutional_code:42">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msup>
      <mi>D</mi>
      <mi>j</mi>
     </msup>
     <mrow>
      <mo>(</mo>
      <mi>𝐀</mi>
      <mo>)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msup>
      <mi>I</mi>
      <mrow>
       <mi></mi>
       <mo>⊗</mo>
       <mrow>
        <mi>j</mi>
        <mi>n</mi>
       </mrow>
      </mrow>
     </msup>
     <mo>⊗</mo>
     <mi>𝐀</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>D</ci>
      <ci>j</ci>
     </apply>
     <ci>𝐀</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">tensor-product</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>I</ci>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <csymbol cd="latexml">absent</csymbol>
       <apply>
        <times></times>
        <ci>j</ci>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
     <ci>𝐀</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D^{j}\left(\mathbf{A}\right)=I^{\otimes jn}\otimes\mathbf{A.}
  </annotation>
 </semantics>
</math>

 Let 

<math display="inline" id="Quantum_convolutional_code:43">
 <semantics>
  <mrow>
   <msup>
    <mi>D</mi>
    <mi>j</mi>
   </msup>
   <mrow>
    <mo>(</mo>
    <msub>
     <mi class="ltx_font_mathcaligraphic">𝒢</mi>
     <mn>0</mn>
    </msub>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>D</ci>
     <ci>j</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝒢</ci>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D^{j}\left(\mathcal{G}_{0}\right)
  </annotation>
 </semantics>
</math>

 be the set of shifts of elements of 

<math display="inline" id="Quantum_convolutional_code:44">
 <semantics>
  <msub>
   <mi class="ltx_font_mathcaligraphic">𝒢</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝒢</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{G}_{0}
  </annotation>
 </semantics>
</math>

 by 

<math display="inline" id="Quantum_convolutional_code:45">
 <semantics>
  <mi>j</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>j</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   j
  </annotation>
 </semantics>
</math>

. Then the full stabilizer 

<math display="inline" id="Quantum_convolutional_code:46">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒢</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒢</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{G}
  </annotation>
 </semantics>
</math>

 for the convolutional stabilizer code is</p>

<p>

<math display="block" id="Quantum_convolutional_code:47">
 <semantics>
  <mrow>
   <mrow>
    <mi class="ltx_font_mathcaligraphic">𝒢</mi>
    <mo>=</mo>
    <mrow>
     <mstyle displaystyle="false">
      <munder>
       <mo largeop="true" mathsize="160%" movablelimits="false" stretchy="false" symmetric="true">⋃</mo>
       <mrow>
        <mi>j</mi>
        <mo>∈</mo>
        <msup>
         <mi>ℤ</mi>
         <mo>+</mo>
        </msup>
       </mrow>
      </munder>
     </mstyle>
     <mrow>
      <msup>
       <mi>D</mi>
       <mi>j</mi>
      </msup>
      <mrow>
       <mo>(</mo>
       <msub>
        <mi class="ltx_font_mathcaligraphic">𝒢</mi>
        <mn>0</mn>
       </msub>
       <mo>)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>𝒢</ci>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <union></union>
      <apply>
       <in></in>
       <ci>j</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>ℤ</ci>
        <plus></plus>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>D</ci>
       <ci>j</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝒢</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{G}={\textstyle\bigcup\limits_{j\in\mathbb{Z}^{+}}}D^{j}\left(\mathcal%
{G}_{0}\right).
  </annotation>
 </semantics>
</math>

</p>
<h2 id="operation">Operation</h2>

<p>The operation of a convolutional stabilizer code is as follows. The protocol begins with the sender encoding a stream of qubits with an online encoding circuit such as that given in (Grassl and Roetteler 2006). The encoding circuit is <em>online</em> if it acts on a few blocks of qubits at a time. The sender transmits a set of qubits as soon as the first unitary finishes processing them. The receiver measures all the generators in 

<math display="inline" id="Quantum_convolutional_code:48">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒢</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒢</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{G}
  </annotation>
 </semantics>
</math>

 and corrects for errors as he receives the online encoded qubits. He finally decodes the encoded qubits with a decoding circuit. The qubits decoded from this convolutional procedure should be error free and ready for quantum computation at the receiving end.</p>

<p>A <em>finite-depth</em> circuit maps a Pauli sequence with finite weight to one with finite weight (Ollivier and Tillich 2004). It does not map a Pauli sequence with finite weight to one with infinite weight. This property is important because we do not want the decoding circuit to propagate uncorrected errors into the information qubit stream (Johannesson and Zigangirov 1999). A finite-depth decoding circuit corresponding to the <a href="Stabilizer_code" title="wikilink">stabilizer</a> 

<math display="inline" id="Quantum_convolutional_code:49">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒢</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒢</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{G}
  </annotation>
 </semantics>
</math>

 exists by the algorithm given in (Grassl and Roetteler 2006).</p>
<h2 id="example">Example</h2>

<p>Forney et al. provided an example of a rate-1/3 quantum convolutional code by importing a particular classical quaternary convolutional code (Forney and Guha 2005). Grassl and Roetteler determined a noncatastrophic encoding circuit for Forney et al.'s rate-1/3 quantum convolutional code (Grassl and Roetteler 2006). The basic stabilizer and its first shift are as follows:</p>

<p>

<math display="block" id="Quantum_convolutional_code:50">
 <semantics>
  <mrow>
   <mi mathvariant="normal">⋯</mi>
   <mrow>
    <mo>|</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <mi>I</mi>
        <mi>I</mi>
        <mi>I</mi>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <mi>I</mi>
        <mi>I</mi>
        <mi>I</mi>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <mi>I</mi>
        <mi>I</mi>
        <mi>I</mi>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <mi>I</mi>
        <mi>I</mi>
        <mi>I</mi>
       </mrow>
      </mtd>
     </mtr>
    </mtable>
    <mo>|</mo>
   </mrow>
   <mtable displaystyle="true">
    <mtr>
     <mtd columnalign="center">
      <mrow>
       <mi>X</mi>
       <mi>X</mi>
       <mi>X</mi>
      </mrow>
     </mtd>
    </mtr>
    <mtr>
     <mtd columnalign="center">
      <mrow>
       <mi>Z</mi>
       <mi>Z</mi>
       <mi>Z</mi>
      </mrow>
     </mtd>
    </mtr>
    <mtr>
     <mtd columnalign="center">
      <mrow>
       <mi>I</mi>
       <mi>I</mi>
       <mi>I</mi>
      </mrow>
     </mtd>
    </mtr>
    <mtr>
     <mtd columnalign="center">
      <mrow>
       <mi>I</mi>
       <mi>I</mi>
       <mi>I</mi>
      </mrow>
     </mtd>
    </mtr>
   </mtable>
   <mrow>
    <mo>|</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <mi>X</mi>
        <mi>Z</mi>
        <mi>Y</mi>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <mi>Z</mi>
        <mi>Y</mi>
        <mi>X</mi>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <mi>X</mi>
        <mi>X</mi>
        <mi>X</mi>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <mi>Z</mi>
        <mi>Z</mi>
        <mi>Z</mi>
       </mrow>
      </mtd>
     </mtr>
    </mtable>
    <mo>|</mo>
   </mrow>
   <mtable displaystyle="true">
    <mtr>
     <mtd columnalign="center">
      <mrow>
       <mi>I</mi>
       <mi>I</mi>
       <mi>I</mi>
      </mrow>
     </mtd>
    </mtr>
    <mtr>
     <mtd columnalign="center">
      <mrow>
       <mi>I</mi>
       <mi>I</mi>
       <mi>I</mi>
      </mrow>
     </mtd>
    </mtr>
    <mtr>
     <mtd columnalign="center">
      <mrow>
       <mi>X</mi>
       <mi>Z</mi>
       <mi>Y</mi>
      </mrow>
     </mtd>
    </mtr>
    <mtr>
     <mtd columnalign="center">
      <mrow>
       <mi>Z</mi>
       <mi>Y</mi>
       <mi>X</mi>
      </mrow>
     </mtd>
    </mtr>
   </mtable>
   <mrow>
    <mo>|</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <mi>I</mi>
        <mi>I</mi>
        <mi>I</mi>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <mi>I</mi>
        <mi>I</mi>
        <mi>I</mi>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <mi>I</mi>
        <mi>I</mi>
        <mi>I</mi>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <mi>I</mi>
        <mi>I</mi>
        <mi>I</mi>
       </mrow>
      </mtd>
     </mtr>
    </mtable>
    <mo>|</mo>
   </mrow>
   <mi mathvariant="normal">⋯</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-⋯</ci>
    <apply>
     <abs></abs>
     <matrix>
      <matrixrow>
       <apply>
        <times></times>
        <ci>I</ci>
        <ci>I</ci>
        <ci>I</ci>
       </apply>
      </matrixrow>
      <matrixrow>
       <apply>
        <times></times>
        <ci>I</ci>
        <ci>I</ci>
        <ci>I</ci>
       </apply>
      </matrixrow>
      <matrixrow>
       <apply>
        <times></times>
        <ci>I</ci>
        <ci>I</ci>
        <ci>I</ci>
       </apply>
      </matrixrow>
      <matrixrow>
       <apply>
        <times></times>
        <ci>I</ci>
        <ci>I</ci>
        <ci>I</ci>
       </apply>
      </matrixrow>
     </matrix>
    </apply>
    <matrix>
     <matrixrow>
      <apply>
       <times></times>
       <ci>X</ci>
       <ci>X</ci>
       <ci>X</ci>
      </apply>
     </matrixrow>
     <matrixrow>
      <apply>
       <times></times>
       <ci>Z</ci>
       <ci>Z</ci>
       <ci>Z</ci>
      </apply>
     </matrixrow>
     <matrixrow>
      <apply>
       <times></times>
       <ci>I</ci>
       <ci>I</ci>
       <ci>I</ci>
      </apply>
     </matrixrow>
     <matrixrow>
      <apply>
       <times></times>
       <ci>I</ci>
       <ci>I</ci>
       <ci>I</ci>
      </apply>
     </matrixrow>
    </matrix>
    <apply>
     <abs></abs>
     <matrix>
      <matrixrow>
       <apply>
        <times></times>
        <ci>X</ci>
        <ci>Z</ci>
        <ci>Y</ci>
       </apply>
      </matrixrow>
      <matrixrow>
       <apply>
        <times></times>
        <ci>Z</ci>
        <ci>Y</ci>
        <ci>X</ci>
       </apply>
      </matrixrow>
      <matrixrow>
       <apply>
        <times></times>
        <ci>X</ci>
        <ci>X</ci>
        <ci>X</ci>
       </apply>
      </matrixrow>
      <matrixrow>
       <apply>
        <times></times>
        <ci>Z</ci>
        <ci>Z</ci>
        <ci>Z</ci>
       </apply>
      </matrixrow>
     </matrix>
    </apply>
    <matrix>
     <matrixrow>
      <apply>
       <times></times>
       <ci>I</ci>
       <ci>I</ci>
       <ci>I</ci>
      </apply>
     </matrixrow>
     <matrixrow>
      <apply>
       <times></times>
       <ci>I</ci>
       <ci>I</ci>
       <ci>I</ci>
      </apply>
     </matrixrow>
     <matrixrow>
      <apply>
       <times></times>
       <ci>X</ci>
       <ci>Z</ci>
       <ci>Y</ci>
      </apply>
     </matrixrow>
     <matrixrow>
      <apply>
       <times></times>
       <ci>Z</ci>
       <ci>Y</ci>
       <ci>X</ci>
      </apply>
     </matrixrow>
    </matrix>
    <apply>
     <abs></abs>
     <matrix>
      <matrixrow>
       <apply>
        <times></times>
        <ci>I</ci>
        <ci>I</ci>
        <ci>I</ci>
       </apply>
      </matrixrow>
      <matrixrow>
       <apply>
        <times></times>
        <ci>I</ci>
        <ci>I</ci>
        <ci>I</ci>
       </apply>
      </matrixrow>
      <matrixrow>
       <apply>
        <times></times>
        <ci>I</ci>
        <ci>I</ci>
        <ci>I</ci>
       </apply>
      </matrixrow>
      <matrixrow>
       <apply>
        <times></times>
        <ci>I</ci>
        <ci>I</ci>
        <ci>I</ci>
       </apply>
      </matrixrow>
     </matrix>
    </apply>
    <ci>normal-⋯</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \cdots\left|\begin{array}[c]{c}III\\
III\\
III\\
III\end{array}\right|\begin{array}[c]{c}XXX\\
ZZZ\\
III\\
III\end{array}\left|\begin{array}[c]{c}XZY\\
ZYX\\
XXX\\
ZZZ\end{array}\right|\begin{array}[c]{c}III\\
III\\
XZY\\
ZYX\end{array}\left|\begin{array}[c]{c}III\\
III\\
III\\
III\end{array}\right|\cdots
  </annotation>
 </semantics>
</math>

 The code consists of all three-qubit shifts of the above generators. The vertical bars are a visual aid to illustrate the three-qubit shifts of the basic generators. The code can correct for an arbitrary single-qubit error in every other frame.</p>
<h2 id="extensions">Extensions</h2>

<p>Wilde and Brun have integrated the theory of <a href="entanglement-assisted_stabilizer_code" title="wikilink">entanglement-assisted stabilizer codes</a> and quantum convolutional codes in a series of articles (Wilde and Brun 2007a, 2007b, 2008, 2009) to form a theory of entanglement-assisted quantum convolutional coding. This theory supposes that a sender and receiver share noiseless bipartite <a href="Quantum_entanglement" title="wikilink">entanglement</a> that they can exploit for protecting a stream of quantum information.</p>

<p>(Wilde 2009), building on work of (Ollivier and Tillich 2004) and (Grassl and Roetteler 2006), also showed how to encode these codes with quantum shift register circuits, a natural extension of the theory of classical <a href="shift_register" title="wikilink">shift register</a> circuits.</p>
<h2 id="references">References</h2>
<ul>
<li>H. Ollivier and J.-P. Tillich, “Description of a quantum convolutional code,” Phys. Rev. Lett., vol. 91, no. 17, p. 177902, Oct 2003. Available at <a class="uri" href="http://arxiv.org/abs/quant-ph/0304189">http://arxiv.org/abs/quant-ph/0304189</a></li>
<li>H. Ollivier and J.-P. Tillich, “Quantum convolutional codes: fundamentals.” Available at <a class="uri" href="http://arxiv.org/abs/quant-ph/0401134">http://arxiv.org/abs/quant-ph/0401134</a></li>
<li>J. G. David Forney and S. Guha, “Simple rate-1/3 convolutional and tail-biting quantum error-correcting codes,” in IEEE International Symposium on Information Theory, 2005. Available at <a class="uri" href="http://arxiv.org/abs/quant-ph/0501099">http://arxiv.org/abs/quant-ph/0501099</a></li>
<li>G. D. Forney, M. Grassl, and S. Guha, “Convolutional and tail-biting quantum error-correcting codes,” IEEE Trans. Inf. Theory, vol. 53, pp. 865–880, 2007. Available at <a class="uri" href="http://arxiv.org/abs/quant-ph/0511016">http://arxiv.org/abs/quant-ph/0511016</a></li>
<li>M. Grassl and M. Roetteler, “Quantum convolutional codes: Encoders and structural properties,” in Forty-Fourth Annual Allerton Conference, 2006. Available at <a class="uri" href="http://www.csl.illinois.edu/allerton/archives/allerton06/PDFs/papers/0285.pdf">http://www.csl.illinois.edu/allerton/archives/allerton06/PDFs/papers/0285.pdf</a></li>
<li>M. Grassl and M. Roetteler, “Noncatastrophic encoders and encoder inverses for quantum convolutional codes,” in IEEE International Symposium on Information Theory (quant-ph/0602129), 2006. Available at <a class="uri" href="http://arxiv.org/abs/quant-ph/0602129">http://arxiv.org/abs/quant-ph/0602129</a></li>
<li>R. Johannesson and K. S. Zigangirov, Fundamentals of Convolutional Coding. Wiley-IEEE Press, 1999.</li>
<li>Mark M. Wilde, Hari Krovi, and Todd A. Brun. (2007a) <em>Convolutional Entanglement Distillation.</em> Available at <a class="uri" href="http://arxiv.org/abs/0708.3699">http://arxiv.org/abs/0708.3699</a></li>
<li>Mark M. Wilde and Todd A. Brun. (2007b) <em>Entanglement-assisted quantum convolutional coding.</em> Available at <a class="uri" href="http://arxiv.org/abs/0712.2223">http://arxiv.org/abs/0712.2223</a></li>
<li>Mark M. Wilde and Todd A. Brun. <em>Quantum Convolutional Coding with Shared Entanglement: General Structure.</em> Available at <a class="uri" href="http://arxiv.org/abs/0807.3803">http://arxiv.org/abs/0807.3803</a></li>
<li>Mark M. Wilde. <em>Quantum Coding with Entanglement.</em> Ph.D. Dissertation, University of Southern California, August 2008. Available at <a class="uri" href="http://arxiv.org/abs/0806.4214">http://arxiv.org/abs/0806.4214</a></li>
<li>Mark M. Wilde and Todd A. Brun. "Extra shared entanglement reduces memory demand in quantum convolutional coding." Phys. Rev. A 79, 032313 (2009). Available at <a class="uri" href="http://arxiv.org/abs/0812.4449">http://arxiv.org/abs/0812.4449</a></li>
<li>Mark M. Wilde. "Quantum-shift-register circuits." Physical Review A 79, 062325 (2009). Available at <a class="uri" href="http://arxiv.org/abs/0903.3894">http://arxiv.org/abs/0903.3894</a></li>
</ul>

<p>"</p>

<p><a href="Category:Quantum_information_science" title="wikilink">Category:Quantum information science</a></p>
</body>
</html>
