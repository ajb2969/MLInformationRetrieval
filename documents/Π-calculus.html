<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="785">Π-calculus</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Π-calculus</h1>
<hr/>

<p>In <a href="theoretical_computer_science" title="wikilink">theoretical computer science</a>, the <strong>π-calculus</strong> (or <strong>pi-calculus</strong>) is a <a href="process_calculus" title="wikilink">process calculus</a>. The π-calculus allows channel names to be communicated along the channels themselves, and in this way it is able to describe <a href="concurrent_computation" title="wikilink">concurrent computations</a> whose network configuration may change during the computation.</p>

<p>The π-calculus is elegantly simple yet very expressive. Functional programs can be encoded into the π-calculus, and the encoding emphasises the dialogue nature of computation, drawing connections with <a href="game_semantics" title="wikilink">game semantics</a>. Extensions of the π-calculus, such as the spi calculus and applied π, have been successful in reasoning about <a href="cryptographic_protocol" title="wikilink">cryptographic protocols</a>. Beside the original use in describing concurrent systems, the π-calculus has also been used to reason about <a href="business_process" title="wikilink">business processes</a> and <a href="molecular_biology" title="wikilink">molecular biology</a>.</p>
<h2 id="informal-definition">Informal definition</h2>

<p>The π-calculus belongs to the family of <a href="process_calculi" title="wikilink">process calculi</a>, mathematical formalisms for describing and analyzing properties of concurrent computation. In fact, the π-calculus, like the <a href="lambda_calculus" title="wikilink">λ-calculus</a>, is so minimal that it does not contain primitives such as numbers, booleans, data structures, variables, functions, or even the usual control flow statements (such as <code>if-then-else</code>, <code>while</code>).</p>
<h3 id="process-constructs">Process constructs</h3>

<p>Central to the π-calculus is the notion of <em>name</em>. The simplicity of the calculus lies in the dual role that names play as <em>communication channels</em> and <em>variables</em>.</p>

<p>The process constructs available in the calculus are the following (a precise definition is given in the following section):</p>
<ul>
<li><em>concurrency</em>, written 

<math display="inline" id="Π-calculus:0">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mo>∣</mo>
   <mi>Q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <ci>normal-∣</ci>
    <csymbol cd="unknown">Q</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P\mid Q
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Π-calculus:1">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Π-calculus:2">
 <semantics>
  <mi>Q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q
  </annotation>
 </semantics>
</math>

 are two processes or threads executed concurrently.</li>
<li><em>communication</em>, where
<ul>
<li><em>input prefixing</em> 

<math display="inline" id="Π-calculus:3">
 <semantics>
  <mrow>
   <mrow>
    <mi>c</mi>
    <mrow>
     <mo>(</mo>
     <mi>x</mi>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mi>P</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <times></times>
     <ci>c</ci>
     <ci>x</ci>
    </apply>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c\left(x\right).P
  </annotation>
 </semantics>
</math>

 is a process waiting for a message that was sent on a communication channel named 

<math display="inline" id="Π-calculus:4">
 <semantics>
  <mi>c</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>c</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c
  </annotation>
 </semantics>
</math>

 before proceeding as <mtpl></mtpl> binding the name received to the name <mtpl></mtpl> Typically, this models either a process expecting a communication from the network or a label <code>c</code> usable only once by a <code>goto c</code> operation.</li>
<li><em>output prefixing</em> 

<math display="inline" id="Π-calculus:5">
 <semantics>
  <mrow>
   <mrow>
    <mover accent="true">
     <mi>c</mi>
     <mo>¯</mo>
    </mover>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mi>y</mi>
     <mo stretchy="false">⟩</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mi>P</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <times></times>
     <apply>
      <ci>normal-¯</ci>
      <ci>c</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-⟨⟩</csymbol>
      <ci>y</ci>
     </apply>
    </apply>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \overline{c}\langle y\rangle.P
  </annotation>
 </semantics>
</math>

 describes that the name 

<math display="inline" id="Π-calculus:6">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

 is emitted on channel 

<math display="inline" id="Π-calculus:7">
 <semantics>
  <mi>c</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>c</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c
  </annotation>
 </semantics>
</math>

 before proceeding as <mtpl></mtpl> Typically, this models either sending a message on the network or a <code>goto c</code> operation.</li>
</ul></li>
<li><em>replication</em>, written 

<math display="inline" id="Π-calculus:8">
 <semantics>
  <mrow>
   <mo lspace="0pt" rspace="3.5pt">!</mo>
   <mi>P</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <factorial></factorial>
    <csymbol cd="unknown">P</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   !\,P
  </annotation>
 </semantics>
</math>

, which may be seen as a process which can always create a new copy of <mtpl></mtpl> Typically, this models either a network service or a label <code>c</code> waiting for any number of <code>goto c</code> operations.</li>
<li><em>creation of a new name</em>, written 

<math display="inline" id="Π-calculus:9">
 <semantics>
  <mrow>
   <mrow>
    <mo>(</mo>
    <mrow>
     <mi>ν</mi>
     <mi>x</mi>
    </mrow>
    <mo>)</mo>
   </mrow>
   <mi>P</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <times></times>
     <ci>ν</ci>
     <ci>x</ci>
    </apply>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left(\nu x\right)P
  </annotation>
 </semantics>
</math>

, which may be seen as a process allocating a new constant 

<math display="inline" id="Π-calculus:10">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 within <mtpl></mtpl> The constants of  are defined by their names only and are always communication channels. Creation of a new name in a process is also called <em>restriction</em>.</li>
<li>the nil process, written 

<math display="inline" id="Π-calculus:11">
 <semantics>
  <mn>0</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">0</cn>
  </annotation-xml>
 </semantics>
</math>

, is a process whose execution is complete and has stopped.</li>
</ul>

<p>Although the minimalism of the π-calculus prevents us from writing programs in the normal sense, it is easy to extend the calculus. In particular, it is easy to define both control structures such as recursion, loops and sequential composition and datatypes such as first-order functions, <a href="truth_value" title="wikilink">truth values</a>, lists and integers. Moreover, extensions of the  have been proposed which take into account distribution or public-key cryptography. The <em>applied </em> due to Abadi and Fournet <a href="http://www.cse.ucsc.edu/~abadi/Papers/isss02.pdf">1</a> put these various extensions on a formal footing by extending the  with arbitrary datatypes.</p>
<h3 id="a-small-example">A small example</h3>

<p>Below is a tiny example of a process which consists of three parallel components. The channel name 

<math display="inline" id="Π-calculus:12">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 is only known by the first two components.</p>

<p>

<math display="inline" id="Π-calculus:13">
 <semantics>
  <mtable>
   <mtr>
    <mtd columnalign="right">
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>ν</mi>
       <mi>x</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mo rspace="5.3pt" stretchy="false">(</mo>
      <mover accent="true">
       <mi>x</mi>
       <mo>¯</mo>
      </mover>
      <mrow>
       <mo stretchy="false">⟨</mo>
       <mi>z</mi>
       <mo stretchy="false">⟩</mo>
      </mrow>
      <mn>. 0</mn>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd></mtd>
    <mtd columnalign="left">
     <mrow>
      <mo rspace="5.3pt" stretchy="false">|</mo>
      <mi>x</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>y</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo rspace="5.3pt">.</mo>
      <mover accent="true">
       <mi>y</mi>
       <mo>¯</mo>
      </mover>
      <mrow>
       <mo stretchy="false">⟨</mo>
       <mi>x</mi>
       <mo stretchy="false">⟩</mo>
      </mrow>
      <mo rspace="5.3pt">.</mo>
      <mi>x</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>y</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mpadded width="+2.8pt">
       <mn>. 0</mn>
      </mpadded>
      <mo stretchy="false">)</mo>
     </mrow>
    </mtd>
   </mtr>
  </mtable>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <apply>
      <times></times>
      <ci>ν</ci>
      <ci>x</ci>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <ci>normal-¯</ci>
       <ci>x</ci>
      </apply>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-⟨</ci>
       <csymbol cd="unknown">z</csymbol>
       <ci>normal-⟩</ci>
      </cerror>
      <cn type="float">. 0</cn>
     </cerror>
    </matrixrow>
    <matrixrow>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-|</ci>
      <csymbol cd="unknown">x</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">y</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-.</ci>
      <apply>
       <ci>normal-¯</ci>
       <ci>y</ci>
      </apply>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-⟨</ci>
       <csymbol cd="unknown">x</csymbol>
       <ci>normal-⟩</ci>
      </cerror>
      <ci>normal-.</ci>
      <csymbol cd="unknown">x</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">y</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <cn type="float">. 0</cn>
      <ci>normal-)</ci>
     </cerror>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle\begin{aligned}\displaystyle(\nu x)&\displaystyle(\;\overline{x}%
\langle z\rangle.\;0\\
&\displaystyle|\;x(y).\;\overline{y}\langle x\rangle.\;x(y).\;0\;)\end{aligned}
  </annotation>
 </semantics>
</math>


</p>

<p>The first two components are able to communicate on the channel 

<math display="inline" id="Π-calculus:14">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

, and the name 

<math display="inline" id="Π-calculus:15">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>


 becomes bound to 

<math display="inline" id="Π-calculus:16">
 <semantics>
  <mi>z</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>z</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z
  </annotation>
 </semantics>
</math>

. The next step in the process is therefore</p>

<p>

<math display="inline" id="Π-calculus:17">
 <semantics>
  <mtable>
   <mtr>
    <mtd columnalign="right">
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>ν</mi>
       <mi>x</mi>
       <mo rspace="5.3pt" stretchy="false">)</mo>
      </mrow>
      <mo stretchy="false">(</mo>
     </mrow>
    </mtd>
    <mtd columnalign="left">
     <mn>0</mn>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="right">
     <mo stretchy="false">|</mo>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mover accent="true">
       <mi>z</mi>
       <mo>¯</mo>
      </mover>
      <mrow>
       <mo stretchy="false">⟨</mo>
       <mi>x</mi>
       <mo stretchy="false">⟩</mo>
      </mrow>
      <mo rspace="5.3pt">.</mo>
      <mi>x</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>y</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mpadded width="+2.8pt">
       <mn>. 0</mn>
      </mpadded>
      <mo stretchy="false">)</mo>
     </mrow>
    </mtd>
   </mtr>
  </mtable>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">ν</csymbol>
       <csymbol cd="unknown">x</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-(</ci>
     </cerror>
     <cn type="integer">0</cn>
    </matrixrow>
    <matrixrow>
     <ci>normal-|</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <apply>
       <ci>normal-¯</ci>
       <ci>z</ci>
      </apply>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-⟨</ci>
       <csymbol cd="unknown">x</csymbol>
       <ci>normal-⟩</ci>
      </cerror>
      <ci>normal-.</ci>
      <csymbol cd="unknown">x</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">y</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <cn type="float">. 0</cn>
      <ci>normal-)</ci>
     </cerror>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle\begin{aligned}\displaystyle(\nu x)\;(&\displaystyle 0\\
\displaystyle|&\displaystyle\overline{z}\langle x\rangle.\;x(y).\;0\;)\end{%
aligned}\par
  </annotation>
 </semantics>
</math>


</p>

<p>Note that the remaining 

<math display="inline" id="Π-calculus:18">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

 is not affected because it is defined in an inner scope. The second and third parallel components can now communicate on the channel name 

<math display="inline" id="Π-calculus:19">
 <semantics>
  <mi>z</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>z</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z
  </annotation>
 </semantics>
</math>

, and the name 

<math display="inline" id="Π-calculus:20">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>

 becomes bound to 

<math display="inline" id="Π-calculus:21">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

. The next step in the process is now</p>

<p>

<math display="inline" id="Π-calculus:22">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>ν</mi>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo stretchy="false">(</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">ν</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-(</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle\par
(\nu x)(
  </annotation>
 </semantics>
</math>


</p>

<p>Note that since the local name 

<math display="inline" id="Π-calculus:23">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 has been output, the scope of 

<math display="inline" id="Π-calculus:24">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 is extended to cover the third component as well. Finally, the channel 

<math display="inline" id="Π-calculus:25">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 can be used for sending the name 

<math display="inline" id="Π-calculus:26">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

. After that all concurrently executing processes have stopped</p>

<p>

<math display="inline" id="Π-calculus:27">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>ν</mi>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo stretchy="false">(</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">ν</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-(</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle\par
(\nu x)(
  </annotation>
 </semantics>
</math>


</p>
<h2 id="formal-definition">Formal definition</h2>
<h3 id="syntax">Syntax</h3>

<p>Let Χ be a set of objects called <em>names</em>. The <a href="abstract_syntax" title="wikilink">abstract syntax</a> for the π-calculus is built from the following <a href="BNF_grammar" title="wikilink">BNF grammar</a> (where <em>x</em> and <em>y</em> are any names from Χ):<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>

<p>

<math display="inline" id="Π-calculus:28">
 <semantics>
  <mrow>
   <mrow>
    <mi>P</mi>
    <mo>,</mo>
    <mi>Q</mi>
    <mo>,</mo>
    <mi>R</mi>
   </mrow>
   <mo>:</mo>
   <mo>:=</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <list>
     <ci>P</ci>
     <ci>Q</ci>
     <ci>R</ci>
    </list>
    <csymbol cd="latexml">assign</csymbol>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle P,Q,R::=
  </annotation>
 </semantics>
</math>


</p>

<p>In the concrete syntax below, the prefixes bind more tightly than the parallel composition (|), and parentheses are used to disambiguate.</p>

<p>Names are bound by the restriction and input prefix constructs. Formally, the sets of free and bound names of a process in π–calculus are defined inductively as follows.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>Construct</p></th>
<th style="text-align: left;">
<p>Free names</p></th>
<th style="text-align: left;">
<p>Bound names</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>

<math display="inline" id="Π-calculus:29">
 <semantics>
  <mn>0</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">0</cn>
  </annotation-xml>
 </semantics>
</math>


</p></td>
<td style="text-align: left;">
<p>None</p></td>
<td style="text-align: left;">
<p>None</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>

<math display="inline" id="Π-calculus:30">
 <semantics>
  <mrow>
   <mrow>
    <mover accent="true">
     <mi>a</mi>
     <mo>¯</mo>
    </mover>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mi>x</mi>
     <mo stretchy="false">⟩</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mi>P</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <times></times>
     <apply>
      <ci>normal-¯</ci>
      <ci>a</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-⟨⟩</csymbol>
      <ci>x</ci>
     </apply>
    </apply>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \overline{a}\langle x\rangle.P
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p><em>a</em>; <em>x</em>; all free names of <em>P</em></p></td>
<td style="text-align: left;">
<p>All bound names of <em>P</em></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>

<math display="inline" id="Π-calculus:31">
 <semantics>
  <mrow>
   <mrow>
    <mi>a</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mi>P</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <times></times>
     <ci>a</ci>
     <ci>x</ci>
    </apply>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a(x).P
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p><em>a</em>; free names of <em>P</em> except for <em>x</em></p></td>
<td style="text-align: left;">
<p><em>x</em>; all bound names of <em>P</em></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>

<math display="inline" id="Π-calculus:32">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mo stretchy="false">|</mo>
   <mi>Q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <ci>normal-|</ci>
    <csymbol cd="unknown">Q</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P|Q
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>All free names of <em>P</em> and <em>Q</em></p></td>
<td style="text-align: left;">
<p>All bound names of <em>P</em> and <em>Q</em></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>

<math display="inline" id="Π-calculus:33">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>ν</mi>
     <mi>x</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>.</mo>
   <mi>P</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <times></times>
     <ci>ν</ci>
     <ci>x</ci>
    </apply>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\nu x).P
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>Free names of <em>P</em> except for <em>x</em></p></td>
<td style="text-align: left;">
<p><em>x</em>; all bound names of <em>P</em></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>

<math display="inline" id="Π-calculus:34">
 <semantics>
  <mrow>
   <mo lspace="0pt" rspace="3.5pt">!</mo>
   <mi>P</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <factorial></factorial>
    <csymbol cd="unknown">P</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   !P
  </annotation>
 </semantics>
</math>


</p></td>
<td style="text-align: left;">
<p>All free names of <em>P</em></p></td>
<td style="text-align: left;">
<p>All bound names of <em>P</em></p></td>
</tr>
</tbody>
</table>
<h3 id="structural-congruence">Structural congruence</h3>

<p>Central to both the reduction semantics and the labelled transition semantics is the notion of <strong>structural congruence</strong>. Two processes are structurally congruent, if they are identical up to structure. In particular, parallel composition is commutative and associative.</p>

<p>More precisely, structural congruence is defined as the least equivalence relation preserved by the process constructs and satisfying:</p>

<p><em>Alpha-conversion</em>:</p>

<p>:* 

<math display="inline" id="Π-calculus:35">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mo>≡</mo>
   <mi>Q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <ci>P</ci>
    <ci>Q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P\equiv Q
  </annotation>
 </semantics>
</math>

 if 

<math display="inline" id="Π-calculus:36">
 <semantics>
  <mi>Q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q
  </annotation>
 </semantics>
</math>

 can be obtained from 

<math display="inline" id="Π-calculus:37">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 by renaming one or more bound names in 

<math display="inline" id="Π-calculus:38">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

.</p>

<p><em>Axioms for parallel composition</em>:</p>

<p>:* 

<math display="inline" id="Π-calculus:39">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mo stretchy="false">|</mo>
   <mi>Q</mi>
   <mo>≡</mo>
   <mi>Q</mi>
   <mo stretchy="false">|</mo>
   <mi>P</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <ci>normal-|</ci>
    <csymbol cd="unknown">Q</csymbol>
    <equivalent></equivalent>
    <csymbol cd="unknown">Q</csymbol>
    <ci>normal-|</ci>
    <csymbol cd="unknown">P</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P|Q\equiv Q|P
  </annotation>
 </semantics>
</math>


</p>

<p>:* 

<math display="inline" id="Π-calculus:40">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>P</mi>
    <mo stretchy="false">|</mo>
    <mi>Q</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo stretchy="false">|</mo>
   <mi>R</mi>
   <mo>≡</mo>
   <mi>P</mi>
   <mo stretchy="false">|</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>Q</mi>
    <mo stretchy="false">|</mo>
    <mi>R</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">P</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">Q</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-|</ci>
    <csymbol cd="unknown">R</csymbol>
    <equivalent></equivalent>
    <csymbol cd="unknown">P</csymbol>
    <ci>normal-|</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">Q</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">R</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (P|Q)|R\equiv P|(Q|R)
  </annotation>
 </semantics>
</math>

</p>

<p>:*

<math display="inline" id="Π-calculus:41">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mo stretchy="false">|</mo>
   <mn>0</mn>
   <mo>≡</mo>
   <mi>P</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <ci>normal-|</ci>
    <cn type="integer">0</cn>
    <equivalent></equivalent>
    <csymbol cd="unknown">P</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P|0\equiv P
  </annotation>
 </semantics>
</math>

</p>

<p><em>Axioms for restriction</em>:</p>

<p>:* 

<math display="inline" id="Π-calculus:42">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>ν</mi>
      <mi>x</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>ν</mi>
      <mi>y</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>P</mi>
   </mrow>
   <mo>≡</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>ν</mi>
      <mi>y</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>ν</mi>
      <mi>x</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>P</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <times></times>
     <apply>
      <times></times>
      <ci>ν</ci>
      <ci>x</ci>
     </apply>
     <apply>
      <times></times>
      <ci>ν</ci>
      <ci>y</ci>
     </apply>
     <ci>P</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <times></times>
      <ci>ν</ci>
      <ci>y</ci>
     </apply>
     <apply>
      <times></times>
      <ci>ν</ci>
      <ci>x</ci>
     </apply>
     <ci>P</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\nu x)(\nu y)P\equiv(\nu y)(\nu x)P
  </annotation>
 </semantics>
</math>

</p>

<p>:* 

<math display="inline" id="Π-calculus:43">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>ν</mi>
      <mi>x</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mn>0</mn>
   </mrow>
   <mo>≡</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <times></times>
     <apply>
      <times></times>
      <ci>ν</ci>
      <ci>x</ci>
     </apply>
     <cn type="integer">0</cn>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\nu x)0\equiv 0
  </annotation>
 </semantics>
</math>

</p>

<p><em>Axiom for replication</em>:</p>

<p>:* 

<math display="inline" id="Π-calculus:44">
 <semantics>
  <mrow>
   <mo lspace="0pt" rspace="3.5pt">!</mo>
   <mi>P</mi>
   <mo>≡</mo>
   <mi>P</mi>
   <mo stretchy="false">|</mo>
   <mo lspace="0pt" rspace="3.5pt">!</mo>
   <mi>P</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <factorial></factorial>
    <csymbol cd="unknown">P</csymbol>
    <equivalent></equivalent>
    <csymbol cd="unknown">P</csymbol>
    <ci>normal-|</ci>
    <factorial></factorial>
    <csymbol cd="unknown">P</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   !P\equiv P|!P
  </annotation>
 </semantics>
</math>


</p>

<p><em>Axiom relating restriction and parallel</em>:</p>

<p>:* 

<math display="inline" id="Π-calculus:45">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>ν</mi>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>P</mi>
    <mo stretchy="false">|</mo>
    <mi>Q</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>≡</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>ν</mi>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi>P</mi>
   <mo stretchy="false">|</mo>
   <mi>Q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">ν</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">P</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">Q</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <equivalent></equivalent>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">ν</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">P</csymbol>
    <ci>normal-|</ci>
    <csymbol cd="unknown">Q</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\nu x)(P|Q)\equiv(\nu x)P|Q
  </annotation>
 </semantics>
</math>

 if 

<math display="inline" id="Π-calculus:46">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 is not a free name of 

<math display="inline" id="Π-calculus:47">
 <semantics>
  <mi>Q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q
  </annotation>
 </semantics>
</math>

.</p>

<p>This last axiom is known as the "scope extension" axiom. This axiom is central, since it describes how a bound name 

<math display="inline" id="Π-calculus:48">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 may be extruded by an output action, causing the scope of 

<math display="inline" id="Π-calculus:49">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>


 to be extended. In cases where 

<math display="inline" id="Π-calculus:50">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 is a free name of 

<math display="inline" id="Π-calculus:51">
 <semantics>
  <mi>Q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q
  </annotation>
 </semantics>
</math>

, alpha-conversion may be used to allow extension to proceed.</p>
<h3 id="reduction-semantics">Reduction semantics</h3>

<p>We write 

<math display="inline" id="Π-calculus:52">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mo>→</mo>
   <msup>
    <mi>P</mi>
    <mo>′</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>P</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>P</ci>
     <ci>normal-′</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P\rightarrow P^{\prime}
  </annotation>
 </semantics>
</math>

 if 

<math display="inline" id="Π-calculus:53">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 can perform a computation step, following which it is now 

<math display="inline" id="Π-calculus:54">
 <semantics>
  <msup>
   <mi>P</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>P</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P^{\prime}
  </annotation>
 </semantics>
</math>


. This <em>reduction relation</em> 

<math display="inline" id="Π-calculus:55">
 <semantics>
  <mo>→</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-→</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rightarrow
  </annotation>
 </semantics>
</math>

 is defined as the least relation closed under a set of reduction rules.</p>

<p>The main reduction rule which captures the ability of processes to communicate through channels is the following:</p>
<ul>
<li>

<math display="inline" id="Π-calculus:56">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>x</mi>
    <mo>¯</mo>
   </mover>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mi>z</mi>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo>.</mo>
   <mi>P</mi>
   <mo stretchy="false">|</mo>
   <mi>x</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>.</mo>
   <mi>Q</mi>
   <mo>→</mo>
   <mi>P</mi>
   <mo stretchy="false">|</mo>
   <mi>Q</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>z</mi>
    <mo>/</mo>
    <mi>y</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <ci>normal-¯</ci>
     <ci>x</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-⟨</ci>
     <csymbol cd="unknown">z</csymbol>
     <ci>normal-⟩</ci>
    </cerror>
    <ci>normal-.</ci>
    <csymbol cd="unknown">P</csymbol>
    <ci>normal-|</ci>
    <csymbol cd="unknown">x</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-.</ci>
    <csymbol cd="unknown">Q</csymbol>
    <ci>normal-→</ci>
    <csymbol cd="unknown">P</csymbol>
    <ci>normal-|</ci>
    <csymbol cd="unknown">Q</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">z</csymbol>
     <divide></divide>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \overline{x}\langle z\rangle.P|x(y).Q\rightarrow P|Q[z/y]
  </annotation>
 </semantics>
</math>

</li>
</ul>
<dl>
<dd>where 

<math display="inline" id="Π-calculus:57">
 <semantics>
  <mrow>
   <mi>Q</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mrow>
     <mi>z</mi>
     <mo>/</mo>
     <mi>y</mi>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>Q</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <apply>
      <divide></divide>
      <ci>z</ci>
      <ci>y</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q[z/y]
  </annotation>
 </semantics>
</math>

 denotes the process 

<math display="inline" id="Π-calculus:58">
 <semantics>
  <mi>Q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q
  </annotation>
 </semantics>
</math>

 in which the free name 

<math display="inline" id="Π-calculus:59">
 <semantics>
  <mi>z</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>z</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z
  </annotation>
 </semantics>
</math>


 has been <em>substituted</em> for the free occurrences of 

<math display="inline" id="Π-calculus:60">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

. If a free occurrence of 

<math display="inline" id="Π-calculus:61">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

 occurs in a location where 

<math display="inline" id="Π-calculus:62">
 <semantics>
  <mi>z</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>z</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z
  </annotation>
 </semantics>
</math>

 would not be free, alpha-conversion may be required.
</dd>
</dl>

<p>There are three additional rules:</p>
<ul>
<li>If 

<math display="inline" id="Π-calculus:63">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mo>→</mo>
   <mi>Q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>P</ci>
    <ci>Q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P\rightarrow Q
  </annotation>
 </semantics>
</math>

 then also 

<math display="inline" id="Π-calculus:64">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mo stretchy="false">|</mo>
   <mi>R</mi>
   <mo>→</mo>
   <mi>Q</mi>
   <mo stretchy="false">|</mo>
   <mi>R</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <ci>normal-|</ci>
    <csymbol cd="unknown">R</csymbol>
    <ci>normal-→</ci>
    <csymbol cd="unknown">Q</csymbol>
    <ci>normal-|</ci>
    <csymbol cd="unknown">R</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P|R\rightarrow Q|R
  </annotation>
 </semantics>
</math>


.</li>
</ul>
<dl>
<dd>This rule says that parallel composition does not inhibit computation.
</dd>
</dl>
<ul>
<li>If 

<math display="inline" id="Π-calculus:65">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mo>→</mo>
   <mi>Q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>P</ci>
    <ci>Q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P\rightarrow Q
  </annotation>
 </semantics>
</math>

, then also 

<math display="inline" id="Π-calculus:66">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>ν</mi>
      <mi>x</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>P</mi>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>ν</mi>
      <mi>x</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>Q</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <times></times>
     <apply>
      <times></times>
      <ci>ν</ci>
      <ci>x</ci>
     </apply>
     <ci>P</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <times></times>
      <ci>ν</ci>
      <ci>x</ci>
     </apply>
     <ci>Q</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\nu x)P\rightarrow(\nu x)Q
  </annotation>
 </semantics>
</math>

.</li>
</ul>
<dl>
<dd>This rule ensures that computation can proceed underneath a restriction.
</dd>
</dl>
<ul>
<li>If 

<math display="inline" id="Π-calculus:67">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mo>≡</mo>
   <msup>
    <mi>P</mi>
    <mo>′</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <ci>P</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>P</ci>
     <ci>normal-′</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P\equiv P^{\prime}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Π-calculus:68">
 <semantics>
  <mrow>
   <msup>
    <mi>P</mi>
    <mo>′</mo>
   </msup>
   <mo>→</mo>
   <msup>
    <mi>Q</mi>
    <mo>′</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>P</ci>
     <ci>normal-′</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>Q</ci>
     <ci>normal-′</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P^{\prime}\rightarrow Q^{\prime}
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Π-calculus:69">
 <semantics>
  <mrow>
   <msup>
    <mi>Q</mi>
    <mo>′</mo>
   </msup>
   <mo>≡</mo>
   <mi>Q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>Q</ci>
     <ci>normal-′</ci>
    </apply>
    <ci>Q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q^{\prime}\equiv Q
  </annotation>
 </semantics>
</math>


, then also 

<math display="inline" id="Π-calculus:70">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mo>→</mo>
   <mi>Q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>P</ci>
    <ci>Q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P\rightarrow Q
  </annotation>
 </semantics>
</math>

.</li>
</ul>

<p>The latter rule states that processes that are structurally congruent have the same reductions.</p>
<h3 id="the-example-revisited">The example revisited</h3>

<p>Consider again the process</p>

<p>

<math display="block" id="Π-calculus:71">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>ν</mi>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mover accent="true">
     <mi>x</mi>
     <mo>¯</mo>
    </mover>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mi>z</mi>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mn>.0</mn>
    <mo stretchy="false">|</mo>
    <mi>x</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>.</mo>
    <mover accent="true">
     <mi>y</mi>
     <mo>¯</mo>
    </mover>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mi>x</mi>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mo>.</mo>
    <mi>x</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mn>.0</mn>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo stretchy="false">|</mo>
   <mi>z</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>v</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>.</mo>
   <mover accent="true">
    <mi>v</mi>
    <mo>¯</mo>
   </mover>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mi>v</mi>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mn>.0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">ν</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <ci>normal-¯</ci>
      <ci>x</ci>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-⟨</ci>
      <csymbol cd="unknown">z</csymbol>
      <ci>normal-⟩</ci>
     </cerror>
     <cn type="float">.0</cn>
     <ci>normal-|</ci>
     <csymbol cd="unknown">x</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">y</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-.</ci>
     <apply>
      <ci>normal-¯</ci>
      <ci>y</ci>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-⟨</ci>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-⟩</ci>
     </cerror>
     <ci>normal-.</ci>
     <csymbol cd="unknown">x</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">y</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <cn type="float">.0</cn>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-|</ci>
    <csymbol cd="unknown">z</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">v</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-.</ci>
    <apply>
     <ci>normal-¯</ci>
     <ci>v</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-⟨</ci>
     <csymbol cd="unknown">v</csymbol>
     <ci>normal-⟩</ci>
    </cerror>
    <cn type="float">.0</cn>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\nu x)(\overline{x}\langle z\rangle.0|x(y).\overline{y}\langle x\rangle.x(y).%
0)|z(v).\overline{v}\langle v\rangle.0
  </annotation>
 </semantics>
</math>

</p>

<p>Applying the definition of the reduction semantics, we get the reduction</p>

<p>

<math display="block" id="Π-calculus:72">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>ν</mi>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mover accent="true">
     <mi>x</mi>
     <mo>¯</mo>
    </mover>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mi>z</mi>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mn>.0</mn>
    <mo stretchy="false">|</mo>
    <mi>x</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>.</mo>
    <mover accent="true">
     <mi>y</mi>
     <mo>¯</mo>
    </mover>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mi>x</mi>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mo>.</mo>
    <mi>x</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mn>.0</mn>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo stretchy="false">|</mo>
   <mi>z</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>v</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>.</mo>
   <mover accent="true">
    <mi>v</mi>
    <mo>¯</mo>
   </mover>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mi>v</mi>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mn>.0</mn>
   <mo>→</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>ν</mi>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>0</mn>
    <mo stretchy="false">|</mo>
    <mover accent="true">
     <mi>z</mi>
     <mo>¯</mo>
    </mover>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mi>x</mi>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mo>.</mo>
    <mi>x</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mn>.0</mn>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo stretchy="false">|</mo>
   <mi>z</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>v</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>.</mo>
   <mover accent="true">
    <mi>v</mi>
    <mo>¯</mo>
   </mover>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mi>v</mi>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mn>.0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">ν</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <ci>normal-¯</ci>
      <ci>x</ci>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-⟨</ci>
      <csymbol cd="unknown">z</csymbol>
      <ci>normal-⟩</ci>
     </cerror>
     <cn type="float">.0</cn>
     <ci>normal-|</ci>
     <csymbol cd="unknown">x</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">y</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-.</ci>
     <apply>
      <ci>normal-¯</ci>
      <ci>y</ci>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-⟨</ci>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-⟩</ci>
     </cerror>
     <ci>normal-.</ci>
     <csymbol cd="unknown">x</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">y</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <cn type="float">.0</cn>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-|</ci>
    <csymbol cd="unknown">z</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">v</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-.</ci>
    <apply>
     <ci>normal-¯</ci>
     <ci>v</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-⟨</ci>
     <csymbol cd="unknown">v</csymbol>
     <ci>normal-⟩</ci>
    </cerror>
    <cn type="float">.0</cn>
    <ci>normal-→</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">ν</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cn type="integer">0</cn>
     <ci>normal-|</ci>
     <apply>
      <ci>normal-¯</ci>
      <ci>z</ci>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-⟨</ci>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-⟩</ci>
     </cerror>
     <ci>normal-.</ci>
     <csymbol cd="unknown">x</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">z</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <cn type="float">.0</cn>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-|</ci>
    <csymbol cd="unknown">z</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">v</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-.</ci>
    <apply>
     <ci>normal-¯</ci>
     <ci>v</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-⟨</ci>
     <csymbol cd="unknown">v</csymbol>
     <ci>normal-⟩</ci>
    </cerror>
    <cn type="float">.0</cn>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\nu x)(\overline{x}\langle z\rangle.0|x(y).\overline{y}\langle x\rangle.x(y).%
0)|z(v).\overline{v}\langle v\rangle.0\rightarrow(\nu x)(0|\overline{z}\langle
x%
\rangle.x(z).0)|z(v).\overline{v}\langle v\rangle.0
  </annotation>
 </semantics>
</math>

</p>

<p>Note how, applying the reduction substitution axiom, occurrences of 

<math display="inline" id="Π-calculus:73">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

 are now labeled as 

<math display="inline" id="Π-calculus:74">
 <semantics>
  <mi>z</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>z</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z
  </annotation>
 </semantics>
</math>


.</p>

<p>Next, we get the reduction</p>

<p>

<math display="block" id="Π-calculus:75">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>ν</mi>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>0</mn>
    <mo stretchy="false">|</mo>
    <mover accent="true">
     <mi>z</mi>
     <mo>¯</mo>
    </mover>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mi>x</mi>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mo>.</mo>
    <mi>x</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mn>.0</mn>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo stretchy="false">|</mo>
   <mi>z</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>v</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>.</mo>
   <mover accent="true">
    <mi>v</mi>
    <mo>¯</mo>
   </mover>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mi>v</mi>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mn>.0</mn>
   <mo>→</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>ν</mi>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>0</mn>
    <mo stretchy="false">|</mo>
    <mi>x</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mn>.0</mn>
    <mo stretchy="false">|</mo>
    <mover accent="true">
     <mi>x</mi>
     <mo>¯</mo>
    </mover>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mi>x</mi>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mn>.0</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">ν</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cn type="integer">0</cn>
     <ci>normal-|</ci>
     <apply>
      <ci>normal-¯</ci>
      <ci>z</ci>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-⟨</ci>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-⟩</ci>
     </cerror>
     <ci>normal-.</ci>
     <csymbol cd="unknown">x</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">z</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <cn type="float">.0</cn>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-|</ci>
    <csymbol cd="unknown">z</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">v</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-.</ci>
    <apply>
     <ci>normal-¯</ci>
     <ci>v</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-⟨</ci>
     <csymbol cd="unknown">v</csymbol>
     <ci>normal-⟩</ci>
    </cerror>
    <cn type="float">.0</cn>
    <ci>normal-→</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">ν</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cn type="integer">0</cn>
     <ci>normal-|</ci>
     <csymbol cd="unknown">x</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">z</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <cn type="float">.0</cn>
     <ci>normal-|</ci>
     <apply>
      <ci>normal-¯</ci>
      <ci>x</ci>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-⟨</ci>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-⟩</ci>
     </cerror>
     <cn type="float">.0</cn>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\nu x)(0|\overline{z}\langle x\rangle.x(z).0)|z(v).\overline{v}\langle v%
\rangle.0\rightarrow(\nu x)(0|x(z).0|\overline{x}\langle x\rangle.0)
  </annotation>
 </semantics>
</math>

</p>

<p>Note that since the local name 

<math display="inline" id="Π-calculus:76">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 has been output, the scope of 

<math display="inline" id="Π-calculus:77">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 is extended to cover the third component as well. This was captured using the scope extension axiom.</p>
<h3 id="labelled-semantics">Labelled semantics</h3>

<p>Alternatively, one may give the pi-calculus a labelled transition semantics (as has been done with the <a href="Calculus_of_Communicating_Systems" title="wikilink">Calculus of Communicating Systems</a>). Transitions in this semantics are of the form:</p>

<p>

<math display="block" id="Π-calculus:78">
 <semantics>
  <mrow>
   <mpadded width="+1.7pt">
    <mi>P</mi>
   </mpadded>
   <mpadded width="+1.7pt">
    <mover accent="true">
     <mo>→</mo>
     <mo>𝛼</mo>
    </mover>
   </mpadded>
   <msup>
    <mi>P</mi>
    <mo>′</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <ci>α</ci>
     <ci>normal-→</ci>
    </apply>
    <ci>P</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>P</ci>
     <ci>normal-′</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P\,\xrightarrow{\alpha}\,P^{\prime}
  </annotation>
 </semantics>
</math>

</p>

<p>This <a href="State_transition_system" title="wikilink">notation</a> signifies that 

<math display="inline" id="Π-calculus:79">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>


 after the action 

<math display="inline" id="Π-calculus:80">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>

 becomes 

<math display="inline" id="Π-calculus:81">
 <semantics>
  <msup>
   <mi>P</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>P</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P^{\prime}
  </annotation>
 </semantics>
</math>

. 

<math display="inline" id="Π-calculus:82">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>

 can be an <em>input action</em> 

<math display="inline" id="Π-calculus:83">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>a</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a(x)
  </annotation>
 </semantics>
</math>

, an <em>output action</em> <em>

<math display="inline" id="Π-calculus:84">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>a</mi>
    <mo>¯</mo>
   </mover>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mi>x</mi>
    <mo stretchy="false">⟩</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <ci>normal-¯</ci>
     <ci>a</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">delimited-⟨⟩</csymbol>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \overline{a}\langle x\rangle
  </annotation>
 </semantics>
</math>


</em>, or a tau-action 

<math display="inline" id="Π-calculus:85">
 <semantics>
  <mi>τ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>τ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau
  </annotation>
 </semantics>
</math>

 corresponding to an internal communication.</p>

<p>A standard result about the labelled semantics is that it agrees with the reduction semantics in the sense that 

<math display="inline" id="Π-calculus:86">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mo>→</mo>
   <msup>
    <mi>P</mi>
    <mo>′</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>P</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>P</ci>
     <ci>normal-′</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P\rightarrow P^{\prime}
  </annotation>
 </semantics>
</math>

 if and only if 

<math display="inline" id="Π-calculus:87">
 <semantics>
  <mrow>
   <mpadded width="+1.7pt">
    <mi>P</mi>
   </mpadded>
   <mpadded width="+1.7pt">
    <mover accent="true">
     <mo>→</mo>
     <mo>𝜏</mo>
    </mover>
   </mpadded>
   <msup>
    <mi>P</mi>
    <mo>′</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <ci>τ</ci>
     <ci>normal-→</ci>
    </apply>
    <ci>P</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>P</ci>
     <ci>normal-′</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P\,\xrightarrow{\tau}\,P^{\prime}
  </annotation>
 </semantics>
</math>

 for some action 

<math display="inline" id="Π-calculus:88">
 <semantics>
  <mi>τ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>τ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="extensions-and-variants">Extensions and variants</h2>

<p>The syntax given above is a minimal one. However, the syntax may be modified in various ways.</p>

<p>A <em>nondeterministic choice operator</em> 

<math display="inline" id="Π-calculus:89">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mo>+</mo>
   <mi>Q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>P</ci>
    <ci>Q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P+Q
  </annotation>
 </semantics>
</math>


 can be added to the syntax.</p>

<p>A test for <em>name equality</em> 

<math display="inline" id="Π-calculus:90">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>x</mi>
    <mo>=</mo>
    <mi>y</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mi>P</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">x</csymbol>
     <eq></eq>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <csymbol cd="unknown">P</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [x=y]P
  </annotation>
 </semantics>
</math>

 can be added to the syntax. This <em>match operator</em> can proceed as 

<math display="inline" id="Π-calculus:91">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 if and only if 

<math display="inline" id="Π-calculus:92">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Π-calculus:93">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

 are the same name. Similarly, one may add a <em>mismatch operator</em> for <strong>name inequality</strong>. Practical programs which can pass names (URLs or pointers) often use such functionality: for directly modelling such functionality inside the calculus, this and related extensions are often useful.</p>

<p>The <em>asynchronous π-calculus</em> allows only outputs with no suffix, i.e. output atoms of the form 

<math display="inline" id="Π-calculus:94">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>x</mi>
    <mo>¯</mo>
   </mover>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mi>y</mi>
    <mo stretchy="false">⟩</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <ci>normal-¯</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">delimited-⟨⟩</csymbol>
     <ci>y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \overline{x}\langle y\rangle
  </annotation>
 </semantics>
</math>


, yielding a smaller calculus. However, any process in the original calculus can be represented by the smaller asynchronous π-calculus using an extra channel to simulate explicit acknowledgement from the receiving process. Since a continuation-free output can model a message-in-transit, this fragment shows that the original π-calculus, which is intuitively based on synchronous communication, has an expressive asynchronous communication model inside its syntax. However, the nondeterministic choice operator defined above cannot be expressed in this way, as an <a href="guard_(computer_science)" title="wikilink">unguarded</a> choice would be converted into a guarded one; this fact has been used to demonstrate that the asynchronous calculus is strictly less expressive than the synchronous one (with the choice operator).<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>

<p>The <em>polyadic π-calculus</em> allows communicating more than one name in a single action

<math display="block" id="Π-calculus:95">
 <semantics>
  <mrow>
   <mrow>
    <mover accent="true">
     <mi>x</mi>
     <mo>¯</mo>
    </mover>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <msub>
      <mi>z</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mrow>
      <mi mathvariant="normal">…</mi>
      <msub>
       <mi>z</mi>
       <mi>n</mi>
      </msub>
     </mrow>
     <mo stretchy="false">⟩</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mi>P</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <times></times>
     <apply>
      <ci>normal-¯</ci>
      <ci>x</ci>
     </apply>
     <list>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>z</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <times></times>
       <ci>normal-…</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>z</ci>
        <ci>n</ci>
       </apply>
      </apply>
     </list>
    </apply>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \overline{x}\langle z_{1},...z_{n}\rangle.P
  </annotation>
 </semantics>
</math>

 <em>(polyadic output)</em> and 

<math display="inline" id="Π-calculus:96">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>z</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mrow>
     <mi mathvariant="normal">…</mi>
     <msub>
      <mi>z</mi>
      <mi>n</mi>
     </msub>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>x</ci>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>z</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <times></times>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>z</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x(z_{1},...z_{n})
  </annotation>
 </semantics>
</math>

 <em>(polyadic input)</em>. This polyadic extension, which is useful especially when studying types for name passing processes, can be encoded in the monadic calculus by passing the name of a private channel through which the multiple arguments are then passed in sequence. The encoding is defined recursively by the clauses</p>

<p>

<math display="inline" id="Π-calculus:97">
 <semantics>
  <mrow>
   <mrow>
    <mover accent="true">
     <mi>x</mi>
     <mo>¯</mo>
    </mover>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <msub>
      <mi>y</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">⋯</mi>
     <mo>,</mo>
     <msub>
      <mi>y</mi>
      <mi>n</mi>
     </msub>
     <mo stretchy="false">⟩</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mi>P</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <times></times>
     <apply>
      <ci>normal-¯</ci>
      <ci>x</ci>
     </apply>
     <list>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-⋯</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <ci>n</ci>
      </apply>
     </list>
    </apply>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \overline{x}\langle y_{1},\cdots,y_{n}\rangle.P
  </annotation>
 </semantics>
</math>

 is encoded as 

<math display="inline" id="Π-calculus:98">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>ν</mi>
      <mi>w</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mover accent="true">
     <mi>x</mi>
     <mo>¯</mo>
    </mover>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mi>w</mi>
     <mo stretchy="false">⟩</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mover accent="true">
     <mi>w</mi>
     <mo>¯</mo>
    </mover>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <msub>
      <mi>y</mi>
      <mn>1</mn>
     </msub>
     <mo stretchy="false">⟩</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mi mathvariant="normal">⋯</mi>
   <mo>.</mo>
   <mrow>
    <mover accent="true">
     <mi>w</mi>
     <mo>¯</mo>
    </mover>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <msub>
      <mi>y</mi>
      <mi>n</mi>
     </msub>
     <mo stretchy="false">⟩</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>P</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <times></times>
     <apply>
      <times></times>
      <ci>ν</ci>
      <ci>w</ci>
     </apply>
     <apply>
      <ci>normal-¯</ci>
      <ci>x</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-⟨⟩</csymbol>
      <ci>w</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <ci>normal-¯</ci>
      <ci>w</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-⟨⟩</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
    <ci>normal-⋯</ci>
    <apply>
     <times></times>
     <apply>
      <ci>normal-¯</ci>
      <ci>w</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-⟨⟩</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>P</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\nu w)\overline{x}\langle w\rangle.\overline{w}\langle y_{1}\rangle.\cdots.%
\overline{w}\langle y_{n}\rangle.[P]
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Π-calculus:99">
 <semantics>
  <mrow>
   <mrow>
    <mi>x</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>y</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">⋯</mi>
     <mo>,</mo>
     <msub>
      <mi>y</mi>
      <mi>n</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mi>P</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <times></times>
     <ci>x</ci>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-⋯</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <ci>n</ci>
      </apply>
     </vector>
    </apply>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x(y_{1},\cdots,y_{n}).P
  </annotation>
 </semantics>
</math>


 is encoded as 

<math display="inline" id="Π-calculus:100">
 <semantics>
  <mrow>
   <mrow>
    <mi>x</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>w</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>w</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>y</mi>
      <mn>1</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mi mathvariant="normal">⋯</mi>
   <mo>.</mo>
   <mrow>
    <mi>w</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>y</mi>
      <mi>n</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>P</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <times></times>
     <ci>x</ci>
     <ci>w</ci>
    </apply>
    <apply>
     <times></times>
     <ci>w</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <ci>normal-⋯</ci>
    <apply>
     <times></times>
     <ci>w</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>P</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x(w).w(y_{1}).\cdots.w(y_{n}).[P]
  </annotation>
 </semantics>
</math>

</p>

<p>All other process constructs are left unchanged by the encoding.</p>

<p>In the above, 

<math display="inline" id="Π-calculus:101">
 <semantics>
  <mrow>
   <mo stretchy="false">[</mo>
   <mi>P</mi>
   <mo stretchy="false">]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">delimited-[]</csymbol>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [P]
  </annotation>
 </semantics>
</math>

 denotes the encoding of all prefixes in the continuation 

<math display="inline" id="Π-calculus:102">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 in the same way.</p>

<p>The full power of replication 

<math display="inline" id="Π-calculus:103">
 <semantics>
  <mrow>
   <mo lspace="0pt" rspace="3.5pt">!</mo>
   <mi>P</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <factorial></factorial>
    <csymbol cd="unknown">P</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   !P
  </annotation>
 </semantics>
</math>

 is not needed. Often, one only considers <em>replicated input</em> 

<math display="inline" id="Π-calculus:104">
 <semantics>
  <mrow>
   <mo lspace="0pt" rspace="3.5pt">!</mo>
   <mi>x</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>.</mo>
   <mi>P</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <factorial></factorial>
    <csymbol cd="unknown">x</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-.</ci>
    <csymbol cd="unknown">P</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   !x(y).P
  </annotation>
 </semantics>
</math>


, whose structural congruence axiom is 

<math display="inline" id="Π-calculus:105">
 <semantics>
  <mrow>
   <mo lspace="0pt" rspace="3.5pt">!</mo>
   <mi>x</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>.</mo>
   <mi>P</mi>
   <mo>≡</mo>
   <mi>x</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>.</mo>
   <mi>P</mi>
   <mo stretchy="false">|</mo>
   <mo lspace="0pt" rspace="3.5pt">!</mo>
   <mi>x</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>.</mo>
   <mi>P</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <factorial></factorial>
    <csymbol cd="unknown">x</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-.</ci>
    <csymbol cd="unknown">P</csymbol>
    <equivalent></equivalent>
    <csymbol cd="unknown">x</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-.</ci>
    <csymbol cd="unknown">P</csymbol>
    <ci>normal-|</ci>
    <factorial></factorial>
    <csymbol cd="unknown">x</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-.</ci>
    <csymbol cd="unknown">P</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   !x(y).P\equiv x(y).P|!x(y).P
  </annotation>
 </semantics>
</math>

.</p>

<p>Replicated input process such as 

<math display="inline" id="Π-calculus:106">
 <semantics>
  <mrow>
   <mo lspace="0pt" rspace="3.5pt">!</mo>
   <mi>x</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>.</mo>
   <mi>P</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <factorial></factorial>
    <csymbol cd="unknown">x</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-.</ci>
    <csymbol cd="unknown">P</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   !x(y).P
  </annotation>
 </semantics>
</math>

 can be understood as servers, waiting on channel 

<math display="inline" id="Π-calculus:107">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 to be invoked by clients. Invocation of a server spawns a new copy of the process 

<math display="inline" id="Π-calculus:108">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mrow>
     <mi>a</mi>
     <mo>/</mo>
     <mi>y</mi>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <apply>
      <divide></divide>
      <ci>a</ci>
      <ci>y</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P[a/y]
  </annotation>
 </semantics>
</math>

, where a is the name passed by the client to the server, during the latter's invocation.</p>

<p>A <em>higher order π-calculus</em> can be defined where not only names but processes are sent through channels. The key reduction rule for the higher order case is</p>

<p>

<math display="inline" id="Π-calculus:109">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>x</mi>
    <mo>¯</mo>
   </mover>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mi>R</mi>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo>.</mo>
   <mi>P</mi>
   <mo stretchy="false">|</mo>
   <mi>x</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>Y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>.</mo>
   <mi>Q</mi>
   <mo>→</mo>
   <mi>P</mi>
   <mo stretchy="false">|</mo>
   <mi>Q</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>R</mi>
    <mo>/</mo>
    <mi>Y</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <ci>normal-¯</ci>
     <ci>x</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-⟨</ci>
     <csymbol cd="unknown">R</csymbol>
     <ci>normal-⟩</ci>
    </cerror>
    <ci>normal-.</ci>
    <csymbol cd="unknown">P</csymbol>
    <ci>normal-|</ci>
    <csymbol cd="unknown">x</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">Y</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-.</ci>
    <csymbol cd="unknown">Q</csymbol>
    <ci>normal-→</ci>
    <csymbol cd="unknown">P</csymbol>
    <ci>normal-|</ci>
    <csymbol cd="unknown">Q</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">R</csymbol>
     <divide></divide>
     <csymbol cd="unknown">Y</csymbol>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \overline{x}\langle R\rangle.P|x(Y).Q\rightarrow P|Q[R/Y]
  </annotation>
 </semantics>
</math>


</p>

<p>Here, 

<math display="inline" id="Π-calculus:110">
 <semantics>
  <mi>Y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y
  </annotation>
 </semantics>
</math>

 denotes a <em>process variable</em> which can be instantiated by a process term. Sangiorgi established that the ability to pass processes does not increase the expressivity of the π-calculus: passing a process <em>P</em> can be simulated by just passing a name that points to <em>P</em> instead.</p>
<h2 id="properties">Properties</h2>
<h3 id="turing-completeness">Turing completeness</h3>

<p>The π-calculus is a <a href="Turing_complete" title="wikilink">universal model of computation</a>. This was first observed by Milner in his paper "Functions as Processes",<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> in which he presents two encodings of the <a class="uri" href="lambda-calculus" title="wikilink">lambda-calculus</a> in the π-calculus. One encoding simulates the eager (call-by-value) <a href="evaluation_strategy" title="wikilink">evaluation strategy</a>, the other encoding simulates the normal-order (call-by-name) strategy. In both of these, the crucial insight is the modeling of environment bindings – for instance, "

<math display="inline" id="Π-calculus:111">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 is bound to term 

<math display="inline" id="Π-calculus:112">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

" – as replicating agents that respond to requests for their bindings by sending back a connection to the term 

<math display="inline" id="Π-calculus:113">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

.</p>

<p>The features of the π-calculus that make these encodings possible are name-passing and replication (or, equivalently, recursively defined agents). In the absence of replication/recursion, the π-calculus ceases to be <a class="uri" href="Turing" title="wikilink">Turing</a>-powerful. This can be seen by the fact that <a class="uri" href="bisimulation" title="wikilink">bisimulation</a> equivalence becomes decidable for the recursion-free calculus and even for the finite-control π-calculus where the number of parallel components in any process is bounded by a constant.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>
<h2 id="bisimulations-in-the-π-calculus">Bisimulations in the π-calculus</h2>

<p>As for process calculi, the π-calculus allows for a definition of bisimulation equivalence. In the π-calculus, the definition of bisimulation equivalence (also known as bisimilarity) may be based on either the reduction semantics or on the labelled transition semantics.</p>

<p>There are (at least) three different ways of defining <em>labelled bisimulation equivalence</em> in the π-calculus: Early, late and open bisimilarity. This stems from the fact that the π-calculus is a value-passing process calculus.</p>

<p>In the remainder of this section, we let 

<math display="inline" id="Π-calculus:114">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>


 and 

<math display="inline" id="Π-calculus:115">
 <semantics>
  <mi>q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q
  </annotation>
 </semantics>
</math>

 denote processes and 

<math display="inline" id="Π-calculus:116">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

 denote binary relations over processes.</p>
<h3 id="early-and-late-bisimilarity">Early and late bisimilarity</h3>

<p>Early and late bisimilarity were both formulated by Milner, Parrow and Walker in their original paper on the π-calculus.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>

<p>A binary relation 

<math display="inline" id="Π-calculus:117">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

 over processes is an <em>early bisimulation</em> if for every pair of processes 

<math display="inline" id="Π-calculus:118">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>p</mi>
    <mo>,</mo>
    <mi>q</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∈</mo>
   <mi>R</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <interval closure="open">
     <ci>p</ci>
     <ci>q</ci>
    </interval>
    <ci>R</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (p,q)\in R
  </annotation>
 </semantics>
</math>

,</p>
<ul>
<li>whenever <math></math></li>
</ul>

<p>p \,\xrightarrow{a(x)}\,p'  then for every name 

<math display="inline" id="Π-calculus:119">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>


 there exists some 

<math display="inline" id="Π-calculus:120">
 <semantics>
  <msup>
   <mi>q</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>q</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q^{\prime}
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Π-calculus:121">
 <semantics>
  <mrow>
   <mpadded width="+1.7pt">
    <mi>q</mi>
   </mpadded>
   <mpadded width="+1.7pt">
    <mover accent="true">
     <mo>→</mo>
     <mrow>
      <mi>a</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mover>
   </mpadded>
   <msup>
    <mi>q</mi>
    <mo>′</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <apply>
      <times></times>
      <ci>a</ci>
      <ci>x</ci>
     </apply>
     <ci>normal-→</ci>
    </apply>
    <ci>q</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>q</ci>
     <ci>normal-′</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q\,\xrightarrow{a(x)}\,q^{\prime}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Π-calculus:122">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msup>
      <mi>p</mi>
      <mo>′</mo>
     </msup>
     <mrow>
      <mo stretchy="false">[</mo>
      <mrow>
       <mi>y</mi>
       <mo>/</mo>
       <mi>x</mi>
      </mrow>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo>,</mo>
    <mrow>
     <msup>
      <mi>q</mi>
      <mo>′</mo>
     </msup>
     <mrow>
      <mo stretchy="false">[</mo>
      <mrow>
       <mi>y</mi>
       <mo>/</mo>
       <mi>x</mi>
      </mrow>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∈</mo>
   <mi>R</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <interval closure="open">
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>p</ci>
       <ci>normal-′</ci>
      </apply>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <divide></divide>
        <ci>y</ci>
        <ci>x</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>q</ci>
       <ci>normal-′</ci>
      </apply>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <divide></divide>
        <ci>y</ci>
        <ci>x</ci>
       </apply>
      </apply>
     </apply>
    </interval>
    <ci>R</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (p^{\prime}[y/x],q^{\prime}[y/x])\in R
  </annotation>
 </semantics>
</math>

;</p>
<ul>
<li>for any non-input action 

<math display="inline" id="Π-calculus:123">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>

, if <math></math></li>
</ul>

<p>p \xrightarrow\alpha p'</p>

<p><code> </code><code> then there exists some </code>

<math display="inline" id="Π-calculus:124">
 <semantics>
  <msup>
   <mi>q</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>q</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q^{\prime}
  </annotation>
 </semantics>
</math>


<code> such that </code>

<math display="inline" id="Π-calculus:125">
 <semantics>
  <mrow>
   <mi>q</mi>
   <mover accent="true">
    <mo>→</mo>
    <mo>𝛼</mo>
   </mover>
   <msup>
    <mi>q</mi>
    <mo>′</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <ci>α</ci>
     <ci>normal-→</ci>
    </apply>
    <ci>q</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>q</ci>
     <ci>normal-′</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q\xrightarrow{\alpha}q^{\prime}
  </annotation>
 </semantics>
</math>

<code> and </code>

<math display="inline" id="Π-calculus:126">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>p</mi>
     <mo>′</mo>
    </msup>
    <mo>,</mo>
    <msup>
     <mi>q</mi>
     <mo>′</mo>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∈</mo>
   <mi>R</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>p</ci>
      <ci>normal-′</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>q</ci>
      <ci>normal-′</ci>
     </apply>
    </interval>
    <ci>R</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (p^{\prime},q^{\prime})\in R
  </annotation>
 </semantics>
</math>

<code>;</code></p>
<ul>
<li>and symmetric requirements with 

<math display="inline" id="Π-calculus:127">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Π-calculus:128">
 <semantics>
  <mi>q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q
  </annotation>
 </semantics>
</math>

 interchanged.</li>
</ul>

<p>Processes 

<math display="inline" id="Π-calculus:129">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>


 and 

<math display="inline" id="Π-calculus:130">
 <semantics>
  <mi>q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q
  </annotation>
 </semantics>
</math>

 are said to be early bisimilar, written 

<math display="inline" id="Π-calculus:131">
 <semantics>
  <mrow>
   <mi>p</mi>
   <msub>
    <mo>∼</mo>
    <mi>e</mi>
   </msub>
   <mi>q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">similar-to</csymbol>
     <ci>e</ci>
    </apply>
    <ci>p</ci>
    <ci>q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\sim_{e}q
  </annotation>
 </semantics>
</math>

 if the pair 

<math display="inline" id="Π-calculus:132">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>p</mi>
    <mo>,</mo>
    <mi>q</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∈</mo>
   <mi>R</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <interval closure="open">
     <ci>p</ci>
     <ci>q</ci>
    </interval>
    <ci>R</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (p,q)\in R
  </annotation>
 </semantics>
</math>

 for some early bisimulation 

<math display="inline" id="Π-calculus:133">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

.</p>

<p>In late bisimilarity, the transition match must be independent of the name being transmitted. A binary relation 

<math display="inline" id="Π-calculus:134">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>


 over processes is a <em>late bisimulation</em> if for every pair of processes 

<math display="inline" id="Π-calculus:135">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>p</mi>
    <mo>,</mo>
    <mi>q</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∈</mo>
   <mi>R</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <interval closure="open">
     <ci>p</ci>
     <ci>q</ci>
    </interval>
    <ci>R</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (p,q)\in R
  </annotation>
 </semantics>
</math>

,</p>
<ul>
<li>whenever <math></math></li>
</ul>

<p>p \xrightarrow{a(x)} p'  then for some 

<math display="inline" id="Π-calculus:136">
 <semantics>
  <msup>
   <mi>q</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>q</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q^{\prime}
  </annotation>
 </semantics>
</math>

 it holds that 

<math display="inline" id="Π-calculus:137">
 <semantics>
  <mrow>
   <mi>q</mi>
   <mover accent="true">
    <mo>→</mo>
    <mrow>
     <mi>a</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mover>
   <msup>
    <mi>q</mi>
    <mo>′</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <apply>
      <times></times>
      <ci>a</ci>
      <ci>x</ci>
     </apply>
     <ci>normal-→</ci>
    </apply>
    <ci>q</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>q</ci>
     <ci>normal-′</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q\xrightarrow{a(x)}q^{\prime}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Π-calculus:138">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msup>
      <mi>p</mi>
      <mo>′</mo>
     </msup>
     <mrow>
      <mo stretchy="false">[</mo>
      <mrow>
       <mi>y</mi>
       <mo>/</mo>
       <mi>x</mi>
      </mrow>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo>,</mo>
    <mrow>
     <msup>
      <mi>q</mi>
      <mo>′</mo>
     </msup>
     <mrow>
      <mo stretchy="false">[</mo>
      <mrow>
       <mi>y</mi>
       <mo>/</mo>
       <mi>x</mi>
      </mrow>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∈</mo>
   <mi>R</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <interval closure="open">
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>p</ci>
       <ci>normal-′</ci>
      </apply>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <divide></divide>
        <ci>y</ci>
        <ci>x</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>q</ci>
       <ci>normal-′</ci>
      </apply>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <divide></divide>
        <ci>y</ci>
        <ci>x</ci>
       </apply>
      </apply>
     </apply>
    </interval>
    <ci>R</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (p^{\prime}[y/x],q^{\prime}[y/x])\in R
  </annotation>
 </semantics>
</math>

 <em>for every name y</em>;</p>
<ul>
<li>for any non-input action 

<math display="inline" id="Π-calculus:139">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>


, if <math></math></li>
</ul>

<p>p \xrightarrow\alpha p'</p>

<p><code> </code><code> implies that there exists some </code>

<math display="inline" id="Π-calculus:140">
 <semantics>
  <msup>
   <mi>q</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>q</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q^{\prime}
  </annotation>
 </semantics>
</math>

<code> such that </code>

<math display="inline" id="Π-calculus:141">
 <semantics>
  <mrow>
   <mi>q</mi>
   <mover accent="true">
    <mo>→</mo>
    <mo>𝛼</mo>
   </mover>
   <msup>
    <mi>q</mi>
    <mo>′</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <ci>α</ci>
     <ci>normal-→</ci>
    </apply>
    <ci>q</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>q</ci>
     <ci>normal-′</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q\xrightarrow{\alpha}q^{\prime}
  </annotation>
 </semantics>
</math>

<code>and </code>

<math display="inline" id="Π-calculus:142">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>p</mi>
     <mo>′</mo>
    </msup>
    <mo>,</mo>
    <msup>
     <mi>q</mi>
     <mo>′</mo>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∈</mo>
   <mi>R</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>p</ci>
      <ci>normal-′</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>q</ci>
      <ci>normal-′</ci>
     </apply>
    </interval>
    <ci>R</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (p^{\prime},q^{\prime})\in R
  </annotation>
 </semantics>
</math>

<code>;</code></p>
<ul>
<li>and symmetric requirements with 

<math display="inline" id="Π-calculus:143">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Π-calculus:144">
 <semantics>
  <mi>q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q
  </annotation>
 </semantics>
</math>


 interchanged.</li>
</ul>

<p>Processes 

<math display="inline" id="Π-calculus:145">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Π-calculus:146">
 <semantics>
  <mi>q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q
  </annotation>
 </semantics>
</math>

 are said to be late bisimilar, written 

<math display="inline" id="Π-calculus:147">
 <semantics>
  <mrow>
   <mi>p</mi>
   <msub>
    <mo>∼</mo>
    <mi>l</mi>
   </msub>
   <mi>q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">similar-to</csymbol>
     <ci>l</ci>
    </apply>
    <ci>p</ci>
    <ci>q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\sim_{l}q
  </annotation>
 </semantics>
</math>

 if the pair 

<math display="inline" id="Π-calculus:148">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>p</mi>
    <mo>,</mo>
    <mi>q</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∈</mo>
   <mi>R</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <interval closure="open">
     <ci>p</ci>
     <ci>q</ci>
    </interval>
    <ci>R</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (p,q)\in R
  </annotation>
 </semantics>
</math>

 for some late bisimulation 

<math display="inline" id="Π-calculus:149">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>


.</p>

<p>Both 

<math display="inline" id="Π-calculus:150">
 <semantics>
  <msub>
   <mo>∼</mo>
   <mi>e</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <csymbol cd="latexml">similar-to</csymbol>
    <ci>e</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sim_{e}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Π-calculus:151">
 <semantics>
  <msub>
   <mo>∼</mo>
   <mi>l</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <csymbol cd="latexml">similar-to</csymbol>
    <ci>l</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sim_{l}
  </annotation>
 </semantics>
</math>

 suffer from the problem that they are not <em>congruence relations</em> in the sense that they are not preserved by all process constructs. More precisely, there exist processes 

<math display="inline" id="Π-calculus:152">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Π-calculus:153">
 <semantics>
  <mi>q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Π-calculus:154">
 <semantics>
  <mrow>
   <mi>p</mi>
   <msub>
    <mo>∼</mo>
    <mi>e</mi>
   </msub>
   <mi>q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">similar-to</csymbol>
     <ci>e</ci>
    </apply>
    <ci>p</ci>
    <ci>q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\sim_{e}q
  </annotation>
 </semantics>
</math>


 but 

<math display="inline" id="Π-calculus:155">
 <semantics>
  <mrow>
   <mrow>
    <mi>a</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>p</mi>
    <msub>
     <mo>≁</mo>
     <mi>e</mi>
    </msub>
    <mrow>
     <mi>a</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mi>q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <times></times>
     <ci>a</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">not-similar-to</csymbol>
      <ci>e</ci>
     </apply>
     <ci>p</ci>
     <apply>
      <times></times>
      <ci>a</ci>
      <ci>x</ci>
     </apply>
    </apply>
    <ci>q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a(x).p\not\sim_{e}a(x).q
  </annotation>
 </semantics>
</math>

. One may remedy this problem by considering the maximal congruence relations included in 

<math display="inline" id="Π-calculus:156">
 <semantics>
  <msub>
   <mo>∼</mo>
   <mi>e</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <csymbol cd="latexml">similar-to</csymbol>
    <ci>e</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sim_{e}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Π-calculus:157">
 <semantics>
  <msub>
   <mo>∼</mo>
   <mi>l</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <csymbol cd="latexml">similar-to</csymbol>
    <ci>l</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sim_{l}
  </annotation>
 </semantics>
</math>

, known as <em>early congruence</em> and <em>late congruence</em>, respectively.</p>
<h3 id="open-bisimilarity">Open bisimilarity</h3>

<p>Fortunately, a third definition is possible, which avoids this problem, namely that of <em>open bisimilarity</em>, due to Sangiorgi.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>

<p>A binary relation 

<math display="inline" id="Π-calculus:158">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

 over processes is an <em>open bisimulation</em> if for every pair of elements 

<math display="inline" id="Π-calculus:159">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>p</mi>
    <mo>,</mo>
    <mi>q</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∈</mo>
   <mi>R</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <interval closure="open">
     <ci>p</ci>
     <ci>q</ci>
    </interval>
    <ci>R</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (p,q)\in R
  </annotation>
 </semantics>
</math>


 and for every name substitution 

<math display="inline" id="Π-calculus:160">
 <semantics>
  <mi>σ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma
  </annotation>
 </semantics>
</math>

 and every action 

<math display="inline" id="Π-calculus:161">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>

, whenever 

<math display="inline" id="Π-calculus:162">
 <semantics>
  <mrow>
   <mrow>
    <mi>p</mi>
    <mi>σ</mi>
   </mrow>
   <mover accent="true">
    <mo>→</mo>
    <mo>𝛼</mo>
   </mover>
   <msup>
    <mi>p</mi>
    <mo>′</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <ci>α</ci>
     <ci>normal-→</ci>
    </apply>
    <apply>
     <times></times>
     <ci>p</ci>
     <ci>σ</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>p</ci>
     <ci>normal-′</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\sigma\xrightarrow{\alpha}p^{\prime}
  </annotation>
 </semantics>
</math>

 then there exists some 

<math display="inline" id="Π-calculus:163">
 <semantics>
  <msup>
   <mi>q</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>q</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q^{\prime}
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Π-calculus:164">
 <semantics>
  <mrow>
   <mrow>
    <mi>q</mi>
    <mi>σ</mi>
   </mrow>
   <mover accent="true">
    <mo>→</mo>
    <mo>𝛼</mo>
   </mover>
   <msup>
    <mi>q</mi>
    <mo>′</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <ci>α</ci>
     <ci>normal-→</ci>
    </apply>
    <apply>
     <times></times>
     <ci>q</ci>
     <ci>σ</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>q</ci>
     <ci>normal-′</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q\sigma\xrightarrow{\alpha}q^{\prime}
  </annotation>
 </semantics>
</math>


 and 

<math display="inline" id="Π-calculus:165">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>p</mi>
     <mo>′</mo>
    </msup>
    <mo>,</mo>
    <msup>
     <mi>q</mi>
     <mo>′</mo>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∈</mo>
   <mi>R</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>p</ci>
      <ci>normal-′</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>q</ci>
      <ci>normal-′</ci>
     </apply>
    </interval>
    <ci>R</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (p^{\prime},q^{\prime})\in R
  </annotation>
 </semantics>
</math>

.</p>

<p>Processes 

<math display="inline" id="Π-calculus:166">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Π-calculus:167">
 <semantics>
  <mi>q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q
  </annotation>
 </semantics>
</math>

 are said to be open bisimilar, written 

<math display="inline" id="Π-calculus:168">
 <semantics>
  <mrow>
   <mi>p</mi>
   <msub>
    <mo>∼</mo>
    <mi>o</mi>
   </msub>
   <mi>q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">similar-to</csymbol>
     <ci>o</ci>
    </apply>
    <ci>p</ci>
    <ci>q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\sim_{o}q
  </annotation>
 </semantics>
</math>

 if the pair 

<math display="inline" id="Π-calculus:169">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>p</mi>
    <mo>,</mo>
    <mi>q</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∈</mo>
   <mi>R</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <interval closure="open">
     <ci>p</ci>
     <ci>q</ci>
    </interval>
    <ci>R</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (p,q)\in R
  </annotation>
 </semantics>
</math>


 for some open bisimulation 

<math display="inline" id="Π-calculus:170">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

.</p>
<h4 id="early-late-and-open-bisimilarity-are-distinct">Early, late and open bisimilarity are distinct</h4>

<p>Early, late and open bisimilarity are distinct. The containments are proper, so 

<math display="inline" id="Π-calculus:171">
 <semantics>
  <mrow>
   <msub>
    <mo>∼</mo>
    <mi>o</mi>
   </msub>
   <mo>⊊</mo>
   <msub>
    <mo>∼</mo>
    <mi>l</mi>
   </msub>
   <mo>⊊</mo>
   <msub>
    <mo>∼</mo>
    <mi>e</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">similar-to</csymbol>
     <ci>o</ci>
    </apply>
    <prsubset></prsubset>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">similar-to</csymbol>
     <ci>l</ci>
    </apply>
    <prsubset></prsubset>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">similar-to</csymbol>
     <ci>e</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sim_{o}\subsetneq\sim_{l}\subsetneq\sim_{e}
  </annotation>
 </semantics>
</math>

.</p>

<p>In certain subcalculi such as the asynchronous pi-calculus, late, early and open bisimilarity are known to coincide. However, in this setting a more appropriate notion is that of <em>asynchronous bisimilarity</em>.</p>

<p>The reader should note that, in the literature, the term <em>open bisimulation</em> usually refers to a more sophisticated notion, where processes and relations are indexed by distinction relations; details are in Sangiorgi's paper cited above.</p>
<h3 id="barbed-equivalence">Barbed equivalence</h3>

<p>Alternatively, one may define bisimulation equivalence directly from the reduction semantics. We write 

<math display="inline" id="Π-calculus:172">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mo>⇓</mo>
   <mi>a</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-⇓</ci>
    <ci>p</ci>
    <ci>a</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\Downarrow a
  </annotation>
 </semantics>
</math>

 if process 

<math display="inline" id="Π-calculus:173">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 immediately allows an input or an output on name 

<math display="inline" id="Π-calculus:174">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>


.</p>

<p>A binary relation 

<math display="inline" id="Π-calculus:175">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

 over processes is a <em>barbed bisimulation</em> if it is a symmetric relation which satisfies that for every pair of elements 

<math display="inline" id="Π-calculus:176">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>p</mi>
    <mo>,</mo>
    <mi>q</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∈</mo>
   <mi>R</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <interval closure="open">
     <ci>p</ci>
     <ci>q</ci>
    </interval>
    <ci>R</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (p,q)\in R
  </annotation>
 </semantics>
</math>

 we have that</p>
<dl>
<dd>(1) 

<math display="inline" id="Π-calculus:177">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mo>⇓</mo>
   <mi>a</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-⇓</ci>
    <ci>p</ci>
    <ci>a</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\Downarrow a
  </annotation>
 </semantics>
</math>

 if and only if 

<math display="inline" id="Π-calculus:178">
 <semantics>
  <mrow>
   <mi>q</mi>
   <mo>⇓</mo>
   <mi>a</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-⇓</ci>
    <ci>q</ci>
    <ci>a</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q\Downarrow a
  </annotation>
 </semantics>
</math>

 for every name 

<math display="inline" id="Π-calculus:179">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>



</dd>
</dl>

<p>and</p>
<dl>
<dd>(2) for every reduction 

<math display="inline" id="Π-calculus:180">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mo>→</mo>
   <msup>
    <mi>p</mi>
    <mo>′</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>p</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>p</ci>
     <ci>normal-′</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\rightarrow p^{\prime}
  </annotation>
 </semantics>
</math>

 there exists a reduction 

<math display="inline" id="Π-calculus:181">
 <semantics>
  <mrow>
   <mi>q</mi>
   <mo>→</mo>
   <msup>
    <mi>q</mi>
    <mo>′</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>q</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>q</ci>
     <ci>normal-′</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q\rightarrow q^{\prime}
  </annotation>
 </semantics>
</math>


</dd>
</dl>

<p>such that 

<math display="inline" id="Π-calculus:182">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>p</mi>
     <mo>′</mo>
    </msup>
    <mo>,</mo>
    <msup>
     <mi>q</mi>
     <mo>′</mo>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∈</mo>
   <mi>R</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>p</ci>
      <ci>normal-′</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>q</ci>
      <ci>normal-′</ci>
     </apply>
    </interval>
    <ci>R</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (p^{\prime},q^{\prime})\in R
  </annotation>
 </semantics>
</math>

.</p>

<p>We say that 

<math display="inline" id="Π-calculus:183">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Π-calculus:184">
 <semantics>
  <mi>q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q
  </annotation>
 </semantics>
</math>


 are <em>barbed bisimilar</em> if there exists a barbed bisimulation 

<math display="inline" id="Π-calculus:185">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Π-calculus:186">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>p</mi>
    <mo>,</mo>
    <mi>q</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∈</mo>
   <mi>R</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <interval closure="open">
     <ci>p</ci>
     <ci>q</ci>
    </interval>
    <ci>R</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (p,q)\in R
  </annotation>
 </semantics>
</math>

.</p>

<p>Defining a context as a π term with a hole [] we say that two processes P and Q are <em>barbed congruent</em>, written 

<math display="inline" id="Π-calculus:187">
 <semantics>
  <mrow>
   <mi>P</mi>
   <msub>
    <mo>∼</mo>
    <mi>b</mi>
   </msub>
   <mi>Q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">similar-to</csymbol>
     <ci>b</ci>
    </apply>
    <ci>P</ci>
    <ci>Q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P\sim_{b}Q\,\!
  </annotation>
 </semantics>
</math>

, if for every context 

<math display="inline" id="Π-calculus:188">
 <semantics>
  <mrow>
   <mi>C</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>C</ci>
    <list></list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C[]
  </annotation>
 </semantics>
</math>

 we have that 

<math display="inline" id="Π-calculus:189">
 <semantics>
  <mrow>
   <mi>C</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>P</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>C</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>P</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C[P]
  </annotation>
 </semantics>
</math>


 and 

<math display="inline" id="Π-calculus:190">
 <semantics>
  <mrow>
   <mi>C</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>Q</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>C</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>Q</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C[Q]
  </annotation>
 </semantics>
</math>

 are barbed bisimilar. It turns out that barbed congruence coincides with the congruence induced by early bisimilarity.</p>
<h2 id="applications">Applications</h2>

<p>The π-calculus has been used to describe many different kinds of concurrent systems. In fact, some of the most recent applications lie outside the realm of traditional computer science.</p>

<p>In 1997, <a href="Martin_Abadi" title="wikilink">Martin Abadi</a> and Andrew Gordon proposed an extension of the π-calculus, the <a class="uri" href="Spi-calculus" title="wikilink">Spi-calculus</a>, as a formal notation for describing and reasoning about cryptographic protocols. The spi-calculus extends the π-calculus with primitives for encryption and decryption. In 2001, <a href="Martin_Abadi" title="wikilink">Martin Abadi</a> and Cedric Fournet generalised the handling of cryptographic protocols to produce the applied π calculus. There is now a large body of work devoted to variants of the applied π calculus, including a number of experimental verification tools. One example is the tool <a class="uri" href="ProVerif" title="wikilink">ProVerif</a> <a href="http://www.proverif.ens.fr/">2</a> due to <a href="Bruno_Blanchet" title="wikilink">Bruno Blanchet</a>, based on a translation of the applied π-calculus into Blanchet's logic programming framework. Another example is Cryptyc <a href="http://www.cryptyc.org">3</a>, due to Andrew Gordon and Alan Jeffrey, which uses Woo and Lam's method of correspondence assertions as the basis for type systems that can check for authentication properties of cryptographic protocols.</p>

<p>Around 2002, Howard Smith and <a href="Peter_Fingar" title="wikilink">Peter Fingar</a> became interested in using the π-calculus as a description tool for modelling business processes. As of July 2006, there is discussion in the community as to how useful this will be. Most recently, the π-calculus has been used as the theoretical basis of <a href="Business_Process_Modeling_Language" title="wikilink">Business Process Modeling Language</a> (BPML), and of Microsoft's XLANG.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>

<p>The π-calculus has also attracted interest in molecular biology. In 1999, <a href="Aviv_Regev" title="wikilink">Aviv Regev</a> and <a href="Ehud_Shapiro" title="wikilink">Ehud Shapiro</a> showed that one can describe a cellular signaling pathway (the so-called <a href="Receptor_tyrosine_kinase" title="wikilink">RTK</a>/<a class="uri" href="MAPK" title="wikilink">MAPK</a> cascade) and in particular the molecular "lego" which implements these tasks of communication in an extension of the π-calculus.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> Following this seminal paper, other authors described the whole metabolic network of a minimal cell.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></p>
<h2 id="history">History</h2>

<p>The π-calculus was originally developed by <a href="Robin_Milner" title="wikilink">Robin Milner</a>, Joachim Parrow and <a href="David_Walker_(computer_scientist)" title="wikilink">David Walker</a> in 1992, based on ideas by Uffe Engberg and Mogens Nielsen. It can be seen as a continuation of Milner's work on the process calculus CCS (<a href="Calculus_of_Communicating_Systems" title="wikilink">Calculus of Communicating Systems</a>). In his Turing lecture, Milner describes the development of the π-calculus as an attempt to capture the uniformity of values and processes in actors.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a></p>
<h2 id="implementations">Implementations</h2>

<p>The following programming languages are implementations either of the π-calculus or of its variants:</p>
<ul>
<li><a href="Business_Process_Modeling_Language" title="wikilink">Business Process Modeling Language</a> (BPML)</li>
<li><a class="uri" href="occam-π" title="wikilink">occam-π</a></li>
<li><a href="Pict_programming_language" title="wikilink">Pict</a></li>
<li><a class="uri" href="JoCaml" title="wikilink">JoCaml</a> (based on the <a class="uri" href="Join-calculus" title="wikilink">Join-calculus</a>)</li>
</ul>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://c2.com/cgi/wiki?PiCalculus">PiCalculus</a> on the C2 wiki</li>
<li><a href="http://www.eecs.harvard.edu/~nr/cs257/archive/jeannette-wing/pi.pdf">FAQ on π-Calculus</a> by <a href="Jeannette_M._Wing" title="wikilink">Jeannette M. Wing</a></li>
</ul>

<p>"</p>

<p><a href="Category:Process_calculi" title="wikilink">Category:Process calculi</a> <a href="Category:Theoretical_computer_science" title="wikilink">Category:Theoretical computer science</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="http://www.lfcs.inf.ed.ac.uk/reports/89/ECS-LFCS-89-85/">A Calculus of Mobile Processes part 1</a> page 10, by R. Milner, J. Parrow and D. Walker published in Information and Computation 100(1) pp.1-40, Sept 1992<a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7">"BPML | BPEL4WS: A Convergence Path toward a Standard BPM Stack." BPMI.org Position Paper. August 15, 2002.<a href="http://www.bpmi.org/downloads/BPML-BPEL4WS.pdf">4</a><a href="#fnref7">↩</a></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
<li id="fn10">Robin Milner. 1993. Elements of interaction: Turing award lecture. Commun. ACM 36, 1 (January 1993), 78-89. DOI=10.1145/151233.151240 <a class="uri" href="http://doi.acm.org/10.1145/151233.151240">http://doi.acm.org/10.1145/151233.151240</a><a href="#fnref10">↩</a></li>
</ol>
</section>
</body>
</html>
