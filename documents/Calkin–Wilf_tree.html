<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="439">Calkin–Wilf tree</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Calkin–Wilf tree</h1>
<hr/>

<p>  In <a href="number_theory" title="wikilink">number theory</a>, the <strong>Calkin–Wilf tree</strong> is a <a href="tree_(graph_theory)" title="wikilink">tree</a> in which the vertices correspond <a href="bijection" title="wikilink">1-for-1</a> to the <a href="positive_number" title="wikilink">positive</a> <a href="rational_number" title="wikilink">rational numbers</a>. The tree is rooted at the number 1, and any rational number expressed in simplest terms as the <a href="Fraction_(mathematics)" title="wikilink">fraction</a> <em>a</em>/<em>b</em> has as its two children the numbers <em>a</em>/(<em>a</em> + <em>b</em>) and (<em>a</em> + <em>b</em>)/<em>b</em>. Every positive rational number appears exactly once in the tree.</p>

<p>The sequence of rational numbers in a <a href="breadth-first_search" title="wikilink">breadth-first traversal</a> of the Calkin–Wilf tree is known as the <strong>Calkin–Wilf sequence</strong>. Its sequence of numerators (or, offset by one, denominators) is <strong>Stern's diatomic series</strong>, and can be computed by the <strong>fusc function</strong>.</p>

<p>The Calkin–Wilf tree is named after <a href="Neil_Calkin" title="wikilink">Neil Calkin</a> and <a href="Herbert_Wilf" title="wikilink">Herbert Wilf</a>, who considered it in their 2000 paper. The tree was introduced earlier by Jean Berstel and Aldo de Luca<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> as <em>Raney tree</em>, since they drew some ideas from a paper by George N. Raney.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> Stern's diatomic series was formulated much earlier by <a href="Moritz_Abraham_Stern" title="wikilink">Moritz Abraham Stern</a>, a 19th-century German mathematician who also invented the closely related <a href="Stern–Brocot_tree" title="wikilink">Stern–Brocot tree</a>.</p>
<h2 id="definition-and-structure">Definition and structure</h2>

<p> The Calkin–Wilf tree may be defined as a directed graph in which each positive rational number <em>a</em>/<em>b</em> occurs as a vertex and has one outgoing edge to another vertex, its parent. We assume that <em>a</em>/<em>b</em> is in simplest terms; that is, the <a href="greatest_common_divisor" title="wikilink">greatest common divisor</a> of <em>a</em> and <em>b</em> is 1. If <em>a</em>/<em>b</em> The description here is dual to the original definition by Calkin and Wilf, which begins by defining the child relationship and derives the parent relationship as part of a proof that every rational appears once in the tree. As defined here, every rational appears once by definition, and instead the fact that the resulting structure is a tree requires a proof.</p>

<p>Although it is a binary tree (each vertex has two children), the Calkin–Wilf tree is not a <a href="binary_search_tree" title="wikilink">binary search tree</a>: its inorder does not coincide with the sorted order of its vertices. However, it is closely related to a different binary search tree on the same set of vertices, the <a href="Stern–Brocot_tree" title="wikilink">Stern–Brocot tree</a>: the vertices at each level of the two trees coincide, and are related to each other by a <a href="bit-reversal_permutation" title="wikilink">bit-reversal permutation</a>.</p>
<h2 id="breadth-first-traversal">Breadth first traversal</h2>

<p> The <strong>Calkin–Wilf sequence</strong> is the sequence of rational numbers generated by a breadth-first traversal of the Calkin–Wilf tree,</p>
<dl>
<dd>1/1, 1/2, 2/1, 1/3, 3/2, 2/3, 3/1, 1/4, 4/3, 3/5, 5/2, 2/5, 5/3, 3/4, ….
</dd>
</dl>

<p>Because the Calkin–Wilf tree contains every positive rational number exactly once, so does this sequence.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> The denominator of each fraction equals the numerator of the next fraction in the sequence. The Calkin–Wilf sequence can also be generated directly by the formula</p>

<p>

<math display="block" id="Calkin–Wilf_tree:0">
 <semantics>
  <mrow>
   <msub>
    <mi>q</mi>
    <mrow>
     <mi>i</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo>=</mo>
   <mfrac>
    <mn>1</mn>
    <mrow>
     <mrow>
      <mrow>
       <mn>2</mn>
       <mrow>
        <mo stretchy="false">⌊</mo>
        <msub>
         <mi>q</mi>
         <mi>i</mi>
        </msub>
        <mo stretchy="false">⌋</mo>
       </mrow>
      </mrow>
      <mo>-</mo>
      <msub>
       <mi>q</mi>
       <mi>i</mi>
      </msub>
     </mrow>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>q</ci>
     <apply>
      <plus></plus>
      <ci>i</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <apply>
      <plus></plus>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <apply>
         <floor></floor>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>q</ci>
          <ci>i</ci>
         </apply>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>q</ci>
        <ci>i</ci>
       </apply>
      </apply>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q_{i+1}=\frac{1}{2\lfloor q_{i}\rfloor-q_{i}+1}
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Calkin–Wilf_tree:1">
 <semantics>
  <msub>
   <mi>q</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>q</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q_{i}
  </annotation>
 </semantics>
</math>

 denotes the <em>i</em>th number in the sequence, starting from 

<math display="inline" id="Calkin–Wilf_tree:2">
 <semantics>
  <mrow>
   <msub>
    <mi>q</mi>
    <mn>1</mn>
   </msub>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>q</ci>
     <cn type="integer">1</cn>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q_{1}=1
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="Calkin–Wilf_tree:3">
 <semantics>
  <mrow>
   <mo stretchy="false">⌊</mo>
   <msub>
    <mi>q</mi>
    <mi>i</mi>
   </msub>
   <mo stretchy="false">⌋</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <floor></floor>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>q</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lfloor q_{i}\rfloor
  </annotation>
 </semantics>
</math>

 represents the <a href="Floor_and_ceiling_functions" title="wikilink">integral part</a>.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>

<p>It's also possible to calculate 

<math display="inline" id="Calkin–Wilf_tree:4">
 <semantics>
  <msub>
   <mi>q</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>q</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q_{i}
  </annotation>
 </semantics>
</math>

 directly. If you count successively equal digits of the <a href="binary_code" title="wikilink">binary code</a> of i you get the <a href="continued_fraction" title="wikilink">continued fraction</a> of 

<math display="inline" id="Calkin–Wilf_tree:5">
 <semantics>
  <msub>
   <mi>q</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>q</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q_{i}
  </annotation>
 </semantics>
</math>

. You must start counting 1-digits at the end of the <a href="binary_code" title="wikilink">binary code</a>. Then you continue counting 0-digits backwards, then you continue counting 1-digits backward and so on.</p>

<p>Example:<br/>
i = 1081 = 

<math display="inline" id="Calkin–Wilf_tree:6">
 <semantics>
  <msub>
   <mn>10000111001</mn>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <cn type="integer">10000111001</cn>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   10000111001_{2}
  </annotation>
 </semantics>
</math>

: The <a href="continued_fraction" title="wikilink">continued fraction</a> is [1;2,3,4,1] hence 

<math display="inline" id="Calkin–Wilf_tree:7">
 <semantics>
  <mrow>
   <msub>
    <mi>q</mi>
    <mn>1081</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <mn>53</mn>
    <mo>/</mo>
    <mn>37</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>q</ci>
     <cn type="integer">1081</cn>
    </apply>
    <apply>
     <divide></divide>
     <cn type="integer">53</cn>
     <cn type="integer">37</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q_{1081}=53/37
  </annotation>
 </semantics>
</math>

.<br/>
i = 1990 = 

<math display="inline" id="Calkin–Wilf_tree:8">
 <semantics>
  <msub>
   <mn>11111000110</mn>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <cn type="integer">11111000110</cn>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   11111000110_{2}
  </annotation>
 </semantics>
</math>

: The <a href="continued_fraction" title="wikilink">continued fraction</a> is [0;1,2,3,5] hence 

<math display="inline" id="Calkin–Wilf_tree:9">
 <semantics>
  <mrow>
   <msub>
    <mi>q</mi>
    <mn>1990</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <mn>37</mn>
    <mo>/</mo>
    <mn>53</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>q</ci>
     <cn type="integer">1990</cn>
    </apply>
    <apply>
     <divide></divide>
     <cn type="integer">37</cn>
     <cn type="integer">53</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q_{1990}=37/53
  </annotation>
 </semantics>
</math>

.<br/>
 If you calculate the continued fraction of any 

<math display="inline" id="Calkin–Wilf_tree:10">
 <semantics>
  <msub>
   <mi>q</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>q</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q_{i}
  </annotation>
 </semantics>
</math>

 you can determine i.<br/>
Example:<br/>


<math display="inline" id="Calkin–Wilf_tree:11">
 <semantics>
  <mrow>
   <msub>
    <mi>q</mi>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mn>3</mn>
    <mo>/</mo>
    <mn>4</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>q</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <divide></divide>
     <cn type="integer">3</cn>
     <cn type="integer">4</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q_{i}=3/4
  </annotation>
 </semantics>
</math>

: The <a href="continued_fraction" title="wikilink">continued fraction</a> is [0;1,3] hence i = 

<math display="inline" id="Calkin–Wilf_tree:12">
 <semantics>
  <msub>
   <mn>1110</mn>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <cn type="integer">1110</cn>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1110_{2}
  </annotation>
 </semantics>
</math>

 = 14.<br/>


<math display="inline" id="Calkin–Wilf_tree:13">
 <semantics>
  <mrow>
   <msub>
    <mi>q</mi>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mn>4</mn>
    <mo>/</mo>
    <mn>3</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>q</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <divide></divide>
     <cn type="integer">4</cn>
     <cn type="integer">3</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q_{i}=4/3
  </annotation>
 </semantics>
</math>

: The <a href="continued_fraction" title="wikilink">continued fraction</a> is [1;3]. But the length of the continued fraction must be a <a href="odd_number" title="wikilink">odd number</a>. So you must use [1;2,1] instead which equals [1;3]. Hence i = 

<math display="inline" id="Calkin–Wilf_tree:14">
 <semantics>
  <msub>
   <mn>1001</mn>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <cn type="integer">1001</cn>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1001_{2}
  </annotation>
 </semantics>
</math>

 = 9.</p>
<h2 id="sterns-diatomic-sequence">Stern's diatomic sequence</h2>

<p> <strong>Stern's diatomic sequence</strong> is the <a href="integer_sequence" title="wikilink">integer sequence</a></p>
<dl>
<dd>0, 1, 1, 2, 1, 3, 2, 3, 1, 4, 3, 5, 2, 5, 3, 4, … .
</dd>
</dl>

<p>Using <a href="zero-based_numbering" title="wikilink">zero-based numbering</a>, the <em>n</em>th value in the sequence is the value fusc(<em>n</em>) of the <strong>fusc function</strong>,<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> defined by the <a href="recurrence_relation" title="wikilink">recurrence relations</a> fusc(2<em>n</em>) = fusc(<em>n</em>) and fusc(2<em>n</em> + 1) = fusc(<em>n</em>) + fusc(<em>n</em> + 1), with the base cases fusc(0) = 0 and fusc(1) = 1. The <em>n</em>th rational number in a breadth-first traversal of the Calkin–Wilf tree is the number fusc(<em>n</em>) / fusc(<em>n</em> + 1).<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> Thus, the diatomic sequence forms both the sequence of numerators and the sequence of denominators of the numbers in the Calkin–Wilf sequence.</p>

<p>The function fusc(<em>n</em> + 1) is the number of odd <a href="binomial_coefficient" title="wikilink">binomial coefficients</a> of the form <span class="LaTeX">$\scriptstyle {n-r\choose r},\ 0\leq 2r<n,< math=""><ref>{{harvtxt|Carlitz|1964}}.</ref> and
also counts the number of ways of writing ''n'' as a sum of [[power of two|powers of two]] in which each power occurs at most twice. This can be seen from the recurrence defining fusc: the expressions as a sum of powers of two for an even number 2''n'' either have no 1's in them (in which case they are formed by doubling each term an expression for ''n'') or two 1's (in which case the rest of the expression is formed by doubling each term in an expression for ''n'' − 1), so the number of representations is the sum of the number of representations for ''n'' and for ''n'' − 1, matching the recurrence. Similarly, each representation for an odd number 2''n'' + 1 is formed by doubling a representation for ''n'' and adding 1, again matching the recurrence.<ref>The OEIS entry credits this fact to {{harvtxt|Carlitz|1964}} and to uncited work of Lind. However, Carlitz' paper describes a more restricted class of sums of powers of two, counted by fusc(''n'') instead of by fusc(''n'' + 1).</ref> For instance,
:6 = 4 + 2 = 4 + 1 + 1 = 2 + 2 + 1 + 1
has three representations as a sum of powers of two with at most two copies of each power, so fusc(6 + 1) = 3.

==Relation to Stern–Brocot tree==
The Calkin–Wilf tree resembles the [[Stern–Brocot tree]] in that both are binary trees with each positive rational number appearing exactly once. Additionally, the top levels of the two trees appear very similar, and in both trees the same numbers appear at the same levels. One tree can be obtained from the other by performing a [[bit-reversal permutation]] on the numbers at each level of the trees.{{sfnp|Gibbons|Lester|Bird|2006}} Alternatively, the number at a given node of the Calkin–Wilf tree can be converted into the number at the same position in the Stern–Brocot tree, and vice versa, by a process involving the reversal of the [[continued fraction]] representations of these numbers.{{sfnp|Bates|Bunder|Tognetti|2010}}
However, in other ways they have different properties: for instance, the Stern–Brocot tree is a [[binary search tree]]: the left-to-right traversal order of the tree is the same as the numerical order of the numbers in it. This property is not true of the Calkin–Wilf tree.

==Notes==
{{reflist}}

==References==
*{{citation
 | last1 = Aigner | first1 = Martin| author1-link = Martin Aigner
| last2 = Ziegler | first2 = Günter M. | author2-link = Günter M. Ziegler
 | edition = 3rd
 | isbn = 978-3-540-40460-6
 | location = Berlin; New York
 | publisher = Springer
 | title = [[Proofs from THE BOOK]]
 | pages = 94–97
 | year = 2004}}
*{{citation
 | last1 = Bates | first1 = Bruce
 | last2 = Bunder | first2 = Martin
 | last3 = Tognetti | first3 = Keith
 | doi = 10.1016/j.ejc.2010.04.002
 | issue = 7
 | journal = European Journal of Combinatorics
 | mr = 2673006
 | pages = 1637–1661
 | title = Linking the Calkin-Wilf and Stern-Brocot trees
 | volume = 31
 | year = 2010}}
*{{citation
 | last1 = Berstel | first1 = Jean
 | last2 = de Luca | first2 = Aldo
 | year = 1997
 | title = Sturmian words, Lyndon words and trees
 | journal = [[Theoretical Computer Science (journal)|Theoretical Computer Science]]
 | volume = 178
 | pages = 171–203
 | doi = 10.1016/S0304-3975(96)00101-6}}
*{{citation
 | last1 = Calkin | first1 = Neil
 | last2 = Wilf | first2 = Herbert
 | issue = 4
 | journal = [[American Mathematical Monthly]]
| pages = 360–363
 | title = Recounting the rationals
 | url = http://www.math.upenn.edu/~wilf/website/recounting.pdf
 | volume = 107
 | year = 2000
 | doi = 10.2307/2589182
 | publisher = [[Mathematical Association of America]]
| jstor = 2589182}}.
*{{citation|first=L.|last=Carlitz|authorlink =Leonard Carlitz|title=A problem in partitions related to the[[Stirling numbers]]|journal=[[Bulletin of the American Mathematical Society]]|volume=70|issue=2|year=1964|pages=275–278|mr=0157907|doi=10.1090/S0002-9904-1964-11118-6}}.
*{{citation
 |first=Edsger W.|last=Dijkstra|authorlink=Edsger W. Dijkstra
 |title=Selected Writings on Computing: A Personal Perspective
 |publisher=[[Springer-Verlag]]|year=1982|isbn=0-387-90652-5}}. [http://www.cs.utexas.edu/users/EWD/ewd05xx/EWD570.PDF EWD 570: An exercise for Dr.R.M.Burstall], pp. 215–216, and [http://www.cs.utexas.edu/users/EWD/ewd05xx/EWD578.PDF EWD 578: More about the function "fusc" (A sequel to EWD570)], pp. 230–232, reprints of notes originally written in 1976.
*{{citation
 | last1 = Gibbons | first1 = Jeremy | authorlink1 = Jeremy Gibbons
 | last2 = Lester | first2 = David
 | last3 = Bird | first3 = Richard | author3-link = Richard Bird (computer scientist)
 | doi = 10.1017/S0956796806005880
 | issue = 3
 | journal = [[Journal of Functional Programming]]
 | pages = 281–291
 | title = Functional pearl: Enumerating the rationals
 | volume = 16
 | year = 2006}}.
*{{citation
 | last = Raney | first = George N.
 | year = 1973
 | title = On continued fractions and finite automata
 | journal = [[Mathematische Annalen]]
 | volume = 206
 | pages = 265–283
 | doi = 10.1007/BF01355980}}
*{{citation
 | last = Stern | first = Moritz A. | author-link = Moritz Abraham Stern
 | journal = [[Crelle's Journal|Journal für die reine und angewandte Mathematik]]
 | pages = 193–220
 | title = Ueber eine zahlentheoretische Funktion
 | url = http://www.digizeitschriften.de/resolveppn/GDZPPN002150301
 | volume = 55
 | year = 1858}}.

==External links==
*{{mathworld|urlname=Calkin-WilfTree|title=Calkin–Wilf Tree}}
*{{mathworld|urlname=SternsDiatomicSeries|title=Stern's Diatomic Series}}
*{{citation|url=http://www.cut-the-knot.org/blue/Fusc.shtml|title=Fractions on a Binary Tree II|publisher=[[Cut-the-knot]]|first=Alexander|last=Bogomolny}}
{{DEFAULTSORT:Calkin-Wilf tree}}
[[Category:Integer sequences]]
[[Category:Trees (data structures)]]"</n,<>$</span></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">, Section 6.<a href="#fnref1">↩</a></li>
<li id="fn2">.<a href="#fnref2">↩</a></li>
<li id="fn3">: "a list of all positive rational numbers, each appearing once and only once, can be made by writing down 1/1, then the fractions on the level just below the top of the tree, reading from left to right, then the fractions on the next level down, reading from left to right, etc."  discuss efficient <a href="functional_programming" title="wikilink">functional programming</a> techniques for performing this breadth first traversal.<a href="#fnref3">↩</a></li>
<li id="fn4"> credit this formula to Moshe Newman.<a href="#fnref4">↩</a></li>
<li id="fn5">The fusc name was given to it in 1976 by <a href="Edsger_W._Dijkstra" title="wikilink">Edsger W. Dijkstra</a>; see EWD570 and EWD578.<a href="#fnref5">↩</a></li>
<li id="fn6">, Theorem 1.<a href="#fnref6">↩</a></li>
</ol>
</section>
</body>
</html>
