   Tunstall coding      Tunstall coding   In computer science and information theory , Tunstall coding is a form of entropy coding used for lossless data compression .  History  Tunstall coding was the subject of Brian Parker Tunstall's PhD thesis in 1967, while at Georgia Institute of Technology. The subject of that thesis was "Synthesis of noiseless compression codes" 1  Its design is a precursor to Lempel-Ziv .  Properties  Unlike variable-length codes , which include Huffman and Lempel–Ziv coding , Tunstall coding is a code which maps source symbols to a fixed number of bits. 2  Unlike typical set encoding , Tunstall coding parses a stochastic source with codewords of variable length.  It can be shown 3 that, for a large enough dictionary, the number of bits per source letter can be infinitely close to    H   (  U  )       H  U    H(U)   , the entropy of the source.  Algorithm  The algorithm requires as input an input alphabet   𝒰   𝒰   \mathcal{U}   , along with a distribution of probabilities for each word input. It also requires an arbitrary constant   C   C   C   , which is an upper bound to the size of the dictionary that it will compute. The dictionary in question,   D   D   D   , is constructed as a tree of probabilities, in which each edge is associated to a letter from the input alphabet. The algorithm goes like this:  D := tree of     |  𝒰  |      𝒰    |\mathcal{U}|    leaves, one for each letter in    𝒰   𝒰   \mathcal{U}    .  While      |  D  |   <  C        D   C    |D|    :  Convert most probable leaf to tree with     |  𝒰  |      𝒰    |\mathcal{U}|    leaves.  Example  Let's imagine that we wish to encode the string "hello, world". Let's further assume (somewhat unrealistically) that the input alphabet   𝒰   𝒰   \mathcal{U}   contains only characters from the string "hello, world" — that is, 'h', 'e', 'l', ',', ' ', 'w', 'o', 'r', 'd'. We can therefore compute the probability of each character based on its statistical appearance in the input string. For instance, the letter L appears thrice in a string of 12 characters: its probability is    3  12      3  12    3\over 12   .  We initialize the tree, starting with a tree of     |  𝒰  |   =  9        𝒰   9    |\mathcal{U}|=9   leaves. Each word is therefore directly associated to a letter of the alphabet. The 9 words that we thus obtain can be encoded into a fixed-sized output of     ⌈    log  2    (  9  )    ⌉   =  4          subscript   2   9    4    \lceil\log_{2}(9)\rceil=4   bits.  (Figure)  Tunstall "hello, world" example — one iteration   We then take the leaf of highest probability (here,    w  1     subscript  w  1    w_{1}   ), and convert it to yet another tree of     |  𝒰  |   =  9        𝒰   9    |\mathcal{U}|=9   leaves, one for each character. We re-compute the probabilities of those leaves. For instance, the sequence of two letters L happens once. Given that there are three occurrences of letters followed by an L, the resulting probability is      1  3   ⋅   3  12    =   1  12        normal-⋅    1  3     3  12      1  12     {1\over 3}\cdot{3\over 12}={1\over 12}   .  We obtain 17 words that only 12 of them has non-zero probability so we it's enough to code them only, which can each be encoded into a fixed-sized output of     ⌈    log  2    (  12  )    ⌉   =  4          subscript   2   12    4    \lceil\log_{2}(12)\rceil=4   bits.  (This picture is wrong and code's length must be 4 not 5)  Note that we could iterate further, increasing the number of words by      |  𝒰  |   -  1   =  8          𝒰   1   8    |\mathcal{U}|-1=8   every time.  Limitations  Tunstall coding requires the algorithm to know, prior to the parsing operation, what the distribution of probabilities for each letter of the alphabet is. This issue is shared with Huffman coding .  Its requiring a fixed-length block output makes it lesser than Lempel-Ziv , which has a similar dictionary-based design, but with a variable-sized block output.  References  "  Category:Lossless compression algorithms     ↩  http://www.rle.mit.edu/rgallager/documents/notes1.pdf , Study of Tunstall's algorithm at MIT ↩  1 , Study of Tunstall's algorithm from EPFL 's Information Theory department ↩     