   Smith normal form      Smith normal form   In mathematics, the Smith normal form is a normal form that can be defined for any matrix (not necessarily square) with entries in a principal ideal domain (PID). The Smith normal form of a matrix is diagonal , and can be obtained from the original matrix by multiplying on the left and right by invertible square matrices. In particular, the integers are a PID, so one can always calculate the Smith normal form of an integer matrix. The Smith normal form is very useful for working with finitely generated modules over a PID, and in particular for deducing the structure of a quotient of a free module .  Definition  Let A be a nonzero m × n matrix over a principal ideal domain  R . There exist invertible    m  ×  m      m  m    m\times m   and    n  ×  n      n  n    n\times n   -matrices S, T so that the product S A T is       (      α  1     0    0       ⋯       0      0     α  2     0       ⋯       0      0    0    ⋱             0      ⋮           α  r           ⋮                  0                           ⋱         0          ⋯          0     )   .       subscript  α  1   0  0  absent  normal-⋯  absent  0    0   subscript  α  2   0  absent  normal-⋯  absent  0    0  0  normal-⋱  absent  absent  absent  0    normal-⋮  absent  absent   subscript  α  r   absent  absent  normal-⋮    absent  absent  absent  absent  0  absent  absent    absent  absent  absent  absent  absent  normal-⋱  absent    0  absent  absent  normal-⋯  absent  absent  0     \begin{pmatrix}\alpha_{1}&0&0&&\cdots&&0\\
 0&\alpha_{2}&0&&\cdots&&0\\
 0&0&\ddots&&&&0\\
 \vdots&&&\alpha_{r}&&&\vdots\\
 &&&&0&&\\
 &&&&&\ddots&\\
 0&&&\cdots&&&0\end{pmatrix}.     and the diagonal elements    α  i     subscript  α  i    \alpha_{i}   satisfy     α  i   ∣    α   i  +  1     ∀  1  ≤  i  <  r     fragments   subscript  α  i   normal-∣   subscript  α    i  1    for-all  1   i   r    \alpha_{i}\mid\alpha_{i+1}\;\forall\;1\leq i   . This is the Smith normal form of the matrix A . The elements    α  i     subscript  α  i    \alpha_{i}   are unique up to multiplication by a unit and are called the elementary divisors , invariants , or invariant factors . They can be computed (up to multiplication by a unit) as        α  i   =     d  i    (  A  )      d   i  -  1     (  A  )      ,       subscript  α  i        subscript  d  i   A      subscript  d    i  1    A      \alpha_{i}=\frac{d_{i}(A)}{d_{i-1}(A)},   where     d  i    (  A  )        subscript  d  i   A    d_{i}(A)   (called i -th determinant divisor ) equals the greatest common divisor of all    i  ×  i      i  i    i\times i    minors of the matrix A .  Algorithm  Our first goal will be to find invertible square matrices S and T such that the product S A T is diagonal. This is the hardest part of the algorithm and once we have achieved diagonality it becomes relatively easy to put the matrix in Smith normal form. Phrased more abstractly, the goal is to show that, thinking of A as a map from    R  n     superscript  R  n    R^{n}   (the free R - module of rank n ) to    R  m     superscript  R  m    R^{m}   (the free R - module of rank m ), there are isomorphisms    S  :    R  m   →   R  m       normal-:  S   normal-→   superscript  R  m    superscript  R  m      S:R^{m}\to R^{m}   and    T  :    R  n   →   R  n       normal-:  T   normal-→   superscript  R  n    superscript  R  n      T:R^{n}\to R^{n}   such that    S  ⋅  A  ⋅  T     normal-⋅  S  A  T    S\cdot A\cdot T   has the simple form of a diagonal matrix . The matrices S and T can be found by starting out with identity matrices of the appropriate size, and modifying S each time a row operation is performed on A in the algorithm by the same row operation, and similarly modifying T for each column operation performed. Since row operations are left-multiplications and column operations are right-multiplications, this preserves the invariant     A  ′   =    S  ′   ⋅  A  ⋅   T  ′         superscript  A  normal-′    normal-⋅   superscript  S  normal-′   A   superscript  T  normal-′      A^{\prime}=S^{\prime}\cdot A\cdot T^{\prime}   where     A  ′   ,   S  ′   ,   T  ′       superscript  A  normal-′    superscript  S  normal-′    superscript  T  normal-′     A^{\prime},S^{\prime},T^{\prime}   denote current values and A denotes the original matrix; eventually the matrices in this invariant become diagonal. Only invertible row and column operations are performed, which ensures that S and T remain invertible matrices.  For a in R \ {0}, write δ( a ) for the number of prime factors of a (these exist and are unique since any PID is also a unique factorization domain ). In particular, R is also a Bézout domain , so it is a gcd domain and the gcd of any two elements satisfies a Bézout's identity .  To put a matrix into Smith normal form, one can repeatedly apply the following, where t loops from 1 to m .  Step I: Choosing a pivot  Choose j t to be the smallest column index of A with a non-zero entry, starting the search at column index j t -1 +1 if t > 1.  We wish to have     a   t  ,   j  t     ≠  0       subscript  a   t   subscript  j  t     0    a_{t,j_{t}}\neq 0   ; if this is the case this step is complete, otherwise there is by assumption some k with     a   k  ,   j  t     ≠  0       subscript  a   k   subscript  j  t     0    a_{k,j_{t}}\neq 0   , and we can exchange rows   t   t   t   and k , thereby obtaining     a   t  ,   j  t     ≠  0       subscript  a   t   subscript  j  t     0    a_{t,j_{t}}\neq 0   .  Our chosen pivot is now at position ( t , j t ).  Step II: Improving the pivot  If there is an entry at position ( k , j t ) such that     a   t  ,   j  t     ∤   a   k  ,   j  t        not-divides   subscript  a   t   subscript  j  t      subscript  a   k   subscript  j  t       a_{t,j_{t}}\nmid a_{k,j_{t}}   , then, letting    β  =   gcd   (   a   t  ,   j  t     ,   a   k  ,   j  t     )        β     subscript  a   t   subscript  j  t      subscript  a   k   subscript  j  t        \beta=\gcd\left(a_{t,j_{t}},a_{k,j_{t}}\right)   , we know by the Bézout property that there exist σ, τ in R such that          a   t  ,   j  t     ⋅  σ   +    a   k  ,   j  t     ⋅  τ    =  β   .         normal-⋅   subscript  a   t   subscript  j  t     σ    normal-⋅   subscript  a   k   subscript  j  t     τ    β    a_{t,j_{t}}\cdot\sigma+a_{k,j_{t}}\cdot\tau=\beta.     By left-multiplication with an appropriate invertible matrix L , it can be achieved that row t of the matrix product is the sum of σ times the original row t and τ times the original row k , that row k of the product is another linear combination of those original rows, and that all other rows are unchanged. Explicitly, if σ and τ satisfy the above equation, then for    α  =    a   t  ,   j  t     /  β       α     subscript  a   t   subscript  j  t     β     \alpha=a_{t,j_{t}}/\beta   and    γ  =    a   k  ,   j  t     /  β       γ     subscript  a   k   subscript  j  t     β     \gamma=a_{k,j_{t}}/\beta   (which divisions are possible by the definition of β) one has         σ  ⋅  α   +   τ  ⋅  γ    =  1   ,         normal-⋅  σ  α    normal-⋅  τ  γ    1    \sigma\cdot\alpha+\tau\cdot\gamma=1,     so that the matrix       L  0   =   (     σ    τ       -  γ     α     )        subscript  L  0     σ  τ      γ   α      L_{0}=\begin{pmatrix}\sigma&\tau\\
 -\gamma&\alpha\\
 \end{pmatrix}     is invertible, with inverse       (     α     -  τ       γ    σ     )   .      α    τ     γ  σ     \begin{pmatrix}\alpha&-\tau\\
 \gamma&\sigma\\
 \end{pmatrix}.     Now L can be obtained by fitting    L  0     subscript  L  0    L_{0}   into rows and columns t and k of the identity matrix. By construction the matrix obtained after left-multiplying by L has entry β at position ( t , j t ) (and due to our choice of α and γ it also has an entry 0 at position ( k , j t ), which is useful though not essential for the algorithm). This new entry β divides the entry    a   t  ,   j  t       subscript  a   t   subscript  j  t      a_{t,j_{t}}   that was there before, and so in particular     δ   (  β  )    <   δ   (   a   t  ,   j  t     )          δ  β     δ   subscript  a   t   subscript  j  t        \delta(\beta)<\delta(a_{t,j_{t}})   ; therefore repeating these steps must eventually terminate. One ends up with a matrix having an entry at position ( t , j t ) that divides all entries in column j t .  Step III: Eliminating entries  Finally, adding appropriate multiples of row t , it can be achieved that all entries in column j t except for that at position ( t , j t ) are zero. This can be achieved by left-multiplication with an appropriate matrix. However, to make the matrix fully diagonal we need to eliminate nonzero entries on the row of position ( t , j t ) as well. This can be achieved by repeating the steps in Step II for columns instead of rows, and using multiplication on the right. In general this will result in the zero entries from the prior application of Step III becoming nonzero again.  However, notice that the ideals generated by the elements at position ( t , j t ) form an ascending chain , because entries from a later step always divide entries from a previous step. Therefore, since R is a Noetherian ring (it is a PID ), the ideals eventually become stationary and do not change. This means that at some stage after Step II has been applied, the entry at ( t , j t ) will divide all nonzero row or column entries before applying any more steps in Step II. Then we can eliminate entries in the row or column with nonzero entries while preserving the zeros in the already-zero row or column. At this point, only the block of A to the lower right of ( t , j t ) needs to be diagonalized, and conceptually the algorithm can be applied recursively, treating this block as a separate matrix. In other words, we can increment t by one and go back to Step I.  Final step  Applying the steps described above to the remaining non-zero columns of the resulting matrix (if any), we get an    m  ×  n      m  n    m\times n   -matrix with column indices     j  1   <  …  <   j  r          subscript  j  1   normal-…        subscript  j  r      j_{1}<\ldots   where    r  ≤   min   (  m  ,  n  )        r    m  n     r\leq\min(m,n)   . The matrix entries    (  l  ,   j  l   )     l   subscript  j  l     (l,j_{l})   are non-zero, and every other entry is zero.  Now we can move the null columns of this matrix to the right, so that the nonzero entries are on positions    (  i  ,  i  )     i  i    (i,i)   for    1  ≤  i  ≤  r        1  i       r     1\leq i\leq r   . For short, set    α  i     subscript  α  i    \alpha_{i}   for the element at position    (  i  ,  i  )     i  i    (i,i)   .  The condition of divisibility of diagonal entries might not be satisfied. For any index   i   i   i   , one can repair this shortcoming by operations on rows and columns    i  +  1      i  1    i+1   and    i  +  1      i  1    i+1   only: first add column   i   i   i   to column    α   i  +  1      subscript  α    i  1     \alpha_{i+1}   to get an entry    α  i     subscript  α  i    \alpha_{i}   in column i without disturbing the entry    (  i  ,  i  )     i  i    (i,i)   at position    (  i  ,  i  )     i  i    (i,i)   , and then apply a row operation to make the entry at position    β  =   gcd   (   α  i   ,   α   i  +  1    )        β     subscript  α  i    subscript  α    i  1       \beta=\gcd(\alpha_{i},\alpha_{i+1})   equal to    (   i  +  1   ,   i  +  1   )       i  1     i  1     (i+1,i+1)   as in Step II; finally proceed as in Step III to make the matrix diagonal again. Since the new entry at position     α  i   ,   α   i  +  1        subscript  α  i    subscript  α    i  1      \alpha_{i},\alpha_{i+1}   is a linear combination of the original     δ   (   α  1   )    +  ⋯  +   δ   (   α  r   )          δ   subscript  α  1    normal-⋯    δ   subscript  α  r      \delta(\alpha_{1})+\cdots+\delta(\alpha_{r})   , it is divisible by β.  The value    r  ×  r      r  r    r\times r   does not change by the above operation (it is δ of the determinant of the upper      ∑   j  =  1   r     (   r  -  j   )   δ   (   α  j   )     .      superscript   subscript     j  1    r       r  j   δ   subscript  α  j      \sum_{j=1}^{r}(r-j)\delta(\alpha_{j}).   submatrix), whence that operation does diminish (by moving prime factors to the right) the value of       α  1   ∣   α  2   ∣  ⋯  ∣   α  r      fragments   subscript  α  1   normal-∣   subscript  α  2   normal-∣  normal-⋯  normal-∣   subscript  α  r     \alpha_{1}\mid\alpha_{2}\mid\cdots\mid\alpha_{r}   So after finitely many applications of this operation no further application is possible, which means that we have obtained    m  ×  m      m  m    m\times m   as desired.  Since all row and column manipulations involved in the process are invertible, this shows that there exist invertible    n  ×  n      n  n    n\times n   and    (     2    4    4       -  6     6    12      10     -  4      -  16      )      2  4  4      6   6  12    10    4     16      \begin{pmatrix}2&4&4\\
 -6&6&12\\
 10&-4&-16\end{pmatrix}   -matrices S, T so that the product S A T satisfies the definition of a Smith normal form. In particular, this shows that the Smith normal form exists, which was assumed without proof in the definition.  Applications  The Smith normal form is useful for computing the homology of a chain complex when the chain modules of the chain complex are finitely generated . For instance, in topology , it can be used to compute the homology of a simplicial complex or CW complex over the integers, because the boundary maps in such a complex are just integer matrices. It can also be used to determine the invariant factors that occur in the structure theorem for finitely generated modules over a principal ideal domain .  Example  As an example, we will find the Smith normal form of the following matrix over the integers.       →   (     2    0    0       -  6     18    24      10     -  24      -  36      )   →   (     2    0    0      0    18    24      0     -  24      -  36      )        normal-→  absent    2  0  0      6   18  24    10    24     36       normal-→      2  0  0    0  18  24    0    24     36        \to\begin{pmatrix}2&0&0\\
 -6&18&24\\
 10&-24&-36\end{pmatrix}\to\begin{pmatrix}2&0&0\\
 0&18&24\\
 0&-24&-36\end{pmatrix}     The following matrices are the intermediate steps as the algorithm is applied to the above matrix.       →   (     2    0    0      0    18    24      0     -  6      -  12      )   →   (     2    0    0      0    6    12      0    18    24     )        normal-→  absent    2  0  0    0  18  24    0    6     12       normal-→      2  0  0    0  6  12    0  18  24       \to\begin{pmatrix}2&0&0\\
 0&18&24\\
 0&-6&-12\end{pmatrix}\to\begin{pmatrix}2&0&0\\
 0&6&12\\
 0&18&24\end{pmatrix}          →   (     2    0    0      0    6    12      0    0     -  12      )   →   (     2    0    0      0    6    0      0    0    12     )        normal-→  absent    2  0  0    0  6  12    0  0    12       normal-→      2  0  0    0  6  0    0  0  12       \to\begin{pmatrix}2&0&0\\
 0&6&12\\
 0&0&-12\end{pmatrix}\to\begin{pmatrix}2&0&0\\
 0&6&0\\
 0&0&12\end{pmatrix}         (     2    0    0      0    6    0      0    0    12     )      2  0  0    0  6  0    0  0  12     \begin{pmatrix}2&0&0\\
 0&6&0\\
 0&0&12\end{pmatrix}     So the Smith normal form is       x  I   -  A        x  I   A    xI-A     and the invariant factors are 2, 6 and 12.  Similarity  The Smith normal form can be used to determine whether or not matrices with entries over a common field are similar . Specifically two matrices A and B are similar if and only if the characteristic matrices      x  I   -  B        x  I   B    xI-B   and   A   A   \displaystyle A   have the same Smith normal form.  For example, with  $$\begin{align}
 A & {} =\begin{bmatrix}
  1 & 2 \\
  0 & 1 
 \end{bmatrix}, & & \mbox{SNF}(xI-A) =\begin{bmatrix}
  1 & 0 \\
  0 & (x-1)^2
 \end{bmatrix} \\
 B & {} =\begin{bmatrix}
  3 & -4 \\
  1 & -1 
 \end{bmatrix}, & & \mbox{SNF}(xI-B) =\begin{bmatrix}
  1 & 0 \\
  0 & (x-1)^2
 \end{bmatrix} \\
 C & {} =\begin{bmatrix}
  1 & 0 \\
  1 & 2 
 \end{bmatrix}, & & \mbox{SNF}(xI-C) =\begin{bmatrix}
  1 & 0 \\
  0 & (x-1)(x-2)
 \end{bmatrix}.
 \end{align}$$  A and B are similar because the Smith normal form of their characteristic matrices match, but are not similar to C because the Smith normal form of the characteristic matrices do not match.  See also   Canonical form  Elementary divisors  Frobenius normal form (also called Rational canonical form)  Hermite normal form  Invariant factor  Henry John Stephen Smith (1826–1883), eponym of the Smith normal form  Structure theorem for finitely generated modules over a principal ideal domain   References    Reprinted (pp. 367–409 ) in The Collected Mathematical Papers of Henry John Stephen Smith , Vol. I , edited by J. W. L. Glaisher . Oxford: Clarendon Press (1894), xcv +603 pp.    K. R. Matthews, Smith normal form . MP274: Linear Algebra, Lecture Notes, University of Queensland, 1991.  An animated example .   "  Category:Matrix theory  Category:Matrix normal forms   