<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="154">Candidate key</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Candidate key</h1>
<hr/>

<p>In the <a href="relational_model" title="wikilink">relational model</a> of <a href="database" title="wikilink">databases</a>, a <strong>candidate key</strong> of a <a href="Relation_(database)" title="wikilink">relation</a> is a minimal <a class="uri" href="superkey" title="wikilink">superkey</a> for that relation; that is, a <a href="set_(mathematics)" title="wikilink">set</a> of attributes such that:</p>
<ol>
<li>the relation does not have two distinct <a href="tuple" title="wikilink">tuples</a> (i.e. rows or records in common database language) with the same values for these attributes (which means that the set of attributes is a superkey)</li>
<li>there is no <a href="proper_subset" title="wikilink">proper subset</a> of these attributes for which (1) holds (which means that the set is minimal).</li>
</ol>

<p>The constituent attributes are called <strong>prime attributes</strong>. Conversely, an attribute that does not occur in ANY candidate key is called a <strong>non-prime attribute</strong>.</p>

<p>Since a relation contains no duplicate tuples, the set of all its attributes is a superkey if NULL values are not used. It follows that every relation will have at least one candidate key.</p>

<p>The candidate keys of a relation tell us all the possible ways we can identify its tuples. As such they are an important concept for the design of <a href="database_schema" title="wikilink">database schema</a>.</p>
<h2 id="example">Example</h2>

<p>The definition of candidate keys can be illustrated with the following (abstract) example. Consider a relation variable (relvar) <em>R</em> with attributes (<em>A</em>, <em>B</em>, <em>C</em>, <em>D</em>) that has only the following two legal values <em>r1</em> and <em>r2</em>:</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p><em>r1</em></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>A</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>a1</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>a1</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>a2</p></td>
</tr>
</tbody>
</table>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p><em>r2</em></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>A</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>a1</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>a1</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>a1</p></td>
</tr>
</tbody>
</table>

<p>Here <em>r2</em> differs from <em>r1</em> only in the <strong>A</strong> and <strong>D</strong> values of the last tuple.</p>

<p>For <em>r1</em> the following sets have the uniqueness property, i.e., there are no two distinct tuples in the instance with the same values for the attributes in the set:</p>
<dl>
<dd>{A,B}, {A,C}, {B,C}, {A,B,C}, {A,B,D}, {A,C,D}, {B,C,D}, {A,B,C,D}
</dd>
</dl>

<p>For <em>r2</em> the uniqueness property holds for the following sets;</p>
<dl>
<dd>{B,C}, {B,D}, {C,D}, {A,B,C}, {A,B,D}, {A,C,D}, {B,C,D}, {A,B,C,D}
</dd>
</dl>

<p>Since superkeys of a relvar are those sets of attributes that have the uniqueness property for <em>all</em> legal values of that relvar and because we assume that <em>r1</em> and <em>r2</em> are all the legal values that <em>R</em> can take, we can determine the set of superkeys of <em>R</em> by taking the intersection of the two lists:</p>
<dl>
<dd>{B,C}, {A,B,C}, {A,B,D}, {A,C,D}, {B,C,D}, {A,B,C,D}
</dd>
</dl>

<p>Finally we need to select those sets for which there is no <a href="subset#proper_subset" title="wikilink">proper subset</a> in the list, which are in this case:</p>
<dl>
<dd>{B,C}, {A,B,D}, {A,C,D}
</dd>
</dl>

<p>These are indeed the candidate keys of relvar <em>R</em>.</p>

<p>We have to consider <em>all</em> the relations that might be assigned to a relvar to determine whether a certain set of attributes is a candidate key. For example, if we had considered only <em>r1</em> then we would have concluded that {A,B} is a candidate key, which is incorrect. However, we <em>might</em> be able to conclude from such a relation that a certain set is <em>not</em> a candidate key, because that set does not have the uniqueness property (example {A,D} for <em>r1</em>). Note that the existence of a proper subset of a set that has the uniqueness property <em>cannot</em> in general be used as evidence that the superset is not a candidate key. In particular, note that in the case of an empty relation, every subset of the heading has the uniqueness property, including the empty set.</p>
<h2 id="determining-candidate-keys">Determining candidate keys</h2>

<p>The set of all candidate keys can be computed e.g. from the set of <a href="Functional_dependency" title="wikilink">functional dependencies</a>. To this end we need to define the attribute closure 

<math display="inline" id="Candidate_key:0">
 <semantics>
  <msup>
   <mi>α</mi>
   <mo>+</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>α</ci>
    <plus></plus>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha^{+}
  </annotation>
 </semantics>
</math>

 for an attribute set 

<math display="inline" id="Candidate_key:1">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>

. The set 

<math display="inline" id="Candidate_key:2">
 <semantics>
  <msup>
   <mi>α</mi>
   <mo>+</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>α</ci>
    <plus></plus>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha^{+}
  </annotation>
 </semantics>
</math>

 contains all attributes that are functionally implied by 

<math display="inline" id="Candidate_key:3">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>

.</p>

<p>It is quite simple to find a single candidate key. We start with a set 

<math display="inline" id="Candidate_key:4">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>

 of attributes and try to remove successively each attribute. If after removing an attribute the attribute closure stays the same, then this attribute is not necessary and we can remove it permanently. We call the result 

<math display="inline" id="Candidate_key:5">
 <semantics>
  <mrow>
   <mtext>minimize</mtext>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>α</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <mtext>minimize</mtext>
    <ci>α</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{minimize}(\alpha)
  </annotation>
 </semantics>
</math>

. If 

<math display="inline" id="Candidate_key:6">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>

 is the set of all attributes, then 

<math display="inline" id="Candidate_key:7">
 <semantics>
  <mrow>
   <mtext>minimize</mtext>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>α</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <mtext>minimize</mtext>
    <ci>α</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{minimize}(\alpha)
  </annotation>
 </semantics>
</math>

 is a candidate key.</p>

<p>Actually we can detect every candidate key with this procedure by simply trying every possible order of removing attributes. However there are much more <a href="permutation" title="wikilink">permutations</a> of attributes (

<math display="inline" id="Candidate_key:8">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo lspace="0pt" rspace="3.5pt">!</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <factorial></factorial>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n!
  </annotation>
 </semantics>
</math>

) than <a href="power_set" title="wikilink">subsets</a> (

<math display="inline" id="Candidate_key:9">
 <semantics>
  <msup>
   <mn>2</mn>
   <mi>n</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{n}
  </annotation>
 </semantics>
</math>

). That is, many attribute orders will lead to the same candidate key.</p>

<p>There is a fundamental difficulty for efficient algorithms for candidate key computation: Certain sets of functional dependencies lead to exponentially many candidate keys. Consider the 

<math display="inline" id="Candidate_key:10">
 <semantics>
  <mrow>
   <mn>2</mn>
   <mo>⋅</mo>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-⋅</ci>
    <cn type="integer">2</cn>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2\cdot n
  </annotation>
 </semantics>
</math>

 functional dependencies 

<math display="inline" id="Candidate_key:11">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <msub>
      <mi>A</mi>
      <mi>i</mi>
     </msub>
     <mo>→</mo>
     <msub>
      <mi>B</mi>
      <mi>i</mi>
     </msub>
    </mrow>
    <mo>:</mo>
    <mrow>
     <mi>i</mi>
     <mo>∈</mo>
     <mrow>
      <mo stretchy="false">{</mo>
      <mn>1</mn>
      <mo>,</mo>
      <mi mathvariant="normal">…</mi>
      <mo>,</mo>
      <mi>n</mi>
      <mo stretchy="false">}</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
   <mo>∪</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <msub>
      <mi>B</mi>
      <mi>i</mi>
     </msub>
     <mo>→</mo>
     <msub>
      <mi>A</mi>
      <mi>i</mi>
     </msub>
    </mrow>
    <mo>:</mo>
    <mrow>
     <mi>i</mi>
     <mo>∈</mo>
     <mrow>
      <mo stretchy="false">{</mo>
      <mn>1</mn>
      <mo>,</mo>
      <mi mathvariant="normal">…</mi>
      <mo>,</mo>
      <mi>n</mi>
      <mo stretchy="false">}</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <union></union>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <apply>
      <ci>normal-→</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>A</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>B</ci>
       <ci>i</ci>
      </apply>
     </apply>
     <apply>
      <in></in>
      <ci>i</ci>
      <set>
       <cn type="integer">1</cn>
       <ci>normal-…</ci>
       <ci>n</ci>
      </set>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <apply>
      <ci>normal-→</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>B</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>A</ci>
       <ci>i</ci>
      </apply>
     </apply>
     <apply>
      <in></in>
      <ci>i</ci>
      <set>
       <cn type="integer">1</cn>
       <ci>normal-…</ci>
       <ci>n</ci>
      </set>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{A_{i}\rightarrow B_{i}:i\in\{1,\dots,n\}\}\cup\{B_{i}\rightarrow A_{i}:i\in%
\{1,\dots,n\}\}
  </annotation>
 </semantics>
</math>

 which yields 

<math display="inline" id="Candidate_key:12">
 <semantics>
  <msup>
   <mn>2</mn>
   <mi>n</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{n}
  </annotation>
 </semantics>
</math>

 candidate keys: 

<math display="inline" id="Candidate_key:13">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">{</mo>
    <msub>
     <mi>A</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>B</mi>
     <mn>1</mn>
    </msub>
    <mo stretchy="false">}</mo>
   </mrow>
   <mo>×</mo>
   <mi mathvariant="normal">…</mi>
   <mo>×</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <msub>
     <mi>A</mi>
     <mi>n</mi>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>B</mi>
     <mi>n</mi>
    </msub>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <set>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>B</ci>
      <cn type="integer">1</cn>
     </apply>
    </set>
    <ci>normal-…</ci>
    <set>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>B</ci>
      <ci>n</ci>
     </apply>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{A_{1},B_{1}\}\times\dots\times\{A_{n},B_{n}\}
  </annotation>
 </semantics>
</math>

. That is, the best we can expect is an algorithm that is efficient with respect to the number of candidate keys.</p>

<p>The following algorithm actually runs in polynomial time in the number of candidate keys and functional dependencies:<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>

<p><code> K[0] := minimize(A);  /* A is the set of all attribute */</code><br/>
<code> n := 1; /* Number of Keys known so far */</code><br/>
<code> i := 0; /* Currently processed key */</code><br/>
<code> while i </code><code>K_i</code></p>

<p>and a functional dependency 

<math display="inline" id="Candidate_key:14">
 <semantics>
  <mrow>
   <mi>α</mi>
   <mo>→</mo>
   <mi>β</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>α</ci>
    <ci>β</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha\rightarrow\beta
  </annotation>
 </semantics>
</math>

, the reverse application of the functional dependency yields the set 

<math display="inline" id="Candidate_key:15">
 <semantics>
  <mrow>
   <mi>α</mi>
   <mo>∪</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msub>
      <mi>K</mi>
      <mi>i</mi>
     </msub>
     <mo>∖</mo>
     <mi>β</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <union></union>
    <ci>α</ci>
    <apply>
     <setdiff></setdiff>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>K</ci>
      <ci>i</ci>
     </apply>
     <ci>β</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha\cup(K_{i}\setminus\beta)
  </annotation>
 </semantics>
</math>

, which is a key, too. It may however be covered by other already known candidate keys. (The algorithm checks this case using the 'found' variable.) If not, then minimizing the new key yields a new candidate key. The key insight is (pun not intended) that all candidate keys can be created this way.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Alternate_key" title="wikilink">Alternate key</a></li>
<li><a href="Compound_key" title="wikilink">Compound key</a></li>
<li><a href="Database_normalization" title="wikilink">Database normalization</a></li>
<li><a href="Primary_key" title="wikilink">Primary key</a></li>
<li><a href="Relational_database" title="wikilink">Relational database</a></li>
<li><a class="uri" href="Superkey" title="wikilink">Superkey</a></li>
<li><a href="Prime_implicant" title="wikilink">Prime implicant</a> is the corresponding notion of a candidate key in <a href="boolean_logic" title="wikilink">boolean logic</a></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://rdbms.opengrass.net/2_Database%20Design/2.1_TermsOfReference/2.1.2_Keys.html">Relational Database Management Systems - Database Design - Terms of Reference - Keys</a>: An overview of the different types of keys in the RDBMS (Relational Database Management System).</li>
</ul>

<p>"</p>

<p><a href="Category:Data_modeling" title="wikilink">Category:Data modeling</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
</ol>
</section>
</body>
</html>
