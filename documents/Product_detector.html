<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="225">Product detector</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Product detector</h1>
<hr/>

<p>A <strong>product detector</strong> is a type of <a class="uri" href="demodulator" title="wikilink">demodulator</a> used for <a href="amplitude_modulation" title="wikilink">AM</a> and <a href="Single-sideband_modulation" title="wikilink">SSB</a> signals. Rather than converting the envelope of the signal into the decoded waveform like an <a href="envelope_detector" title="wikilink">envelope detector</a>, the product detector takes the product of the modulated signal and a <a href="local_oscillator" title="wikilink">local oscillator</a>, hence the name. A product detector is a <a href="frequency_mixer" title="wikilink">frequency mixer</a>.</p>

<p>Product detectors can be designed to accept either <a href="Intermediate_frequency" title="wikilink">IF</a> or <a href="Radio_frequency" title="wikilink">RF</a> frequency inputs. A product detector which accepts an IF signal would be used as a demodulator block in a <a href="superheterodyne_receiver" title="wikilink">superheterodyne receiver</a>, and a detector designed for RF can be combined with an RF amplifier and a low-pass filter into a <a href="Direct_conversion_receiver" title="wikilink">direct-conversion receiver</a>.</p>
<h2 id="a-simple-product-detector">A simple product detector</h2>

<p>The simplest form of product detector mixes (or heterodynes) the RF or IF signal with a locally derived carrier (the Beat Frequency Oscillator, or BFO) to produce an audio frequency copy of the original audio signal and a mixer product at twice the original RF or IF frequency. This high-frequency component can then be filtered out, leaving the original audio frequency signal.</p>
<h3 id="mathematical-model-of-the-simple-product-detector">Mathematical model of the simple product detector</h3>

<p>If <em>m</em>(<em>t</em>) is the original message, the AM signal can be shown to be</p>

<p>

<math display="block" id="Product_detector:0">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mpadded lspace="1.7pt" width="+1.7pt">
      <mi>x</mi>
     </mpadded>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>C</mi>
       <mo>+</mo>
       <mrow>
        <mi>m</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>t</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mi>cos</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>ω</mi>
        <mi>t</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>x</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <plus></plus>
      <ci>C</ci>
      <apply>
       <times></times>
       <ci>m</ci>
       <ci>t</ci>
      </apply>
     </apply>
     <apply>
      <cos></cos>
      <apply>
       <times></times>
       <ci>ω</ci>
       <ci>t</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \,x(t)=(C+m(t))\cos(\omega t).
  </annotation>
 </semantics>
</math>

 Multiplying the AM signal <em>x</em>(<em>t</em>) by an oscillator at the same frequency as and in phase with the carrier yields</p>

<p>

<math display="block" id="Product_detector:1">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mpadded lspace="1.7pt" width="+1.7pt">
      <mi>y</mi>
     </mpadded>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>C</mi>
       <mo>+</mo>
       <mrow>
        <mi>m</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>t</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mi>cos</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>ω</mi>
        <mi>t</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mrow>
      <mi>cos</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>ω</mi>
        <mi>t</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>y</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <plus></plus>
      <ci>C</ci>
      <apply>
       <times></times>
       <ci>m</ci>
       <ci>t</ci>
      </apply>
     </apply>
     <apply>
      <cos></cos>
      <apply>
       <times></times>
       <ci>ω</ci>
       <ci>t</ci>
      </apply>
     </apply>
     <apply>
      <cos></cos>
      <apply>
       <times></times>
       <ci>ω</ci>
       <ci>t</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \,y(t)=(C+m(t))\cos(\omega t)\cos(\omega t),
  </annotation>
 </semantics>
</math>

 which can be re-written as</p>

<p>

<math display="block" id="Product_detector:2">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mpadded lspace="1.7pt" width="+1.7pt">
      <mi>y</mi>
     </mpadded>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>C</mi>
       <mo>+</mo>
       <mrow>
        <mi>m</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>t</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo>(</mo>
      <mrow>
       <mstyle displaystyle="false">
        <mfrac>
         <mn>1</mn>
         <mn>2</mn>
        </mfrac>
       </mstyle>
       <mo>+</mo>
       <mrow>
        <mstyle displaystyle="false">
         <mfrac>
          <mn>1</mn>
          <mn>2</mn>
         </mfrac>
        </mstyle>
        <mrow>
         <mi>cos</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <mn>2</mn>
           <mi>ω</mi>
           <mi>t</mi>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
      </mrow>
      <mo>)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>y</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <plus></plus>
      <ci>C</ci>
      <apply>
       <times></times>
       <ci>m</ci>
       <ci>t</ci>
      </apply>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <cos></cos>
        <apply>
         <times></times>
         <cn type="integer">2</cn>
         <ci>ω</ci>
         <ci>t</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \,y(t)=(C+m(t))\left(\tfrac{1}{2}+\tfrac{1}{2}\cos(2\omega t)\right).
  </annotation>
 </semantics>
</math>

</p>

<p>After filtering out the high-frequency component based around cos(2ω<em>t</em>) and the DC component <em>C</em>, the original message will be recovered.</p>
<h3 id="drawbacks-of-the-simple-product-detector">Drawbacks of the simple product detector</h3>

<p>Although this simple detector works, it has two major drawbacks:</p>
<ul>
<li>The frequency of the local oscillator must be the same as the frequency of the carrier, or else the output message will fade in and out in the case of AM, or be frequency shifted in the case of SSB</li>
<li>Once the frequency is matched, the phase of carrier must be obtained, or else the demodulated message will be attenuated, but the noise will not be.</li>
</ul>

<p>Frequency of an AM carrier can be accurately determined with a <a href="phase-locked_loop" title="wikilink">phase-locked loop</a>, but for SSB, the only solution is to construct a highly stable oscillator.</p>
<h2 id="another-example">Another example</h2>

<p>There are many other kinds of product detectors as well, which are practical if one has access to <a href="digital_signal_processing" title="wikilink">digital signal processing</a> equipment. For instance, it is possible to multiply the incoming signal by the carrier, times the square of another carrier 90° out of phase with it. This will produce a copy of the original message, and another AM signal at the fourth harmonic, by means of the <a href="trigonometric_identity" title="wikilink">trigonometric identity</a></p>

<p>

<math display="block" id="Product_detector:3">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msup>
      <mi>sin</mi>
      <mn>2</mn>
     </msup>
     <mi>θ</mi>
    </mrow>
    <mrow>
     <msup>
      <mi>cos</mi>
      <mn>2</mn>
     </msup>
     <mi>θ</mi>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mn>1</mn>
     <mo>-</mo>
     <mrow>
      <mi>cos</mi>
      <mrow>
       <mn>4</mn>
       <mi>θ</mi>
      </mrow>
     </mrow>
    </mrow>
    <mn>8</mn>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <sin></sin>
       <cn type="integer">2</cn>
      </apply>
      <ci>θ</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cos></cos>
       <cn type="integer">2</cn>
      </apply>
      <ci>θ</ci>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
      <apply>
       <cos></cos>
       <apply>
        <times></times>
        <cn type="integer">4</cn>
        <ci>θ</ci>
       </apply>
      </apply>
     </apply>
     <cn type="integer">8</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sin^{2}\theta\cos^{2}\theta=\frac{1-\cos 4\theta}{8}
  </annotation>
 </semantics>
</math>

</p>

<p>The high-frequency component can again be filtered out, leaving the original signal.</p>
<h3 id="mathematical-model-of-the-detector">Mathematical model of the detector</h3>

<p>If <em>m</em>(<em>t</em>) is the original message, the AM signal can be shown to be</p>

<p>

<math display="block" id="Product_detector:4">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mpadded lspace="1.7pt" width="+1.7pt">
      <mi>x</mi>
     </mpadded>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>C</mi>
       <mo>+</mo>
       <mrow>
        <mi>m</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>t</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mi>cos</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>ω</mi>
        <mi>t</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>x</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <plus></plus>
      <ci>C</ci>
      <apply>
       <times></times>
       <ci>m</ci>
       <ci>t</ci>
      </apply>
     </apply>
     <apply>
      <cos></cos>
      <apply>
       <times></times>
       <ci>ω</ci>
       <ci>t</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \,x(t)=(C+m(t))\cos(\omega t).
  </annotation>
 </semantics>
</math>

 Multiplying the AM signal by the new set of frequencies yields</p>

<p>

<math display="block" id="Product_detector:5">
 <semantics>
  <mrow>
   <mrow>
    <mpadded lspace="1.7pt" width="+1.7pt">
     <mi>y</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>C</mi>
      <mo>+</mo>
      <mrow>
       <mi>m</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>t</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <msup>
      <mi>sin</mi>
      <mn>2</mn>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>ω</mi>
       <mi>t</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mrow>
     <msup>
      <mi>cos</mi>
      <mn>2</mn>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>ω</mi>
       <mi>t</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>y</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <plus></plus>
      <ci>C</ci>
      <apply>
       <times></times>
       <ci>m</ci>
       <ci>t</ci>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <sin></sin>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <times></times>
       <ci>ω</ci>
       <ci>t</ci>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cos></cos>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <times></times>
       <ci>ω</ci>
       <ci>t</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \,y(t)=(C+m(t))\sin^{2}(\omega t)\cos^{2}(\omega t)
  </annotation>
 </semantics>
</math>

</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Product_detector:6">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>C</mi>
      <mo>+</mo>
      <mrow>
       <mi>m</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>t</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mfrac>
     <mrow>
      <mn>1</mn>
      <mo>-</mo>
      <mrow>
       <mi>cos</mi>
       <mrow>
        <mn>4</mn>
        <mi>ω</mi>
        <mi>t</mi>
       </mrow>
      </mrow>
     </mrow>
     <mn>8</mn>
    </mfrac>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <csymbol cd="latexml">absent</csymbol>
    <apply>
     <times></times>
     <apply>
      <plus></plus>
      <ci>C</ci>
      <apply>
       <times></times>
       <ci>m</ci>
       <ci>t</ci>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
       <apply>
        <cos></cos>
        <apply>
         <times></times>
         <cn type="integer">4</cn>
         <ci>ω</ci>
         <ci>t</ci>
        </apply>
       </apply>
      </apply>
      <cn type="integer">8</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =(C+m(t))\frac{1-\cos 4\omega t}{8}
  </annotation>
 </semantics>
</math>


</dd>
<dd>

<math display="inline" id="Product_detector:7">
 <semantics>
  <mrow>
   <mrow>
    <mi></mi>
    <mo>=</mo>
    <mrow>
     <mfrac>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>C</mi>
        <mo>+</mo>
        <mrow>
         <mi>m</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>t</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mn>8</mn>
     </mfrac>
     <mo>-</mo>
     <mfrac>
      <mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>C</mi>
         <mo>+</mo>
         <mrow>
          <mi>m</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>t</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mrow>
        <mi>cos</mi>
        <mrow>
         <mn>4</mn>
         <mi>ω</mi>
         <mi>t</mi>
        </mrow>
       </mrow>
      </mrow>
      <mn>8</mn>
     </mfrac>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <csymbol cd="latexml">absent</csymbol>
    <apply>
     <minus></minus>
     <apply>
      <divide></divide>
      <apply>
       <plus></plus>
       <ci>C</ci>
       <apply>
        <times></times>
        <ci>m</ci>
        <ci>t</ci>
       </apply>
      </apply>
      <cn type="integer">8</cn>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <apply>
        <plus></plus>
        <ci>C</ci>
        <apply>
         <times></times>
         <ci>m</ci>
         <ci>t</ci>
        </apply>
       </apply>
       <apply>
        <cos></cos>
        <apply>
         <times></times>
         <cn type="integer">4</cn>
         <ci>ω</ci>
         <ci>t</ci>
        </apply>
       </apply>
      </apply>
      <cn type="integer">8</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =\frac{(C+m(t))}{8}-\frac{(C+m(t))\cos 4\omega t}{8}.
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>After filtering out the component based around cos(4ω<em>t</em>) and the DC component C, the original message will be recovered.</p>
<h2 id="a-more-sophisticated-product-detector">A more sophisticated product detector</h2>

<p>A more sophisticated product detector can be constructed in a way much like a single-sideband modulator. Two copies of the modulated input signals are created. The first copy is mixed with a local oscillator and <a href="low-pass_filter" title="wikilink">low-pass filtered</a>. The second copy is mixed with a 90° phase-shifted copy of the oscillator and the output of this mixer is also 90° phase-shifted and then low-pass filtered. These copies are then combined to produce the original message. This operation is similar to that performed by a dual-phase <a href="lock-in_amplifier" title="wikilink">lock-in amplifier</a>. Example: I-Q Demodulator</p>
<h2 id="advantages-and-disadvantages">Advantages and disadvantages</h2>

<p>The product demodulator has some advantages over an envelope detector for AM signal reception.</p>
<ul>
<li>The product demodulator can decode <a href="overmodulation" title="wikilink">overmodulated</a> AM and AM with suppressed carrier.</li>
<li>A signal demodulated with a product detector will have a higher <a href="signal_to_noise_ratio" title="wikilink">signal to noise ratio</a> than the same signal demodulated with an envelope detector.</li>
</ul>

<p>On the other hand, the envelope detector is a simple and relatively inexpensive circuit, and it can provide higher fidelity, since there is no possibility of mistuning the local oscillator.</p>

<p>A product detector (or equivalent) is needed to demodulate SSB signals.</p>

<p><a class="uri" href="de:Amplitudenmodulation#Koh.C3.A4rente_Demodulation" title="wikilink">de:Amplitudenmodulation#Koh.C3.A4rente_Demodulation</a>"</p>

<p><a href="Category:Frequency_mixers" title="wikilink">Category:Frequency mixers</a> <a href="Category:Communication_circuits" title="wikilink">Category:Communication circuits</a> <a class="uri" href="Category:Demodulation" title="wikilink">Category:Demodulation</a></p>
</body>
</html>
