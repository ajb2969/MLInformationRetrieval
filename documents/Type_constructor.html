<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="924">Type constructor</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Type constructor</h1>
<hr/>

<p>In the area of <a href="mathematical_logic" title="wikilink">mathematical logic</a> and <a href="computer_science" title="wikilink">computer science</a> known as <a href="type_theory" title="wikilink">type theory</a>, a <strong>type constructor</strong> is a feature of a typed <a href="formal_language" title="wikilink">formal language</a> that builds new types from old. Typical type constructors encountered are <a href="product_type" title="wikilink">product types</a>, <a href="function_type" title="wikilink">function types</a>, power types and <a href="list_type" title="wikilink">list types</a>. <a href="Basic_type" title="wikilink">Basic types</a> are considered <a class="uri" href="nullary" title="wikilink">nullary</a> type constructors. New types can be defined by recursively composing type constructors.</p>

<p>For example, <a href="simply_typed_lambda_calculus" title="wikilink">simply typed lambda calculus</a> can be seen as a language with a single type constructor—the function type constructor. Product types can generally be considered "built-in" in <a href="Typed_lambda_calculus" title="wikilink">typed lambda calculi</a> via <a class="uri" href="currying" title="wikilink">currying</a>.</p>

<p>Abstractly, a type constructor is an <em>n</em>-ary <strong>type operator</strong> taking as argument zero or more types, and returning another type. Making use of currying, <em>n</em>-ary type operators can be (re)written as a sequence of applications of unary type operators. Therefore, we can view the type operators as a simply typed lambda calculus, which has only one basic type, usually denoted 

<math display="inline" id="Type_constructor:0">
 <semantics>
  <mo>*</mo>
  <annotation-xml encoding="MathML-Content">
   <times></times>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   *
  </annotation>
 </semantics>
</math>

, and pronounced "type", which is the type of all types in the underlying language, which are now called <em>proper types</em> in order to distinguish them from the types of the type operators in their own calculus, which are called <em><a href="Kind_(type_theory)" title="wikilink">kinds</a></em>.</p>

<p>Instituting a simply typed lambda calculus over the type operators results in more than just a formalization of type constructors though. Higher-order type operators become possible. (See <a href="Kind_(type_theory)#Examples" title="wikilink">Kind (type theory)</a> for some examples.) Type operators correspond to the 2nd axis in the <a href="lambda_cube" title="wikilink">lambda cube</a>, leading to the simply typed lambda-calculus with type operators, λ<sub>ω</sub>; while this is not so well known, combining type operators with polymorphic lambda calculus (<a href="system_F" title="wikilink">system F</a>) yields <a href="system_F-omega" title="wikilink">system F-omega</a>.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Algebraic_data_type" title="wikilink">Algebraic data type</a></li>
<li><a href="Recursive_data_type" title="wikilink">Recursive data type</a></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li>

<p>, chapter 29, "Type Operators and Kinding"</p></li>
<li><a href="P.T._Johnstone" title="wikilink">P.T. Johnstone</a>, <em>Sketches of an Elephant</em>, p. 940</li>
</ul>

<p>"</p>

<p><a href="Category:Type_theory" title="wikilink">Category:Type theory</a></p>
</body>
</html>
