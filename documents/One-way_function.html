<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="373">One-way function</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>One-way function</h1>
<hr/>

<p>In <a href="computer_science" title="wikilink">computer science</a>, a <strong>one-way function</strong> is a <a href="function_(mathematics)" title="wikilink">function</a> that is easy to compute on every input, but hard to <a href="Inverse_function" title="wikilink">invert</a> given the <a href="image_(mathematics)" title="wikilink">image</a> of a random input. Here, "easy" and "hard" are to be understood in the sense of <a href="computational_complexity_theory" title="wikilink">computational complexity theory</a>, specifically the theory of <a href="polynomial_time" title="wikilink">polynomial time</a> problems. Not being <a href="One-to-one_function" title="wikilink">one-to-one</a> is not considered sufficient of a function for it to be called one-way (see Theoretical Definition, below).</p>

<p>The existence of such one-way functions is still an open conjecture. In fact, their existence would prove that the <a href="complexity_classes" title="wikilink">complexity classes</a> <a href="P_=_NP_problem" title="wikilink">P and NP are not equal</a>, thus resolving the foremost unsolved question of theoretical computer science.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> The converse is not known to be true, i.e. the existence of a proof that P and NP are not equal would not directly imply the existence of one-way functions.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>

<p>In applied contexts, the terms "easy" and "hard" are usually interpreted relative to some specific computing entity; typically "cheap enough for the legitimate users" and "prohibitively expensive for any <a href="Black_hat_hacking" title="wikilink">malicious agents</a>". One-way functions, in this sense, are fundamental tools for <a class="uri" href="cryptography" title="wikilink">cryptography</a>, <a href="personal_identification" title="wikilink">personal identification</a>, <a class="uri" href="authentication" title="wikilink">authentication</a>, and other <a href="data_security" title="wikilink">data security</a> applications. While the existence of one-way functions in this sense is also an open conjecture, there are several candidates that have withstood decades of intense scrutiny. Some of them are essential ingredients of most <a href="telecommunication" title="wikilink">telecommunications</a>, <a class="uri" href="e-commerce" title="wikilink">e-commerce</a>, and <a href="Online_banking" title="wikilink">e-banking</a> systems around the world.</p>
<h2 id="theoretical-definition">Theoretical definition</h2>

<p>A function <em>f</em>: {0, 1}<sup>*</sup> → {0, 1}<sup>*</sup> is <strong>one-way</strong> if <em>f</em> can be computed by a polynomial time algorithm, but for every <a href="randomized_algorithm" title="wikilink">randomized algorithm</a> <em>A</em> that runs in time polynomial in <em>n=|x|</em>, every polynomial <em>p</em>(<em>n</em>), and all sufficiently large <em>n</em></p>

<p>

<math display="block" id="One-way_function:0">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mi>r</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>A</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>=</mo>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo><</mo>
   <mfrac>
    <mn>1</mn>
    <mrow>
     <mi>p</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <csymbol cd="unknown">r</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">f</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">A</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">f</csymbol>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <csymbol cd="unknown">x</csymbol>
        <ci>normal-)</ci>
       </cerror>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <eq></eq>
     <csymbol cd="unknown">f</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-]</ci>
    </cerror>
    <lt></lt>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <apply>
      <times></times>
      <ci>p</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Pr[f(A(f(x)))=f(x)]<\frac{1}{p(n)}
  </annotation>
 </semantics>
</math>

</p>

<p>where the probability is over the choice of <em>x</em> from the <a href="Uniform_distribution_(discrete)" title="wikilink">uniform distribution</a> on {0, 1}<sup><em>n</em></sup>, and the randomness of <em>A</em>.</p>

<p>Note that, by this definition, the function must be "hard to invert" in the <a href="best,_worst_and_average_case" title="wikilink">average-case, rather than worst-case</a> sense. This is different from much of complexity theory (e.g., <a href="NP-hard" title="wikilink">NP-hardness</a>), where the term "hard" is meant in the worst-case. That's why even if some candidates for one-way functions (described below) are known to be <a class="uri" href="NP-complete" title="wikilink">NP-complete</a>, it does not imply their one-wayness. The latter property is only based on the lack of known algorithm to solve the problem.</p>

<p>It is not sufficient to make a function "lossy" (not one-to-one) to have a one-way function. In particular, the function that outputs the string of <em>n</em> zeros on any input of length <em>n</em> is <em>not</em> a one-way function because it is easy to come up with an input that will result in the same output. More precisely: For a function that simply outputs a string of zeroes, an algorithm A that just outputs any string of length <em>n</em> on input <em>f</em>(<em>x</em>) will "find" a proper preimage of the output, even if it is not the input which was originally used to find the output string.</p>
<h2 id="related-concepts">Related concepts</h2>

<p>A <strong>one-way permutation</strong> is a one-way function that is also a permutation—that is, a one-way function that is both <a href="injective_function" title="wikilink">injective</a> and <a href="surjection" title="wikilink">surjective</a>. One-way permutations are an important <a href="cryptographic_primitive" title="wikilink">cryptographic primitive</a>, and it is not known if their existence is implied by the existence of one-way functions.</p>

<p>A <a href="trapdoor_one-way_function" title="wikilink">trapdoor one-way function</a> or trapdoor permutation is a special kind of one-way function. Such a function is hard to invert unless some secret information, called the <em>trapdoor</em>, is known.</p>

<p>A <strong>collision-free hash function</strong> <em>f</em> is a one-way function that is also <em>collision-resistant</em>; that is, no <a href="randomized_polynomial_time" title="wikilink">randomized polynomial time</a> algorithm can find a <a href="Collision_(computer_science)" title="wikilink">collision</a>—distinct values <em>x</em>, <em>y</em> such that <em>f</em>(<em>x</em>) = <em>f</em>(<em>y</em>)—with non-negligible probability.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>
<h2 id="theoretical-implications-of-one-way-functions">Theoretical implications of one-way functions</h2>

<p>If <em>f</em> is a one-way function, then the inversion of <em>f</em> would be a problem whose output is hard to compute (by definition) but easy to check (just by computing <em>f</em> on it). Thus, the existence of a one-way function implies that <a href="FP_(complexity)" title="wikilink">FP</a>≠<a href="FNP_(complexity)" title="wikilink">FNP</a>, which in turn implies that P≠NP. However, it is not known whether P≠NP implies the existence of one-way functions.</p>

<p>The existence of a one-way function implies the existence of many other useful concepts, including:</p>
<ul>
<li><a href="Pseudorandom_generator" title="wikilink">Pseudorandom generators</a></li>
<li><a href="Pseudorandom_function" title="wikilink">Pseudorandom function</a> families</li>
<li><a href="commitment_scheme" title="wikilink">Bit commitment schemes</a></li>
<li>Private-key encryption schemes secure against <a href="adaptive_chosen-ciphertext_attack" title="wikilink">adaptive chosen-ciphertext attack</a></li>
<li><a href="Message_authentication_code" title="wikilink">Message authentication codes</a></li>
<li><a href="Digital_signature_scheme" title="wikilink">Digital signature schemes</a> (secure against adaptive chosen-message attack)</li>
</ul>

<p>The existence of one-way functions also implies that there is no <a href="natural_proof" title="wikilink">natural proof</a> for P≠NP.</p>
<h2 id="candidates-for-one-way-functions">Candidates for one-way functions</h2>

<p>The following are several candidates for one-way functions (as of April 2009). Clearly, it is not known whether these functions are indeed one-way; but extensive research has so far failed to produce an efficient inverting algorithm for any of them.</p>
<h3 id="multiplication-and-factoring">Multiplication and factoring</h3>

<p>The function <em>f</em> takes as inputs two prime numbers <em>p</em> and <em>q</em> in binary notation and returns their product. This function can be computed in <a href="big_O_notation" title="wikilink"><em>O</em>(<em>n</em><sup>2</sup>)</a> time where <em>n</em> is the total length (number of bits) of the inputs. Inverting this function requires <a href="integer_factorization" title="wikilink">finding the factors</a> of a given integer <em>N</em>. The best factoring algorithms known run in 

<math display="inline" id="One-way_function:1">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mn>2</mn>
     <mrow>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>log</mi>
         <mi>N</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mrow>
        <mn>1</mn>
        <mo>/</mo>
        <mn>3</mn>
       </mrow>
      </msup>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>log</mi>
         <mrow>
          <mi>log</mi>
          <mi>N</mi>
         </mrow>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mrow>
        <mn>2</mn>
        <mo>/</mo>
        <mn>3</mn>
       </mrow>
      </msup>
     </mrow>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <log></log>
        <ci>N</ci>
       </apply>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <cn type="integer">3</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <log></log>
        <apply>
         <log></log>
         <ci>N</ci>
        </apply>
       </apply>
       <apply>
        <divide></divide>
        <cn type="integer">2</cn>
        <cn type="integer">3</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(2^{{(\log N)^{1/3}(\log\log N})^{2/3}})
  </annotation>
 </semantics>
</math>

 time, which is only <a href="pseudo-polynomial_time" title="wikilink">pseudo-polynomial</a> in 

<math display="inline" id="One-way_function:2">
 <semantics>
  <mrow>
   <mi>log</mi>
   <mi>N</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <log></log>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \log N
  </annotation>
 </semantics>
</math>

, the number of bits needed to represent <em>N</em>.</p>

<p>This function can be generalized by allowing <em>p</em> and <em>q</em> to range over a suitable set of <a class="uri" href="semiprimes" title="wikilink">semiprimes</a>. Note that <em>f</em> is not one-way for arbitrary <em>p,q</em>&gt;1, since the product will have 2 as a factor with probability 3/4 (because the probability that an arbitrary <em>p</em> is odd is 1/2, and likewise for <em>q</em>, so if they're chosen independently, the probability that both are odd is therefore 1/4; hence the probability that neither is odd is 1 - 1/4 = 3/4).</p>
<h3 id="the-rabin-function-modular-squaring">The Rabin function (modular squaring)</h3>

<p>The <strong>Rabin function</strong>,<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> or squaring <a href="modular_arithmetic" title="wikilink">modulo</a> 

<math display="inline" id="One-way_function:3">
 <semantics>
  <mrow>
   <mi>N</mi>
   <mo>=</mo>
   <mrow>
    <mi>p</mi>
    <mi>q</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>N</ci>
    <apply>
     <times></times>
     <ci>p</ci>
     <ci>q</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N=pq
  </annotation>
 </semantics>
</math>


, where 

<math display="inline" id="One-way_function:4">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="One-way_function:5">
 <semantics>
  <mi>q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q
  </annotation>
 </semantics>
</math>

 are primes is believed to be a collection of one-way functions. We write</p>

<p>

<math display="block" id="One-way_function:6">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mtext>Rabin</mtext>
     <mi>N</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≜</mo>
   <mrow>
    <msup>
     <mi>x</mi>
     <mn>2</mn>
    </msup>
    <mo lspace="2.5pt" rspace="2.5pt">mod</mo>
    <mi>N</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-≜</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <mtext>Rabin</mtext>
      <ci>N</ci>
     </apply>
     <ci>x</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">modulo</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>N</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{Rabin}_{N}(x)\triangleq x^{2}\mod N
  </annotation>
 </semantics>
</math>

 to denote squaring modulo 

<math display="inline" id="One-way_function:7">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

: a specific member of the <strong>Rabin collection</strong>. It can be shown that extracting square roots, i.e. inverting the Rabin function, is computationally equivalent to factoring 

<math display="inline" id="One-way_function:8">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>


 (in the sense of <a href="polynomial-time_reduction" title="wikilink">polynomial-time reduction</a>). Hence it can be proven that the Rabin collection is one-way if and only if factoring is hard. This also holds for the special case in which 

<math display="inline" id="One-way_function:9">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="One-way_function:10">
 <semantics>
  <mi>q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q
  </annotation>
 </semantics>
</math>

 are of the same bit length. The <a href="Rabin_cryptosystem" title="wikilink">Rabin cryptosystem</a> is based on the assumption that this <a href="Rabin_one-way_function" title="wikilink">Rabin function</a> is one-way.</p>
<h3 id="discrete-exponential-and-logarithm">Discrete exponential and logarithm</h3>

<p>The function <em>f</em> takes a prime number <em>p</em> and an integer <em>x</em> between 0 and <em>p</em>−1; and returns the remainder of 2<sup><em>x</em></sup> divided by <em>p</em>. <a href="Modular_exponentiation" title="wikilink">Modular exponentiation</a> can be done in time <em>O</em>(<em>n</em><sup>3</sup>) where <em>n</em> is the number of bits in <em>p</em>. Inverting this function requires computing the <a href="discrete_logarithm" title="wikilink">discrete logarithm</a> modulo <em>p</em>; namely, given a prime <em>p</em> and an integer <em>y</em> between 0 and <em>p</em>−1, find <em>x</em> such that 2<sup><em>x</em></sup> = <em>y</em>. As of 2009, there is no published algorithm for this problem that runs in polynomial time. The <a href="ElGamal_encryption" title="wikilink">ElGamal encryption</a> scheme is based on this function.</p>
<h3 id="cryptographically-secure-hash-functions">Cryptographically secure hash functions</h3>

<p>There are a number of <a href="cryptographic_hash_function" title="wikilink">cryptographic hash functions</a> that are fast to compute like <a href="SHA_256" title="wikilink">SHA 256</a>. Some of the simpler versions have fallen to sophisticated analysis, but the strongest versions continue to offer fast, practical solutions for one-way computation. Most of the theoretical support for the functions are more techniques for thwarting some of the previously successful attacks.</p>
<h3 id="elliptic-curves">Elliptic curves</h3>

<p>An <a href="elliptic_curve" title="wikilink">elliptic curve</a> is a set of pairs of elements of a <a class="uri" href="field" title="wikilink">field</a> satisfying y<sup>2</sup> = x<sup>3</sup> + ax + b. For cryptography, <a href="finite_field" title="wikilink">finite fields</a> must be used. The elements of the curve form a group under an operation called "point addition" (which is not the same as the addition operation of the field). Multiplication kP of a point P by an integer k is defined as repeated addition of the point to itself. If k and P are known, it is easy to compute R=kP, but if R and P are known, it is assumed to be hard to compute k.</p>
<h3 id="other-candidates">Other candidates</h3>

<p>Other candidates for one-way functions have been based on the hardness of the decoding of random <a href="linear_code" title="wikilink">linear codes</a>, the <a href="subset_sum_problem" title="wikilink">subset sum problem</a> (<a href="Naccache-Stern_knapsack_cryptosystem" title="wikilink">Naccache-Stern knapsack cryptosystem</a>), or other problems.</p>
<h2 id="universal-one-way-function">Universal one-way function</h2>

<p>There is an explicit function <em>f</em> that has been proved to be one-way, if and only if one-way functions exist.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> In other words, if any function is one-way, then so is <em>f</em>. Since this function was the first combinatorial complete one-way function to be demonstrated, it is known as the "universal one-way function". The problem of determining the existence of one-way functions is thus reduced to the problem of proving that this specific function is one-way.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="One-way_compression_function" title="wikilink">One-way compression function</a></li>
<li><a href="Cryptographic_hash_function" title="wikilink">Cryptographic hash function</a></li>
<li><a href="Geometric_cryptography" title="wikilink">Geometric cryptography</a></li>
<li><a href="Trapdoor_function" title="wikilink">Trapdoor function</a></li>
</ul>
<h2 id="references">References</h2>
<h2 id="further-reading">Further reading</h2>
<ul>
<li>Jonathan Katz and Yehuda Lindell (2007). <em>Introduction to Modern Cryptography</em>. CRC Press. ISBN 1-58488-551-3.</li>
<li>

<p>Section 10.6.3: One-way functions, pp. 374–376.</p></li>
<li>

<p>Section 12.1: One-way functions, pp. 279–298.</p></li>
</ul>

<p>"</p>

<p><a class="uri" href="Category:Cryptography" title="wikilink">Category:Cryptography</a> <a href="Category:Cryptographic_primitives" title="wikilink">Category:Cryptographic primitives</a> <a href="Category:Unsolved_problems_in_computer_science" title="wikilink">Category:Unsolved problems in computer science</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="Oded_Goldreich" title="wikilink">Oded Goldreich</a> (2001). Foundations of Cryptography: Volume 1, Basic Tools, (<a href="http://www.wisdom.weizmann.ac.il/~oded/PSBookFrag/part2N.ps">draft available</a> from author's site). Cambridge University Press. ISBN 0-521-79172-3. (see also <a class="uri" href="http://www.wisdom.weizmann.ac.il/~oded/foc-book.html">http://www.wisdom.weizmann.ac.il/~oded/foc-book.html</a>)<a href="#fnref1">↩</a></li>
<li id="fn2"><a href="Shafi_Goldwasser" title="wikilink">Goldwasser, S.</a> and Bellare, M. <a href="http://cseweb.ucsd.edu/~mihir/papers/gb.html">"Lecture Notes on Cryptography"</a>. Summer course on cryptography, MIT, 1996–2001<a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
</ol>
</section>
</body>
</html>
