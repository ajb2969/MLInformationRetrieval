<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="138">Kernel density estimation</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Kernel density estimation</h1>
<hr/>

<p> In <a class="uri" href="statistics" title="wikilink">statistics</a>, <strong>kernel density estimation (KDE)</strong> is a <a href="non-parametric_statistics" title="wikilink">non-parametric</a> way to <a href="density_estimation" title="wikilink">estimate</a> the <a href="probability_density_function" title="wikilink">probability density function</a> of a <a href="random_variable" title="wikilink">random variable</a>. Kernel density estimation is a fundamental data smoothing problem where inferences about the <a href="statistical_population" title="wikilink">population</a> are made, based on a finite data <a href="statistical_sample" title="wikilink">sample</a>. In some fields such as <a href="signal_processing" title="wikilink">signal processing</a> and <a class="uri" href="econometrics" title="wikilink">econometrics</a> it is also termed the <em>Parzen–Rosenblatt window</em> method, after <a href="Emanuel_Parzen" title="wikilink">Emanuel Parzen</a> and <a href="Murray_Rosenblatt" title="wikilink">Murray Rosenblatt</a>, who are usually credited with independently creating it in its current form.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a><a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>
<h2 id="definition">Definition</h2>

<p>Let (<em>x</em><sub>1</sub>, <em>x</em><sub>2</sub>, …, <em>x<sub>n</sub></em>) be an <a href="Independent_and_identically_distributed_random_variables" title="wikilink">independent and identically distributed</a> sample drawn from some distribution with an unknown <a href="probability_density_function" title="wikilink">density</a> <em>ƒ</em>. We are interested in estimating the shape of this function <em>ƒ</em>. Its <em>kernel density estimator</em> is</p>

<p>

<math display="block" id="Kernel_density_estimation:0">
 <semantics>
  <mrow>
   <msub>
    <mover accent="true">
     <mi>f</mi>
     <mo stretchy="false">^</mo>
    </mover>
    <mi>h</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mn>1</mn>
    <mi>n</mi>
   </mfrac>
   <munderover>
    <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
    <mrow>
     <mi>i</mi>
     <mo>=</mo>
     <mn>1</mn>
    </mrow>
    <mi>n</mi>
   </munderover>
   <msub>
    <mi>K</mi>
    <mi>h</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>-</mo>
    <msub>
     <mi>x</mi>
     <mi>i</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mn>1</mn>
    <mrow>
     <mi>n</mi>
     <mi>h</mi>
    </mrow>
   </mfrac>
   <munderover>
    <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
    <mrow>
     <mi>i</mi>
     <mo>=</mo>
     <mn>1</mn>
    </mrow>
    <mi>n</mi>
   </munderover>
   <mi>K</mi>
   <mrow>
    <mo maxsize="160%" minsize="160%">(</mo>
    <mfrac>
     <mrow>
      <mi>x</mi>
      <mo>-</mo>
      <msub>
       <mi>x</mi>
       <mi>i</mi>
      </msub>
     </mrow>
     <mi>h</mi>
    </mfrac>
    <mo maxsize="160%" minsize="160%">)</mo>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <ci>normal-^</ci>
      <ci>f</ci>
     </apply>
     <ci>h</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <ci>n</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <eq></eq>
       <ci>i</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>n</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>K</ci>
     <ci>h</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>i</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <ci></ci>
    <eq></eq>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <apply>
      <times></times>
      <ci>n</ci>
      <ci>h</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <eq></eq>
       <ci>i</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>n</ci>
    </apply>
    <csymbol cd="unknown">K</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <divide></divide>
      <apply>
       <minus></minus>
       <ci>x</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>i</ci>
       </apply>
      </apply>
      <ci>h</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-,</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{f}_{h}(x)=\frac{1}{n}\sum_{i=1}^{n}K_{h}(x-x_{i})\quad=\frac{1}{nh}\sum_{%
i=1}^{n}K\Big(\frac{x-x_{i}}{h}\Big),
  </annotation>
 </semantics>
</math>

 where <em>K</em>(•) is the <a href="kernel_(statistics)#In_non-parametric_statistics" title="wikilink">kernel</a> — a non-negative function that integrates to one and has mean zero — and  is a <a class="uri" href="smoothing" title="wikilink">smoothing</a> parameter called the <em>bandwidth</em>. A kernel with subscript <em>h</em> is called the <em>scaled kernel</em> and defined as <mtpl> 1/<em>h K</em>(<em>x/h</em>)}}</mtpl>. Intuitively one wants to choose <em>h</em> as small as the data allow, however there is always a trade-off between the bias of the estimator and its variance; more on the choice of bandwidth below.</p>

<p>A range of kernel functions are commonly used: <a href="kernel_(statistics)#Kernel_functions_in_common_use" title="wikilink">uniform, triangular, biweight, triweight, Epanechnikov</a>, <a href="normal_distribution" title="wikilink">normal</a>, and others. The Epanechnikov kernel is optimal in a mean square error sense,<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> though the loss of efficiency is small for the kernels listed previously,<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> and due to its convenient mathematical properties, the normal kernel is often used , where <em>ϕ</em> is the <a href="standard_normal" title="wikilink">standard normal</a> density function.</p>

<p>The construction of a kernel density estimate finds interpretations in fields outside of density estimation. For example, in <a class="uri" href="thermodynamics" title="wikilink">thermodynamics</a>, this is equivalent to the amount of heat generated when <a href="heat_kernel" title="wikilink">heat kernels</a> (the fundamental solution to the <a href="heat_equation" title="wikilink">heat equation</a>) are placed at each data point locations <em>x<sub>i</sub></em>. Similar methods are used to construct <a href="discrete_Laplace_operator" title="wikilink">discrete Laplace operators</a> on point clouds for <a href="manifold_learning" title="wikilink">manifold learning</a>.</p>

<p>Kernel density estimates are closely related to <a class="uri" href="histograms" title="wikilink">histograms</a>, but can be endowed with properties such as smoothness or continuity by using a suitable kernel. To see this, we compare the construction of histogram and kernel density estimators, using these 6 data points: <em>x</em><sub>1</sub> = −2.1, <em>x</em><sub>2</sub> = −1.3, <em>x</em><sub>3</sub> = −0.4, <em>x</em><sub>4</sub> = 1.9, <em>x</em><sub>5</sub> = 5.1, <em>x</em><sub>6</sub> = 6.2. For the histogram, first the horizontal axis is divided into sub-intervals or bins which cover the range of the data. In this case, we have 6 bins each of width 2. Whenever a data point falls inside this interval, we place a box of height 1/12. If more than one data point falls inside the same bin, we stack the boxes on top of each other.</p>

<p>For the kernel density estimate, we place a normal kernel with variance 2.25 (indicated by the red dashed lines) on each of the data points <em>x<sub>i</sub></em>. The kernels are summed to make the kernel density estimate (solid blue curve). The smoothness of the kernel density estimate is evident compared to the discreteness of the histogram, as kernel density estimates converge faster to the true underlying density for continuous random variables.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>
<figure><b>(Figure)</b>
<figcaption>Comparison of the histogram (left) and kernel density estimate (right) constructed using the same data. The 6 individual kernels are the red dashed curves, the kernel density estimate the blue curves. The data points are the rug plot on the horizontal axis.</figcaption>
</figure>
<h2 id="bandwidth-selection">Bandwidth selection</h2>
<figure><b>(Figure)</b>
<figcaption>Kernel density estimate (KDE) with different bandwidths of a random sample of 100 points from a standard normal distribution. Grey: true density (standard normal). Red: KDE with h=0.05. Black: KDE with h=0.337. Green: KDE with h=2.</figcaption>
</figure>

<p>The bandwidth of the kernel is a <a href="free_parameter" title="wikilink">free parameter</a> which exhibits a strong influence on the resulting estimate. To illustrate its effect, we take a simulated <a href="Random_number_generator" title="wikilink">random sample</a> from the standard <a href="normal_distribution" title="wikilink">normal distribution</a> (plotted at the blue spikes in the <a href="Carpet_plot" title="wikilink">rug plot</a> on the horizontal axis). The grey curve is the true density (a normal density with mean 0 and variance 1). In comparison, the red curve is <em>undersmoothed</em> since it contains too many spurious data artifacts arising from using a bandwidth <em>h</em> = 0.05, which is too small. The green curve is <em>oversmoothed</em> since using the bandwidth <em>h</em> = 2 obscures much of the underlying structure. The black curve with a bandwidth of <em>h</em> = 0.337 is considered to be optimally smoothed since its density estimate is close to the true density.</p>

<p>The most common optimality criterion used to select this parameter is the expected <em>L</em><sub>2</sub> <a href="risk_function" title="wikilink">risk function</a>, also termed the <a href="mean_integrated_squared_error" title="wikilink">mean integrated squared error</a>:</p>

<p>

<math display="block" id="Kernel_density_estimation:1">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>MISE</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>h</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>E</mi>
     <mrow>
      <mo largeop="true" symmetric="true">∫</mo>
      <mrow>
       <mpadded width="+1.7pt">
        <msup>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <mrow>
            <msub>
             <mover accent="true">
              <mi>f</mi>
              <mo stretchy="false">^</mo>
             </mover>
             <mi>h</mi>
            </msub>
            <mrow>
             <mo stretchy="false">(</mo>
             <mi>x</mi>
             <mo stretchy="false">)</mo>
            </mrow>
           </mrow>
           <mo>-</mo>
           <mrow>
            <mi>f</mi>
            <mrow>
             <mo stretchy="false">(</mo>
             <mi>x</mi>
             <mo stretchy="false">)</mo>
            </mrow>
           </mrow>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
         <mn>2</mn>
        </msup>
       </mpadded>
       <mi>d</mi>
       <mi>x</mi>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>MISE</ci>
     <ci>h</ci>
    </apply>
    <apply>
     <times></times>
     <ci>E</ci>
     <apply>
      <int></int>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <minus></minus>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <apply>
            <ci>normal-^</ci>
            <ci>f</ci>
           </apply>
           <ci>h</ci>
          </apply>
          <ci>x</ci>
         </apply>
         <apply>
          <times></times>
          <ci>f</ci>
          <ci>x</ci>
         </apply>
        </apply>
        <cn type="integer">2</cn>
       </apply>
       <ci>d</ci>
       <ci>x</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{MISE}(h)=E\int(\hat{f}_{h}(x)-f(x))^{2}\,dx.
  </annotation>
 </semantics>
</math>

</p>

<p>Under weak assumptions on <em>ƒ</em> and <em>K</em>,<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a><a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> MISE (<em>h</em>) = AMISE(<em>h</em>) + <em>o(1/(nh) + h<sup>4</sup>)</em> where <em>o</em> is the <a href="little_o_notation" title="wikilink">little o notation</a>. The AMISE is the Asymptotic MISE which consists of the two leading terms</p>

<p>

<math display="block" id="Kernel_density_estimation:2">
 <semantics>
  <mrow>
   <mrow>
    <mo>AMISE</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>h</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mrow>
      <mi>R</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>K</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mrow>
      <mi>n</mi>
      <mi>h</mi>
     </mrow>
    </mfrac>
    <mo>+</mo>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <mn>4</mn>
     </mfrac>
     <msub>
      <mi>m</mi>
      <mn>2</mn>
     </msub>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>K</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mn>2</mn>
     </msup>
     <msup>
      <mi>h</mi>
      <mn>4</mn>
     </msup>
     <mi>R</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msup>
       <mi>f</mi>
       <mi>′′</mi>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>AMISE</ci>
     <ci>h</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <ci>R</ci>
       <ci>K</ci>
      </apply>
      <apply>
       <times></times>
       <ci>n</ci>
       <ci>h</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <cn type="integer">4</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>m</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>K</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>h</ci>
       <cn type="integer">4</cn>
      </apply>
      <ci>R</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>f</ci>
       <ci>′′</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{AMISE}(h)=\frac{R(K)}{nh}+\frac{1}{4}m_{2}(K)^{2}h^{4}R(f^{%
\prime\prime})
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Kernel_density_estimation:3">
 <semantics>
  <mrow>
   <mrow>
    <mi>R</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>g</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo largeop="true" symmetric="true">∫</mo>
    <mrow>
     <mi>g</mi>
     <mpadded width="+1.7pt">
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <mn>2</mn>
      </msup>
     </mpadded>
     <mi>d</mi>
     <mi>x</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>R</ci>
     <ci>g</ci>
    </apply>
    <apply>
     <int></int>
     <apply>
      <times></times>
      <ci>g</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>d</ci>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R(g)=\int g(x)^{2}\,dx
  </annotation>
 </semantics>
</math>


 for a function <em>g</em>, 

<math display="inline" id="Kernel_density_estimation:4">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>m</mi>
     <mn>2</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>K</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo largeop="true" symmetric="true">∫</mo>
    <mrow>
     <msup>
      <mi>x</mi>
      <mn>2</mn>
     </msup>
     <mi>K</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo rspace="4.2pt" stretchy="false">)</mo>
     </mrow>
     <mi>d</mi>
     <mi>x</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>m</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>K</ci>
    </apply>
    <apply>
     <int></int>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>K</ci>
      <ci>x</ci>
      <ci>d</ci>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m_{2}(K)=\int x^{2}K(x)\,dx
  </annotation>
 </semantics>
</math>

 and <em>ƒ</em>'' is the second derivative of <em>ƒ</em>. The minimum of this AMISE is the solution to this differential equation</p>

<p>

<math display="block" id="Kernel_density_estimation:5">
 <semantics>
  <mrow>
   <mrow>
    <mfrac>
     <mo>∂</mo>
     <mrow>
      <mo>∂</mo>
      <mi>h</mi>
     </mrow>
    </mfrac>
    <mrow>
     <mo>AMISE</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>h</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo>-</mo>
     <mfrac>
      <mrow>
       <mi>R</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>K</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mrow>
       <mi>n</mi>
       <msup>
        <mi>h</mi>
        <mn>2</mn>
       </msup>
      </mrow>
     </mfrac>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>m</mi>
      <mn>2</mn>
     </msub>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>K</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mn>2</mn>
     </msup>
     <msup>
      <mi>h</mi>
      <mn>3</mn>
     </msup>
     <mi>R</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msup>
       <mi>f</mi>
       <mi>′′</mi>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <partialdiff></partialdiff>
       <apply>
        <partialdiff></partialdiff>
        <ci>h</ci>
       </apply>
      </apply>
      <apply>
       <ci>AMISE</ci>
       <ci>h</ci>
      </apply>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <minus></minus>
       <apply>
        <divide></divide>
        <apply>
         <times></times>
         <ci>R</ci>
         <ci>K</ci>
        </apply>
        <apply>
         <times></times>
         <ci>n</ci>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>h</ci>
          <cn type="integer">2</cn>
         </apply>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>m</ci>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>K</ci>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>h</ci>
        <cn type="integer">3</cn>
       </apply>
       <ci>R</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>f</ci>
        <ci>′′</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{\partial}{\partial h}\operatorname{AMISE}(h)=-\frac{R(K)}{nh^{2}}+m_{2}(%
K)^{2}h^{3}R(f^{\prime\prime})=0
  </annotation>
 </semantics>
</math>

</p>

<p>or</p>

<p>

<math display="block" id="Kernel_density_estimation:6">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>h</mi>
     <mo>AMISE</mo>
    </msub>
    <mo>=</mo>
    <mfrac>
     <mrow>
      <mi>R</mi>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>K</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <mrow>
        <mn>1</mn>
        <mo>/</mo>
        <mn>5</mn>
       </mrow>
      </msup>
     </mrow>
     <mrow>
      <msub>
       <mi>m</mi>
       <mn>2</mn>
      </msub>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>K</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <mrow>
        <mn>2</mn>
        <mo>/</mo>
        <mn>5</mn>
       </mrow>
      </msup>
      <mi>R</mi>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <msup>
         <mi>f</mi>
         <mi>′′</mi>
        </msup>
        <mo stretchy="false">)</mo>
       </mrow>
       <mrow>
        <mn>1</mn>
        <mo>/</mo>
        <mn>5</mn>
       </mrow>
      </msup>
      <msup>
       <mi>n</mi>
       <mrow>
        <mn>1</mn>
        <mo>/</mo>
        <mn>5</mn>
       </mrow>
      </msup>
     </mrow>
    </mfrac>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>h</ci>
     <ci>AMISE</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <ci>R</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>K</ci>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <cn type="integer">5</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>m</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>K</ci>
       <apply>
        <divide></divide>
        <cn type="integer">2</cn>
        <cn type="integer">5</cn>
       </apply>
      </apply>
      <ci>R</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>f</ci>
        <ci>′′</ci>
       </apply>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <cn type="integer">5</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>n</ci>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <cn type="integer">5</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h_{\operatorname{AMISE}}=\frac{R(K)^{1/5}}{m_{2}(K)^{2/5}R(f^{\prime\prime})^{%
1/5}n^{1/5}}.
  </annotation>
 </semantics>
</math>

</p>

<p>Neither the AMISE nor the <em>h</em><sub>AMISE</sub> formulas are able to be used directly since they involve the unknown density function <em>ƒ</em> or its second derivative <em>ƒ</em>'', so a variety of automatic, data-based methods have been developed for selecting the bandwidth. Many review studies have been carried out to compare their efficacities,<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a><a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a><a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a><a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a><a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> with the general consensus that the plug-in selectors<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> <a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a> and <a href="Cross-validation_(statistics)" title="wikilink">cross validation</a> selectors<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a><a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a><a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a> are the most useful over a wide range of data sets.</p>

<p>Substituting any bandwidth <em>h</em> which has the same asymptotic order <em>n</em><sup>−1/5</sup> as <em>h</em><sub>AMISE</sub> into the AMISE gives that AMISE(<em>h</em>) = <em>O</em>(<em>n</em><sup>−4/5</sup>), where <em>O</em> is the <a href="big_o_notation" title="wikilink">big o notation</a>. It can be shown that, under weak assumptions, there cannot exist a non-parametric estimator that converges at a faster rate than the kernel estimator.<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a> Note that the <em>n</em><sup>−4/5</sup> rate is slower than the typical <em>n</em><sup>−1</sup> convergence rate of parametric methods.</p>

<p>If the bandwidth is not held fixed, but is varied depending upon the location of either the estimate (balloon estimator) or the samples (pointwise estimator), this produces a particularly powerful method termed <a href="variable_kernel_density_estimation" title="wikilink">adaptive or variable bandwidth kernel density estimation</a>.</p>
<h3 id="practical-estimation-of-the-bandwidth">Practical estimation of the bandwidth</h3>

<p>If Gaussian basis functions are used to approximate <a class="uri" href="univariate" title="wikilink">univariate</a> data, and the underlying density being estimated is Gaussian then it can be shown that the optimal choice for <em>h</em> is<a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a></p>

<p>

<math display="block" id="Kernel_density_estimation:7">
 <semantics>
  <mrow>
   <mrow>
    <mi>h</mi>
    <mo>=</mo>
    <msup>
     <mrow>
      <mo>(</mo>
      <mfrac>
       <mrow>
        <mn>4</mn>
        <msup>
         <mover accent="true">
          <mi>σ</mi>
          <mo stretchy="false">^</mo>
         </mover>
         <mn>5</mn>
        </msup>
       </mrow>
       <mrow>
        <mn>3</mn>
        <mi>n</mi>
       </mrow>
      </mfrac>
      <mo>)</mo>
     </mrow>
     <mfrac>
      <mn>1</mn>
      <mn>5</mn>
     </mfrac>
    </msup>
    <mo>≈</mo>
    <mrow>
     <mn>1.06</mn>
     <mover accent="true">
      <mi>σ</mi>
      <mo stretchy="false">^</mo>
     </mover>
     <msup>
      <mi>n</mi>
      <mrow>
       <mo>-</mo>
       <mrow>
        <mn>1</mn>
        <mo>/</mo>
        <mn>5</mn>
       </mrow>
      </mrow>
     </msup>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>h</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <cn type="integer">4</cn>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <ci>normal-^</ci>
          <ci>σ</ci>
         </apply>
         <cn type="integer">5</cn>
        </apply>
       </apply>
       <apply>
        <times></times>
        <cn type="integer">3</cn>
        <ci>n</ci>
       </apply>
      </apply>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <cn type="integer">5</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <approx></approx>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <cn type="float">1.06</cn>
      <apply>
       <ci>normal-^</ci>
       <ci>σ</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>n</ci>
       <apply>
        <minus></minus>
        <apply>
         <divide></divide>
         <cn type="integer">1</cn>
         <cn type="integer">5</cn>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h=\left(\frac{4\hat{\sigma}^{5}}{3n}\right)^{\frac{1}{5}}\approx 1.06\hat{%
\sigma}n^{-1/5},
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Kernel_density_estimation:8">
 <semantics>
  <mover accent="true">
   <mi>σ</mi>
   <mo stretchy="false">^</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-^</ci>
    <ci>σ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{\sigma}
  </annotation>
 </semantics>
</math>


 is the standard deviation of the samples. This approximation is termed the <em>normal distribution approximation</em>, Gaussian approximation, or <em><a href="Bernard_Silverman" title="wikilink">Silverman</a>'s rule of thumb</em>.</p>
<h2 id="relation-to-the-characteristic-function-density-estimator">Relation to the characteristic function density estimator</h2>

<p>Given the sample (<em>x</em><sub>1</sub>, <em>x</em><sub>2</sub>, …, <em>x<sub>n</sub></em>), it is natural to estimate the <a href="characteristic_function_(probability_theory)" title="wikilink">characteristic function</a> <mtpl> E[<em>e</em><sup><em>itX</em></sup>]}}</mtpl> as</p>

<p>

<math display="block" id="Kernel_density_estimation:9">
 <semantics>
  <mrow>
   <mrow>
    <mover accent="true">
     <mi>φ</mi>
     <mo stretchy="false">^</mo>
    </mover>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mi>n</mi>
    </mfrac>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>j</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>n</mi>
     </munderover>
     <msup>
      <mi>e</mi>
      <mrow>
       <mi>i</mi>
       <mi>t</mi>
       <msub>
        <mi>x</mi>
        <mi>j</mi>
       </msub>
      </mrow>
     </msup>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <ci>normal-^</ci>
      <ci>φ</ci>
     </apply>
     <ci>t</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <ci>n</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>j</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>n</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>e</ci>
       <apply>
        <times></times>
        <ci>i</ci>
        <ci>t</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>j</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{\varphi}(t)=\frac{1}{n}\sum_{j=1}^{n}e^{itx_{j}}
  </annotation>
 </semantics>
</math>

 Knowing the characteristic function, it is possible to find the corresponding probability density function through the <a href="Fourier_transform" title="wikilink">Fourier transform</a> formula. One difficulty with applying this inversion formula is that it leads to a diverging integral, since the estimate 

<math display="inline" id="Kernel_density_estimation:10">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>φ</mi>
    <mo stretchy="false">^</mo>
   </mover>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <ci>normal-^</ci>
     <ci>φ</ci>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle\hat{\varphi}(t)
  </annotation>
 </semantics>
</math>

 is unreliable for large <em>t</em>’s. To circumvent this problem, the estimator 

<math display="inline" id="Kernel_density_estimation:11">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>φ</mi>
    <mo stretchy="false">^</mo>
   </mover>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <ci>normal-^</ci>
     <ci>φ</ci>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle\hat{\varphi}(t)
  </annotation>
 </semantics>
</math>

 is multiplied by a damping function <mtpl> <em>ψ</em>(<em>ht</em>)}}</mtpl>, which is equal to 1 at the origin and then falls to 0 at infinity. The “bandwidth parameter” <em>h</em> controls how fast we try to dampen the function 

<math display="inline" id="Kernel_density_estimation:12">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>φ</mi>
    <mo stretchy="false">^</mo>
   </mover>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <ci>normal-^</ci>
     <ci>φ</ci>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle\hat{\varphi}(t)
  </annotation>
 </semantics>
</math>

. In particular when <em>h</em> is small, then <em>ψ<sub>h</sub></em>(<em>t</em>) will be approximately one for a large range of <em>t</em>’s, which means that 

<math display="inline" id="Kernel_density_estimation:13">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>φ</mi>
    <mo stretchy="false">^</mo>
   </mover>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <ci>normal-^</ci>
     <ci>φ</ci>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle\hat{\varphi}(t)
  </annotation>
 </semantics>
</math>


 remains practically unaltered in the most important region of <em>t</em>’s.</p>

<p>The most common choice for function <em>ψ</em> is either the uniform function }, which effectively means truncating the interval of integration in the inversion formula to , or the <a href="gaussian_function" title="wikilink">gaussian function</a> <mtpl> <em>e</em><sup><em>−π t</em><sup>2</sup></sup>}}</mtpl>. Once the function <em>ψ</em> has been chosen, the inversion formula may be applied, and the density estimator will be</p>

<p>

<math display="inline" id="Kernel_density_estimation:14">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>f</mi>
    <mo stretchy="false">^</mo>
   </mover>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <ci>normal-^</ci>
     <ci>f</ci>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle\hat{f}(x)
  </annotation>
 </semantics>
</math>


 where <em>K</em> is the Fourier transform of the damping function <em>ψ</em>. Thus the kernel density estimator coincides with the characteristic function density estimator.</p>
<h2 id="statistical-implementation">Statistical implementation</h2>

<p>A non-exhaustive list of software implementations of kernel density estimators includes:</p>
<ul>
<li>In <a href="Analytica_(software)" title="wikilink">Analytica</a> release 4.4, the <em>Smoothing</em> option for PDF results uses KDE, and from expressions it is available via the built-in <code>Pdf</code> function.</li>
<li>In <a href="C_(programming_language)" title="wikilink">C</a>/<a class="uri" href="C++" title="wikilink">C++</a>, <a href="http://www.umiacs.umd.edu/~morariu/figtree/">FIGTree</a> is a library that can be used to compute kernel density estimates using normal kernels. MATLAB interface available.</li>
<li>In <a class="uri" href="C++" title="wikilink">C++</a>, <a href="http://libagf.sf.net">libagf</a> is a library for <a href="variable_kernel_density_estimation" title="wikilink">variable kernel density estimation</a>.</li>
<li>In <a class="uri" href="CrimeStat" title="wikilink">CrimeStat</a>, kernel density estimation is implemented using five different kernel functions – normal, uniform, quartic, negative exponential, and triangular. Both single- and dual-kernel density estimate routines are available. Kernel density estimation is also used in interpolating a Head Bang routine, in estimating a two-dimensional Journey-to-crime density function, and in estimating a three-dimensional Bayesian Journey-to-crime estimate.</li>
<li>In <a class="uri" href="ELKI" title="wikilink">ELKI</a>, kernel density functions can be found in the package <code>de.lmu.ifi.dbs.elki.math.statistics.kernelfunctions</code></li>
<li>In <a class="uri" href="ESRI" title="wikilink">ESRI</a> products, kernel density mapping is managed out of the Spatial Analyst toolbox and uses the Quartic(biweight) kernel.</li>
<li>In <a href="Microsoft_Excel" title="wikilink">Excel</a>, the Royal Society of Chemistry has created an add-in to run kernel density estimation based on their <a href="http://www.rsc.org/Membership/Networking/InterestGroups/Analytical/AMC/Software/kerneldensities.asp">Analytical Methods Committee Technical Brief 4</a>.</li>
<li>In <a class="uri" href="gnuplot" title="wikilink">gnuplot</a>, kernel density estimation is implemented by the <code>smooth kdensity</code> option, the datafile can contain a weight and bandwidth for each point, or the bandwidth can be set automatically<a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a> according to "Silverman's rule of thumb" (see above).</li>
<li>In <a href="Haskell_(programming_language)" title="wikilink">Haskell</a>, kernel density is implemented in the <a href="http://hackage.haskell.org/package/statistics">statistics</a> package.</li>
<li>In <a href="Java_(programming_language)" title="wikilink">Java</a>, the <a href="Weka_(machine_learning)" title="wikilink">Weka (machine learning)</a> package provides <a href="http://weka.sourceforge.net/doc.stable/weka/estimators/KernelEstimator.html">weka.estimators.KernelEstimator</a>, among others.</li>
<li>In <a class="uri" href="JavaScript" title="wikilink">JavaScript</a>, the visualization package <a href="D3js" title="wikilink">D3.js</a> offers a KDE package in its science.stats package.</li>
<li>In <a href="JMP_(statistical_software)" title="wikilink">JMP</a>, The Distribution platform can be used to create univariate kernel density estimates, and the Fit Y by X platform can be used to create bivariate kernel density estimates.</li>
<li>In <a href="Julia_(programming_language)" title="wikilink">Julia</a>, kernel density estimation is implemented in the <a href="https://github.com/JuliaStats/KernelDensity.jl">KernelDensity.jl</a> package.</li>
<li>In <a class="uri" href="MATLAB" title="wikilink">MATLAB</a>, kernel density estimation is implemented through the <code>ksdensity</code> function (Statistics Toolbox). This function does not provide an automatic data-driven bandwidth but uses a <a href="rule_of_thumb" title="wikilink">rule of thumb</a>, which is optimal only when the target density is normal. A free MATLAB software package which implements an automatic bandwidth selection method<a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a> is available from the MATLAB Central File Exchange for <a href="http://www.mathworks.com/matlabcentral/fileexchange/14034">1-dimensional data</a> and for <a href="http://www.mathworks.com/matlabcentral/fileexchange/17204">2-dimensional data</a>.</li>
<li>In <a class="uri" href="Mathematica" title="wikilink">Mathematica</a>, numeric kernel density estimation is implemented by the function <code>SmoothKernelDistribution</code> <a href="http://reference.wolfram.com/mathematica/ref/SmoothKernelDistribution.html">here</a> and symbolic estimation is implemented using the function <code>KernelMixtureDistribution</code> <a href="http://reference.wolfram.com/mathematica/ref/KernelMixtureDistribution.html">here</a> both of which provide data-driven bandwidths.</li>
<li>In <a class="uri" href="Minitab" title="wikilink">Minitab</a>, the Royal Society of Chemistry has created a macro to run kernel density estimation based on their <a href="http://www.rsc.org/Membership/Networking/InterestGroups/Analytical/AMC/Software/kerneldensities.asp">Analytical Methods Committee Technical Brief 4</a>.</li>
<li>In the <a href="NAG_Numerical_Library" title="wikilink">NAG Library</a>, kernel density estimation is implemented via the <code>g10ba</code> routine (available in both the Fortran<a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a> and the C<a class="footnoteRef" href="#fn23" id="fnref23"><sup>23</sup></a> versions of the Library).</li>
<li>In <a href="GNU_Octave" title="wikilink">Octave</a>, kernel density estimation is implemented by the <code>kernel_density</code> option (econometrics package).</li>
<li>In <a href="Origin_(software)" title="wikilink">Origin</a>, 2D kernel density plot can be made from its user interface, and two functions, Ksdensity for 1D and Ks2density for 2D can be used from its <a href="http://wiki.originlab.com/~originla/ltwiki/index.php?title=Category:LabTalk_Programming">LabTalk</a>, <a href="Python_(programming_language)" title="wikilink">Python</a>, or <a href="C_(programming_language)" title="wikilink">C</a> code.</li>
<li>In <a class="uri" href="Perl" title="wikilink">Perl</a>, an implementation can be found in the <a href="http://search.cpan.org/~janert/Statistics-KernelEstimation-0.05">Statistics-KernelEstimation module</a></li>
<li>In <a href="Python_(programming_language)" title="wikilink">Python</a>, many implementations exist: SciPy (<code>scipy.stats.gaussian_kde</code>), Statsmodels (<code>KDEUnivariate</code> and <code>KDEMultivariate</code>), and Scikit-learn (<code>KernelDensity</code>) (see comparison<a class="footnoteRef" href="#fn24" id="fnref24"><sup>24</sup></a>).</li>
</ul>
<ul>
<li>In <a href="R_(programming_language)" title="wikilink">R</a>, it is implemented through the <code>density</code> and the <code>bkde</code> function in the <a href="http://cran.r-project.org/web/packages/KernSmooth/index.html">KernSmooth library</a> (both included in the base distribution), the <code>kde</code> function in the <a href="http://cran.r-project.org/web/packages/ks/index.html">ks library</a>, the <code>dkden</code> and <code>dbckden</code> functions in the <a href="http://cran.r-project.org/web/packages/evmix/index.html">evmix library</a> (latter for boundary corrected kernel density estimation for bounded support), the <code>npudens</code> function in the <a href="http://cran.r-project.org/web/packages/np/index.html">np library</a> (numeric and categorical data), the <code>sm.density</code> function in the <a href="http://cran.r-project.org/web/packages/sm/index.html">sm library</a>. For an implementation of the <code>kde.R</code> function, which does not require installing any packages or libraries, see <a href="http://www-etud.iro.umontreal.ca/~botev/kde.R">kde.R</a>.</li>
<li>In <a href="SAS_(software)" title="wikilink">SAS</a>, <code> proc kde </code> can be used to estimate univariate and bivariate kernel densities.</li>
<li>In <a class="uri" href="Stata" title="wikilink">Stata</a>, it is implemented through <code>kdensity</code>;<a class="footnoteRef" href="#fn25" id="fnref25"><sup>25</sup></a> for example <code>histogram x, kdensity</code>. Alternatively a free Stata module KDENS is available from <a href="http://ideas.repec.org/c/boc/bocode/s456410.html">here</a> allowing a user to estimate 1D or 2D density functions.</li>
</ul>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Kernel_(statistics)" title="wikilink">Kernel (statistics)</a></li>
<li><a href="Kernel_smoothing" title="wikilink">Kernel smoothing</a></li>
<li><a href="Kernel_regression" title="wikilink">Kernel regression</a></li>
<li><a href="Density_estimation" title="wikilink">Density estimation</a> (with presentation of other examples)</li>
<li><a class="uri" href="Mean-shift" title="wikilink">Mean-shift</a></li>
<li><a href="Scale_space" title="wikilink">Scale space</a> The triplets {(<em>x</em>, <em>h</em>, KDE with bandwidth <em>h</em> evaluated at <em>x</em>: all <em>x</em>, <em>h</em> &gt; 0} form a <a href="scale_space" title="wikilink">scale space</a> representation of the data.</li>
<li><a href="Multivariate_kernel_density_estimation" title="wikilink">Multivariate kernel density estimation</a></li>
<li><a href="Variable_kernel_density_estimation" title="wikilink">Variable kernel density estimation</a></li>
</ul>
<h2 id="references">References</h2>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.mvstat.net/tduong/research/seminars/seminar-2001-05">Introduction to kernel density estimation</a> A short tutorial which motivates kernel density estimators as an improvement over histograms.</li>
<li><a href="http://2000.jukuin.keio.ac.jp/shimazaki/res/kernel.html">Kernel Bandwidth Optimization</a> A free online tool that instantly generates an optimized kernel density estimate of your data.</li>
<li><a href="http://www.wessa.net/rwasp_density.wasp">Free Online Software (Calculator)</a> computes the Kernel Density Estimation for any data series according to the following Kernels: Gaussian, Epanechnikov, Rectangular, Triangular, Biweight, Cosine, and Optcosine.</li>
<li><a href="http://pcarvalho.com/things/kerneldensityestimation/index.html">Kernel Density Estimation Applet</a> An online interactive example of kernel density estimation. Requires .NET 3.0 or later.</li>
</ul>

<p>"</p>

<p><a href="Category:Estimation_of_densities" title="wikilink">Category:Estimation of densities</a> <a href="Category:Non-parametric_statistics" title="wikilink">Category:Non-parametric statistics</a> <a href="Category:Machine_learning" title="wikilink">Category:Machine learning</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"></li>
<li id="fn7"></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
<li id="fn10"><a href="#fnref10">↩</a></li>
<li id="fn11"><a href="#fnref11">↩</a></li>
<li id="fn12"><a href="#fnref12">↩</a></li>
<li id="fn13"><a href="#fnref13">↩</a></li>
<li id="fn14"><a href="#fnref14">↩</a></li>
<li id="fn15"><a href="#fnref15">↩</a></li>
<li id="fn16"><a href="#fnref16">↩</a></li>
<li id="fn17"><a href="#fnref17">↩</a></li>
<li id="fn18"><a href="#fnref18">↩</a></li>
<li id="fn19"><a href="#fnref19">↩</a></li>
<li id="fn20"> See section 13.2.2 entitled <em>Kernel density estimates</em>.<a href="#fnref20">↩</a></li>
<li id="fn21"><a href="#fnref21">↩</a></li>
<li id="fn22"><a href="#fnref22">↩</a></li>
<li id="fn23"><a href="#fnref23">↩</a></li>
<li id="fn24"><a href="#fnref24">↩</a></li>
<li id="fn25"><a class="uri" href="https://www.stata.com/manuals13/rkdensity.pdf">https://www.stata.com/manuals13/rkdensity.pdf</a><a href="#fnref25">↩</a></li>
</ol>
</section>
</body>
</html>
