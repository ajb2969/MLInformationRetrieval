<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1035">Find first set</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Find first set</h1>
<hr>In [[software]], '''find first set''' ('''ffs''') or<style>
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
<style>
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
</hr></body></html>
<body>

<p><strong><code>find</code> <code>first</code> <code>one</code></strong><code> is a </code><a href="bit_operation" title="wikilink"><code>bit</code> <code>operation</code></a><code> that, given an unsigned </code><a href="Word_(computer_architecture)" title="wikilink"><code>machine</code> <code>word</code></a><code>, identifies the least significant index or position of the bit set to one in the word. A nearly equivalent operation is </code><strong><code>count</code> <code>trailing</code> <code>zeros</code></strong><code> (</code><strong><code>ctz</code></strong><code>) or </code><strong><code>number</code> <code>of</code> <code>trailing</code> <code>zeros</code></strong><code> (</code><strong><code>ntz</code></strong><code>), which counts the number of zero bits following the least significant one bit. The complementary operation that finds the index or position of the most significant set bit is </code><em><code>log</code> <code>base</code> <code>2</code></em><code>, so called because it computes the </code><a href="binary_logarithm" title="wikilink"><code>binary</code> <code>logarithm</code></a><code> </code>

<math display="inline" id="Find_first_set:0">
 <semantics>
  <mrow>
   <mo stretchy="false">⌊</mo>
   <mrow>
    <msub>
     <mi>log</mi>
     <mn>2</mn>
    </msub>
    <mi>x</mi>
   </mrow>
   <mo stretchy="false">⌋</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <floor></floor>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <log></log>
      <cn type="integer">2</cn>
     </apply>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lfloor\log_{2}x\rfloor
  </annotation>
 </semantics>
</math>

<code>.</code><a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a><code> This is closely related to </code><strong><code>count</code> <code>leading</code> <code>zeros</code></strong><code> (</code><strong><code>clz</code></strong><code>) or </code><strong><code>number</code> <code>of</code> <code>leading</code> <code>zeros</code></strong><code> (</code><strong><code>nlz</code></strong><code>), which counts the number of zero bits preceding the most significant one bit. These four operations also have negated versions:</code></p>
<ul>
<li><strong>find first zero</strong> (<strong>ffz</strong>), which identifies the index of the least significant zero bit;</li>
<li><strong>count trailing ones</strong>, which counts the number of one bits following the least significant zero bit.</li>
<li><strong>count leading ones</strong>, which counts the number of one bits preceding the most significant zero bit;</li>
<li>The operation that finds the index of the most significant zero bit, which is a rounded version of the <a href="binary_logarithm" title="wikilink">binary logarithm</a>.</li>
</ul>

<p>There are two common variants of find first set, the POSIX definition which starts indexing of bits at 1,<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> herein labelled ffs, and the variant which starts indexing of bits at zero, which is equivalent to ctz and so will be called by that name.</p>
<h2 id="examples">Examples</h2>

<p>Given the following 32-bit word:</p>
<dl>
<dd>00000000000000001000000000001000
</dd>
</dl>

<p>The count trailing zeros operation would return 3, while the count leading zeros operation returns 16. The count leading zeros operation depends on the word size: if this 32-bit word were truncated to a 16-bit word, count leading zeros would return zero. The find first set operation would return 4, indicating the 4th position from the right. The log base 2 is 15.</p>

<p>Similarly, given the following 32-bit word, the bitwise negation of the above word:</p>
<dl>
<dd>11111111111111110111111111110111
</dd>
</dl>

<p>The count trailing ones operation would return 3, the count leading ones operation would return 16, and the find first zero operation ffz would return 4.</p>

<p>If the word is zero (no bits set), count leading zeros and count trailing zeros both return the number of bits in the word, while ffs returns zero. Both log base 2 and zero-based implementations of find first set generally return an undefined result for the zero word.</p>
<h2 id="hardware-support">Hardware support</h2>

<p>Many architectures include <a href="instruction_set" title="wikilink">instructions</a> to rapidly perform find first set and/or related operations, listed below. The most common operation is count leading zeros (clz), likely because all other operations can be implemented efficiently in terms of it (see <a href="#Properties_and_relations" title="wikilink">Properties and relations</a>).</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>Platform</p></th>
<th style="text-align: left;">
<p>Mnemonic</p></th>
<th style="text-align: left;">
<p>Name</p></th>
<th style="text-align: left;">
<p>Word sizes</p></th>
<th style="text-align: left;">
<p>Description</p></th>
<th style="text-align: left;">
<p>Result on zero input</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p><a href="ARM_architecture" title="wikilink">ARM</a> (<a href="List_of_ARM_microarchitectures" title="wikilink">ARMv5T architecture and later</a>)</p></td>
<td style="text-align: left;">
<p>clz<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p></td>
<td style="text-align: left;">
<p>Count Leading Zeros</p></td>
<td style="text-align: left;">
<p>32</p></td>
<td style="text-align: left;">
<p>clz</p></td>
<td style="text-align: left;">
<p>32</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><a href="ARM_architecture" title="wikilink">ARM</a> (<a href="List_of_ARM_microarchitectures" title="wikilink">ARMv8-A architecture</a>)</p></td>
<td style="text-align: left;">
<p>clz</p></td>
<td style="text-align: left;">
<p>Count Leading Zeros</p></td>
<td style="text-align: left;">
<p>32, 64</p></td>
<td style="text-align: left;">
<p>clz</p></td>
<td style="text-align: left;">
<p>input size</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><a href="DEC_Alpha" title="wikilink">DEC Alpha</a></p></td>
<td style="text-align: left;">
<p>ctlz<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p></td>
<td style="text-align: left;">
<p>Count Leading Zeros</p></td>
<td style="text-align: left;">
<p>64</p></td>
<td style="text-align: left;">
<p>clz</p></td>
<td style="text-align: left;">
<p>64</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><a href="DEC_Alpha" title="wikilink">DEC Alpha</a></p></td>
<td style="text-align: left;">
<p>cttz<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p></td>
<td style="text-align: left;">
<p>Count Trailing Zeros</p></td>
<td style="text-align: left;">
<p>64</p></td>
<td style="text-align: left;">
<p>ctz</p></td>
<td style="text-align: left;">
<p>64</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><a href="Intel_80386" title="wikilink">Intel 80386</a> and later</p></td>
<td style="text-align: left;">
<p>bsf<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p></td>
<td style="text-align: left;">
<p>Bit Scan Forward</p></td>
<td style="text-align: left;">
<p>16, 32, 64</p></td>
<td style="text-align: left;">
<p>ctz</p></td>
<td style="text-align: left;">
<p>Undefined, sets zero flag</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><a href="Intel_80386" title="wikilink">Intel 80386</a> and later</p></td>
<td style="text-align: left;">
<p>bsr<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p></td>
<td style="text-align: left;">
<p>Bit Scan Reverse</p></td>
<td style="text-align: left;">
<p>16, 32, 64</p></td>
<td style="text-align: left;">
<p>log base 2</p></td>
<td style="text-align: left;">
<p>Undefined, sets zero flag</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><a class="uri" href="x86" title="wikilink">x86</a> supporting <a href="Bit_Manipulation_Instruction_Sets#ABM" title="wikilink">ABM</a></p></td>
<td style="text-align: left;">
<p>lzcnt<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></p></td>
<td style="text-align: left;">
<p>Count Leading Zeros</p></td>
<td style="text-align: left;">
<p>16, 32, 64</p></td>
<td style="text-align: left;">
<p>clz</p></td>
<td style="text-align: left;">
<p>input size, sets carry flag</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><a class="uri" href="x86" title="wikilink">x86</a> supporting <a href="Bit_Manipulation_Instruction_Sets#BMI1" title="wikilink">BMI1</a></p></td>
<td style="text-align: left;">
<p>tzcnt<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></p></td>
<td style="text-align: left;">
<p>Count Trailing Zeros</p></td>
<td style="text-align: left;">
<p>16, 32, 64</p></td>
<td style="text-align: left;">
<p>ctz</p></td>
<td style="text-align: left;">
<p>input size, sets carry flag</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><a class="uri" href="Itanium" title="wikilink">Itanium</a></p></td>
<td style="text-align: left;">
<p>clz<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a></p></td>
<td style="text-align: left;">
<p>Count Leading Zeros</p></td>
<td style="text-align: left;">
<p>64</p></td>
<td style="text-align: left;">
<p>clz</p></td>
<td style="text-align: left;">
<p>64</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><a href="MIPS_architecture" title="wikilink">MIPS</a></p></td>
<td style="text-align: left;">
<p>clz<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a><a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a></p></td>
<td style="text-align: left;">
<p>Count Leading Zeros in Word</p></td>
<td style="text-align: left;">
<p>32, 64</p></td>
<td style="text-align: left;">
<p>clz</p></td>
<td style="text-align: left;">
<p>input size</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><a href="MIPS_architecture" title="wikilink">MIPS</a></p></td>
<td style="text-align: left;">
<p>clo<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a><a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a></p></td>
<td style="text-align: left;">
<p>Count Leading Ones in Word</p></td>
<td style="text-align: left;">
<p>32, 64</p></td>
<td style="text-align: left;">
<p>clo</p></td>
<td style="text-align: left;">
<p>input size</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><a href="Motorola_68020" title="wikilink">Motorola 68020</a> and later</p></td>
<td style="text-align: left;">
<p>bfffo<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a></p></td>
<td style="text-align: left;">
<p>Find First One in Bit Field</p></td>
<td style="text-align: left;">
<p>arbitrary</p></td>
<td style="text-align: left;">
<p>log base 2</p></td>
<td style="text-align: left;">
<p>field offset + field width</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><a class="uri" href="PDP-10" title="wikilink">PDP-10</a></p></td>
<td style="text-align: left;">
<p>jffo</p></td>
<td style="text-align: left;">
<p>Jump if Find First One</p></td>
<td style="text-align: left;">
<p>36</p></td>
<td style="text-align: left;">
<p>ctz</p></td>
<td style="text-align: left;">
<p>Do not jump</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><a href="IBM_POWER_Instruction_Set_Architecture" title="wikilink">POWER</a>/<a class="uri" href="PowerPC" title="wikilink">PowerPC</a>/<a href="Power_Architecture" title="wikilink">Power Architecture</a></p></td>
<td style="text-align: left;">
<p>cntlz/cntlzw/cntlzd<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a></p></td>
<td style="text-align: left;">
<p>Count Leading Zeros</p></td>
<td style="text-align: left;">
<p>32, 64</p></td>
<td style="text-align: left;">
<p>clz</p></td>
<td style="text-align: left;">
<p>input size</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><a href="SPARC" title="wikilink">SPARC Oracle Architecture 2011 and later</a></p></td>
<td style="text-align: left;">
<p>lzcnt (synonym: lzd) <a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a></p></td>
<td style="text-align: left;">
<p>Leading Zero Count</p></td>
<td style="text-align: left;">
<p>64</p></td>
<td style="text-align: left;">
<p>clz</p></td>
<td style="text-align: left;">
<p>64</p></td>
</tr>
</tbody>
</table>

<p><strong>Notes:</strong> On some Alpha platforms CTLZ and CTTZ are emulated in software.</p>
<h2 id="tool-and-library-support">Tool and library support</h2>

<p>A number of compiler and library vendors supply compiler intrinsics or library functions to perform find first set and/or related operations, which are frequently implemented in terms of the hardware instructions above:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>Tool/library</p></th>
<th style="text-align: left;">
<p>Name</p></th>
<th style="text-align: left;">
<p>Type</p></th>
<th style="text-align: left;">
<p>Input type(s)</p></th>
<th style="text-align: left;">
<p>Notes</p></th>
<th style="text-align: left;">
<p>Result for zero input</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p><a class="uri" href="POSIX" title="wikilink">POSIX</a>.1 compliant libc<br/>
<a class="uri" href="4.3BSD" title="wikilink">4.3BSD</a> libc<br/>
OS X 10.3 libc<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a><a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a></p></td>
<td style="text-align: left;">
<p><code>ffs</code></p></td>
<td style="text-align: left;">
<p>Library function</p></td>
<td style="text-align: left;">
<p>int</p></td>
<td style="text-align: left;">
<p>Includes <a class="uri" href="glibc" title="wikilink">glibc</a>.<br/>
POSIX does not supply the complementary log base 2 / clz.</p></td>
<td style="text-align: left;">
<p>0</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><a class="uri" href="FreeBSD" title="wikilink">FreeBSD</a> 5.3 libc<br/>
OS X 10.4 libc<a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a></p></td>
<td style="text-align: left;">
<p><code>ffsl<br/>fls, flsl</code></p></td>
<td style="text-align: left;">
<p>Library function</p></td>
<td style="text-align: left;">
<p>int, long</p></td>
<td style="text-align: left;">
<p>fls ("find last set") computes (log base 2) + 1.</p></td>
<td style="text-align: left;">
<p>0</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><a class="uri" href="FreeBSD" title="wikilink">FreeBSD</a> 7.1 libc<a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a></p></td>
<td style="text-align: left;">
<p><code>ffsll, flsll</code></p></td>
<td style="text-align: left;">
<p>Library function</p></td>
<td style="text-align: left;">
<p>long long</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>0</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><a href="GNU_Compiler_Collection" title="wikilink">GCC</a> 3.2.2<a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a><a class="footnoteRef" href="#fn23" id="fnref23"><sup>23</sup></a></p></td>
<td style="text-align: left;">
<p><code>__builtin_ffs</code></p></td>
<td style="text-align: left;">
<p>Built-in functions</p></td>
<td style="text-align: left;">
<p>unsigned int,<br/>
unsigned long,<br/>
unsigned long long</p></td>
<td style="text-align: left;">
<p>Possibly available before 3.2.2.</p></td>
<td style="text-align: left;">
<p>0</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><code>__builtin_ctz</code></p></td>
<td style="text-align: left;">
<p>undefined</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><code>__builtin_clz</code></p></td>
<td style="text-align: left;">
<p>undefined</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><a href="Visual_Studio" title="wikilink">Visual Studio</a> 2005</p></td>
<td style="text-align: left;">
<p><code>_BitScanForward</code><a class="footnoteRef" href="#fn24" id="fnref24"><sup>24</sup></a><br/>
<code>_BitScanReverse</code><a class="footnoteRef" href="#fn25" id="fnref25"><sup>25</sup></a></p></td>
<td style="text-align: left;">
<p>Compiler intrinsics</p></td>
<td style="text-align: left;">
<p>unsigned long,<br/>
unsigned __int64</p></td>
<td style="text-align: left;">
<p>Separate return value to indicate zero input</p></td>
<td style="text-align: left;">
<p>0</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><a href="Visual_Studio" title="wikilink">Visual Studio</a> 2008</p></td>
<td style="text-align: left;">
<p><code>__lzcnt</code><a class="footnoteRef" href="#fn26" id="fnref26"><sup>26</sup></a></p></td>
<td style="text-align: left;">
<p>Compiler intrinsic</p></td>
<td style="text-align: left;">
<p>unsigned short,<br/>
unsigned int,<br/>
unsigned __int64</p></td>
<td style="text-align: left;">
<p>Relies on x64-only lzcnt instruction</p></td>
<td style="text-align: left;">
<p>Input size in bits</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><a href="Intel_C++_Compiler" title="wikilink">Intel C++ Compiler</a></p></td>
<td style="text-align: left;">
<p><code>_bit_scan_forward<br/>_bit_scan_reverse</code><a class="footnoteRef" href="#fn27" id="fnref27"><sup>27</sup></a></p></td>
<td style="text-align: left;">
<p>Compiler intrinsics</p></td>
<td style="text-align: left;">
<p>int</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>undefined</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>NVIDIA <a class="uri" href="CUDA" title="wikilink">CUDA</a><a class="footnoteRef" href="#fn28" id="fnref28"><sup>28</sup></a></p></td>
<td style="text-align: left;">
<p><code>__clz</code></p></td>
<td style="text-align: left;">
<p>Functions</p></td>
<td style="text-align: left;">
<p>32-bit, 64-bit</p></td>
<td style="text-align: left;">
<p>Compiles to fewer instructions on the <a href="GeForce_400_Series" title="wikilink">GeForce 400 Series</a></p></td>
<td style="text-align: left;">
<p>32</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><code>__ffs</code></p></td>
<td style="text-align: left;">
<p>0</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><a class="uri" href="LLVM" title="wikilink">LLVM</a></p></td>
<td style="text-align: left;">
<p><code>llvm.ctlz.*</code><br/>
<code>llvm.cttz.*</code><a class="footnoteRef" href="#fn29" id="fnref29"><sup>29</sup></a></p></td>
<td style="text-align: left;">
<p>Intrinsic</p></td>
<td style="text-align: left;">
<p>8, 16, 32, 64, 256</p></td>
<td style="text-align: left;">
<p>LLVM assembly language</p></td>
<td style="text-align: left;">
<p>Input size if arg 2<br/>
is 0, else undefined</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><a href="Glasgow_Haskell_Compiler" title="wikilink">GHC</a> 7.10 (base 4.8), in <code>Data.Bits</code></p></td>
<td style="text-align: left;">
<p><code>countLeadingZeros, countTrailingZeros</code></p></td>
<td style="text-align: left;">
<p>Library function</p></td>
<td style="text-align: left;">
<p><code>FiniteBits b =&gt; b</code></p></td>
<td style="text-align: left;">
<p>Haskell programming language</p></td>
<td style="text-align: left;">
<p>Input size in bits</p></td>
</tr>
</tbody>
</table>
<h2 id="properties-and-relations">Properties and relations</h2>

<p>The count trailing zeros and find first set operations are related by ctz(x) = ffs(x) − 1 (except for the zero input). Given w bits per word, the log base 2 is easily computed from the clz and vice versa by lg(x) = w − 1 − clz(x).</p>

<p>As demonstrated in the example above, the find first zero, count leading ones, and count trailing ones operations can be implemented by negating the input and using find first set, count leading zeros, and count trailing zeros. The reverse is also true.</p>

<p>On platforms with an efficient log base 2 operation such as M68000, ctz can be computed by:</p>
<dl>
<dd>ctz(x) = lg(x &amp; (−x))
</dd>
</dl>

<p>where "&amp;" denotes bitwise AND and "−x" denotes the negative of x treating x as a signed integer in <a href="twos_complement" title="wikilink">twos complement</a> arithmetic. The expression x &amp; (−x) clears all but the least-significant 1 bit, so that the most- and least-significant 1 bit are the same.</p>

<p>On platforms with an efficient count leading zeros operation such as ARM and PowerPC, ffs can be computed by:</p>
<dl>
<dd>ffs(x) = w − clz(x &amp; (−x)).
</dd>
</dl>

<p>Conversely, clz can be computed using ctz by first rounding up to the nearest power of two using shifts and bitwise ORs,<a class="footnoteRef" href="#fn30" id="fnref30"><sup>30</sup></a> as in this 32-bit example (note that this example depends on ctz returning 32 for the zero input):</p>

<p><strong><code>function</code></strong><code> clz(x):</code><br/>
<code>    </code><strong><code>for</code> <code>each</code></strong><code> y </code><strong><code>in</code></strong><code> {1, 2, 4, 8, 16}: x ← x | (x &gt;&gt; y)</code><br/>
<code>    </code><strong><code>return</code></strong><code> 32 − ctz(x + 1)</code></p>

<p>On platforms with an efficient <a href="Hamming_weight" title="wikilink">Hamming weight</a> (population count) operation such as <a class="uri" href="SPARC" title="wikilink">SPARC</a>'s POPC or <a class="uri" href="Blackfin" title="wikilink">Blackfin</a>'s ONES,<a class="footnoteRef" href="#fn31" id="fnref31"><sup>31</sup></a> ctz can be computed using the identity:<a class="footnoteRef" href="#fn32" id="fnref32"><sup>32</sup></a><a class="footnoteRef" href="#fn33" id="fnref33"><sup>33</sup></a></p>
<dl>
<dd>ctz(x) = pop((x &amp; (−x)) − 1),
</dd>
</dl>

<p>ffs can be computed using:<a class="footnoteRef" href="#fn34" id="fnref34"><sup>34</sup></a></p>
<dl>
<dd>ffs(x) = pop(x ^ (~(−x)))
</dd>
</dl>

<p>where "^" denotes bitwise xor, and clz can be computed by:</p>

<p><strong><code>function</code></strong><code> clz(x):</code><br/>
<code>    </code><strong><code>for</code> <code>each</code></strong><code> y </code><strong><code>in</code></strong><code> {1, 2, 4, 8, 16}: x ← x | (x &gt;&gt; y)</code><br/>
<code>    </code><strong><code>return</code></strong><code> 32 − pop(x)</code></p>

<p>The inverse problem (given i, produce an x such that ctz(x)=i) can be computed with a left-shift (1 n-1] = ffs(i) <strong>for</strong> i <strong>in</strong> 0..2<sup>n</sup>-1</p>

<p><strong><code>function</code></strong><code> ffs_table (x)</code><br/>
<code>    </code><strong><code>if</code></strong><code> x = 0 </code><strong><code>return</code></strong><code> 0</code><br/>
<code>    r ← 0</code><br/>
<code>    </code><strong><code>loop</code></strong><br/>
<code>        </code><strong><code>if</code></strong><code> (x &amp; (2</code><sup><code>n</code></sup><code>-1)) ≠ 0</code><br/>
<code>            </code><strong><code>return</code></strong><code> r + table[x &amp; (2</code><sup><code>n</code></sup><code>-1)]</code><br/>
<code>        x ← x &gt;&gt; n</code><br/>
<code>        r ← r + n</code></p>

<p>The parameter <em>n</em> is fixed (typically 8) and represents a <a href="time-space_tradeoff" title="wikilink">time-space tradeoff</a>. The loop may also be fully <a href="loop_unrolling" title="wikilink">unrolled</a>.</p>
<h3 id="ctz">CTZ</h3>

<p>Count Trailing Zeros (ctz) counts the number of zero bits succeeding the least significant one bit. For example, the ctz of 0x00000F00 is 8, and the ctz of 0x80000000 is 31.</p>

<p>An algorithm for 32-bit ctz by Leiserson, Prokop, and Randall uses <a href="de_Bruijn_sequence" title="wikilink">de Bruijn sequences</a> to construct a <a href="minimal_perfect_hash_function" title="wikilink">minimal perfect hash function</a> that eliminates all branches:<a class="footnoteRef" href="#fn35" id="fnref35"><sup>35</sup></a> <a class="footnoteRef" href="#fn36" id="fnref36"><sup>36</sup></a> This algorithm requires a CPU with a 32-bit multiply instruction with a 64-bit result. The 32-bit multiply instruction in the low-cost <a href="ARM_Cortex-M0" title="wikilink">ARM Cortex-M0</a> / M0+ / M1 cores have a 32-bit result, though other <a href="ARM_architecture" title="wikilink">ARM</a> cores have another multiply instruction with a 64-bit result.<a class="footnoteRef" href="#fn37" id="fnref37"><sup>37</sup></a></p>

<p><code>table[0..31] initialized by: </code><strong><code>for</code></strong><code> i </code><strong><code>from</code></strong><code> 0 </code><strong><code>to</code></strong><code> 31: table[ ( 0x077CB531 * ( 1 </code><code>&gt; 27 ] ← i</code><br/>
<strong><code>function</code></strong><code> ctz_debruijn (x)</code><br/>
<code>    </code><strong><code>return</code></strong><code> table[((x &amp; (-x)) * 0x077CB531) &gt;&gt; 27]</code></p>

<p>The expression (x &amp; (-x)) again isolates the least-significant 1 bit. There are then only 32 possible words, which the unsigned multiplication and shift hash to the correct position in the table. (Note: this algorithm does not handle the zero input.) A similar algorithm works for log base 2, but rather than isolate the most-significant bit, it rounds up to the nearest integer of the form 2<sup><em>n</em></sup>−1 using shifts and bitwise ORs:<a class="footnoteRef" href="#fn38" id="fnref38"><sup>38</sup></a></p>

<p><code>table[0..31] = {0, 9, 1, 10, 13, 21, 2, 29, 11, 14, 16, 18, 22, 25, 3, 30,</code><br/>
<code>                8, 12, 20, 28, 15, 17, 24, 7, 19, 27, 23, 6, 26, 5, 4, 31}</code><br/>
<strong><code>function</code></strong><code> lg_debruijn (x)</code><br/>
<code>    </code><strong><code>for</code> <code>each</code></strong><code> y </code><strong><code>in</code></strong><code> {1, 2, 4, 8, 16}: x ← x | (x &gt;&gt; y)</code><br/>
<code>    </code><strong><code>return</code></strong><code> table[(x * 0x07C4ACDD) &gt;&gt; 27]</code></p>

<p>A <a href="binary_search" title="wikilink">binary search</a> implementation which takes a logarithmic number of operations and branches, as in these 32-bit versions:<a class="footnoteRef" href="#fn39" id="fnref39"><sup>39</sup></a><a class="footnoteRef" href="#fn40" id="fnref40"><sup>40</sup></a> This algorithm can be assisted by a table as well, replacing the bottom three "if" statements with a 256 entry lookup table using the final byte as an index.</p>

<p><strong><code>function</code></strong><code> ctz (x)</code><br/>
<code>    </code><strong><code>if</code></strong><code> x = 0 </code><strong><code>return</code></strong><code> 32</code><br/>
<code>    n ← 0</code><br/>
<code>    </code><strong><code>if</code></strong><code> (x &amp; 0x0000FFFF) = 0: n ← n + 16, x ← x &gt;&gt; 16</code><br/>
<code>    </code><strong><code>if</code></strong><code> (x &amp; 0x000000FF) = 0: n ← n +  8, x ← x &gt;&gt;  8</code><br/>
<code>    </code><strong><code>if</code></strong><code> (x &amp; 0x0000000F) = 0: n ← n +  4, x ← x &gt;&gt;  4</code><br/>
<code>    </code><strong><code>if</code></strong><code> (x &amp; 0x00000003) = 0: n ← n +  2, x ← x &gt;&gt;  2</code><br/>
<code>    </code><strong><code>if</code></strong><code> (x &amp; 0x00000001) = 0: n ← n +  1</code><br/>
<code>    </code><strong><code>return</code></strong><code> n</code></p>
<h3 id="clz">CLZ</h3>

<p>Count Leading Zeros (clz) counts the number of zero bits preceding the most significant one bit. For example, the clz of 0x00000F00 is 20, and the clz of 0x00000001 is 31.</p>

<p>Just as count leading zeros is useful for software <a href="floating_point" title="wikilink">floating point</a> implementations, conversely, on platforms that provide hardware conversion of integers to floating point, the exponent field can be extracted and subtracted from a constant to compute the count of leading zeros. Corrections are needed to account for rounding errors.<a class="footnoteRef" href="#fn41" id="fnref41"><sup>41</sup></a><a class="footnoteRef" href="#fn42" id="fnref42"><sup>42</sup></a></p>

<p>The non-optimized approach examines one bit at a time until a non-zero bit is found, as shown in this <a href="C_(programming_language)" title="wikilink">C language</a> example, and slowest with an input value of 1 because of the many loops it has to perform to find it.</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">int</span> clz1( <span class="dt">uint32_t</span> x )  <span class="co">/* uint32_t is a 32-bit unsigned integer type defined in stdint.h */</span>
{
  <span class="dt">int</span> n;
  <span class="kw">if</span> (x == <span class="dv">0</span>) <span class="kw">return</span> <span class="dv">32</span>;
  <span class="kw">for</span> (n = <span class="dv">0</span>; ((x &amp; <span class="bn">0x80000000</span>) == <span class="dv">0</span>); n++, x &lt;&lt;= <span class="dv">1</span>);
  <span class="kw">return</span> n;
}</code></pre></div>

<p>An evolution of the previous looping approach examines four bits at a time then using a lookup table for the final four bits, which is shown here. A faster looping approach would examine eight bits at a time and increasing to a 256 entry lookup table.</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">static</span> <span class="dt">const</span> <span class="dt">uint8_t</span> clz_table_4bit[<span class="dv">16</span>] = { <span class="dv">4</span>, <span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">2</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span> };
<span class="dt">int</span> clz2( <span class="dt">uint32_t</span> x )
{
  <span class="dt">int</span> n;
  <span class="kw">if</span> (x == <span class="dv">0</span>) <span class="kw">return</span> <span class="dv">32</span>;
  <span class="kw">for</span> (n = <span class="dv">0</span>; ((x &amp; <span class="bn">0xF0000000</span>) == <span class="dv">0</span>); n += <span class="dv">4</span>, x &lt;&lt;= <span class="dv">4</span>);
  n += (<span class="dt">int</span>)clz_table_4bit[x &gt;&gt; (<span class="dv">32-4</span>)];
  <span class="kw">return</span> n;
}</code></pre></div>

<p>Faster than the looping method is a <a href="binary_search" title="wikilink">binary search</a> implementation which takes a logarithmic number of operations and branches, as in these 32-bit versions:<a class="footnoteRef" href="#fn43" id="fnref43"><sup>43</sup></a><a class="footnoteRef" href="#fn44" id="fnref44"><sup>44</sup></a></p>

<p><strong><code>function</code></strong><code> clz3(x)</code><br/>
<code>    </code><strong><code>if</code></strong><code> x = 0 </code><strong><code>return</code></strong><code> 32</code><br/>
<code>    n ← 0</code><br/>
<code>    </code><strong><code>if</code></strong><code> (x &amp; 0xFFFF0000) = 0: n ← n + 16, x ← x </code></p>

<p>/* uint8_t is a 8-bit unsigned integer, uint32_t is a 32-bit unsigned integer, both defined in stdint.h */ static const uint8_t clz_table_4bit[16] = { 4, 3, 2, 2, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0 }; int clz4( uint32_t x ) {</p>

<p><code> int n;</code><br/>
<code> if ((x &amp; 0xFFFF0000) == 0) {n  = 16; x </code><code>&gt; (32-4)];</code><br/>
<code> return n;</code></p>

<p>}</p>

<p>The fastest practical approach to simulate clz uses a precomputed 64KB lookup table, as shown in this <a href="C_(programming_language)" title="wikilink">C language</a> example. Technically, the fastest method is a 4GB lookup table, but obviously it's not practical.</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">static</span> <span class="dt">uint8_t</span> clz_table_16bit[<span class="dv">65536</span>]; <span class="co">/* This table MUST be calculated before calling the function */</span>
<span class="dt">int</span> clz5( <span class="dt">uint32_t</span> x )
{
  <span class="kw">if</span> ((x &amp; <span class="bn">0xFFFF0000</span>) == <span class="dv">0</span>)
    <span class="kw">return</span> (<span class="dt">int</span>)clz_table_16bit[x] + <span class="dv">16</span>;
  <span class="kw">else</span>
    <span class="kw">return</span> (<span class="dt">int</span>)clz_table_16bit[x &gt;&gt; <span class="dv">16</span>];
}</code></pre></div>
<h2 id="applications">Applications</h2>

<p>The count leading zeros (clz) operation can be used to efficiently implement <em>normalization</em>, which encodes an integer as <em>m</em> × 2<sup><em>e</em></sup>, where <em>m</em> has its most significant bit in a known position (such as the highest position). This can in turn be used to implement <a href="Newton-Raphson_division" title="wikilink">Newton-Raphson division</a>, perform integer to <a href="floating_point" title="wikilink">floating point</a> conversion in software, and other applications.<a class="footnoteRef" href="#fn45" id="fnref45"><sup>45</sup></a><a class="footnoteRef" href="#fn46" id="fnref46"><sup>46</sup></a></p>

<p>Count leading zeros (clz) can be used to compute the 32-bit predicate "x = y" (zero if true, one if false) via the identity clz(x − y) &gt;&gt; 5, where "&gt;&gt;" is unsigned right shift.<a class="footnoteRef" href="#fn47" id="fnref47"><sup>47</sup></a> It can be used to perform more sophisticated bit operations like finding the first string of <em>n</em> 1 bits.<a class="footnoteRef" href="#fn48" id="fnref48"><sup>48</sup></a> The expression 16 − clz(x − 1)/2 is an effective initial guess for computing the square root of a 32-bit integer using <a href="Newton's_method" title="wikilink">Newton's method</a>.<a class="footnoteRef" href="#fn49" id="fnref49"><sup>49</sup></a> CLZ can efficiently implement <em>null suppression</em>, a fast <a href="data_compression" title="wikilink">data compression</a> technique that encodes an integer as the number of leading zero bytes together with the nonzero bytes.<a class="footnoteRef" href="#fn50" id="fnref50"><sup>50</sup></a> It can also efficiently generate <a href="exponential_distribution" title="wikilink">exponentially distributed</a> integers by taking the clz of <a href="uniform_distribution_(discrete)" title="wikilink">uniformly random</a> integers.<a class="footnoteRef" href="#fn51" id="fnref51"><sup>51</sup></a></p>

<p>The log base 2 can be used to anticipate whether a multiplication will overflow, since 

<math display="inline" id="Find_first_set:1">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">⌈</mo>
    <mrow>
     <msub>
      <mi>log</mi>
      <mn>2</mn>
     </msub>
     <mrow>
      <mi>x</mi>
      <mi>y</mi>
     </mrow>
    </mrow>
    <mo stretchy="false">⌉</mo>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">⌈</mo>
     <mrow>
      <msub>
       <mi>log</mi>
       <mn>2</mn>
      </msub>
      <mi>x</mi>
     </mrow>
     <mo stretchy="false">⌉</mo>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mo stretchy="false">⌈</mo>
     <mrow>
      <msub>
       <mi>log</mi>
       <mn>2</mn>
      </msub>
      <mi>y</mi>
     </mrow>
     <mo stretchy="false">⌉</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <ceiling></ceiling>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <log></log>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <times></times>
       <ci>x</ci>
       <ci>y</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <ceiling></ceiling>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <log></log>
        <cn type="integer">2</cn>
       </apply>
       <ci>x</ci>
      </apply>
     </apply>
     <apply>
      <ceiling></ceiling>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <log></log>
        <cn type="integer">2</cn>
       </apply>
       <ci>y</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lceil\log_{2}xy\rceil\leq\lceil\log_{2}x\rceil+\lceil\log_{2}y\rceil
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn52" id="fnref52"><sup>52</sup></a></p>

<p>Count leading zeros and count trailing zeros can be used together to implement <a href="Gosper's_loop-detection_algorithm" title="wikilink">Gosper's loop-detection algorithm</a>,<a class="footnoteRef" href="#fn53" id="fnref53"><sup>53</sup></a> which can find the period of a function of finite range using limited resources.<a class="footnoteRef" href="#fn54" id="fnref54"><sup>54</sup></a></p>

<p>A bottleneck in the <a href="binary_GCD_algorithm" title="wikilink">binary GCD algorithm</a> is a loop removing trailing zeros, which can be replaced by a count trailing zeros (ctz) followed by a shift. A similar loop appears in computations of the <a href="hailstone_sequence" title="wikilink">hailstone sequence</a>.</p>

<p>A <a href="bit_array" title="wikilink">bit array</a> can be used to implement a <a href="priority_queue" title="wikilink">priority queue</a>. In this context, find first set (ffs) is useful in implementing the "pop" or "pull highest priority element" operation efficiently. The <a href="Linux_kernel" title="wikilink">Linux kernel</a> real-time scheduler internally uses <code>sched_find_first_bit()</code> for this purpose.<a class="footnoteRef" href="#fn55" id="fnref55"><sup>55</sup></a></p>

<p>The count trailing zeros operation gives a simple optimal solution to the <a href="Tower_of_Hanoi" title="wikilink">Tower of Hanoi</a> problem: the disks are numbered from zero, and at move <em>k</em>, disk number ctz(<em>k</em>) is moved the minimum possible distance to the right (circling back around to the left as needed). It can also generate a <a href="Gray_code" title="wikilink">Gray code</a> by taking an arbitrary word and flipping bit ctz(<em>k</em>) at step <em>k</em>.<a class="footnoteRef" href="#fn56" id="fnref56"><sup>56</sup></a></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Bit_Manipulation_Instruction_Sets" title="wikilink">Bit Manipulation Instruction Sets</a> for Intel and AMD x86-based processors</li>
</ul>
<h2 id="references">References</h2>
<h2 id="further-reading">Further reading</h2>
<ul>
<li></li>
<li></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="https://software.intel.com/sites/landingpage/IntrinsicsGuide/">Intel Intrinsics Guide</a></li>
<li><a href="http://graphics.stanford.edu/~seander/bithacks.html">Bit Twiddling Hacks</a>, Lists several efficient public domain C implementations for <a href="http://graphics.stanford.edu/~seander/bithacks.html#ZerosOnRightLinear">count trailing zeros</a> and <a href="http://graphics.stanford.edu/~seander/bithacks.html#IntegerLogObvious">log base 2</a>.</li>
<li><a href="http://chessprogramming.wikispaces.com/BitScan">Chess Programming Wiki: BitScan</a>: A detailed explanation of a number of implementation methods for ffs (called LS1B) and log base 2 (called MS1B).</li>
</ul>

<p>"</p>

<p><a href="Category:Binary_arithmetic" title="wikilink">Category:Binary arithmetic</a> <a href="Category:Computer_arithmetic" title="wikilink">Category:Computer arithmetic</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><code>Anderson,</code> <a href="http://graphics.stanford.edu/~seander/bithacks.html#IntegerLogObvious"><code>Find</code> <code>the</code> <code>log</code> <code>base</code> <code>2</code> <code>of</code> <code>an</code> <code>integer</code> <code>with</code> <code>the</code> <code>MSB</code> <code>N</code> <code>set</code> <code>in</code> <code>O(N)</code> <code>operations</code> <code>(the</code> <code>obvious</code> <code>way)</code></a><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"></li>
<li id="fn6"> Order number 325383.<a href="#fnref6">↩</a></li>
<li id="fn7"></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
<li id="fn10"><a href="#fnref10">↩</a></li>
<li id="fn11"><a href="#fnref11">↩</a></li>
<li id="fn12"><a href="#fnref12">↩</a></li>
<li id="fn13"></li>
<li id="fn14"></li>
<li id="fn15"><a href="#fnref15">↩</a></li>
<li id="fn16"><a href="#fnref16">↩</a></li>
<li id="fn17"><a href="#fnref17">↩</a></li>
<li id="fn18"></li>
<li id="fn19"><a href="#fnref19">↩</a></li>
<li id="fn20"><a href="#fnref20">↩</a></li>
<li id="fn21"><a href="#fnref21">↩</a></li>
<li id="fn22"><a href="#fnref22">↩</a></li>
<li id="fn23"><a href="#fnref23">↩</a></li>
<li id="fn24"><a href="#fnref24">↩</a></li>
<li id="fn25"><a href="#fnref25">↩</a></li>
<li id="fn26"><a href="#fnref26">↩</a></li>
<li id="fn27"><a href="#fnref27">↩</a></li>
<li id="fn28"><a href="#fnref28">↩</a></li>
<li id="fn29"><a href="#fnref29">↩</a></li>
<li id="fn30">Anderson, <a href="http://graphics.stanford.edu/~seander/bithacks.html#RoundUpPowerOf2">Round up to the next highest power of 2</a>.<a href="#fnref30">↩</a></li>
<li id="fn31"> Part Number 82-000410-14.<a href="#fnref31">↩</a></li>
<li id="fn32"><a href="#fnref32">↩</a></li>
<li id="fn33"><a href="#fnref33">↩</a></li>
<li id="fn34"> A.41: Population Count. Programming Note.<a href="#fnref34">↩</a></li>
<li id="fn35"><a href="#fnref35">↩</a></li>
<li id="fn36"><a href="#fnref36">↩</a></li>
<li id="fn37"><a href="http://infocenter.arm.com/help/topic/com.arm.doc.ddi0432c/DDI0432C_cortex_m0_r0p0_trm.pdf">Cortex-M0 r0p0 Technical Reference Manual; ARM Holdings.</a><a href="#fnref37">↩</a></li>
<li id="fn38">Anderson, <a href="http://graphics.stanford.edu/~seander/bithacks.html#IntegerLogDeBruijn">Find the log base 2 of an N-bit integer in O(lg(N)) operations with multiply and lookup</a><a href="#fnref38">↩</a></li>
<li id="fn39">Warren, Section 5-3: Counting Leading 0's.<a href="#fnref39">↩</a></li>
<li id="fn40">Warren, Section 5-4: Counting Trailing 0's.<a href="#fnref40">↩</a></li>
<li id="fn41"></li>
<li id="fn42">Anderson, <a href="http://graphics.stanford.edu/~seander/bithacks.html#IntegerLogIEEE64Float">Find the integer log base 2 of an integer with an 64-bit IEEE float</a>.<a href="#fnref42">↩</a></li>
<li id="fn43">Warren, Section 5-3: Counting Leading 0's.<a href="#fnref43">↩</a></li>
<li id="fn44">Warren, Section 5-4: Counting Trailing 0's.<a href="#fnref44">↩</a></li>
<li id="fn45"></li>
<li id="fn46"><a href="#fnref46">↩</a></li>
<li id="fn47">Warren, Section 2-11: Comparison Predicates<a href="#fnref47">↩</a></li>
<li id="fn48">Warren, Section 6-2. Find First String of 1-Bits of a Given Length.<a href="#fnref48">↩</a></li>
<li id="fn49">Warren, 11-1: Integer Square Root.<a href="#fnref49">↩</a></li>
<li id="fn50"><a href="#fnref50">↩</a></li>
<li id="fn51"></li>
<li id="fn52">Warren, Section 2-12. Overflow Detection.<a href="#fnref52">↩</a></li>
<li id="fn53"><a href="#fnref53">↩</a></li>
<li id="fn54"></li>
<li id="fn55"><a href="#fnref55">↩</a></li>
<li id="fn56"></li>
</ol>
</section>
</body>

