<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1139">Neural modeling fields</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Neural modeling fields</h1>
<hr/>

<p><strong>Neural modeling field (NMF)</strong> is a mathematical framework for <a href="machine_learning" title="wikilink">machine learning</a> which combines ideas from <a href="neural_networks" title="wikilink">neural networks</a>, <a href="fuzzy_logic" title="wikilink">fuzzy logic</a>, and <a href="model_based_recognition" title="wikilink">model based recognition</a>. It has also been referred to as <strong>modeling fields</strong>, <strong>modeling fields theory</strong> (MFT), <strong>Maximum likelihood artificial neural networks</strong> (MLANS). <a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> <a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> <a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> <a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> <a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> <a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> This framework has been developed by <a href="Leonid_Perlovsky" title="wikilink">Leonid Perlovsky</a> at the <a class="uri" href="AFRL" title="wikilink">AFRL</a>. NMF is interpreted as a mathematical description of mind’s mechanisms, including <a href="concept" title="wikilink">concepts</a>, <a class="uri" href="emotions" title="wikilink">emotions</a>, <a class="uri" href="instincts" title="wikilink">instincts</a>, <a class="uri" href="imagination" title="wikilink">imagination</a>, <a class="uri" href="thinking" title="wikilink">thinking</a>, and <a class="uri" href="understanding" title="wikilink">understanding</a>. NMF is a multi-level, hetero-hierarchical system. At each level in NMF there are concept-models encapsulating the knowledge; they generate so-called top-down signals, interacting with input, bottom-up signals. These interactions are governed by dynamic equations, which drive concept-model learning, adaptation, and formation of new concept-models for better correspondence to the input, bottom-up signals.</p>
<h2 id="concept-models-and-similarity-measures">Concept models and similarity measures</h2>

<p>In the general case, NMF system consists of multiple processing levels. At each level, output signals are the concepts recognized in (or formed from) input, bottom-up signals. Input signals are associated with (or recognized, or grouped into) concepts according to the models and at this level. In the process of learning the concept-models are adapted for better representation of the input signals so that similarity between the concept-models and signals increases. This increase in similarity can be interpreted as satisfaction of an instinct for knowledge, and is felt as <a href="aesthetic_emotions" title="wikilink">aesthetic emotions</a>.</p>

<p>Each hierarchical level consists of N "neurons" enumerated by index n=1,2..N. These neurons receive input, bottom-up signals, <strong>X(n)</strong>, from lower levels in the processing hierarchy. <strong>X</strong>(n) is a field of bottom-up neuronal synaptic activations, coming from neurons at a lower level. Each neuron has a number of synapses; for generality, each neuron activation is described as a set of numbers,</p>

<p>

<math display="block" id="Neural_modeling_fields:0">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mover accent="true">
       <mi>X</mi>
       <mo stretchy="false">→</mo>
      </mover>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>n</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>=</mo>
     <mrow>
      <mo stretchy="false">{</mo>
      <mrow>
       <msub>
        <mi>X</mi>
        <mi>d</mi>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>n</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">}</mo>
     </mrow>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mi>d</mi>
     <mo>=</mo>
     <mrow>
      <mn>1..</mn>
      <mi>D</mi>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <ci>normal-→</ci>
       <ci>X</ci>
      </apply>
      <ci>n</ci>
     </apply>
     <set>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>X</ci>
        <ci>d</ci>
       </apply>
       <ci>n</ci>
      </apply>
     </set>
    </apply>
    <apply>
     <eq></eq>
     <ci>d</ci>
     <apply>
      <times></times>
      <cn type="float">1..</cn>
      <ci>D</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vec{X}(n)=\{X_{d}(n)\},d=1..D.
  </annotation>
 </semantics>
</math>

</p>

<p>,where D is the number or dimensions necessary to describe individual neuron's activation.</p>

<p>Top-down, or priming signals to these neurons are sent by concept-models, <strong>M</strong><sub>m</sub>(<strong>S</strong><sub>m</sub>,n)</p>

<p>

<math display="block" id="Neural_modeling_fields:1">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <msub>
       <mover accent="true">
        <mi>M</mi>
        <mo stretchy="false">→</mo>
       </mover>
       <mi>m</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mover accent="true">
         <mi>S</mi>
         <mo stretchy="false">→</mo>
        </mover>
        <mi>m</mi>
       </msub>
       <mo>,</mo>
       <mi>n</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mi>m</mi>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mn>1..</mn>
     <mi>M</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <list>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <ci>normal-→</ci>
        <ci>M</ci>
       </apply>
       <ci>m</ci>
      </apply>
      <interval closure="open">
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <ci>normal-→</ci>
         <ci>S</ci>
        </apply>
        <ci>m</ci>
       </apply>
       <ci>n</ci>
      </interval>
     </apply>
     <ci>m</ci>
    </list>
    <apply>
     <times></times>
     <cn type="float">1..</cn>
     <ci>M</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vec{M}_{m}(\vec{S}_{m},n),m=1..M.
  </annotation>
 </semantics>
</math>

</p>

<p>,where M is the number of models. Each model is characterized by its parameters, <strong>S<sub>m</sub></strong>; in the neuron structure of the brain they are encoded by strength of synaptic connections, mathematically, they are given by a set of numbers,</p>

<p>

<math display="block" id="Neural_modeling_fields:2">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mover accent="true">
       <mi>S</mi>
       <mo stretchy="false">→</mo>
      </mover>
      <mi>m</mi>
     </msub>
     <mo>=</mo>
     <mrow>
      <mo stretchy="false">{</mo>
      <msubsup>
       <mi>S</mi>
       <mi>m</mi>
       <mi>a</mi>
      </msubsup>
      <mo stretchy="false">}</mo>
     </mrow>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mi>a</mi>
     <mo>=</mo>
     <mrow>
      <mn>1..</mn>
      <mi>A</mi>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <ci>normal-→</ci>
       <ci>S</ci>
      </apply>
      <ci>m</ci>
     </apply>
     <set>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>S</ci>
        <ci>m</ci>
       </apply>
       <ci>a</ci>
      </apply>
     </set>
    </apply>
    <apply>
     <eq></eq>
     <ci>a</ci>
     <apply>
      <times></times>
      <cn type="float">1..</cn>
      <ci>A</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vec{S}_{m}=\{S_{m}^{a}\},a=1..A.
  </annotation>
 </semantics>
</math>

</p>

<p>,where A is the number of dimensions necessary to describe invividual model.</p>

<p>Models represent signals in the following way. Suppose that signal <strong>X(<em>n</em>)</strong> is coming from sensory neurons n activated by object m, which is characterized by parameters <strong>S<sub>m</sub></strong>. These parameters may include position, orientation, or lighting of an object m. Model <strong>M<sub>m</sub></strong>(<strong>S<sub>m</sub></strong>,n) predicts a value <strong>X</strong>(n) of a signal at neuron n. For example, during visual perception, a neuron n in the visual cortex receives a signal <strong>X</strong>(n) from retina and a <a href="Priming_(psychology)" title="wikilink">priming</a> signal <strong>M<sub>m</sub></strong>(<strong>S<sub>m</sub></strong>,n) from an object-concept-model <em>m</em>. Neuron <em>n</em> is activated if both the bottom-up signal from lower-level-input and the top-down priming signal are strong. Various models compete for evidence in the bottom-up signals, while adapting their parameters for better match as described below. This is a simplified description of perception. The most benign everyday visual perception uses many levels from retina to object perception. The NMF premise is that the same laws describe the basic interaction dynamics at each level. Perception of minute features, or everyday objects, or cognition of complex abstract concepts is due to the same mechanism described below. Perception and cognition involve concept-models and learning. In perception, concept-models correspond to objects; in cognition models correspond to relationships and situations.</p>

<p>Learning is an essential part of perception and cognition, and in NMF theory it is driven by the dynamics that increase a similarity measure between the sets of models and signals, L({<strong>X</strong>},{<strong>M</strong>}). The similarity measure is a function of model parameters and associations between the input bottom-up signals and top-down, concept-model signals. In constructing a mathematical description of the similarity measure, it is important to acknowledge two principles:</p>
<dl>
<dd><em>First</em>, the visual field content is unknown before perception occurred
</dd>
<dd><em>Second</em>, it may contain any of a number of objects. Important information could be contained in any bottom-up signal;
</dd>
</dl>

<p>Therefore, the similarity measure is constructed so that it accounts for all bottom-up signals, <em>X</em>(<em>n</em>),</p>

<p>

<math display="block" id="Neural_modeling_fields:3">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>L</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mo stretchy="false">{</mo>
       <mrow>
        <mover accent="true">
         <mi>X</mi>
         <mo stretchy="false">→</mo>
        </mover>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>n</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">}</mo>
      </mrow>
      <mo>,</mo>
      <mrow>
       <mo stretchy="false">{</mo>
       <mrow>
        <msub>
         <mover accent="true">
          <mi>M</mi>
          <mo stretchy="false">→</mo>
         </mover>
         <mi>m</mi>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mover accent="true">
           <mi>S</mi>
           <mo stretchy="false">→</mo>
          </mover>
          <mi>m</mi>
         </msub>
         <mo>,</mo>
         <mi>n</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">}</mo>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∏</mo>
      <mrow>
       <mi>n</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>N</mi>
     </munderover>
     <mrow>
      <mi>l</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mover accent="true">
         <mi>X</mi>
         <mo stretchy="false">→</mo>
        </mover>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>n</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>L</ci>
     <interval closure="open">
      <set>
       <apply>
        <times></times>
        <apply>
         <ci>normal-→</ci>
         <ci>X</ci>
        </apply>
        <ci>n</ci>
       </apply>
      </set>
      <set>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <apply>
          <ci>normal-→</ci>
          <ci>M</ci>
         </apply>
         <ci>m</ci>
        </apply>
        <interval closure="open">
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <apply>
           <ci>normal-→</ci>
           <ci>S</ci>
          </apply>
          <ci>m</ci>
         </apply>
         <ci>n</ci>
        </interval>
       </apply>
      </set>
     </interval>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <csymbol cd="latexml">product</csymbol>
       <apply>
        <eq></eq>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>N</ci>
     </apply>
     <apply>
      <times></times>
      <ci>l</ci>
      <apply>
       <times></times>
       <apply>
        <ci>normal-→</ci>
        <ci>X</ci>
       </apply>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L(\{\vec{X}(n)\},\{\vec{M}_{m}(\vec{S}_{m},n)\})=\prod_{n=1}^{N}{l(\vec{X}(n))}.
  </annotation>
 </semantics>
</math>

    (1)</p>

<p>This expression contains a product of partial similarities, l(<strong>X</strong>(n)), over all bottom-up signals; therefore it forces the NMF system to account for every signal (even if one term in the product is zero, the product is zero, the similarity is low and the knowledge instinct is not satisfied); this is a reflection of the first principle. Second, before perception occurs, the mind does not know which object gave rise to a signal from a particular retinal neuron. Therefore a partial similarity measure is constructed so that it treats each model as an alternative (a sum over concept-models) for each input neuron signal. Its constituent elements are conditional partial similarities between signal <strong>X</strong>(n) and model <strong>M<sub>m</sub></strong>, l(<strong>X</strong>(n)|m). This measure is “conditional” on object m being present, therefore, when combining these quantities into the overall similarity measure, L, they are multiplied by r(m), which represent a probabilistic measure of object m actually being present. Combining these elements with the two principles noted above, a similarity measure is constructed as follows:</p>

<p>

<math display="block" id="Neural_modeling_fields:4">
 <semantics>
  <mrow>
   <mi>L</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mover accent="true">
      <mi>X</mi>
      <mo stretchy="false">→</mo>
     </mover>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">}</mo>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <msub>
      <mover accent="true">
       <mi>M</mi>
       <mo stretchy="false">→</mo>
      </mover>
      <mi>m</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mover accent="true">
        <mi>S</mi>
        <mo stretchy="false">→</mo>
       </mover>
       <mi>m</mi>
      </msub>
      <mo>,</mo>
      <mi>n</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">}</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <munderover>
    <mo largeop="true" movablelimits="false" symmetric="true">∏</mo>
    <mrow>
     <mi>n</mi>
     <mo>=</mo>
     <mn>1</mn>
    </mrow>
    <mi>N</mi>
   </munderover>
   <munderover>
    <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
    <mrow>
     <mi>m</mi>
     <mo>=</mo>
     <mn>1</mn>
    </mrow>
    <mi>M</mi>
   </munderover>
   <mi>r</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>m</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi>l</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mover accent="true">
     <mi>X</mi>
     <mo stretchy="false">→</mo>
    </mover>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">|</mo>
    <mi>m</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">L</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-{</ci>
      <apply>
       <ci>normal-→</ci>
       <ci>X</ci>
      </apply>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">n</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-}</ci>
     </cerror>
     <ci>normal-,</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-{</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <ci>normal-→</ci>
        <ci>M</ci>
       </apply>
       <ci>m</ci>
      </apply>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <ci>normal-→</ci>
         <ci>S</ci>
        </apply>
        <ci>m</ci>
       </apply>
       <ci>normal-,</ci>
       <csymbol cd="unknown">n</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-}</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">product</csymbol>
      <apply>
       <eq></eq>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>N</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <eq></eq>
       <ci>m</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>M</ci>
    </apply>
    <csymbol cd="unknown">r</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">m</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">l</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <ci>normal-→</ci>
      <ci>X</ci>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">n</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-|</ci>
     <csymbol cd="unknown">m</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-.</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L(\{\vec{X}(n)\},\{\vec{M}_{m}(\vec{S}_{m},n)\})=\prod_{n=1}^{N}{\sum_{m=1}^{M%
}{r(m)l(\vec{X}(n)|m)}}.
  </annotation>
 </semantics>
</math>

    (2)</p>

<p>The structure of the expression above follows standard principles of the probability theory: a summation is taken over alternatives, m, and various pieces of evidence, n, are multiplied. This expression is not necessarily a probability, but it has a probabilistic structure. If learning is successful, it approximates probabilistic description and leads to near-optimal Bayesian decisions. The name “conditional partial similarity” for l(<strong>X</strong>(n)|m) (or simply l(n|m)) follows the probabilistic terminology. If learning is successful, l(n|m) becomes a conditional probability density function, a probabilistic measure that signal in neuron n originated from object m. Then L is a total likelihood of observing signals {<strong>X</strong>(n)} coming from objects described by concept-model {<strong>M<sub>m</sub></strong>}. Coefficients r(m), called priors in probability theory, contain preliminary biases or expectations, expected objects m have relatively high r(m) values; their true values are usually unknown and should be learned, like other parameters <strong>S<sub>m</sub></strong>.</p>

<p>Note that in probability theory, a product of probabilities usually assumes that evidence is independent. Expression for L contains a product over n, but it does not assume independence among various signals <strong>X</strong>(n). There is a dependence among signals due to concept-models: each model <strong>M<sub>m</sub></strong>(<strong>S<sub>m</sub></strong>,n) predicts expected signal values in many neurons n.</p>

<p>During the learning process, concept-models are constantly modified. Usually, the functional forms of models, <strong>M<sub>m</sub></strong>(<strong>S<sub>m</sub></strong>,n), are all fixed and learning-adaptation involves only model parameters, <strong>S<sub>m</sub></strong>. From time to time a system forms a new concept, while retaining an old one as well; alternatively, old concepts are sometimes merged or eliminated. This requires a modification of the similarity measure L; The reason is that more models always result in a better fit between the models and data. This is a well known problem, it is addressed by reducing similarity L using a “skeptic penalty function,” (<a href="Penalty_method" title="wikilink">Penalty method</a>) p(N,M) that grows with the number of models M, and this growth is steeper for a smaller amount of data N. For example, an asymptotically unbiased maximum likelihood estimation leads to multiplicative p(N,M) = exp(-N<sub>par</sub>/2), where N<sub>par</sub> is a total number of adaptive parameters in all models (this penalty function is known as <a href="Akaike_information_criterion" title="wikilink">Akaike information criterion</a>, see (Perlovsky 2001) for further discussion and references).</p>
<h2 id="learning-in-nmf-using-dynamic-logic-algorithm">Learning in NMF using dynamic logic algorithm</h2>

<p>The learning process consists of estimating model parameters <strong>S</strong> and associating signals with concepts by maximizing the similarity L. Note that all possible combinations of signals and models are accounted for in expression (2) for L. This can be seen by expanding a sum and multiplying all the terms resulting in M<sup>N</sup> items, a huge number. This is the number of combinations between all signals (N) and all models (M). This is the source of Combinatorial Complexity, which is solved in NMF by utilizing the idea of <a href="Perlovsky" title="wikilink">dynamic logic</a>,.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a><a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> An important aspect of dynamic logic is <em>matching vagueness or fuzziness of similarity measures to the uncertainty of models</em>. Initially, parameter values are not known, and uncertainty of models is high; so is the fuzziness of the similarity measures. In the process of learning, models become more accurate, and the similarity measure more crisp, the value of the similarity increases.</p>

<p>The maximization of similarity L is done as follows. First, the unknown parameters {<strong>S</strong><sub>m</sub>} are randomly initialized. Then the association variables f(m|n) are computed,</p>

<p>

<math display="block" id="Neural_modeling_fields:5">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>m</mi>
    <mo stretchy="false">|</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mi>r</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>m</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>l</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mover accent="true">
       <mi>X</mi>
       <mo stretchy="false">→</mo>
      </mover>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>n</mi>
       <mo stretchy="false">|</mo>
       <mi>m</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <msup>
        <mi>m</mi>
        <mo>′</mo>
       </msup>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>M</mi>
     </msubsup>
     <mi>r</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msup>
       <mi>m</mi>
       <mo>′</mo>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>l</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mover accent="true">
       <mi>X</mi>
       <mo stretchy="false">→</mo>
      </mover>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>n</mi>
       <mo stretchy="false">|</mo>
       <msup>
        <mi>m</mi>
        <mo>′</mo>
       </msup>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">f</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">m</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">n</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <divide></divide>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="unknown">r</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">m</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <csymbol cd="unknown">l</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <apply>
        <ci>normal-→</ci>
        <ci>X</ci>
       </apply>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <csymbol cd="unknown">n</csymbol>
        <ci>normal-|</ci>
        <csymbol cd="unknown">m</csymbol>
        <ci>normal-)</ci>
       </cerror>
       <ci>normal-)</ci>
      </cerror>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>m</ci>
          <ci>normal-′</ci>
         </apply>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>M</ci>
      </apply>
      <csymbol cd="unknown">r</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>m</ci>
        <ci>normal-′</ci>
       </apply>
       <ci>normal-)</ci>
      </cerror>
      <csymbol cd="unknown">l</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <apply>
        <ci>normal-→</ci>
        <ci>X</ci>
       </apply>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <csymbol cd="unknown">n</csymbol>
        <ci>normal-|</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>m</ci>
         <ci>normal-′</ci>
        </apply>
        <ci>normal-)</ci>
       </cerror>
       <ci>normal-)</ci>
      </cerror>
     </cerror>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(m|n)=\frac{r(m)l(\vec{X}(n|m))}{\sum_{m^{\prime}=1}^{M}{r(m^{\prime})l(\vec{%
X}(n|m^{\prime}))}}
  </annotation>
 </semantics>
</math>

    (3).</p>

<p>Equation for f(m|n) looks like the Bayes formula for a posteriori probabilities; if l(n|m) in the result of learning become conditional likelihoods, f(m|n) become Bayesian probabilities for signal n originating from object m. The dynamic logic of the NMF is defined as follows:</p>

<p>

<math display="block" id="Neural_modeling_fields:6">
 <semantics>
  <mrow>
   <mfrac>
    <mrow>
     <mi>d</mi>
     <msub>
      <mover accent="true">
       <mi>S</mi>
       <mo stretchy="false">→</mo>
      </mover>
      <mi>m</mi>
     </msub>
    </mrow>
    <mrow>
     <mi>d</mi>
     <mi>t</mi>
    </mrow>
   </mfrac>
   <mo>=</mo>
   <munderover>
    <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
    <mrow>
     <mi>n</mi>
     <mo>=</mo>
     <mn>1</mn>
    </mrow>
    <mi>N</mi>
   </munderover>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>m</mi>
    <mo stretchy="false">|</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mfrac>
    <mrow>
     <mo>∂</mo>
     <mi>ln</mi>
     <mi>l</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo stretchy="false">|</mo>
      <mi>m</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mrow>
     <mo>∂</mo>
     <msub>
      <mover accent="true">
       <mi>M</mi>
       <mo stretchy="false">→</mo>
      </mover>
      <mi>m</mi>
     </msub>
    </mrow>
   </mfrac>
   <mfrac>
    <mrow>
     <mo>∂</mo>
     <msub>
      <mover accent="true">
       <mi>M</mi>
       <mo stretchy="false">→</mo>
      </mover>
      <mi>m</mi>
     </msub>
    </mrow>
    <mrow>
     <mo>∂</mo>
     <msub>
      <mover accent="true">
       <mi>S</mi>
       <mo stretchy="false">→</mo>
      </mover>
      <mi>m</mi>
     </msub>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <ci>d</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <ci>normal-→</ci>
        <ci>S</ci>
       </apply>
       <ci>m</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>d</ci>
      <ci>t</ci>
     </apply>
    </apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <eq></eq>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>N</ci>
    </apply>
    <csymbol cd="unknown">f</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">m</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">n</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <apply>
     <divide></divide>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <partialdiff></partialdiff>
      <ln></ln>
      <csymbol cd="unknown">l</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">n</csymbol>
       <ci>normal-|</ci>
       <csymbol cd="unknown">m</csymbol>
       <ci>normal-)</ci>
      </cerror>
     </cerror>
     <apply>
      <partialdiff></partialdiff>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <ci>normal-→</ci>
        <ci>M</ci>
       </apply>
       <ci>m</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <partialdiff></partialdiff>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <ci>normal-→</ci>
        <ci>M</ci>
       </apply>
       <ci>m</ci>
      </apply>
     </apply>
     <apply>
      <partialdiff></partialdiff>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <ci>normal-→</ci>
        <ci>S</ci>
       </apply>
       <ci>m</ci>
      </apply>
     </apply>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{d\vec{S}_{m}}{dt}=\sum_{n=1}^{N}{f(m|n)\frac{\partial{\ln l(n|m)}}{%
\partial{\vec{M}_{m}}}\frac{\partial{\vec{M}_{m}}}{\partial{\vec{S}_{m}}}}
  </annotation>
 </semantics>
</math>

    (4).</p>

<p>

<math display="block" id="Neural_modeling_fields:7">
 <semantics>
  <mrow>
   <mfrac>
    <mrow>
     <mi>d</mi>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>m</mi>
      <mo stretchy="false">|</mo>
      <mi>n</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mrow>
     <mi>d</mi>
     <mi>t</mi>
    </mrow>
   </mfrac>
   <mo>=</mo>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>m</mi>
    <mo stretchy="false">|</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <munderover>
    <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
    <mrow>
     <msup>
      <mi>m</mi>
      <mo>′</mo>
     </msup>
     <mo>=</mo>
     <mn>1</mn>
    </mrow>
    <mi>M</mi>
   </munderover>
   <mrow>
    <mo stretchy="false">[</mo>
    <msub>
     <mi>δ</mi>
     <mrow>
      <mi>m</mi>
      <msup>
       <mi>m</mi>
       <mo>′</mo>
      </msup>
     </mrow>
    </msub>
    <mo>-</mo>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>m</mi>
      <mo>′</mo>
     </msup>
     <mo stretchy="false">|</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
   <mfrac>
    <mrow>
     <mo>∂</mo>
     <mi>ln</mi>
     <mi>l</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo stretchy="false">|</mo>
      <msup>
       <mi>m</mi>
       <mo>′</mo>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mrow>
     <mo>∂</mo>
     <msub>
      <mover accent="true">
       <mi>M</mi>
       <mo stretchy="false">→</mo>
      </mover>
      <msup>
       <mi>m</mi>
       <mo>′</mo>
      </msup>
     </msub>
    </mrow>
   </mfrac>
   <mfrac>
    <mrow>
     <mo>∂</mo>
     <msub>
      <mover accent="true">
       <mi>M</mi>
       <mo stretchy="false">→</mo>
      </mover>
      <msup>
       <mi>m</mi>
       <mo>′</mo>
      </msup>
     </msub>
    </mrow>
    <mrow>
     <mo>∂</mo>
     <msub>
      <mover accent="true">
       <mi>S</mi>
       <mo stretchy="false">→</mo>
      </mover>
      <msup>
       <mi>m</mi>
       <mo>′</mo>
      </msup>
     </msub>
    </mrow>
   </mfrac>
   <mfrac>
    <mrow>
     <mi>d</mi>
     <msub>
      <mover accent="true">
       <mi>S</mi>
       <mo stretchy="false">→</mo>
      </mover>
      <msup>
       <mi>m</mi>
       <mo>′</mo>
      </msup>
     </msub>
    </mrow>
    <mrow>
     <mi>d</mi>
     <mi>t</mi>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <divide></divide>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="unknown">d</csymbol>
      <csymbol cd="unknown">f</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">m</csymbol>
       <ci>normal-|</ci>
       <csymbol cd="unknown">n</csymbol>
       <ci>normal-)</ci>
      </cerror>
     </cerror>
     <apply>
      <times></times>
      <ci>d</ci>
      <ci>t</ci>
     </apply>
    </apply>
    <eq></eq>
    <csymbol cd="unknown">f</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">m</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">n</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <eq></eq>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>m</ci>
        <ci>normal-′</ci>
       </apply>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>M</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>δ</ci>
      <apply>
       <times></times>
       <ci>m</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>m</ci>
        <ci>normal-′</ci>
       </apply>
      </apply>
     </apply>
     <minus></minus>
     <csymbol cd="unknown">f</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>m</ci>
       <ci>normal-′</ci>
      </apply>
      <ci>normal-|</ci>
      <csymbol cd="unknown">n</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-]</ci>
    </cerror>
    <apply>
     <divide></divide>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <partialdiff></partialdiff>
      <ln></ln>
      <csymbol cd="unknown">l</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">n</csymbol>
       <ci>normal-|</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>m</ci>
        <ci>normal-′</ci>
       </apply>
       <ci>normal-)</ci>
      </cerror>
     </cerror>
     <apply>
      <partialdiff></partialdiff>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <ci>normal-→</ci>
        <ci>M</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>m</ci>
        <ci>normal-′</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <partialdiff></partialdiff>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <ci>normal-→</ci>
        <ci>M</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>m</ci>
        <ci>normal-′</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <partialdiff></partialdiff>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <ci>normal-→</ci>
        <ci>S</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>m</ci>
        <ci>normal-′</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <ci>d</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <ci>normal-→</ci>
        <ci>S</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>m</ci>
        <ci>normal-′</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>d</ci>
      <ci>t</ci>
     </apply>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{df(m|n)}{dt}=f(m|n)\sum_{m^{\prime}=1}^{M}{[\delta_{mm^{\prime}}-f(m^{%
\prime}|n)]\frac{\partial{\ln l(n|m^{\prime})}}{\partial{\vec{M}_{m^{\prime}}}%
}}\frac{\partial{\vec{M}_{m^{\prime}}}}{\partial{\vec{S}_{m^{\prime}}}}\frac{d%
\vec{S}_{m^{\prime}}}{dt}
  </annotation>
 </semantics>
</math>

    (5)</p>

<p>The following theorem has been proved (Perlovsky 2001):</p>

<p><em>Theorem</em>. Equations (3), (4), and (5) define a convergent dynamic NMF system with stationary states defined by max{S<sub>m</sub>}L.</p>

<p>It follows that the stationary states of an MF system are the maximum similarity states. When partial similarities are specified as probability density functions (pdf), or likelihoods, the stationary values of parameters {<strong>S</strong><sub>m</sub>} are asymptotically unbiased and efficient estimates of these parameters.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> The computational complexity of dynamic logic is linear in N.</p>

<p>Practically, when solving the equations through successive iterations, f(m|n) can be recomputed at every iteration using (3), as opposed to incremental formula (5).</p>

<p>The proof of the above theorem contains a proof that similarity L increases at each iteration. This has a psychological interpretation that the instinct for increasing knowledge is satisfied at each step, resulting in the positive emotions: NMF-dynamic logic system emotionally enjoys learning.</p>
<h2 id="example-of-dynamic-logic-operations">Example of dynamic logic operations</h2>

<p>Finding patterns below noise can be an exceedingly complex problem. If an exact pattern shape is not known and depends on unknown parameters, these parameters should be found by fitting the pattern model to the data. However, when the locations and orientations of patterns are not known, it is not clear which subset of the data points should be selected for fitting. A standard approach for solving this kind of problem is multiple hypothesis testing (Singer et al. 1974). Since all combinations of subsets and models are exhaustively searched, this method faces the problem of combinatorial complexity. In the current example, noisy ‘smile’ and ‘frown’ patterns are sought. They are shown in Fig.1a without noise, and in Fig.1b with the noise, as actually measured. The true number of patterns is 3, which is not known. Therefore, at least 4 patterns should be fit to the data, to decide that 3 patterns fit best. The image size in this example is 100x100 = 10,000 points. If one attempts to fit 4 models to all subsets of 10,000 data points, computation of complexity, M<sup>N</sup> ~ 10<sup>6000</sup>. An alternative computation by searching through the parameter space, yields lower complexity: each pattern is characterized by a 3-parameter parabolic shape. Fitting 4x3=12 parameters to 100x100 grid by a brute-force testing would take about 10<sup>32</sup> to 10<sup>40</sup> operations, still a prohibitive computational complexity. To apply NMF and dynamic logic to this problem one needs to develop parametric adaptive models of expected patterns. The models and conditional partial similarities for this case are described in details in:<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> a uniform model for noise, Gaussian blobs for highly-fuzzy, poorly resolved patterns, and parabolic models for ‘smiles’ and ‘frowns’. The number of computer operations in this example was about 10<sup>10</sup>. Thus, a problem that was not solvable due to combinatorial complexity becomes solvable using dynamic logic.</p>

<p>During an adaptation process, initially fuzzy and uncertain models are associated with structures in the input signals, and fuzzy models become more definite and crisp with successive iterations. The type, shape, and number, of models are selected so that the internal representation within the system is similar to input signals: the NMF concept-models represent structure-objects in the signals. The figure below illustrates operations of dynamic logic. In Fig. 1(a) true ‘smile’ and ‘frown’ patterns are shown without noise; (b) actual image available for recognition (signal is below noise, signal-to-noise ratio is between –2dB and –0.7dB); (c) an initial fuzzy model, a large fuzziness corresponds to uncertainty of knowledge; (d) through (m) show improved models at various iteration stages (total of 22 iterations). Every five iterations the algorithm tried to increase or decrease the number of models. Between iterations (d) and (e) the algorithm decided, that it needs three Gaussian models for the ‘best’ fit.</p>

<p>There are several types of models: one uniform model describing noise (it is not shown) and a variable number of blob models and parabolic models; their number, location, and curvature are estimated from the data. Until about stage (g) the algorithm used simple blob models, at (g) and beyond, the algorithm decided that it needs more complex parabolic models to describe the data. Iterations stopped at (h), when similarity stopped increasing.</p>

<p><a href="File:ExampleOfApplicationOfDynamicLogicToNoisyImage.JPG" title="wikilink">center |frame| Fig.1. Finding ‘smile’ and ‘frown’ patterns in noise, an example of dynamic logic operation: (a) true ‘smile’ and ‘frown’ patterns are shown without noise; (b) actual image available for recognition (signal is below noise, signal-to-noise ratio is between –2dB and –0.7dB); (c) an initial fuzzy blob-model, the fuzziness corresponds to uncertainty of knowledge; (d) through (m) show improved models at various iteration stages (total of 22 iterations). Between stages (d) and (e) the algorithm tried to fit the data with more than one model and decided, that it needs three blob-models to ‘understand’ the content of the data. There are several types of models: one uniform model describing noise (it is not shown) and a variable number of blob-models and parabolic models, which number, location, and curvature are estimated from the data. Until about stage (g) the algorithm ‘thought’ in terms of simple blob models, at (g) and beyond, the algorithm decided that it needs more complex parabolic models to describe the data. Iterations stopped at (m), when similarity L stopped increasing. This example is discussed in more details in (Linnehan et al. 2003).</a></p>
<h2 id="neural-modeling-fields-hierarchical-organization">Neural modeling fields hierarchical organization</h2>

<p>Above, a single processing level in a hierarchical NMF system was described. At each level of hierarchy there are input signals from lower levels, models, similarity measures (L), emotions, which are defined as changes in similarity, and actions; actions include adaptation, behavior satisfying the knowledge instinct – maximization of similarity. An input to each level is a set of signals <strong>X</strong>(n), or in neural terminology, an input field of neuronal activations. The result of signal processing at a given level are activated models, or concepts m recognized in the input signals n; these models along with the corresponding instinctual signals and emotions may activate behavioral models and generate behavior at this level.</p>

<p>The activated models initiate other actions. They serve as input signals to the next processing level, where more general concept-models are recognized or created. Output signals from a given level, serving as input to the next level, are the model activation signals, a<sub>m</sub>, defined as</p>

<p>a<sub>m</sub> = ∑<sub>n=1..N</sub> f(m|n).</p>

<p>The hierarchical NMF system is illustrated in Fig. 2. Within the hierarchy of the mind, each concept-model finds its “mental” meaning and purpose at a higher level (in addition to other purposes). For example, consider a concept-model “chair.” It has a “behavioral” purpose of initiating sitting behavior (if sitting is required by the body), this is the “bodily” purpose at the same hierarchical level. In addition, it has a “purely mental” purpose at a higher level in the hierarchy, a purpose of helping to recognize a more general concept, say of a “concert hall,” a model of which contains rows of chairs.</p>

<p><a href="File:NMF_Hierarchy.JPG" title="wikilink">center |frame| Fig.2. Hierarchical NMF system. At each level of a hierarchy there are models, similarity measures, and actions (including adaptation, maximizing the knowledge instinct - similarity). High levels of partial similarity measures correspond to concepts recognized at a given level. Concept activations are output signals at this level and they become input signals to the next level, propagating knowledge up the hierarchy.</a></p>

<p>From time to time a system forms a new concept or eliminates an old one. At every level, the NMF system always keeps a reserve of vague (fuzzy) inactive concept-models. They are inactive in that their parameters are not adapted to the data; therefore their similarities to signals are low. Yet, because of a large vagueness (covariance) the similarities are not exactly zero. When a new signal does not fit well into any of the active models, its similarities to inactive models automatically increase (because first, every piece of data is accounted for, and second, inactive models are vague-fuzzy and potentially can “grab” every signal that does not fit into more specific, less fuzzy, active models. When the activation signal a<sub>m</sub> for an inactive model, m, exceeds a certain threshold, the model is activated. Similarly, when an activation signal for a particular model falls below a threshold, the model is deactivated. Thresholds for activation and deactivation are set usually based on information existing at a higher hierarchical level (prior information, system resources, numbers of activated models of various types, etc.). Activation signals for active models at a particular level { a<sub>m</sub> } form a “neuronal field,” which serve as input signals to the next level, where more abstract and more general concepts are formed.</p>
<h2 id="references">References</h2>
<h2 id="related">Related</h2>
<ul>
<li><a href="Leonid_Perlovsky" title="wikilink">Leonid Perlovsky</a></li>
</ul>

<p>"</p>

<p><a href="Category:Artificial_intelligence" title="wikilink">Category:Artificial intelligence</a> <a href="Category:Machine_learning" title="wikilink">Category:Machine learning</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">[<a class="uri" href="http://www.oup.com/us/catalog/he/subject/Engineering/ElectricalandComputerEngineering/ComputerEngineering/NeuralNetworks/?view=usa&amp;ci">http://www.oup.com/us/catalog/he/subject/Engineering/ElectricalandComputerEngineering/ComputerEngineering/NeuralNetworks/?view=usa&amp;ci;</a>;=9780195111620]: Perlovsky, L.I. 2001. Neural Networks and Intellect: using model based concepts. New York: Oxford University Press<a href="#fnref1">↩</a></li>
<li id="fn2">Perlovsky, L.I. (2006). Toward Physics of the Mind: Concepts, Emotions, Consciousness, and Symbols. Phys. Life Rev. 3(1), pp.22-55.<a href="#fnref2">↩</a></li>
<li id="fn3">[<a class="uri" href="http://ieeexplore.ieee.org/xpl/absprintf.jsp?arnumber=713700&amp;page">http://ieeexplore.ieee.org/xpl/absprintf.jsp?arnumber=713700&amp;page;</a>;=FREE]: Deming, R.W., Automatic buried mine detection using the maximum likelihoodadaptive neural system (MLANS), in Proceedings of <em>Intelligent Control (ISIC)</em>, 1998. Held jointly with <em>IEEE International Symposium on Computational Intelligence in Robotics and Automation (CIRA), Intelligent Systems and Semiotics (ISAS)</em><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="http://www.mdatechnology.net/techprofile.aspx?id=227"></a>: MDA Technology Applications Program web site<a href="#fnref4">↩</a></li>
<li id="fn5"><a href="http://ieeexplore.ieee.org/search/wrapper.jsp?arnumber=4274797">1</a>: Cangelosi, A.; Tikhanoff, V.; Fontanari, J.F.; Hourdakis, E., Integrating Language and Cognition: A Cognitive Robotics Approach, Computational Intelligence Magazine, IEEE, Volume 2, Issue 3, Aug. 2007 Page(s):65 - 70<a href="#fnref5">↩</a></li>
<li id="fn6">[<a class="uri" href="http://spie.org/x648.xml?product_id=521387&amp;showAbstracts">http://spie.org/x648.xml?product_id=521387&amp;showAbstracts;</a>;=true&amp;origin;_id=x648]: Sensors, and Command, Control, Communications, and Intelligence (C3I) Technologies for Homeland Security and Homeland Defense III (Proceedings Volume),Editor(s): Edward M. Carapezza, Date: 15 September 2004,ISBN 978-0-8194-5326-6, See Chapter: <em>Counter-terrorism threat prediction architecture</em><a href="#fnref6">↩</a></li>
<li id="fn7">Perlovsky, L.I. (1996). Mathematical Concepts of Intellect. Proc. World Congress on Neural Networks, San Diego, CA; Lawrence Erlbaum Associates, NJ, pp.1013-16<a href="#fnref7">↩</a></li>
<li id="fn8">Perlovsky, L.I.(1997). Physical Concepts of Intellect. Proc. Russian Academy of Sciences, 354(3), pp. 320-323.<a href="#fnref8">↩</a></li>
<li id="fn9">Cramer, H. (1946). Mathematical Methods of Statistics, Princeton University Press, Princeton NJ.<a href="#fnref9">↩</a></li>
<li id="fn10">Linnehan, R., Mutz, Perlovsky, L.I., C., Weijers, B., Schindler, J., Brockett, R. (2003). Detection of Patterns Below Clutter in Images. Int. Conf. On Integration of Knowledge Intensive Multi-Agent Systems, Cambridge, MA Oct.1-3, 2003.<a href="#fnref10">↩</a></li>
</ol>
</section>
</body>
</html>
