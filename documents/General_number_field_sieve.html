<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="434">General number field sieve</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>General number field sieve</h1>
<hr/>

<p>In <a href="number_theory" title="wikilink">number theory</a>, the <strong>general number field sieve</strong> (<strong>GNFS</strong>) is the most <a href="algorithmic_efficiency" title="wikilink">efficient</a> classical <a class="uri" href="algorithm" title="wikilink">algorithm</a> known for <a href="integer_factorization" title="wikilink">factoring integers</a> larger than 100 digits. <a href="Heuristic" title="wikilink">Heuristically</a>, its <a href="Computational_complexity_theory" title="wikilink">complexity</a> for factoring an integer 

<math display="inline" id="General_number_field_sieve:0">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 (consisting of 

<math display="inline" id="General_number_field_sieve:1">
 <semantics>
  <mrow>
   <mrow>
    <mo>‚åä</mo>
    <mrow>
     <msub>
      <mi>log</mi>
      <mn>2</mn>
     </msub>
     <mi>n</mi>
    </mrow>
    <mo>‚åã</mo>
   </mrow>
   <mo>+</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <floor></floor>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <log></log>
       <cn type="integer">2</cn>
      </apply>
      <ci>n</ci>
     </apply>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left\lfloor\log_{2}n\right\rfloor+1
  </annotation>
 </semantics>
</math>

 bits) is of the form</p>

<p>

<math display="block" id="General_number_field_sieve:2">
 <semantics>
  <mrow>
   <mrow>
    <mi>exp</mi>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mrow>
       <mo>(</mo>
       <mrow>
        <mroot>
         <mfrac>
          <mn>64</mn>
          <mn>9</mn>
         </mfrac>
         <mn>3</mn>
        </mroot>
        <mo>+</mo>
        <mrow>
         <mi>o</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mn>1</mn>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
       <mo>)</mo>
      </mrow>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>ln</mi>
         <mi>n</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mfrac>
        <mn>1</mn>
        <mn>3</mn>
       </mfrac>
      </msup>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>ln</mi>
         <mrow>
          <mi>ln</mi>
          <mi>n</mi>
         </mrow>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mfrac>
        <mn>2</mn>
        <mn>3</mn>
       </mfrac>
      </msup>
     </mrow>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>L</mi>
     <mi>n</mi>
    </msub>
    <mrow>
     <mo>[</mo>
     <mfrac>
      <mn>1</mn>
      <mn>3</mn>
     </mfrac>
     <mo>,</mo>
     <mroot>
      <mfrac>
       <mn>64</mn>
       <mn>9</mn>
      </mfrac>
      <mn>3</mn>
     </mroot>
     <mo>]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <exp></exp>
     <apply>
      <times></times>
      <apply>
       <plus></plus>
       <apply>
        <root></root>
        <degree>
         <cn type="integer">3</cn>
        </degree>
        <apply>
         <divide></divide>
         <cn type="integer">64</cn>
         <cn type="integer">9</cn>
        </apply>
       </apply>
       <apply>
        <times></times>
        <ci>o</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <ln></ln>
        <ci>n</ci>
       </apply>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <cn type="integer">3</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <ln></ln>
        <apply>
         <ln></ln>
         <ci>n</ci>
        </apply>
       </apply>
       <apply>
        <divide></divide>
        <cn type="integer">2</cn>
        <cn type="integer">3</cn>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>L</ci>
      <ci>n</ci>
     </apply>
     <interval closure="closed">
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <cn type="integer">3</cn>
      </apply>
      <apply>
       <root></root>
       <degree>
        <cn type="integer">3</cn>
       </degree>
       <apply>
        <divide></divide>
        <cn type="integer">64</cn>
        <cn type="integer">9</cn>
       </apply>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \exp\left(\left(\sqrt[3]{\frac{64}{9}}+o(1)\right)(\ln n)^{\frac{1}{3}}(\ln\ln
n%
)^{\frac{2}{3}}\right)=L_{n}\left[\frac{1}{3},\sqrt[3]{\frac{64}{9}}\right]
  </annotation>
 </semantics>
</math>

</p>

<p>(in <a class="uri" href="L-notation" title="wikilink">L-notation</a>), where 

<math display="inline" id="General_number_field_sieve:3">
 <semantics>
  <mrow>
   <mi>l</mi>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>l</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ln
  </annotation>
 </semantics>
</math>

 is the <a href="natural_logarithm" title="wikilink">natural logarithm</a>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> It is a generalization of the <a href="special_number_field_sieve" title="wikilink">special number field sieve</a>: while the latter can only factor numbers of a certain special form, the general number field sieve can factor any number apart from <a href="prime_power" title="wikilink">prime powers</a> (which are trivial to factor by taking roots). When the term <strong>number field sieve</strong> (<strong>NFS</strong>) is used without qualification, it refers to the general number field sieve.</p>

<p>The principle of the number field sieve (both special and general) can be understood as an improvement to the simpler <a href="rational_sieve" title="wikilink">rational sieve</a> or <a href="quadratic_sieve" title="wikilink">quadratic sieve</a>. When using such algorithms to factor a large number 

<math display="inline" id="General_number_field_sieve:4">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

, it is necessary to search for <a href="smooth_number" title="wikilink">smooth numbers</a> (i.e. numbers with small prime factors) of order <mtpl></mtpl>. The size of these values is exponential in the size of 

<math display="inline" id="General_number_field_sieve:5">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 (see below). The general number field sieve, on the other hand, manages to search for smooth numbers that are subexponential in the size of 

<math display="inline" id="General_number_field_sieve:6">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

. Since these numbers are smaller, they are more likely to be smooth than the numbers inspected in previous algorithms. This is the key to the efficiency of the number field sieve. In order to achieve this speed-up, the number field sieve has to perform computations and factorizations in <a href="number_field" title="wikilink">number fields</a>. This results in many rather complicated aspects of the algorithm, as compared to the simpler rational sieve.</p>

<p>Note that <mtpl></mtpl> is the number of bits in the binary representation of 

<math display="inline" id="General_number_field_sieve:7">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

, that is the size of the input to the algorithm, so any element of the order <mtpl></mtpl> for a constant 

<math display="inline" id="General_number_field_sieve:8">
 <semantics>
  <mi>c</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>c</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c
  </annotation>
 </semantics>
</math>

 is exponential in 

<math display="inline" id="General_number_field_sieve:9">
 <semantics>
  <mrow>
   <mi>l</mi>
   <mi>o</mi>
   <mi>g</mi>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>l</ci>
    <ci>o</ci>
    <ci>g</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   logn
  </annotation>
 </semantics>
</math>

. The running time of the number field sieve is super-polynomial but sub-exponential in the size of the input.</p>
<h2 id="number-fields">Number fields</h2>

<p>Suppose 

<math display="inline" id="General_number_field_sieve:10">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 is a 

<math display="inline" id="General_number_field_sieve:11">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

-degree polynomial over 

<math display="inline" id="General_number_field_sieve:12">
 <semantics>
  <mi>ùêê</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ùêê</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{Q}
  </annotation>
 </semantics>
</math>

 (the rational numbers), and 

<math display="inline" id="General_number_field_sieve:13">
 <semantics>
  <mi>r</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>r</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r
  </annotation>
 </semantics>
</math>

 is a complex root of 

<math display="inline" id="General_number_field_sieve:14">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

. Then, 

<math display="inline" id="General_number_field_sieve:15">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>r</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>r</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(r)=0
  </annotation>
 </semantics>
</math>

, which can be rearranged to express <mtpl></mtpl> as a linear combination of powers of 

<math display="inline" id="General_number_field_sieve:16">
 <semantics>
  <mi>r</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>r</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r
  </annotation>
 </semantics>
</math>

 less than 

<math display="inline" id="General_number_field_sieve:17">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

. This equation can be used to reduce away any powers of 

<math display="inline" id="General_number_field_sieve:18">
 <semantics>
  <mrow>
   <mi>r</mi>
   <mi mathvariant="normal">‚â•</mi>
   <mi>k</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>r</ci>
    <ci>normal-‚â•</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r‚â•k
  </annotation>
 </semantics>
</math>

. For example, if <mtpl>¬†<em>x</em><sup>2</sup>¬†+¬†1}}</mtpl> and 

<math display="inline" id="General_number_field_sieve:19">
 <semantics>
  <mi>r</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>r</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r
  </annotation>
 </semantics>
</math>

 is the imaginary unit 

<math display="inline" id="General_number_field_sieve:20">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

, then <mtpl>0}}</mtpl>, or <mtpl>¬†‚àí1}}</mtpl>. This allows us to define the complex product:</p>

<p>

<math display="block" id="General_number_field_sieve:21">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>a</mi>
       <mo>+</mo>
       <mrow>
        <mi>b</mi>
        <mi>i</mi>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>c</mi>
       <mo>+</mo>
       <mrow>
        <mi>d</mi>
        <mi>i</mi>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mi>a</mi>
      <mi>c</mi>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mrow>
         <mi>a</mi>
         <mi>d</mi>
        </mrow>
        <mo>+</mo>
        <mrow>
         <mi>b</mi>
         <mi>c</mi>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>i</mi>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>b</mi>
        <mi>d</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <msup>
       <mi>i</mi>
       <mn>2</mn>
      </msup>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <mi>a</mi>
        <mi>c</mi>
       </mrow>
       <mo>-</mo>
       <mrow>
        <mi>b</mi>
        <mi>d</mi>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mrow>
         <mi>a</mi>
         <mi>d</mi>
        </mrow>
        <mo>+</mo>
        <mrow>
         <mi>b</mi>
         <mi>c</mi>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>i</mi>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <plus></plus>
       <ci>a</ci>
       <apply>
        <times></times>
        <ci>b</ci>
        <ci>i</ci>
       </apply>
      </apply>
      <apply>
       <plus></plus>
       <ci>c</ci>
       <apply>
        <times></times>
        <ci>d</ci>
        <ci>i</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>a</ci>
       <ci>c</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <plus></plus>
        <apply>
         <times></times>
         <ci>a</ci>
         <ci>d</ci>
        </apply>
        <apply>
         <times></times>
         <ci>b</ci>
         <ci>c</ci>
        </apply>
       </apply>
       <ci>i</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <times></times>
        <ci>b</ci>
        <ci>d</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>i</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <plus></plus>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <ci>a</ci>
        <ci>c</ci>
       </apply>
       <apply>
        <times></times>
        <ci>b</ci>
        <ci>d</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <plus></plus>
        <apply>
         <times></times>
         <ci>a</ci>
         <ci>d</ci>
        </apply>
        <apply>
         <times></times>
         <ci>b</ci>
         <ci>c</ci>
        </apply>
       </apply>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (a+bi)(c+di)=ac+(ad+bc)i+(bd)i^{2}=(ac-bd)+(ad+bc)i.
  </annotation>
 </semantics>
</math>

 In general, this leads directly to the <a href="algebraic_number_field" title="wikilink">algebraic number field</a> 

<math display="inline" id="General_number_field_sieve:22">
 <semantics>
  <mrow>
   <mi>ùêê</mi>
   <mi>r</mi>
   <mi>r</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>ùêê</ci>
    <ci>r</ci>
    <ci>r</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{Q}rr
  </annotation>
 </semantics>
</math>

, which can be defined as the set of real numbers given by:</p>

<p>

<math display="block" id="General_number_field_sieve:23">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <msub>
       <mi>a</mi>
       <mrow>
        <mi>k</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msub>
      <msup>
       <mi>r</mi>
       <mrow>
        <mi>k</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msup>
     </mrow>
     <mo>+</mo>
     <mi mathvariant="normal">‚Ä¶</mi>
     <mo>+</mo>
     <mrow>
      <msub>
       <mi>a</mi>
       <mn>1</mn>
      </msub>
      <msup>
       <mi>r</mi>
       <mn>1</mn>
      </msup>
     </mrow>
     <mo>+</mo>
     <mrow>
      <msub>
       <mi>a</mi>
       <mn>0</mn>
      </msub>
      <msup>
       <mi>r</mi>
       <mn>0</mn>
      </msup>
     </mrow>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mtext>where</mtext>
     <msub>
      <mi>a</mi>
      <mn>0</mn>
     </msub>
    </mrow>
    <mo>,</mo>
    <mi mathvariant="normal">‚Ä¶</mi>
    <mo>,</mo>
    <mrow>
     <msub>
      <mi>a</mi>
      <mrow>
       <mi>k</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msub>
     <mtext>in</mtext>
     <mi>‚Ñö</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <apply>
        <minus></minus>
        <ci>k</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>r</ci>
       <apply>
        <minus></minus>
        <ci>k</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
     <ci>normal-‚Ä¶</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>r</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <cn type="integer">0</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>r</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <mtext>where</mtext>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <cn type="integer">0</cn>
     </apply>
    </apply>
    <ci>normal-‚Ä¶</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <apply>
       <minus></minus>
       <ci>k</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <mtext>in</mtext>
     <ci>‚Ñö</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{k-1}r^{k-1}+...+a_{1}r^{1}+a_{0}r^{0},\text{ where }a_{0},...,a_{k-1}\text{%
 in }\mathbb{Q}.
  </annotation>
 </semantics>
</math>

</p>

<p>The product of any two such values can be computed by taking the product as polynomials, then reducing any powers of 

<math display="inline" id="General_number_field_sieve:24">
 <semantics>
  <mrow>
   <mi>r</mi>
   <mi mathvariant="normal">‚â•</mi>
   <mi>k</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>r</ci>
    <ci>normal-‚â•</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r‚â•k
  </annotation>
 </semantics>
</math>

 as described above, yielding a value in the same form. To ensure that this field is actually 

<math display="inline" id="General_number_field_sieve:25">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

-dimensional and does not collapse to an even smaller field, it is sufficient that 

<math display="inline" id="General_number_field_sieve:26">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 is an <a href="irreducible_polynomial" title="wikilink">irreducible polynomial</a> over the rationals. Similarly, one may define the <a href="ring_of_integers" title="wikilink">ring of integers</a> <mtpl></mtpl> as the subset of 

<math display="inline" id="General_number_field_sieve:27">
 <semantics>
  <mrow>
   <mi>ùêê</mi>
   <mi>r</mi>
   <mi>r</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>ùêê</ci>
    <ci>r</ci>
    <ci>r</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{Q}rr
  </annotation>
 </semantics>
</math>

 where <mtpl></mtpl> are restricted to be integers. In some cases, this ring of integers is equivalent to the ring 

<math display="inline" id="General_number_field_sieve:28">
 <semantics>
  <mrow>
   <mi>ùêô</mi>
   <mi>r</mi>
   <mi>r</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>ùêô</ci>
    <ci>r</ci>
    <ci>r</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{Z}rr
  </annotation>
 </semantics>
</math>

. However, there are many exceptions, such as for 

<math display="inline" id="General_number_field_sieve:29">
 <semantics>
  <mrow>
   <mi>ùêê</mi>
   <mi>s</mi>
   <mi>q</mi>
   <mi>r</mi>
   <mi>t</mi>
   <mi>q</mi>
   <mi>r</mi>
   <mi>t</mi>
   <mi>d</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>ùêê</ci>
    <ci>s</ci>
    <ci>q</ci>
    <ci>r</ci>
    <ci>t</ci>
    <ci>q</ci>
    <ci>r</ci>
    <ci>t</ci>
    <ci>d</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{Q}sqrtqrtd
  </annotation>
 </semantics>
</math>

 when 

<math display="inline" id="General_number_field_sieve:30">
 <semantics>
  <mi>d</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>d</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d
  </annotation>
 </semantics>
</math>

 is equal to 1 modulo 4.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>
<h2 id="method">Method</h2>

<p>Two <a href="polynomial" title="wikilink">polynomials</a> <em>f</em>(<em>x</em>) and <em>g</em>(<em>x</em>) of small <a href="degree_of_a_polynomial" title="wikilink">degrees</a> <em>d</em> and <em>e</em> are chosen, which have integer coefficients, which are <a href="irreducible_polynomial" title="wikilink">irreducible</a> over the <a href="rational_number" title="wikilink">rationals</a>, and which, when interpreted <a href="modular_arithmetic" title="wikilink">mod <em>n</em></a>, have a common integer <a href="root_of_a_function" title="wikilink">root</a> <em>m</em>. An optimal strategy for choosing these polynomials is not known; one simple method is to pick a degree <em>d</em> for a polynomial, consider the expansion of <em>n</em> in <a href="radix" title="wikilink">base <em>m</em></a> (allowing digits between ‚àí<em>m</em> and <em>m</em>) for a number of different <em>m</em> of order <em>n</em><sup>1/<em>d</em></sup>, and pick <em>f</em>(<em>x</em>) as the polynomial with the smallest coefficients and <em>g</em>(<em>x</em>) as <em>x</em>¬†‚àí¬†<em>m</em>.</p>

<p>Consider the number field rings <strong>Z</strong>[<em>r</em><sub>1</sub>] and <strong>Z</strong>[<em>r</em><sub>2</sub>], where <em>r</em><sub>1</sub> and <em>r</em><sub>2</sub> are roots of the polynomials <em>f</em> and <em>g</em>. Since <em>f</em> is of degree <em>d</em> with integer coefficients, if <em>a</em> and <em>b</em> are integers, then so will be <em>b</em><sup><em>d</em></sup>¬∑<em>f</em>(<em>a</em>/<em>b</em>), which we call <em>r</em>. Similarly, <em>s</em> = <em>b</em><sup><em>e</em></sup>¬∑<em>g</em>(<em>a</em>/<em>b</em>) is an integer. The goal is to find integer values of <em>a</em> and <em>b</em> that simultaneously make <em>r</em> and <em>s</em> <a href="smooth_number" title="wikilink">smooth</a> relative to the chosen basis of primes. If <em>a</em> and <em>b</em> are small, then <em>r</em> and <em>s</em> will be small too, about the size of <em>m</em>, and we have a better chance for them to be smooth at the same time. The current best-known approach for this search is <a href="lattice_sieving" title="wikilink">lattice sieving</a>; to get acceptable yields, it is necessary to use a large factor base.</p>

<p>Having enough such pairs, using <a href="Gaussian_elimination" title="wikilink">Gaussian elimination</a>, one can get products of certain <em>r</em> and of the corresponding <em>s</em> to be squares at the same time. A slightly stronger condition is needed‚Äîthat they are <a href="field_norm" title="wikilink">norms</a> of squares in our number fields, but that condition can be achieved by this method too. Each <em>r</em> is a norm of <em>a</em>¬†‚àí¬†<em>r</em><sub>1</sub><em>b</em> and hence that the product of the corresponding factors <em>a</em>¬†‚àí¬†<em>r</em><sub>1</sub><em>b</em> is a square in <strong>Z</strong>[<em>r</em><sub>1</sub>], with a "square root" which can be determined (as a product of known factors in <strong>Z</strong>[<em>r</em><sub>1</sub>])‚Äîit will typically be represented as an irrational <a href="algebraic_number" title="wikilink">algebraic number</a>. Similarly, the product of the factors <em>a</em>¬†‚àí¬†<em>r</em><sub>2</sub><em>b</em> is a square in <strong>Z</strong>[<em>r</em><sub>2</sub>], with a "square root" which also can be computed. It should be remarked that the use of Gaussian elimination does not give the optimal run time of the algorithm. Instead, sparse matrix solving algorithms such as <a href="Block_Lanczos_algorithm_for_nullspace_of_a_matrix_over_a_finite_field" title="wikilink">Block Lanczos</a> or <a href="Block_Wiedemann_algorithm" title="wikilink">Block Wiedemann</a> are used.</p>

<p>Since <em>m</em> is a root of both <em>f</em> and <em>g</em> mod <em>n</em>, there are <a href="homomorphism" title="wikilink">homomorphisms</a> from the rings <strong>Z</strong>[<em>r</em><sub>1</sub>] and <strong>Z</strong>[<em>r</em><sub>2</sub>] to the ring <strong>Z/nZ</strong> (the integers <a href="Modular_arithmetic" title="wikilink">mod <em>n</em></a>), which map <em>r</em><sub>1</sub> and <em>r</em><sub>2</sub> to <em>m</em>, and these homomorphisms will map each "square root" (typically not represented as a rational number) into its integer representative. Now the product of the factors <em>a</em>¬†‚àí¬†<em>mb</em> mod <em>n</em> can be obtained as a square in two ways‚Äîone for each homomorphism. Thus, one can find two numbers <em>x</em> and <em>y</em>, with <em>x</em><sup>2</sup>¬†‚àí¬†<em>y</em><sup>2</sup> divisible by <em>n</em> and again with probability at least one half we get a factor of <em>n</em> by finding the <a href="greatest_common_divisor" title="wikilink">greatest common divisor</a> of <em>n</em> and <em>x</em>¬†‚àí¬†<em>y</em>.</p>
<h2 id="improving-polynomial-choice">Improving polynomial choice</h2>

<p>The choice of polynomial can dramatically affect the time to complete the remainder of the algorithm. The method of choosing polynomials based on the expansion of 

<math display="inline" id="General_number_field_sieve:31">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 in base 

<math display="inline" id="General_number_field_sieve:32">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

 shown above is suboptimal in many practical situations, leading to the development of better methods.</p>

<p>One such method was suggested by Murphy and Brent;<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> they introduce a two-part score for polynomials, based on the presence of roots modulo small primes and on the average value that the polynomial takes over the sieving area.</p>

<p>The best reported results<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> were achieved by the method of <a href="Thorsten_Kleinjung" title="wikilink">Thorsten Kleinjung</a>,<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> which allows 

<math display="inline" id="General_number_field_sieve:33">
 <semantics>
  <mrow>
   <mrow>
    <mi>g</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>a</mi>
     <mi>x</mi>
    </mrow>
    <mo>+</mo>
    <mi>b</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>g</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>a</ci>
      <ci>x</ci>
     </apply>
     <ci>b</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g(x)=ax+b
  </annotation>
 </semantics>
</math>

, and searches over 

<math display="inline" id="General_number_field_sieve:34">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 composed of small prime factors congruent to 1 modulo 2

<math display="inline" id="General_number_field_sieve:35">
 <semantics>
  <mi>d</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>d</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d
  </annotation>
 </semantics>
</math>

 and over leading coefficients of 

<math display="inline" id="General_number_field_sieve:36">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 which are divisible by 60.</p>
<h2 id="implementations">Implementations</h2>

<p>Some implementations focus on a certain smaller class of numbers. These are known as <a href="special_number_field_sieve" title="wikilink">special number field sieve</a> techniques, such as used in the <a href="Cunningham_project" title="wikilink">Cunningham project</a>. A project called NFSNET ran from 2002<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> through at least 2007. It used volunteer distributed computing on the <a class="uri" href="Internet" title="wikilink">Internet</a>.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> <a href="Paul_Leyland" title="wikilink">Paul Leyland</a> of the <a href="United_Kingdom" title="wikilink">United Kingdom</a> and Richard Wackerbarth of Texas were involved.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></p>

<p>Until 2007, the gold-standard implementation was a suite of software developed and distributed by <a href="Centrum_Wiskunde_&amp;_Informatica" title="wikilink">CWI</a> in the Netherlands, which was available only under a relatively restrictive license. In 2007, <a href="Jason_Papadopoulos" title="wikilink">Jason Papadopoulos</a> developed a faster implementation of final processing as part of msieve, which is public-domain. Both implementations feature the ability to be distributed among several nodes in a cluster with a sufficiently fast interconnect.</p>

<p>Polynomial selection is normally performed by <a class="uri" href="GPL" title="wikilink">GPL</a> software written by Kleinjung, or by msieve, and lattice sieving by GPL software written by Franke and Kleinjung; these are distributed in GGNFS.</p>
<ul>
<li><a href="http://escatter11.fullerton.edu/nfs/">NFS@Home</a></li>
<li><a href="http://www.math.ttu.edu/~cmonico/software/ggnfs/">GGNFS</a></li>
<li><a href="http://pgnfs.org/">pGNFS</a></li>
<li><a href="https://sourceforge.net/projects/factor-by-gnfs/">factor by gnfs</a></li>
<li><a href="http://cado-nfs.gforge.inria.fr/">CADO-NFS</a></li>
<li><a href="http://sourceforge.net/projects/msieve/">msieve</a>, which contains excellent final-processing code, a good implementation of the polynomial selection which is very good for smaller numbers, and an implementation of the line sieve.</li>
<li><a href="http://kmgnfs.cti.gr">kmGNFS</a></li>
</ul>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Special_number_field_sieve" title="wikilink">Special number field sieve</a></li>
</ul>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<ul>
<li><a href="Arjen_Lenstra" title="wikilink">Arjen K. Lenstra</a> and <a href="Hendrik_Lenstra" title="wikilink">H. W. Lenstra, Jr.</a> (eds.). "The development of the number field sieve". Lecture Notes in Math. (1993) 1554. Springer-Verlag.</li>
<li>Richard Crandall and <a href="Carl_Pomerance" title="wikilink">Carl Pomerance</a>. Prime Numbers: A Computational Perspective (2001). 2nd edition, Springer. ISBN 0-387-25282-7. Section 6.2: Number field sieve, pp.¬†278‚Äì301.</li>
</ul>

<p>"</p>

<p><a href="Category:Integer_factorization_algorithms" title="wikilink">Category:Integer factorization algorithms</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">‚Ü©</a></li>
<li id="fn2"><a href="#fnref2">‚Ü©</a></li>
<li id="fn3"><a href="#fnref3">‚Ü©</a></li>
<li id="fn4"><a href="#fnref4">‚Ü©</a></li>
<li id="fn5"><a href="#fnref5">‚Ü©</a></li>
<li id="fn6"><a href="#fnref6">‚Ü©</a></li>
<li id="fn7"><a href="#fnref7">‚Ü©</a></li>
<li id="fn8"><a href="#fnref8">‚Ü©</a></li>
</ol>
</section>
</body>
</html>
