<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="218">Standard ML</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Standard ML</h1>
<style>
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
<style>
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
</body></html>
<body>
<hr/>

<p><strong>Standard ML</strong> (<strong>SML</strong>) is a general-purpose, <a href="Module_(programming)" title="wikilink">modular</a>, <a href="functional_programming_language" title="wikilink">functional programming language</a> with <a href="compile-time_type_checking" title="wikilink">compile-time type checking</a> and <a href="type_inference" title="wikilink">type inference</a>. It is popular among <a class="uri" href="compiler" title="wikilink">compiler</a> writers and <a href="programming_language_research" title="wikilink">programming language researchers</a>, as well as in the development of <a href="automated_theorem_proving" title="wikilink">theorem provers</a>.</p>

<p>SML is a modern descendant of the <a href="ML_programming_language" title="wikilink">ML programming language</a> used in the <a href="Logic_for_Computable_Functions" title="wikilink">Logic for Computable Functions</a> (LCF) theorem-proving project. It is distinctive among widely used languages in that it has a formal specification, given as <a href="type_rules" title="wikilink">typing rules</a> and <a href="operational_semantics" title="wikilink">operational semantics</a> in <em>The Definition of Standard ML</em> (1990, revised and simplified as <em>The Definition of Standard ML (Revised)</em> in 1997).<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>
<h2 id="language">Language</h2>

<p>Standard ML is a functional programming language with some impure features. Programs written in Standard ML consist of <a href="expression_(programming)" title="wikilink">expressions</a> to be evaluated, as opposed to statements or commands, although some expressions return a trivial "unit" value and are only evaluated for their side-effects.</p>

<p>Like all functional programming languages, a key feature of Standard ML is the <a href="function_(programming)" title="wikilink">function</a>, which is used for abstraction. For instance, the <a class="uri" href="factorial" title="wikilink">factorial</a> function can be expressed as:</p>
<pre class="sml"><code> fun factorial n = 
        if n = 0 then 1 else n * factorial (n-1)</code></pre>

<p>A Standard ML compiler is required to infer the static type <code>int -&gt; int </code>of this function without user-supplied type annotations. I.e., it has to deduce that <em>n</em> is only used with integer expressions, and must therefore itself be an integer, and that all value-producing expressions within the function return integers.</p>

<p>The same function can be expressed with <a href="clausal_function_definitions" title="wikilink">clausal function definitions</a> where the <em>if</em>-<em>then</em>-<em>else</em> conditional is replaced by a sequence of templates of the factorial function evaluated for specific values, separated by '|', which are tried one by one in the order written until a match is found:</p>
<pre class="sml"><code> fun factorial 0 = 1
   | factorial n = n * factorial (n - 1)</code></pre>

<p>This can be rewritten using a case statement like this:</p>
<pre class="sml"><code> val rec factorial =
        fn n =&gt; case n of 0 =&gt; 1
                        | n =&gt; n * factorial (n - 1)</code></pre>

<p>or as a lambda function:</p>
<pre class="sml"><code> val rec factorial = fn 0 =&gt; 1 | n =&gt; n * factorial(n -1)</code></pre>

<p>Here, the keyword <code>val</code> introduces a binding of an identifier to a value, <code>fn</code> introduces the definition of an <a href="anonymous_function" title="wikilink">anonymous function</a>, and <code>case</code> introduces a sequence of patterns and corresponding expressions.</p>

<p>Using a local function, this function can be rewritten in a more efficient <a href="tail_recursive" title="wikilink">tail recursive</a> style.</p>
<pre class="sml"><code> fun factorial n = let
       fun lp (0, acc) = acc
        | lp (m, acc) = lp (m-1, m*acc)
      in
        lp (n, 1)
      end</code></pre>

<p>(The value of a <strong>let</strong>-expression is that of the expression between <strong>in</strong> and <strong>end</strong>.) The encapsulation of an invariant-preserving tail-recursive tight loop with one or more accumulator parameters inside an invariant-free outer function, as seen here, is a common idiom in Standard ML, and appears with great frequency in SML code.</p>
<h3 id="type-synonyms">Type synonyms</h3>

<p>A type synonym is defined with the <strong>type</strong> keyword. Here is a type synonym for points in the plane, and functions computing the distances between two points, and the area of a triangle with the given corners as per <a href="Heron's_formula" title="wikilink">Heron's formula</a>.</p>
<pre class="sml"><code> type loc = real * real

 fun dist ((x0, y0), (x1, y1)) = let
      val dx = x1 - x0
      val dy = y1 - y0
      in
        Math.sqrt (dx * dx + dy * dy)
      end

 fun heron (a, b, c) = let
      val ab = dist (a, b)
      val bc = dist (b, c)
      val ac = dist (a, c)
      val perim = ab + bc + ac
      val s = perim / 2.0
      in
        Math.sqrt (s * (s - ab) * (s - bc) * (s - ac))
      end</code></pre>
<h3 id="algebraic-datatypes-and-pattern-matching">Algebraic datatypes and pattern matching</h3>

<p>Standard ML provides strong support for <a href="algebraic_datatypes" title="wikilink">algebraic datatypes</a>. An ML datatype can be thought of as a <a href="disjoint_union" title="wikilink">disjoint union</a> of tuples (or a "sum of products"). They are easy to define and easy to program with, in large part because of Standard ML's <a href="pattern_matching" title="wikilink">pattern matching</a> as well as most Standard ML implementations' pattern exhaustiveness checking and pattern redundancy checking.</p>

<p>A datatype is defined with the <strong>datatype</strong> keyword, as in</p>
<pre class="sml"><code> datatype shape
    = Circle   of loc * real      (* center and radius *)
    | Square   of loc * real      (* upper-left corner and side length; axis-aligned *)
    | Triangle of loc * loc * loc (* corners *)</code></pre>

<p>(See above for the definition of <code>loc</code>.) Note: datatypes, not type synonyms, are necessary to define recursive constructors. (This is not at issue in the present example.)</p>

<p>Order matters in pattern matching; patterns that are textually first are tried first. Pattern matching can be syntactically embedded in function definitions as follows:</p>
<pre class="sml"><code> fun area (Circle (_, r)) = 3.14 * r * r
    | area (Square (_, s)) = s * s
    | area (Triangle (a, b, c)) = heron (a, b, c) (* see above *)</code></pre>

<p>Note that subcomponents whose values are not needed in a particular computation are ellided with underscores, or so-called wildcard patterns.</p>

<p>The so-called "clausal form" style function definition, where patterns appear immediately after the function name, is merely <a href="syntactic_sugar" title="wikilink">syntactic sugar</a> for</p>
<pre class="sml"><code> fun area shape =
    case shape
     of Circle (_, r) =&gt; 3.14 * r * r
      | Square (_, s) =&gt; s * s
      | Triangle (a, b, c) =&gt; heron (a, b, c)</code></pre>

<p>Pattern exhaustiveness checking will make sure each case of the datatype has been accounted for, and will produce a warning if not. The following pattern is inexhaustive:</p>
<pre class="sml"><code> fun center (Circle (c, _)) = c
    | center (Square ((x, y), s)) = (x + s / 2.0, y + s / 2.0)</code></pre>

<p>There is no pattern for the <code>Triangle</code> case in the <code>center</code> function. The compiler will issue a warning that the pattern is inexhaustive, and if, at runtime, a <code>Triangle</code> is passed to this function, the exception <code>Match</code> will be raised.</p>

<p>The set of clauses in the following function definition is exhaustive and not redundant:</p>
<pre class="sml"><code> fun hasCorners (Circle _) = false
    | hasCorners _ = true</code></pre>

<p>If control gets past the first pattern (the <code>Circle</code>), we know the value must be either a <code>Square</code> or a <code>Triangle</code>. In either of those cases, we know the shape has corners, so we can return <code>true</code> without discriminating which case we are in.</p>

<p>The pattern in second clause the following (meaningless) function is redundant:</p>
<pre class="sml"><code> fun f (Circle ((x, y), r)) = x+y
    | f (Circle _) = 1.0
    | f _ = 0.0</code></pre>

<p>Any value that matches the pattern in the second clause will also match the pattern in the first clause, so the second clause is unreachable. Therefore this definition as a whole exhibits redundancy, and causes a compile-time warning.</p>

<p>C programmers will often use <a href="tagged_union" title="wikilink">tagged unions</a>, dispatching on tag values, to accomplish what ML accomplishes with datatypes and pattern matching. Nevertheless, while a C program decorated with appropriate checks will be in a sense as robust as the corresponding ML program, those checks will of necessity be dynamic; ML provides a set of static checks that give the programmer a high degree of confidence in the correctness of the program at compile time.</p>

<p>Note that in object-oriented programming languages, such as Java, a disjoint union can be expressed by designing <a href="class_hierarchies" title="wikilink">class hierarchies</a>. However, as opposed to class hierarchies, ADTs are <a href="Closed_world_assumption" title="wikilink">closed</a>. This makes ADT extensible in a way that is orthogonal to the extensibility of class hierarchies. Class hierarchies can be extended with new subclasses but no new methods, while ADTs can be extended to provide new behavior for all existing constructors, but do not allow defining new constructors.</p>
<h3 id="higher-order-functions">Higher-order functions</h3>

<p>Functions can consume functions as arguments:</p>
<pre class="sml"><code> fun applyToBoth f x y = (f x, f y)</code></pre>

<p>Functions can produce functions as return values:</p>
<pre class="sml"><code> fun constantFn k = let
     fun const anything = k
    in
      const
    end</code></pre>

<p>(alternatively)</p>
<pre class="sml"><code> fun constantFn k = (fn anything =&gt; k)</code></pre>

<p>Functions can also both consume and produce functions:</p>
<pre class="sml"><code> fun compose (f, g) = let
     fun h x = f (g x)
    in
      h
    end</code></pre>

<p>(alternatively)</p>
<pre class="sml"><code> fun compose (f, g) = (fn x =&gt; f (g x))</code></pre>

<p>The function <code>List.map</code> from the basis library is one of the most commonly used higher-order functions in Standard ML:</p>
<pre class="sml"><code> fun map _ [] = []
    | map f (x::xs) = f x  :: map f xs</code></pre>

<p>(A more efficient implementation of <code>map</code> would define a tail-recursive inner loop as follows:)</p>
<pre class="sml"><code> fun map f xs = let
     fun m ([], acc) = List.rev acc
      | m (x::xs, acc) = m (xs, f x  :: acc)
    in
      m (xs, [])
    end</code></pre>
<h3 id="exceptions">Exceptions</h3>

<p>Exceptions are raised with the <code>raise</code> keyword, and handled with pattern matching <code>handle</code> constructs.</p>
<pre class="sml"><code> exception Undefined
  fun max [x] = x
    | max (x::xs) = let val m = max xs in if x &gt; m then x else m end
    | max [] = raise Undefined
  fun main xs = let
     val msg = (Int.toString (max xs)) handle Undefined =&gt; "empty list...there is no max!"
    in
      print (msg ^ "\n")
    end</code></pre>

<p>The exception system can be exploited to implement <a href="non-local_exit" title="wikilink">non-local exit</a>, an optimization technique suitable for functions like the following.</p>
<pre class="sml"><code> exception Zero
  fun listProd ns = let
     fun p [] = 1
      | p (0::_) = raise Zero
      | p (h::t) = h * p t
    in
      (p ns) handle Zero =&gt; 0
    end</code></pre>

<p>When the exception <code>Zero</code> is raised in the 0 case, control leaves the function <code>p</code> altogether. Consider the alternative: the value 0 would be returned to the most recent awaiting frame, it would be multiplied by the local value of <code>h</code>, the resulting value (inevitably 0) would be returned in turn to the next awaiting frame, and so on. The raising of the exception allows control to leapfrog directly over the entire chain of frames and avoid the associated computation. It has to be noted that the same optimization could have been obtained by using a tail recursion for this example.</p>
<h3 id="module-system">Module system</h3>

<p>Standard ML has an advanced <a href="Module_(programming)" title="wikilink">module</a> system, allowing programs to be decomposed into hierarchically organized <em>structures</em> of logically related type and value declarations. SML modules provide not only <a class="uri" href="namespace" title="wikilink">namespace</a> control but also abstraction, in the sense that they allow programmers to define <a href="abstract_data_type" title="wikilink">abstract data types</a>.</p>

<p>Three main syntactic constructs comprise the SML module system: signatures, structures and functors. A <em>structure</em> is a module; it consists of a collection of types, exceptions, values and structures (called <em>substructures</em>) packaged together into a logical unit. A <em>signature</em> is an <a href="Interface_(computer_science)" title="wikilink">interface</a>, usually thought of as a type for a structure: it specifies the names of all the entities provided by the structure as well as the <a href="arity" title="wikilink">arities</a> of type components, the types of value components, and signatures for substructures. The definitions of type components may or may not be exported; type components whose definitions are hidden are <em>abstract types</em>. Finally, a <em>functor</em> is a function from structures to structures; that is, a functor accepts one or more arguments, which are usually structures of a given signature, and produces a structure as its result. Functors are used to implement <a href="generic_programming" title="wikilink">generic</a> data structures and algorithms.</p>

<p>For example, the signature for a <a href="Queue_(data_structure)" title="wikilink">queue</a> data structure might be:</p>
<pre class="sml"><code> signature QUEUE = 
 sig
    type 'a queue
    exception QueueError
    val empty     : 'a queue
    val isEmpty   : 'a queue -&gt; bool
    val singleton : 'a -&gt; 'a queue
    val insert    : 'a * 'a queue -&gt; 'a queue
    val peek      : 'a queue -&gt; 'a
    val remove    : 'a queue -&gt; 'a * 'a queue
 end</code></pre>

<p>This signature describes a module that provides a parameterized type <code>queue</code> of queues, an exception called <code>QueueError</code>, and six values (five of which are functions) providing the basic operations on queues. One can now implement the queue data structure by writing a structure with this signature:</p>
<pre class="sml"><code> structure TwoListQueue    :&gt; QUEUE = 
 struct
   type 'a queue = 'a list * 'a list
   exception QueueError
 
   val empty = ([],[])
 
   fun isEmpty ([],[]) = true
     | isEmpty _ = false
   
   fun singleton a = ([], [a])
 
   fun insert (a, ([], [])) = ([], [a])
     | insert (a, (ins, outs)) = (a::ins, outs)
   
   fun peek (_,[]) = raise QueueError
     | peek (ins, a::outs) = a
   
   fun remove (_,[]) = raise QueueError
     | remove (ins, [a]) = (a, ([], rev ins))
     | remove (ins, a::outs) = (a, (ins,outs))
    
 end</code></pre>

<p>This definition declares that <code>TwoListQueue</code> is an implementation of the <code>QUEUE</code> signature. Furthermore, the <em>opaque ascription</em> (denoted by <code>:&gt;</code>) states that any type components whose definitions are not provided in the signature (<em>i.e.,</em> <code>queue</code>) should be treated as abstract, meaning that the definition of a queue as a pair of lists is not visible outside the module. The body of the structure provides bindings for all of the components listed in the signature.</p>

<p>To use a structure, one can access its type and value members using "dot notation". For instance, a queue of strings would have type <code>string TwoListQueue.queue</code>, the empty queue is <code>TwoListQueue.empty</code>, and to remove the first element from a queue called <code>q</code> one would write <code>TwoListQueue.remove q</code>.</p>

<p>One popular algorithm<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> for <a href="breadth-first_search" title="wikilink">breadth-first search</a> of trees makes uses of queues. Here we present a version of that algorithm parameterized over an abstract queue structure:</p>
<pre class="sml"><code> functor BFS (structure Q: QUEUE) = (* after Okasaki, ICFP, 2000 *)
  struct 
     datatype 'a tree
      = E
      | T of 'a * 'a tree * 'a tree
    fun bfsQ (q  : 'a tree Q.queue)  : 'a list = 
      if Q.isEmpty q then []
      else let
         val (t, q') = Q.remove q
        in case t
          of E =&gt; bfsQ q'
           | T (x, l, r) =&gt; let
                val q'' = Q.insert (r, Q.insert (l, q'))
               in
                 x  :: bfsQ q''
                end
         end
     fun bfs t = bfsQ (Q.singleton t)
  end</code></pre>

<p>Please note that inside the <code>BFS</code> structure, the program has no access to the particular queue representation in play. More concretely, there is no way for the program to, say. select the first list in the two-list queue representation, if that is indeed the representation being used. This <a href="data_abstraction" title="wikilink">data abstraction</a> mechanism makes the breadth-first code truly agnostic to the queue representation choice. This is in general desirable; in the present case, the queue structure can safely maintain any of the various logical invariants on which its correctness depends behind the bulletproof wall of abstraction.</p>
<h2 id="code-examples">Code examples</h2>

<p>Snippets of SML code are most easily studied by entering them into a "top-level", also known as a <a href="read-eval-print_loop" title="wikilink">read-eval-print loop</a> or REPL. This is an interactive session that prints the inferred types of resulting or defined expressions. Many SML implementations provide an interactive REPL, including <a class="uri" href="SML/NJ" title="wikilink">SML/NJ</a>:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"> $ <span class="kw">sml</span>
   [[<span class="kw">Standard</span> ML of New Jersey]] v110.52 [built: Fri Jan 21 16:42:10 2005]
   <span class="kw">-</span></code></pre></div>

<p>Code can then be entered at the "-" prompt. For example, to calculate 1+2*3:</p>
<pre class="sml"><code> - 1 + 2 * 3;
   val it = 7  : int</code></pre>

<p>The top-level infers the type of the expression to be "int" and gives the result "7".</p>
<h3 id="hello-world">Hello world</h3>

<p>The following program "hello.sml":</p>
<pre class="sml"><code> print "Hello world!\n";</code></pre>

<p>can be compiled with MLton:</p>

<p><code>$ mlton hello.sml</code></p>

<p>and executed:</p>

<p><code>$ ./hello</code><br/>
<code>  Hello world!</code></p>
<h3 id="insertion-sort">Insertion sort</h3>

<p>Insertion sort for lists of integers (ascending) is expressed concisely as follows:</p>
<pre class="sml"><code> fun ins (n, []) = [n]
    | ins (n, ns as h::t) = if (n<h) (n,="" <="" []="" else="" h::(ins="" ins="" insertionsort="List.foldr" n::ns="" source="" t))="" then="" val="">

This can be made polymorphic by abstracting over the ordering operator. Here we use the symbolic name <code>&lt;&lt;</code> for that operator.
<source lang="sml"> fun ins' &lt;&lt; (num, nums) = let
     fun i (n, []) = [n]
      | i (n, ns as h::t) = if &lt;&lt;(n,h) then n::ns else h::i(n,t)
    in
      i (num, nums)
    end
   fun insertionSort' &lt;&lt; = List.foldr (ins' &lt;&lt;) []</source></h)></code></pre>

<p>The type of <code>insertionSort'</code> is <code>('a * 'a -&gt; bool) -&gt; ('a list) -&gt; ('a list)</code>.</p>
<h3 id="mergesort">Mergesort</h3>

<p>Here, the classic mergesort algorithm is implemented in three functions: split, merge and mergesort.</p>

<p>The function <code>split</code> is implemented with a local function named <code>loop</code>, which has two additional parameters. The local function <code>loop</code> is written in a <a href="tail_recursion" title="wikilink">tail-recursive</a> style; as such it can be compiled efficiently. This function makes use of SML's pattern matching syntax to differentiate between non-empty list (<code>x::xs</code>) and empty list (<code>[]</code>) cases. For stability, the input list <code>ns</code> is reversed before being passed to <code>loop</code>.</p>
<pre class="sml"><code> (* Split list into two near-halves, returned as a pair.
  * The “halves” will either be the same size,
  * or the first will have one more element than the second.
  * Runs in O(n) time, where n = |xs|. *)
   local
     fun loop (x::y::zs, xs, ys) = loop (zs, x::xs, y::ys)
       | loop (x::[], xs, ys) = (x::xs, ys)
       | loop ([], xs, ys) = (xs, ys)
   in
     fun split ns = loop (List.rev ns, [], [])
   end</code></pre>

<p>The local-in-end syntax could be replaced with a let-in-end syntax, yielding the equivalent definition:</p>
<pre class="sml"><code> fun split ns = let
   fun loop (x::y::zs, xs, ys) = loop (zs, x::xs, y::ys)
     | loop (x::[], xs, ys) = (x::xs, ys)
     | loop ([], xs, ys) = (xs, ys)
   in
     loop (List.rev ns, [], [])
   end</code></pre>

<p>As with split, merge also uses a local function loop for efficiency. The inner <code>loop</code> is defined in terms of cases: when two non-empty lists are passed, when one non-empty list is passed, and when two empty lists are passed. Note the use of the underscore (<code>_</code>) as a wildcard pattern.</p>

<p>This function merges two "ascending" lists into one ascending list. Note how the accumulator <code>out</code> is built "backwards", then reversed with <code>List.rev</code> before being returned. This is a common technique—build a list backwards, then reverse it before returning it. In SML, lists are represented as imbalanced binary trees, and thus it is efficient to prepend an element to a list, but inefficient to append an element to a list. The extra pass over the list is a <a href="linear_time" title="wikilink">linear time</a> operation, so while this technique requires more wall clock time, the asymptotics are not any worse.</p>
<pre class="sml"><code> (* Merge two ordered lists using the order lt.
  * Pre: the given lists xs and ys must already be ordered per lt.
  * Runs in O(n) time, where n = |xs| + |ys|. *)
  fun merge lt (xs, ys) = let
    fun loop (out, left as x::xs, right as y::ys) =
            if lt (x, y) then loop (x::out, xs, right)
            else loop (y::out, left, ys)
      | loop (out, x::xs, []) = loop (x::out, xs, [])
      | loop (out, [], y::ys) = loop (y::out, [], ys)
      | loop (out, [], []) = List.rev out
    in
      loop ([], xs, ys)
    end</code></pre>

<p>The main function.</p>
<pre class="sml"><code> (* Sort a list in according to the given ordering operation lt.
  * Runs in O(n log n) time, where n = |xs|.
  *)
  fun mergesort lt xs = let
    val merge' = merge lt
    fun ms [] = []
      | ms [x] = [x]
      | ms xs = let
          val (left, right) = split xs
          in
            merge' (ms left, ms right)
          end
    in
      ms xs
    end</code></pre>

<p>Also note that the code makes no mention of variable types, with the exception of the :: and [] syntax which signify lists. This code will sort lists of any type, so long as a consistent ordering function lt can be defined. Using <a href="Hindley–Milner_type_inference" title="wikilink">Hindley–Milner type inference</a>, the compiler is capable of inferring the types of all variables, even complicated types such as that of the lt function.</p>
<h3 id="quicksort">Quicksort</h3>

<p>Quicksort can be expressed as follows. This generic quicksort consumes an order operator <code>.</code></p>
<pre class="sml"><code>  fun quicksort &lt;&lt; xs = let
     fun qs [] = []
       | qs [x] = [x]
      | qs (p::xs) = let
          val (less, more) = List.partition (fn x =&gt; &lt;&lt; (x, p)) xs
          in
            qs less @ p :: qs more
          end
     in
       qs xs
     end</code></pre>
<h3 id="expression-language">Expression language</h3>

<p>Note the relative ease with which a small expression language is defined and processed.</p>
<pre class="sml"><code> exception Err
 
  datatype ty
    = IntTy
    | BoolTy
 
  datatype exp
    = True
    | False
    | Int of int
    | Not of exp
    | Add of exp * exp
    | If of exp * exp * exp
 
  fun typeOf (True) = BoolTy
    | typeOf (False) = BoolTy
    | typeOf (Int _) = IntTy
    | typeOf (Not e) = if typeOf e = BoolTy then BoolTy else raise Err
    | typeOf (Add (e1, e2)) = 
        if (typeOf e1 = IntTy) andalso (typeOf e2 = IntTy) then IntTy else raise Err
    | typeOf (If (e1, e2, e3)) = 
        if typeOf e1 &lt;&gt; BoolTy then raise Err
        else if typeOf e2 &lt;&gt; typeOf e3 then raise Err
        else typeOf e2
  
  fun eval (True) = True
    | eval (False) = False
    | eval (Int n) = Int n
    | eval (Not e) = 
       (case eval e
          of True =&gt; False
           | False =&gt; True
           | _ =&gt; raise Fail "type-checking is broken")
    | eval (Add (e1, e2)) = let
         val (Int n1) = eval e1
        val (Int n2) = eval e2
        in
          Int (n1 + n2)
        end
    | eval (If (e1, e2, e3)) = 
        if eval e1 = True then eval e2 else eval e3
 
  fun chkEval e = (ignore (typeOf e); eval e) (* will raise Err on type error *)</code></pre>
<h3 id="arbitrary-precision-factorial-function-libraries">Arbitrary-precision factorial function (libraries)</h3>

<p>In SML, the IntInf module provides arbitrary-precision integer arithmetic. Moreover, integer literals may be used as arbitrary-precision integers without the programmer having to do anything.</p>

<p>The following program "fact.sml" implements an arbitrary-precision factorial function and prints the factorial of 120:</p>
<pre class="sml"><code> fun fact n  : IntInf.int =
       if n=0 then 1 else n * fact(n - 1)

 val () =
       print (IntInf.toString (fact 120) ^ "\n")</code></pre>

<p>and can be compiled and run with:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">   $ <span class="kw">mlton</span> fact.sml
   $ <span class="kw">./fact</span>
   <span class="kw">66895029134491270575881180540903725867527463331380298102956713523016335</span>
   <span class="kw">57244962989366874165271984981308157637893214090552534408589408121859898</span>
   <span class="kw">481114389650005964960521256960000000000000000000000000000</span></code></pre></div>
<h3 id="numerical-derivative-higher-order-functions">Numerical derivative (higher-order functions)</h3>

<p>Since SML is a functional programming language, it is easy to create and pass around functions in SML programs. This capability has an enormous number of applications. Calculating the numerical derivative of a function is one such application. The following SML function "d" computes the numerical derivative of a given function "f" at a given point "x":</p>
<pre class="sml"><code> - fun d delta f x =
       (f (x + delta) - f (x - delta)) / (2.0 * delta);
   val d = fn  : real -&gt; (real -&gt; real) -&gt; real -&gt; real</code></pre>

<p>This function requires a small value "delta". A good choice for delta when using this algorithm is the cube root of the <a href="machine_epsilon" title="wikilink">machine epsilon</a>.</p>

<p>The type of the function "d" indicates that it maps a "float" onto another function with the type "(real -&gt; real) -&gt; real -&gt; real". This allows us to partially apply arguments. This functional style is known as <a class="uri" href="currying" title="wikilink">currying</a>. In this case, it is useful to partially apply the first argument "delta" to "d", to obtain a more specialised function:</p>
<pre class="sml"><code> - val d = d 1E~8;
   val d = fn  : (real -&gt; real) -&gt; real -&gt; real</code></pre>

<p>Note that the inferred type indicates that the replacement "d" is expecting a function with the type "real -&gt; real" as its first argument. We can compute a numerical approximation to the derivative of 

<math display="inline" id="Standard_ML:0">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>x</mi>
     <mn>3</mn>
    </msup>
    <mo>-</mo>
    <mi>x</mi>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <cn type="integer">3</cn>
     </apply>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x)=x^{3}-x-1
  </annotation>
 </semantics>
</math>

 at 

<math display="inline" id="Standard_ML:1">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>=</mo>
   <mn>3</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>x</ci>
    <cn type="integer">3</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x=3
  </annotation>
 </semantics>
</math>

 with:</p>
<pre class="sml"><code> - d (fn x =&gt; x * x * x - x - 1.0) 3.0;
   val it = 25.9999996644  : real</code></pre>

<p>The correct answer is 

<math display="inline" id="Standard_ML:2">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>f</mi>
     <mo>′</mo>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mn>3</mn>
     <msup>
      <mi>x</mi>
      <mn>2</mn>
     </msup>
    </mrow>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>f</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>x</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <cn type="integer">3</cn>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f^{\prime}(x)=3x^{2}-1
  </annotation>
 </semantics>
</math>

; 

<math display="inline" id="Standard_ML:3">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>f</mi>
     <mo>′</mo>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>3</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mn>27</mn>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
   <mo>=</mo>
   <mn>26</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>f</ci>
       <ci>normal-′</ci>
      </apply>
      <cn type="integer">3</cn>
     </apply>
     <apply>
      <minus></minus>
      <cn type="integer">27</cn>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="integer">26</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f^{\prime}(3)=27-1=26
  </annotation>
 </semantics>
</math>


.</p>

<p>The function "d" is called a "higher-order function" because it accepts another function ("f") as an argument.</p>

<p>Curried and higher-order functions can be used to eliminate redundant code. For example, a library may require functions of type <code>a -&gt; b</code>, but it is more convenient to write functions of type <code>a * c -&gt; b</code> where there is a fixed relationship between the objects of type <code>a</code> and <code>c</code>. A higher order function of type (a * c -&gt; b) -&gt; (a -&gt; b) can factor out this commonality. This is an example of the <a href="adapter_pattern" title="wikilink">adapter pattern</a>.</p>
<h3 id="discrete-wavelet-transform-pattern-matching">Discrete wavelet transform (pattern matching)</h3>

<p>The 1D <a href="Haar_wavelet" title="wikilink">Haar wavelet</a> <a href="Discrete_wavelet_transform" title="wikilink">transform</a> of an <a class="uri" href="integer" title="wikilink">integer</a>-power-of-two-length list of numbers can be implemented very succinctly in SML and is an excellent example of the use of <a href="pattern_matching" title="wikilink">pattern matching</a> over lists, taking pairs of elements ("h1" and "h2") off the front and storing their sums and differences on the lists "s" and "d", respectively:</p>
<pre class="sml"><code> - fun haar l = let
       fun aux [s] [] d = s  :: d
         | aux [] s d = aux s [] d
         | aux (h1::h2::t) s d = aux t (h1+h2  :: s) (h1-h2  :: d)
         | aux _ _ _ = raise Empty
       in  
         aux l [] []
       end;
   val haar = fn  : int list -&gt; int list</code></pre>

<p>For example:</p>
<pre class="sml"><code> - haar [1, 2, 3, 4, ~4, ~3, ~2, ~1];
   val it = [0,20,4,4,~1,~1,~1,~1]  : int list</code></pre>

<p>Pattern matching is a useful construct that allows complicated transformations to be represented clearly and succinctly. Moreover, SML compilers turn pattern matches into efficient code, resulting in programs that are not only shorter but also faster.</p>
<h2 id="implementations">Implementations</h2>

<p>Many SML implementations exist, including:</p>
<ul>
<li><a class="uri" href="MLton" title="wikilink">MLton</a> is a <a href="Whole_program_optimization" title="wikilink">whole-program optimizing</a> compiler that produces very fast code compared to other ML implementations. <a href="http://www.mlton.org">1</a></li>
<li><a href="http://www.polyml.org/">Poly/ML</a> is a full implementation of Standard ML that produces fast code and supports multicore hardware (via Posix threads); its runtime system performs parallel garbage collection and online sharing of immutable substructures.</li>
<li><a href="http://isabelle.in.tum.de">Isabelle/ML</a> integrates parallel Poly/ML into an interactive theorem prover, with a sophisticated IDE (based on <a class="uri" href="jEdit" title="wikilink">jEdit</a>) both for the Isabelle/ML dialect and the proof language. Starting with Isabelle2014, official Standard ML (SML'97) is supported as well.</li>
<li><a href="Standard_ML_of_New_Jersey" title="wikilink">Standard ML of New Jersey</a> (abbreviated SML/NJ) is a full compiler, with associated libraries, tools, an interactive shell, and documentation. <a href="http://www.smlnj.org/">2</a></li>
<li><a href="Moscow_ML" title="wikilink">Moscow ML</a> is a light-weight implementation, based on the <a href="Caml" title="wikilink">CAML Light</a> runtime engine. It implements the full SML language, including SML Modules, and much of the SML Basis Library. <a href="http://www.itu.dk/people/sestoft/mosml.html">3</a></li>
<li>CakeML<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> a read-eval-print loop version of ML with formally verified runtime and translation to assembler</li>
<li><a href="http://www.mpi-sws.org/~rossberg/hamlet/">HaMLet</a> is an SML interpreter that aims to be an accurate and accessible reference implementation of the standard.</li>
<li>The <a href="http://www.elsman.com/mlkit/">ML Kit</a> integrates a garbage collector (which can be disabled) and <a href="region-based_memory_management" title="wikilink">region-based memory management</a> with automatic inference of regions, aiming to support realtime applications. Its implementation is based very closely on the Definition.</li>
<li><a href="http://www.cs.cornell.edu/home/jgm/tilt.html">TILT</a> is a full certifying compiler for SML. It uses typed intermediate languages to optimize code and ensure correctness, and can compile to <a href="Type_system" title="wikilink">typed</a> <a href="Assembly_language" title="wikilink">Assembly language</a>.</li>
<li><a href="http://www.cl.cam.ac.uk/Research/TSG/SMLNET/">SML.NET</a> allows compiling to the Microsoft <a href="Common_Language_Runtime" title="wikilink">CLR</a> and has extensions for linking with other <a href=".NET_Framework" title="wikilink">.NET</a> code.</li>
<li>SML2c is a batch compiler and compiles only module-level declarations (i.e. signatures, structures, functors) into <a href="C_(programming_language)" title="wikilink">C</a>. It is based on SML/NJ version 0.67 and shares the front end, and most of its run-time system, but does not support SML/NJ style debugging and profiling. Module-level programs that run on SML/NJ can be compiled by sml2c with no changes.</li>
<li>The <a class="uri" href="Poplog" title="wikilink">Poplog</a> system implements a version of SML, with <a class="uri" href="POP-11" title="wikilink">POP-11</a>, and optionally <a href="Common_Lisp" title="wikilink">Common Lisp</a>, and <a class="uri" href="Prolog" title="wikilink">Prolog</a>, allowing mixed language programming. For all, the implementation language is POP-11, which is compiled incrementally. It also has an integrated <a class="uri" href="Emacs" title="wikilink">Emacs</a>-like editor that communicates with the compiler.</li>
<li><a href="http://www.pllab.riec.tohoku.ac.jp/smlsharp/">SML#</a> is an extension of SML providing record polymorphism and C language interoperability. It is a conventional native compiler and its name is <em>not</em> an allusion to running on the .NET framework.</li>
<li><a href="Alice_(programming_language)" title="wikilink">Alice</a>: an interpreter for Standard ML by Saarland University adding features for <a href="lazy_evaluation" title="wikilink">lazy evaluation</a>, <a href="Concurrency_(computer_science)" title="wikilink">concurrency</a> (<a href="thread_(computer_science)" title="wikilink">multithreading</a> and <a href="distributed_computing" title="wikilink">distributed computing</a> via <a href="remote_procedure_call" title="wikilink">remote procedure calls</a>) and <a href="constraint_programming" title="wikilink">constraint programming</a>.</li>
</ul>

<p>All of these implementations are <a class="uri" href="open-source" title="wikilink">open-source</a> and freely available. Most are implemented themselves in SML. There are no longer any commercial SML implementations. <a href="Harlequin_(software_company)" title="wikilink">Harlequin</a> once produced a commercial IDE and compiler for SML called <a class="uri" href="MLWorks" title="wikilink">MLWorks</a>. The company is now defunct. <a class="uri" href="MLWorks" title="wikilink">MLWorks</a> passed on to <a class="uri" href="Xanalys" title="wikilink">Xanalys</a> and was later acquired by <a href="Ravenbrook_Limited" title="wikilink">Ravenbrook Limited</a> on 2013-04-26 and open sourced.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Alice_(programming_language)" title="wikilink">Alice</a></li>
<li><a href="ML_programming_language" title="wikilink">ML</a></li>
<li><a href="Concurrent_ML" title="wikilink">Concurrent ML</a></li>
<li><a href="Dependent_ML" title="wikilink">Dependent ML</a></li>
<li><a href="Extensible_ML" title="wikilink">Extensible ML</a></li>
<li><a href="Extended_ML" title="wikilink">Extended ML</a></li>
<li><a href="F_Sharp_(programming_language)" title="wikilink">F#</a></li>
<li><a class="uri" href="OCaml" title="wikilink">OCaml</a></li>
<li><a class="uri" href="Ur/Web" title="wikilink">Ur/Web</a></li>
</ul>
<h2 id="references">References</h2>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.smlnj.org/sml.html">What is SML?</a></li>
<li><a href="http://www.smlnj.org/sml97.html">What is SML '97?</a></li>
<li><a href="http://www.successor-ml.org">successor ML (sML)</a> is intended to provide a vehicle for the continued evolution of ML, using Standard ML as a starting point.</li>
<li></li>
<li><a href="http://www.classes.cs.uchicago.edu/archive/2007/winter/22610-1/docs/sml-tutorial.pdf">Univ. of Chicago - SML tutorial (slides)</a></li>
<li><a href="http://www.cs.cmu.edu/~rwh/smlbook/book.pdf">Carnegie Mellon Univ. - The Book of SML</a></li>
<li><a href="http://www.cs.cmu.edu/~rwh/smlbook/examples/">Carnegie Mellon Univ. - SML - Examples</a></li>
<li><a href="http://www.lfcs.inf.ed.ac.uk/reports/97/ECS-LFCS-97-364/ECS-LFCS-97-364.pdf">University of Edinburgh - Programming in Standard ML '97: A Tutorial Introduction (pdf)</a></li>
<li><a href="http://www.dcs.ed.ac.uk/home/stg/NOTES/notes.html">University of Edinburgh - SML '97 - Online Tutorial</a></li>
</ul>

<p>"</p>

<p><a href="Category:Procedural_programming_languages" title="wikilink">Category:Procedural programming languages</a> <a href="Category:ML_programming_language_family" title="wikilink">Category:ML programming language family</a> <a href="Category:Functional_languages" title="wikilink">Category:Functional languages</a> <a href="Category:Programming_languages_created_in_1990" title="wikilink">Category:Programming languages created in 1990</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
</ol>
</section>
</body>

