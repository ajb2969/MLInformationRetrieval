   Proof of knowledge      Proof of knowledge  In [[cryptography]], a '''proof of knowledge''' is an [[interactive proof system|interactive proof]] in which the prover succeeds 'convincing' a verifier that the prover knows s omething. What it means for a machine to 'know something' is defined in terms of computation. A machine 'knows something', if this something can be computed, given the machine as an input. As the program of the prover does not necessarily spit out the knowledge itself (as is the case for zero-knowledge proofs 1 ) a machine with a different program, called the knowledge extractor is introduced to capture this idea. We are mostly interested in what can be proven by polynomial time bounded machines. In this case the set of knowledge elements is limited to a set of witnesses of some language in NP .  Let   x   x   x   be a language element of language   L   L   L   in NP, and    W   (  x  )       W  x    W(x)   the set of witnesses for x that should be accepted in the proof. This allows us to define the following relation    R  =   {   (  x  ,  w  )   :    x  ∈  L   ,   w  ∈   W   (  x  )      }       R   conditional-set   x  w    formulae-sequence    x  L     w    W  x        R=\{(x,w):x\in L,w\in W(x)\}   .  A proof of knowledge for relation   R   R   R   with knowledge error   κ   κ   \kappa   is a two party protocol with a prover   P   P   P   and a verifier   V   V   V   with the following two properties:   Completeness : if     (  x  ,  w  )   ∈  R       x  w   R    (x,w)\in R   , the prover P who knows witness   w   w   w   for   x   x   x   succeeds in convincing the verifier   V   V   V   of his knowledge. More formally    P  r   (  P   (  x  ,  w  )   ↔  V   (  x  )   →  1  )   =  1     fragments  P  r   fragments  normal-(  P   fragments  normal-(  x  normal-,  w  normal-)   normal-↔  V   fragments  normal-(  x  normal-)   normal-→  1  normal-)    1    Pr(P(x,w)\leftrightarrow V(x)\rightarrow 1)=1     Validity : Validity requires that the success probability of a knowledge extractor   E   E   E   in extracting the witness, given oracle access to a possibly malicious prover    P  ~     normal-~  P    \tilde{P}   , must be at least as high as the success probability of the prover    P  ~     normal-~  P    \tilde{P}   in convincing the verifier. This Property guarantees that no prover that doesn't know the witness can succeed in convincing the verifier.   Details on the definition  This is a more rigorous definition of Validity : 2  Let   R   R   R   be a witness relation,    W   (  x  )       W  x    W(x)   the set of all witnesses for public value   x   x   x   , and   κ   κ   \kappa   the knowledge error. A proof of knowledge is   κ   κ   \kappa   -valid if there exists a polynomial-time machine   E   E   E   , given oracle access to    P  ~     normal-~  P    \tilde{P}   , such that for every    P  ~     normal-~  P    \tilde{P}   , it is the case that      E    P  ~    (  x  )      (  x  )    ∈    W   (  x  )    ∪   {  ⊥  }           superscript  E     normal-~  P   x    x       W  x    bottom      E^{\tilde{P}(x)}(x)\in W(x)\cup\{\bot\}   and      Pr   (     E    P  ~    (  x  )      (  x  )    ∈   W   (  x  )     )    ≥    Pr   (     P  ~    (  x  )    ↔    V   (  x  )    →  1    )    -   κ   (  x  )      .       Pr       superscript  E     normal-~  P   x    x     W  x        Pr   normal-↔     normal-~  P   x    normal-→    V  x   1       κ  x      \Pr(E^{\tilde{P}(x)}(x)\in W(x))\geq\Pr(\tilde{P}(x)\leftrightarrow V(x)%
 \rightarrow 1)-\kappa(x).     The result   ⊥   bottom   \bot   signifies that the Turing machine   E   E   E   did not come to a conclusion.  The knowledge error    κ   (  x  )       κ  x    \kappa(x)   denotes the probability that the verifier   V   V   V   might accept   x   x   x   , even though the prover does in fact not know a witness   w   w   w   . The knowledge extractor   E   E   E   is used to express what is meant by the knowledge of a Turing machine . If   E   E   E   can extract   w   w   w   from    P  ~     normal-~  P    \tilde{P}   , we say that    P  ~     normal-~  P    \tilde{P}   knows the value of   w   w   w   .  This definition of the validity property is a combination of the validity and strong validity properties in. 3 For small knowledge errors    κ   (  x  )       κ  x    \kappa(x)   , such as e.g.    2   -  80      superscript  2    80     2^{-80}   or     1  /  poly    (   |  x  |   )         1  poly     x     1/\mathrm{poly}(|x|)   it can be seen as being stronger than the soundness of ordinary interactive proofs .  Relation to general interactive proofs  In order to define a specific proof of knowledge, one need not only define the language, but also the witnesses the verifier should know. In some cases proving membership in a language may be easy, while computing a specific witness may be hard. This is best explained using an example:  Let    ⟨  g  ⟩     delimited-⟨⟩  g    \langle g\rangle   be a cyclic group with generator   g   g   g   in which solving the discrete logarithm problem is believed to be hard. Deciding membership of the language    L  =   {  x  |    g  w   =  x   }       L   conditional-set  x     superscript  g  w   x      L=\{x|g^{w}=x\}   is trivial, as every   x   x   x   is in    ⟨  g  ⟩     delimited-⟨⟩  g    \langle g\rangle   . However, finding the witness   w   w   w   such that     g  w   =  x       superscript  g  w   x    g^{w}=x   holds corresponds to solving the discrete logarithm problem.  Protocols  Schnorr protocol  One of the simplest and frequently used proofs of knowledge, the proof of knowledge of a discrete logarithm , is due to Schnorr. 4 The protocol is defined for a cyclic group     G  q     subscript  G  q    G_{q}   of order   q   q   q   with generator   g   g   g   .  In order to prove knowledge of    x  =    log  g   y       x    subscript   g   y     x=\log_{g}y   , the prover interacts with the verifier as follows:   In the first round the prover commits herself to randomness   r   r   r   ; therefore the first message    t  =   g  r       t   superscript  g  r     t=g^{r}   is also called commitment .  The verifier replies with a challenge    c   c   c   chosen at random.  After receiving   c   c   c   , the prover sends the third and last message (the response )    s  =   r  +   c  x        s    r    c  x      s=r+cx   .   The verifier accepts, if     g  s   =   t   y  c         superscript  g  s     t   superscript  y  c      g^{s}=ty^{c}   .  Sigma protocols  Protocols which have the above three-move structure (commitment, challenge and response) are called sigma protocols . The Greek letter   Σ   normal-Σ   \Sigma   visualizes the flow of the protocol. Sigma protocols exist for proving various statements, such as those pertaining to discrete logarithms. Using these proofs, the prover can not only prove the knowledge of the discrete logarithm, but also that the discrete logarithm is of a specific form. For instance, it is possible to prove that two logarithms of    y  1     subscript  y  1    y_{1}   and    y  2     subscript  y  2    y_{2}   with respect to bases    g  1     subscript  g  1    g_{1}   and    g  2     subscript  g  2    g_{2}   are equal or fulfill some other linear  relation . For a and b elements of    Z  q     subscript  Z  q    Z_{q}   , we say that the prover proves knowledge of    x  1     subscript  x  1    x_{1}   and    x  2     subscript  x  2    x_{2}   such that     y  1   =    g  1   x  1    ∧   y  2    =   g  2   x  2           subscript  y  1      superscript   subscript  g  1    subscript  x  1     subscript  y  2          superscript   subscript  g  2    subscript  x  2       y_{1}=g_{1}^{x_{1}}\land y_{2}=g_{2}^{x_{2}}   and     x  2   =    a   x  1    +  b        subscript  x  2       a   subscript  x  1    b     x_{2}=ax_{1}+b   . Equality corresponds to the special case where a = 1 and b = 0. As    x  2     subscript  x  2    x_{2}   can be trivially computed from    x  1     subscript  x  1    x_{1}   this is equivalent to proving knowledge of an x such that     y  1   =    g  1  x   ∧   y  2    =     (   g  2  a   )   x    g  2  b           subscript  y  1      superscript   subscript  g  1   x    subscript  y  2            superscript   superscript   subscript  g  2   a   x    superscript   subscript  g  2   b       y_{1}=g_{1}^{x}\land y_{2}={(g_{2}^{a})}^{x}g_{2}^{b}   .  This is the intuition behind the following notation, which is commonly used to express what exactly is proven by a proof of knowledge.       P  K   {   (  x  )   :    y  1   =    g  1  x   ∧   y  2    =     (   g  2  a   )   x    g  2  b     }    ,      P  K   conditional-set  x       subscript  y  1      superscript   subscript  g  1   x    subscript  y  2            superscript   superscript   subscript  g  2   a   x    superscript   subscript  g  2   b         PK\{(x):y_{1}=g_{1}^{x}\land y_{2}={(g_{2}^{a})}^{x}g_{2}^{b}\},     states that the prover knows an x that fulfills the relation above.  Applications  Proofs of knowledge are useful tool for the construction of identification protocols, and in their non-interactive variant, signature schemes. Such schemes are:   Schnorr signature   They are also used in the construction of group signature and anonymous digital credential systems.  See also   Cryptographic protocol  Zero-knowledge proof  interactive proof system  Topics in cryptography  Zero-knowledge password proof  Soundness (interactive proof)   References    External links   Helger Lipmaa's cryptology pointers   "  Category:Cryptographic protocols     Shafi Goldwasser , Silvio Micali , and Charles Rackoff . The knowledge complexity of interactive proof-systems . Proceedings of 17th Symposium on the Theory of Computation , Providence, Rhode Island. 1985. Draft. Extended abstract ↩  Mihir Bellare , Oded Goldreich: On Defining Proofs of Knowledge . CRYPTO 1992: 390–420 ↩   C P Schnorr , Efficient identification and signatures for smart cards, in G Brassard, ed. Advances in Cryptology – Crypto '89, 239–252, Springer-Verlag , 1990. Lecture Notes in Computer Science, nr 435 ↩     