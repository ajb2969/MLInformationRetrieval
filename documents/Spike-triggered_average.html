<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="923">Spike-triggered average</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Spike-triggered average</h1>
<hr/>

<p>The <strong>Spike-triggered average (STA)</strong> is a tool for characterizing the response properties of a neuron using the <a href="action_potentials" title="wikilink">spikes</a> emitted in response to a time-varying stimulus. The STA provides an estimate of a neuron's linear <a href="receptive_field" title="wikilink">receptive field</a>. It is a useful technique for the analysis of <a href="electrophysiology" title="wikilink">electrophysiological</a> data.</p>
<figure><b>(Figure)</b>
<figcaption>Diagram showing how the STA is calculated. A stimulus (consisting here of 9 pixel values for each stimulus frame) is presented, and spikes from the neuron are recorded. The stimuli in some time window preceding each spike (here consisting of 3 time bins) are selected (orange boxes) and then averaged to obtain the STA. The STA (shown at right) indicates that this neuron is selective for a group of 3 white pixels that change spatial position on each of three consecutive stimulus frames.</figcaption>
</figure>

<p>Mathematically, the STA is the average stimulus preceding a spike.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a><a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a><a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a><a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> To compute the STA, the stimulus in the time window preceding each spike is extracted, and the resulting (spike-triggered) stimuli are averaged (see diagram). The STA provides an <a href="Bias_of_an_estimator" title="wikilink">unbiased</a> estimate of a neuron's receptive field only if the stimulus distribution is spherically symmetric (e.g., <a href="Gaussian_noise" title="wikilink">Gaussian white noise</a>).<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a><a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a><a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>

<p>The STA has been used to characterize <a href="retinal_ganglion_cells" title="wikilink">retinal ganglion cells</a>,<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a><a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> neurons in the <a href="lateral_geniculate_nucleus" title="wikilink">lateral geniculate nucleus</a> and <a href="simple_cell" title="wikilink">simple cells</a> in the <a href="striate_cortex" title="wikilink">striate cortex</a> (V1) .<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a><a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> It can be used to estimate the linear stage of the <a href="linear-nonlinear-Poisson_cascade_model" title="wikilink">linear-nonlinear-Poisson (LNP)</a> cascade model.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a></p>

<p>Spike-triggered averaging is also commonly referred to as â€œreverse correlationâ€³ or â€œwhite-noise analysisâ€. The STA is well known as the first term in the <a href="Volterra_series" title="wikilink">Volterra kernel</a> or <a href="Wiener_series" title="wikilink">Wiener kernel</a> series expansion.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> It is closely related to <a href="linear_regression" title="wikilink">linear regression</a>.</p>
<h2 id="mathematical-definition">Mathematical Definition</h2>
<h3 id="standard-sta">Standard STA</h3>

<p>Let 

<math display="inline" id="Spike-triggered_average:0">
<semantics>
<msub>
<mi>ğ±</mi>
<mi>ğ¢</mi>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>ğ±</ci>
<ci>ğ¢</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mathbf{x_{i}}
  </annotation>
</semantics>
</math>

 denote the spatio-temporal stimulus vector preceding the 

<math display="inline" id="Spike-triggered_average:1">
<semantics>
<mi>i</mi>
<annotation-xml encoding="MathML-Content">
<ci>i</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   i
  </annotation>
</semantics>
</math>

'th time bin, and 

<math display="inline" id="Spike-triggered_average:2">
<semantics>
<msub>
<mi>y</mi>
<mi>i</mi>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>y</ci>
<ci>i</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   y_{i}
  </annotation>
</semantics>
</math>

 the spike count in that bin. The stimuli can be assumed to have zero mean (i.e., 

<math display="inline" id="Spike-triggered_average:3">
<semantics>
<mrow>
<mrow>
<mi>E</mi>
<mrow>
<mo stretchy="false">[</mo>
<mi>ğ±</mi>
<mo stretchy="false">]</mo>
</mrow>
</mrow>
<mo>=</mo>
<mn>0</mn>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<times></times>
<ci>E</ci>
<apply>
<csymbol cd="latexml">delimited-[]</csymbol>
<ci>ğ±</ci>
</apply>
</apply>
<cn type="integer">0</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   E[\mathbf{x}]=0
  </annotation>
</semantics>
</math>


). If not, it can be transformed to have zero-mean by subtracting the mean stimulus from each vector. The STA is given by</p>

<p>
<math display="block" id="Spike-triggered_average:4">
<semantics>
<mrow>
<mrow>
<mi>STA</mi>
<mo>=</mo>
<mrow>
<mstyle displaystyle="false">
<mfrac>
<mn>1</mn>
<msub>
<mi>n</mi>
<mrow>
<mi>s</mi>
<mi>p</mi>
</mrow>
</msub>
</mfrac>
</mstyle>
<mrow>
<munderover>
<mo largeop="true" movablelimits="false" symmetric="true">âˆ‘</mo>
<mrow>
<mi>i</mi>
<mo>=</mo>
<mn>1</mn>
</mrow>
<mi>T</mi>
</munderover>
<mrow>
<msub>
<mi>y</mi>
<mi>i</mi>
</msub>
<msub>
<mi>ğ±</mi>
<mi>ğ¢</mi>
</msub>
</mrow>
</mrow>
</mrow>
</mrow>
<mo>,</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<ci>STA</ci>
<apply>
<times></times>
<apply>
<divide></divide>
<cn type="integer">1</cn>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>n</ci>
<apply>
<times></times>
<ci>s</ci>
<ci>p</ci>
</apply>
</apply>
</apply>
<apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<sum></sum>
<apply>
<eq></eq>
<ci>i</ci>
<cn type="integer">1</cn>
</apply>
</apply>
<ci>T</ci>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>y</ci>
<ci>i</ci>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>ğ±</ci>
<ci>ğ¢</ci>
</apply>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mathrm{STA}=\tfrac{1}{n_{sp}}\sum_{i=1}^{T}y_{i}\mathbf{x_{i}},
  </annotation>
</semantics>
</math>

 where 

<math display="inline" id="Spike-triggered_average:5">
<semantics>
<mrow>
<msub>
<mi>n</mi>
<mrow>
<mi>s</mi>
<mi>p</mi>
</mrow>
</msub>
<mo>=</mo>
<mrow>
<mo largeop="true" symmetric="true">âˆ‘</mo>
<msub>
<mi>y</mi>
<mi>i</mi>
</msub>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>n</ci>
<apply>
<times></times>
<ci>s</ci>
<ci>p</ci>
</apply>
</apply>
<apply>
<sum></sum>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>y</ci>
<ci>i</ci>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   n_{sp}=\sum y_{i}
  </annotation>
</semantics>
</math>

, the total number of spikes.</p>

<p>This equation is more easily expressed in matrix notation: let 

<math display="inline" id="Spike-triggered_average:6">
<semantics>
<mi>X</mi>
<annotation-xml encoding="MathML-Content">
<ci>X</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   X
  </annotation>
</semantics>
</math>

 denote a matrix whose 

<math display="inline" id="Spike-triggered_average:7">
<semantics>
<mi>i</mi>
<annotation-xml encoding="MathML-Content">
<ci>i</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   i
  </annotation>
</semantics>
</math>

'th row is the stimulus vector 

<math display="inline" id="Spike-triggered_average:8">
<semantics>
<msubsup>
<mi>ğ±</mi>
<mi>ğ¢</mi>
<mi>ğ“</mi>
</msubsup>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>ğ±</ci>
<ci>ğ¢</ci>
</apply>
<ci>ğ“</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mathbf{x_{i}^{T}}
  </annotation>
</semantics>
</math>


 and let 

<math display="inline" id="Spike-triggered_average:9">
<semantics>
<mi>ğ²</mi>
<annotation-xml encoding="MathML-Content">
<ci>ğ²</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mathbf{y}
  </annotation>
</semantics>
</math>

 denote a column vector whose 

<math display="inline" id="Spike-triggered_average:10">
<semantics>
<mi>i</mi>
<annotation-xml encoding="MathML-Content">
<ci>i</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   i
  </annotation>
</semantics>
</math>

th element is 

<math display="inline" id="Spike-triggered_average:11">
<semantics>
<msub>
<mi>y</mi>
<mi>i</mi>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>y</ci>
<ci>i</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   y_{i}
  </annotation>
</semantics>
</math>

. Then the STA can be written</p>

<p>
<math display="block" id="Spike-triggered_average:12">
<semantics>
<mrow>
<mrow>
<mi>STA</mi>
<mo>=</mo>
<mrow>
<mstyle displaystyle="false">
<mfrac>
<mn>1</mn>
<msub>
<mi>n</mi>
<mrow>
<mi>s</mi>
<mi>p</mi>
</mrow>
</msub>
</mfrac>
</mstyle>
<msup>
<mi>X</mi>
<mi>T</mi>
</msup>
<mi>ğ²</mi>
</mrow>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<ci>STA</ci>
<apply>
<times></times>
<apply>
<divide></divide>
<cn type="integer">1</cn>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>n</ci>
<apply>
<times></times>
<ci>s</ci>
<ci>p</ci>
</apply>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>X</ci>
<ci>T</ci>
</apply>
<ci>ğ²</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mathrm{STA}=\tfrac{1}{n_{sp}}X^{T}\mathbf{y}.
  </annotation>
</semantics>
</math>
</p>
<h3 id="whitened-sta">Whitened STA</h3>

<p>If the stimulus is not <a href="white_noise" title="wikilink">white noise</a>, but instead has non-zero correlation across space or time, the standard STA provides a biased estimate of the linear receptive field.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a> It may therefore be appropriate to whiten the STA by the inverse of the stimulus covariance matrix. The resulting estimator is known as the whitened STA, which is given by</p>

<p>
<math display="block" id="Spike-triggered_average:13">
<semantics>
<mrow>
<mrow>
<msub>
<mi>STA</mi>
<mi>w</mi>
</msub>
<mo>=</mo>
<mrow>
<msup>
<mrow>
<mo>(</mo>
<mrow>
<mstyle displaystyle="false">
<mfrac>
<mn>1</mn>
<mi>T</mi>
</mfrac>
</mstyle>
<mrow>
<munderover>
<mo largeop="true" movablelimits="false" symmetric="true">âˆ‘</mo>
<mrow>
<mi>i</mi>
<mo>=</mo>
<mn>1</mn>
</mrow>
<mi>T</mi>
</munderover>
<mrow>
<msub>
<mi>ğ±</mi>
<mi>ğ¢</mi>
</msub>
<mmultiscripts>
<mi>ğ±</mi>
<mi>ğ¢</mi>
<none></none>
<none></none>
<mi>T</mi>
</mmultiscripts>
</mrow>
</mrow>
</mrow>
<mo>)</mo>
</mrow>
<mrow>
<mo>-</mo>
<mn>1</mn>
</mrow>
</msup>
<mrow>
<mo>(</mo>
<mrow>
<mstyle displaystyle="false">
<mfrac>
<mn>1</mn>
<msub>
<mi>n</mi>
<mrow>
<mi>s</mi>
<mi>p</mi>
</mrow>
</msub>
</mfrac>
</mstyle>
<mrow>
<munderover>
<mo largeop="true" movablelimits="false" symmetric="true">âˆ‘</mo>
<mrow>
<mi>i</mi>
<mo>=</mo>
<mn>1</mn>
</mrow>
<mi>T</mi>
</munderover>
<mrow>
<msub>
<mi>y</mi>
<mi>i</mi>
</msub>
<msub>
<mi>ğ±</mi>
<mi>ğ¢</mi>
</msub>
</mrow>
</mrow>
</mrow>
<mo>)</mo>
</mrow>
</mrow>
</mrow>
<mo>,</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>STA</ci>
<ci>w</ci>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<times></times>
<apply>
<divide></divide>
<cn type="integer">1</cn>
<ci>T</ci>
</apply>
<apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<sum></sum>
<apply>
<eq></eq>
<ci>i</ci>
<cn type="integer">1</cn>
</apply>
</apply>
<ci>T</ci>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>ğ±</ci>
<ci>ğ¢</ci>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>ğ±</ci>
<ci>ğ¢</ci>
</apply>
<ci>T</ci>
</apply>
</apply>
</apply>
</apply>
<apply>
<minus></minus>
<cn type="integer">1</cn>
</apply>
</apply>
<apply>
<times></times>
<apply>
<divide></divide>
<cn type="integer">1</cn>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>n</ci>
<apply>
<times></times>
<ci>s</ci>
<ci>p</ci>
</apply>
</apply>
</apply>
<apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<sum></sum>
<apply>
<eq></eq>
<ci>i</ci>
<cn type="integer">1</cn>
</apply>
</apply>
<ci>T</ci>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>y</ci>
<ci>i</ci>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>ğ±</ci>
<ci>ğ¢</ci>
</apply>
</apply>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mathrm{STA}_{w}=\left(\tfrac{1}{T}\sum_{i=1}^{T}\mathbf{x_{i}}\mathbf{x_{i}}^%
{T}\right)^{-1}\left(\tfrac{1}{n_{sp}}\sum_{i=1}^{T}y_{i}\mathbf{x_{i}}\right),
  </annotation>
</semantics>
</math>

 where the first term is the inverse covariance matrix of the raw stimuli and the second is the standard STA. In matrix notation, this can be written</p>

<p>
<math display="block" id="Spike-triggered_average:14">
<semantics>
<mrow>
<mrow>
<msub>
<mi>STA</mi>
<mi>w</mi>
</msub>
<mo>=</mo>
<mrow>
<mstyle displaystyle="false">
<mfrac>
<mi>T</mi>
<msub>
<mi>n</mi>
<mrow>
<mi>s</mi>
<mi>p</mi>
</mrow>
</msub>
</mfrac>
</mstyle>
<msup>
<mrow>
<mo>(</mo>
<mrow>
<msup>
<mi>X</mi>
<mi>T</mi>
</msup>
<mi>X</mi>
</mrow>
<mo>)</mo>
</mrow>
<mrow>
<mo>-</mo>
<mn>1</mn>
</mrow>
</msup>
<msup>
<mi>X</mi>
<mi>T</mi>
</msup>
<mi>ğ²</mi>
</mrow>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>STA</ci>
<ci>w</ci>
</apply>
<apply>
<times></times>
<apply>
<divide></divide>
<ci>T</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>n</ci>
<apply>
<times></times>
<ci>s</ci>
<ci>p</ci>
</apply>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>X</ci>
<ci>T</ci>
</apply>
<ci>X</ci>
</apply>
<apply>
<minus></minus>
<cn type="integer">1</cn>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>X</ci>
<ci>T</ci>
</apply>
<ci>ğ²</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mathrm{STA}_{w}=\tfrac{T}{n_{sp}}\left(X^{T}X\right)^{-1}X^{T}\mathbf{y}.
  </annotation>
</semantics>
</math>

 The whitened STA is unbiased only if the stimulus distribution can be described by a correlated Gaussian distribution <a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a> (correlated Gaussian distributions are elliptically symmetric, i.e. can be made spherically symmetric by a linear transformation, but not all elliptically symmetric distributions are Gaussian). This is a weaker condition than spherical symmetry.</p>

<p>The whitened STA is equivalent to <a href="linear_regression" title="wikilink">linear least-squares regression</a> of the stimulus against the spike train.</p>
<h3 id="regularized-sta">Regularized STA</h3>

<p>In practice, it may be necessary to <a href="Regularization_(mathematics)" title="wikilink">regularize</a> the whitened STA, since whitening amplifies noise along stimulus dimensions that are poorly explored by the stimulus (i.e., axes along which the stimulus has low variance). A common approach to this problem is <a href="Tikhonov_regularization" title="wikilink">ridge regression</a>. The regularized STA, computed using ridge regression, can be written</p>

<p>
<math display="block" id="Spike-triggered_average:15">
<semantics>
<mrow>
<mrow>
<msub>
<mi>STA</mi>
<mrow>
<mi>r</mi>
<mi>i</mi>
<mi>d</mi>
<mi>g</mi>
<mi>e</mi>
</mrow>
</msub>
<mo>=</mo>
<mrow>
<mstyle displaystyle="false">
<mfrac>
<mi>T</mi>
<msub>
<mi>n</mi>
<mrow>
<mi>s</mi>
<mi>p</mi>
</mrow>
</msub>
</mfrac>
</mstyle>
<msup>
<mrow>
<mo>(</mo>
<mrow>
<mrow>
<msup>
<mi>X</mi>
<mi>T</mi>
</msup>
<mi>X</mi>
</mrow>
<mo>+</mo>
<mrow>
<mi>Î»</mi>
<mi>I</mi>
</mrow>
</mrow>
<mo>)</mo>
</mrow>
<mrow>
<mo>-</mo>
<mn>1</mn>
</mrow>
</msup>
<msup>
<mi>X</mi>
<mi>T</mi>
</msup>
<mi>ğ²</mi>
</mrow>
</mrow>
<mo>,</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>STA</ci>
<apply>
<times></times>
<ci>r</ci>
<ci>i</ci>
<ci>d</ci>
<ci>g</ci>
<ci>e</ci>
</apply>
</apply>
<apply>
<times></times>
<apply>
<divide></divide>
<ci>T</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>n</ci>
<apply>
<times></times>
<ci>s</ci>
<ci>p</ci>
</apply>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<plus></plus>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>X</ci>
<ci>T</ci>
</apply>
<ci>X</ci>
</apply>
<apply>
<times></times>
<ci>Î»</ci>
<ci>I</ci>
</apply>
</apply>
<apply>
<minus></minus>
<cn type="integer">1</cn>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>X</ci>
<ci>T</ci>
</apply>
<ci>ğ²</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mathrm{STA}_{ridge}=\tfrac{T}{n_{sp}}\left(X^{T}X+\lambda I\right)^{-1}X^{T}%
\mathbf{y},
  </annotation>
</semantics>
</math>

 where 

<math display="inline" id="Spike-triggered_average:16">
<semantics>
<mi>I</mi>
<annotation-xml encoding="MathML-Content">
<ci>I</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   I
  </annotation>
</semantics>
</math>

 denotes the identity matrix and 

<math display="inline" id="Spike-triggered_average:17">
<semantics>
<mi>Î»</mi>
<annotation-xml encoding="MathML-Content">
<ci>Î»</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \lambda
  </annotation>
</semantics>
</math>

 is the ridge parameter controlling the amount of regularization. This procedure has a simple Bayesian interpretation: ridge regression is equivalent to placing a prior on the STA elements that says they are drawn i.i.d. from a zero-mean Gaussian prior with covariance proportional to the identity matrix. The ridge parameter sets the inverse variance of this prior, and is usually fit by <a href="cross-validation_(statistics)" title="wikilink">cross-validation</a> or <a href="Empirical_Bayes_method" title="wikilink">empirical Bayes</a>.</p>
<h2 id="statistical-properties">Statistical Properties</h2>

<p>For responses generated according to an <a href="linear-nonlinear-Poisson_cascade_model" title="wikilink">LNP</a> model, the whitened STA provides an estimate of the subspace spanned by the linear receptive field. The properties of this estimate are as follows</p>
<h3 id="consistency">Consistency</h3>

<p>The whitened STA is a <a href="consistent_estimator" title="wikilink">consistent estimator</a>, i.e., it converges to the true linear subspace, if</p>
<ol>
<li>The stimulus distribution 

<math display="inline" id="Spike-triggered_average:18">
<semantics>
<mrow>
<mi>P</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>ğ±</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<ci>P</ci>
<ci>ğ±</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   P(\mathbf{x})
  </annotation>
</semantics>
</math>


 is <a href="Elliptical_distribution" title="wikilink">elliptically symmetric</a>, e.g., <a href="Gaussian_Distribution" title="wikilink">Gaussian</a>. (<a href="Bussgang_theorem" title="wikilink">Bussgang's theorem</a>)</li>
<li>The expected STA is not zero, i.e., nonlinearity induces a shift in the spike-triggered stimuli.<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a></li>
</ol>
<h3 id="optimality">Optimality</h3>

<p>The whitened STA is an asymptotically <a href="efficient_estimator" title="wikilink">efficient estimator</a> if</p>
<ol>
<li>The stimulus distribution 

<math display="inline" id="Spike-triggered_average:19">
<semantics>
<mrow>
<mi>P</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>ğ±</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<ci>P</ci>
<ci>ğ±</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   P(\mathbf{x})
  </annotation>
</semantics>
</math>

 is elliptically symmetric</li>
<li>The neuron's nonlinear response function is the exponential, 

<math display="inline" id="Spike-triggered_average:20">
<semantics>
<mrow>
<mi>e</mi>
<mi>x</mi>
<mi>p</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>x</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<ci>e</ci>
<ci>x</ci>
<ci>p</ci>
<ci>x</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   exp(x)
  </annotation>
</semantics>
</math>

.<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a></li>
</ol>

<p>For arbitrary stimuli, the STA is generally not consistent or efficient. For such cases, <a href="maximum_likelihood" title="wikilink">maximum likelihood</a> and <a href="Mutual_information" title="wikilink">information-based</a> estimators <a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a><a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a><a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a> have been developed that are both consistent and efficient.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Spike-triggered_covariance" title="wikilink">Spike-triggered covariance</a></li>
<li><a href="Linear-nonlinear-Poisson_cascade_model" title="wikilink">Linear-nonlinear-Poisson cascade model</a></li>
<li><a href="Sliced_inverse_regression" title="wikilink">Sliced inverse regression</a></li>
</ul>
<h2 id="references">References</h2>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://pillowlab.cps.utexas.edu/code_STC.html">Matlab code for computing the STA</a></li>
</ul>

<p>"</p>

<p><a class="uri" href="Category:Neuroscience" title="wikilink">Category:Neuroscience</a> <a class="uri" href="Category:Neurophysiology" title="wikilink">Category:Neurophysiology</a> <a class="uri" href="Category:Electrophysiology" title="wikilink">Category:Electrophysiology</a> <a href="Category:Computational_neuroscience" title="wikilink">Category:Computational neuroscience</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">de Boer and Kuyper (1968) Triggered Correlation. <em>IEEE Transact. Biomed. Eng.</em>, 15:169-179<a href="#fnref1">â†©</a></li>
<li id="fn2">Marmarelis, P. Z. and Naka, K. (1972). White-noise analysis of a neuron chain: an application of the Wiener theory. <em>Science</em>, 175:1276-1278<a href="#fnref2">â†©</a></li>
<li id="fn3">Chichilnisky, E. J. (2001). A simple white noise analysis of neuronal light responses. <em>Network: Computation in Neural Systems</em>, 12:199-213<a href="#fnref3">â†©</a></li>
<li id="fn4">Simoncelli, E. P., Paninski, L., Pillow, J. &amp; Swartz, O. (2004). <a href="http://www.cns.nyu.edu/~lcv/pubs/makeAbs.php?loc=Simoncelli03c">"Characterization of neural responses with stochastic stimuli"</a>. In M. Gazzaniga (Ed.) <em>The Cognitive Neurosciences, III</em> (pp. 327-338). MIT press.<a href="#fnref4">â†©</a></li>
<li id="fn5"></li>
<li id="fn6">Paninski, L. (2003). Convergence properties of some spike-triggered analysis techniques. <em>Network: Computation in Neural Systems</em> 14:437-464<a href="#fnref6">â†©</a></li>
<li id="fn7">Sharpee, T.O., Rust, N.C., &amp; Bialek, W. (2004). Analyzing neural responses to natural signals: Maximally informative dimensions. <em>Neural Computation</em> 16:223-250<a href="#fnref7">â†©</a></li>
<li id="fn8">Sakai and Naka (1987).<a href="#fnref8">â†©</a></li>
<li id="fn9">Meister, Pine, and Baylor (1994).<a href="#fnref9">â†©</a></li>
<li id="fn10">Jones and Palmer (1987).<a href="#fnref10">â†©</a></li>
<li id="fn11">McLean and Palmer (1989).<a href="#fnref11">â†©</a></li>
<li id="fn12"></li>
<li id="fn13">Lee and Schetzen (1965). Measurement of the Wiener kernels of a non- linear system by cross-correlation. <em>International Journal of Control, First Series</em>, 2:237-254<a href="#fnref13">â†©</a></li>
<li id="fn14"></li>
<li id="fn15"></li>
<li id="fn16"></li>
<li id="fn17"></li>
<li id="fn18"></li>
<li id="fn19"></li>
<li id="fn20">Kouh M. &amp; Sharpee, T.O. (2009). Estimating linear-nonlinear models using RÃ©nyi divergences, <em>Network: Computation in Neural Systems</em> 20(2): 49â€“68<a href="#fnref20">â†©</a></li>
</ol>
</section>
</body>
</html>
