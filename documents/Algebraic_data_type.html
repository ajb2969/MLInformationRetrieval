<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1666">Algebraic data type</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Algebraic data type</h1>
<style>
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
<style>
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
</body></html>
<body>
<hr/>

<p>In <a href="computer_programming" title="wikilink">computer programming</a>, particularly <a href="functional_programming" title="wikilink">functional programming</a> and <a href="type_theory" title="wikilink">type theory</a>, an <strong>algebraic data type</strong> is a kind of <a href="composite_type" title="wikilink">composite type</a>, i.e. a type formed by combining other types. Two common classes of algebraic type are <a href="product_type" title="wikilink">product types</a>—i.e. <a href="tuple" title="wikilink">tuples</a> and <a href="record_(computer_science)" title="wikilink">records</a>—and <a href="sum_type" title="wikilink">sum types</a>, also called tagged or disjoint unions or <em>variant types</em>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>

<p>The <a href="value_(computer_science)" title="wikilink">values</a> of a product type typically contain several values, called <em>fields</em>. All values of that type have the same combination of field types. The set of all possible values of a product type is the <a href="Cartesian_product" title="wikilink">set-theoretical product</a> of the sets of all possible values of its field types.</p>

<p>The values of a sum type are typically grouped into several classes, called <em>variants</em>. A value of a variant type is usually created with a quasi-functional entity called a <em>constructor</em>. Each variant has its own constructor, which takes a specified number of arguments with specified types. The set of all possible values of a sum type is the set-theoretical sum, i.e. the <a href="disjoint_union" title="wikilink">disjoint union</a>, of the sets of all possible values of its variants. <a href="Enumerated_type" title="wikilink">Enumerated types</a> are a special case of sum types in which the constructors take no arguments, as exactly one value is defined for each type.</p>

<p>Values of algebraic types are analyzed with <a href="pattern_matching" title="wikilink">pattern matching</a>, which identifies a value by its constructor or field names and extracts the data it contains.</p>

<p>Algebraic data types were introduced in <a href="Hope_(programming_language)" title="wikilink">Hope</a>, a small functional programming language developed in the 1970s at Edinburgh University.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>
<h2 id="examples">Examples</h2>

<p>One of the most common examples of an algebraic data type is the singly linked list. A list type is a sum type with two variants, <code>Nil</code> for an empty list and <code>Cons ''x'' ''xs''</code> for the combination of a new element <em>x</em> with a list <em>xs</em> to create a new list:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">List</span> a <span class="fu">=</span> <span class="dt">Nil</span> <span class="fu">|</span> <span class="dt">Cons</span> a (<span class="dt">List</span> a)</code></pre></div>

<p><code>Cons</code> is an abbreviation of <em>cons</em>truct. Many languages have special syntax for lists. For example, Haskell and ML use <code>[]</code> for <code>Nil</code>, <code>:</code> or <code>::</code> for <code>Cons</code>, and square brackets for entire lists. So <code>Cons 1 (Cons 2 (Cons 3 Nil))</code> would normally be written as <code>1:2:3:[]</code> or <code>[1,2,3]</code> in Haskell, or as <code>1::2::3::[]</code> or <code>[1;2;3]</code> in ML.</p>

<p>For another example, in <a href="Haskell_(programming_language)" title="wikilink">Haskell</a> we can define a new algebraic data type, <code>Tree</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Tree</span> <span class="fu">=</span> <span class="dt">Empty</span>
          <span class="fu">|</span> <span class="dt">Leaf</span> <span class="dt">Int</span>
          <span class="fu">|</span> <span class="dt">Node</span> <span class="dt">Tree</span> <span class="dt">Tree</span></code></pre></div>

<p>Here, <code>Empty</code> represents an empty tree, <code>Leaf</code> contains a piece of data, and <code>Node</code> organizes the data into branches.</p>

<p>In most languages that support algebraic data types, it is possible to define <a href="parametric_polymorphism" title="wikilink">parametric</a> types. Examples are given later in this article.</p>

<p>Somewhat similar to a function, a data constructor is applied to arguments of an appropriate type, yielding an instance of the data type to which the type constructor belongs. For instance, the data constructor <code>Leaf</code> is logically a function <code>Int -&gt; Tree</code>, meaning that giving an integer as an argument to <code>Leaf</code> produces a value of the type <code>Tree</code>. As <code>Node</code> takes two arguments of the type <code>Tree</code> itself, the datatype is <a href="recursive_type" title="wikilink">recursive</a>.</p>

<p>Operations on algebraic data types can be defined by using <a href="pattern_matching" title="wikilink">pattern matching</a> to retrieve the arguments. For example, consider a function to find the depth of a <code>Tree</code>, given here in Haskell:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot"> depth ::</span> <span class="dt">Tree</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
 depth <span class="dt">Empty</span> <span class="fu">=</span> <span class="dv">0</span>
 depth (<span class="dt">Leaf</span> n) <span class="fu">=</span> <span class="dv">1</span>
 depth (<span class="dt">Node</span> l r) <span class="fu">=</span> <span class="dv">1</span> <span class="fu">+</span> max (depth l) (depth r)</code></pre></div>

<p>Thus, a <code>Tree</code> given to <code>depth</code> can be constructed using any of <code>Empty</code>, <code>Leaf</code> or <code>Node</code> and we must match for any of them respectively to deal with all cases. In case of <code>Node</code>, the pattern extracts the subtrees <code>l</code> and <code>r</code> for further processing.</p>

<p>Algebraic data types are particularly well-suited to the implementation of <a href="abstract_syntax" title="wikilink">abstract syntax</a>. For instance, the following algebraic data type describes a simple language representing numerical expressions:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Expression</span> <span class="fu">=</span> <span class="dt">Number</span> <span class="dt">Int</span>
                <span class="fu">|</span> <span class="dt">Add</span> <span class="dt">Expression</span> <span class="dt">Expression</span>
                <span class="fu">|</span> <span class="dt">Minus</span> <span class="dt">Expression</span>
                <span class="fu">|</span> <span class="dt">Mult</span> <span class="dt">Expression</span> <span class="dt">Expression</span>
                <span class="fu">|</span> <span class="dt">Divide</span> <span class="dt">Expression</span> <span class="dt">Expression</span></code></pre></div>

<p>An element of such a data type would have a form such as <code>Mult (Add (Number 4) (Minus (Number 1))) (Number 2)</code>.</p>

<p>Writing an evaluation function for this language is a simple exercise; however, more complex transformations also become feasible. For instance, an optimization pass in a compiler might be written as a function taking an abstract expression as input and returning an optimized form.</p>
<h2 id="explanation">Explanation</h2>

<p>What is happening is that we have a datatype, which can be “one of several types of things.” Each “type of thing” is associated with an identifier called a <em>constructor</em>, which can be thought of as a kind of tag for that kind of data. Each constructor can carry with it a different type of data. A constructor could carry no data at all (e.g. "Empty" in the example above), carry one piece of data (e.g. “Leaf” has one Int value), or multiple pieces of data (e.g. “Node” has two Tree values).</p>

<p>When we want to do something with a value of this Tree algebraic data type, we <em>deconstruct</em> it using a process known as <em>pattern matching.</em> It involves <em>matching</em> the data with a series of <em>patterns</em>. The example function "depth" above pattern-matches its argument with three patterns. When the function is called, it finds the first pattern that matches its argument, performs any variable bindings that are found in the pattern, and evaluates the expression corresponding to the pattern.</p>

<p>Each pattern has a form that resembles the structure of some possible value of this datatype. The first pattern above simply matches values of the constructor Empty. The second pattern above matches values of the constructor Leaf. Patterns are recursive, so then the data that is associated with that constructor is matched with the pattern "n". In this case, a lowercase identifier represents a pattern that matches any value, which then is bound to a variable of that name — in this case, a variable “<code>n</code>” is bound to the integer value stored in the data type — to be used in the expression to be evaluated.</p>

<p>The recursion in patterns in this example are trivial, but a possible more complex recursive pattern would be something like <code><source enclose="none" lang="lisp">Node (Node (Leaf 4) x) (Node y (Node Empty z))</source></code>. Recursive patterns several layers deep are used for example in balancing <a href="red-black_tree" title="wikilink">red-black trees</a>, which involve cases that require looking at colors several layers deep.</p>

<p>The example above is operationally equivalent to the following pseudocode:</p>

<p><code>switch on (data.constructor)</code><br/>
<code>  case Empty:</code><br/>
<code>    return 0</code><br/>
<code>  case Leaf:</code><br/>
<code>    let n = data.field1</code><br/>
<code>    return 1</code><br/>
<code>  case Node:</code><br/>
<code>    let l = data.field1</code><br/>
<code>    let r = data.field2</code><br/>
<code>    return 1 + max (depth l) (depth r)</code></p>

<p>The comparison of this with pattern matching will point out some of the advantages of algebraic data types and pattern matching. First is <a href="type_safety" title="wikilink">type safety</a>. The pseudocode above relies on the diligence of the programmer to not access <code>field2</code> when the constructor is a Leaf, for example. Also, the type of <code>field1</code> is different for Leaf and Node (for Leaf it is <code>Int</code>; for Node it is <code>Tree</code>), so the type system would have difficulties assigning a static type to it in a safe way in a traditional <a href="record_(computer_science)" title="wikilink">record</a> data structure. However, in pattern matching, the type of each extracted value is checked based on the types declared by the relevant constructor, and how many values you can extract is known based on the constructor, so it does not face these problems.</p>

<p>Second, in pattern matching, the compiler statically checks that all cases are handled. If one of the cases of the “depth” function above were missing, the compiler would issue a warning, indicating that a case is not handled. This task may seem easy for the simple patterns above, but with many complicated recursive patterns, the task becomes difficult for the average human (or compiler, if it has to check arbitrary nested if-else constructs) to handle. Similarly, there may be patterns which never match (i.e. it is already covered by previous patterns), and the compiler can also check and issue warnings for these, as they may indicate an error in reasoning.</p>

<p>Do not confuse these patterns with <a href="regular_expression" title="wikilink">regular expression</a> patterns used in string pattern matching. The purpose is similar — to check whether a piece of data matches certain constraints, and if so, extract relevant parts of it for processing — but the mechanism is very different. This kind of pattern matching on algebraic data types matches on the structural properties of an object rather than on the character sequence of strings.</p>
<h2 id="theory">Theory</h2>

<p>A general algebraic data type is a possibly recursive <a href="sum_type" title="wikilink">sum type</a> of <a href="product_type" title="wikilink">product types</a>. Each constructor tags a product type to separate it from others, or if there is only one constructor, the data type is a product type. Further, the parameter types of a constructor are the factors of the product type. A parameterless constructor corresponds to the <a href="empty_product" title="wikilink">empty product</a>. If a datatype is recursive, the entire sum of products is wrapped in a <a href="recursive_type" title="wikilink">recursive type</a>, and each constructor also rolls the datatype into the recursive type.</p>

<p>For example, the Haskell datatype:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"> <span class="kw">data</span> <span class="dt">List</span> a <span class="fu">=</span> <span class="dt">Nil</span> <span class="fu">|</span> <span class="dt">Cons</span> a (<span class="dt">List</span> a)</code></pre></div>

<p>is represented in <a href="type_theory" title="wikilink">type theory</a> as 

<math display="inline" id="Algebraic_data_type:0">
 <semantics>
  <mrow>
   <mrow>
    <mi>λ</mi>
    <mi>α</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mrow>
     <mi>μ</mi>
     <mi>β</mi>
     <mn>.1</mn>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>α</mi>
     <mo>×</mo>
     <mi>β</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>α</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>μ</ci>
      <ci>β</ci>
      <cn type="float">.1</cn>
     </apply>
     <apply>
      <times></times>
      <ci>α</ci>
      <ci>β</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda\alpha.\mu\beta.1+\alpha\times\beta
  </annotation>
 </semantics>
</math>

 with constructors 

<math display="inline" id="Algebraic_data_type:1">
 <semantics>
  <mrow>
   <msub>
    <mi>nil</mi>
    <mi>α</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mpadded width="+5pt">
     <mi>roll</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>inl</mi>
      </mpadded>
      <mrow>
       <mo stretchy="false">⟨</mo>
       <mo stretchy="false">⟩</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>nil</ci>
     <ci>α</ci>
    </apply>
    <apply>
     <times></times>
     <ci>roll</ci>
     <apply>
      <times></times>
      <ci>inl</ci>
      <list></list>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{nil}_{\alpha}=\mathrm{roll}\ (\mathrm{inl}\ \langle\rangle)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Algebraic_data_type:2">
 <semantics>
  <mrow>
   <mrow>
    <mpadded width="+5pt">
     <msub>
      <mi>cons</mi>
      <mi>α</mi>
     </msub>
    </mpadded>
    <mpadded width="+5pt">
     <mi>x</mi>
    </mpadded>
    <mi>l</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mpadded width="+5pt">
     <mi>roll</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>inr</mi>
      </mpadded>
      <mrow>
       <mo stretchy="false">⟨</mo>
       <mi>x</mi>
       <mo>,</mo>
       <mi>l</mi>
       <mo stretchy="false">⟩</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>cons</ci>
      <ci>α</ci>
     </apply>
     <ci>x</ci>
     <ci>l</ci>
    </apply>
    <apply>
     <times></times>
     <ci>roll</ci>
     <apply>
      <times></times>
      <ci>inr</ci>
      <list>
       <ci>x</ci>
       <ci>l</ci>
      </list>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{cons}_{\alpha}\ x\ l=\mathrm{roll}\ (\mathrm{inr}\ \langle x,l\rangle)
  </annotation>
 </semantics>
</math>

.</p>

<p>The Haskell List datatype can also be represented in type theory in a slightly different form, as follows: 

<math display="inline" id="Algebraic_data_type:3">
 <semantics>
  <mrow>
   <mrow>
    <mi>μ</mi>
    <mi>ϕ</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mrow>
     <mi>λ</mi>
     <mi>α</mi>
     <mn>.1</mn>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mrow>
      <mi>α</mi>
      <mo>×</mo>
      <mpadded width="+5pt">
       <mi>ϕ</mi>
      </mpadded>
     </mrow>
     <mi>α</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <times></times>
     <ci>μ</ci>
     <ci>ϕ</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>λ</ci>
      <ci>α</ci>
      <cn type="float">.1</cn>
     </apply>
     <apply>
      <times></times>
      <apply>
       <times></times>
       <ci>α</ci>
       <ci>ϕ</ci>
      </apply>
      <ci>α</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu\phi.\lambda\alpha.1+\alpha\times\phi\ \alpha
  </annotation>
 </semantics>
</math>

. (Note how the 

<math display="inline" id="Algebraic_data_type:4">
 <semantics>
  <mi>μ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>μ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Algebraic_data_type:5">
 <semantics>
  <mi>λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda
  </annotation>
 </semantics>
</math>

 constructs are reversed relative to the original.) The original formation specified a type function whose body was a recursive type; the revised version specifies a recursive function on types. (We use the type variable 

<math display="inline" id="Algebraic_data_type:6">
 <semantics>
  <mi>ϕ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϕ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi
  </annotation>
 </semantics>
</math>

 to suggest a function rather than a "base type" like 

<math display="inline" id="Algebraic_data_type:7">
 <semantics>
  <mi>β</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>β</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta
  </annotation>
 </semantics>
</math>

, since 

<math display="inline" id="Algebraic_data_type:8">
 <semantics>
  <mi>ϕ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϕ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi
  </annotation>
 </semantics>
</math>

 is like a Greek "f".) Note that we must also now apply the function 

<math display="inline" id="Algebraic_data_type:9">
 <semantics>
  <mi>ϕ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϕ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi
  </annotation>
 </semantics>
</math>

 to its argument type 

<math display="inline" id="Algebraic_data_type:10">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>

 in the body of the type.</p>

<p>For the purposes of the List example, these two formulations are not significantly different; but the second form allows one to express so-called <a href="nested_data_type" title="wikilink">nested data types</a>, i.e., those where the recursive type differs parametrically from the original. (For more information on nested data types, see the works of <a href="Richard_Bird_(computer_scientist)" title="wikilink">Richard Bird</a>, <a href="Lambert_Meertens" title="wikilink">Lambert Meertens</a> and Ross Paterson.)</p>

<p>In <a href="set_theory" title="wikilink">set theory</a> the equivalent of a sum type is a <a href="disjoint_union" title="wikilink">disjoint union</a> – a set whose elements are pairs consisting of a tag (equivalent to a constructor) and an object of a type corresponding to the tag (equivalent to the constructor arguments).</p>
<h2 id="programming-languages-with-algebraic-data-types">Programming languages with algebraic data types</h2>

<p>The following programming languages have algebraic data types as a first class notion:</p>
<ul>
<li><a href="Clean_(programming_language)" title="wikilink">Clean</a></li>
<li><a href="Ceylon_(programming_language)" title="wikilink">Ceylon</a></li>
<li><a href="D_(programming_language)" title="wikilink">D</a></li>
<li><a href="Elm_(programming_language)" title="wikilink">Elm</a></li>
<li><a href="F_Sharp_(programming_language)" title="wikilink">F#</a></li>
<li><a href="Haskell_(programming_language)" title="wikilink">Haskell</a></li>
<li><a class="uri" href="Haxe" title="wikilink">Haxe</a></li>
<li><a href="Hope_(programming_language)" title="wikilink">Hope</a></li>
<li><a href="Julia_(programming_language)" title="wikilink">Julia</a></li>
<li><a href="Language_Of_Temporal_Ordering_Specification" title="wikilink">LOTOS</a></li>
<li><a href="Limbo_(programming_language)" title="wikilink">Limbo</a></li>
<li><a href="Mercury_(programming_language)" title="wikilink">Mercury</a></li>
<li><a href="Miranda_(programming_language)" title="wikilink">Miranda</a></li>
<li><a class="uri" href="Nemerle" title="wikilink">Nemerle</a></li>
<li><a class="uri" href="OCaml" title="wikilink">OCaml</a></li>
<li><a href="Opa_(programming_language)" title="wikilink">Opa</a></li>
<li><a href="Racket_(programming_language)" title="wikilink">Racket</a></li>
<li><a href="Rust_(programming_language)" title="wikilink">Rust</a></li>
<li><a href="Scala_(programming_language)" title="wikilink">Scala</a></li>
<li><a href="Shen_(programming_language)" title="wikilink">Shen</a></li>
<li><a href="Standard_ML" title="wikilink">Standard ML</a></li>
<li><a href="Swift_(Apple_programming_language)" title="wikilink">Swift</a></li>
<li><a href="Tom_(pattern_matching_language)" title="wikilink">Tom</a></li>
<li><a href="Visual_Prolog" title="wikilink">Visual Prolog</a></li>
</ul>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Tagged_union" title="wikilink">Tagged union</a></li>
<li><a href="Disjoint_union" title="wikilink">Disjoint union</a></li>
<li><a href="Type_theory" title="wikilink">Type theory</a></li>
<li><a href="Generalized_algebraic_data_type" title="wikilink">Generalized algebraic data type</a></li>
<li><a href="Initial_algebra" title="wikilink">Initial algebra</a></li>
<li><a href="Quotient_type" title="wikilink">Quotient type</a></li>
<li><a href="Visitor_pattern" title="wikilink">Visitor pattern</a></li>
</ul>
<h2 id="references">References</h2>
<references>
</references>

<p>"</p>

<p><a href="Category:Functional_programming" title="wikilink">Category:Functional programming</a> <a href="Category:Type_theory" title="wikilink">Category:Type theory</a> <a href="Category:Data_types" title="wikilink">Category:Data types</a> <a href="Category:Articles_with_example_Haskell_code" title="wikilink">Category:Articles with example Haskell code</a> <a href="Category:Composite_data_types" title="wikilink">Category:Composite data types</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="http://caml.inria.fr/pub/docs/manual-ocaml/manual003.html#toc7">Records and variants</a> - OCaml manual section 1.4<a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
</ol>
</section>
</body>

