<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="691">Satisfiability</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Satisfiability</h1>
<hr/>

<p>In <a href="mathematical_logic" title="wikilink">mathematical logic</a>, <strong>satisfiability</strong> and <strong><a class="uri" href="validity" title="wikilink">validity</a></strong> are elementary concepts of <a class="uri" href="semantics" title="wikilink">semantics</a>. A <a href="formula_(mathematical_logic)" title="wikilink">formula</a> is <em>satisfiable</em> if it is possible to find an <a href="interpretation_(logic)" title="wikilink">interpretation</a> (<a href="model_theory" title="wikilink">model</a>) that makes the formula true.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> A formula is <em>valid</em> if all interpretations make the formula true. The opposites of these concepts are <strong>unsatisfiability</strong> and <strong>invalidity</strong>, that is, a formula is <em>unsatisfiable</em> if none of the interpretations make the formula true, and <em>invalid</em> if some such interpretation makes the formula false. These four concepts are related to each other in a manner exactly analogous to <a class="uri" href="Aristotle" title="wikilink">Aristotle</a>'s <a href="square_of_opposition" title="wikilink">square of opposition</a>.</p>

<p>The four concepts can be raised to apply to whole <a href="Theory_(mathematical_logic)" title="wikilink">theories</a>: a theory is satisfiable (valid) if one (all) of the interpretations make(s) each of the <a href="axiom" title="wikilink">axioms</a> of the theory true, and a theory is unsatisfiable (invalid) if all (one) of the interpretations make(s) each of the axioms of the theory false.</p>

<p>It is also possible to consider only interpretations that make all of the axioms of a second theory true. This generalization is commonly called <a href="satisfiability_modulo_theories" title="wikilink">satisfiability modulo theories</a>.</p>

<p>The question whether a sentence in <a href="propositional_logic" title="wikilink">propositional logic</a> is satisfiable is a <a href="decidable_problem" title="wikilink">decidable problem</a>. In general, the question whether sentences in <a href="first-order_logic" title="wikilink">first-order logic</a> are satisfiable is not decidable. In <a href="universal_algebra" title="wikilink">universal algebra</a> and <a href="equational_theory" title="wikilink">equational theory</a>, the methods of <a href="term_rewriting" title="wikilink">term rewriting</a>, <a href="congruence_closure" title="wikilink">congruence closure</a> and <a href="unification_(computer_science)" title="wikilink">unification</a> are used to attempt to decide satisfiability. Whether a particular <a href="theory_(logic)" title="wikilink">theory</a> is decidable or not depends whether the theory is <a class="uri" href="variable-free" title="wikilink">variable-free</a> or on other conditions.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>
<h2 id="reduction-of-validity-to-satisfiability">Reduction of validity to satisfiability</h2>

<p>For <a href="classical_logic" title="wikilink">classical logics</a>, it is generally possible to reexpress the question of the validity of a formula to one involving satisfiability, because of the relationships between the concepts expressed in the above square of opposition. In particular φ is valid if and only if ¬φ is unsatisfiable, which is to say it is not true that ¬φ is satisfiable. Put another way, φ is satisfiable if and only if ¬φ is invalid.</p>

<p>For logics without negation, such as the <a href="List_of_logic_systems#Positive_propositional_calculus" title="wikilink">positive propositional calculus</a>, the questions of validity and satisfiability may be unrelated. In the case of the <a href="List_of_logic_systems#Positive_propositional_calculus" title="wikilink">positive propositional calculus</a>, the satisfiability problem is trivial, as every formula is satisfiable, while the validity problem is <a href="Co-NP-complete" title="wikilink">co-NP complete</a>.</p>
<h2 id="propositional-satisfiability">Propositional satisfiability</h2>

<p>In the case of <a href="classical_propositional_logic" title="wikilink">classical propositional logic</a>, satisfiability is decidable for propositional formulae. In particular, satisfiability is an <a class="uri" href="NP-complete" title="wikilink">NP-complete</a> problem, and is one of the most intensively studied problems in <a href="computational_complexity_theory" title="wikilink">computational complexity theory</a>.</p>
<h2 id="satisfiability-in-first-order-logic">Satisfiability in first-order logic</h2>

<p>Satisfiability is <a href="undecidable_problem" title="wikilink">undecidable</a> and indeed it isn't even a semidecidable property of formulae in <a href="first-order_logic" title="wikilink">first-order logic</a> (FOL).<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> This fact has to do with the undecidability of the validity problem for FOL. The question of the status of the validity problem was posed firstly by David Hilbert, as the so-called <a class="uri" href="Entscheidungsproblem" title="wikilink">Entscheidungsproblem</a>. The universal validity of a formula is a semi-decidable problem. If satisfiability were also a semi-decidable problem, then the problem of the existence of counter-models would be too (a formula has counter-models iff its negation is satisfiable). So the problem of logical validity would be decidable, which contradicts the Church-Turing theorem, a result stating the negative answer for the <a class="uri" href="Entscheidungsproblem" title="wikilink">Entscheidungsproblem</a>.</p>
<h2 id="satisfiability-in-model-theory">Satisfiability in model theory</h2>

<p>In <a href="model_theory" title="wikilink">model theory</a>, an <a href="atomic_formula" title="wikilink">atomic formula</a> is satisfiable if there is a collection of elements of a <a href="structure_(logic)" title="wikilink">structure</a> that render the formula true.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> If <em>A</em> is a structure, φ is a formula, and <em>a</em> is a collection of elements, taken from the structure, that satisfy φ, then it is commonly written that</p>
<dl>
<dd><em>A</em> ⊧ φ [a]
</dd>
</dl>

<p>If φ has no variables, that is, if φ is an <a href="atomic_sentence" title="wikilink">atomic sentence</a>, and it is satisfied by <em>A</em>, then one writes</p>
<dl>
<dd><em>A</em> ⊧ φ
</dd>
</dl>

<p>In this case, one may also say that <em>A</em> is a model for φ, or that φ is <em>true</em> in <em>A</em>. If <em>T</em> is a collection of atomic sentences (a theory) satisfied by <em>A</em>, one writes</p>
<dl>
<dd><em>A</em> ⊧ T
</dd>
</dl>
<h2 id="finite-satisfiability">Finite satisfiability</h2>

<p>A problem related to satisfiability is that of <strong>finite satisfiability</strong>, which is the question of determining whether a formula admits a <em>finite</em> model that makes it true. For a logic that has the <a href="finite_model_property" title="wikilink">finite model property</a>, the problems of satisfiability and finite satisfiability coincide, as a formula of that logic has a model if and only if it has a finite model. This question is important in the mathematical field of <a href="finite_model_theory" title="wikilink">finite model theory</a>.</p>

<p>Nevertheless, finite satisfiability and satisfiability need not coincide in general. For instance, consider the <a href="first-order_logic" title="wikilink">first-order logic</a> formula obtained as the <a href="logical_conjunction" title="wikilink">conjunction</a> of the following sentences, where 

<math display="inline" id="Satisfiability:0">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Satisfiability:1">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>

 are <a href="logical_constant" title="wikilink">constants</a>:</p>
<ul>
<li>

<math display="inline" id="Satisfiability:2">
 <semantics>
  <mrow>
   <mi>R</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>a</mi>
     <mn>0</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>a</mi>
     <mn>0</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>R</ci>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <cn type="integer">0</cn>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R(a_{0},a_{0})
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="Satisfiability:3">
 <semantics>
  <mrow>
   <mi>R</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>a</mi>
     <mn>0</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>a</mi>
     <mn>1</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>R</ci>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <cn type="integer">1</cn>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R(a_{0},a_{1})
  </annotation>
 </semantics>
</math>


</li>
<li>

<math display="inline" id="Satisfiability:4">
 <semantics>
  <mrow>
   <mo>∀</mo>
   <mi>x</mi>
   <mi>y</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>R</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>→</mo>
    <mo>∃</mo>
    <mi>z</mi>
    <mi>R</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>y</mi>
     <mo>,</mo>
     <mi>z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <csymbol cd="unknown">y</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">R</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-,</ci>
      <csymbol cd="unknown">y</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-→</ci>
     <exists></exists>
     <csymbol cd="unknown">z</csymbol>
     <csymbol cd="unknown">R</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">y</csymbol>
      <ci>normal-,</ci>
      <csymbol cd="unknown">z</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall xy(R(x,y)\rightarrow\exists zR(y,z))
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="Satisfiability:5">
 <semantics>
  <mrow>
   <mo>∀</mo>
   <mi>x</mi>
   <mi>y</mi>
   <mi>z</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>R</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>y</mi>
     <mo>,</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∧</mo>
    <mi>R</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>z</mi>
     <mo>,</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>→</mo>
    <mi>x</mi>
    <mo>=</mo>
    <mi>z</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <csymbol cd="unknown">y</csymbol>
    <csymbol cd="unknown">z</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">R</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">y</csymbol>
      <ci>normal-,</ci>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <and></and>
     <csymbol cd="unknown">R</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">z</csymbol>
      <ci>normal-,</ci>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-→</ci>
     <csymbol cd="unknown">x</csymbol>
     <eq></eq>
     <csymbol cd="unknown">z</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-)</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall xyz(R(y,x)\wedge R(z,x)\rightarrow x=z))
  </annotation>
 </semantics>
</math>

</li>
</ul>

<p>The resulting formula has the infinite model 

<math display="inline" id="Satisfiability:6">
 <semantics>
  <mrow>
   <mrow>
    <mi>R</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>a</mi>
      <mn>0</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>a</mi>
      <mn>0</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>R</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>a</mi>
      <mn>0</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>a</mi>
      <mn>1</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>R</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>a</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>a</mi>
      <mn>2</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <times></times>
     <ci>R</ci>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <cn type="integer">0</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <cn type="integer">0</cn>
      </apply>
     </interval>
    </apply>
    <apply>
     <times></times>
     <ci>R</ci>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <cn type="integer">0</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <cn type="integer">1</cn>
      </apply>
     </interval>
    </apply>
    <apply>
     <times></times>
     <ci>R</ci>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <cn type="integer">2</cn>
      </apply>
     </interval>
    </apply>
    <ci>normal-…</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R(a_{0},a_{0}),R(a_{0},a_{1}),R(a_{1},a_{2}),\ldots
  </annotation>
 </semantics>
</math>

, but it can be shown that it has no finite model (starting at the fact 

<math display="inline" id="Satisfiability:7">
 <semantics>
  <mrow>
   <mi>R</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>a</mi>
    <mo>,</mo>
    <mi>b</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>R</ci>
    <interval closure="open">
     <ci>a</ci>
     <ci>b</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R(a,b)
  </annotation>
 </semantics>
</math>

 and following the chain of 

<math display="inline" id="Satisfiability:8">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>


 <a href="atomic_formula" title="wikilink">atoms</a> that must exist by the third axiom, the finiteness of a model would require the existence of a loop, which would violate the fourth axiom, whether it loops back on 

<math display="inline" id="Satisfiability:9">
 <semantics>
  <msub>
   <mi>a</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>a</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{0}
  </annotation>
 </semantics>
</math>

 or on a different element).</p>

<p>The <a href="Computational_complexity_theory" title="wikilink">computational complexity</a> of deciding satisfiability for an input formula in a given logic may differ from that of deciding finite satisfiability; in fact, for some logics, only one of them is <a href="decidability_(logic)" title="wikilink">decidable</a>.</p>
<h2 id="numerical-constraints">Numerical constraints</h2>

<p>Numerical constraints often appear in the field of <a href="mathematical_optimization" title="wikilink">mathematical optimization</a>, where one usually wants to maximize (or minimize) an objective function subject to some constraints. However, leaving aside the objective function, the basic issue of simply deciding whether the constraints are satisfiable can be challenging or undecidable in some settings. The following table summarizes the main cases.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>Constraints</p></th>
<th style="text-align: left;">
<p>over reals</p></th>
<th style="text-align: left;">
<p>over integers</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>Linear</p></td>
<td style="text-align: left;">
<p><a class="uri" href="PTIME" title="wikilink">PTIME</a> (see <a href="linear_programming" title="wikilink">linear programming</a>)</p></td>
<td style="text-align: left;">
<p><a class="uri" href="NP-complete" title="wikilink">NP-complete</a> (see <a href="integer_programming" title="wikilink">integer programming</a>)</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Non-linear</p></td>
<td style="text-align: left;">
<p><a href="decision_problem" title="wikilink">decidable</a></p></td>
<td style="text-align: left;">
<p>undecidable (<a href="Hilbert's_tenth_problem" title="wikilink">Hilbert's tenth problem</a>)</p></td>
</tr>
</tbody>
</table>

<p><em>Table source: Bockmayr and Weispfenning</em>.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>

<p>For linear constraints, a fuller picture is provided by the following table.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>Constraints over:</p></th>
<th style="text-align: left;">
<p>rationals</p></th>
<th style="text-align: left;">
<p>integers</p></th>
<th style="text-align: left;">
<p>natural numbers</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p><a href="System_of_linear_equations" title="wikilink">Linear equations</a></p></td>
<td style="text-align: left;">
<p>PTIME</p></td>
<td style="text-align: left;">
<p>PTIME</p></td>
<td style="text-align: left;">
<p>NP-complete</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><a href="Linear_inequality#Systems_of_linear_inequalities" title="wikilink">Linear inequalities</a></p></td>
<td style="text-align: left;">
<p>PTIME</p></td>
<td style="text-align: left;">
<p>NP-complete</p></td>
<td style="text-align: left;">
<p>NP-complete</p></td>
</tr>
</tbody>
</table>

<p><em>Table source: Bockmayr and Weispfenning</em>.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a class="uri" href="2-satisfiability" title="wikilink">2-satisfiability</a></li>
<li><a href="Boolean_satisfiability_problem" title="wikilink">Boolean satisfiability problem</a></li>
<li><a href="Circuit_satisfiability" title="wikilink">Circuit satisfiability</a></li>
<li><a href="Karp's_21_NP-complete_problems" title="wikilink">Karp's 21 NP-complete problems</a></li>
<li><a class="uri" href="Validity" title="wikilink">Validity</a></li>
<li><a href="Constraint_satisfaction" title="wikilink">Constraint satisfaction</a></li>
<li><a class="uri" href="Satisficing" title="wikilink">Satisficing</a></li>
</ul>
<h2 id="notes">Notes</h2>
<references>
</references>
<h2 id="references">References</h2>
<ul>
<li>Boolos and Jeffrey, 1974. <em>Computability and Logic</em>. Cambridge University Press.</li>
</ul>
<h2 id="further-reading">Further reading</h2>
<ul>
<li></li>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Logical_truth" title="wikilink">Category:Logical truth</a> <a href="Category:Model_theory" title="wikilink">Category:Model theory</a> <a href="Category:Philosophy_of_logic" title="wikilink">Category:Philosophy of logic</a> <a href="Category:Concepts_in_logic" title="wikilink">Category:Concepts in logic</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">See, for example, Boolos and Jeffrey, 1974, chapter 11.<a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"></li>
</ol>
</section>
</body>
</html>
