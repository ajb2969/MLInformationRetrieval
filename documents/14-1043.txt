   Homomorphic signatures for network coding      Homomorphic signatures for network coding  [[Network coding]] has been shown to optimally use [[Bandwidth (computing)|bandwidth]] in a network, maximizing information flow but the scheme is very inherently vulnerable to pollution attacks by malicious nodes in the network. A node injecting garbage can quickly affect many receivers.  The pollution of [[network packet]]s spreads quickly since the output of (even an) honest node is corrupted if at least one of the incoming packets is corrupted. An attacker can easily corrupt a packet even i f it is encrypted by either forging the signature or by producing a collision under the hash function . This will give an attacker access to the packets and the ability to corrupt them. Denis Charles, Kamal Jain and Kristin Lauter designed a new homomorphic encryption signature scheme for use with network coding to prevent pollution attacks. 1 The homomorphic property of the signatures allows nodes to sign any linear combination of the incoming packets without contacting the signing authority. In this scheme it is computationally infeasible for a node to sign a linear combination of the packets without disclosing what linear combination was used in the generation of the packet. Furthermore, we can prove that the signature scheme is secure under well known cryptographic assumptions of the hardness of the discrete logarithm problem and the computational Elliptic curve Diffie‚ÄìHellman .  Network coding  Let    G  =   (  V  ,  E  )       G   V  E     G=(V,E)   be a directed graph where   V   V   V   is a set, whose elements are called vertices or nodes , and   E   E   E   is a set of ordered pairs of vertices, called arcs, directed edges, or arrows. A source    s  ‚àà  V      s  V    s\in V   wants to transmit a file   D   D   D   to a set    T  ‚äÜ  V      T  V    T\subseteq V   of the vertices. One chooses a vector space     W  /   ùîΩ  p       W   subscript  ùîΩ  p     W/\mathbb{F}_{p}   (say of dimension   d   d   d   ), where   p   p   p   is a prime, and views the data to be transmitted as a bunch of vectors      w  1   ,  ‚Ä¶  ,   w  k    ‚àà  W        subscript  w  1   normal-‚Ä¶   subscript  w  k    W    w_{1},\ldots,w_{k}\in W   . The source then creates the augmented vectors     v  1   ,  ‚Ä¶  ,   v  k       subscript  v  1   normal-‚Ä¶   subscript  v  k     v_{1},\ldots,v_{k}   by setting     v  i   =   (  0  ,  ‚Ä¶  ,  0  ,  1  ,  ‚Ä¶  ,  0  ,   w   i  1    ,  ‚Ä¶  ,   w   i  d    )        subscript  v  i    0  normal-‚Ä¶  0  1  normal-‚Ä¶  0   subscript  w   subscript  i  1    normal-‚Ä¶    w   subscript  i  d       v_{i}=(0,\ldots,0,1,\ldots,0,w_{i_{1}},\ldots,w{i_{d}})   where    w   i  j      subscript  w   subscript  i  j     w_{i_{j}}   is the   j   j   j   -th coordinate of the vector    w  i     subscript  w  i    w_{i}   . There are    (   i  -  1   )      i  1    (i-1)   zeros before the first '1' appears in    v  i     subscript  v  i    v_{i}   . One can assume without loss of generality that the vectors    v  i     subscript  v  i    v_{i}   are linearly independent . We denote the linear subspace (of    ùîΩ  p   k  +  d      superscript   subscript  ùîΩ  p     k  d     \mathbb{F}_{p}^{k+d}   ) spanned by these vectors by   V   V   V   . Each outgoing edge    e  ‚àà  E      e  E    e\in E   computes a linear combination,    y   (  e  )       y  e    y(e)   , of the vectors entering the vertex    v  =   i  n   (  e  )        v    i  n  e     v=in(e)   where the edge originates, that is to say       y   (  e  )    =    ‚àë   f  :    out   (  f  )    =  v      (    m  e    (  f  )   y   (  f  )    )          y  e     subscript    normal-:  f      out  f   v        subscript  m  e   f  y  f      y(e)=\sum_{f:\mathrm{out}(f)=v}(m_{e}(f)y(f))     where      m  e    (  f  )    ‚àà   ùîΩ  p          subscript  m  e   f    subscript  ùîΩ  p     m_{e}(f)\in\mathbb{F}_{p}   . We consider the source as having   k   k   k   input edges carrying the   k   k   k   vectors    w  i     subscript  w  i    w_{i}   . By induction , one has that the vector    y   (  e  )       y  e    y(e)   on any edge is a linear combination     y   (  e  )    =    ‚àë   1  ‚â§  i  ‚â§  k     (    g  i    (  e  )    v  i    )          y  e     subscript       1  i       k        subscript  g  i   e   subscript  v  i       y(e)=\sum_{1\leq i\leq k}(g_{i}(e)v_{i})   and is a vector in   V   V   V   . The k-dimensional vector     g   (  e  )    =   (    g  1    (  e  )    ,  ‚Ä¶  ,    g  k    (  e  )    )         g  e       subscript  g  1   e   normal-‚Ä¶     subscript  g  k   e      g(e)=(g_{1}(e),\ldots,g_{k}(e))   is simply the first k coordinates of the vector    y   (  e  )       y  e    y(e)   . We call the matrix whose rows are the vectors     g   (   e  1   )    ,  ‚Ä¶  ,   g   (   e  k   )         g   subscript  e  1    normal-‚Ä¶    g   subscript  e  k      g(e_{1}),\ldots,g(e_{k})   , where    e  i     subscript  e  i    e_{i}   are the incoming edges for a vertex    t  ‚àà  T      t  T    t\in T   , the global encoding matrix for   t   t   t   and denote it as    G  t     subscript  G  t    G_{t}   . In practice the encoding vectors are chosen at random so the matrix    G  t     subscript  G  t    G_{t}   is invertible with high probability. Thus any receiver, on receiving     y  1   ,  ‚Ä¶  ,   y  k       subscript  y  1   normal-‚Ä¶   subscript  y  k     y_{1},\ldots,y_{k}   can find     w  1   ,  ‚Ä¶  ,   w  k       subscript  w  1   normal-‚Ä¶   subscript  w  k     w_{1},\ldots,w_{k}   by solving       [      y  ‚Ä≤        y  2  ‚Ä≤       ‚ãÆ       y  k  ‚Ä≤      ]   =    G  t    [      w  1        w  2       ‚ãÆ       w  k      ]           superscript  y  normal-‚Ä≤      superscript   subscript  y  2   normal-‚Ä≤     normal-‚ãÆ     superscript   subscript  y  k   normal-‚Ä≤        subscript  G  t      subscript  w  1      subscript  w  2     normal-‚ãÆ     subscript  w  k        \begin{bmatrix}y^{\prime}\\
 y_{2}^{\prime}\\
 \vdots\\
 y_{k}^{\prime}\end{bmatrix}=G_{t}\begin{bmatrix}w_{1}\\
 w_{2}\\
 \vdots\\
 w_{k}\end{bmatrix}     where the    y  i  ‚Ä≤     superscript   subscript  y  i   normal-‚Ä≤    y_{i}^{\prime}   are the vectors formed by removing the first   k   k   k   coordinates of the vector    y  i     subscript  y  i    y_{i}   .  Decoding at the receiver  Each receiver ,    t  ‚àà  T      t  T    t\in T   , gets   k   k   k   vectors     y  1   ,  ‚Ä¶  ,   y  k       subscript  y  1   normal-‚Ä¶   subscript  y  k     y_{1},\ldots,y_{k}   which are random linear combinations of the    v  i     subscript  v  i    v_{i}   ‚Äôs. In fact, if       y  i   =   (   Œ±   i  1    ,  ‚Ä¶  ,   Œ±   i  k    ,   a   i  1    ,  ‚Ä¶  ,   a   i  d    )        subscript  y  i     subscript  Œ±   subscript  i  1    normal-‚Ä¶   subscript  Œ±   subscript  i  k     subscript  a   subscript  i  1    normal-‚Ä¶   subscript  a   subscript  i  d       y_{i}=(\alpha_{i_{1}},\ldots,\alpha_{i_{k}},a_{i_{1}},\ldots,a_{i_{d}})     then        y  i   =    ‚àë   1  ‚â§  j  ‚â§  k     (    Œ±   i  j     v  j    )     .       subscript  y  i     subscript       1  j       k        subscript  Œ±    i  j     subscript  v  j       y_{i}=\sum_{1\leq j\leq k}(\alpha_{ij}v_{j}).     Thus we can invert the linear transformation to find the    v  i     subscript  v  i    v_{i}   ‚Äôs with high probability .  History  Krohn, Freedman and Mazieres proposed a theory 2 in 2004 that if we have a hash function    H  :   V  ‚ü∂  G      normal-:  H   normal-‚ü∂  V  G     H:V\longrightarrow G   such that:      H   H   H   is collision resistant ‚Äì it is hard to find   x   x   x   and   y   y   y   such that     H   (  x  )    =   H   (  y  )          H  x     H  y     H(x)=H(y)   ;     H   H   H   is a homomorphism ‚Äì     H   (   x  +  y   )    =    H   (  x  )    +   H   (  y  )           H    x  y        H  x     H  y      H(x+y)=H(x)+H(y)   .   Then server can securely distribute    H   (   v  i   )       H   subscript  v  i     H(v_{i})   to each receiver, and to check if      y  =    ‚àë   1  ‚â§  i  ‚â§  k     (    Œ±  i    v  i    )        y    subscript       1  i       k        subscript  Œ±  i    subscript  v  i       y=\sum_{1\leq i\leq k}(\alpha_{i}v_{i})     we can check whether       H   (  y  )    =    ‚àë   1  ‚â§  i  ‚â§  k     (    Œ±  i   H   (   v  i   )    )          H  y     subscript       1  i       k        subscript  Œ±  i   H   subscript  v  i       H(y)=\sum_{1\leq i\leq k}(\alpha_{i}H(v_{i}))     The problem with this method is that the server needs to transfer secure information to each of the receivers. The hash functions   H   H   H   needs to be transmitted to all the nodes in the network through a separate secure channel.   H   H   H   is expensive to compute and secure transmission of   H   H   H   is not economical either.  Advantages of homomorphic signatures   Establishes authentication in addition to detecting pollution.  No need for distributing secure hash digests.  Smaller bit lengths in general will suffice. Signatures of length 180 bits have as much security as 1024 bit RSA signatures.  Public information does not change for subsequent file transmission.   Signature scheme  The homomorphic property of the signatures allows nodes to sign any linear combination of the incoming packets without contacting the signing authority.  Elliptic curves cryptography over a finite field  Elliptic curve cryptography over a finite field is an approach to public-key cryptography based on the algebraic structure of elliptic curves over finite fields .  Let    ùîΩ  q     subscript  ùîΩ  q    \mathbb{F}_{q}   be a finite field such that   q   q   q   is not a power of 2 or 3. Then an elliptic curve   E   E   E   over    ùîΩ  q     subscript  ùîΩ  q    \mathbb{F}_{q}   is a curve given by an equation of the form        y  2   =    x  3   +   a  x   +  b    ,       superscript  y  2      superscript  x  3     a  x   b     y^{2}=x^{3}+ax+b,\,     where     a  ,  b   ‚àà   ùîΩ  q        a  b    subscript  ùîΩ  q     a,b\in\mathbb{F}_{q}   such that      4   a  3    +   27   b  2     ‚â†  0          4   superscript  a  3      27   superscript  b  2     0    4a^{3}+27b^{2}\not=0     Let    K  ‚äá   ùîΩ  q        subscript  ùîΩ  q   K    K\supseteq\mathbb{F}_{q}   , then,       E   (  K  )    =    {   (  x  ,  y  )   |    y  2   =    x  3   +   a  x   +  b    }    ‚ãÉ   {  O  }           E  K      conditional-set   x  y      superscript  y  2      superscript  x  3     a  x   b        O       E(K)=\{(x,y)|y^{2}=x^{3}+ax+b\}\bigcup\{O\}     forms an abelian group with O as identity. The group operations can be performed efficiently.  Weil pairing  Weil pairing is a construction of roots of unity by means of functions on an elliptic curve    E   E   E   , in such a way as to constitute a pairing ( bilinear form , though with multiplicative notation ) on the torsion subgroup of   E   E   E   . Let    E  /   ùîΩ  q       E   subscript  ùîΩ  q     E/\mathbb{F}_{q}   be an elliptic curve and let     ùîΩ  ¬Ø   q     subscript   normal-¬Ø  ùîΩ   q    \mathbb{\bar{F}}_{q}   be an algebraic closure of    ùîΩ  q     subscript  ùîΩ  q    \mathbb{F}_{q}   . If   m   m   m   is an integer, relatively prime to the characteristic of the field    ùîΩ  q     subscript  ùîΩ  q    \mathbb{F}_{q}   , then the group of   m   m   m   -torsion points,      E   [  m  ]    =  P  ‚àà   E   (    ùîΩ  ¬Ø   q   )     :    m  P   =  O      normal-:        E   delimited-[]  m    P         E   subscript   normal-¬Ø  ùîΩ   q          m  P   O     E[m]={P\in E(\mathbb{\bar{F}}_{q}):mP=O}   .  If    E  /   ùîΩ  q       E   subscript  ùîΩ  q     E/\mathbb{F}_{q}   is an elliptic curve and     gcd   (  m  ,  q  )    =  1        m  q   1    \gcd(m,q)=1   then       E   [  m  ]    ‚âÖ    (    ‚Ñ§  /  m   ‚Ñ§   )   *   (    ‚Ñ§  /  m   ‚Ñ§   )          E   delimited-[]  m          ‚Ñ§  m   ‚Ñ§       ‚Ñ§  m   ‚Ñ§      E[m]\cong(\mathbb{Z}/m\mathbb{Z})*(\mathbb{Z}/m\mathbb{Z})     There is a map     e  m   :      E   [  m  ]    *  E    [  m  ]    ‚Üí    Œº  m    (   ùîΩ  q   )        normal-:   subscript  e  m    normal-‚Üí        E   delimited-[]  m    E    delimited-[]  m       subscript  Œº  m    subscript  ùîΩ  q       e_{m}:E[m]*E[m]\rightarrow\mu_{m}(\mathbb{F}_{q})   such that:   (Bilinear)      e  m    (   P  +  R   ,  Q  )    =    e  m    (  P  ,  Q  )    e  m    (  R  ,  Q  )   and   e  m    (  P  ,   Q  +  R   )    =    e  m    (  P  ,  Q  )    e  m    (  P  ,  R  )             subscript  e  m      P  R   Q       subscript  e  m    P  Q    subscript  e  m    R  Q   and   subscript  e  m    P    Q  R             subscript  e  m    P  Q    subscript  e  m    P  R       e_{m}(P+R,Q)=e_{m}(P,Q)e_{m}(R,Q)\text{ and }e_{m}(P,Q+R)=e_{m}(P,Q)e_{m}(P,R)   .  (Non-degenerate)      e  m    (  P  ,  Q  )    =  1         subscript  e  m    P  Q    1    e_{m}(P,Q)=1   for all P implies that    Q  =  O      Q  O    Q=O   .  (Alternating)      e  m    (  P  ,  P  )    =  1         subscript  e  m    P  P    1    e_{m}(P,P)=1   .   Also,    e  m     subscript  e  m    e_{m}   can be computed efficiently. 3  Homomorphic signatures  Let   p   p   p   be a prime and   q   q   q   a prime power. Let    V  /   ùîΩ  p       V   subscript  ùîΩ  p     V/\mathbb{F}_{p}   be a vector space of dimension   D   D   D   and    E  /   ùîΩ  q       E   subscript  ùîΩ  q     E/\mathbb{F}_{q}   be an elliptic curve such that      P  1   ,  ‚Ä¶  ,   P  D    ‚àà   E   [  p  ]          subscript  P  1   normal-‚Ä¶   subscript  P  D      E   delimited-[]  p      P_{1},\ldots,P_{D}\in E[p]   . Define    h  :   V  ‚ü∂   E   [  p  ]        normal-:  h   normal-‚ü∂  V    E   delimited-[]  p       h:V\longrightarrow E[p]   as follows:     h   (   u  1   ,  ‚Ä¶  ,   u  D   )    =    ‚àë   1  ‚â§  i  ‚â§  D     (    u  i    P  i    )          h    subscript  u  1   normal-‚Ä¶   subscript  u  D       subscript       1  i       D        subscript  u  i    subscript  P  i       h(u_{1},\ldots,u_{D})=\sum_{1\leq i\leq D}(u_{i}P_{i})   . The function   h   h   h   is an arbitrary homomorphism from   V   V   V   to    E   [  p  ]       E   delimited-[]  p     E[p]   .  The server chooses     s  1   ,  ‚Ä¶  ,   s  D       subscript  s  1   normal-‚Ä¶   subscript  s  D     s_{1},\ldots,s_{D}   secretly in    ùîΩ  p     subscript  ùîΩ  p    \mathbb{F}_{p}   and publishes a point   Q   Q   Q   of p-torsion such that      e  p    (   P  i   ,  Q  )    ‚â†  1         subscript  e  p     subscript  P  i   Q    1    e_{p}(P_{i},Q)\not=1   and also publishes    (   P  i   ,    s  i   Q   )      subscript  P  i      subscript  s  i   Q     (P_{i},s_{i}Q)   for    1  ‚â§  i  ‚â§  D        1  i       D     1\leq i\leq D   . The signature of the vector    v  =    u  1   ,  ‚Ä¶  ,   u  D        v    subscript  u  1   normal-‚Ä¶   subscript  u  D      v=u_{1},\ldots,u_{D}   is     œÉ   (  v  )    =    ‚àë   1  ‚â§  i  ‚â§  D     (    u  i    s  i    P  i    )          œÉ  v     subscript       1  i       D        subscript  u  i    subscript  s  i    subscript  P  i       \sigma(v)=\sum_{1\leq i\leq D}(u_{i}s_{i}P_{i})   Note: This signature is homomorphic since the computation of h is a homomorphism.  Signature verification  Given    v  =    u  1   ,  ‚Ä¶  ,   u  D        v    subscript  u  1   normal-‚Ä¶   subscript  u  D      v=u_{1},\ldots,u_{D}   and its signature   œÉ   œÉ   \sigma   , verify that       e  p    (  œÉ  ,  Q  )        subscript  e  p    œÉ  Q     \displaystyle e_{p}(\sigma,Q)     The verification crucially uses the bilinearity of the Weil-pairing.  System setup  The server computes    œÉ   (   v  i   )       œÉ   subscript  v  i     \sigma(v_{i})   for each    1  ‚â§  i  ‚â§  k        1  i       k     1\leq i\leq k   . Transmits     v  i   ,   œÉ   (   v  i   )        subscript  v  i     œÉ   subscript  v  i      v_{i},\sigma(v_{i})   . At each edge   e   e   e   while computing     y   (  e  )    =    ‚àë    f  ‚àà  E   :    out   (  f  )    =   in   (  e  )        (    m  e    (  f  )   y   (  f  )    )          y  e     subscript    normal-:    f  E       out  f     in  e         subscript  m  e   f  y  f      y(e)=\sum_{f\in E:\mathrm{out}(f)=\mathrm{in}(e)}(m_{e}(f)y(f))   also compute     œÉ   (   y   (  e  )    )    =    ‚àë    f  ‚àà  E   :    out   (  f  )    =   in   (  e  )        (    m  e    (  f  )   œÉ   (   y   (  f  )    )    )          œÉ    y  e      subscript    normal-:    f  E       out  f     in  e         subscript  m  e   f  œÉ    y  f       \sigma(y(e))=\sum_{f\in E:\mathrm{out}(f)=\mathrm{in}(e)}(m_{e}(f)\sigma(y(f)))   on the elliptic curve   E   E   E   .  The signature is a point on the elliptic curve with coordinates in    ùîΩ  q     subscript  ùîΩ  q    \mathbb{F}_{q}   . Thus the size of the signature is    2   log  q       2    q     2\log q   bits (which is some constant times    l  o  g   (  p  )       l  o  g  p    log(p)   bits, depending on the relative size of   p   p   p   and   q   q   q   ), and this is the transmission overhead. The computation of the signature    h   (  e  )       h  e    h(e)   at each vertex requires    O   (    d   i  n     log   p    log   1  +  œµ    q      )       O     subscript  d    i  n        p    superscript     1  œµ    q        O(d_{in}\log p\log^{1+\epsilon}q)   bit operations, where    d   i  n      subscript  d    i  n     d_{in}   is the in-degree of the vertex    i  n   (  e  )       i  n  e    in(e)   . The verification of a signature requires    O   (    (   d  +  k   )     log   2  +  œµ    q    )       O      d  k     superscript     2  œµ    q      O((d+k)\log^{2+\epsilon}q)   bit operations.  Proof of security  Attacker can produce a collision under the hash function.  If given    (   P  1   ,  ‚Ä¶  ,   P  r   )      subscript  P  1   normal-‚Ä¶   subscript  P  r     (P_{1},\ldots,P_{r})   points in    E   [  p  ]       E   delimited-[]  p     E[p]   find    a  =   (   a  1   ,  ‚Ä¶  ,   a  r   )   ‚àà   ùîΩ  p  r         a    subscript  a  1   normal-‚Ä¶   subscript  a  r          superscript   subscript  ùîΩ  p   r      a=(a_{1},\ldots,a_{r})\in\mathbb{F}_{p}^{r}   and    b  =   (   b  1   ,  ‚Ä¶  ,   b  r   )   ‚àà   ùîΩ  p  r         b    subscript  b  1   normal-‚Ä¶   subscript  b  r          superscript   subscript  ùîΩ  p   r      b=(b_{1},\ldots,b_{r})\in\mathbb{F}_{p}^{r}     such that    a  ‚â†  b      a  b    a\not=b   and         ‚àë   1  ‚â§  i  ‚â§  r     (    a  i    P  i    )    =    ‚àë   1  ‚â§  j  ‚â§  r     (    b  j    P  j    )     .        subscript       1  i       r        subscript  a  i    subscript  P  i       subscript       1  j       r        subscript  b  j    subscript  P  j       \sum_{1\leq i\leq r}(a_{i}P_{i})=\sum_{1\leq j\leq r}(b_{j}P_{j}).     Proposition: There is a polynomial time reduction from discrete log on the cyclic group of order   p   p   p   on elliptic curves to Hash-Collision.  If    r  =  2      r  2    r=2   , then we get      x  P   +   y  Q    =    u  P   +   v  Q            x  P     y  Q        u  P     v  Q      xP+yQ=uP+vQ   . Thus       (   x  -  u   )   P   +    (   y  -  v   )   Q    =  0            x  u   P       y  v   Q    0    (x-u)P+(y-v)Q=0   . We claim that    x  ‚â†  u      x  u    x\not=u   and    y  ‚â†  v      y  v    y\not=v   . Suppose that    x  =  u      x  u    x=u   , then we would have      (   y  -  v   )   Q   =  0          y  v   Q   0    (y-v)Q=0   , but   Q   Q   Q   is a point of order   p   p   p   (a prime) thus     y  -  u   ‚â°   0  mod  p         y  u    modulo  0  p     y-u\equiv 0\bmod p   . In other words    y  =  v      y  v    y=v   in    ùîΩ  p     subscript  ùîΩ  p    \mathbb{F}_{p}   . This contradicts the assumption that    (  x  ,  y  )     x  y    (x,y)   and    (  u  ,  v  )     u  v    (u,v)   are distinct pairs in    ùîΩ  2     subscript  ùîΩ  2    \mathbb{F}_{2}   . Thus we have that    Q  =   -    (   x  -  u   )     (   y  -  v   )    -  1    P        Q        x  u    superscript    y  v     1    P      Q=-(x-u)(y-v)^{-1}P   , where the inverse is taken as modulo   p   p   p   .  If we have r > 2 then we can do one of two things. Either we can take     P  1   =  P       subscript  P  1   P    P_{1}=P   and     P  2   =  Q       subscript  P  2   Q    P_{2}=Q   as before and set     P  i   =  O       subscript  P  i   O    P_{i}=O   for   i   i   i   > 2 (in this case the proof reduces to the case when    r  =  2      r  2    r=2   ), or we can take     P  1   =    r  1   P        subscript  P  1      subscript  r  1   P     P_{1}=r_{1}P   and     P  i   =    r  i   Q        subscript  P  i      subscript  r  i   Q     P_{i}=r_{i}Q   where    r  i     subscript  r  i    r_{i}   are chosen at random from    ùîΩ  p     subscript  ùîΩ  p    \mathbb{F}_{p}   . We get one equation in one unknown (the discrete log of   Q   Q   Q   ). It is quite possible that the equation we get does not involve the unknown. However, this happens with very small probability as we argue next. Suppose the algorithm for Hash-Collision gave us that        a   r  1   P   +    ‚àë   2  ‚â§  i  ‚â§  r     (    b  i    r  i   Q   )     =  0.          a   subscript  r  1   P     subscript       2  i       r        subscript  b  i    subscript  r  i   Q     0.    ar_{1}P+\sum_{2\leq i\leq r}(b_{i}r_{i}Q)=0.     Then as long as      ‚àë   2  ‚â§  i  ‚â§  r      b  i    r  i     ‚â¢   0  mod  p      not-equivalent-to    subscript       2  i       r        subscript  b  i    subscript  r  i      modulo  0  p     \sum_{2\leq i\leq r}b_{i}r_{i}\not\equiv 0\bmod p   , we can solve for the discrete log of Q. But the    r  i     subscript  r  i    r_{i}   ‚Äôs are unknown to the oracle for Hash-Collision and so we can interchange the order in which this process occurs. In other words, given    b  i     subscript  b  i    b_{i}   , for    2  ‚â§  i  ‚â§  r        2  i       r     2\leq i\leq r   , not all zero, what is the probability that the    r  i     subscript  r  i    r_{i}   ‚Äôs we chose satisfies      ‚àë   2  ‚â§  i  ‚â§  r     (    b  i    r  i    )    =  0        subscript       2  i       r        subscript  b  i    subscript  r  i     0    \sum_{2\leq i\leq r}(b_{i}r_{i})=0   ? It is clear that the latter probability is    1  p      1  p    1\over p   . Thus with high probability we can solve for the discrete log of   Q   Q   Q   .  We have shown that producing hash collisions in this scheme is difficult. The other method by which an adversary can foil our system is by forging a signature. This scheme for the signature is essentially the Aggregate Signature version of the Boneh-Lynn-Shacham signature scheme. 4 Here it is shown that forging a signature is at least as hard as solving the elliptic curve Diffie‚ÄìHellman problem. The only known way to solve this problem on elliptic curves is via computing discrete-logs. Thus forging a signature is at least as hard as solving the computational co-Diffie‚ÄìHellman on elliptic curves and probably as hard as computing discrete-logs.  See also   Network coding  Homomorphic encryption  Elliptic curve cryptography  Weil pairing  Elliptic curve Diffie‚ÄìHellman  Elliptic curve DSA  Digital Signature Algorithm   References  External links   Comprehensive View of a Live Network Coding P2P System  Signatures for Network Coding(presentation) CISS 2006, Princeton  University at Buffalo Lecture Notes on Coding Theory ‚Äì Dr. Atri Rudra   "  Category:Finite fields  Category:Coding theory  Category:Information theory  Category:Error detection and correction     http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.60.4738&rep; ;=rep1&type;=pdf ‚Ü©  http://www.cs.princeton.edu/~mfreed/docs/authcodes-ieee04.pdf ‚Ü©  http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.88.8848&rep; ;=rep1&type;=pdf ‚Ü©  http://cseweb.ucsd.edu/~hovav/dist/sigs.pdf ‚Ü©     