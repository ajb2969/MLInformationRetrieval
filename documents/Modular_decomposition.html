<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="221">Modular decomposition</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Modular decomposition</h1>
<hr/>

<p>In <a href="Graph_(mathematics)" title="wikilink">graph theory</a>, the <strong>modular decomposition</strong> is a decomposition of a <a href="Graph_(mathematics)" title="wikilink">graph</a> into subsets of vertices called <strong>modules.</strong> A module is a generalization of a <a href="Connected_component_(graph_theory)" title="wikilink">connected component</a> of a graph. Unlike connected components, however, one module can be a proper subset of another. Modules therefore lead to a recursive (hierarchical) decomposition of the graph, instead of just a partition.</p>

<p>There are variants of modular decomposition for <a href="undirected_graph" title="wikilink">undirected graphs</a> and <a href="directed_graph" title="wikilink">directed graphs</a>. For each undirected graph, this decomposition is unique.</p>

<p>This notion can be generalized to other structures (for example directed graphs) and is useful to design efficient algorithms for the recognition of some graph classes, for finding transitive orientations of <a href="comparability_graph" title="wikilink">comparability graphs</a>, for <a href="Optimization_(mathematics)" title="wikilink">optimization problems</a> on graphs, and for <a href="graph_drawing" title="wikilink">graph drawing</a>.</p>
<h2 id="modules">Modules</h2>

<p>As the notion of modules has been rediscovered in many areas, <em>modules</em> have also been called <em>autonomous sets</em>, <em>homogeneous sets</em>, <em>intervals</em>, and <em>partitive sets</em>. Perhaps the earliest reference to them, and the first description of modular quotients and the graph decomposition they give rise to appeared in (<a href="Tibor_Gallai" title="wikilink">Gallai</a> 1967).</p>

<p>A <em>module</em> of a graph is a generalization of a <a href="Connected_component_(graph_theory)" title="wikilink">connected component</a>. A connected component has the property that it is a set <em>X</em> of vertices such that every member of <em>X</em> is a <a href="Neighbourhood_(graph_theory)" title="wikilink">non-neighbor</a> of every vertex not in <em>X</em>. (It is a union of connected components if and only if it has this property.) More generally, <em>X</em> is a module if, for each vertex 

<math display="inline" id="Modular_decomposition:0">
 <semantics>
  <mrow>
   <mi>v</mi>
   <mo>∉</mo>
   <mi>X</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <notin></notin>
    <ci>v</ci>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v\not\in X
  </annotation>
 </semantics>
</math>

, either every member of <em>X</em> is a non-neighbor of <em>v</em> or every member of <em>X</em> is a neighbor of <em>v</em>.</p>

<p>Equivalently, <em>X</em> is a module if all members of <em>X</em> have the same set of neighbors among vertices not in <em>X</em>.</p>

<p>Contrary to the connected components, the modules of a graph are the same as the modules of its <a href="Complement_graph" title="wikilink">complement</a>, and modules can be "nested": one module can be a proper subset of another. Note that the set <em>V</em> of vertices of a graph is a module, as are its one-element subsets and the empty set; these are called the <strong>trivial modules</strong>. A graph may or may not have other modules. A graph is called <strong>prime</strong> if all of its modules are trivial.</p>

<p>Despite these differences, modules preserve a desirable property of connected components, which is that many properties of the subgraph <em>G[X]</em> <a href="Glossary_of_graph_theory#Subgraphs" title="wikilink">induced</a> by a connected component <em>X</em> are independent of the rest of the graph. A similar phenomenon also applies to the subgraphs induced by modules.</p>

<p>The modules of a graph are therefore of great algorithmic interest. A set of nested modules, of which the modular decomposition is an example, can be used to guide the recursive solution of many combinatorial problems on graphs, such as recognizing and transitively orienting <a href="comparability_graph" title="wikilink">comparability graphs</a>, recognizing and finding permutation representations of <a href="permutation_graph" title="wikilink">permutation graphs</a>, recognizing whether a graph is a <a class="uri" href="cograph" title="wikilink">cograph</a> and finding a certificate of the answer to the question, recognizing <a href="interval_graph" title="wikilink">interval graphs</a> and finding interval representations for them, defining <a href="distance-hereditary_graph" title="wikilink">distance-hereditary graphs</a> (Spinrad, 2003) and for <a href="graph_drawing" title="wikilink">graph drawing</a> (Papadoupoulos, 2006). They play an important role in Lovász's celebrated proof of the <a href="perfect_graph_theorem#Characterizations_and_the_perfect_graph_theorems" title="wikilink">perfect graph theorem</a> (Golumbic, 1980).</p>

<p>For recognizing distance-hereditary graphs and <a href="circle_graph" title="wikilink">circle graphs</a>, a further generalization of modular decomposition, called the <a href="split_decomposition" title="wikilink">split decomposition</a>, is especially useful (Spinrad, 2003).</p>

<p>To avoid the possibility of ambiguity in the above definitions, we give the following formal definitions of modules. 

<math display="inline" id="Modular_decomposition:1">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>V</mi>
    <mo>,</mo>
    <mi>E</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>G</ci>
    <interval closure="open">
     <ci>V</ci>
     <ci>E</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G=(V,E)
  </annotation>
 </semantics>
</math>

. 

<math display="inline" id="Modular_decomposition:2">
 <semantics>
  <mrow>
   <mi>M</mi>
   <mo>⊆</mo>
   <mi>V</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <ci>M</ci>
    <ci>V</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M\subseteq V
  </annotation>
 </semantics>
</math>

 is a <strong>module</strong> of 

<math display="inline" id="Modular_decomposition:3">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

 if:</p>
<ul>
<li>the vertices of 

<math display="inline" id="Modular_decomposition:4">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 cannot be distinguished by any vertex in 

<math display="inline" id="Modular_decomposition:5">
 <semantics>
  <mrow>
   <mi>V</mi>
   <mo>\</mo>
   <mi>M</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-\</ci>
    <ci>V</ci>
    <ci>M</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V\backslash M
  </annotation>
 </semantics>
</math>

, i.e.</li>
</ul>

<p>

<math display="inline" id="Modular_decomposition:6">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mo>∀</mo>
      <mi>u</mi>
     </mrow>
     <mo>,</mo>
     <mi>v</mi>
    </mrow>
    <mo>∈</mo>
    <mi>M</mi>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mrow>
     <mo>∀</mo>
     <mi>x</mi>
    </mrow>
    <mo>∈</mo>
    <mrow>
     <mi>V</mi>
     <mo>\</mo>
     <mi>M</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <in></in>
     <list>
      <apply>
       <csymbol cd="latexml">for-all</csymbol>
       <ci>u</ci>
      </apply>
      <ci>v</ci>
     </list>
     <ci>M</ci>
    </apply>
    <apply>
     <in></in>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <ci>x</ci>
     </apply>
     <apply>
      <ci>normal-\</ci>
      <ci>V</ci>
      <ci>M</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall u,v\in M,\forall x\in V\backslash M
  </annotation>
 </semantics>
</math>

, either 

<math display="inline" id="Modular_decomposition:7">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 is adjacent to both 

<math display="inline" id="Modular_decomposition:8">
 <semantics>
  <mi>u</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>u</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Modular_decomposition:9">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>

 or 

<math display="inline" id="Modular_decomposition:10">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 is not adjacent to both 

<math display="inline" id="Modular_decomposition:11">
 <semantics>
  <mi>u</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>u</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Modular_decomposition:12">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>

.</p>
<ul>
<li>the vertices of 

<math display="inline" id="Modular_decomposition:13">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 have the same set of outer neighbors, i.e.</li>
</ul>

<p>

<math display="inline" id="Modular_decomposition:14">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mo>∀</mo>
      <mi>u</mi>
     </mrow>
     <mo>,</mo>
     <mi>v</mi>
    </mrow>
    <mo>∈</mo>
    <mi>M</mi>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mrow>
     <mrow>
      <mi>N</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>u</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>∖</mo>
     <mi>M</mi>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mi>N</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>v</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>∖</mo>
     <mi>M</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <in></in>
     <list>
      <apply>
       <csymbol cd="latexml">for-all</csymbol>
       <ci>u</ci>
      </apply>
      <ci>v</ci>
     </list>
     <ci>M</ci>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <setdiff></setdiff>
      <apply>
       <times></times>
       <ci>N</ci>
       <ci>u</ci>
      </apply>
      <ci>M</ci>
     </apply>
     <apply>
      <setdiff></setdiff>
      <apply>
       <times></times>
       <ci>N</ci>
       <ci>v</ci>
      </apply>
      <ci>M</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall u,v\in M,N(u)\setminus M=N(v)\setminus M
  </annotation>
 </semantics>
</math>

.</p>

<p>

<math display="inline" id="Modular_decomposition:15">
 <semantics>
  <mi mathvariant="normal">∅</mi>
  <annotation-xml encoding="MathML-Content">
   <emptyset></emptyset>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \emptyset
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Modular_decomposition:16">
 <semantics>
  <mi>V</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>V</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V
  </annotation>
 </semantics>
</math>

 and all the <a href="Singleton_set" title="wikilink">singletons</a> 

<math display="inline" id="Modular_decomposition:17">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mi>v</mi>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <ci>v</ci>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{v\}
  </annotation>
 </semantics>
</math>

 for 

<math display="inline" id="Modular_decomposition:18">
 <semantics>
  <mrow>
   <mi>v</mi>
   <mo>∈</mo>
   <mi>V</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>v</ci>
    <ci>V</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v\in V
  </annotation>
 </semantics>
</math>

 are modules, and are called <strong>trivial modules</strong>. A graph is <strong>prime</strong> if all its modules are trivial. <a href="connected_component_(graph_theory)" title="wikilink">Connected components</a> of a graph 

<math display="inline" id="Modular_decomposition:19">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

, or of its complement graph are also modules of 

<math display="inline" id="Modular_decomposition:20">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

.</p>

<p>

<math display="inline" id="Modular_decomposition:21">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 is a <strong>strong module</strong> of a graph 

<math display="inline" id="Modular_decomposition:22">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

 if it does not overlap any other module of 

<math display="inline" id="Modular_decomposition:23">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

: 

<math display="inline" id="Modular_decomposition:24">
 <semantics>
  <mrow>
   <mo>∀</mo>
   <msup>
    <mi>M</mi>
    <mo>′</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">for-all</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>M</ci>
     <ci>normal-′</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall M^{\prime}
  </annotation>
 </semantics>
</math>

 module of 

<math display="inline" id="Modular_decomposition:25">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

, either 

<math display="inline" id="Modular_decomposition:26">
 <semantics>
  <mrow>
   <mrow>
    <mi>M</mi>
    <mo>∩</mo>
    <msup>
     <mi>M</mi>
     <mo>′</mo>
    </msup>
   </mrow>
   <mo>=</mo>
   <mi mathvariant="normal">∅</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <intersect></intersect>
     <ci>M</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>M</ci>
      <ci>normal-′</ci>
     </apply>
    </apply>
    <emptyset></emptyset>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M\cap M^{\prime}=\emptyset
  </annotation>
 </semantics>
</math>

 or 

<math display="inline" id="Modular_decomposition:27">
 <semantics>
  <mrow>
   <mi>M</mi>
   <mo>⊆</mo>
   <msup>
    <mi>M</mi>
    <mo>′</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <ci>M</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>M</ci>
     <ci>normal-′</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M\subseteq M^{\prime}
  </annotation>
 </semantics>
</math>

 or 

<math display="inline" id="Modular_decomposition:28">
 <semantics>
  <mrow>
   <msup>
    <mi>M</mi>
    <mo>′</mo>
   </msup>
   <mo>⊆</mo>
   <mi>M</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>M</ci>
     <ci>normal-′</ci>
    </apply>
    <ci>M</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M^{\prime}\subseteq M
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="modular-quotients-and-factors">Modular quotients and factors</h2>

<p>If 

<math display="inline" id="Modular_decomposition:29">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Modular_decomposition:30">
 <semantics>
  <mi>Y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y
  </annotation>
 </semantics>
</math>

 are disjoint modules, then it is easy to see that either every member of 

<math display="inline" id="Modular_decomposition:31">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

 is a neighbor of every element of 

<math display="inline" id="Modular_decomposition:32">
 <semantics>
  <mi>Y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y
  </annotation>
 </semantics>
</math>

, or no member of 

<math display="inline" id="Modular_decomposition:33">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

 is adjacent to any member of 

<math display="inline" id="Modular_decomposition:34">
 <semantics>
  <mi>Y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y
  </annotation>
 </semantics>
</math>

. Thus, the relationship between two disjoint modules is either <em>adjacent</em> or <em>nonadjacent</em>. No relationship intermediate between these two extremes can exist.</p>

<p>Because of this, <strong>modular partitions</strong> of 

<math display="inline" id="Modular_decomposition:35">
 <semantics>
  <mi>V</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>V</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V
  </annotation>
 </semantics>
</math>

 where each partition class is a module are of particular interest. Suppose 

<math display="inline" id="Modular_decomposition:36">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 is a modular partition. Since the partition classes are disjoint, their adjacencies constitute a new graph, a <strong><a href="quotient_graph" title="wikilink">quotient graph</a></strong> 

<math display="inline" id="Modular_decomposition:37">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mo>/</mo>
   <mi>P</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <ci>G</ci>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G/P
  </annotation>
 </semantics>
</math>

, whose vertices are the members of 

<math display="inline" id="Modular_decomposition:38">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

. That is, each vertex of 

<math display="inline" id="Modular_decomposition:39">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mo>/</mo>
   <mi>P</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <ci>G</ci>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G/P
  </annotation>
 </semantics>
</math>

 is a module of G, and the adjacencies of these modules are the edges of 

<math display="inline" id="Modular_decomposition:40">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mo>/</mo>
   <mi>P</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <ci>G</ci>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G/P
  </annotation>
 </semantics>
</math>

.</p>

<p>In the figure below, vertex 1, vertices 2 through 4, vertex 5, vertices 6 and 7, and vertices 8 through 11 are a modular partition. In the upper right diagram, the edges between these sets depict the quotient given by this partition, while the edges internal to the sets depict the corresponding factors.</p>

<p>The partitions <em>{V}</em> and 

<math display="inline" id="Modular_decomposition:41">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mi>x</mi>
    <mo stretchy="false">}</mo>
   </mrow>
   <mo stretchy="false">|</mo>
   <mrow>
    <mi>x</mi>
    <mo>∈</mo>
    <mi>V</mi>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">conditional-set</csymbol>
    <set>
     <ci>x</ci>
    </set>
    <apply>
     <in></in>
     <ci>x</ci>
     <ci>V</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{\{x\}|x\in V\}
  </annotation>
 </semantics>
</math>

 are the <strong>trivial modular partitions</strong>. 

<math display="inline" id="Modular_decomposition:42">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mo>/</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mi>V</mi>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <ci>G</ci>
    <set>
     <ci>V</ci>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G/\{V\}
  </annotation>
 </semantics>
</math>

 is just the one-vertex graph, while 

<math display="inline" id="Modular_decomposition:43">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mo>/</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mi>x</mi>
     <mo stretchy="false">}</mo>
    </mrow>
    <mo stretchy="false">|</mo>
    <mrow>
     <mi>x</mi>
     <mo>∈</mo>
     <mi>V</mi>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <ci>G</ci>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <set>
      <ci>x</ci>
     </set>
     <apply>
      <in></in>
      <ci>x</ci>
      <ci>V</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G/\{\{x\}|x\in V\}
  </annotation>
 </semantics>
</math>

 = G. Suppose 

<math display="inline" id="Modular_decomposition:44">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

 is a nontrivial module. Then 

<math display="inline" id="Modular_decomposition:45">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

 and the one-elements subsets of 

<math display="inline" id="Modular_decomposition:46">
 <semantics>
  <mrow>
   <mi>V</mi>
   <mo>\</mo>
   <mi>X</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-\</ci>
    <ci>V</ci>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V\backslash X
  </annotation>
 </semantics>
</math>

 are a nontrivial modular partition of 

<math display="inline" id="Modular_decomposition:47">
 <semantics>
  <mi>V</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>V</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V
  </annotation>
 </semantics>
</math>

. Thus, the existence of <em>any</em> nontrivial modules implies the existence of nontrivial modular partitions. In general, many or all members of 

<math display="inline" id="Modular_decomposition:48">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 can be nontrivial modules.</p>

<p>If <em>P</em> is a nontrivial modular partition, then <em>G/P</em> is a compact representation of all the edges that have endpoints in different partition classes of <em>P</em>. For each partition class <em>X</em> in <em>P</em>, the subgraph <em>G[X]</em> induced by <em>X</em> is called a <strong>factor</strong> and gives a representation of all edges with both endpoints in <em>X</em>. Therefore, the edges of <em>G</em> can be reconstructed given only the quotient graph <em>G/P</em> and its factors. The term <em>prime</em> graph comes from the fact that a prime graph has only trivial quotients and factors.</p>

<p>When <em>G[X]</em> is a factor of a modular quotient <em>G/P</em>, it is possible that <em>G[X]</em> can be recursively decomposed into factors and quotients. Each level of the recursion gives rise to a quotient. As a base case, the graph has only one vertex. Collectively, <em>G</em> can be reconstructed inductively by reconstructing the factors from the bottom up, inverting the steps of the decomposition by combining factors with the quotient at each level.</p>

<p>In the figure below, such a recursive decomposition is represented by a tree that depicts one way of recursively decomposing factors of an initial modular partition into smaller modular partitions.</p>

<p>A way to recursively decompose a graph into factors and quotients may not be unique. (For example, all subsets of the vertices of a complete graph are modules, which means that there are many different ways of decomposing it recursively.) Some ways may be more useful than others.</p>
<h2 id="the-modular-decomposition">The modular decomposition</h2>

<p>Fortunately, there exists such a recursive decomposition of a graph that implicitly represents all ways of decomposing it; this is the modular decomposition. It is itself a way of decomposing a graph recursively into quotients, but it subsumes all others. The decomposition depicted in the figure below is this special decomposition for the given graph.</p>
<figure><b>(Figure)</b>
<figcaption>A graph, its quotient where "bags" of vertices of the graph correspond to the children of the root of the modular decomposition tree, and its full modular decomposition tree: series nodes are labeled "s", parallel nodes "//" and prime nodes "p".</figcaption>
</figure>

<p>The following is a key observation in understanding the modular decomposition:</p>

<p><strong>If <em>X</em> is a module of <em>G</em> and <em>Y</em> is a subset of <em>X</em></strong>, then <em>Y</em> is a module of <em>G</em>, if and only if it is a module of <em>G[X]</em>.</p>

<p>In (Gallai, 1967), Gallai defined the modular decomposition recursively on a graph with vertex set <em>V</em>, as follows:</p>
<ol>
<li>As a base case, if <em>G</em> only has one vertex, its modular decomposition is a single tree node.</li>
<li>Gallai showed that if <em>G</em> is connected and so is its complement, then the maximal modules that are proper subsets of <em>V</em> are a partition of <em>V</em>. They are therefore a modular partition. The quotient that they define is prime. The root of the tree is labeled a <em>prime</em> node, and these modules are assigned as children of <em>V</em>. Since they are maximal, every module not represented so far is contained in a child <em>X</em> of <em>V</em>. For each child <em>X</em> of <em>V</em>, replacing <em>X</em> with the modular decomposition tree of <em>G[X]</em> gives a representation of all modules of <em>G</em>, by the key observation above.</li>
<li>If <em>G</em> is disconnected, its complement is connected. Every union of connected components is a module of <em>G</em>. All other modules are subsets of a single connected component. This represents all modules, except for subsets of connected components. For each component <em>X</em>, replacing <em>X</em> by the modular decomposition tree of <em>G[X]</em> gives a representation of all modules of <em>G</em>, by the key observation above. The root of the tree is labeled a <em>parallel</em> node, and it is attached in place of <em>X</em> as a child of the root. The quotient defined by the children is the complement of a complete graph.</li>
<li>If the complement of <em>G</em> is disconnected, <em>G</em> is connected. The subtrees that are children of <em>V</em> are defined in a way that is symmetric with the case where <em>G</em> is disconnected, since the modules of a graph are the same as the modules of its complement. The root of the tree is labeled a <em>serial</em> node, and the quotient defined by the children is a complete graph.</li>
</ol>

<p>The final tree has one-element sets of vertices of <em>G</em> as its leaves, due to the base case. A set <em>Y</em> of vertices of <em>G</em> is a module if and only if it is a node of the tree or a union of children of a series or parallel node. This implicitly gives all modular partitions of <em>V</em>. It is in this sense that the modular decomposition tree "subsumes" all other ways of recursively decomposing <em>G</em> into quotients.</p>
<h2 id="algorithmic-issues">Algorithmic issues</h2>

<p>A data structure for representing the modular decomposition tree should support the operation that inputs a node and returns the set of vertices of G that the node represents. An obvious way to do this is to assign to each node a list of the <em>k</em> vertices of <em>G</em> that it represents. Given a pointer to a node, this structure could return the set of vertices of <em>G</em> that it represents in <em>O(k)</em> time. However, this data structure would require 

<math display="inline" id="Modular_decomposition:49">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Θ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>n</mi>
     <mn>2</mn>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Θ</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>n</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Theta(n^{2})
  </annotation>
 </semantics>
</math>

 space in the worst case.</p>
<figure><b>(Figure)</b>
<embed src="O n ModularDecompRep.pdf" title="An O(n) representation of the modular decomposition"></embed><figcaption>An O(n) representation of the modular decomposition</figcaption>
</figure>

<p>An <em>O(n)</em>-space alternative that matches this performance is obtained by representing the modular decomposition tree using any standard <em>O(n)</em> rooted-tree data structure and labeling each leaf with the vertex of <em>G</em> that it represents. The set represented by an internal node <em>v</em> is given by the set of labels of its leaf descendants. It is well known that any rooted tree with <em>k</em> leaves has at most <em>k-1</em> internal nodes. One can use a depth-first search starting at <em>v</em> to report the labels of leaf-descendants of <em>v</em> in <em>O(k)</em> time.</p>
<figure><b>(Figure)</b>
<embed src="ModDecompQuotients.pdf" title="The modular decomposition, augmented with a quotient on the children of each internal node, gives a complete representation of G."></embed><figcaption>The modular decomposition, augmented with a quotient on the children of each internal node, gives a complete representation of <em>G</em>.</figcaption>
</figure>

<p>Each node <em>X</em> is a set of vertices of <em>G</em> and, if <em>X</em> is an internal node, the set <em>P</em> of children of <em>X</em> is a partition of <em>X</em> where each partition class is a module. They therefore induce the quotient <em>G[X]/P</em> in <em>G[X]</em>. The vertices of this quotient are the elements of <em>P</em>, so <em>G[X]/P</em> can be represented by installing edges among the children of <em>X</em>. If <em>Y</em> and <em>Z</em> are two members of <em>P</em> and 

<math display="inline" id="Modular_decomposition:50">
 <semantics>
  <mrow>
   <mi>u</mi>
   <mo>∈</mo>
   <mi>Y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>u</ci>
    <ci>Y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u\in Y
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Modular_decomposition:51">
 <semantics>
  <mrow>
   <mi>v</mi>
   <mo>∈</mo>
   <mi>Z</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>v</ci>
    <ci>Z</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v\in Z
  </annotation>
 </semantics>
</math>

, then <em>u</em> and <em>v</em> are adjacent in <em>G</em> if and only if <em>Y</em> and <em>Z</em> are adjacent in this quotient. For any pair <em>{u,v}</em> of vertices of <em>G</em>, this is determined by the quotient at children of the least common ancestor of <em>{u}</em> and <em>{v}</em> in the modular decomposition tree. Therefore, the modular decomposition, labeled in this way with quotients, gives a complete representation of <em>G</em>.</p>

<p>Many combinatorial problems can be solved on <em>G</em> by solving the problem separately on each of these quotients. For example, <em>G</em> is a comparability graph if and only if each of these quotients is a comparability graph (Gallai, 67; Möhring, 85). Therefore, to find whether a graph is a comparability graph, one need only find whether each of the quotients is. In fact, to find a <a href="comparability_graph" title="wikilink">transitive orientation</a> of a comparability graph, it suffices to transitively orient each of these quotients of its modular decomposition (Gallai, 67; Möhring, 85). A similar phenomenon applies for permutation graphs, (McConnell and Spinrad '94), interval graphs (Hsu and Ma '99), perfect graphs, and other graph classes. Some important combinatorial optimization problems on graphs can be solved using a similar strategy (Möhring, 85).</p>

<p><a href="Cograph" title="wikilink">Cographs</a> are the graphs that only have parallel or series nodes in their modular decomposition tree.</p>

<p>The first polynomial algorithm to compute the modular decomposition tree of a graph was published in 1972 (James, Stanton &amp; Cowan 1972) and now linear algorithms are available (McConnell &amp; Spinrad 1999, Tedder et al. 2007, Cournier &amp; Habib 1994).</p>
<h2 id="generalizations">Generalizations</h2>

<p>Modular decomposition of directed graphs can be done in linear time .</p>

<p>With a small number of simple exceptions, every graph with a nontrivial modular decomposition also has a <a href="skew_partition" title="wikilink">skew partition</a> .</p>
<h2 id="references">References</h2>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li>

<p>.</p></li>
<li></li>
<li>

<p>.</p></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li>A <a class="uri" href="Perl" title="wikilink">Perl</a> <a href="http://www.dns.net/dist/graph/">implementation of a modular decomposition algorithm</a></li>
<li>A Java <a href="http://code.google.com/p/bpstruct/">implementation of a modular decomposition algorithm</a></li>
</ul>

<p>"</p>

<p><a href="Category:Graph_theory_objects" title="wikilink">Category:Graph theory objects</a></p>
</body>
</html>
