   Domain decomposition methods      Domain decomposition methods  table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
   margin: 0; padding: 0; vertical-align: baseline; border: none; }
 <style>
 table.sourceCode { width: 100%; line-height: 100%; }
 td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
 td.sourceCode { padding-left: 5px; }
 code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
 code > span.dt { color: #902000; } /* DataType */
 code > span.dv { color: #40a070; } /* DecVal */
 code > span.bn { color: #40a070; } /* BaseN */
 code > span.fl { color: #40a070; } /* Float */
 code > span.ch { color: #4070a0; } /* Char */
 code > span.st { color: #4070a0; } /* String */
 code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
 code > span.ot { color: #007020; } /* Other */
 code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
 code > span.fu { color: #06287e; } /* Function */
 code > span.er { color: #ff0000; font-weight: bold; } /* Error */
 code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
 code > span.cn { color: #880000; } /* Constant */
 code > span.sc { color: #4070a0; } /* SpecialChar */
 code > span.vs { color: #4070a0; } /* VerbatimString */
 code > span.ss { color: #bb6688; } /* SpecialString */
 code > span.im { } /* Import */
 code > span.va { color: #19177c; } /* Variable */
 code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
 code > span.op { color: #666666; } /* Operator */
 code > span.bu { } /* BuiltIn */
 code > span.ex { } /* Extension */
 code > span.pp { color: #bc7a00; } /* Preprocessor */
 code > span.at { color: #7d9029; } /* Attribute */
 code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
 code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
 code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
 code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */     (Figure)  Domain decomposition methods   In mathematics , numerical analysis , and numerical partial differential equations , domain decomposition methods solve a boundary value problem by splitting it into smaller boundary value problems on subdomains and iterating to coordinate the solution between adjacent subdomains. A coarse problem with one or few unknowns per subdomain is used to further coordinate the solution between the subdomains globally. The problems on the subdomains are independent, which makes domain decomposition methods suitable for parallel computing . Domain decomposition methods are typically used as preconditioners for Krylov space  iterative methods , such as the conjugate gradient method or GMRES .  In overlapping domain decomposition methods, the subdomains overlap by more than the interface. Overlapping domain decomposition methods include the Schwarz alternating method and the additive Schwarz method . Many domain decomposition methods can be written and analyzed as a special case of the abstract additive Schwarz method .  In non-overlapping methods, the subdomains intersect only on their interface. In primal methods, such as Balancing domain decomposition and BDDC , the continuity of the solution across subdomain interface is enforced by representing the value of the solution on all neighboring subdomains by the same unknown. In dual methods, such as FETI , the continuity of the solution across the subdomain interface is enforced by Lagrange multipliers . The FETI-DP method is hybrid between a dual and a primal method.  Non-overlapping domain decomposition methods are also called iterative substructuring methods .  Mortar methods are discretization methods for partial differential equations, which use separate discretization on nonoverlapping subdomains. The meshes on the subdomains do not match on the interface, and the equality of the solution is enforced by Lagrange multipliers, judiciously chosen to preserve the accuracy of the solution. In the engineering practice in the finite element method, continuity of solutions between non-matching subdomains is implemented by multiple-point constraints .  Finite element simulations of moderate size models require solving linear systems with millions of unknowns. Several hours per time step is an average sequential run time, therefore, parallel computing is a necessity. Domain decomposition methods embody large potential for a parallelization of the finite element methods, and serve a basis for distributed, parallel computations.  Example 1: 1D Linear BVP         u  ′′    (  x  )    -   u   (  x  )     =  0           superscript  u  ′′   x     u  x    0    u^{\prime\prime}(x)-u(x)=0          u   (  0  )    =  0   ,    u   (  1  )    =  1      formulae-sequence      u  0   0       u  1   1     u(0)=0,u(1)=1    The exact solution is:      u   (  x  )    =     e  x   -   e   -  x       e  1   -   e   -  1            u  x        superscript  e  x    superscript  e    x        superscript  e  1    superscript  e    1        u(x)=\frac{e^{x}-e^{-x}}{e^{1}-e^{-1}}    Subdivide the domain into two subdomains, one from    [  0  ,   1  2   ]     0    1  2     [0,\frac{1}{2}]   and another from    [   1  2   ,  1  ]       1  2   1    [\frac{1}{2},1]   . In each of these two subdomains define interpolating functions     v  1    (  x  )        subscript  v  1   x    v_{1}(x)   and     v  2    (  x  )        subscript  v  2   x    v_{2}(x)   At the interface between these two subdomains the following inferface conditions shall be imposed:       v  1    (   1  2   )    =    v  2    (   1  2   )           subscript  v  1     1  2       subscript  v  2     1  2      v_{1}\left(\frac{1}{2}\right)=v_{2}\left(\frac{1}{2}\right)          v  1  ′    (   1  2   )    =    v  2  ′    (   1  2   )           superscript   subscript  v  1   normal-′     1  2       superscript   subscript  v  2   normal-′     1  2      v_{1}^{\prime}\left(\frac{1}{2}\right)=v_{2}^{\prime}\left(\frac{1}{2}\right)    Let the interpolating functions be defined as:       v  1    (  x  )    =    ∑   n  =  0   N     u  n    T  n    (    y  1    (  x  )    )            subscript  v  1   x     superscript   subscript     n  0    N      subscript  u  n    subscript  T  n      subscript  y  1   x       v_{1}(x)=\sum_{n=0}^{N}u_{n}T_{n}(y_{1}(x))          v  2    (  x  )    =    ∑   n  =  0   N     u   n  +  N     T  n    (    y  2    (  x  )    )            subscript  v  2   x     superscript   subscript     n  0    N      subscript  u    n  N     subscript  T  n      subscript  y  2   x       v_{2}(x)=\sum_{n=0}^{N}u_{n+N}T_{n}(y_{2}(x))          y  1    (  x  )    =    4  x   -  1          subscript  y  1   x       4  x   1     y_{1}(x)=4x-1          y  2    (  x  )    =    4  x   -  3          subscript  y  2   x       4  x   3     y_{2}(x)=4x-3    Where     T  n    (  y  )        subscript  T  n   y    T_{n}(y)   is the nth cardinal function of the chebyshev polynomials of the first kind with input argument y. If N=4 then the following approximation is obtained by this scheme:      u  1   =  0.06236       subscript  u  1   0.06236    u_{1}=0.06236         u  2   =  0.21495       subscript  u  2   0.21495    u_{2}=0.21495         u  3   =  0.37428       subscript  u  3   0.37428    u_{3}=0.37428         u  4   =  0.44341       subscript  u  4   0.44341    u_{4}=0.44341         u  5   =  0.51492       subscript  u  5   0.51492    u_{5}=0.51492         u  6   =  0.69972       subscript  u  6   0.69972    u_{6}=0.69972         u  7   =  0.90645       subscript  u  7   0.90645    u_{7}=0.90645    This was obtained with the following MATLAB code.   clear all
 N= 4 ;
 a1= 0 ; b1= 1 / 2 ; 
 
 [T D1 D2 E1 E2 x xsub]=cheb(N,a1,b1); % the diff matrices on [0,1/2] are the same  %as those on [1/2 1]. I=eye(N+ 1 );
 H=D2-I;
 H1=[[ 1 zeros( 1 ,N)]; H( 2 :end- 1 ,:); [zeros( 1 ,N) 1 ]];
 H1=[H1 [zeros(N,N+ 1 ); -[ 1 zeros( 1 ,N)]]];
 H2=[D1( 1 ,:); H( 2 :end- 1 ,:); [zeros( 1 ,N) 1 ]];
 H2=[[-D1(N+ 1 ,:); zeros(N,N+ 1 )] H2];
 K=[H1; H2];
 F=[zeros( 2 *N+ 1 , 1 ); 1 ];
 u=K\F;
 xx=-cos(pi*( 0 :N)'/N);
 x1= 1 / 4 *(xx+ 1 ); x2= 1 / 4 *(xx+ 3 );
 x=[x1; x2];
 uex=(exp(x)-exp(-x))./(exp( 1 )-exp(- 1 ));  See also   Multigrid method   External links   The official Domain Decomposition Methods page  Domain Decomposition - Numerical Simulations page   "  Category:Domain decomposition methods  Category:Articles with example MATLAB/Octave code  