<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="695">Functional predicate</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Functional predicate</h1>
<hr/>

<p>In <a href="formal_logic" title="wikilink">formal logic</a> and related branches of <a class="uri" href="mathematics" title="wikilink">mathematics</a>, a <strong>functional predicate</strong>, or <strong>function symbol</strong>, is a logical symbol that may be applied to an object term to produce another object term. Functional predicates are also sometimes called <em>mappings</em>, but that term has other meanings as well. In a <a href="model_(logic)" title="wikilink">model</a>, a function symbol will be modelled by a <a href="function_(mathematics)" title="wikilink">function</a>.</p>

<p>Specifically, the symbol <em>F</em> in a <a href="formal_language" title="wikilink">formal language</a> is a functional symbol if, <a href="given_any" title="wikilink">given any</a> symbol <em>X</em> representing an object in the language, <em>F</em>(<em>X</em>) is again a symbol representing an object in that language. In <a href="typed_logic" title="wikilink">typed logic</a>, <em>F</em> is a functional symbol with <em>domain</em> type <strong>T</strong> and <em>codomain</em> type <strong>U</strong> if, given any symbol <em>X</em> representing an object of type <strong>T</strong>, <em>F</em>(<em>X</em>) is a symbol representing an object of type <strong>U</strong>. One can similarly define function symbols of more than one variable, analogous to functions of more than one variable; a function symbol in <a href="0_(number)" title="wikilink">zero</a> variables is simply a <a href="Logical_constant" title="wikilink">constant</a> symbol.</p>

<p>Now consider a model of the formal language, with the types <strong>T</strong> and <strong>U</strong> modelled by <a href="Set_(mathematics)" title="wikilink">sets</a> [<strong>T</strong>] and [<strong>U</strong>] and each symbol <em>X</em> of type <strong>T</strong> modelled by an element [<em>X</em>] in [<strong>T</strong>]. Then <em>F</em> can be modelled by the set</p>

<p>
<math display="block" id="Functional_predicate:0">
<semantics>
<mrow>
<mrow>
<mrow>
<mo stretchy="false">[</mo>
<mi>F</mi>
<mo stretchy="false">]</mo>
</mrow>
<mo>:=</mo>
<mrow>
<mo maxsize="120%" minsize="120%">{</mo>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mo stretchy="false">[</mo>
<mi>X</mi>
<mo stretchy="false">]</mo>
</mrow>
<mo>,</mo>
<mrow>
<mo stretchy="false">[</mo>
<mrow>
<mi>F</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>X</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo stretchy="false">]</mo>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mo>:</mo>
<mrow>
<mrow>
<mo stretchy="false">[</mo>
<mi>X</mi>
<mo stretchy="false">]</mo>
</mrow>
<mo>‚àà</mo>
<mrow>
<mo stretchy="false">[</mo>
<mi>ùêì</mi>
<mo stretchy="false">]</mo>
</mrow>
</mrow>
<mo maxsize="120%" minsize="120%">}</mo>
</mrow>
</mrow>
<mo>,</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="latexml">assign</csymbol>
<apply>
<csymbol cd="latexml">delimited-[]</csymbol>
<ci>F</ci>
</apply>
<apply>
<csymbol cd="latexml">conditional-set</csymbol>
<interval closure="open">
<apply>
<csymbol cd="latexml">delimited-[]</csymbol>
<ci>X</ci>
</apply>
<apply>
<csymbol cd="latexml">delimited-[]</csymbol>
<apply>
<times></times>
<ci>F</ci>
<ci>X</ci>
</apply>
</apply>
</interval>
<apply>
<in></in>
<apply>
<csymbol cd="latexml">delimited-[]</csymbol>
<ci>X</ci>
</apply>
<apply>
<csymbol cd="latexml">delimited-[]</csymbol>
<ci>ùêì</ci>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   [F]:=\big\{([X],[F(X)]):[X]\in[\mathbf{T}]\big\},
  </annotation>
</semantics>
</math>

 which is simply a <a href="function_(mathematics)" title="wikilink">function</a> with domain [<strong>T</strong>] and codomain [<strong>U</strong>]. It is a requirement of a consistent model that [<em>F</em>(<em>X</em>)] = [<em>F</em>(<em>Y</em>)] whenever [<em>X</em>] = [<em>Y</em>].</p>
<h2 id="introducing-new-function-symbols">Introducing new function symbols</h2>

<p>In a treatment of predicate logic that allows one to introduce new predicate symbols, one will also want to be able to introduce new function symbols. Given the function symbols <em>F</em> and <em>G</em>, one can introduce a new function symbol <em>F</em> ‚àò <em>G</em>, the <em>composition</em> of <em>F</em> and <em>G</em>, satisfying (<em>F</em> ‚àò <em>G</em>)(<em>X</em>) = <em>F</em>(<em>G</em>(<em>X</em>)), <a href="for_all" title="wikilink">for all</a> <em>X</em>. Of course, the right side of this equation doesn't make sense in typed logic unless the domain type of <em>F</em> matches the codomain type of <em>G</em>, so this is required for the composition to be defined.</p>

<p>One also gets certain function symbols automatically. In untyped logic, there is an <em>identity predicate</em> id that satisfies id(<em>X</em>) = <em>X</em> for all <em>X</em>. In typed logic, given any type <strong>T</strong>, there is an identity predicate id<sub><strong>T</strong></sub> with domain and codomain type <strong>T</strong>; it satisfies id<sub><strong>T</strong></sub>(<em>X</em>) = <em>X</em> for all <em>X</em> of type <strong>T</strong>. Similarly, if <strong>T</strong> is a <a class="uri" href="subtype" title="wikilink">subtype</a> of <strong>U</strong>, then there is an inclusion predicate of domain type <strong>T</strong> and codomain type <strong>U</strong> that satisfies the same equation; there are additional function symbols associated with other ways of constructing new types out of old ones.</p>

<p>Additionally, one can define functional predicates after proving an appropriate <a class="uri" href="theorem" title="wikilink">theorem</a>. (If you're working in a <a href="formal_system" title="wikilink">formal system</a> that doesn't allow you to introduce new symbols after proving theorems, then you will have to use relation symbols to get around this, as in the next section.) Specifically, if you can prove that for every <em>X</em> (or every <em>X</em> of a certain type), <a href="there_exists" title="wikilink">there exists</a> a <a class="uri" href="unique" title="wikilink">unique</a> <em>Y</em> satisfying some condition <em>P</em>, then you can introduce a function symbol <em>F</em> to indicate this. Note that <em>P</em> will itself be a relational <a href="predicate_(logic)" title="wikilink">predicate</a> involving both <em>X</em> and <em>Y</em>. So if there is such a predicate <em>P</em> and a theorem:</p>
<dl>
<dd>For all <em>X</em> of type <strong>T</strong>, for some unique <em>Y</em> of type <strong>U</strong>, <em>P</em>(<em>X</em>,<em>Y</em>),
</dd>
</dl>

<p>then you can introduce a function symbol <em>F</em> of domain type <strong>T</strong> and codomain type <strong>U</strong> that satisfies:</p>
<dl>
<dd>For all <em>X</em> of type <strong>T</strong>, for all <em>Y</em> of type <strong>U</strong>, <em>P</em>(<em>X</em>,<em>Y</em>) <a href="if_and_only_if" title="wikilink">if and only if</a> <em>Y</em> = <em>F</em>(<em>X</em>).
</dd>
</dl>
<h2 id="doing-without-functional-predicates">Doing without functional predicates</h2>

<p>Many treatments of predicate logic don't allow functional predicates, only relational <a href="predicate_(logic)" title="wikilink">predicates</a>. This is useful, for example, in the context of proving <a href="metalogic" title="wikilink">metalogical</a> theorems (such as <a href="G√∂del's_incompleteness_theorem" title="wikilink">G√∂del's incompleteness theorems</a>), where one doesn't want to allow the introduction of new functional symbols (nor any other new symbols, for that matter). But there is a method of replacing functional symbols with relational symbols wherever the former may occur; furthermore, this is algorithmic and thus suitable for applying most metalogical theorems to the result.</p>

<p>Specifically, if <em>F</em> has domain type <strong>T</strong> and <a class="uri" href="codomain" title="wikilink">codomain</a> type <strong>U</strong>, then it can be replaced with a predicate <em>P</em> of type (<strong>T</strong>,<strong>U</strong>). Intuitively, <em>P</em>(<em>X</em>,<em>Y</em>) means <em>F</em>(<em>X</em>) = <em>Y</em>. Then whenever <em>F</em>(<em>X</em>) would appear in a statement, you can replace it with a new symbol <em>Y</em> of type <strong>U</strong> and include another statement <em>P</em>(<em>X</em>,<em>Y</em>). To be able to make the same deductions, you need an additional proposition:</p>
<dl>
<dd><a href="For_all" title="wikilink">For all</a> <em>X</em> of type <strong>T</strong>, for some <a class="uri" href="unique" title="wikilink">unique</a> <em>Y</em> of type <strong>U</strong>, <em>P</em>(<em>X</em>,<em>Y</em>).
</dd>
</dl>

<p>(Of course, this is the same proposition that had to be proved as a theorem before introducing a new function symbol in the previous section.)</p>

<p>Because the elimination of functional predicates is both convenient for some purposes and possible, many treatments of formal logic do not deal explicitly with function symbols but instead use only relation symbols; another way to think of this is that a functional predicate is a <em>special kind of</em> predicate, specifically one that satisfies the proposition above. This may seem to be a problem if you wish to specify a proposition <a href="schema_(logic)" title="wikilink">schema</a> that applies only to functional predicates <em>F</em>; how do you know ahead of time whether it satisfies that condition? To get an equivalent formulation of the schema, first replace anything of the form <em>F</em>(<em>X</em>) with a new variable <em>Y</em>. Then <a href="universally_quantify" title="wikilink">universally quantify</a> over each <em>Y</em> immediately after the corresponding <em>X</em> is introduced (that is, after <em>X</em> is quantified over, or at the beginning of the statement if <em>X</em> is free), and guard the quantification with <em>P</em>(<em>X</em>,<em>Y</em>). Finally, make the entire statement a <a href="material_conditional" title="wikilink">material consequence</a> of the uniqueness condition for a functional predicate above.</p>

<p>Let us take as an example the <a href="axiom_schema_of_replacement" title="wikilink">axiom schema of replacement</a> in <a href="Zermelo‚ÄìFraenkel_set_theory" title="wikilink">Zermelo‚ÄìFraenkel set theory</a>. (This example uses <a href="mathematical_symbols" title="wikilink">mathematical symbols</a>.) This schema states (in one form), for any functional predicate <em>F</em> in one variable:</p>

<p>
<math display="block" id="Functional_predicate:1">
<semantics>
<mrow>
<mrow>
<mrow>
<mrow>
<mo>‚àÄ</mo>
<mi>A</mi>
</mrow>
<mo>,</mo>
<mrow>
<mo>‚àÉ</mo>
<mi>B</mi>
</mrow>
<mo>,</mo>
<mrow>
<mo>‚àÄ</mo>
<mi>C</mi>
</mrow>
<mo>,</mo>
<mi>C</mi>
</mrow>
<mo>‚àà</mo>
<mi>A</mi>
<mo>‚Üí</mo>
<mrow>
<mi>F</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>C</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>‚àà</mo>
<mi>B</mi>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<and></and>
<apply>
<in></in>
<list>
<apply>
<csymbol cd="latexml">for-all</csymbol>
<ci>A</ci>
</apply>
<apply>
<exists></exists>
<ci>B</ci>
</apply>
<apply>
<csymbol cd="latexml">for-all</csymbol>
<ci>C</ci>
</apply>
<ci>C</ci>
</list>
<ci>A</ci>
</apply>
<apply>
<ci>normal-‚Üí</ci>
<share href="#.cmml">
</share>
<apply>
<times></times>
<ci>F</ci>
<ci>C</ci>
</apply>
</apply>
<apply>
<in></in>
<share href="#.cmml">
</share>
<ci>B</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \forall A,\exists B,\forall C,C\in A\rightarrow F(C)\in B.
  </annotation>
</semantics>
</math>

 First, we must replace <em>F</em>(<em>C</em>) with some other variable <em>D</em>:</p>

<p>
<math display="block" id="Functional_predicate:2">
<semantics>
<mrow>
<mrow>
<mrow>
<mrow>
<mo>‚àÄ</mo>
<mi>A</mi>
</mrow>
<mo>,</mo>
<mrow>
<mo>‚àÉ</mo>
<mi>B</mi>
</mrow>
<mo>,</mo>
<mrow>
<mo>‚àÄ</mo>
<mi>C</mi>
</mrow>
<mo>,</mo>
<mi>C</mi>
</mrow>
<mo>‚àà</mo>
<mi>A</mi>
<mo>‚Üí</mo>
<mi>D</mi>
<mo>‚àà</mo>
<mi>B</mi>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<and></and>
<apply>
<in></in>
<list>
<apply>
<csymbol cd="latexml">for-all</csymbol>
<ci>A</ci>
</apply>
<apply>
<exists></exists>
<ci>B</ci>
</apply>
<apply>
<csymbol cd="latexml">for-all</csymbol>
<ci>C</ci>
</apply>
<ci>C</ci>
</list>
<ci>A</ci>
</apply>
<apply>
<ci>normal-‚Üí</ci>
<share href="#.cmml">
</share>
<ci>D</ci>
</apply>
<apply>
<in></in>
<share href="#.cmml">
</share>
<ci>B</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \forall A,\exists B,\forall C,C\in A\rightarrow D\in B.
  </annotation>
</semantics>
</math>

 Of course, this statement isn't correct; <em>D</em> must be quantified over just after <em>C</em>:</p>

<p>
<math display="block" id="Functional_predicate:3">
<semantics>
<mrow>
<mrow>
<mrow>
<mrow>
<mo>‚àÄ</mo>
<mi>A</mi>
</mrow>
<mo>,</mo>
<mrow>
<mo>‚àÉ</mo>
<mi>B</mi>
</mrow>
<mo>,</mo>
<mrow>
<mo>‚àÄ</mo>
<mi>C</mi>
</mrow>
<mo>,</mo>
<mrow>
<mo>‚àÄ</mo>
<mi>D</mi>
</mrow>
<mo>,</mo>
<mi>C</mi>
</mrow>
<mo>‚àà</mo>
<mi>A</mi>
<mo>‚Üí</mo>
<mi>D</mi>
<mo>‚àà</mo>
<mi>B</mi>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<and></and>
<apply>
<in></in>
<list>
<apply>
<csymbol cd="latexml">for-all</csymbol>
<ci>A</ci>
</apply>
<apply>
<exists></exists>
<ci>B</ci>
</apply>
<apply>
<csymbol cd="latexml">for-all</csymbol>
<ci>C</ci>
</apply>
<apply>
<csymbol cd="latexml">for-all</csymbol>
<ci>D</ci>
</apply>
<ci>C</ci>
</list>
<ci>A</ci>
</apply>
<apply>
<ci>normal-‚Üí</ci>
<share href="#.cmml">
</share>
<ci>D</ci>
</apply>
<apply>
<in></in>
<share href="#.cmml">
</share>
<ci>B</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \forall A,\exists B,\forall C,\forall D,C\in A\rightarrow D\in B.
  </annotation>
</semantics>
</math>

 We still must introduce <em>P</em> to guard this quantification:</p>

<p>
<math display="block" id="Functional_predicate:4">
<semantics>
<mrow>
<mo>‚àÄ</mo>
<mi>A</mi>
<mo>,</mo>
<mo>‚àÉ</mo>
<mi>B</mi>
<mo>,</mo>
<mo>‚àÄ</mo>
<mi>C</mi>
<mo>,</mo>
<mo>‚àÄ</mo>
<mi>D</mi>
<mo>,</mo>
<mi>P</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>C</mi>
<mo>,</mo>
<mi>D</mi>
<mo stretchy="false">)</mo>
</mrow>
<mo>‚Üí</mo>
<mrow>
<mo stretchy="false">(</mo>
<mi>C</mi>
<mo>‚àà</mo>
<mi>A</mi>
<mo>‚Üí</mo>
<mi>D</mi>
<mo>‚àà</mo>
<mi>B</mi>
<mo stretchy="false">)</mo>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<csymbol cd="latexml">for-all</csymbol>
<csymbol cd="unknown">A</csymbol>
<ci>normal-,</ci>
<exists></exists>
<csymbol cd="unknown">B</csymbol>
<ci>normal-,</ci>
<csymbol cd="latexml">for-all</csymbol>
<csymbol cd="unknown">C</csymbol>
<ci>normal-,</ci>
<csymbol cd="latexml">for-all</csymbol>
<csymbol cd="unknown">D</csymbol>
<ci>normal-,</ci>
<csymbol cd="unknown">P</csymbol>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<csymbol cd="unknown">C</csymbol>
<ci>normal-,</ci>
<csymbol cd="unknown">D</csymbol>
<ci>normal-)</ci>
</cerror>
<ci>normal-‚Üí</ci>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<csymbol cd="unknown">C</csymbol>
<in></in>
<csymbol cd="unknown">A</csymbol>
<ci>normal-‚Üí</ci>
<csymbol cd="unknown">D</csymbol>
<in></in>
<csymbol cd="unknown">B</csymbol>
<ci>normal-)</ci>
</cerror>
<ci>normal-.</ci>
</cerror>
</annotation-xml>
<annotation encoding="application/x-tex">
   \forall A,\exists B,\forall C,\forall D,P(C,D)\rightarrow(C\in A\rightarrow D%
\in B).
  </annotation>
</semantics>
</math>

 This is almost correct, but it applies to too many predicates; what we actually want is:</p>

<p>
<math display="block" id="Functional_predicate:5">
<semantics>
<mrow>
<mrow>
<mo stretchy="false">(</mo>
<mo>‚àÄ</mo>
<mi>X</mi>
<mo>,</mo>
<mo>‚àÉ</mo>
<mo lspace="0pt" rspace="3.5pt">!</mo>
<mi>Y</mi>
<mo>,</mo>
<mi>P</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>X</mi>
<mo>,</mo>
<mi>Y</mi>
<mo stretchy="false">)</mo>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mo>‚Üí</mo>
<mrow>
<mo stretchy="false">(</mo>
<mo>‚àÄ</mo>
<mi>A</mi>
<mo>,</mo>
<mo>‚àÉ</mo>
<mi>B</mi>
<mo>,</mo>
<mo>‚àÄ</mo>
<mi>C</mi>
<mo>,</mo>
<mo>‚àÄ</mo>
<mi>D</mi>
<mo>,</mo>
<mi>P</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>C</mi>
<mo>,</mo>
<mi>D</mi>
<mo stretchy="false">)</mo>
</mrow>
<mo>‚Üí</mo>
<mrow>
<mo stretchy="false">(</mo>
<mi>C</mi>
<mo>‚àà</mo>
<mi>A</mi>
<mo>‚Üí</mo>
<mi>D</mi>
<mo>‚àà</mo>
<mi>B</mi>
<mo stretchy="false">)</mo>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<csymbol cd="latexml">for-all</csymbol>
<csymbol cd="unknown">X</csymbol>
<ci>normal-,</ci>
<exists></exists>
<factorial></factorial>
<csymbol cd="unknown">Y</csymbol>
<ci>normal-,</ci>
<csymbol cd="unknown">P</csymbol>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<csymbol cd="unknown">X</csymbol>
<ci>normal-,</ci>
<csymbol cd="unknown">Y</csymbol>
<ci>normal-)</ci>
</cerror>
<ci>normal-)</ci>
</cerror>
<ci>normal-‚Üí</ci>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<csymbol cd="latexml">for-all</csymbol>
<csymbol cd="unknown">A</csymbol>
<ci>normal-,</ci>
<exists></exists>
<csymbol cd="unknown">B</csymbol>
<ci>normal-,</ci>
<csymbol cd="latexml">for-all</csymbol>
<csymbol cd="unknown">C</csymbol>
<ci>normal-,</ci>
<csymbol cd="latexml">for-all</csymbol>
<csymbol cd="unknown">D</csymbol>
<ci>normal-,</ci>
<csymbol cd="unknown">P</csymbol>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<csymbol cd="unknown">C</csymbol>
<ci>normal-,</ci>
<csymbol cd="unknown">D</csymbol>
<ci>normal-)</ci>
</cerror>
<ci>normal-‚Üí</ci>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<csymbol cd="unknown">C</csymbol>
<in></in>
<csymbol cd="unknown">A</csymbol>
<ci>normal-‚Üí</ci>
<csymbol cd="unknown">D</csymbol>
<in></in>
<csymbol cd="unknown">B</csymbol>
<ci>normal-)</ci>
</cerror>
<ci>normal-)</ci>
</cerror>
<ci>normal-.</ci>
</cerror>
</annotation-xml>
<annotation encoding="application/x-tex">
   (\forall X,\exists!Y,P(X,Y))\rightarrow(\forall A,\exists B,\forall C,\forall D%
,P(C,D)\rightarrow(C\in A\rightarrow D\in B)).
  </annotation>
</semantics>
</math>

 This version of the axiom schema of replacement is now suitable for use in a formal language that doesn't allow the introduction of new function symbols. Alternatively, one may interpret the original statement as a statement in such a formal language; it was merely an abbreviation for the statement produced at the end.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Logical_connective" title="wikilink">Logical connective</a></li>
<li><a href="Logical_constant" title="wikilink">Logical constant</a></li>
</ul>

<p>"</p>

<p><a href="Category:Model_theory" title="wikilink">Category:Model theory</a></p>
</body>
</html>
