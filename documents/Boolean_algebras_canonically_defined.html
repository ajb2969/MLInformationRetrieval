<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="920">Boolean algebras canonically defined</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Boolean algebras canonically defined</h1>
<hr/>
<dl>
<dd><em>Boolean algebras have been formally defined variously as a kind of lattice and as a kind of ring. This article presents them, equally formally, as simply the models of the equational theory of two values, and observes the equivalence of both the lattice and ring definitions to this more elementary one.</em>
</dd>
</dl>

<p><a href="Boolean_algebra" title="wikilink">Boolean algebra</a> is a mathematically rich branch of <a href="abstract_algebra" title="wikilink">abstract algebra</a>. Just as <a href="group_theory" title="wikilink">group theory</a> deals with <a href="Group_(mathematics)" title="wikilink">groups</a>, and <a href="linear_algebra" title="wikilink">linear algebra</a> with <a href="vector_spaces" title="wikilink">vector spaces</a>, <a href="Boolean_algebras" title="wikilink">Boolean algebras</a> are models of the <a href="equational_theory" title="wikilink">equational theory</a> of the two values 0 and 1 (whose interpretation need not be numerical). Common to Boolean algebras, groups, and vector spaces is the notion of an <a href="algebraic_structure" title="wikilink">algebraic structure</a>, a <a href="Set_(mathematics)" title="wikilink">set</a> closed under zero or more <a href="operation_(mathematics)" title="wikilink">operations</a> satisfying certain equations.</p>

<p>Just as there are basic examples of groups, such as the group <strong>Z</strong> of <a href="integer" title="wikilink">integers</a> and the <a href="permutation_group" title="wikilink">permutation group</a> <em>S</em><sub><em>n</em></sub> of <a href="permutation" title="wikilink">permutations</a> of <em>n</em> objects, there are also basic examples of Boolean algebra such as the following.</p>
<ul>
<li>The algebra of <a href="binary_digit" title="wikilink">binary digits</a> or bits 0 and 1 under the logical operations including disjunction, conjunction, and negation. Applications include the <a href="propositional_calculus" title="wikilink">propositional calculus</a> and the theory of <a href="digital_circuits" title="wikilink">digital circuits</a>.</li>
<li>The <a href="algebra_of_sets" title="wikilink">algebra of sets</a> under the set operations including <a href="Union_(set_theory)" title="wikilink">union</a>, <a href="intersection_(set_theory)" title="wikilink">intersection</a>, and <a href="Complement_(set_theory)" title="wikilink">complement</a>. Applications include any area of mathematics for which sets form a natural <a href="foundation_of_mathematics" title="wikilink">foundation</a>.</li>
</ul>

<p>Boolean algebra thus permits applying the methods of <a href="abstract_algebra" title="wikilink">abstract algebra</a> to <a href="mathematical_logic" title="wikilink">mathematical logic</a>, <a href="digital_logic" title="wikilink">digital logic</a>, and the set-theoretic <a href="foundations_of_mathematics" title="wikilink">foundations of mathematics</a>.</p>

<p>Unlike <a href="Group_(mathematics)" title="wikilink">groups</a> of finite <a href="order_(group_theory)" title="wikilink">order</a>, which exhibit complexity and diversity and whose <a href="first-order_logic" title="wikilink">first-order</a> theory is <a href="Decidability_(logic)" title="wikilink">decidable</a> only in special cases, all finite Boolean algebras share the same theorems and have a decidable first-order theory. Instead the intricacies of Boolean algebra are divided between the structure of infinite algebras and the <a href="algorithm" title="wikilink">algorithmic</a> complexity of their <a href="syntax" title="wikilink">syntactic</a> structure.</p>
<h2 id="definition">Definition</h2>

<p>Boolean algebra treats the <a href="equational_theory" title="wikilink">equational theory</a> of the maximal two-element <a class="uri" href="finitary" title="wikilink">finitary</a> algebra, called the <strong>Boolean prototype</strong>, and the models of that theory, called <strong>Boolean algebras</strong>. These terms are defined as follows.</p>

<p>An <a href="Universal_algebra" title="wikilink">algebra</a> is a <a href="Indexed_family" title="wikilink">family</a> of operations on a set, called the underlying set of the algebra. We take the underlying set of the Boolean prototype to be {0,1}.</p>

<p>An algebra is <strong><a class="uri" href="finitary" title="wikilink">finitary</a></strong> when each of its operations takes only finitely many arguments. For the prototype each argument of an operation is either 0 or 1, as is the result of the operation. The maximal such algebra consists of all finitary operations on {0,1}.</p>

<p>The number of arguments taken by each operation is called the <a class="uri" href="arity" title="wikilink">arity</a> of the operation. An operation on {0,1} of arity <em>n</em>, or <em>n</em>-ary operation, can be applied to any of 2<sup><em>n</em></sup> possible values for its <em>n</em> arguments. For each choice of arguments the operation may return 0 or 1, whence there are 2<sup><span>2<sup><em>n</em></sup></span></sup> <em>n</em>-ary operations.</p>

<p>The prototype therefore has two operations taking no arguments, called zeroary or <strong>nullary</strong> operations, namely zero and one. It has four <a href="unary_operation" title="wikilink">unary operations</a>, two of which are constant operations, another is the identity, and the most commonly used one, called <em>negation</em>, returns the opposite of its argument: 1 if 0, 0 if 1. It has sixteen <a href="binary_operation" title="wikilink">binary operations</a>; again two of these are constant, another returns its first argument, yet another returns its second, one is called <em>conjunction</em> and returns 1 if both arguments are 1 and otherwise 0, another is called <em>disjunction</em> and returns 0 if both arguments are 0 and otherwise 1, and so on. The number of (<em>n</em>+1)-ary operations in the prototype is the square of the number of <em>n</em>-ary operations, so there are 16<sup>2</sup> = 256 ternary operations, 256<sup>2</sup> = 65,536 quaternary operations, and so on.</p>

<p>A <a href="Indexed_family" title="wikilink">family</a> is indexed by an <a href="index_set" title="wikilink">index set</a>. In the case of a family of operations forming an algebra, the indices are called <strong>operation symbols</strong>, constituting the <strong>language</strong> of that algebra. The operation indexed by each symbol is called the denotation or <strong><a href="interpretation_(model_theory)" title="wikilink">interpretation</a></strong> of that symbol. Each operation symbol specifies the arity of its interpretation, whence all possible interpretations of a symbol have the same arity. In general it is possible for an algebra to interpret distinct symbols with the same operation, but this is not the case for the prototype, whose symbols are in one-one correspondence with its operations. The prototype therefore has 2<sup><span>2<sup><em>n</em></sup></span></sup> <em>n</em>-ary operation symbols, called the <strong>Boolean operation symbols</strong> and forming the language of Boolean algebra. Only a few operations have conventional symbols, such as ¬ for negation, ∧ for conjunction, and ∨ for disjunction. It is convenient to consider the <em>i</em>-th <em>n</em>-ary symbol to be <sup><em>n</em></sup><em>f</em><sub><em>i</em></sub> as done below in the section on <a href="Boolean_algebras_canonically_defined#Truth_tables" title="wikilink">truth tables</a>.</p>

<p>An <a href="equational_theory" title="wikilink">equational theory</a> in a given language consists of equations between terms built up from variables using symbols of that language. Typical equations in the language of Boolean algebra are <em>x</em>∧<em>y</em> = <em>y</em>∧<em>x</em>, <em>x</em>∧<em>x</em> = <em>x</em>, <em>x</em>∧¬<em>x</em> = <em>y</em>∧¬<em>y</em>, and <em>x</em>∧<em>y</em> = <em>x</em>.</p>

<p>An algebra <strong><a href="satisfiability" title="wikilink">satisfies</a></strong> an equation when the equation holds for all possible values of its variables in that algebra when the operation symbols are interpreted as specified by that algebra. The laws of Boolean algebra are the equations in the language of Boolean algebra satisfied by the prototype. The first three of the above examples are Boolean laws, but not the fourth since 1∧0 ≠ 1.</p>

<p>The <a href="equational_theory" title="wikilink">equational theory</a> of an algebra is the set of all equations satisfied by the algebra. The laws of Boolean algebra therefore constitute the equational theory of the Boolean prototype.</p>

<p>A <a href="model_(model_theory)" title="wikilink">model of a theory</a> is an algebra interpreting the operation symbols in the language of the theory and satisfying the equations of the theory.</p>
<dl>
<dd><em>A Boolean algebra is any model of the laws of Boolean algebra.</em>
</dd>
</dl>

<p>That is, a Boolean algebra is a set and a family of operations thereon interpreting the Boolean operation symbols and satisfying the same laws as the Boolean prototype.</p>

<p>If we define a homologue of an algebra to be a model of the equational theory of that algebra, then a Boolean algebra can be defined as any homologue of the prototype.</p>

<p><strong>Example 1</strong>. The Boolean prototype is a Boolean algebra, since trivially it satisfies its own laws. It is thus the prototypical Boolean algebra. We did not call it that initially in order to avoid any appearance of circularity in the definition.</p>
<h2 id="basis">Basis</h2>

<p>The operations need not be all explicitly stated. A <em>basis</em> is any set from which the remaining operations can be obtained by composition. A "Boolean algebra" may be defined from any of several different bases. Three bases for Boolean algebra are in common use, the lattice basis, the ring basis, and the <a href="Sheffer_stroke" title="wikilink">Sheffer stroke</a> or NAND basis. These bases impart respectively a logical, an arithmetical, and a parsimonious character to the subject.</p>
<ul>
<li>The <a href="lattice_(order)" title="wikilink">lattice</a> basis originated in the 19th century with the work of <a href="George_Boole" title="wikilink">Boole</a>, <a href="Charles_Sanders_Peirce" title="wikilink">Peirce</a>, and others seeking an algebraic formalization of logical thought processes.</li>
<li>The <a href="Boolean_ring" title="wikilink">ring</a> basis emerged in the 20th century with the work of <a href="Ivan_Ivanovich_Zhegalkin" title="wikilink">Zhegalkin</a> and <a href="Marshall_Stone" title="wikilink">Stone</a> and became the basis of choice for algebraists coming to the subject from a background in <a href="abstract_algebra" title="wikilink">abstract algebra</a>. Most treatments of Boolean algebra assume the lattice basis, a notable exception being <a href="Paul_Halmos" title="wikilink">Halmos</a>[1963] whose linear algebra background evidently endeared the ring basis to him.</li>
<li>Since all finitary operations on {0,1} can be defined in terms of the <a href="Sheffer_stroke" title="wikilink">Sheffer stroke</a> NAND (or its dual NOR), the resulting economical basis has become the basis of choice for analyzing <a href="digital_circuit" title="wikilink">digital circuits</a>, in particular <a href="gate_array" title="wikilink">gate arrays</a> in <a href="digital_electronics" title="wikilink">digital electronics</a>.</li>
</ul>

<p>The common elements of the lattice and ring bases are the constants 0 and 1, and an <a class="uri" href="associative" title="wikilink">associative</a> <a class="uri" href="commutative" title="wikilink">commutative</a> <a href="binary_operation" title="wikilink">binary operation</a>, called <a href="meet_(mathematics)" title="wikilink">meet</a> <em>x</em>∧<em>y</em> in the lattice basis, and <a class="uri" href="multiplication" title="wikilink">multiplication</a> <em>xy</em> in the ring basis. The distinction is only terminological. The lattice basis has the further operations of <a href="join_(mathematics)" title="wikilink">join</a>, <em>x</em>∨<em>y</em>, and <a href="Complement_(order_theory)" title="wikilink">complement</a>, ¬<em>x</em>. The ring basis has instead the arithmetic operation <em>x</em>⊕<em>y</em> of <a class="uri" href="addition" title="wikilink">addition</a> (the symbol ⊕ is used in preference to + because the latter is sometimes given the Boolean reading of join).</p>

<p>To be a basis is to yield all other operations by composition, whence any two bases must be intertranslatable. The lattice basis translates <em>x</em>∨<em>y</em> to the ring basis as <em>x</em>⊕<em>y</em>⊕<em>xy</em>, and ¬<em>x</em> as <em>x</em>⊕1. Conversely the ring basis translates <em>x</em>⊕<em>y</em> to the lattice basis as (<em>x</em>∨<em>y</em>)∧¬(<em>x</em>∧<em>y</em>).</p>

<p>Both of these bases allow Boolean algebras to be defined via a subset of the equational properties of the Boolean operations. For the lattice basis, it suffices to define a Boolean algebra as a <a href="distributive_lattice" title="wikilink">distributive lattice</a> satisfying <em>x</em>∧¬<em>x</em> = 0 and <em>x</em>∨¬<em>x</em> = 1, called a <a href="Complemented_lattice" title="wikilink">complemented</a> distributive lattice. The ring basis turns a Boolean algebra into a <a href="Boolean_ring" title="wikilink">Boolean ring</a>, namely a ring satisfying <em>x</em><sup>2</sup> = <em>x</em>.</p>

<p><a href="Emil_Post" title="wikilink">Emil Post</a> gave a necessary and sufficient condition for a set of operations to be a basis for the nonzeroary Boolean operations. A <em>nontrivial</em> property is one shared by some but not all operations making up a basis. Post listed five nontrivial properties of operations, identifiable with the five <a href="Post's_class" title="wikilink">Post's classes</a>, each preserved by composition, and showed that a set of operations formed a basis if, for each property, the set contained an operation lacking that property. (The converse of Post's theorem, extending "if" to "<a href="iff" title="wikilink">if and only if</a>," is the easy observation that a property from among these five holding of every operation in a candidate basis will also hold of every operation formed by composition from that candidate, whence by nontriviality of that property the candidate will fail to be a basis.) Post's five properties are:</p>
<ul>
<li><a href="Monotonic_function" title="wikilink">monotone</a>, no 0-1 input transition can cause a 1-0 output transition;</li>
<li><a href="affine_transformation" title="wikilink">affine</a>, representable with <a href="Zhegalkin_polynomial" title="wikilink">Zhegalkin polynomials</a> that lack <a class="uri" href="bilinear" title="wikilink">bilinear</a> or higher terms, e.g. <em>x</em>⊕<em>y</em>⊕1 but not <em>xy</em>;</li>
<li><a href="De_Morgan's_laws" title="wikilink">self-dual</a>, so that complementing all inputs complements the output, as with <em>x</em>, or the <a href="median_operator" title="wikilink">median operator</a> <em>xy</em>⊕<em>yz</em>⊕<em>zx</em>, or their negations;</li>
<li><a href="strict_function" title="wikilink">strict</a> (mapping the all-zeros input to zero);</li>
<li>costrict (mapping all-ones to one).</li>
</ul>

<p>The <a href="Sheffer_stroke" title="wikilink">NAND</a> (dually NOR) operation lacks all these, thus forming a basis by itself.</p>
<h2 id="truth-tables">Truth tables</h2>

<p>The finitary operations on {0,1} may be exhibited as <a href="truth_table" title="wikilink">truth tables</a>, thinking of 0 and 1 as the <a href="truth_value" title="wikilink">truth values</a> <strong>false</strong> and <strong>true</strong>. They can be laid out in a uniform and application-independent way that allows us to name, or at least number, them individually. These names provide a convenient shorthand for the Boolean operations. The names of the <em>n</em>-ary operations are binary numbers of 2<sup><em>n</em></sup> bits. There being 2<sup>2<span><sup><em>n</em></sup></span></sup> such operations, one cannot ask for a more succinct nomenclature! Note that each finitary operation can be called a <a href="switching_function" title="wikilink">switching function</a>.</p>

<p>This layout and associated naming of operations is illustrated here in full for arities from 0 to 2.</p>
<div>
<center>

<p>::{| border="0" style="border:4px" |+ <strong>Truth tables for the Boolean operations of arity up to 2</strong> |- valign="top" |</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>Constants</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>

<math display="inline" id="Boolean_algebras_canonically_defined:0">
 <semantics>
  <mmultiscripts>
   <mi>f</mi>
   <mn>0</mn>
   <none></none>
   <mprescripts></mprescripts>
   <none></none>
   <mn>0</mn>
  </mmultiscripts>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>f</ci>
     <cn type="integer">0</cn>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {}^{0}\!f_{0}
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>0</p></td>
</tr>
</tbody>
</table>

<p>|</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>Unary Operations</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>

<math display="inline" id="Boolean_algebras_canonically_defined:1">
 <semantics>
  <msub>
   <mi>x</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{0}
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>0</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>1</p></td>
</tr>
</tbody>
</table>

<p>|- |</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>Binary Operations</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>

<math display="inline" id="Boolean_algebras_canonically_defined:2">
 <semantics>
  <msub>
   <mi>x</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{0}
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>0</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>1</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>0</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>1</p></td>
</tr>
</tbody>
</table>

<p>|}</p>
</center>
</div>

<p>These tables continue at higher arities, with 2<sup><em>n</em></sup> rows at arity <em>n</em>, each row giving a valuation or binding of the <em>n</em> variables <em>x</em><sub>0</sub>,…<em>x</em><sub><em>n</em>−1</sub> and each column headed <sup><em>n</em></sup><em>f</em><sub><em>i</em></sub> giving the value <sup><em>n</em></sup><em>f</em><sub><em>i</em></sub>(<em>x</em><sub>0</sub>,…,<em>x</em><sub><em>n</em>−1</sub>) of the <em>i</em>-th <em>n</em>-ary operation at that valuation. The operations include the variables, for example <sup>1</sup><em>f</em><sub>2</sub> is <em>x</em><sub>0</sub> while <sup>2</sup><em>f</em><sub>10</sub> is <em>x</em><sub>0</sub> (as two copies of its unary counterpart) and <sup>2</sup><em>f</em><sub>12</sub> is <em>x</em><sub>1</sub> (with no unary counterpart). Negation or complement ¬<em>x</em><sub>0</sub> appears as <sup>1</sup><em>f</em><sub>1</sub> and again as <sup>2</sup><em>f</em><sub>5</sub>, along with <sup>2</sup><em>f</em><sub>3</sub> (¬<em>x</em><sub>1</sub>, which did not appear at arity 1), disjunction or union <em>x</em><sub>0</sub>∨<em>x</em><sub>1</sub> as <sup>2</sup><em>f</em><sub>14</sub>, conjunction or intersection <em>x</em><sub>0</sub>∧<em>x</em><sub>1</sub> as <sup>2</sup><em>f</em><sub>8</sub>, implication <em>x</em><sub>0</sub>→<em>x</em><sub>1</sub> as <sup>2</sup><em>f</em><sub>13</sub>, exclusive-or symmetric difference <em>x</em><sub>0</sub>⊕<em>x</em><sub>1</sub> as <sup>2</sup><em>f</em><sub>6</sub>, set difference <em>x</em><sub>0</sub>−<em>x</em><sub>1</sub> as <sup>2</sup><em>f</em><sub>2</sub>, and so on.</p>

<p>As a minor detail important more for its form than its content, the operations of an algebra are traditionally organized as a list. Although we are here indexing the operations of a Boolean algebra by the finitary operations on {0,1}, the truth-table presentation above serendipitously orders the operations first by arity and second by the layout of the tables for each arity. This permits organizing the set of all Boolean operations in the traditional list format. The list order for the operations of a given arity is determined by the following two rules.</p>
<dl>
<dd>(i) The <em>i</em>-th row in the left half of the table is the binary representation of <em>i</em> with its least significant or 0-th bit on the left ("little-endian" order, originally proposed by <a href="Alan_Turing" title="wikilink">Alan Turing</a>, so it would not be unreasonable to call it Turing order).
</dd>
</dl>
<dl>
<dd>(ii) The <em>j</em>-th column in the right half of the table is the binary representation of <em>j</em>, again in little-endian order. In effect the subscript of the operation <em>is</em> the truth table of that operation. By analogy with <a href="Gödel_number" title="wikilink">Gödel numbering</a> of computable functions one might call this numbering of the Boolean operations the Boole numbering.
</dd>
</dl>

<p>When programming in C or Java, bitwise disjunction is denoted <code>''x''|''y''</code>, conjunction <code>''x''&amp;''y''</code>, and negation <code>~''x''</code>. A program can therefore represent for example the operation <em>x</em>∧(<em>y</em>∨<em>z</em>) in these languages as <code>''x''&amp;(''y''|''z'')</code>, having previously set <code>''x'' = 0xaa</code>, <code>''y'' = 0xcc</code>, and <code>''z'' = 0xf0</code> (the "<code>0x</code>" indicates that the following constant is to be read in hexadecimal or base 16), either by assignment to variables or defined as macros. These one-byte (eight-bit) constants correspond to the columns for the input variables in the extension of the above tables to three variables. This technique is almost universally used in raster graphics hardware to provide a flexible variety of ways of combining and masking images, the typical operations being ternary and acting simultaneously on source, destination, and mask bits.</p>
<h2 id="examples">Examples</h2>
<h3 id="bit-vectors">Bit vectors</h3>

<p><strong>Example 2</strong>. All <a href="bit_vector" title="wikilink">bit vectors</a> of a given length form a Boolean algebra "pointwise", meaning that any <em>n</em>-ary Boolean operation can be applied to <em>n</em> bit vectors one bit position at a time. For example the ternary OR of three bit vectors each of length 4 is the bit vector of length 4 formed by oring the three bits in each of the four bit positions, thus 0100∨1000∨1001 = 1101. Another example is the truth tables above for the <em>n</em>-ary operations, whose columns are all the bit vectors of length 2<sup><em>n</em></sup> and which therefore can be combined pointwise whence the <em>n</em>-ary operations form a Boolean algebra. This works equally well for bit vectors of finite and infinite length, the only rule being that the bit positions all be indexed by the same set in order that "corresponding position" be well defined.</p>

<p>The <strong><a href="atom_(order_theory)" title="wikilink">atoms</a></strong> of such an algebra are the bit vectors containing exactly one 1. In general the atoms of a Boolean algebra are those elements <em>x</em> such that <em>x</em>∧<em>y</em> has only two possible values, <em>x</em> or 0.</p>
<h3 id="power-set-algebra">Power set algebra</h3>

<p><strong>Example 3</strong>. The <strong>power set algebra</strong>, the set 2<sup><em>W</em></sup> of all subsets of a given set <em>W</em>. This is just Example 2 in disguise, with <em>W</em> serving to index the bit positions. Any subset <em>X</em> of <em>W</em> can be viewed as the bit vector having 1's in just those bit positions indexed by elements of <em>X</em>. Thus the all-zero vector is the empty subset of <em>W</em> while the all-ones vector is <em>W</em> itself, these being the constants 0 and 1 respectively of the power set algebra. The counterpart of disjunction <em>x</em>∨<em>y</em> is union <em>X</em>∪<em>Y</em>, while that of conjunction <em>x</em>∧<em>y</em> is intersection <em>X</em>∩<em>Y</em>. Negation ¬<em>x</em> becomes ~<em>X</em>, complement relative to <em>W</em>. There is also set difference <em>X</em>∖<em>Y</em> = <em>X</em>∩~<em>Y</em>, symmetric difference (<em>X</em>∖<em>Y</em>)∪(<em>Y</em>∖<em>X</em>), ternary union <em>X</em>∪<em>Y</em>∪<em>Z</em>, and so on. The atoms here are the singletons, those subsets with exactly one element.</p>

<p>Examples 2 and 3 are special cases of a general construct of algebra called <a href="direct_product" title="wikilink">direct product</a>, applicable not just to Boolean algebras but all kinds of algebra including groups, rings, etc. The direct product of any family <em>B</em><sub>i</sub> of Boolean algebras where <em>i</em> ranges over some index set <em>I</em> (not necessarily finite or even countable) is a Boolean algebra consisting of all <em>I</em>-tuples (…<em>x</em><sub>i</sub>,…) whose <em>i</em>-th element is taken from <em>B</em><sub><em>i</em></sub>. The operations of a direct product are the corresponding operations of the constituent algebras acting within their respective coordinates; in particular operation <sup><em>n</em></sup><em>f</em><sub><em>j</em></sub> of the product operates on <em>n</em> <em>I</em>-tuples by applying operation <sup><em>n</em></sup><em>f</em><sub><em>j</em></sub> of <em>B</em><sub><em>i</em></sub> to the <em>n</em> elements in the <em>i</em>-th coordinate of the <em>n</em> tuples, for all <em>i</em> in <em>I</em>.</p>

<p>When all the algebras being multiplied together in this way are the same algebra <em>A</em> we call the direct product a <em>direct power</em> of <em>A</em>. The Boolean algebra of all 32-bit bit vectors is the two-element Boolean algebra raised to the 32nd power, or power set algebra of a 32-element set, denoted 2<sup>32</sup>. The Boolean algebra of all sets of integers is 2<sup><strong>Z</strong></sup>. All Boolean algebras we have exhibited thus far have been direct powers of the two-element Boolean algebra, justifying the name "power set algebra".</p>
<h3 id="representation-theorems">Representation theorems</h3>

<p>It can be shown that every finite Boolean algebra is <a class="uri" href="isomorphic" title="wikilink">isomorphic</a> to some power set algebra. Hence the cardinality (number of elements) of a finite Boolean algebra is a power of 2, namely one of 1,2,4,8,…,2<sup><em>n</em></sup>,… This is called a <strong>representation theorem</strong> as it gives insight into the nature of finite Boolean algebras by giving a <a href="representation_(mathematics)" title="wikilink">representation</a> of them as power set algebras.</p>

<p>This representation theorem does not extend to infinite Boolean algebras: although every power set algebra is a Boolean algebra, not every Boolean algebra need be isomorphic to a power set algebra. In particular, whereas there can be no <a href="countably_infinite" title="wikilink">countably infinite</a> power set algebras (the smallest infinite power set algebra is the power set algebra 2<sup><em>N</em></sup> of sets of natural numbers, <a href="Cantor's_diagonal_argument" title="wikilink">shown</a> by <a href="Georg_Cantor" title="wikilink">Cantor</a> to be <a class="uri" href="uncountable" title="wikilink">uncountable</a>), there exist various countably infinite Boolean algebras.</p>

<p>To go beyond power set algebras we need another construct. A <a class="uri" href="subalgebra" title="wikilink">subalgebra</a> of an algebra <em>A</em> is any subset of <em>A</em> closed under the operations of <em>A</em>. Every subalgebra of a Boolean algebra <em>A</em> must still satisfy the equations holding of <em>A</em>, since any violation would constitute a violation for <em>A</em> itself. Hence every subalgebra of a Boolean algebra is a Boolean algebra.</p>

<p>A <a class="uri" href="subalgebra" title="wikilink">subalgebra</a> of a power set algebra is called a <a href="field_of_sets" title="wikilink">field of sets</a>; equivalently a field of sets is a set of subsets of some set <em>W</em> including the empty set and <em>W</em> and closed under finite union and complement with respect to <em>W</em> (and hence also under finite intersection). Birkhoff's [1935] representation theorem for Boolean algebras states that every Boolean algebra is isomorphic to a field of sets. Now <a href="Birkhoff's_HSP_theorem" title="wikilink">Birkhoff's HSP theorem</a> for varieties can be stated as, every class of models of the equational theory of a class <em>C</em> of algebras is the Homomorphic image of a <a class="uri" href="Subalgebra" title="wikilink">Subalgebra</a> of a <a href="direct_product" title="wikilink">direct Product</a> of algebras of <em>C</em>. Normally all three of H, S, and P are needed; what the first of these two Birkhoff theorems shows is that for the special case of the variety of Boolean algebras <a class="uri" href="Homomorphism" title="wikilink">Homomorphism</a> can be replaced by <a class="uri" href="Isomorphism" title="wikilink">Isomorphism</a>. Birkhoff's HSP theorem for varieties in general therefore becomes Birkhoff's ISP theorem for the <a href="variety_(universal_algebra)" title="wikilink">variety</a> of Boolean algebras.</p>
<h3 id="other-examples">Other examples</h3>

<p>It is convenient when talking about a set <em>X</em> of natural numbers to view it as a sequence <em>x</em><sub>0</sub>,<em>x</em><sub>1</sub>,<em>x</em><sub>2</sub>,… of bits, with <em>x</em><sub><em>i</em></sub> = 1 if and only if <em>i</em> ∈ <em>X</em>. This viewpoint will make it easier to talk about <a href="subalgebra" title="wikilink">subalgebras</a> of the power set algebra 2<sup><em>N</em></sup>, which this viewpoint makes the Boolean algebra of all sequences of bits. It also fits well with the columns of a truth table: when a column is read from top to bottom it constitutes a sequence of bits, but at the same time it can be viewed as the set of those valuations (assignments to variables in the left half of the table) at which the function represented by that column evaluates to 1.</p>

<p><strong>Example 4</strong>. <em>Ultimately constant sequences</em>. Any Boolean combination of ultimately constant sequences is ultimately constant; hence these form a Boolean algebra. We can identify these with the integers by viewing the ultimately-zero sequences as nonnegative binary numerals (bit 0 of the sequence being the low-order bit) and the ultimately-one sequences as negative binary numerals (think <a href="two's_complement" title="wikilink">two's complement</a> arithmetic with the all-ones sequence being −1). This makes the integers a Boolean algebra, with union being bit-wise OR and complement being <em>−x−1</em>. There are only countably many integers, so this infinite Boolean algebra is countable. The atoms are the powers of two, namely 1,2,4,…. Another way of describing this algebra is as the set of all finite and cofinite sets of natural numbers, with the ultimately all-ones sequences corresponding to the cofinite sets, those sets omitting only finitely many natural numbers.</p>

<p><strong>Example 5</strong>. <em>Periodic sequence</em>. A sequence is called <em>periodic</em> when there exists some number <em>n</em> &gt; 0, called a witness to periodicity, such that <em>x</em><sub><em>i</em></sub> = <em>x</em><sub><em>i</em>+<em>n</em></sub> for all <em>i</em> ≥ 0. The period of a periodic sequence is its least witness. Negation leaves period unchanged, while the disjunction of two periodic sequences is periodic, with period at most the least common multiple of the periods of the two arguments (the period can be as small as 1, as happens with the union of any sequence and its complement). Hence the periodic sequences form a Boolean algebra.</p>

<p>Example 5 resembles Example 4 in being countable, but differs in being atomless. The latter is because the conjunction of any nonzero periodic sequence <em>x</em> with a sequence of greater period is neither 0 nor <em>x</em>. It can be shown that all countably infinite atomless Boolean algebras are isomorphic, that is, up to isomorphism there is only one such algebra.</p>

<p><strong>Example 6</strong>. <em>Periodic sequence with period a power of two</em>. This is a proper <a class="uri" href="subalgebra" title="wikilink">subalgebra</a> of Example 5 (a proper subalgebra equals the intersection of itself with its algebra). These can be understood as the finitary operations, with the first period of such a sequence giving the truth table of the operation it represents. For example the truth table of <em>x</em><sub>0</sub> in the table of binary operations, namely <sup>2</sup><em>f</em><sub>10</sub>, has period 2 (and so can be recognized as using only the first variable) even though 12 of the binary operations have period 4. When the period is 2<sup><em>n</em></sup> the operation only depends on the first <em>n</em> variables, the sense in which the operation is finitary. This example is also a countably infinite atomless Boolean algebra. Hence Example 5 is isomorphic to a proper subalgebra of itself! Example 6, and hence Example 5, constitutes the free Boolean algebra on countably many generators, meaning the Boolean algebra of all finitary operations on a countably infinite set of generators or variables.</p>

<p><strong>Example 7</strong>. <em>Ultimately periodic sequences</em>, sequences that become periodic after an initial finite bout of lawlessness. They constitute a proper extension of Example 5 (meaning that Example 5 is a proper <a class="uri" href="subalgebra" title="wikilink">subalgebra</a> of Example 7) and also of Example 4, since constant sequences are periodic with period one. Sequences may vary as to when they settle down, but any finite set of sequences will all eventually settle down no later than their slowest-to-settle member, whence ultimately periodic sequences are closed under all Boolean operations and so form a Boolean algebra. This example has the same atoms and coatoms as Example 4, whence it is not atomless and therefore not isomorphic to Example 5/6. However it contains an infinite atomless <a class="uri" href="subalgebra" title="wikilink">subalgebra</a>, namely Example 5, and so is not isomorphic to Example 4, every <a class="uri" href="subalgebra" title="wikilink">subalgebra</a> of which must be a Boolean algebra of finite sets and their complements and therefore atomic. This example is isomorphic to the direct product of Examples 4 and 5, furnishing another description of it.</p>

<p><strong>Example 8</strong>. The <a href="direct_product" title="wikilink">direct product</a> of a Periodic Sequence (Example 5) with any finite but nontrivial Boolean algebra. (The trivial one-element Boolean algebra is the unique finite atomless Boolean algebra.) This resembles Example 7 in having both atoms and an atomless <a class="uri" href="subalgebra" title="wikilink">subalgebra</a>, but differs in having only finitely many atoms. Example 8 is in fact an infinite family of examples, one for each possible finite number of atoms.</p>

<p>These examples by no means exhaust the possible Boolean algebras, even the countable ones. Indeed there are uncountably many nonisomorphic countable Boolean algebras, which Jussi Ketonen [1978] classified completely in terms of invariants representable by certain hereditarily countable sets.</p>
<h2 id="boolean-algebras-of-boolean-operations">Boolean algebras of Boolean operations</h2>

<p>The <em>n</em>-ary Boolean operations themselves constitute a power set algebra 2<sup><em>W</em></sup>, namely when <em>W</em> is taken to be the set of 2<sup><em>n</em></sup> valuations of the <em>n</em> inputs. In terms of the naming system of operations <sup><em>n</em></sup><em>f</em><sub><em>i</em></sub> where <em>i</em> in binary is a column of a truth table, the columns can be combined with Boolean operations of any arity to produce other columns present in the table. That is, we can apply any Boolean operation of arity <em>m</em> to <em>m</em> Boolean operations of arity <em>n</em> to yield a Boolean operation of arity <em>n</em>, for any <em>m</em> and <em>n</em>.</p>

<p>The practical significance of this convention for both software and hardware is that <em>n</em>-ary Boolean operations can be represented as words of the appropriate length. For example each of the 256 ternary Boolean operations can be represented as an unsigned byte. The available logical operations such as AND and OR can then be used to form new operations. If we take <em>x</em>, <em>y</em>, and <em>z</em> (dispensing with subscripted variables for now) to be 10101010, 11001100, and 11110000 respectively (170, 204, and 240 in decimal, 0xaa, 0xcc, and 0xf0 in hexadecimal), their pairwise conjunctions are <em>x</em>∧<em>y</em> = 10001000, <em>y</em>∧<em>z</em> = 11000000, and <em>z</em>∧<em>x</em> = 10100000, while their pairwise disjunctions are <em>x</em>∨<em>y</em> = 11101110, <em>y</em>∨<em>z</em> = 11111100, and <em>z</em>∨<em>x</em> = 11111010. The disjunction of the three conjunctions is 11101000, which also happens to be the conjunction of three disjunctions. We have thus calculated, with a dozen or so logical operations on bytes, that the two ternary operations</p>
<dl>
<dd>(<em>x</em>∧<em>y</em>)∨(<em>y</em>∧<em>z</em>)∨(<em>z</em>∧<em>x</em>)
</dd>
</dl>

<p>and</p>
<dl>
<dd>(<em>x</em>∨<em>y</em>)∧(<em>y</em>∨<em>z</em>)∧(<em>z</em>∨<em>x</em>)
</dd>
</dl>

<p>are actually the same operation. That is, we have proved the equational identity</p>
<dl>
<dd>(<em>x</em>∧<em>y</em>)∨(<em>y</em>∧<em>z</em>)∨(<em>z</em>∧<em>x</em>) = (<em>x</em>∨<em>y</em>)∧(<em>y</em>∨<em>z</em>)∧(<em>z</em>∨<em>x</em>),
</dd>
</dl>

<p>for the two-element Boolean algebra. By the definition of "Boolean algebra" this identity must therefore hold in every Boolean algebra.</p>

<p>This ternary operation incidentally formed the basis for Grau's [1947] ternary Boolean algebras, which he axiomatized in terms of this operation and negation. The operation is symmetric, meaning that its value is independent of any of the 3! = 6 permutations of its arguments. The two halves of its truth table 11101000 are the truth tables for ∨, 1110, and ∧, 1000, so the operation can be phrased as <strong>if</strong> <em>z</em> <strong>then</strong> <em>x</em>∨<em>y</em> <strong>else</strong> <em>x</em>∧<em>y</em>. Since it is symmetric it can equally well be phrased as either of <strong>if</strong> <em>x</em> <strong>then</strong> <em>y</em>∨<em>z</em> <strong>else</strong> <em>y</em>∧<em>z</em>, or <strong>if</strong> <em>y</em> <strong>then</strong> <em>z</em>∨<em>x</em> <strong>else</strong> <em>z</em>∧<em>x</em>. Viewed as a labeling of the 8-vertex 3-cube, the upper half is labeled 1 and the lower half 0; for this reason it has been called the <a href="median_operator" title="wikilink">median operator</a>, with the evident generalization to any odd number of variables (odd in order to avoid the tie when exactly half the variables are 0).</p>
<h2 id="axiomatizing-boolean-algebras">Axiomatizing Boolean algebras</h2>

<p>The technique we just used to prove an identity of Boolean algebra can be generalized to all identities in a systematic way that can be taken as a sound and complete <a class="uri" href="axiomatization" title="wikilink">axiomatization</a> of, or <a href="axiomatic_system" title="wikilink">axiomatic system</a> for, the equational laws of <a href="Boolean_logic" title="wikilink">Boolean logic</a>. The customary formulation of an axiom system consists of a set of axioms that "prime the pump" with some initial identities, along with a set of inference rules for inferring the remaining identities from the axioms and previously proved identities. In principle it is desirable to have finitely many axioms; however as a practical matter it is not necessary since it is just as effective to have a finite <a href="axiom_schema" title="wikilink">axiom schema</a> having infinitely many instances each of which when used in a proof can readily be verified to be a legal instance, the approach we follow here.</p>

<p>Boolean identities are assertions of the form <em>s</em> = <em>t</em> where <em>s</em> and <em>t</em> are <em>n</em>-ary terms, by which we shall mean here terms whose variables are limited to <em>x</em><sub><em>0</em></sub> through <em>x</em><sub><em>n-1</em></sub>. An <em>n</em>-ary <strong>term</strong> is either an atom or an application. An application <sup><em>m</em></sup><em>f</em><sub><em>i</em></sub>(<em>t</em><sub>0</sub>,…,<em>t</em><sub><em>m</em>-1</sub>) is a pair consisting of an <em>m</em>-ary operation <sup><em>m</em></sup><em>f</em><sub><em>i</em></sub> and a list or <em>m</em>-tuple (<em>t</em><sub>0</sub>,…,<em>t</em><sub><em>m</em>-1</sub>) of <em>m</em> <em>n</em>-ary terms called <strong>operands</strong>.</p>

<p>Associated with every term is a natural number called its <strong>height</strong>. Atoms are of zero height, while applications are of height one plus the height of their highest operand.</p>

<p>Now what is an atom? Conventionally an atom is either a constant (0 or 1) or a variable <em>x</em><sub><em>i</em></sub> where 0 ≤ <em>i</em> <em>n</em><em>f</em><sub><em>i</em></sub>, which although treated here as atoms nevertheless mean the same as ordinary terms of the exact form <sup><em>n</em></sup><em>f</em><sub><em>i</em></sub>(<em>x</em><sub>0</sub>,…,<em>x</em><sub><em>n</em>-1</sub>) (exact in that the variables must listed in the order shown without repetition or omission). This is not a restriction because atoms of this form include all the ordinary atoms, namely the constants 0 and 1, which arise here as the <em>n</em>-ary operations <sup><em>n</em></sup><em>f</em><sub>0</sub> and <sup><em>n</em></sup><em>f</em><sub>−1</sub> for each <em>n</em> (abbreviating 2<sup>2<span><sup><em>n</em></sup></span></sup>−1 to −1), and the variables <em>x</em><sub>0</sub>,…,<em>x</em><sub><em>n</em>-1</sub> as can be seen from the truth tables where <em>x</em><sub>0</sub> appears as both the unary operation <sup>1</sup><em>f</em><sub>2</sub> and the binary operation <sup>2</sup><em>f</em><sub>10</sub> while <em>x</em><sub>1</sub> appears as <sup>2</sup><em>f</em><sub>12</sub>.</p>

<p>The following axiom schema and three inference rules axiomatize the Boolean algebra of <em>n</em>-ary terms.</p>
<dl>
<dd><strong>A1</strong>. <sup><em>m</em></sup><em>f</em><sub><em>i</em></sub>(<sup><em>n</em></sup><em>f</em><sub><em>j</em><span><sub>0</sub></span></sub>,…,<sup><em>n</em></sup><em>f</em><sub><em>j</em><span><sub><em>m</em>-1</sub></span></sub>) = <sup><em>n</em></sup><em>f</em><sub><em>i</em>o<em>ĵ</em></sub> where (<em>i</em><small>o</small><em>ĵ</em>)<sub><em>v</em></sub> = <em>i</em><sub><em>ĵ</em><span><sub><em>v</em></sub></span></sub>, with <em>ĵ</em> being <em>j</em> transpose, defined by (<em>ĵ</em><sub><em>v</em></sub>)<sub><em>u</em></sub> = (<em>j</em><sub><em>u</em></sub>)<sub><em>v</em></sub>.
</dd>
<dd><strong>R1</strong>. With no premises infer <em>t</em> = <em>t</em>.
</dd>
<dd><strong>R2</strong>. From <em>s</em> = <em>u</em> and <em>t</em> = <em>u</em> infer <em>s</em> = <em>t</em> where <em>s</em>, <em>t</em>, and <em>u</em> are <em>n</em>-ary terms.
</dd>
<dd><strong>R3</strong>. From <em>s</em><sub>0</sub> = <em>t</em><sub>0</sub>,…,<em>s</em><sub><em>m</em>-1</sub> = <em>t</em><sub><em>m</em>-1</sub> infer <sup><em>m</em></sup><em>f</em><sub><em>i</em></sub>(<em>s</em><sub>0</sub>,…,<em>s</em><sub><em>m</em>-1</sub>) = <sup><em>m</em></sup><em>f</em><sub><em>i</em></sub>(<em>t</em><sub>0</sub>,…,<em>t</em><sub><em>m</em>-1</sub>), where all terms <em>s</em><sub>i</sub>, <em>t</em><sub>i</sub> are <em>n</em>-ary.
</dd>
</dl>

<p>The meaning of the side condition on <strong>A1</strong> is that <em>i</em><small>o</small><em>ĵ</em> is that 2<sup><em>n</em></sup>-bit number whose <em>v</em>-th bit is the <em>ĵ</em><sub><em>v</em></sub>-th bit of <em>i</em>, where the ranges of each quantity are <em>u</em>: <em>m</em>, <em>v</em>: 2<sup><em>n</em></sup>, <em>j</em><sub><em>u</em></sub>: 2<sup>2<span><sup><em>n</em></sup></span></sup>, and <em>ĵ</em><sub><em>v</em></sub>: 2<sup><em>m</em></sup>. (So <em>j</em> is an <em>m</em>-tuple of 2<sup><em>n</em></sup>-bit numbers while <em>ĵ</em> as the transpose of <em>j</em> is a 2<sup><em>n</em></sup>-tuple of <em>m</em>-bit numbers. Both <em>j</em> and <em>ĵ</em> therefore contain <em>m</em>2<sup><em>n</em></sup> bits.)</p>

<p><strong>A1</strong> is an axiom schema rather than an axiom by virtue of containing <strong>metavariables</strong>, namely <em>m</em>, <em>i</em>, <em>n</em>, and <em>j<sub>0</sub></em> through <em>j<sub>m-1</sub></em>. The actual axioms of the axiomatization are obtained by setting the metavariables to specific values. For example if we take <em>m</em> = <em>n</em> = <em>i</em> = <em>j</em><sub>0</sub> = 1, we can compute the two bits of <em>i</em><small>o</small><em>ĵ</em> from <em>i</em><sub>1</sub> = 0 and <em>i</em><sub>0</sub> = 1, so <em>i</em><small>o</small><em>ĵ</em> = 2 (or 10 when written as a two-bit number). The resulting instance, namely <sup>1</sup><em>f</em><sub>1</sub>(<sup>1</sup><em>f</em><sub>1</sub>) = <sup>1</sup><em>f</em><sub>2</sub>, expresses the familiar axiom ¬¬<em>x</em> = <em>x</em> of double negation. Rule <strong>R3</strong> then allows us to infer ¬¬¬<em>x</em> = ¬<em>x</em> by taking <em>s<sub>0</sub></em> to be <sup>1</sup><em>f</em><sub>1</sub>(<sup>1</sup><em>f</em><sub>1</sub>) or ¬¬<em>x</em><sub>0</sub>, <em>t<sub>0</sub></em> to be <sup>1</sup><em>f</em><sub>2</sub> or <em>x</em><sub>0</sub>, and <sup><em>m</em></sup><em>f</em><sub><em>i</em></sub> to be <sup><em>1</em></sup><em>f</em><sub><em>1</em></sub> or ¬.</p>

<p>For each <em>m</em> and <em>n</em> there are only finitely many axioms instantiating <strong>A1</strong>, namely 2<sup>2<span><sup><em>m</em></sup></span></sup> × (2<sup>2<span><sup><em>n</em></sup></span></sup>)<sup><em>m</em></sup>. Each instance is specified by 2<sup><em>m</em></sup>+<em>m</em>2<sup><em>n</em></sup> bits.</p>

<p>We treat <strong>R1</strong> as an inference rule, even though it is like an axiom in having no premises, because it is a domain-independent rule along with <strong>R2</strong> and <strong>R3</strong> common to all equational axiomatizations, whether of groups, rings, or any other variety. The only entity specific to Boolean algebras is axiom schema <strong>A1</strong>. In this way when talking about different equational theories we can push the rules to one side as being independent of the particular theories, and confine attention to the axioms as the only part of the axiom system characterizing the particular equational theory at hand.</p>

<p>This axiomatization is complete, meaning that every Boolean law <em>s</em> = <em>t</em> is provable in this system. One first shows by induction on the height of <em>s</em> that every Boolean law for which <em>t</em> is atomic is provable, using <strong>R1</strong> for the base case (since distinct atoms are never equal) and <strong>A1</strong> and <strong>R3</strong> for the induction step (<em>s</em> an application). This proof strategy amounts to a recursive procedure for evaluating <em>s</em> to yield an atom. Then to prove <em>s</em> = <em>t</em> in the general case when <em>t</em> may be an application, use the fact that if <em>s</em> = <em>t</em> is an identity then <em>s</em> and <em>t</em> must evaluate to the same atom, call it <em>u</em>. So first prove <em>s</em> = <em>u</em> and <em>t</em> = <em>u</em> as above, that is, evaluate <em>s</em> and <em>t</em> using <strong>A1</strong>, <strong>R1</strong>, and <strong>R3</strong>, and then invoke <strong>R2</strong> to infer <em>s</em> = <em>t</em>.</p>

<p>In <strong>A1</strong>, if we view the number <em>n</em><sup><em>m</em></sup> as the function type <em>m</em>→<em>n</em>, and <em>m</em><sub><em>n</em></sub> as the application <em>m</em>(<em>n</em>), we can reinterpret the numbers <em>i</em>, <em>j</em>, <em>ĵ</em>, and <em>i</em><small>o</small><em>ĵ</em> as functions of type <em>i</em>: (<em>m</em>→2)→2, <em>j</em>: <em>m</em>→((<em>n</em>→2)→2), <em>ĵ</em>: (<em>n</em>→2)→(<em>m</em>→2), and <em>i</em><small>o</small><em>ĵ</em>: (<em>n</em>→2)→2. The definition (<em>i</em><small>o</small><em>ĵ</em>)<sub><em>v</em></sub> = <em>i</em><sub><em>ĵ</em><span><sub><em>v</em></sub></span></sub> in <strong>A1</strong> then translates to (<em>i</em><small>o</small><em>ĵ</em>)(<em>v</em>) = <em>i</em>(<em>ĵ</em>(<em>v</em>)), that is, <em>i</em><small>o</small><em>ĵ</em> is defined to be composition of <em>i</em> and <em>ĵ</em> understood as functions. So the content of <strong>A1</strong> amounts to defining term application to be essentially composition, modulo the need to transpose the <em>m</em>-tuple <em>j</em> to make the types match up suitably for composition. This composition is the one in Lawvere's previously mentioned category of power sets and their functions. In this way we have translated the commuting diagrams of that category, as the equational theory of Boolean algebras, into the equational consequences of <strong>A1</strong> as the logical representation of that particular composition law.</p>
<h2 id="underlying-lattice-structure">Underlying lattice structure</h2>

<p>Underlying every Boolean algebra <em>B</em> is a <a href="partially_ordered_set" title="wikilink">partially ordered set</a> or <strong>poset</strong> (<em>B</em>,≤). The <strong>partial order</strong> relation is defined by <em>x</em> ≤ <em>y</em> just when <em>x</em> = <em>x</em>∧<em>y</em>, or equivalently when <em>y</em> = <em>x</em>∨<em>y</em>. Given a set <em>X</em> of elements of a Boolean algebra, an <strong>upper bound</strong> on <em>X</em> is an element <em>y</em> such that for every element <em>x</em> of <em>X</em>, <em>x</em> ≤ <em>y</em>, while a lower bound on <em>X</em> is an element <em>y</em> such that for every element <em>x</em> of <em>X</em>, <em>y</em> ≤ <em>x</em>.</p>

<p>A <strong>sup</strong> (<a class="uri" href="supremum" title="wikilink">supremum</a>) of <em>X</em> is a least upper bound on <em>X</em>, namely an upper bound on <em>X</em> that is less or equal to every upper bound on <em>X</em>. Dually an <strong>inf</strong> (<a class="uri" href="infimum" title="wikilink">infimum</a>) of <em>X</em> is a greatest lower bound on <em>X</em>. The sup of <em>x</em> and <em>y</em> always exists in the underlying poset of a Boolean algebra, being <em>x</em>∨<em>y</em>, and likewise their inf exists, namely <em>x</em>∧<em>y</em>. The empty sup is 0 (the bottom element) and the empty inf is 1 (top). It follows that every finite set has both a sup and an inf. Infinite subsets of a Boolean algebra may or may not have a sup and/or an inf; in a power set algebra they always do.</p>

<p>Any poset (<em>B</em>,≤) such that every pair <em>x</em>,<em>y</em> of elements has both a sup and an inf is called a <strong><a href="lattice_(order)" title="wikilink">lattice</a></strong>. We write <em>x</em>∨<em>y</em> for the sup and <em>x</em>∧<em>y</em> for the inf. The underlying poset of a Boolean algebra always forms a lattice. The lattice is said to be <strong>distributive</strong> when <em>x</em>∧(<em>y</em>∨<em>z</em>) = (<em>x</em>∧<em>y</em>)∨(<em>x</em>∧<em>z</em>), or equivalently when <em>x</em>∨(<em>y</em>∧<em>z</em>) = (<em>x</em>∨<em>y</em>)∧(<em>x</em>∨<em>z</em>), since either law implies the other in a lattice. These are laws of Boolean algebra whence the underlying poset of a Boolean algebra forms a distributive lattice.</p>

<p>Given a lattice with a bottom element 0 and a top element 1, a pair <em>x</em>,<em>y</em> of elements is called <strong>complementary</strong> when <em>x</em>∧<em>y</em> = 0 and <em>x</em>∨<em>y</em> = 1, and we then say that <em>y</em> is a complement of <em>x</em> and vice versa. Any element <em>x</em> of a distributive lattice with top and bottom can have at most one complement. When every element of a lattice has a complement the lattice is called complemented. It follows that in a complemented distributive lattice, the complement of an element always exists and is unique, making complement a unary operation. Furthermore every complemented distributive lattice forms a Boolean algebra, and conversely every Boolean algebra forms a complemented distributive lattice. This provides an alternative definition of a Boolean algebra, namely as any complemented distributive lattice. Each of these three properties can be axiomatized with finitely many equations, whence these equations taken together constitute a finite axiomatization of the equational theory of Boolean algebras.</p>

<p>In a class of algebras defined as all the models of a set of equations, it is usually the case that some algebras of the class satisfy more equations than just those needed to qualify them for the class. The class of Boolean algebras is unusual in that, with a single exception, every Boolean algebra satisfies exactly the Boolean identities and no more. The exception is the one-element Boolean algebra, which necessarily satisfies every equation, even <em>x</em> = <em>y</em>, and is therefore sometimes referred to as the inconsistent Boolean algebra.</p>
<h2 id="boolean-homomorphisms">Boolean homomorphisms</h2>

<p>A Boolean <a class="uri" href="homomorphism" title="wikilink">homomorphism</a> is a function <em>h</em>: <em>A</em>→<em>B</em> between Boolean algebras <em>A</em>, <em>B</em> such that for every Boolean operation <sup><em>m</em></sup><em>f</em><sub><em>i</em></sub>,</p>
<dl>
<dd><em>h</em>(<sup><em>m</em></sup><em>f</em><sub><em>i</em></sub>(<em>x</em><sub>0</sub>,…,<em>x</em><sub><em>m</em>−1</sub>)) = <sup><em>m</em></sup><em>f</em><sub><em>i</em></sub>(<em>h</em>(<em>x</em><sub>0</sub>),…,<em>h</em>(<em>x</em><sub><em>m</em>−1</sub>)).
</dd>
</dl>

<p>The <a href="category_(mathematics)" title="wikilink">category</a> <strong>Bool</strong> of Boolean algebras has as objects all Boolean algebras and as morphisms the Boolean homomorphisms between them.</p>

<p>There exists a unique homomorphism from the two-element Boolean algebra <strong>2</strong> to every Boolean algebra, since homomorphisms must preserve the two constants and those are the only elements of <strong>2</strong>. A Boolean algebra with this property is called an <strong>initial</strong> Boolean algebra. It can be shown that any two initial Boolean algebras are isomorphic, so up to isomorphism <strong>2</strong> is <em>the</em> initial Boolean algebra.</p>

<p>In the other direction, there may exist many homomorphisms from a Boolean algebra <em>B</em> to <strong>2</strong>. Any such homomorphism partitions <em>B</em> into those elements mapped to 1 and those to 0. The subset of <em>B</em> consisting of the former is called an <a class="uri" href="ultrafilter" title="wikilink">ultrafilter</a> of <em>B</em>. When <em>B</em> is finite its ultrafilters pair up with its atoms; one atom is mapped to 1 and the rest to 0. Each ultrafilter of <em>B</em> thus consists of an atom of <em>B</em> and all the elements above it; hence exactly half the elements of <em>B</em> are in the ultrafilter, and there as many ultrafilters as atoms.</p>

<p>For infinite Boolean algebras the notion of ultrafilter becomes considerably more delicate. The elements greater or equal than an atom always form an ultrafilter but so do many other sets; for example in the Boolean algebra of finite and cofinite sets of integers the cofinite sets form an ultrafilter even though none of them are atoms. Likewise the powerset of the integers has among its ultrafilters the set of all subsets containing a given integer; there are countably many of these "standard" ultrafilters, which may be identified with the integers themselves, but there are uncountably many more "nonstandard" ultrafilters. These form the basis for <a href="nonstandard_analysis" title="wikilink">nonstandard analysis</a>, providing representations for such classically inconsistent objects as infinitesimals and delta functions.</p>
<h2 id="infinitary-extensions">Infinitary extensions</h2>

<p>Recall the definition of sup and inf from the section above on the underlying partial order of a Boolean algebra. A <a href="complete_Boolean_algebra" title="wikilink">complete Boolean algebra</a> is one every subset of which has both a sup and an inf, even the infinite subsets. Gaifman [1964] and <a href="Alfred_W._Hales" title="wikilink">Hales</a> [1964] independently showed that infinite <a href="free_object" title="wikilink">free</a> <a href="complete_Boolean_algebra" title="wikilink">complete Boolean algebras</a> do not exist. This suggests that a logic with set-sized-infinitary operations may have class-many terms—just as a logic with finitary operations may have infinitely many terms.</p>

<p>There is however another approach to introducing infinitary Boolean operations: simply drop "finitary" from the definition of Boolean algebra. A model of the equational theory of the algebra of <em>all</em> operations on {0,1} of arity up to the cardinality of the model is called a complete atomic Boolean algebra, or <em>CABA</em>. (In place of this awkward restriction on arity we could allow any arity, leading to a different awkwardness, that the signature would then be larger than any set, that is, a proper class. One benefit of the latter approach is that it simplifies the definition of homomorphism between CABAs of different <a class="uri" href="cardinality" title="wikilink">cardinality</a>.) Such an algebra can be defined equivalently as a <a href="complete_Boolean_algebra" title="wikilink">complete Boolean algebra</a> that is <strong>atomic</strong>, meaning that every element is a sup of some set of atoms. Free CABAs exist for all cardinalities of a set <em>V</em> of <a href="generating_set_of_an_algebra" title="wikilink">generators</a>, namely the <a href="power_set" title="wikilink">power set</a> algebra 2<sup>2<span><sup><em>V</em></sup></span></sup>, this being the obvious generalization of the finite free Boolean algebras. This neatly rescues infinitary Boolean logic from the fate the Gaifman–Hales result seemed to consign it to.</p>

<p>The nonexistence of <a href="free_object" title="wikilink">free</a> <a href="complete_Boolean_algebra" title="wikilink">complete Boolean algebras</a> can be traced to failure to extend the equations of Boolean logic suitably to all laws that should hold for infinitary conjunction and disjunction, in particular the neglect of distributivity in the definition of complete Boolean algebra. A complete Boolean algebra is called <strong>completely distributive</strong> when arbitrary conjunctions distribute over arbitrary disjunctions and vice versa. A Boolean algebra is a CABA if and only if it is complete and completely distributive, giving a third definition of CABA. A fourth definition is as any Boolean algebra isomorphic to a power set algebra.</p>

<p>A complete homomorphism is one that preserves all sups that exist, not just the finite sups, and likewise for infs. The category <strong>CABA</strong> of all CABAs and their complete homomorphisms is dual to the category of sets and their functions, meaning that it is equivalent to the opposite of that category (the category resulting from reversing all morphisms). Things are not so simple for the category <strong>Bool</strong> of Boolean algebras and their homomorphisms, which <a href="Marshall_Stone" title="wikilink">Marshall Stone</a> showed in effect (though he lacked both the language and the conceptual framework to make the duality explicit) to be dual to the category of <a href="totally_disconnected_space" title="wikilink">totally disconnected</a> <a href="compact_Hausdorff_space" title="wikilink">compact Hausdorff spaces</a>, subsequently called <a href="Stone_space" title="wikilink">Stone spaces</a>.</p>

<p>Another infinitary class intermediate between Boolean algebras and <a href="complete_Boolean_algebra" title="wikilink">complete Boolean algebras</a> is the notion of a <a class="uri" href="sigma-algebra" title="wikilink">sigma-algebra</a>. This is defined analogously to complete Boolean algebras, but with <a href="supremum" title="wikilink">sups</a> and <a href="infimum" title="wikilink">infs</a> limited to countable arity. That is, a <a class="uri" href="sigma-algebra" title="wikilink">sigma-algebra</a> is a Boolean algebra with all countable sups and infs. Because the sups and infs are of bounded <a class="uri" href="cardinality" title="wikilink">cardinality</a>, unlike the situation with <a href="complete_Boolean_algebra" title="wikilink">complete Boolean algebras</a>, the Gaifman-Hales result does not apply and <a href="free_object" title="wikilink">free</a> <a href="sigma-algebra" title="wikilink">sigma-algebras</a> do exist. Unlike the situation with CABAs however, the free countably generated sigma algebra is not a power set algebra.</p>
<h2 id="other-definitions-of-boolean-algebra">Other definitions of Boolean algebra</h2>

<p>We have already encountered several definitions of Boolean algebra, as a model of the equational theory of the two-element algebra, as a complemented distributive lattice, as a Boolean ring, and as a product-preserving functor from a certain category (Lawvere). Two more definitions worth mentioning are:.</p>
<dl>
<dt><a href="Marshall_Stone" title="wikilink">Stone</a> (1936): A Boolean algebra is the set of all <a href="clopen_set" title="wikilink">clopen sets</a> of a <a href="topological_space" title="wikilink">topological space</a>. It is no limitation to require the space to be a totally disconnected compact <a href="Hausdorff_space" title="wikilink">Hausdorff space</a>, or <a href="Stone_space" title="wikilink">Stone space</a>, that is, every Boolean algebra arises in this way, up to <a class="uri" href="isomorphism" title="wikilink">isomorphism</a>. Moreover if the two Boolean algebras formed as the clopen sets of two Stone spaces are isomorphic, so are the Stone spaces themselves, which is not the case for arbitrary topological spaces. This is just the reverse direction of the duality mentioned earlier from Boolean algebras to <a href="Stone_space" title="wikilink">Stone spaces</a>. This definition is fleshed out by the next definition.</dt>
</dl>
<dl>
<dt>Johnstone (1982): A Boolean algebra is a <a href="filtered_colimit" title="wikilink">filtered colimit</a> of finite Boolean algebras.</dt>
</dl>

<p>(The circularity in this definition can be removed by replacing "finite Boolean algebra" by "finite power set" equipped with the Boolean operations standardly interpreted for power sets.)</p>

<p>To put this in perspective, infinite sets arise as filtered colimits of finite sets, infinite CABAs as filtered limits of finite power set algebras, and infinite Stone spaces as filtered limits of finite sets. Thus if one starts with the finite sets and asks how these generalize to infinite objects, there are two ways: "adding" them gives ordinary or inductive sets while "multiplying" them gives <a href="Stone_space" title="wikilink">Stone spaces</a> or <a href="profinite_set" title="wikilink">profinite sets</a>. The same choice exists for finite power set algebras as the duals of finite sets: addition yields Boolean algebras as inductive objects while multiplication yields CABAs or power set algebras as profinite objects.</p>

<p>A characteristic distinguishing feature is that the underlying topology of objects so constructed, when defined so as to be <a href="Hausdorff_space" title="wikilink">Hausdorff</a>, is <a href="discrete_space" title="wikilink">discrete</a> for inductive objects and <a href="compact_space" title="wikilink">compact</a> for profinite objects. The topology of finite Hausdorff spaces is always both discrete and compact, whereas for infinite spaces "discrete"' and "compact" are mutually exclusive. Thus when generalizing finite algebras (of any kind, not just Boolean) to infinite ones, "discrete" and "compact" part company, and one must choose which one to retain. The general rule, for both finite and infinite algebras, is that finitary algebras are discrete, whereas their duals are compact and feature infinitary operations. Between these two extremes, there are many intermediate infinite Boolean algebras whose topology is neither discrete nor compact.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Boolean_domain" title="wikilink">Boolean domain</a></li>
<li><a href="Boolean_function" title="wikilink">Boolean function</a></li>
<li><a href="Boolean-valued_function" title="wikilink">Boolean-valued function</a></li>
<li><a href="Boolean-valued_model" title="wikilink">Boolean-valued model</a></li>
<li><a href="Cartesian_closed_category" title="wikilink">Cartesian closed category</a></li>
<li><a href="Closed_monoidal_category" title="wikilink">Closed monoidal category</a></li>
<li><a href="Complete_Boolean_algebra" title="wikilink">Complete Boolean algebra</a></li>
<li><a href="Topos#Elementary_topoi_(topoi_in_logic)" title="wikilink">Elementary topos</a></li>
</ul>
<ul>
<li><a href="Field_of_sets" title="wikilink">Field of sets</a></li>
<li><a href="Filter_(mathematics)" title="wikilink">Filter (mathematics)</a></li>
<li><a href="Finitary_boolean_function" title="wikilink">Finitary boolean function</a></li>
<li><a href="Free_Boolean_algebra" title="wikilink">Free Boolean algebra</a></li>
<li><a href="Functional_completeness" title="wikilink">Functional completeness</a></li>
<li><a href="Ideal_(order_theory)" title="wikilink">Ideal (order theory)</a></li>
<li><a href="Lattice_(order)" title="wikilink">Lattice (order)</a></li>
<li><a href="Lindenbaum-Tarski_algebra" title="wikilink">Lindenbaum-Tarski algebra</a></li>
</ul>
<ul>
<li><a href="Monoidal_category" title="wikilink">Monoidal category</a></li>
<li><a href="Propositional_calculus" title="wikilink">Propositional calculus</a></li>
<li><a href="Robbins_algebra" title="wikilink">Robbins algebra</a></li>
<li><a href="Truth_table" title="wikilink">Truth table</a></li>
<li><a class="uri" href="Ultrafilter" title="wikilink">Ultrafilter</a></li>
<li><a href="Universal_algebra" title="wikilink">Universal algebra</a></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li>

<p>.</p></li>
<li></li>
<li></li>
<li></li>
<li>--------, and Givant, Steven (1998) <em>Logic as Algebra</em>. Dolciani Mathematical Exposition, No. 21. <a href="Mathematical_Association_of_America" title="wikilink">Mathematical Association of America</a>.</li>
<li></li>
<li></li>
<li>Koppelberg, Sabine (1989) "General Theory of Boolean Algebras" in Monk, J. Donald, and Bonnet, Robert, eds., <em>Handbook of Boolean Algebras, Vol. 1</em>. North Holland. ISBN 978-0-444-70261-6.</li>
</ul>
<ul>
<li><a href="Charles_Sanders_Peirce" title="wikilink">Peirce, C. S.</a> (1989) <em>Writings of Charles S. Peirce: A Chronological Edition: 1879–1884</em>. Kloesel, C. J. W., ed. Indianapolis: Indiana University Press. ISBN 978-0-253-37204-8.</li>
<li></li>
<li></li>
<li></li>
<li></li>
<li><a href="Alfred_Tarski" title="wikilink">Tarski, Alfred</a> (1983). <em>Logic, Semantics, Metamathematics</em>, Corcoran, J., ed. Hackett. 1956 1st edition edited and translated by J. H. Woodger, Oxford Uni. Press. Includes English translations of the following two articles:
<ul>
<li></li>
<li></li>
</ul></li>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Articles_with_inconsistent_citation_formats" title="wikilink">Category:Articles with inconsistent citation formats</a> <a href="Category:Boolean_algebra" title="wikilink">Category:Boolean algebra</a></p>
</body>
</html>
