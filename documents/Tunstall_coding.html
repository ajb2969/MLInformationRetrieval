<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="970">Tunstall coding</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Tunstall coding</h1>
<hr/>

<p>In <a href="computer_science" title="wikilink">computer science</a> and <a href="information_theory" title="wikilink">information theory</a>, <strong>Tunstall coding</strong> is a form of <a href="entropy_coding" title="wikilink">entropy coding</a> used for <a href="lossless_data_compression" title="wikilink">lossless data compression</a>.</p>
<h2 id="history">History</h2>

<p>Tunstall coding was the subject of Brian Parker Tunstall's PhD thesis in 1967, while at Georgia Institute of Technology. The subject of that thesis was "Synthesis of noiseless compression codes" <a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>

<p>Its design is a precursor to <a class="uri" href="Lempel-Ziv" title="wikilink">Lempel-Ziv</a>.</p>
<h2 id="properties">Properties</h2>

<p>Unlike <a href="variable-length_code" title="wikilink">variable-length codes</a>, which include <a href="Huffman_coding" title="wikilink">Huffman</a> and <a href="Lempel–Ziv" title="wikilink">Lempel–Ziv coding</a>, Tunstall coding is a <a class="uri" href="code" title="wikilink">code</a> which maps source symbols to a fixed number of bits.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>

<p>Unlike <a href="Typical_set" title="wikilink">typical set encoding</a>, Tunstall coding parses a stochastic source with codewords of variable length.</p>

<p>It can be shown<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> that, for a large enough dictionary, the number of bits per source letter can be infinitely close to 

<math display="inline" id="Tunstall_coding:0">
 <semantics>
  <mrow>
   <mi>H</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>U</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>H</ci>
    <ci>U</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H(U)
  </annotation>
 </semantics>
</math>

, the <a href="Entropy_(information_theory)" title="wikilink">entropy</a> of the source.</p>
<h2 id="algorithm">Algorithm</h2>

<p>The algorithm requires as input an input alphabet 

<math display="inline" id="Tunstall_coding:1">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒰</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒰</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{U}
  </annotation>
 </semantics>
</math>

, along with a distribution of probabilities for each word input. It also requires an arbitrary constant 

<math display="inline" id="Tunstall_coding:2">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

, which is an upper bound to the size of the dictionary that it will compute. The dictionary in question, 

<math display="inline" id="Tunstall_coding:3">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>

, is constructed as a tree of probabilities, in which each edge is associated to a letter from the input alphabet. The algorithm goes like this:</p>

<p><code> D := tree of </code>

<math display="inline" id="Tunstall_coding:4">
 <semantics>
  <mrow>
   <mo stretchy="false">|</mo>
   <mi class="ltx_font_mathcaligraphic">𝒰</mi>
   <mo stretchy="false">|</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <abs></abs>
    <ci>𝒰</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\mathcal{U}|
  </annotation>
 </semantics>
</math>

<code> leaves, one for each letter in </code>

<math display="inline" id="Tunstall_coding:5">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒰</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒰</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{U}
  </annotation>
 </semantics>
</math>

<code>.</code><br/>
<code> While </code>

<math display="inline" id="Tunstall_coding:6">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">|</mo>
    <mi>D</mi>
    <mo stretchy="false">|</mo>
   </mrow>
   <mo><</mo>
   <mi>C</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <abs></abs>
     <ci>D</ci>
    </apply>
    <ci>C</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |D|<C
  </annotation>
 </semantics>
</math>

<code>:</code><br/>
<code>   Convert most probable leaf to tree with </code>

<math display="inline" id="Tunstall_coding:7">
 <semantics>
  <mrow>
   <mo stretchy="false">|</mo>
   <mi class="ltx_font_mathcaligraphic">𝒰</mi>
   <mo stretchy="false">|</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <abs></abs>
    <ci>𝒰</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\mathcal{U}|
  </annotation>
 </semantics>
</math>

<code> leaves.</code></p>
<h2 id="example">Example</h2>

<p>Let's imagine that we wish to encode the string "hello, world". Let's further assume (somewhat unrealistically) that the input alphabet 

<math display="inline" id="Tunstall_coding:8">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒰</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒰</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{U}
  </annotation>
 </semantics>
</math>

 contains only characters from the string "hello, world" — that is, 'h', 'e', 'l', ',', ' ', 'w', 'o', 'r', 'd'. We can therefore compute the probability of each character based on its statistical appearance in the input string. For instance, the letter L appears thrice in a string of 12 characters: its probability is 

<math display="inline" id="Tunstall_coding:9">
 <semantics>
  <mfrac>
   <mn>3</mn>
   <mn>12</mn>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <cn type="integer">3</cn>
    <cn type="integer">12</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   3\over 12
  </annotation>
 </semantics>
</math>

.</p>

<p>We initialize the tree, starting with a tree of 

<math display="inline" id="Tunstall_coding:10">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">|</mo>
    <mi class="ltx_font_mathcaligraphic">𝒰</mi>
    <mo stretchy="false">|</mo>
   </mrow>
   <mo>=</mo>
   <mn>9</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <abs></abs>
     <ci>𝒰</ci>
    </apply>
    <cn type="integer">9</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\mathcal{U}|=9
  </annotation>
 </semantics>
</math>

 leaves. Each word is therefore directly associated to a letter of the alphabet. The 9 words that we thus obtain can be encoded into a fixed-sized output of 

<math display="inline" id="Tunstall_coding:11">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">⌈</mo>
    <mrow>
     <msub>
      <mi>log</mi>
      <mn>2</mn>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>9</mn>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">⌉</mo>
   </mrow>
   <mo>=</mo>
   <mn>4</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ceiling></ceiling>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <log></log>
       <cn type="integer">2</cn>
      </apply>
      <cn type="integer">9</cn>
     </apply>
    </apply>
    <cn type="integer">4</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lceil\log_{2}(9)\rceil=4
  </annotation>
 </semantics>
</math>

 bits.</p>
<figure><b>(Figure)</b>
<figcaption>Tunstall "hello, world" example — one iteration</figcaption>
</figure>

<p>We then take the leaf of highest probability (here, 

<math display="inline" id="Tunstall_coding:12">
 <semantics>
  <msub>
   <mi>w</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>w</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w_{1}
  </annotation>
 </semantics>
</math>

), and convert it to yet another tree of 

<math display="inline" id="Tunstall_coding:13">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">|</mo>
    <mi class="ltx_font_mathcaligraphic">𝒰</mi>
    <mo stretchy="false">|</mo>
   </mrow>
   <mo>=</mo>
   <mn>9</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <abs></abs>
     <ci>𝒰</ci>
    </apply>
    <cn type="integer">9</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\mathcal{U}|=9
  </annotation>
 </semantics>
</math>

 leaves, one for each character. We re-compute the probabilities of those leaves. For instance, the sequence of two letters L happens once. Given that there are three occurrences of letters followed by an L, the resulting probability is 

<math display="inline" id="Tunstall_coding:14">
 <semantics>
  <mrow>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mn>3</mn>
    </mfrac>
    <mo>⋅</mo>
    <mfrac>
     <mn>3</mn>
     <mn>12</mn>
    </mfrac>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mn>1</mn>
    <mn>12</mn>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>normal-⋅</ci>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <cn type="integer">3</cn>
     </apply>
     <apply>
      <divide></divide>
      <cn type="integer">3</cn>
      <cn type="integer">12</cn>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <cn type="integer">12</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {1\over 3}\cdot{3\over 12}={1\over 12}
  </annotation>
 </semantics>
</math>

.</p>

<p>We obtain 17 words that only 12 of them has non-zero probability so we it's enough to code them only, which can each be encoded into a fixed-sized output of 

<math display="inline" id="Tunstall_coding:15">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">⌈</mo>
    <mrow>
     <msub>
      <mi>log</mi>
      <mn>2</mn>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>12</mn>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">⌉</mo>
   </mrow>
   <mo>=</mo>
   <mn>4</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ceiling></ceiling>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <log></log>
       <cn type="integer">2</cn>
      </apply>
      <cn type="integer">12</cn>
     </apply>
    </apply>
    <cn type="integer">4</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lceil\log_{2}(12)\rceil=4
  </annotation>
 </semantics>
</math>

 bits.</p>

<p> (This picture is wrong and code's length must be 4 not 5)</p>

<p>Note that we could iterate further, increasing the number of words by 

<math display="inline" id="Tunstall_coding:16">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">|</mo>
     <mi class="ltx_font_mathcaligraphic">𝒰</mi>
     <mo stretchy="false">|</mo>
    </mrow>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
   <mo>=</mo>
   <mn>8</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <minus></minus>
     <apply>
      <abs></abs>
      <ci>𝒰</ci>
     </apply>
     <cn type="integer">1</cn>
    </apply>
    <cn type="integer">8</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\mathcal{U}|-1=8
  </annotation>
 </semantics>
</math>

 every time.</p>
<h2 id="limitations">Limitations</h2>

<p>Tunstall coding requires the algorithm to know, prior to the parsing operation, what the distribution of probabilities for each letter of the alphabet is. This issue is shared with <a href="Huffman_coding" title="wikilink">Huffman coding</a>.</p>

<p>Its requiring a fixed-length block output makes it lesser than <a class="uri" href="Lempel-Ziv" title="wikilink">Lempel-Ziv</a>, which has a similar dictionary-based design, but with a variable-sized block output.</p>
<h2 id="references">References</h2>

<p>"</p>

<p><a href="Category:Lossless_compression_algorithms" title="wikilink">Category:Lossless compression algorithms</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a class="uri" href="http://www.rle.mit.edu/rgallager/documents/notes1.pdf">http://www.rle.mit.edu/rgallager/documents/notes1.pdf</a>, Study of Tunstall's algorithm at <a class="uri" href="MIT" title="wikilink">MIT</a><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="http://ipg.epfl.ch/lib/exe/fetch.php?media=en:courses:2013-2014:itc:tunstall.pdf">1</a>, Study of Tunstall's algorithm from <a class="uri" href="EPFL" title="wikilink">EPFL</a>'s Information Theory department<a href="#fnref3">↩</a></li>
</ol>
</section>
</body>
</html>
