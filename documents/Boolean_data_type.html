<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title offset="1860">Boolean data type</title>
   <script type="text/javascript"
      src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js">
    </script>
</head>
<body>
<h1>Boolean data type</h1>
<hr/>
<p>In <a href="computer_science" title="wikilink">computer science</a>, the <strong>Boolean data type</strong> is a <a href="data_type" title="wikilink">data type</a>, having two values (usually denoted <strong>true</strong> and <strong>false</strong>), intended to represent the <a href="truth_value" title="wikilink">truth values</a> of <a class="uri" href="logic" title="wikilink">logic</a> and <a href="Boolean_algebra_(logic)" title="wikilink">Boolean algebra</a>. It is named after <a href="George_Boole" title="wikilink">George Boole</a>, who first defined an algebraic system of logic in the mid 19th century. The Boolean data type is primarily associated with <a href="Conditional_(programming)" title="wikilink">conditional statements</a>, which allow different actions and change <a href="control_flow" title="wikilink">control flow</a> depending on whether a programmer-specified Boolean <em>condition</em> evaluates to true or false. It is a special case of a more general <strong>logical data type</strong>; logic does not always have to be Boolean.</p>
<h2 id="generalities">Generalities</h2>
<p>In <a href="programming_language" title="wikilink">programming languages</a> that have a built-in Boolean data type, such as <a href="Pascal_programming_language" title="wikilink">Pascal</a> and <a href="Java_programming_language" title="wikilink">Java</a>, the <a href="comparison_operator" title="wikilink">comparison operators</a> such as <code>></code> and <code>≠</code> are usually defined to return a Boolean value. <a href="if-then-else" title="wikilink">Conditional</a> and <a href="while_loop" title="wikilink">iterative commands</a> may be defined to test Boolean-valued expressions.</p>
<p>Languages without an explicit Boolean data type, like <a href="ANSI_C#C90" title="wikilink">C90</a> and <a href="Common_Lisp_(programming_language)" title="wikilink">Lisp</a>, may still represent truth values by some other data type. Common Lisp uses an empty list for false, and any other value for true. C uses an <a href="integer_(computer_science)" title="wikilink">integer</a> type, where relational expressions like <code>i > j</code> and logical expressions connected by <code>&&</code> and <code>||</code> are defined to have value 1 if true and 0 if false, whereas the test parts of <code>if</code>, <code>while</code>, <code>for</code>, etc., treat any non-zero value as true.<ref name="k&r1e"><a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> Indeed, a Boolean variable may be regarded (and be implemented) as a numerical variable with a single <a href="bit" title="wikilink">binary digit (bit)</a>, which can store only two values. It is worth noting that the implementation of Booleans in computers are most likely represented as a full <a href="Word_(computer_architecture)" title="wikilink">word</a>, rather than a bit; this is usually due to the ways computers transfer blocks of information.</p>
<p>Most programming languages, even those that do not have an explicit Boolean type, have support for Boolean algebraic operations such as <a href="logical_conjunction" title="wikilink">conjunction</a> (<code>AND</code>, <code>&</code>, <code>*</code>), <a href="logical_disjunction" title="wikilink">disjunction</a> (<code>OR</code>, <code>|</code>, <code>+</code>), <a href="logical_equivalence" title="wikilink">equivalence</a> (<code>EQV</code>, <code>=</code>, <code>==</code>), <a href="exclusive_disjunction" title="wikilink">exclusive or/non-equivalence</a> (<code>XOR</code>, <code>NEQV</code>, <code>^</code>, <code>!=</code>), and <a class="uri" href="negation" title="wikilink">negation</a> (<code>NOT</code>, <code>~</code>, <code>!</code>).</p>
<p>In some languages, like <a href="Ruby_(programming_language)" title="wikilink">Ruby</a>, <a class="uri" href="Smalltalk" title="wikilink">Smalltalk</a>, and <a href="Alice_(software)" title="wikilink">Alice</a> the "true" and "false" values belong to separate classes—e.g. <code>True</code> and <code>False</code>, resp.—so there is no single Boolean "type."</p>
<p>In <a class="uri" href="SQL" title="wikilink">SQL</a>, which uses a <a href="three-valued_logic" title="wikilink">three-valued logic</a> for explicit comparisons because of its special treatment of <a href="Null_(SQL)" title="wikilink">Nulls</a>, the Boolean data type (introduced in <a class="uri" href="SQL:1999" title="wikilink">SQL:1999</a>) is also defined to include more than two truth values, so that SQL "Booleans" can store all logical values resulting from the evaluation of predicates in SQL. A column of Boolean type can also be restricted to just <code>TRUE</code> and <code>FALSE</code> though.</p>
<p>In the <a href="lambda_calculus" title="wikilink">lambda calculus</a> model of computing, Boolean values can be represented as <a href="church_booleans" title="wikilink">Church Booleans</a>.</p>
<h2 id="algol-java-and-c">ALGOL, Java, and C#</h2>
<p>One of the earliest programming languages to provide an explicit <strong>Boolean</strong> data type was <a href="ALGOL_60" title="wikilink">ALGOL 60</a> (1960) with values <strong>true</strong> and <strong>false</strong> and logical operators denoted by symbols '<span class="LaTeX">$\wedge$</span>' (and), '<span class="LaTeX">$\vee$</span>' (or), '<span class="LaTeX">$\supset$</span>' (implies), '<span class="LaTeX">$\equiv$</span>' (equivalence), and '<span class="LaTeX">$\neg$</span>' (not). Due to input device limitations of the time, however, most compilers used alternative representations for the latter, such as <code>AND</code> or <code>'AND'</code>.</p>
<p>This approach ("Boolean is a separate built-in <a href="primitive_data_type" title="wikilink">primitive data type</a>") was adopted by many later programming languages, such as <a href="ALGOL_68" title="wikilink">ALGOL 68</a> (1970),<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> <a href="Java_(programming_language)" title="wikilink">Java</a>, and <a href="C_Sharp_(programming_language)" title="wikilink">C#</a>.</p>
<h2 id="fortran">Fortran</h2>
<p>The first version of <a href="Fortran" title="wikilink">FORTRAN</a> (1957) and its successor FORTRAN II (1958) did not have logical values or operations; even the conditional <code>IF</code> statement took an arithmetic expression and branched to one of three locations according to its sign; see <a href="arithmetic_IF" title="wikilink">arithmetic IF</a>. FORTRAN IV (1962), however, followed the ALGOL 60 example by providing a Boolean data type (<code>LOGICAL</code>), truth literals (<code>.TRUE.</code> and <code>.FALSE.</code>), Boolean-valued numeric comparison operators (<code>.EQ.</code>, <code>.GT.</code>, etc.), and logical operators (<code>.NOT.</code>, <code>.AND.</code>, <code>.OR.</code>). In <code>FORMAT</code> statements, a specific control character ('<code>L</code>') was provided for the parsing or formatting of logical values.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>
<h2 id="lisp-and-scheme">Lisp and Scheme</h2>
<p>The <a href="Lisp_(programming_language)" title="wikilink">Lisp</a> language (1958) never had a built-in Boolean data type. Instead, conditional constructs like <code>cond</code> assume that the logical value "false" is represented by the empty list <code>()</code>, which is defined to be the same as the special atom <code>nil</code> or <code>NIL</code>; whereas any other <a class="uri" href="s-expression" title="wikilink">s-expression</a> is interpreted as "true". For convenience, most modern dialects of Lisp predefine the atom <code>t</code> to have value <code>t</code>, so that one can use <code>t</code> as a mnemonic notation for "true".</p>
<p>This approach ("any value can be used as a Boolean value") was retained in most Lisp dialects (<a href="Common_Lisp" title="wikilink">Common Lisp</a>, <a href="Scheme_(programming_language)" title="wikilink">Scheme</a>, <a href="Emacs_Lisp" title="wikilink">Emacs Lisp</a>), and similar models were adopted by many <a href="scripting_language" title="wikilink">scripting languages</a>, even ones that do have a distinct Boolean type or Boolean values; although which values are interpreted as "false" and which are "true" vary from language to language. In Scheme, for example, the "false" value is an atom distinct from the empty list, so the latter is interpreted as "true".</p>
<h2 id="pascal-ada-and-haskell">Pascal, Ada, and Haskell</h2>
<p>The <a href="Pascal_(programming_language)" title="wikilink">Pascal</a> language (1978) introduced the concept of programmer-defined <a href="enumerated_type" title="wikilink">enumerated types</a>. A built-in <code>Boolean</code> data type was then provided as a predefined enumerated type with values <code>FALSE</code> and <code>TRUE</code>. By definition, all comparisons, logical operations, and conditional statements applied to and/or yielded <code>Boolean</code> values. Otherwise, the <code>Boolean</code> type had all the facilities which were available for enumerated types in general — such as ordering and use as indices. On the other hand, the conversion between <code>Boolean</code>s and integers (or any other types) still required explicit tests or function calls, as in ALGOL 60. This approach ("Boolean is an enumerated type") was adopted by most later languages which had enumerated types, such as <a class="uri" href="Modula" title="wikilink">Modula</a>, <a href="Ada_(programming_language)" title="wikilink">Ada</a> and <a href="Haskell_(programming_language)" title="wikilink">Haskell</a>.</p>
<h2 id="c-c-objective-c-awk-perl">C, C++, Objective-C, AWK, Perl</h2>
<p>The initial implementations of the <a href="C_(programming_language)" title="wikilink">C</a> language (1972) provided no Boolean type, and to this day Boolean values are commonly represented by integers (<code>int</code>s) in C programs. The comparison operators ('<code>></code>', '<code>==</code>', etc.) are defined to return a signed integer (<code>int</code>) result, either 0 (for false) or 1 (for true). Logical operators ('<code>&&</code>', '<code>||</code>', '<code>!</code>', etc.) and condition-testing statements ('<code>if</code>', '<code>while</code>') assume that zero is false and all other values are true. One problem with this approach is that the tests <code>if(t==TRUE){...}</code> and <code>if(t)</code> are not equivalent.</p>
<p>After enumerated types (<code>enum</code>s) were added to the <a href="ANSI_C" title="wikilink">ANSI version of C</a> (1989), many C programmers got used to defining their own Boolean types as such, for readability reasons. However, enumerated types are equivalent to integers according to the language standards; so the effective identity between Booleans and integers is still valid for C programs.</p>
<p>Standard <a href="C_programming_language" title="wikilink">C</a> (since <a class="uri" href="C99" title="wikilink">C99</a>) and several dialects of C such as <a class="uri" href="Objective-C" title="wikilink">Objective-C</a> provide definitions of a Boolean type as an integer type and macros for "false" and "true" as 0 and 1, respectively. Thus logical values can be stored in integer variables, and used anywhere integers would be valid, including in indexing, arithmetic, parsing, and formatting. This approach ("Boolean values are just integers") has been retained in all later versions of C.</p>
<p><a class="uri" href="C++" title="wikilink">C++</a> has a separate Boolean data type (<code>'bool'</code>), but with automatic conversions from scalar and pointer values that are very similar to those of C. This approach was adopted also by many later languages, especially by some <a href="scripting_language" title="wikilink">scripting</a> ones such as <a class="uri" href="AWK" title="wikilink">AWK</a>.</p>
<p><a class="uri" href="Objective-C" title="wikilink">Objective-C</a> also has a separate Boolean data type (<code>'BOOL'</code>), with possible values being <code>YES</code> or <code>NO</code>, equivalents of true and false respectively.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>
<p><a class="uri" href="Perl" title="wikilink">Perl</a> has many values of <code>false</code>: the number zero, the strings "0" and "", the empty list "()", and the special value <code>undef</code>.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> Everything else evaluates to <code>true</code>.</p>
<h2 id="python-ruby-and-javascript">Python, Ruby, and JavaScript</h2>
<p>In <a href="Python_(programming_language)" title="wikilink">Python</a> from version 2.3 forward, there is a <code>bool</code> type which is a <a href="subclass_(computer_science)" title="wikilink">subclass</a> of <code>int</code>, the standard integer type.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> It has two possible values: <code>True</code> and <code>False</code>, which are "special versions" of 1 and 0 respectively and behave as such in arithmetic contexts. In addition, a numeric value of zero (integer or fractional), the null value (<code>None</code>), the empty <a href="String_(computer_science)" title="wikilink">string</a>, and empty containers (i.e. <a href="list_(computing)" title="wikilink">lists</a>, <a href="set_(computing)" title="wikilink">sets</a>, etc.) are considered Boolean false; all other values are considered Boolean true by default.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> Classes can define how their instances are treated in a Boolean context through the special method <code>__nonzero__</code> (Python 2) or <code>__bool__</code> (Python 3). For containers, <code>__len__</code> (the special method for determining the length of containers) is used if the explicit Boolean conversion method is not defined.</p>
<p>In <a href="Ruby_(programming_language)" title="wikilink">Ruby</a>, on the other hand, only <code>nil</code> (Ruby's null value) and a special <code>false</code> object are "false", everything else (including the integer 0 and empty arrays) is "true".</p>
<p>In <a class="uri" href="JavaScript" title="wikilink">JavaScript</a>, the empty string (<code>""</code>), <code>null</code>, <code>undefined</code>, <code>[[NaN]]</code>, +0, <a class="uri" href="−0" title="wikilink">−0</a> and <code>false</code><a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> are sometimes called "falsy", and their <a href="complement_(set_theory)" title="wikilink">complement</a>, "truthy", to distinguish between strictly <a class="uri" href="type-checked" title="wikilink">type-checked</a> and <a href="type_coercion" title="wikilink">coerced</a> Booleans.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> Languages such as <a class="uri" href="PHP" title="wikilink">PHP</a> also use this approach.</p>
<h2 id="sql">SQL</h2>
<p>The <a class="uri" href="SQL:1999" title="wikilink">SQL:1999</a> standard introduced a BOOLEAN data type as an optional feature (T031). When restricted by a <code>NOT NULL</code> constraint, a SQL BOOLEAN behaves like Booleans in other languages. In SQL however, the BOOLEAN type is <a href="nullable_type" title="wikilink">nullable</a> by default like all other SQL data types, meaning it can have the special <a href="Null_(SQL)" title="wikilink">null</a> value as well. Although the SQL standard defines three <a href="Literal_(computer_programming)" title="wikilink">literals</a> for the BOOLEAN type—TRUE, FALSE and UNKNOWN—, it also says that the NULL BOOLEAN and UNKNOWN "may be used interchangeably to mean exactly the same thing".<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a><a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> This has caused some controversy because the identification subjects UNKNOWN to the equality comparison rules for NULL. More precisely UNKNOWN = UNKNOWN is not TRUE but UNKNOWN/NULL.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> As of 2012 few major SQL systems implement the T031 feature.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> <a class="uri" href="PostgreSQL" title="wikilink">PostgreSQL</a> is a notable exception, although it does not implement the UNKNOWN literal; NULL can be used instead.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a> (PostgreSQL does implement the IS UNKNOWN operator, which is part of an orthogonal feature, F571.) In other SQL implementations various ad hoc solutions are used, like <a class="uri" href="bit" title="wikilink">bit</a>, <a class="uri" href="byte" title="wikilink">byte</a>, and <a href="character_(computing)" title="wikilink">character</a> to simulate Boolean values.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="true_and_false_(Unix)" title="wikilink">true and false</a> commands for <a href="shell_scripting" title="wikilink">shell scripting</a></li>
<li><a href="Shannon's_expansion" title="wikilink">Shannon's expansion</a></li>
<li><a class="uri" href="stdbool.h" title="wikilink">stdbool.h</a> — C99 definitions for boolean</li>
</ul>
<h2 id="references">References</h2>
<p>"</p>
<p><a href="Category:Boolean_algebra" title="wikilink">Category:Boolean algebra</a> <a href="Category:Data_types" title="wikilink">Category:Data types</a> <a href="Category:Primitive_types" title="wikilink">Category:Primitive types</a> <a href="Category:Articles_with_example_ALGOL_68_code" title="wikilink">Category:Articles with example ALGOL 68 code</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3">Digital Equipment Corporation, <em>DECSystem10 FORTRAN IV Programmers Reference Manual</em>. Reprinted in <em>Mathematical Languages Handbook</em>. <a href="http://www.bitsavers.org/pdf/tymshare/tymcom-x/Tymcom-X_Reference_Series_Fortran_IV_Jan73.pdf">Online version</a> accessed 2011-11-16.<a href="#fnref3">↩</a></li>
<li id="fn4"><a class="uri" href="http://developer.apple.com/library/ios/#documentation/cocoa/conceptual/ProgrammingWithObjectiveC/FoundationTypesandCollections/FoundationTypesandCollections.html">http://developer.apple.com/library/ios/#documentation/cocoa/conceptual/ProgrammingWithObjectiveC/FoundationTypesandCollections/FoundationTypesandCollections.html</a><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
<li id="fn10"><a href="#fnref10">↩</a></li>
<li id="fn11">ISO/IEC 9075-2:2011 §4.5<a href="#fnref11">↩</a></li>
<li id="fn12"><a href="#fnref12">↩</a></li>
<li id="fn13">Troels Arvin, <a href="http://troels.arvin.dk/db/rdbms/#data_types-boolean">Survey of BOOLEAN data type implementation</a><a href="#fnref13">↩</a></li>
<li id="fn14"><a class="uri" href="http://www.postgresql.org/docs/current/static/datatype-boolean.html">http://www.postgresql.org/docs/current/static/datatype-boolean.html</a><a href="#fnref14">↩</a></li>
</ol>
</section>
</body>
</html>
