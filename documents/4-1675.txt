   Divide-and-conquer eigenvalue algorithm      Divide-and-conquer eigenvalue algorithm   Divide-and-conquer eigenvalue algorithms are a class of eigenvalue algorithms for Hermitian or real  symmetric matrices that have recently (circa 1990s) become competitive in terms of stability and efficiency with more traditional algorithms such as the QR algorithm . The basic concept behind these algorithms is the divide-and-conquer approach from computer science . An eigenvalue problem is divided into two problems of roughly half the size, each of these are solved recursively , and the eigenvalues of the original problem are computed from the results of these smaller problems.  Here we present the simplest version of a divide-and-conquer algorithm, similar to the one originally proposed by Cuppen in 1981. Many details that lie outside the scope of this article will be omitted; however, without considering these details, the algorithm is not fully stable.  Background  As with most eigenvalue algorithms for Hermitian matrices, divide-and-conquer begins with a reduction to tridiagonal form. For an    m  ×  m      m  m    m\times m   matrix, the standard method for this, via Householder reflections , takes     4  3    m  3         4  3    superscript  m  3     \frac{4}{3}m^{3}    flops , or     8  3    m  3         8  3    superscript  m  3     \frac{8}{3}m^{3}   if eigenvectors are needed as well. There are other algorithms, such as the Arnoldi iteration , which may do better for certain classes of matrices; we will not consider this further here.  In certain cases, it is possible to deflate an eigenvalue problem into smaller problems. Consider a block diagonal matrix       T  =   [      T  1     0      0     T  2      ]    .      T     subscript  T  1   0    0   subscript  T  2       T=\begin{bmatrix}T_{1}&0\\
 0&T_{2}\end{bmatrix}.   The eigenvalues and eigenvectors of   T   T   T   are simply those of    T  1     subscript  T  1    T_{1}   and    T  2     subscript  T  2    T_{2}   , and it will almost always be faster to solve these two smaller problems than to solve the original problem all at once. This technique can be used to improve the efficiency of many eigenvalue algorithms, but it has special significance to divide-and-conquer.  For the rest of this article, we will assume the input to the divide-and-conquer algorithm is an    m  ×  m      m  m    m\times m   real symmetric tridiagonal matrix   T   T   T   . Although the algorithm can be modified for Hermitian matrices, we do not give the details here.  Divide  The divide part of the divide-and-conquer algorithm comes from the realization that a tridiagonal matrix is "almost" block diagonal.      The size of submatrix    T  1     subscript  T  1    T_{1}   we will call    n  ×  n      n  n    n\times n   , and then    T  2     subscript  T  2    T_{2}   is     (   m  -  n   )   ×   (   m  -  n   )         m  n     m  n     (m-n)\times(m-n)   . Note that the remark about   T   T   T   being almost block diagonal is true regardless of how   n   n   n   is chosen (i.e., there are many ways to so decompose the matrix). However, it makes sense, from an efficiency standpoint, to choose    n  ≈   m  /  2       n    m  2     n\approx m/2   .  We write   T   T   T   as a block diagonal matrix, plus a rank-1 correction:      The only difference between    T  1     subscript  T  1    T_{1}   and     T  ^   1     subscript   normal-^  T   1    \hat{T}_{1}   is that the lower right entry    t   n  n      subscript  t    n  n     t_{nn}   in     T  ^   1     subscript   normal-^  T   1    \hat{T}_{1}   has been replaced with     t   n  n    -  β       subscript  t    n  n    β    t_{nn}-\beta   and similarly, in     T  ^   2     subscript   normal-^  T   2    \hat{T}_{2}   the top left entry    t    n  +  1   ,   n  +  1       subscript  t     n  1     n  1      t_{n+1,n+1}   has been replaced with     t    n  +  1   ,   n  +  1     -  β       subscript  t     n  1     n  1     β    t_{n+1,n+1}-\beta   .  The remainder of the divide step is to solve for the eigenvalues (and if desired the eigenvectors) of     T  ^   1     subscript   normal-^  T   1    \hat{T}_{1}   and     T  ^   2     subscript   normal-^  T   2    \hat{T}_{2}   , that is to find the diagonalizations       T  ^   1   =    Q  1    D  1    Q  1  T         subscript   normal-^  T   1      subscript  Q  1    subscript  D  1    superscript   subscript  Q  1   T      \hat{T}_{1}=Q_{1}D_{1}Q_{1}^{T}   and      T  ^   2   =    Q  2    D  2    Q  2  T         subscript   normal-^  T   2      subscript  Q  2    subscript  D  2    superscript   subscript  Q  2   T      \hat{T}_{2}=Q_{2}D_{2}Q_{2}^{T}   . This can be accomplished with recursive calls to the divide-and-conquer algorithm, although practical implementations often switch to the QR algorithm for small enough submatrices.  Conquer  The conquer part of the algorithm is the unintuitive part. Given the diagonalizations of the submatrices, calculated above, how do we find the diagonalization of the original matrix?  First, define     z  T   =   (   q  1  T   ,   q  2  T   )        superscript  z  T     superscript   subscript  q  1   T    superscript   subscript  q  2   T      z^{T}=(q_{1}^{T},q_{2}^{T})   , where    q  1  T     superscript   subscript  q  1   T    q_{1}^{T}   is the last row of    Q  1     subscript  Q  1    Q_{1}   and    q  2  T     superscript   subscript  q  2   T    q_{2}^{T}   is the first row of    Q  2     subscript  Q  2    Q_{2}   . It is now elementary to show that      T  =    [      Q  1              Q  2      ]    (    [      D  1              D  2      ]   +   β  z   z  T     )    [      Q  1  T              Q  2  T      ]        T       subscript  Q  1   absent    absent   subscript  Q  2          subscript  D  1   absent    absent   subscript  D  2       β  z   superscript  z  T        superscript   subscript  Q  1   T   absent    absent   superscript   subscript  Q  2   T        T=\begin{bmatrix}Q_{1}&\\
 &Q_{2}\end{bmatrix}\left(\begin{bmatrix}D_{1}&\\
 &D_{2}\end{bmatrix}+\beta zz^{T}\right)\begin{bmatrix}Q_{1}^{T}&\\
 &Q_{2}^{T}\end{bmatrix}     The remaining task has been reduced to finding the eigenvalues of a diagonal matrix plus a rank-one correction. Before showing how to do this, let us simplify the notation. We are looking for the eigenvalues of the matrix    D  +   w   w  T        D    w   superscript  w  T      D+ww^{T}   , where   D   D   D   is diagonal with distinct entries and   w   w   w   is any vector with nonzero entries.  If w i is zero, (    e  i     subscript  e  i    e_{i}   ,d i ) is an eigenpair of    D  +   w   w  T        D    w   superscript  w  T      D+ww^{T}   since      (   D  +   w   w  T     )    e  i    =   D   e  i    =    d  i    e  i              D    w   superscript  w  T      subscript  e  i      D   subscript  e  i            subscript  d  i    subscript  e  i       (D+ww^{T})e_{i}=De_{i}=d_{i}e_{i}   .  If   λ   λ   \lambda   is an eigenvalue, we have:        (   D  +   w   w  T     )   q   =   λ  q           D    w   superscript  w  T     q     λ  q     (D+ww^{T})q=\lambda q   where   q   q   q   is the corresponding eigenvector. Now         (   D  -   λ  I    )   q   +   w   (    w  T   q   )     =  0            D    λ  I    q     w     superscript  w  T   q     0    (D-\lambda I)q+w(w^{T}q)=0          q  +     (   D  -   λ  I    )    -  1    w   (    w  T   q   )     =  0        q     superscript    D    λ  I      1    w     superscript  w  T   q     0    q+(D-\lambda I)^{-1}w(w^{T}q)=0            w  T   q   +    w  T     (   D  -   λ  I    )    -  1    w   (    w  T   q   )     =  0           superscript  w  T   q      superscript  w  T    superscript    D    λ  I      1    w     superscript  w  T   q     0    w^{T}q+w^{T}(D-\lambda I)^{-1}w(w^{T}q)=0   Keep in mind that     w  T   q       superscript  w  T   q    w^{T}q   is a nonzero scalar. Neither   w   w   w   nor   q   q   q   are zero. If     w  T   q       superscript  w  T   q    w^{T}q   were to be zero,   q   q   q   would be an eigenvector of   D   D   D   by      (   D  +   w   w  T     )   q   =   λ  q           D    w   superscript  w  T     q     λ  q     (D+ww^{T})q=\lambda q   . If that were the case,   q   q   q   would contain only one nonzero position since   D   D   D   is distinct diagonal and thus the inner product     w  T   q       superscript  w  T   q    w^{T}q   can not be zero after all. Therefore, we have:       1  +    w  T     (   D  -   λ  I    )    -  1    w    =  0        1     superscript  w  T    superscript    D    λ  I      1    w    0    1+w^{T}(D-\lambda I)^{-1}w=0   or written as a scalar equation,       1  +    ∑   j  =  1   m     w  j  2     d  j   -  λ      =  0.        1    superscript   subscript     j  1    m      superscript   subscript  w  j   2      subscript  d  j   λ      0.    1+\sum_{j=1}^{m}\frac{w_{j}^{2}}{d_{j}-\lambda}=0.   This equation is known as the secular equation . The problem has therefore been reduced to finding the roots of the rational function defined by the left-hand side of this equation.  All general eigenvalue algorithms must be iterative, and the divide-and-conquer algorithm is no different. Solving the nonlinear secular equation requires an iterative technique, such as the Newton–Raphson method . However, each root can be found in O (1) iterations, each of which requires    Θ   (  m  )       normal-Θ  m    \Theta(m)   flops (for an   m   m   m   -degree rational function), making the cost of the iterative part of this algorithm    Θ   (   m  2   )       normal-Θ   superscript  m  2     \Theta(m^{2})   .  Analysis  As is common for divide and conquer algorithms, we will use the Master theorem to analyze the running time. Remember that above we stated we choose    n  ≈   m  /  2       n    m  2     n\approx m/2   . We can write the recurrence relation :       T   (  m  )    =     2  ×  T    (   m  2   )    +   Θ   (   m  2   )           T  m         2  T     m  2      normal-Θ   superscript  m  2       T(m)=2\times T\left(\frac{m}{2}\right)+\Theta(m^{2})   In the notation of the Master theorem,    a  =  b  =  2        a  b       2     a=b=2   and thus      log  b   a   =  1        subscript   b   a   1    \log_{b}a=1   . Clearly,     Θ   (   m  2   )    =   Ω   (   m  1   )          normal-Θ   superscript  m  2      normal-Ω   superscript  m  1      \Theta(m^{2})=\Omega(m^{1})   , so we have       T   (  m  )    =   Θ   (   m  2   )          T  m     normal-Θ   superscript  m  2      T(m)=\Theta(m^{2})     Remember that above we pointed out that reducing a Hermitian matrix to tridiagonal form takes     4  3    m  3         4  3    superscript  m  3     \frac{4}{3}m^{3}   flops. This dwarfs the running time of the divide-and-conquer part, and at this point it is not clear what advantage the divide-and-conquer algorithm offers over the QR algorithm (which also takes    Θ   (   m  2   )       normal-Θ   superscript  m  2     \Theta(m^{2})   flops for tridiagonal matrices).  The advantage of divide-and-conquer comes when eigenvectors are needed as well. If this is the case, reduction to tridiagonal form takes     8  3    m  3         8  3    superscript  m  3     \frac{8}{3}m^{3}   , but the second part of the algorithm takes    Θ   (   m  3   )       normal-Θ   superscript  m  3     \Theta(m^{3})   as well. For the QR algorithm with a reasonable target precision, this is     ≈   6   m  3        absent    6   superscript  m  3      \approx 6m^{3}   , whereas for divide-and-conquer it is     ≈    4  3    m  3        absent      4  3    superscript  m  3      \approx\frac{4}{3}m^{3}   . The reason for this improvement is that in divide-and-conquer, the    Θ   (   m  3   )       normal-Θ   superscript  m  3     \Theta(m^{3})   part of the algorithm (multiplying   Q   Q   Q   matrices) is separate from the iteration, whereas in QR, this must occur in every iterative step. Adding the     8  3    m  3         8  3    superscript  m  3     \frac{8}{3}m^{3}   flops for the reduction, the total improvement is from     ≈   9   m  3        absent    9   superscript  m  3      \approx 9m^{3}   to     ≈   4   m  3        absent    4   superscript  m  3      \approx 4m^{3}   flops.  Practical use of the divide-and-conquer algorithm has shown that in most realistic eigenvalue problems, the algorithm actually does better than this. The reason is that very often the matrices   Q   Q   Q   and the vectors   z   z   z   tend to be numerically sparse , meaning that they have many entries with values smaller than the floating point precision, allowing for numerical deflation , i.e. breaking the problem into uncoupled subproblems.  Variants and implementation  The algorithm presented here is the simplest version. In many practical implementations, more complicated rank-1 corrections are used to guarantee stability; some variants even use rank-2 corrections.  There exist specialized root-finding techniques for rational functions that may do better than the Newton-Raphson method in terms of both performance and stability. These can be used to improve the iterative part of the divide-and-conquer algorithm.  The divide-and-conquer algorithm is readily parallelized , and linear algebra computing packages such as LAPACK contain high-quality parallel implementations.  References    .   "  Category:Numerical linear algebra   