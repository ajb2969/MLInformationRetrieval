   Precedence graph      Precedence graph   A precedence graph , also named conflict graph and serializability graph , is used in the context of concurrency control in databases .  The precedence graph for a schedule S contains:   A node for each committed transaction in S  An arc from T i to T j if an action of T i precedes and conflicts with one of T j 's actions.   Precedence graph example  (Figure)  Precedence graph.svg       D  =   [      T  1      T  2      T  3        R   (  A  )                  W   (  A  )                    W   (  A  )                                W   (  A  )               ]       D      T  1     T  2     T  3       R  A   absent  absent    absent    W  A   absent    absent  absent      W  A   absent  absent    absent  absent  absent    absent  absent    W  A     absent  absent      D=\begin{bmatrix}T1&T2&T3\\
 R(A)&&\\
 &W(A)&\\
 &\\
 W(A)&&\\
 &&\\
 &&W(A)\\
 &\\
 \end{bmatrix}     or       D  =   R  1   (  A  )        D    R  1  A     D=R1(A)       W  2   (  A  )       W  2  A    W2(A)       C  o  m  .2      C  o  m  .2    Com.2       W  1   (  A  )       W  1  A    W1(A)       C  o  m  .1      C  o  m  .1    Com.1       W  3   (  A  )       W  3  A    W3(A)       C  o  m  .3      C  o  m  .3    Com.3       A precedence graph of the schedule D, with 3 transactions. As there is a cycle (of length 2; with two edges) through the committed transactions T1 and T2, this schedule (history) is not  Conflict serializable .  Testing Serializability with Precedence Graph  The drawing sequence for the precedence graph:-   For each transaction T i participating in schedule S, create a node labelled T i in the precedence graph. So the precedence graph contains T 1 , T 2 , T 3  For each case in S where T i executes a write_item(X) then T j executes a read_item(X), create an edge (T i --> T j ) in the precedence graph. This occurs nowhere in the above example, as there is no read after write.  For each case in S where T i executes a read_item(X) then T j executes a write_item(X), create an edge (T i --> T j ) in the precedence graph. This will bring to front a directed graph from T 1 to T 2 .  For each case in S where T i executes a write_item(X) then T j executes a write_item(X), create an edge (T i --> T j ) in the precedence graph. It creates a directed graph from T 2 to T 1 , T 1 to T 3 , and T 2 to T 3 .  The schedule S is serializable if the precedence graph has no cycles. As T 1 and T 2 constitute a cycle, then we cannot declare S as serializable or not and serializability has to be checked using other methods.   External links   [ http://portal.acm.org/citation.cfm?id=1202608&dl; ;=GUIDE&coll;=GUIDE&CFID;=9802819&CFTOKEN;=82728908 The Fundamentals of Database Systems, 5th Edition] the use of precedence graphs is discussed in chapter 17, as they relate to tests for conflict serializability .  Abraham Silberschatz, Henry Korth, and S. Sudarshan. 2005. Database Systems Concepts (5 ed.), PP. 628–630. McGraw-Hill, Inc., New York, NY, USA.   el:Γράφος Σειριοποιησιμότητας  ru:Граф предшествования "  Category:Database management systems   