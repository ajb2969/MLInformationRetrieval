   Karger's algorithm      Karger's algorithm   In computer science and graph theory , Karger's algorithm is a randomized algorithm to compute a minimum cut of a connected graph . It was invented by David Karger and first published in 1993. 1  The idea of the algorithm is based on the concept of contraction of an edge     (  u  ,  v  )     u  v    (u,v)   in an undirected graph    G  =   (  V  ,  E  )       G   V  E     G=(V,E)   . Informally speaking, the contraction of an edge merges the nodes   u   u   u   and   v   v   v   into one, reducing the total number of nodes of the graph by one. All other edges connecting either   u   u   u   or   v   v   v   are "reattached" to the merged node, effectively producing a multigraph . Karger's basic algorithm iteratively contracts randomly chosen edges until only two nodes remain; those nodes represent a cut in the original graph. By iterating this basic algorithm a sufficient number of times, a minimum cut can be found with high probability.  The global minimum cut problem  A cut     (  S  ,  T  )     S  T    (S,T)   in an undirected graph    G  =   (  V  ,  E  )       G   V  E     G=(V,E)   is a partition of the vertices   V   V   V   into two non-empty, disjoint sets     S  ‚à™  T   =  V        S  T   V    S\cup T=V   . The cutset of a cut consists of the edges    {    u  v   ‚àà  E   :    u  ‚àà  S   ,   v  ‚àà   T     }     conditional-set      u  v   E    formulae-sequence    u  S     v  T      \{\,uv\in E\colon u\in S,v\in T\,\}   between the two parts. The size (or weight ) of a cut in an unweighted graph is the cardinality of the cutset, i.e., the number of edges between the two parts,          w   (  S  ,  T  )    =   |   {    u  v   ‚àà  E   :    u  ‚àà  S   ,   v  ‚àà   T     }   |    .        w   S  T       conditional-set      u  v   E    formulae-sequence    u  S     v  T        w(S,T)=|\{\,uv\in E\colon u\in S,v\in T\,\}|\,.        There are    2   |  V  |      superscript  2    V     2^{|V|}   ways of choosing for each vertex whether it belongs to   S   S   S   or to   T   T   T   , but two of these choices make   S   S   S   or   T   T   T   empty and do not give rise to cuts. Among the remaining choices, swapping the roles of   S   S   S   and   T   T   T   does not change the cut, so each cut is counted twice; therefore, there are     2    |  V  |   -  1    -  1       superscript  2      V   1    1    2^{|V|-1}-1   distinct cuts. The minimum cut problem is to find a cut of smallest size among these cuts.  For weighted graphs with positive edge weights    w  :   E  ‚Üí   ùêë  +       normal-:  w   normal-‚Üí  E   superscript  ùêë       w\colon E\rightarrow\mathbf{R}^{+}   the weight of the cut is the sum of the weights of edges between vertices in each part          w   (  S  ,  T  )    =    ‚àë     u  v   ‚àà  E   :    u  ‚àà  S   ,   v  ‚àà  T       w   (   u  v   )      ,        w   S  T      subscript    normal-:      u  v   E    formulae-sequence    u  S     v  T        w    u  v       w(S,T)=\sum_{uv\in E\colon u\in S,v\in T}w(uv)\,,        which agrees with the unweighted definition for    w  =  1      w  1    w=1   .  A cut is sometimes called a ‚Äúglobal cut‚Äù to distinguish it from an ‚Äú   s   s   s   -   t   t   t   cut‚Äù for a given pair of vertices, which has the additional requirement that    s  ‚àà  S      s  S    s\in S   and    t  ‚àà  T      t  T    t\in T   . Every global cut is an   s   s   s   -   t   t   t   cut for some     s  ,  t   ‚àà  V       s  t   V    s,t\in V   . Thus, the minimum cut problem can be solved in polynomial time by iterating over all choices of     s  ,  t   ‚àà  V       s  t   V    s,t\in V   and solving the resulting minimum   s   s   s   -   t   t   t   cut problem using the max-flow min-cut theorem and a polynomial time algorithm for maximum flow , such as the push-relabel algorithm , though this approach is not optimal. There is a deterministic algorithm for the global minimum cut problem with running time    O   (    m  n   +    n  2    log  n     )       O      m  n      superscript  n  2     n       O(mn+n^{2}\log n)   . 2  Contraction algorithm  The fundamental operation of Karger‚Äôs algorithm is a form of edge contraction . The result of contracting the edge    e  =   {  u  ,  v  }       e   u  v     e=\{u,v\}   is new node    u  v      u  v    uv   . Every edge    {  w  ,  u  }     w  u    \{w,u\}   or    {  w  ,  v  }     w  v    \{w,v\}   for    w  ‚àâ   {  u  ,  v  }       w   u  v     w\notin\{u,v\}   to the endpoints of the contracted edge is replaced by an edge    {  w  ,   u  v   }     w    u  v     \{w,uv\}   to the new node. Finally, the contracted nodes   u   u   u   and   v   v   v   with all their incident edges are removed. In particular, the resulting graph contains no self-loops. The result of contracting edge   e   e   e   is denoted    G  /  e      G  e    G/e   .  (Figure)  The marked edge is contracted into a single node.   The contraction algorithm repeatedly contracts random edges in the graph, until only two nodes remain, at which point there is only a single cut.  (Figure)  Successful run of Karger‚Äôs algorithm on a 10-vertex graph. The minimum cut has size 3.    procedure contract(     G  =   (  V  ,  E  )       G   V  E     G=(V,E)    ):   while       |  V  |   >  2        V   2    |V|>2     choose     e  ‚àà  E      e  E    e\in E    uniformly¬†at¬†random       G  ‚Üê   G  /  e      normal-‚Üê  G    G  e     G\leftarrow G/e      return the¬†only¬†cut¬†in    G   G   G     When the graph is represented using adjacency lists or an adjacency matrix , a single edge contraction operation can be implemented with a linear number of updates to the data structure, for a total running time of    O   (    |  V  |   2   )       O   superscript    V   2     O(|V|^{2})   . Alternatively, the procedure can be viewed as an execution of Kruskal‚Äôs algorithm for constructing the minimum spanning tree in a graph where the edges have weights     w   (   e  i   )    =   œÄ   (  i  )          w   subscript  e  i      œÄ  i     w(e_{i})=\pi(i)   according to a random permutation   œÄ   œÄ   \pi   . Removing the heaviest edge of this tree results in two components that describe a cut. In this way, the contraction procedure can be implemented like Kruskal‚Äôs algorithm in time    O   (    |  E  |    log   |  E  |     )       O      E       E       O(|E|\log|E|)   .  (Figure)  The random edge choices in Karger‚Äôs algorithm correspond to an execution of Kruskal‚Äôs algorithm on a graph with random edge ranks until only two components remain.   The best known implementations use    O   (   |  E  |   )       O    E     O(|E|)   time and space, or    O   (    |  E  |    log   |  E  |     )       O      E       E       O(|E|\log|E|)   time and    O   (   |  V  |   )       O    V     O(|V|)   space, respectively. 3  Success probability of the contraction algorithm  In a graph    G  =   (  V  ,  E  )       G   V  E     G=(V,E)   with    n  =   |  V  |       n    V     n=|V|   vertices, the contraction algorithm returns a minimum cut with polynomially small probability     (      n      2      )    -  1      superscript   binomial  n  2     1     {\left({{n}\atop{2}}\right)}^{-1}   . Every graph has     2   n  -  1    -  1       superscript  2    n  1    1    2^{n-1}-1   cuts, 4 among which at most    (      n      2      )     binomial  n  2    {\textstyle\left({{n}\atop{2}}\right)}   can be minimum cuts. Therefore, the success probability for this algorithm is much better than the probability for picking a cut at random, which is at most     (      n      2      )   /   (    2   n  -  1    -  1   )        binomial  n  2      superscript  2    n  1    1     {\textstyle\left({{n}\atop{2}}\right)}/(2^{n-1}-1)     For instance, the cycle graph on   n   n   n   vertices has exactly    (      n      2      )     binomial  n  2    {\left({{n}\atop{2}}\right)}   minimum cuts, given by every choice of 2 edges. The contraction procedure finds each of these with equal probability.  To establish the bound on the success probability in general, let   C   C   C   denote the edges of a specific minimum cut of size   k   k   k   . The contraction algorithm returns   C   C   C   if none of the random edges belongs to the cutset of   C   C   C   . In particular, the first edge contraction avoids   C   C   C   , which happens with probability    1  -   k  /   |  E  |        1    k    E      1-k/|E|   . The minimum degree of   G   G   G   is at least   k   k   k   (otherwise a minimum degree vertex would induce a smaller cut), so     |  E  |   ‚â•    n  k   /  2         E       n  k   2     |E|\geq nk/2   . Thus, the probability that the contraction algorithm picks an edge from   C   C   C   is          k   |  E  |    ‚â§   k    n  k   /  2    =   2  n    .          k    E      k      n  k   2           2  n      \frac{k}{|E|}\leq\frac{k}{nk/2}=\frac{2}{n}.        The probability    p  n     subscript  p  n    p_{n}   that the contraction algorithm on an   n   n   n   -vertex graph avoids   C   C   C   satisfies the recurrence     p  n   ‚â•    (   1  -   2  n    )    p   n  -  1          subscript  p  n       1    2  n     subscript  p    n  1       p_{n}\geq\bigl(1-\frac{2}{n}\bigr)p_{n-1}   , with     p  2   =  1       subscript  p  2   1    p_{2}=1   , which can be expanded as         p_n \geq \prod_{i=0}^{n-3} \Bigl(1-\frac{2}{n-i}\Bigr) =  \prod_{i=0}^{n-3}¬†{\frac{n-i-2}{n-i}}  =¬†\frac{n-2}{n}\cdot¬†\frac{n-3}{n-1}¬†\cdot¬†\frac{n-4}{n-2}\cdots¬†\frac{3}{5}\cdot¬†\frac{2}{4}¬†\cdot¬†\frac{1}{3}  =¬†\binom{n}{2}^{-1}\,.   Repeating the contraction algorithm  (Figure)  10 repetitions of the contraction procedure. The 5th repetition finds the minimum cut of size 3.   By repeating the contraction algorithm    T  =    (      n      2      )    ln  n        T     binomial  n  2     n      T={\left({{n}\atop{2}}\right)}\ln n   times with independent random choices and returning the smallest cut, the probability of not finding a minimum cut is         \Bigl[1-\binom{n}{2}^{-1}\Bigr]^T  \leq¬†\frac{1}{e^{\ln¬†n}}¬†=¬†\frac{1}{n}\,.   The total running time for   T   T   T   repetitions for a graph with   n   n   n   vertices and   m   m   m   edges is     O   (   T  m   )    =   O   (    n  2   m   log  n    )          O    T  m      O     superscript  n  2   m    n       O(Tm)=O(n^{2}m\log n)   .  Karger‚ÄìStein algorithm  An extension of Karger‚Äôs algorithm due to David Karger and Clifford Stein achieves an order of magnitude improvement. 5  The basic idea is to perform the contraction procedure until the graph reaches   t   t   t   vertices.   procedure contract(     G  =   (  V  ,  E  )       G   V  E     G=(V,E)    ,    t   t   t    ):   while       |  V  |   >  t        V   t    |V|>t     choose     e  ‚àà  E      e  E    e\in E    uniformly¬†at¬†random       G  ‚Üê   G  /  e      normal-‚Üê  G    G  e     G\leftarrow G/e      return     G   G   G     The probability    p   n  ,  t      subscript  p   n  t     p_{n,t}   that this contraction procedure avoids a specific cut   C   C   C   in an   n   n   n   -vertex graph is               p   n  ,  t    ‚â•    ‚àè   i  =  0    n  -  t  -  1     (   1  -   2   n  -  i     )    =    (      t      2      )   /    (      n      2      )      .         subscript  p   n  t      superscript   subscript  product    i  0      n  t  1      1    2    n  i              binomial  t  2    binomial  n  2       p_{n,t}\geq\prod_{i=0}^{n-t-1}\Bigl(1-\frac{2}{n-i}\Bigr)={\left({{t}\atop{2}}%
 \right)}\Bigg/{\left({{n}\atop{2}}\right)}\,.     This expression is    Œ©   (    t  2   /   n  2    )       normal-Œ©     superscript  t  2    superscript  n  2      \Omega(t^{2}/n^{2})   becomes less than    1  2      1  2    \frac{1}{2}   around    t  =   ‚åà   1  +   n  /   2     ‚åâ       t      1    n    2        t=\lceil 1+n/\sqrt{2}\rceil   . In particular, the probability that an edge from   C   C   C   is contracted grows towards the end. This motivates the idea of switching to a slower algorithm after a certain number of contraction steps.   procedure fastmincut(     G  =   (  V  ,  E  )       G   V  E     G=(V,E)    ):   if       |  V  |   <  6        V   6    |V|<6    :   return mincut(    V   V   V    )   else :       t  ‚Üê   ‚åà   1  +    |  V  |   /   2     ‚åâ      normal-‚Üê  t      1      V     2        t\leftarrow\lceil 1+|V|/\sqrt{2}\rceil          G  1   ‚Üê      normal-‚Üê   subscript  G  1   absent    G_{1}\leftarrow   contract(   G   G   G   ,   t   t   t   )        G  2   ‚Üê      normal-‚Üê   subscript  G  2   absent    G_{2}\leftarrow    contract(    G   G   G    ,    t   t   t    )   return min¬†{fastmincut(     G  1     subscript  G  1    G_{1}    ),¬†fastmincut(     G  2     subscript  G  2    G_{2}    )}  Analysis  The probability    P   (  n  )       P  n    P(n)   the algorithm finds a specific cutset   C   C   C   is given by the recurrence relation         P   (  n  )    =   1  -    (   1  -    1  2   P   (   ‚åà   1  +   n   2     ‚åâ   )     )   2          P  n     1   superscript    1      1  2   P      1    n    2        2      P(n)=1-\left(1-\frac{1}{2}P\left(\Bigl\lceil 1+\frac{n}{\sqrt{2}}\Bigr\rceil%
 \right)\right)^{2}        with solution     P   (  n  )    =   O   (   1   log  n    )          P  n     O    1    n       P(n)=O\left(\frac{1}{\log n}\right)   . The running time of fastmincut satisfies         T   (  n  )    =    2  T   (   ‚åà   1  +   n   2     ‚åâ   )    +   O   (   n  2   )           T  n       2  T      1    n    2         O   superscript  n  2       T(n)=2T\left(\Bigl\lceil 1+\frac{n}{\sqrt{2}}\Bigr\rceil\right)+O(n^{2})        with solution     T   (  n  )    =   O   (    n  2    log  n    )          T  n     O     superscript  n  2     n       T(n)=O(n^{2}\log n)   . To achieve error probability    O   (   1  /  n   )       O    1  n     O(1/n)   , the algorithm can be repeated    O   (    log   n  /  P     (  n  )    )       O        n  P    n     O(\log n/P(n))   times, for an overall running time of      T   (  n  )    ‚ãÖ    log  n    P   (  n  )      =   O   (    n  2     log  3   n    )         normal-‚ãÖ    T  n       n     P  n       O     superscript  n  2     superscript   3   n       T(n)\cdot\frac{\log n}{P(n)}=O(n^{2}\log^{3}n)   . This is an order of magnitude improvement over Karger‚Äôs original algorithm.  Finding all min-cuts  Theorem: With high probability we can find all min cuts in the running time of    O   (    n  2     ln  3   n    )       O     superscript  n  2     superscript   3   n      O(n^{2}\ln^{3}n)   .  Proof: Since we know that     P   (  n  )    =   O   (   1   ln  n    )          P  n     O    1    n       P(n)=O\left(\frac{1}{\ln n}\right)   , therefore after running this algorithm    O   (    ln  2   n   )       O    superscript   2   n     O(\ln^{2}n)   times The probability of missing a specific min-cut is         Pr   [  miss a specific min-cut  ]    =    (   1  -   P   (  n  )     )    O   (    ln  2   n   )     ‚â§    (   1  -   c   ln  n     )     3    ln  2   n    c    ‚â§   e   -   3   ln  n      =   1   n  3           Pr  miss a specific min-cut    superscript    1    P  n      O    superscript   2   n           superscript    1    c    n         3    superscript   2   n    c          superscript  e      3    n             1   superscript  n  3       \Pr[\text{miss a specific min-cut}]=(1-P(n))^{O(\ln^{2}n)}\leq\left(1-\frac{c}%
 {\ln n}\right)^{\frac{3\ln^{2}n}{c}}\leq e^{-3\ln n}=\frac{1}{n^{3}}   .     And there are at most    (      n      2      )     binomial  n  2    {\left({{n}\atop{2}}\right)}   min-cuts, hence the probability of missing any min-cut is          Pr   [  miss any min-cut  ]    ‚â§    (      n      2      )   ‚ãÖ   1   n  3     =   O   (   1  n   )     .         Pr  miss any min-cut    normal-‚ãÖ   binomial  n  2     1   superscript  n  3            O    1  n       \Pr[\text{miss any min-cut}]\leq{\left({{n}\atop{2}}\right)}\cdot\frac{1}{n^{3%
 }}=O\left(\frac{1}{n}\right).        The probability of failures is considerably small when n is large enough.‚àé  Improvement bound  To determine a min-cut, one has to touch every edge in the graph at least once, which is    O   (   n  2   )       O   superscript  n  2     O(n^{2})   time in a dense graph . The Karger‚ÄìStein's min-cut algorithm takes the running time of    O   (    n  2     ln   O   (  1  )     n    )       O     superscript  n  2     superscript     O  1    n      O(n^{2}\ln^{O(1)}n)   , which is very close to that.  References    "  Category:Graph algorithms  Category:Graph connectivity     ‚Ü©  ‚Ü©   . ‚Ü©  ‚Ü©     