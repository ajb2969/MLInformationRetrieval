<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="109">Generalized lifting</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Generalized lifting</h1>
<hr/>
<figure><b>(Figure)</b>
<figcaption>The (forward) Lifting Scheme transform block diagram.</figcaption>
</figure>

<p><strong>Generalized lifting scheme</strong> was developed by <a href="https://imatge.upc.edu/web/people/joel-sole">Joel Solé</a> and <a href="https://imatge.upc.edu/web/people/philippe-salembier">Philippe Salembier</a> and published in Joel's PhD Thesis.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> It is based on classical <a href="lifting_scheme" title="wikilink">lifting scheme</a> and generalizes it breaking out a restriction hidden in the scheme structure. Classical lifting scheme has three kind of operations.</p>
<ol>
<li><strong>Lazy wavelet transform</strong> splits signal 

<math display="inline" id="Generalized_lifting:0">
 <semantics>
  <mrow>
   <msub>
    <mi>f</mi>
    <mi>j</mi>
   </msub>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>n</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>f</ci>
     <ci>j</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{j}[n]
  </annotation>
 </semantics>
</math>

 in two new signals: the odd samples signal denoted by 

<math display="inline" id="Generalized_lifting:1">
 <semantics>
  <mrow>
   <msubsup>
    <mi>f</mi>
    <mi>j</mi>
    <mi>o</mi>
   </msubsup>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>n</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <ci>j</ci>
     </apply>
     <ci>o</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{j}^{o}[n]
  </annotation>
 </semantics>
</math>

 and the even samples signal denoted by 

<math display="inline" id="Generalized_lifting:2">
 <semantics>
  <mrow>
   <msubsup>
    <mi>f</mi>
    <mi>j</mi>
    <mi>e</mi>
   </msubsup>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>n</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <ci>j</ci>
     </apply>
     <ci>e</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{j}^{e}[n]
  </annotation>
 </semantics>
</math>

.</li>
<li><strong>Prediction step</strong> its objective is compute a prediction for the odd samples, based on the even samples (or vice versa). This prediction is subtracted from the odd samples creating an error signal 

<math display="inline" id="Generalized_lifting:3">
 <semantics>
  <mrow>
   <msub>
    <mi>g</mi>
    <mrow>
     <mi>j</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>n</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>g</ci>
     <apply>
      <plus></plus>
      <ci>j</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g_{j+1}[n]
  </annotation>
 </semantics>
</math>


.</li>
<li><strong>Update step</strong> This step recalibrates the low frequency branch with some of the energy removed during subsampling. In the case of classical Lifting, this is used in order to "prepare" the signal for the next prediction step. It uses the predicted odd samples 

<math display="inline" id="Generalized_lifting:4">
 <semantics>
  <mrow>
   <msub>
    <mi>g</mi>
    <mrow>
     <mi>j</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>n</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>g</ci>
     <apply>
      <plus></plus>
      <ci>j</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g_{j+1}[n]
  </annotation>
 </semantics>
</math>

 to prepare the even ones 

<math display="inline" id="Generalized_lifting:5">
 <semantics>
  <mrow>
   <msubsup>
    <mi>f</mi>
    <mi>j</mi>
    <mi>e</mi>
   </msubsup>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>n</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <ci>j</ci>
     </apply>
     <ci>e</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{j}^{e}[n]
  </annotation>
 </semantics>
</math>

 (or vice versa). This update is subtracted from the even samples producing the signal denoted by 

<math display="inline" id="Generalized_lifting:6">
 <semantics>
  <mrow>
   <msub>
    <mi>f</mi>
    <mrow>
     <mi>j</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>n</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>f</ci>
     <apply>
      <plus></plus>
      <ci>j</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{j+1}[n]
  </annotation>
 </semantics>
</math>

.</li>
</ol>

<p>The scheme is invertible due to the structure of itself. In the <a href="Receiver_(information_theory)" title="wikilink">receiver</a> the update step is computed first. Its result is added to the even samples. After that, it's possible to compute exactly the same prediction and add it to the odd samples. In order to recover the original signal, we have to invert the Lazy Wavelet Transform. Generalized lifting scheme has the same three kind of operations. However this scheme avoids the addition-subtraction restriction that offered Classical Lifting. That fact has some consequences. For example, the design of all steps must guarantee the scheme invertibility (not guaranteed if the addition-subtraction restriction is avoided).</p>
<h2 id="definition">Definition</h2>
<figure><b>(Figure)</b>
<figcaption>The (forward) Generalized Lifting Scheme transform block diagram.</figcaption>
</figure>

<p><em>Generalized lifting scheme</em> is a dyadic transform that follows the next rules:</p>
<ol>
<li>Computes a <strong>Lazy Wavelet Transform</strong> and splits even samples from odd samples.</li>
<li>Computes a <strong>Prediction <a href="Map_(mathematics)" title="wikilink">Mapping</a></strong>. This step tries to predict odd samples taking into account the even ones (or vice versa). This a mapping from the space of the samples in 

<math display="inline" id="Generalized_lifting:7">
 <semantics>
  <mrow>
   <msubsup>
    <mi>f</mi>
    <mi>j</mi>
    <mi>e</mi>
   </msubsup>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>n</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <ci>j</ci>
     </apply>
     <ci>e</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{j}^{e}[n]
  </annotation>
 </semantics>
</math>

 to the space of the samples in 

<math display="inline" id="Generalized_lifting:8">
 <semantics>
  <mrow>
   <msub>
    <mi>g</mi>
    <mrow>
     <mi>j</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>n</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>g</ci>
     <apply>
      <plus></plus>
      <ci>j</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g_{j+1}[n]
  </annotation>
 </semantics>
</math>


. In this case the samples (from 

<math display="inline" id="Generalized_lifting:9">
 <semantics>
  <mrow>
   <msubsup>
    <mi>f</mi>
    <mi>j</mi>
    <mi>e</mi>
   </msubsup>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>n</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <ci>j</ci>
     </apply>
     <ci>e</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{j}^{e}[n]
  </annotation>
 </semantics>
</math>

) chosen to be the reference for 

<math display="inline" id="Generalized_lifting:10">
 <semantics>
  <mrow>
   <msubsup>
    <mi>f</mi>
    <mi>j</mi>
    <mi>o</mi>
   </msubsup>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>n</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <ci>j</ci>
     </apply>
     <ci>o</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{j}^{o}[n]
  </annotation>
 </semantics>
</math>

 are called <strong>the context</strong>. It could be expressed as:

<p>

<math display="block" id="Generalized_lifting:11">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>g</mi>
     <mrow>
      <mi>j</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>n</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msubsup>
       <mi>f</mi>
       <mi>j</mi>
       <mi>o</mi>
      </msubsup>
      <mrow>
       <mo stretchy="false">[</mo>
       <mi>n</mi>
       <mo stretchy="false">]</mo>
      </mrow>
     </mrow>
     <mo>;</mo>
     <mrow>
      <msubsup>
       <mi>f</mi>
       <mi>j</mi>
       <mi>e</mi>
      </msubsup>
      <mrow>
       <mo stretchy="false">[</mo>
       <mi>n</mi>
       <mo stretchy="false">]</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>g</ci>
      <apply>
       <plus></plus>
       <ci>j</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>P</ci>
     <list>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>f</ci>
         <ci>j</ci>
        </apply>
        <ci>o</ci>
       </apply>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <ci>n</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>f</ci>
         <ci>j</ci>
        </apply>
        <ci>e</ci>
       </apply>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <ci>n</ci>
       </apply>
      </apply>
     </list>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle g_{j+1}[n]=P(f_{j}^{o}[n];f_{j}^{e}[n])
  </annotation>
 </semantics>
</math>

</p></li>
<li>Computes an <strong>Update Mapping</strong>. This step tries to update the even samples taking into account the odd predicted samples. It would be a kind of preparation for the next prediction step, if any. It could be expressed:

<p>

<math display="block" id="Generalized_lifting:12">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>f</mi>
     <mrow>
      <mi>j</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>n</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>U</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msubsup>
       <mi>f</mi>
       <mi>j</mi>
       <mi>e</mi>
      </msubsup>
      <mrow>
       <mo stretchy="false">[</mo>
       <mi>n</mi>
       <mo stretchy="false">]</mo>
      </mrow>
     </mrow>
     <mo>;</mo>
     <mrow>
      <msub>
       <mi>f</mi>
       <mrow>
        <mi>j</mi>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
      </msub>
      <mrow>
       <mo stretchy="false">[</mo>
       <mi>n</mi>
       <mo stretchy="false">]</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <apply>
       <plus></plus>
       <ci>j</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>U</ci>
     <list>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>f</ci>
         <ci>j</ci>
        </apply>
        <ci>e</ci>
       </apply>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <ci>n</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>f</ci>
        <apply>
         <plus></plus>
         <ci>j</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <ci>n</ci>
       </apply>
      </apply>
     </list>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle f_{j+1}[n]=U(f_{j}^{e}[n];f_{j+1}[n])
  </annotation>
 </semantics>
</math>

</p></li>
</ol>

<p>Obviously, these mapping cannot be any function. In order to guarantee the invertibility of the scheme itself, all mapping involved in the transform, must be invertible. In case that mappings arise and arrive on finite sets (discrete bounded value signals), this condition is equivalent to say that mappings are <a href="Injective_function" title="wikilink">injective</a> (one-to-one). Moreover, if mapping goes from one set to a set of the same cardinality, it should be <a href="Bijection" title="wikilink">bijective</a>.</p>

<p>In the Generalized Lifting Scheme the addition/subtraction restriction is avoided by including this step in the mapping. In this way the Classical Lifting Scheme is generalized.</p>
<h2 id="design">Design</h2>

<p>Nowadays, it has been developed some designs for the prediction step mapping. The update step design is not considered at the moment, because there isn't any answers for the question: <em>what does the update step is useful for?</em>. The main application of this technique is the image compression. There some interesting references such as,<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a><a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a><a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> and.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>
<h2 id="references">References</h2>

<p>"</p>

<p><a class="uri" href="Category:Wavelets" title="wikilink">Category:Wavelets</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Ph.D. Thesis Dissertation: <strong>Optimization and Generalization of Lifting Schemes: Application to Lossless Image Compression</strong><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
</ol>
</section>
</body>
</html>
