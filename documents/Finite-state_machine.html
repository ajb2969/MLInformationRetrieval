<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="388">Finite-state machine</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Finite-state machine</h1>
<hr/>

<p>A <strong>finite-state machine</strong> (<strong>FSM</strong>) or <strong>finite-state automaton</strong> (plural: <em>automata</em>), or simply a <strong>state machine</strong>, is a mathematical <a href="model_of_computation" title="wikilink">model of computation</a> used to design both <a href="computer_programs" title="wikilink">computer programs</a> and <a href="sequential_logic" title="wikilink">sequential logic</a> circuits. It is conceived as an <a href="abstract_machine" title="wikilink">abstract machine</a> that can be in one of a finite number of <em><a href="state_(computer_science)" title="wikilink">states</a></em>. The machine is in only one state at a time; the state it is in at any given time is called the <em>current state</em>. It can change from one state to another when initiated by a triggering event or condition; this is called a <em>transition</em>. A particular FSM is defined by a list of its states, and the triggering condition for each transition.</p>

<p>The behavior of state machines can be observed in many devices in modern society which perform a predetermined sequence of actions depending on a sequence of events with which they are presented. Simple examples are <a href="vending_machine" title="wikilink">vending machines</a> which dispense products when the proper combination of coins is deposited, <a href="elevator" title="wikilink">elevators</a> which drop riders off at upper floors before going down, <a href="traffic_light" title="wikilink">traffic lights</a> which change sequence when cars are waiting, and <a href="combination_lock" title="wikilink">combination locks</a> which require the input of combination numbers in the proper order.</p>

<p>Finite-state machines can model a large number of problems, among which are <a href="electronic_design_automation" title="wikilink">electronic design automation</a>, <a href="communication_protocol" title="wikilink">communication protocol</a> design, language <a class="uri" href="parsing" title="wikilink">parsing</a> and other engineering applications. In <a class="uri" href="biology" title="wikilink">biology</a> and <a href="artificial_intelligence" title="wikilink">artificial intelligence</a> research, state machines or hierarchies of state machines have been used to describe <a href="neurology" title="wikilink">neurological systems</a>. In <a class="uri" href="linguistics" title="wikilink">linguistics</a>, they are used to describe simple parts of the <a href="grammar" title="wikilink">grammars</a> of natural <a class="uri" href="languages" title="wikilink">languages</a>.</p>

<p>Considered as an abstract model of computation, the finite state machine is weak; it has less computational power than some other models of computation such as the <a href="Turing_machine" title="wikilink">Turing machine</a>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> That is, there are tasks which no FSM can do, but some Turing machines can. This is because the FSM <a href="Computer_memory" title="wikilink">memory</a> is limited by the number of states.</p>

<p>FSMs are studied in the more general field of <a href="automata_theory" title="wikilink">automata theory</a>.</p>
<h2 id="example-coin-operated-turnstile">Example: coin-operated turnstile</h2>

<p><a href="Image:Turnstile_state_machine_colored.svg" title="wikilink">thumb|upright=1.5|State diagram for a turnstile</a> <a href="Image:Torniqueterevolution.jpg" title="wikilink">thumb|upright=0.5|A turnstile</a> An example of a very simple mechanism that can be modeled by a state machine is a <a class="uri" href="turnstile" title="wikilink">turnstile</a>.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a><a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> A turnstile, used to control access to subways and amusement park rides, is a gate with three rotating arms at waist height, one across the entryway. Initially the arms are locked, barring the entry, preventing customers from passing through. Depositing a coin or <a href="Token_coin" title="wikilink">token</a> in a slot on the turnstile unlocks the arms, allowing a single customer to push through. After the customer passes through, the arms are locked again until another coin is inserted.</p>

<p>Considered as a state machine, the turnstile has two states: <strong><em>Locked</em></strong> and <strong><em>Unlocked<strong><em>.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> There are two inputs that affect its state: putting a coin in the slot (</em></strong>coin<strong><em>) and pushing the arm (</em></strong>push</em></strong>). In the locked state, pushing on the arm has no effect; no matter how many times the input <strong><em>push</em></strong> is given, it stays in the locked state. Putting a coin in – that is, giving the machine a <strong><em>coin</em></strong> input – shifts the state from <strong><em>Locked</em></strong> to <strong><em>Unlocked</em></strong>. In the unlocked state, putting additional coins in has no effect; that is, giving additional <strong><em>coin</em></strong> inputs does not change the state. However, a customer pushing through the arms, giving a <strong><em>push</em></strong> input, shifts the state back to <strong><em>Locked</em></strong>.</p>

<p>The turnstile state machine can be represented by a <a href="state_transition_table" title="wikilink">state transition table</a>, showing for each state the new state and the output (action) resulting from each input</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>Current State</p></th>
<th style="text-align: left;">
<p>Input</p></th>
<th style="text-align: left;">
<p>Next State</p></th>
<th style="text-align: left;">
<p>Output</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>rowspan="2" Locked</p></td>
<td style="text-align: left;">
<p>coin</p></td>
<td style="text-align: left;">
<p>Unlocked</p></td>
<td style="text-align: left;">
<p>Unlock turnstile so customer can push through</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>push</p></td>
<td style="text-align: left;">
<p>Locked</p></td>
<td style="text-align: left;">
<p>None</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>rowspan="2" Unlocked</p></td>
<td style="text-align: left;">
<p>coin</p></td>
<td style="text-align: left;">
<p>Unlocked</p></td>
<td style="text-align: left;">
<p>None</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>push</p></td>
<td style="text-align: left;">
<p>Locked</p></td>
<td style="text-align: left;">
<p>When customer has pushed through, lock turnstile</p></td>
</tr>
</tbody>
</table>

<p>It can also be represented by a <a href="directed_graph" title="wikilink">directed graph</a> called a <a href="state_diagram" title="wikilink">state diagram</a> <em>(above)</em>. Each of the states is represented by a <a href="node_(graph_theory)" title="wikilink">node</a> (<em>circle</em>). Edges (<em>arrows</em>) show the transitions from one state to another. Each arrow is labeled with the input that triggers that transition. Inputs that don't cause a change of state (such as a <strong><em>coin</em></strong> input in the <strong><em>Unlocked</em></strong> state) are represented by a circular arrow returning to the original state. The arrow into the <strong><em>Locked</em></strong> node from the black dot indicates it is the initial state.</p>
<h2 id="concepts-and-terminology">Concepts and terminology</h2>

<p>A <em>state</em> is a description of the status of a system that is waiting to execute a <em>transition</em>. A transition is a set of actions to be executed when a condition is fulfilled or when an event is received. For example, when using an audio system to listen to the radio (the system is in the "radio" state), receiving a "next" stimulus results in moving to the next station. When the system is in the "CD" state, the "next" stimulus results in moving to the next track. Identical stimuli trigger different actions depending on the current state.</p>

<p>In some finite-state machine representations, it is also possible to associate actions with a state:</p>
<ul>
<li>Entry action: performed <em>when entering</em> the state,</li>
<li>Exit action: performed <em>when exiting</em> the state.</li>
</ul>
<h2 id="representations">Representations</h2>

<p> </p>
<h3 id="stateevent-table">State/Event table</h3>

<p>Several <a href="state_transition_table" title="wikilink">state transition table</a> types are used. The most common representation is shown below: the combination of current state (e.g. B) and input (e.g. Y) shows the next state (e.g. C). The complete action's information is not directly described in the table and can only be added using footnotes. A FSM definition including the full actions information is possible using <a href="Virtual_finite_state_machine#State_Table" title="wikilink">state tables</a> (see also <a href="virtual_finite-state_machine" title="wikilink">virtual finite-state machine</a>).</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>State transition table</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Current state →<br/>
 Input ↓</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>Input X</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Input Y</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>Input Z</p></td>
</tr>
</tbody>
</table>
<h3 id="uml-state-machines">UML state machines</h3>

<p>The <a href="Unified_Modeling_Language" title="wikilink">Unified Modeling Language</a> has a notation for describing state machines. <a href="UML_state_machine" title="wikilink">UML state machines</a> overcome the limitations of traditional finite state machines while retaining their main benefits. UML state machines introduce the new concepts of <a href="UML_state_machine#Hierarchically_nested_states" title="wikilink">hierarchically nested states</a> and <a href="UML_state_machine#Orthogonal_regions" title="wikilink">orthogonal regions</a>, while extending the notion of <a href="UML_state_machine#Actions_and_transitions" title="wikilink">actions</a>. UML state machines have the characteristics of both <a href="Mealy_machine" title="wikilink">Mealy machines</a> and <a href="Moore_machine" title="wikilink">Moore machines</a>. They support <a href="UML_state_machine#Actions_and_transitions" title="wikilink">actions</a> that depend on both the state of the system and the triggering <a href="UML_state_machine#Events" title="wikilink">event</a>, as in Mealy machines, as well as <a href="UML_state_machine#Entry_and_exit_actions" title="wikilink">entry and exit actions</a>, which are associated with states rather than transitions, as in Moore machines.</p>
<h3 id="sdl-state-machines">SDL state machines</h3>

<p>The <a href="Specification_and_Description_Language" title="wikilink">Specification and Description Language</a> is a standard from <a class="uri" href="ITU" title="wikilink">ITU</a> which includes graphical symbols to describe actions in the transition:</p>
<ul>
<li>send an event</li>
<li>receive an event</li>
<li>start a timer</li>
<li>cancel a timer</li>
<li>start another concurrent state machine</li>
<li>decision</li>
</ul>

<p>SDL embeds basic data types called Abstract Data Types, an action language, and an execution semantic in order to make the finite state machine executable.</p>
<h3 id="other-state-diagrams">Other state diagrams</h3>

<p>There are a large number of variants to represent an FSM such as the one in figure 3.</p>
<h2 id="usage">Usage</h2>

<p>In addition to their use in modeling <a href="reactive_system" title="wikilink">reactive systems</a> presented here, finite state automata are significant in many different areas, including <a href="electrical_engineering" title="wikilink">electrical engineering</a>, <a class="uri" href="linguistics" title="wikilink">linguistics</a>, <a href="computer_science" title="wikilink">computer science</a>, <a class="uri" href="philosophy" title="wikilink">philosophy</a>, <a class="uri" href="biology" title="wikilink">biology</a>, <a href="mathematic" title="wikilink">mathematics</a>, and <a class="uri" href="logic" title="wikilink">logic</a>. Finite state machines are a class of automata studied in <a href="automata_theory" title="wikilink">automata theory</a> and the <a href="theory_of_computation" title="wikilink">theory of computation</a>. In computer science, finite state machines are widely used in modeling of application behavior, design of <a href="Digital_electronics" title="wikilink">hardware digital systems</a>, <a href="software_engineering" title="wikilink">software engineering</a>, <a href="compiler" title="wikilink">compilers</a>, <a href="network_protocol" title="wikilink">network protocols</a>, and the study of computation and languages.</p>
<h2 id="classification">Classification</h2>

<p>The state machines can be subdivided into Transducers, Acceptors, Classifiers and Sequencers.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>
<h3 id="acceptors-and-recognizers">Acceptors and recognizers</h3>
<figure><b>(Figure)</b>
<figcaption>Fig. 4 Acceptor FSM: parsing the string "nice"</figcaption>
</figure>

<p><strong>Acceptors</strong> (also <strong>recognizers</strong> and <strong>sequence detectors</strong>) produce a binary output, saying either <em>yes</em> or <em>no</em> to answer whether the input is accepted by the machine or not. All states of the FSM are said to be either accepting or not accepting. At the time when all input is processed, if the current state is an accepting state, the input is accepted; otherwise it is rejected. As a rule the input are symbols (characters); actions are not used. The example in figure 4 shows a finite state machine which accepts the string "nice". In this FSM the only accepting state is number 7.</p>

<p>The machine can also be described as defining a language, which would contain every string accepted by the machine but none of the rejected ones; we say then that the language is <em>accepted</em> by the machine. By definition, the languages accepted by FSMs are the <a href="regular_language" title="wikilink">regular languages</a>—that is, a language is regular if there is some FSM that accepts it.</p>

<p>The problem of determining the language accepted by a given FSA is an instance of the <a href="algebraic_path_problem" title="wikilink">algebraic path problem</a>—itself a generalization of the <a href="shortest_path_problem" title="wikilink">shortest path problem</a> to graphs with edges weighted by the elements of an (arbitrary) <a class="uri" href="semiring" title="wikilink">semiring</a>.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a><a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a><a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></p>
<h4 id="start-state">Start state</h4>

<p>The start state is usually shown drawn with an arrow "pointing at it from any where" (Sipser (2006) p. 34).</p>
<h4 id="accept-or-final-states">Accept (or final) states</h4>
<figure><b>(Figure)</b>
<figcaption>Fig. 5: Representation of a finite-state machine; this example shows one that determines whether a binary number has an even number of 0s, where 

<math display="inline" id="Finite-state_machine:0">
 <semantics>
  <msub>
   <mi>S</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>S</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{1}
  </annotation>
 </semantics>
</math>

 is an <strong>accepting state</strong>.</figcaption>
</figure>

<p><strong>Accept states</strong> (also referred to as <strong>accepting</strong> or <strong>final</strong> states) are those at which the machine reports that the input string, as processed so far, is a member of the language it accepts. It is usually represented by a double circle.</p>

<p>The start state can also be a final state, in which case the automaton accepts the empty string. If the start state is not an accepting state and there are no connecting edges to any of the accepting states, then the automaton is accepting nothing.</p>

<p>An example of an accepting state appears in Fig.5: a <a href="deterministic_finite_automaton" title="wikilink">deterministic finite automaton</a> (DFA) that detects whether the <a href="Binary_numeral_system" title="wikilink">binary</a> input string contains an even number of 0s.</p>

<p><em>S</em><sub>1</sub> (which is also the start state) indicates the state at which an even number of 0s has been input. S<sub>1</sub> is therefore an accepting state. This machine will finish in an accept state, if the binary string contains an even number of 0s (including any binary string containing no 0s). Examples of strings accepted by this DFA are <a class="uri" href="ε" title="wikilink">ε</a> (the <a href="empty_string" title="wikilink">empty string</a>), 1, 11, 11..., 00, 010, 1010, 10110, etc...</p>

<p><strong>Classifier</strong> is a generalization that, similar to acceptor, produces single output when terminates but has more than two terminal states.</p>
<h3 id="transducers">Transducers</h3>

<p><a href="Finite_state_transducer" title="wikilink">Transducers</a> generate output based on a given input and/or a state using actions. They are used for control applications and in the field of <a href="computational_linguistics" title="wikilink">computational linguistics</a>.</p>

<p>In control applications, two types are distinguished:</p>
<dl>
<dt><a href="Moore_machine" title="wikilink">Moore machine</a>: The FSM uses only entry actions, i.e., output depends only on the state. The advantage of the Moore model is a simplification of the behaviour. Consider an elevator door. The state machine recognizes two commands: "command_open" and "command_close" which trigger state changes. The entry action (E:) in state "Opening" starts a motor opening the door, the entry action in state "Closing" starts a motor in the other direction closing the door. States "Opened" and "Closed" stop the motor when fully opened or closed. They signal to the outside world (e.g., to other state machines) the situation: "door is open" or "door is closed".</dt>
</dl>
<figure><b>(Figure)</b>
<figcaption>Fig. 7 Transducer FSM: Mealy model example</figcaption>
</figure>
<dl>
<dt><a href="Mealy_machine" title="wikilink">Mealy machine</a>: The FSM uses only input actions, i.e., output depends on input and state. The use of a Mealy FSM leads often to a reduction of the number of states. The example in figure 7 shows a Mealy FSM implementing the same behaviour as in the Moore example (the behaviour depends on the implemented FSM execution model and will work, e.g., for <a href="Virtual_finite_state_machine" title="wikilink">virtual FSM</a> but not for <a href="event_driven_finite_state_machine" title="wikilink">event driven FSM</a>). There are two input actions (I:): "start motor to close the door if command_close arrives" and "start motor in the other direction to open the door if command_open arrives". The "opening" and "closing" intermediate states are not shown.</dt>
</dl>
<h3 id="generators">Generators</h3>

<p>The <strong>sequencers</strong> or <strong>generators</strong> are a subclass of aforementioned types that have a <a href="Arity#Nullary" title="wikilink">single-letter input alphabet</a>. They produce only one sequence, which can be interpreted as output sequence of transducer or classifier outputs.</p>
<h3 id="determinism">Determinism</h3>

<p>A further distinction is between <strong>deterministic</strong> (<a href="Deterministic_finite_state_machine" title="wikilink">DFA</a>) and <strong>non-deterministic</strong> (<a href="Nondeterministic_finite_automaton" title="wikilink">NFA</a>, <a class="uri" href="GNFA" title="wikilink">GNFA</a>) automata. In deterministic automata, every state has exactly one transition for each possible input. In non-deterministic automata, an input can lead to one, more than one or no transition for a given state. This distinction is relevant in practice, but not in theory, as there exists an algorithm (the <a href="powerset_construction" title="wikilink">powerset construction</a>) which can transform any NFA into a more complex DFA with identical functionality.</p>

<p>The FSM with only one state is called a combinatorial FSM and uses only input actions. This concept is useful in cases where a number of FSM are required to work together, and where it is convenient to consider a purely combinatorial part as a form of FSM to suit the design tools.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></p>
<h2 id="alternative-semantics">Alternative semantics</h2>

<p>There are other sets of semantics available to represent state machines. For example, there are tools for modeling and designing logic for embedded controllers.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> They combine <a href="UML_state_machine#Hierarchically_nested_states" title="wikilink">hierarchical state machines</a>, flow graphs, and <a href="truth_table" title="wikilink">truth tables</a> into one language, resulting in a different formalism and set of semantics.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> Figure 8 illustrates this mix of state machines and flow graphs with a set of states to represent the state of a stopwatch and a flow graph to control the ticks of the watch. These charts, like Harel's original state machines,<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> support hierarchically nested states, <a href="UML_state_machine#Orthogonal_regions" title="wikilink">orthogonal regions</a>, state actions, and transition actions.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a></p>
<h2 id="fsm-logic">FSM logic</h2>
<figure><b>(Figure)</b>
<figcaption>Fig. 8 FSM Logic (Mealy)</figcaption>
</figure>

<p>The next state and output of an FSM is a function of the input and of the current state. The FSM logic is shown in Figure 8.</p>
<h2 id="mathematical-model">Mathematical model</h2>

<p>In accordance with the general classification, the following formal definitions are found:</p>
<ul>
<li>A <em>deterministic finite state machine</em> or <em>acceptor deterministic finite state machine</em> is a <a href="Tuple" title="wikilink">quintuple</a> 

<math display="inline" id="Finite-state_machine:1">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi mathvariant="normal">Σ</mi>
   <mo>,</mo>
   <mi>S</mi>
   <mo>,</mo>
   <msub>
    <mi>s</mi>
    <mn>0</mn>
   </msub>
   <mo>,</mo>
   <mi>δ</mi>
   <mo>,</mo>
   <mi>F</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <ci>normal-Σ</ci>
    <ci>S</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>s</ci>
     <cn type="integer">0</cn>
    </apply>
    <ci>δ</ci>
    <ci>F</ci>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\Sigma,S,s_{0},\delta,F)
  </annotation>
 </semantics>
</math>

, where:
<ul>
<li>

<math display="inline" id="Finite-state_machine:2">
 <semantics>
  <mi mathvariant="normal">Σ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma
  </annotation>
 </semantics>
</math>

 is the input <a href="alphabet_(computer_science)" title="wikilink">alphabet</a> (a finite, non-empty set of symbols).</li>
<li>

<math display="inline" id="Finite-state_machine:3">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 is a finite, non-empty set of states.</li>
<li>

<math display="inline" id="Finite-state_machine:4">
 <semantics>
  <msub>
   <mi>s</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>s</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s_{0}
  </annotation>
 </semantics>
</math>

 is an initial state, an element of 

<math display="inline" id="Finite-state_machine:5">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

.</li>
<li>

<math display="inline" id="Finite-state_machine:6">
 <semantics>
  <mi>δ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>δ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta
  </annotation>
 </semantics>
</math>

 is the state-transition function

<math display="block" id="Finite-state_machine:7">
 <semantics>
  <mrow>
   <mi>δ</mi>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mi>S</mi>
     <mo>×</mo>
     <mi mathvariant="normal">Σ</mi>
    </mrow>
    <mo>→</mo>
    <mi>S</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>δ</ci>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <times></times>
      <ci>S</ci>
      <ci>normal-Σ</ci>
     </apply>
     <ci>S</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta:S\times\Sigma\rightarrow S
  </annotation>
 </semantics>
</math>

 (in a <a href="nondeterministic_finite_automaton" title="wikilink">nondeterministic finite automaton</a> it would be 

<math display="inline" id="Finite-state_machine:8">
 <semantics>
  <mrow>
   <mi>δ</mi>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mi>S</mi>
     <mo>×</mo>
     <mi mathvariant="normal">Σ</mi>
    </mrow>
    <mo>→</mo>
    <mrow>
     <mi class="ltx_font_mathcaligraphic">𝒫</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>S</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>δ</ci>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <times></times>
      <ci>S</ci>
      <ci>normal-Σ</ci>
     </apply>
     <apply>
      <times></times>
      <ci>𝒫</ci>
      <ci>S</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta:S\times\Sigma\rightarrow\mathcal{P}(S)
  </annotation>
 </semantics>
</math>

, i.e., 

<math display="inline" id="Finite-state_machine:9">
 <semantics>
  <mi>δ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>δ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta
  </annotation>
 </semantics>
</math>

 would return a set of states).</li>
<li>

<math display="inline" id="Finite-state_machine:10">
 <semantics>
  <mi>F</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>F</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F
  </annotation>
 </semantics>
</math>

 is the set of final states, a (possibly empty) subset of 

<math display="inline" id="Finite-state_machine:11">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

.</li>
</ul></li>
</ul>

<p>For both deterministic and non-deterministic FSMs, it is conventional to allow 

<math display="inline" id="Finite-state_machine:12">
 <semantics>
  <mi>δ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>δ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta
  </annotation>
 </semantics>
</math>

 to be a <a href="partial_function" title="wikilink">partial function</a>, i.e. 

<math display="inline" id="Finite-state_machine:13">
 <semantics>
  <mrow>
   <mi>δ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>q</mi>
    <mo>,</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>δ</ci>
    <interval closure="open">
     <ci>q</ci>
     <ci>x</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta(q,x)
  </annotation>
 </semantics>
</math>

 does not have to be defined for every combination of 

<math display="inline" id="Finite-state_machine:14">
 <semantics>
  <mrow>
   <mi>q</mi>
   <merror class="ltx_ERROR undefined undefined">
    <mtext>\isin</mtext>
   </merror>
   <mi>S</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>q</ci>
    <mtext>\isin</mtext>
    <ci>S</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q\isin S
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Finite-state_machine:15">
 <semantics>
  <mrow>
   <mi>x</mi>
   <merror class="ltx_ERROR undefined undefined">
    <mtext>\isin</mtext>
   </merror>
   <mi mathvariant="normal">Σ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>x</ci>
    <mtext>\isin</mtext>
    <ci>normal-Σ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\isin\Sigma
  </annotation>
 </semantics>
</math>

. If an FSM 

<math display="inline" id="Finite-state_machine:16">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 is in a state 

<math display="inline" id="Finite-state_machine:17">
 <semantics>
  <mi>q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q
  </annotation>
 </semantics>
</math>

, the next symbol is 

<math display="inline" id="Finite-state_machine:18">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Finite-state_machine:19">
 <semantics>
  <mrow>
   <mi>δ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>q</mi>
    <mo>,</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>δ</ci>
    <interval closure="open">
     <ci>q</ci>
     <ci>x</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta(q,x)
  </annotation>
 </semantics>
</math>

 is not defined, then 

<math display="inline" id="Finite-state_machine:20">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 can announce an error (i.e. reject the input). This is useful in definitions of general state machines, but less useful when transforming the machine. Some algorithms in their default form may require total functions.</p>

<p>A finite-state machine is a restricted <a href="Turing_machine" title="wikilink">Turing machine</a> where the head can only perform "read" operations, and always moves from left to right.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a></p>
<ul>
<li>A <em><a href="finite_state_transducer" title="wikilink">finite state transducer</a></em> is a <a class="uri" href="sextuple" title="wikilink">sextuple</a> 

<math display="inline" id="Finite-state_machine:21">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi mathvariant="normal">Σ</mi>
   <mo>,</mo>
   <mi mathvariant="normal">Γ</mi>
   <mo>,</mo>
   <mi>S</mi>
   <mo>,</mo>
   <msub>
    <mi>s</mi>
    <mn>0</mn>
   </msub>
   <mo>,</mo>
   <mi>δ</mi>
   <mo>,</mo>
   <mi>ω</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <ci>normal-Σ</ci>
    <ci>normal-Γ</ci>
    <ci>S</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>s</ci>
     <cn type="integer">0</cn>
    </apply>
    <ci>δ</ci>
    <ci>ω</ci>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\Sigma,\Gamma,S,s_{0},\delta,\omega)
  </annotation>
 </semantics>
</math>

, where:
<ul>
<li>

<math display="inline" id="Finite-state_machine:22">
 <semantics>
  <mi mathvariant="normal">Σ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma
  </annotation>
 </semantics>
</math>

 is the input <a href="alphabet_(computer_science)" title="wikilink">alphabet</a> (a finite non-empty set of symbols).</li>
<li>

<math display="inline" id="Finite-state_machine:23">
 <semantics>
  <mi mathvariant="normal">Γ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Γ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Gamma
  </annotation>
 </semantics>
</math>

 is the output alphabet (a finite, non-empty set of symbols).</li>
<li>

<math display="inline" id="Finite-state_machine:24">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 is a finite, non-empty set of states.</li>
<li>

<math display="inline" id="Finite-state_machine:25">
 <semantics>
  <msub>
   <mi>s</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>s</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s_{0}
  </annotation>
 </semantics>
</math>

 is the initial state, an element of 

<math display="inline" id="Finite-state_machine:26">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

. In a <a href="nondeterministic_finite_automaton" title="wikilink">nondeterministic finite automaton</a>, 

<math display="inline" id="Finite-state_machine:27">
 <semantics>
  <msub>
   <mi>s</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>s</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s_{0}
  </annotation>
 </semantics>
</math>

 is a set of initial states.</li>
<li>

<math display="inline" id="Finite-state_machine:28">
 <semantics>
  <mi>δ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>δ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta
  </annotation>
 </semantics>
</math>

 is the state-transition function

<math display="block" id="Finite-state_machine:29">
 <semantics>
  <mrow>
   <mi>δ</mi>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mi>S</mi>
     <mo>×</mo>
     <mi mathvariant="normal">Σ</mi>
    </mrow>
    <mo>→</mo>
    <mi>S</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>δ</ci>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <times></times>
      <ci>S</ci>
      <ci>normal-Σ</ci>
     </apply>
     <ci>S</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta:S\times\Sigma\rightarrow S
  </annotation>
 </semantics>
</math>

.</li>
<li>

<math display="inline" id="Finite-state_machine:30">
 <semantics>
  <mi>ω</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ω</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \omega
  </annotation>
 </semantics>
</math>

 is the output function.</li>
</ul></li>
</ul>

<p>If the output function is a function of a state and input alphabet (

<math display="inline" id="Finite-state_machine:31">
 <semantics>
  <mrow>
   <mi>ω</mi>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mi>S</mi>
     <mo>×</mo>
     <mi mathvariant="normal">Σ</mi>
    </mrow>
    <mo>→</mo>
    <mi mathvariant="normal">Γ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>ω</ci>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <times></times>
      <ci>S</ci>
      <ci>normal-Σ</ci>
     </apply>
     <ci>normal-Γ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \omega:S\times\Sigma\rightarrow\Gamma
  </annotation>
 </semantics>
</math>

) that definition corresponds to the <strong>Mealy model</strong>, and can be modelled as a <a href="Mealy_machine" title="wikilink">Mealy machine</a>. If the output function depends only on a state (

<math display="inline" id="Finite-state_machine:32">
 <semantics>
  <mrow>
   <mi>ω</mi>
   <mo>:</mo>
   <mrow>
    <mi>S</mi>
    <mo>→</mo>
    <mi mathvariant="normal">Γ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>ω</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>S</ci>
     <ci>normal-Γ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \omega:S\rightarrow\Gamma
  </annotation>
 </semantics>
</math>

) that definition corresponds to the <strong>Moore model</strong>, and can be modelled as a <a href="Moore_machine" title="wikilink">Moore machine</a>. A finite-state machine with no output function at all is known as a <a class="uri" href="semiautomaton" title="wikilink">semiautomaton</a> or <a href="transition_system" title="wikilink">transition system</a>.</p>

<p>If we disregard the first output symbol of a Moore machine, 

<math display="inline" id="Finite-state_machine:33">
 <semantics>
  <mrow>
   <mi>ω</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>s</mi>
     <mn>0</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>ω</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>s</ci>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \omega(s_{0})
  </annotation>
 </semantics>
</math>

, then it can be readily converted to an output-equivalent Mealy machine by setting the output function of every Mealy transition (i.e. labeling every edge) with the output symbol given of the destination Moore state. The converse transformation is less straightforward because a Mealy machine state may have different output labels on its incoming transitions (edges). Every such state needs to be split in multiple Moore machine states, one for every incident output symbol.<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a></p>
<h2 id="optimization">Optimization</h2>

<p>Optimizing an FSM means finding the machine with the minimum number of states that performs the same function. The fastest known algorithm doing this is the <a href="DFA_minimization#Hopcroft.27s_algorithm" title="wikilink">Hopcroft minimization algorithm</a>.<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a><a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a> Other techniques include using an <a href="implication_table" title="wikilink">implication table</a>, or the <a href="Moore_reduction_procedure" title="wikilink">Moore reduction procedure</a>. Additionally, acyclic FSAs can be minimized in linear time.<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a></p>
<h2 id="implementation">Implementation</h2>
<h3 id="hardware-applications">Hardware applications</h3>

<p> In a <a href="digital_circuit" title="wikilink">digital circuit</a>, an FSM may be built using a <a href="programmable_logic_device" title="wikilink">programmable logic device</a>, a <a href="programmable_logic_controller" title="wikilink">programmable logic controller</a>, <a href="logic_gate" title="wikilink">logic gates</a> and <a href="Flip-flop_(electronics)" title="wikilink">flip flops</a> or <a href="relay" title="wikilink">relays</a>. More specifically, a hardware implementation requires a <a href="processor_register" title="wikilink">register</a> to store state variables, a block of <a href="combinational_logic" title="wikilink">combinational logic</a> which determines the state transition, and a second block of combinational logic that determines the output of an FSM. One of the classic hardware implementations is the <a href="Richards_controller" title="wikilink">Richards controller</a>.</p>

<p>A particular case of Moore FSM, when output is directly connected to the state flip-flops, that is when output function is simple identity, is known as Medvedev FSM.<a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a> It is advised in chip design that no logic is placed between primary I/O and registers to minimize interchip delays, which are usually long and limit the FSM frequencies.</p>

<p>Through <a href="state_encoding_for_low_power" title="wikilink">state encoding for low power</a> state machines may be optimized to minimize power consumption.</p>
<h3 id="software-applications">Software applications</h3>

<p>The following concepts are commonly used to build software applications with finite state machines:</p>
<ul>
<li><a href="Automata-based_programming" title="wikilink">Automata-based programming</a></li>
<li><a href="Event-driven_finite-state_machine" title="wikilink">Event-driven FSM</a></li>
<li><a href="Virtual_finite-state_machine" title="wikilink">Virtual FSM (VFSM)</a></li>
<li><a href="State_pattern" title="wikilink">State design pattern</a></li>
</ul>
<h3 id="finite-automata-and-compilers">Finite automata and compilers</h3>

<p>Finite automata are often used in the <a href="Compilers#Front_end" title="wikilink">frontend</a> of programming language compilers. Such a frontend may comprise several finite state machines that implement a <a href="lexical_analysis" title="wikilink">lexical analyzer</a> and a parser. Starting from a sequence of characters, the lexical analyzer builds a sequence of language tokens (such as reserved words, literals, and identifiers) from which the parser builds a syntax tree. The lexical analyzer and the parser handle the regular and context-free parts of the programming language's grammar.<a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Abstract_state_machines" title="wikilink">Abstract state machines</a> (ASM)</li>
<li><a href="Artificial_intelligence" title="wikilink">Artificial intelligence</a> (AI)</li>
<li><a href="Abstract_State_Machine_Language" title="wikilink">Abstract State Machine Language</a> (AsmL)</li>
<li><a href="Communicating_finite-state_machine" title="wikilink">Communicating finite-state machine</a></li>
<li><a href="Control_system" title="wikilink">Control system</a></li>
<li><a href="Control_table" title="wikilink">Control table</a></li>
<li><a href="Decision_table" title="wikilink">Decision tables</a></li>
<li><a class="uri" href="DEVS" title="wikilink">DEVS</a>: Discrete Event System Specification</li>
<li><a href="Extended_finite-state_machine" title="wikilink">Extended finite-state machine</a> (EFSM)</li>
<li><a href="FSMD" title="wikilink">Finite state machine with datapath</a></li>
<li><a href="Hidden_Markov_model" title="wikilink">Hidden Markov model</a></li>
<li><a href="Petri_net" title="wikilink">Petri net</a></li>
<li><a href="Pushdown_automaton" title="wikilink">Pushdown automaton</a></li>
<li><a href="Quantum_finite_automata" title="wikilink">Quantum finite automata</a> (QFA)</li>
<li><a href="Recognizable_language" title="wikilink">Recognizable language</a></li>
<li><a href="Sequential_logic" title="wikilink">Sequential logic</a></li>
<li><a href="Specification_and_Description_Language" title="wikilink">Specification and Description Language</a></li>
<li><a href="State_diagram" title="wikilink">State diagram</a></li>
<li><a class="uri" href="SCXML" title="wikilink">SCXML</a></li>
<li><a href="Transition_system" title="wikilink">Transition system</a></li>
<li><a href="Tree_automaton" title="wikilink">Tree automaton</a></li>
<li><a href="Turing_machine" title="wikilink">Turing machine</a></li>
<li><a href="UML_state_machine" title="wikilink">UML state machine</a></li>
<li><a href="YAKINDU_Statechart_Tools" title="wikilink">YAKINDU Statechart Tools</a></li>
</ul>
<h2 id="references">References</h2>
<h2 id="further-reading">Further reading</h2>
<h3 id="general">General</h3>
<ul>
<li></li>
<li>Wagner, F., "Modeling Software with Finite State Machines: A Practical Approach", Auerbach Publications, 2006, ISBN 0-8493-8086-3.</li>
<li>ITU-T, <a href="http://www.itu.int/rec/T-REC-Z.100-200711-I/en"><em>Recommendation Z.100 Specification and Description Language (SDL)</em></a></li>
<li>Samek, M., <a href="http://www.state-machine.com/psicc/index.php"><em>Practical Statecharts in C/C++</em></a>, CMP Books, 2002, ISBN 1-57820-110-1.</li>
<li>Samek, M., <a href="http://www.state-machine.com/psicc2/index.php"><em>Practical UML Statecharts in C/C++, 2nd Edition</em></a>, Newnes, 2008, ISBN 0-7506-8706-1.</li>
<li>Gardner, T., <a href="http://www.troyworks.com/cogs/"><em>Advanced State Management</em></a>, 2007</li>
<li>Cassandras, C., Lafortune, S., "Introduction to Discrete Event Systems". Kluwer, 1999, ISBN 0-7923-8609-4.</li>
<li>Timothy Kam, <em>Synthesis of Finite State Machines: Functional Optimization</em>. Kluwer Academic Publishers, Boston 1997, ISBN 0-7923-9842-4</li>
<li>Tiziano Villa, <em>Synthesis of Finite State Machines: Logic Optimization</em>. Kluwer Academic Publishers, Boston 1997, ISBN 0-7923-9892-0</li>
<li>Carroll, J., Long, D., <em>Theory of Finite Automata with an Introduction to Formal Languages</em>. Prentice Hall, Englewood Cliffs, 1989.</li>
<li>Kohavi, Z., <em>Switching and Finite Automata Theory</em>. McGraw-Hill, 1978.</li>
<li>Gill, A., <em>Introduction to the Theory of Finite-state Machines</em>. McGraw-Hill, 1962.</li>
<li>Ginsburg, S., <em>An Introduction to Mathematical Machine Theory</em>. Addison-Wesley, 1962.</li>
</ul>
<h3 id="finite-state-machines-automata-theory-in-theoretical-computer-science">Finite state machines (automata theory) in theoretical computer science</h3>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
<h3 id="abstract-state-machines-in-theoretical-computer-science">Abstract state machines in theoretical computer science</h3>
<ul>
<li></li>
</ul>
<h3 id="machine-learning-using-finite-state-algorithms">Machine learning using finite-state algorithms</h3>
<ul>
<li></li>
</ul>
<h3 id="hardware-engineering-state-minimization-and-synthesis-of-sequential-circuits">Hardware engineering: state minimization and synthesis of sequential circuits</h3>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
<h3 id="finite-markov-chain-processes">Finite Markov chain processes</h3>
<dl>
<dd><dl>
<dd>"We may think of a <a href="Markov_chain" title="wikilink">Markov chain</a> as a process that moves successively through a set of states <em>s<sub>1</sub></em>, <em>s<sub>2</sub></em>, ..., <em>s<sub>r</sub></em>. ... if it is in state <em>s<sub>i</sub></em> it moves on to the next stop to state <em>s<sub>j</sub></em> with probability <em>p<sub>ij</sub></em>. These probabilities can be exhibited in the form of a transition matrix" (Kemeny (1959), p. 384)
</dd>
</dl>
</dd>
</dl>

<p>Finite Markov-chain processes are also known as <a href="subshifts_of_finite_type" title="wikilink">subshifts of finite type</a>.</p>
<ul>
<li></li>
<li>

<p>Chapter 6 "Finite Markov Chains".</p></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li></li>
<li><a href="http://web.archive.org/web/20130203032845/http://blog.manuvra.com/modeling-a-simple-ai-behavior-using-a-finite-state-machine/"><em>Modeling a Simple AI behavior using a Finite State Machine</em></a> Example of usage in Video Games</li>
<li><a href="http://foldoc.doc.ic.ac.uk/foldoc/foldoc.cgi?query=finite+state+machine">Free On-Line Dictionary of Computing</a> description of Finite State Machines</li>
<li><a href="http://www.nist.gov/dads/HTML/finiteStateMachine.html">NIST Dictionary of Algorithms and Data Structures</a> description of Finite State Machines</li>
<li><a href="http://teahlab.com/Moore_Finite_State_Machine_Control_Circuit/">Interactive FSM: Control Circuit</a>, demonstrates the logic flow of the Finite State Machines.</li>
<li><a href="http://ivanzuzak.info/noam/webapps/fsm_simulator/#tab2">FSM simulator</a>, simulates DFAs, NFAs and ε-NFAs, including generated by regular expression.</li>
</ul>

<p>"</p>

<p><a href="Category:Automata_theory" title="wikilink">Category:Automata theory</a> <a href="Category:Models_of_computation" title="wikilink">Category:Models of computation</a> <a href="Category:Digital_electronics" title="wikilink">Category:Digital electronics</a> <a href="Category:Formal_languages" title="wikilink">Category:Formal languages</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
<li id="fn8"><a class="uri" href="http://www.iam.unibe.ch/~run/talks/2008-06-05-Bern-Jonczy.pdf">http://www.iam.unibe.ch/~run/talks/2008-06-05-Bern-Jonczy.pdf</a>, p. 34<a href="#fnref8">↩</a></li>
<li id="fn9">Brutscheck, M., Berger, S., Franke, M., Schwarzbacher, A., Becker, S.: Structural Division Procedure for Efficient IC Analysis. IET Irish Signals and Systems Conference, (ISSC 2008), pp.18-23. Galway, Ireland, 18–19 June 2008. <a href="http://arrow.dit.ie/engschececon/2/">1</a><a href="#fnref9">↩</a></li>
<li id="fn10"><a href="http://www.csl.sri.com/users/tiwari/papers/stateflow.pdf">Tiwari, A. (2002). Formal Semantics and Analysis Methods for Simulink Stateflow Models.</a><a href="#fnref10">↩</a></li>
<li id="fn11"><a href="#fnref11">↩</a></li>
<li id="fn12"><a href="http://www.fceia.unr.edu.ar/asist/harel01.pdf">Harel, D. (1987). A Visual Formalism for Complex Systems. Science of Computer Programming , 231–274.</a><a href="#fnref12">↩</a></li>
<li id="fn13"><a href="http://drona.csa.iisc.ernet.in/~kanade/publications/symbolic_analysis_for_improving_simulation_coverage_of_simulink_stateflow_models.pdf">Alur, R., Kanade, A., Ramesh, S., &amp; Shashidhar, K. C. (2008). Symbolic analysis for improving simulation coverage of Simulink/Stateflow models. International Conference on Embedded Software (pp. 89–98). Atlanta, GA: ACM.</a><a href="#fnref13">↩</a></li>
<li id="fn14"><a href="#fnref14">↩</a></li>
<li id="fn15"><a href="#fnref15">↩</a></li>
<li id="fn16"><a href="#fnref16">↩</a></li>
<li id="fn17"><a href="#fnref17">↩</a></li>
<li id="fn18"><a href="#fnref18">↩</a></li>
<li id="fn19"><a href="#fnref19">↩</a></li>
<li id="fn20"><a href="#fnref20">↩</a></li>
</ol>
</section>
</body>
</html>
