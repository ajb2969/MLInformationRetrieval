<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="243">Fork–join queue</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Fork–join queue</h1>
<hr/>
<figure><b>(Figure)</b>
<figcaption>A fork–join queueing node</figcaption>
</figure>

<p>In <a href="queueing_theory" title="wikilink">queueing theory</a>, a discipline within the mathematical <a href="probability_theory" title="wikilink">theory of probability</a>, a <strong>fork–join queue</strong> is a queue where incoming jobs are split on arrival for service by numerous servers and joined before departure.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> The model is often used for parallel computations<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> or systems where products need to be obtained simultaneously from different suppliers (in a warehouse or manufacturing setting).<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> The key quantity of interest in this model is usually the time taken to service a complete job. The model has been described as a "key model for the performance analysis of <a href="parallel_computing" title="wikilink">parallel</a> and <a href="distributed_computing" title="wikilink">distributed systems</a>."<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> Few analytical results exist for fork–join queues, but various approximations are known.</p>

<p>The situation where jobs arrive according to a <a href="Poisson_process" title="wikilink">Poisson process</a> and service times are exponentially distributed is sometimes referred to as a <strong>Flatto–Hahn–Wright model</strong> or <strong>FHW model</strong>.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a><a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a><a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>
<h2 id="definition">Definition</h2>

<p>On arrival at the fork point, a job is split into <em>N</em> sub-jobs which are served by each of the <em>N</em> servers. After service, sub-job wait until all other sub-jobs have also been processed. The sub-jobs are then rejoined and leave the system.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></p>

<p>For the fork–join queue to be stable the input rate must be strictly less than sum of the service rates at the service nodes.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></p>
<h2 id="applications">Applications</h2>

<p>Fork–join queues have been used to model zoned <a class="uri" href="RAID" title="wikilink">RAID</a> systems,<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> parallel computations<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> and for modelling order fulfilment in warehouses.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a></p>
<h2 id="response-time">Response time</h2>

<p>The response time (or sojourn time<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a>) is the total amount of time a job spends in the system.</p>
<h3 id="distribution">Distribution</h3>

<p>Ko and Serfozo give an approximation for the response time distribution when service times are exponentially distributed and jobs arrive either according to a <a href="Poisson_process" title="wikilink">Poisson process</a><a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a> or a general distribution.<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a></p>
<h3 id="average-response-time">Average response time</h3>

<p>An exact formula for the average response time is only known in the case of two servers (<em>N</em>=2) with exponentially distributed service times (where each server is an <a href="M/M/1_queue" title="wikilink">M/M/1 queue</a>). In this situation, the response time (total time a job spends in the system) is<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a></p>

<p>

<math display="block" id="Fork–join_queue:0">
 <semantics>
  <mfrac>
   <mrow>
    <mn>12</mn>
    <mo>-</mo>
    <mi>ρ</mi>
   </mrow>
   <mrow>
    <mn>8</mn>
    <mi>μ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mn>1</mn>
      <mo>-</mo>
      <mi>ρ</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <minus></minus>
     <cn type="integer">12</cn>
     <ci>ρ</ci>
    </apply>
    <apply>
     <times></times>
     <cn type="integer">8</cn>
     <ci>μ</ci>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
      <ci>ρ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{12-\rho}{8\mu(1-\rho)}
  </annotation>
 </semantics>
</math>

 where</p>
<ul>
<li>

<math display="inline" id="Fork–join_queue:1">
 <semantics>
  <mrow>
   <mi>ρ</mi>
   <mo>=</mo>
   <mrow>
    <mi>λ</mi>
    <mo>/</mo>
    <mi>μ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>ρ</ci>
    <apply>
     <divide></divide>
     <ci>λ</ci>
     <ci>μ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho=\lambda/\mu
  </annotation>
 </semantics>
</math>

 is the <a class="uri" href="utilization" title="wikilink">utilization</a>.</li>
<li>

<math display="inline" id="Fork–join_queue:2">
 <semantics>
  <mi>λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda
  </annotation>
 </semantics>
</math>

 is the arrival rate of jobs to all the nodes.</li>
<li>

<math display="inline" id="Fork–join_queue:3">
 <semantics>
  <mi>μ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>μ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu
  </annotation>
 </semantics>
</math>

 is the service rate across all the nodes.</li>
</ul>

<p>In the situation where nodes are <a href="M/M/1_queue" title="wikilink">M/M/1 queues</a> and <em>N</em> &gt; 2, Varki's modification of <a href="mean_value_analysis" title="wikilink">mean value analysis</a> can also be used to give an approximate value for the average response time.<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a></p>

<p>For general service times (where each node is an <a href="M/G/1_queue" title="wikilink">M/G/1 queue</a>) Baccelli and Makowski give bounds for the average response time and higher <a href="moment_(mathematics)" title="wikilink">moments</a> of this quantity both in the transient and steady state situations.<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a> Kemper and Mandjes show that for some parameters these bounds are not tight and show demonstrate an approximation technique.<a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a> For heterogeneous fork-join queues (fork-join queues with different service times), Alomari and Menasce propose an approximation based on harmonic numbers that can be extended to cover more general cases such as probabilistic fork, open and closed fork-join queues.<a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a></p>
<h3 id="subtask-dispersion">Subtask dispersion</h3>

<p>The subtask dispersion, defined to be the <a href="range_(statistics)" title="wikilink">range</a> of service times, can be numerically computed and optimal deterministic delays introduced to minimize the range.<a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a></p>
<h2 id="stationary-distribution">Stationary distribution</h2>

<p>In general the <a href="Markov_chain#Steady-state_analysis_and_limiting_distributions" title="wikilink">stationary distribution</a> of the number of jobs at each queue is intractable.<a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a> Flatto considered the case of two servers (<em>N=2</em>) and derived the stationary distribution for the number of jobs at each queue via <a href="uniformization_(probability_theory)" title="wikilink">uniformization</a> techniques.<a class="footnoteRef" href="#fn23" id="fnref23"><sup>23</sup></a> Pinotsi and Zazanis show that a <a href="product_form_solution" title="wikilink">product form solution</a> exists when arrivals are <a href="deterministic_system" title="wikilink">deterministic</a> as the queue lengths are then independent <a href="D/M/1_queue" title="wikilink">D/M/1 queues</a>.<a class="footnoteRef" href="#fn24" id="fnref24"><sup>24</sup></a></p>
<h3 id="heavy-trafficdiffusion-approximation">Heavy traffic/diffusion approximation</h3>

<p>When the server is heavily loaded (service rate of the queue is only just larger than arrival rate) the queue length process can be approximated by a <a href="reflected_Brownian_motion" title="wikilink">reflected Brownian motion</a> which converges to the same stationary distribution as the original queueing process.<a class="footnoteRef" href="#fn25" id="fnref25"><sup>25</sup></a><a class="footnoteRef" href="#fn26" id="fnref26"><sup>26</sup></a> Under limiting conditions the state space of the synchronisation queues collapses and all queues behave identically.<a class="footnoteRef" href="#fn27" id="fnref27"><sup>27</sup></a></p>
<h2 id="join-queue-distribution">Join queue distribution</h2>

<p>Once jobs are served, the parts are reassembled at the join queue. Nelson and Tantawi published the distribution of the join queue length in the situation where all servers have the same service rate.<a class="footnoteRef" href="#fn28" id="fnref28"><sup>28</sup></a> Heterogeneous service rates and distribution <a href="asymptotic_analysis" title="wikilink">asymptotic analysis</a> are considered by Li and Zhao.<a class="footnoteRef" href="#fn29" id="fnref29"><sup>29</sup></a></p>
<h2 id="networks-of-forkjoin-queues">Networks of fork–join queues</h2>

<p>An approximate formula can be used to calculate the response time distribution for a network of fork–join queues joined in series (one after the other).<a class="footnoteRef" href="#fn30" id="fnref30"><sup>30</sup></a></p>
<h2 id="splitmerge-model">Split–merge model</h2>

<p>A related model is the split–merge model, for which analytical results exist.<a class="footnoteRef" href="#fn31" id="fnref31"><sup>31</sup></a><a class="footnoteRef" href="#fn32" id="fnref32"><sup>32</sup></a> Here on arrival a job is split into <em>N</em> sub-tasks which are serviced in parallel. Only when all the tasks ﬁnish servicing and have rejoined can the next job start. This leads to a slower response time on average.</p>
<h2 id="generalized-nk-fork-join-system">Generalized (n,k) fork-join system</h2>

<p>A generalization of the fork-join queueing system is the 

<math display="inline" id="Fork–join_queue:4">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>n</mi>
   <mo>,</mo>
   <mi>k</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>n</ci>
    <ci>k</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (n,k)
  </annotation>
 </semantics>
</math>

 fork-join system where the job exits the system when any 

<math display="inline" id="Fork–join_queue:5">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 out of 

<math display="inline" id="Fork–join_queue:6">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 tasks are served. The traditional fork-join queueing system is a special case of the 

<math display="inline" id="Fork–join_queue:7">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>n</mi>
   <mo>,</mo>
   <mi>k</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>n</ci>
    <ci>k</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (n,k)
  </annotation>
 </semantics>
</math>

 system when 

<math display="inline" id="Fork–join_queue:8">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>=</mo>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>k</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k=n
  </annotation>
 </semantics>
</math>

. Bounds on the mean response time of this generalized system were found by Joshi, Liu and Soljanin. <a class="footnoteRef" href="#fn33" id="fnref33"><sup>33</sup></a> <a class="footnoteRef" href="#fn34" id="fnref34"><sup>34</sup></a></p>
<h2 id="references">References</h2>

<p>"</p>

<p><a href="Category:Single_queueing_nodes" title="wikilink">Category:Single queueing nodes</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
<li id="fn8"></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
<li id="fn10"><a href="#fnref10">↩</a></li>
<li id="fn11"></li>
<li id="fn12"></li>
<li id="fn13"></li>
<li id="fn14"></li>
<li id="fn15"><a href="#fnref15">↩</a></li>
<li id="fn16"><a href="#fnref16">↩</a></li>
<li id="fn17"><a href="#fnref17">↩</a></li>
<li id="fn18"><a href="#fnref18">↩</a></li>
<li id="fn19"><a href="#fnref19">↩</a></li>
<li id="fn20"><a href="#fnref20">↩</a></li>
<li id="fn21"><a href="#fnref21">↩</a></li>
<li id="fn22"><a href="#fnref22">↩</a></li>
<li id="fn23"><a href="#fnref23">↩</a></li>
<li id="fn24"></li>
<li id="fn25"><a href="#fnref25">↩</a></li>
<li id="fn26"><a href="#fnref26">↩</a></li>
<li id="fn27"><a href="#fnref27">↩</a></li>
<li id="fn28"></li>
<li id="fn29"><a href="#fnref29">↩</a></li>
<li id="fn30"><a href="#fnref30">↩</a></li>
<li id="fn31"><a href="#fnref31">↩</a></li>
<li id="fn32"><a href="#fnref32">↩</a></li>
<li id="fn33"><a href="#fnref33">↩</a></li>
<li id="fn34"><a href="#fnref34">↩</a></li>
</ol>
</section>
</body>
</html>
