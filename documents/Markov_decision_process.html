<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1741">Markov decision process</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Markov decision process</h1>
<hr/>

<p><strong>Markov decision processes (MDPs)</strong>, named after <a href="Andrey_Markov" title="wikilink">Andrey Markov</a>, provide a mathematical framework for modeling <a href="decision_making" title="wikilink">decision making</a> in situations where outcomes are partly <a href="Randomness#In_mathematics" title="wikilink">random</a> and partly under the control of a decision maker. MDPs are useful for studying a wide range of <a href="optimization_problem" title="wikilink">optimization problems</a> solved via <a href="dynamic_programming" title="wikilink">dynamic programming</a> and <a href="reinforcement_learning" title="wikilink">reinforcement learning</a>. MDPs were known at least as early as the 1950s (cf. Bellman 1957). A core body of research on Markov decision processes resulted from <a href="Ronald_A._Howard" title="wikilink">Ronald A. Howard</a>'s book published in 1960, <em>Dynamic Programming and Markov Processes</em>. They are used in a wide area of disciplines, including <a class="uri" href="robotics" title="wikilink">robotics</a>, <a href="Automatic_control" title="wikilink">automated control</a>, <a class="uri" href="economics" title="wikilink">economics</a>, and <a class="uri" href="manufacturing" title="wikilink">manufacturing</a>.</p>

<p>More precisely, a Markov Decision Process is a <a href="discrete_time" title="wikilink">discrete time</a> <a class="uri" href="stochastic" title="wikilink">stochastic</a> <a href="Optimal_control_theory" title="wikilink">control</a> process. At each time step, the process is in some state 

<math display="inline" id="Markov_decision_process:0">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

, and the decision maker may choose any action 

<math display="inline" id="Markov_decision_process:1">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 that is available in state 

<math display="inline" id="Markov_decision_process:2">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

. The process responds at the next time step by randomly moving into a new state 

<math display="inline" id="Markov_decision_process:3">
 <semantics>
  <msup>
   <mi>s</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>s</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s^{\prime}
  </annotation>
 </semantics>
</math>


, and giving the decision maker a corresponding reward 

<math display="inline" id="Markov_decision_process:4">
 <semantics>
  <mrow>
   <msub>
    <mi>R</mi>
    <mi>a</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>s</mi>
    <mo>,</mo>
    <msup>
     <mi>s</mi>
     <mo>′</mo>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>R</ci>
     <ci>a</ci>
    </apply>
    <interval closure="open">
     <ci>s</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>s</ci>
      <ci>normal-′</ci>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{a}(s,s^{\prime})
  </annotation>
 </semantics>
</math>

.</p>

<p>The probability that the process moves into its new state 

<math display="inline" id="Markov_decision_process:5">
 <semantics>
  <msup>
   <mi>s</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>s</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s^{\prime}
  </annotation>
 </semantics>
</math>

 is influenced by the chosen action. Specifically, it is given by the state transition function 

<math display="inline" id="Markov_decision_process:6">
 <semantics>
  <mrow>
   <msub>
    <mi>P</mi>
    <mi>a</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>s</mi>
    <mo>,</mo>
    <msup>
     <mi>s</mi>
     <mo>′</mo>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>P</ci>
     <ci>a</ci>
    </apply>
    <interval closure="open">
     <ci>s</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>s</ci>
      <ci>normal-′</ci>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{a}(s,s^{\prime})
  </annotation>
 </semantics>
</math>

. Thus, the next state 

<math display="inline" id="Markov_decision_process:7">
 <semantics>
  <msup>
   <mi>s</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>s</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s^{\prime}
  </annotation>
 </semantics>
</math>

 depends on the current state 

<math display="inline" id="Markov_decision_process:8">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>


 and the decision maker's action 

<math display="inline" id="Markov_decision_process:9">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

. But given 

<math display="inline" id="Markov_decision_process:10">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Markov_decision_process:11">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

, it is conditionally independent of all previous states and actions; in other words, the state transitions of an MDP process satisfies the <em><a href="Markov_property" title="wikilink">Markov property</a></em>.</p>

<p>Markov decision processes are an extension of <a href="Markov_chain" title="wikilink">Markov chains</a>; the difference is the addition of actions (allowing choice) and rewards (giving motivation). Conversely, if only one action exists for each state and all rewards are the same (e.g., zero), a Markov decision process reduces to a <a href="Markov_chain" title="wikilink">Markov chain</a>.</p>
<h2 id="definition">Definition</h2>

<p> A Markov decision process is a 5-<a class="uri" href="tuple" title="wikilink">tuple</a> 

<math display="inline" id="Markov_decision_process:12">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>S</mi>
   <mo>,</mo>
   <mi>A</mi>
   <mo>,</mo>
   <mrow>
    <msub>
     <mi>P</mi>
     <mo>⋅</mo>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mo>⋅</mo>
     <mo>,</mo>
     <mo>⋅</mo>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mrow>
    <msub>
     <mi>R</mi>
     <mo>⋅</mo>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mo>⋅</mo>
     <mo>,</mo>
     <mo>⋅</mo>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mi>γ</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <ci>S</ci>
    <ci>A</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>P</ci>
      <ci>normal-⋅</ci>
     </apply>
     <interval closure="open">
      <ci>normal-⋅</ci>
      <ci>normal-⋅</ci>
     </interval>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>R</ci>
      <ci>normal-⋅</ci>
     </apply>
     <interval closure="open">
      <ci>normal-⋅</ci>
      <ci>normal-⋅</ci>
     </interval>
    </apply>
    <ci>γ</ci>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (S,A,P_{\cdot}(\cdot,\cdot),R_{\cdot}(\cdot,\cdot),\gamma)
  </annotation>
 </semantics>
</math>

, where</p>
<ul>
<li>

<math display="inline" id="Markov_decision_process:13">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>


 is a finite set of states,</li>
<li>

<math display="inline" id="Markov_decision_process:14">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 is a finite set of actions (alternatively, 

<math display="inline" id="Markov_decision_process:15">
 <semantics>
  <msub>
   <mi>A</mi>
   <mi>s</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>A</ci>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{s}
  </annotation>
 </semantics>
</math>

 is the finite set of actions available from state 

<math display="inline" id="Markov_decision_process:16">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

),</li>
<li>

<math display="inline" id="Markov_decision_process:17">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>P</mi>
     <mi>a</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>s</mi>
     <mo>,</mo>
     <msup>
      <mi>s</mi>
      <mo>′</mo>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>Pr</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>s</mi>
       <mrow>
        <mi>t</mi>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
      </msub>
      <mo>=</mo>
      <msup>
       <mi>s</mi>
       <mo>′</mo>
      </msup>
     </mrow>
     <mo>∣</mo>
     <mrow>
      <msub>
       <mi>s</mi>
       <mi>t</mi>
      </msub>
      <mo>=</mo>
      <mi>s</mi>
     </mrow>
     <mo>,</mo>
     <mrow>
      <msub>
       <mi>a</mi>
       <mi>t</mi>
      </msub>
      <mo>=</mo>
      <mi>a</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>P</ci>
      <ci>a</ci>
     </apply>
     <interval closure="open">
      <ci>s</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>s</ci>
       <ci>normal-′</ci>
      </apply>
     </interval>
    </apply>
    <apply>
     <ci>Pr</ci>
     <apply>
      <eq></eq>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>s</ci>
       <apply>
        <plus></plus>
        <ci>t</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>s</ci>
       <ci>normal-′</ci>
      </apply>
     </apply>
     <apply>
      <eq></eq>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>s</ci>
       <ci>t</ci>
      </apply>
      <ci>s</ci>
     </apply>
     <apply>
      <eq></eq>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <ci>t</ci>
      </apply>
      <ci>a</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{a}(s,s^{\prime})=\Pr(s_{t+1}=s^{\prime}\mid s_{t}=s,a_{t}=a)
  </annotation>
 </semantics>
</math>

 is the probability that action 

<math display="inline" id="Markov_decision_process:18">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>


 in state 

<math display="inline" id="Markov_decision_process:19">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

 at time 

<math display="inline" id="Markov_decision_process:20">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 will lead to state 

<math display="inline" id="Markov_decision_process:21">
 <semantics>
  <msup>
   <mi>s</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>s</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s^{\prime}
  </annotation>
 </semantics>
</math>

 at time 

<math display="inline" id="Markov_decision_process:22">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mo>+</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>t</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t+1
  </annotation>
 </semantics>
</math>

,</li>
<li>

<math display="inline" id="Markov_decision_process:23">
 <semantics>
  <mrow>
   <msub>
    <mi>R</mi>
    <mi>a</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>s</mi>
    <mo>,</mo>
    <msup>
     <mi>s</mi>
     <mo>′</mo>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>R</ci>
     <ci>a</ci>
    </apply>
    <interval closure="open">
     <ci>s</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>s</ci>
      <ci>normal-′</ci>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{a}(s,s^{\prime})
  </annotation>
 </semantics>
</math>


 is the immediate reward (or expected immediate reward) received after transition to state 

<math display="inline" id="Markov_decision_process:24">
 <semantics>
  <msup>
   <mi>s</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>s</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s^{\prime}
  </annotation>
 </semantics>
</math>

 from state 

<math display="inline" id="Markov_decision_process:25">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

,</li>
<li>

<math display="inline" id="Markov_decision_process:26">
 <semantics>
  <mrow>
   <mi>γ</mi>
   <mo>∈</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mn>1</mn>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>γ</ci>
    <interval closure="closed">
     <cn type="integer">0</cn>
     <cn type="integer">1</cn>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gamma\in[0,1]
  </annotation>
 </semantics>
</math>

 is the discount factor, which represents the difference in importance between future rewards and present rewards.</li>
</ul>

<p>(Note: The theory of Markov decision processes does not state that 

<math display="inline" id="Markov_decision_process:27">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 or 

<math display="inline" id="Markov_decision_process:28">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>


 are finite, but the basic algorithms below assume that they are finite.)</p>
<h2 id="problem">Problem</h2>

<p>The core problem of MDPs is to find a "policy" for the decision maker: a function 

<math display="inline" id="Markov_decision_process:29">
 <semantics>
  <mi>π</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>π</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi
  </annotation>
 </semantics>
</math>

 that specifies the action 

<math display="inline" id="Markov_decision_process:30">
 <semantics>
  <mrow>
   <mi>π</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>s</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>π</ci>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi(s)
  </annotation>
 </semantics>
</math>

 that the decision maker will choose when in state 

<math display="inline" id="Markov_decision_process:31">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

. Note that once a Markov decision process is combined with a policy in this way, this fixes the action for each state and the resulting combination behaves like a <a href="Markov_chain" title="wikilink">Markov chain</a>.</p>

<p>The goal is to choose a policy 

<math display="inline" id="Markov_decision_process:32">
 <semantics>
  <mi>π</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>π</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi
  </annotation>
 </semantics>
</math>

 that will maximize some cumulative function of the random rewards, typically the expected discounted sum over a potentially infinite horizon:</p>

<p>

<math display="block" id="Markov_decision_process:33">
 <semantics>
  <mrow>
   <munderover>
    <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
    <mrow>
     <mi>t</mi>
     <mo>=</mo>
     <mn>0</mn>
    </mrow>
    <mi mathvariant="normal">∞</mi>
   </munderover>
   <mrow>
    <msup>
     <mi>γ</mi>
     <mi>t</mi>
    </msup>
    <msub>
     <mi>R</mi>
     <msub>
      <mi>a</mi>
      <mi>t</mi>
     </msub>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>s</mi>
      <mi>t</mi>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>s</mi>
      <mrow>
       <mi>t</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <sum></sum>
      <infinity></infinity>
     </apply>
     <apply>
      <eq></eq>
      <ci>t</ci>
      <cn type="integer">0</cn>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>γ</ci>
      <ci>t</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>R</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <ci>t</ci>
      </apply>
     </apply>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>s</ci>
       <ci>t</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>s</ci>
       <apply>
        <plus></plus>
        <ci>t</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum^{\infty}_{t=0}{\gamma^{t}R_{a_{t}}(s_{t},s_{t+1})}
  </annotation>
 </semantics>
</math>

    (where we choose 

<math display="inline" id="Markov_decision_process:34">
 <semantics>
  <mrow>
   <msub>
    <mi>a</mi>
    <mi>t</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mi>π</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>s</mi>
      <mi>t</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <times></times>
     <ci>π</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>s</ci>
      <ci>t</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{t}=\pi(s_{t})
  </annotation>
 </semantics>
</math>

)</p>

<p>where 

<math display="inline" id="Markov_decision_process:35">
 <semantics>
  <mpadded lspace="5pt" width="+5pt">
   <mi>γ</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>γ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ \gamma
  </annotation>
 </semantics>
</math>

 is the discount factor and satisfies 

<math display="inline" id="Markov_decision_process:36">
 <semantics>
  <mrow>
   <mn>0</mn>
   <mo rspace="7.5pt">≤</mo>
   <mpadded width="+5pt">
    <mi>γ</mi>
   </mpadded>
   <mo><</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <cn type="integer">0</cn>
     <ci>γ</ci>
    </apply>
    <apply>
     <lt></lt>
     <share href="#.cmml">
     </share>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0\leq\ \gamma\ <1
  </annotation>
 </semantics>
</math>

. (For example, 

<math display="inline" id="Markov_decision_process:37">
 <semantics>
  <mrow>
   <mi>γ</mi>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mo>/</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mn>1</mn>
      <mo>+</mo>
      <mi>r</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>γ</ci>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <apply>
      <plus></plus>
      <cn type="integer">1</cn>
      <ci>r</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gamma=1/(1+r)
  </annotation>
 </semantics>
</math>

 when the discount rate is r.) 

<math display="inline" id="Markov_decision_process:38">
 <semantics>
  <mi>γ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>γ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gamma
  </annotation>
 </semantics>
</math>


 is typically close to 1.</p>

<p>Because of the Markov property, the optimal policy for this particular problem can indeed be written as a function of 

<math display="inline" id="Markov_decision_process:39">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

 only, as assumed above.</p>
<h2 id="algorithms">Algorithms</h2>

<p>MDPs can be solved by <a href="linear_programming" title="wikilink">linear programming</a> or <a href="dynamic_programming" title="wikilink">dynamic programming</a>. In what follows we present the latter approach.</p>

<p>Suppose we <em>know</em> the state transition function 

<math display="inline" id="Markov_decision_process:40">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 and the reward function 

<math display="inline" id="Markov_decision_process:41">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

, and we wish to calculate the policy that maximizes the expected discounted reward.</p>

<p>The standard family of algorithms to calculate this optimal policy requires storage for two arrays indexed by state: <em>value</em> 

<math display="inline" id="Markov_decision_process:42">
 <semantics>
  <mi>V</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>V</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V
  </annotation>
 </semantics>
</math>

, which contains real values, and <em>policy</em> 

<math display="inline" id="Markov_decision_process:43">
 <semantics>
  <mi>π</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>π</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi
  </annotation>
 </semantics>
</math>


 which contains actions. At the end of the algorithm, 

<math display="inline" id="Markov_decision_process:44">
 <semantics>
  <mi>π</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>π</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi
  </annotation>
 </semantics>
</math>

 will contain the solution and 

<math display="inline" id="Markov_decision_process:45">
 <semantics>
  <mrow>
   <mi>V</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>s</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>V</ci>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V(s)
  </annotation>
 </semantics>
</math>

 will contain the discounted sum of the rewards to be earned (on average) by following that solution from state 

<math display="inline" id="Markov_decision_process:46">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

.</p>

<p>The algorithm has the following two kinds of steps, which are repeated in some order for all the states until no further changes take place. They are defined recursively as follows:</p>

<p>

<math display="block" id="Markov_decision_process:47">
 <semantics>
  <mrow>
   <mrow>
    <mi>π</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>s</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>:=</mo>
   <mrow>
    <mi>arg</mi>
    <mrow>
     <munder>
      <mi>max</mi>
      <mi>a</mi>
     </munder>
     <mrow>
      <mo>{</mo>
      <mrow>
       <munder>
        <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
        <msup>
         <mi>s</mi>
         <mo>′</mo>
        </msup>
       </munder>
       <mrow>
        <msub>
         <mi>P</mi>
         <mi>a</mi>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>s</mi>
         <mo>,</mo>
         <msup>
          <mi>s</mi>
          <mo>′</mo>
         </msup>
         <mo stretchy="false">)</mo>
        </mrow>
        <mrow>
         <mo>(</mo>
         <mrow>
          <mrow>
           <msub>
            <mi>R</mi>
            <mi>a</mi>
           </msub>
           <mrow>
            <mo stretchy="false">(</mo>
            <mi>s</mi>
            <mo>,</mo>
            <msup>
             <mi>s</mi>
             <mo>′</mo>
            </msup>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
          <mo>+</mo>
          <mrow>
           <mi>γ</mi>
           <mi>V</mi>
           <mrow>
            <mo stretchy="false">(</mo>
            <msup>
             <mi>s</mi>
             <mo>′</mo>
            </msup>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
         </mrow>
         <mo>)</mo>
        </mrow>
       </mrow>
      </mrow>
      <mo>}</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <apply>
     <times></times>
     <ci>π</ci>
     <ci>s</ci>
    </apply>
    <apply>
     <arg></arg>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <max></max>
       <ci>a</ci>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>s</ci>
         <ci>normal-′</ci>
        </apply>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>P</ci>
         <ci>a</ci>
        </apply>
        <interval closure="open">
         <ci>s</ci>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>s</ci>
          <ci>normal-′</ci>
         </apply>
        </interval>
        <apply>
         <plus></plus>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>R</ci>
           <ci>a</ci>
          </apply>
          <interval closure="open">
           <ci>s</ci>
           <apply>
            <csymbol cd="ambiguous">superscript</csymbol>
            <ci>s</ci>
            <ci>normal-′</ci>
           </apply>
          </interval>
         </apply>
         <apply>
          <times></times>
          <ci>γ</ci>
          <ci>V</ci>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>s</ci>
           <ci>normal-′</ci>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi(s):=\arg\max_{a}\left\{\sum_{s^{\prime}}P_{a}(s,s^{\prime})\left(R_{a}(s,s%
^{\prime})+\gamma V(s^{\prime})\right)\right\}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Markov_decision_process:48">
 <semantics>
  <mrow>
   <mrow>
    <mi>V</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>s</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>:=</mo>
   <mrow>
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <msup>
      <mi>s</mi>
      <mo>′</mo>
     </msup>
    </munder>
    <mrow>
     <msub>
      <mi>P</mi>
      <mrow>
       <mi>π</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>s</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>s</mi>
      <mo>,</mo>
      <msup>
       <mi>s</mi>
       <mo>′</mo>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo>(</mo>
      <mrow>
       <mrow>
        <msub>
         <mi>R</mi>
         <mrow>
          <mi>π</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>s</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>s</mi>
         <mo>,</mo>
         <msup>
          <mi>s</mi>
          <mo>′</mo>
         </msup>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>+</mo>
       <mrow>
        <mi>γ</mi>
        <mi>V</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <msup>
          <mi>s</mi>
          <mo>′</mo>
         </msup>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
      <mo>)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <apply>
     <times></times>
     <ci>V</ci>
     <ci>s</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>s</ci>
       <ci>normal-′</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>P</ci>
       <apply>
        <times></times>
        <ci>π</ci>
        <ci>s</ci>
       </apply>
      </apply>
      <interval closure="open">
       <ci>s</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>s</ci>
        <ci>normal-′</ci>
       </apply>
      </interval>
      <apply>
       <plus></plus>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>R</ci>
         <apply>
          <times></times>
          <ci>π</ci>
          <ci>s</ci>
         </apply>
        </apply>
        <interval closure="open">
         <ci>s</ci>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>s</ci>
          <ci>normal-′</ci>
         </apply>
        </interval>
       </apply>
       <apply>
        <times></times>
        <ci>γ</ci>
        <ci>V</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>s</ci>
         <ci>normal-′</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V(s):=\sum_{s^{\prime}}P_{\pi(s)}(s,s^{\prime})\left(R_{\pi(s)}(s,s^{\prime})+%
\gamma V(s^{\prime})\right)
  </annotation>
 </semantics>
</math>

</p>

<p>Their order depends on the variant of the algorithm; one can also do them for all states at once or state by state, and more often to some states than others. As long as no state is permanently excluded from either of the steps, the algorithm will eventually arrive at the correct solution.</p>
<h3 id="notable-variants">Notable variants</h3>
<h4 id="value-iteration">Value iteration</h4>

<p>In value iteration (Bellman 1957), which is also called <a href="backward_induction" title="wikilink">backward induction</a>, the 

<math display="inline" id="Markov_decision_process:49">
 <semantics>
  <mi>π</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>π</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi
  </annotation>
 </semantics>
</math>

 function is not used; instead, the value of 

<math display="inline" id="Markov_decision_process:50">
 <semantics>
  <mrow>
   <mi>π</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>s</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>π</ci>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi(s)
  </annotation>
 </semantics>
</math>

 is calculated within 

<math display="inline" id="Markov_decision_process:51">
 <semantics>
  <mrow>
   <mi>V</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>s</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>V</ci>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V(s)
  </annotation>
 </semantics>
</math>

 whenever it is needed. Shapley's 1953 paper on <a href="stochastic_games" title="wikilink">stochastic games</a> included as a special case the value iteration method for MDPs, but this was recognized only later on.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>

<p>Substituting the calculation of 

<math display="inline" id="Markov_decision_process:52">
 <semantics>
  <mrow>
   <mi>π</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>s</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>π</ci>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi(s)
  </annotation>
 </semantics>
</math>

 into the calculation of 

<math display="inline" id="Markov_decision_process:53">
 <semantics>
  <mrow>
   <mi>V</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>s</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>V</ci>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V(s)
  </annotation>
 </semantics>
</math>


 gives the combined step:</p>

<p>

<math display="block" id="Markov_decision_process:54">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>V</mi>
      <mrow>
       <mi>i</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>s</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>:=</mo>
    <mrow>
     <munder>
      <mi>max</mi>
      <mi>a</mi>
     </munder>
     <mrow>
      <mo>{</mo>
      <mrow>
       <munder>
        <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
        <msup>
         <mi>s</mi>
         <mo>′</mo>
        </msup>
       </munder>
       <mrow>
        <msub>
         <mi>P</mi>
         <mi>a</mi>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>s</mi>
         <mo>,</mo>
         <msup>
          <mi>s</mi>
          <mo>′</mo>
         </msup>
         <mo stretchy="false">)</mo>
        </mrow>
        <mrow>
         <mo>(</mo>
         <mrow>
          <mrow>
           <msub>
            <mi>R</mi>
            <mi>a</mi>
           </msub>
           <mrow>
            <mo stretchy="false">(</mo>
            <mi>s</mi>
            <mo>,</mo>
            <msup>
             <mi>s</mi>
             <mo>′</mo>
            </msup>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
          <mo>+</mo>
          <mrow>
           <mi>γ</mi>
           <msub>
            <mi>V</mi>
            <mi>i</mi>
           </msub>
           <mrow>
            <mo stretchy="false">(</mo>
            <msup>
             <mi>s</mi>
             <mo>′</mo>
            </msup>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
         </mrow>
         <mo>)</mo>
        </mrow>
       </mrow>
      </mrow>
      <mo>}</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>V</ci>
      <apply>
       <plus></plus>
       <ci>i</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>s</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <max></max>
      <ci>a</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>s</ci>
        <ci>normal-′</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>P</ci>
        <ci>a</ci>
       </apply>
       <interval closure="open">
        <ci>s</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>s</ci>
         <ci>normal-′</ci>
        </apply>
       </interval>
       <apply>
        <plus></plus>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>R</ci>
          <ci>a</ci>
         </apply>
         <interval closure="open">
          <ci>s</ci>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>s</ci>
           <ci>normal-′</ci>
          </apply>
         </interval>
        </apply>
        <apply>
         <times></times>
         <ci>γ</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>V</ci>
          <ci>i</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>s</ci>
          <ci>normal-′</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V_{i+1}(s):=\max_{a}\left\{\sum_{s^{\prime}}P_{a}(s,s^{\prime})\left(R_{a}(s,s%
^{\prime})+\gamma V_{i}(s^{\prime})\right)\right\},
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Markov_decision_process:55">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

 is the iteration number. Value iteration starts at 

<math display="inline" id="Markov_decision_process:56">
 <semantics>
  <mrow>
   <mi>i</mi>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>i</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i=0
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Markov_decision_process:57">
 <semantics>
  <msub>
   <mi>V</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>V</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V_{0}
  </annotation>
 </semantics>
</math>

 as a guess of the value function. It then iterates, repeatedly computing 

<math display="inline" id="Markov_decision_process:58">
 <semantics>
  <msub>
   <mi>V</mi>
   <mrow>
    <mi>i</mi>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>V</ci>
    <apply>
     <plus></plus>
     <ci>i</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V_{i+1}
  </annotation>
 </semantics>
</math>


 for all states 

<math display="inline" id="Markov_decision_process:59">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

, until 

<math display="inline" id="Markov_decision_process:60">
 <semantics>
  <mi>V</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>V</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V
  </annotation>
 </semantics>
</math>

 converges with the left-hand side equal to the right-hand side (which is the "<a href="Bellman_equation" title="wikilink">Bellman equation</a>" for this problem).</p>
<h4 id="policy-iteration">Policy iteration</h4>

<p>In policy iteration (Howard 1960), step one is performed once, and then step two is repeated until it converges. Then step one is again performed once and so on.</p>

<p>Instead of repeating step two to convergence, it may be formulated and solved as a set of linear equations.</p>

<p>This variant has the advantage that there is a definite stopping condition: when the array 

<math display="inline" id="Markov_decision_process:61">
 <semantics>
  <mi>π</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>π</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi
  </annotation>
 </semantics>
</math>

 does not change in the course of applying step 1 to all states, the algorithm is completed.</p>
<h4 id="modified-policy-iteration">Modified policy iteration</h4>

<p>In modified policy iteration (van Nunen, 1976; Puterman and Shin 1978), step one is performed once, and then step two is repeated several times. Then step one is again performed once and so on.</p>
<h4 id="prioritized-sweeping">Prioritized sweeping</h4>

<p>In this variant, the steps are preferentially applied to states which are in some way important - whether based on the algorithm (there were large changes in 

<math display="inline" id="Markov_decision_process:62">
 <semantics>
  <mi>V</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>V</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V
  </annotation>
 </semantics>
</math>

 or 

<math display="inline" id="Markov_decision_process:63">
 <semantics>
  <mi>π</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>π</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi
  </annotation>
 </semantics>
</math>


 around those states recently) or based on use (those states are near the starting state, or otherwise of interest to the person or program using the algorithm).</p>
<h2 id="extensions-and-generalizations">Extensions and generalizations</h2>

<p>A Markov decision process is a <a href="stochastic_game" title="wikilink">stochastic game</a> with only one player.</p>
<h3 id="partial-observability">Partial observability</h3>

<p>The solution above assumes that the state 

<math display="inline" id="Markov_decision_process:64">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

 is known when action is to be taken; otherwise 

<math display="inline" id="Markov_decision_process:65">
 <semantics>
  <mrow>
   <mi>π</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>s</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>π</ci>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi(s)
  </annotation>
 </semantics>
</math>

 cannot be calculated. When this assumption is not true, the problem is called a partially observable Markov decision process or POMDP.</p>

<p>A major advance in this area was provided by Burnetas and Katehakis in "Optimal adaptive policies for Markov decision processes".<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> In this work a class of adaptive policies that possess uniformly maximum convergence rate properties for the total expected finite horizon reward, were constructed under the assumptions of finite state-action spaces and irreducibility of the transition law. These policies prescribe that the choice of actions, at each state and time period, should be based on indices that are inflations of the right-hand side of the estimated average reward optimality equations.</p>
<h3 id="reinforcement-learning">Reinforcement learning</h3>

<p>If the probabilities or rewards are unknown, the problem is one of <a href="reinforcement_learning" title="wikilink">reinforcement learning</a> (Sutton and Barto, 1998).</p>

<p>For this purpose it is useful to define a further function, which corresponds to taking the action 

<math display="inline" id="Markov_decision_process:66">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 and then continuing optimally (or according to whatever policy one currently has):</p>

<p>

<math display="block" id="Markov_decision_process:67">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mpadded lspace="5pt" width="+5pt">
      <mi>Q</mi>
     </mpadded>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>s</mi>
      <mo>,</mo>
      <mi>a</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <msup>
       <mi>s</mi>
       <mo>′</mo>
      </msup>
     </munder>
     <mrow>
      <msub>
       <mi>P</mi>
       <mi>a</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>s</mi>
       <mo>,</mo>
       <msup>
        <mi>s</mi>
        <mo>′</mo>
       </msup>
       <mo stretchy="false">)</mo>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mrow>
         <msub>
          <mi>R</mi>
          <mi>a</mi>
         </msub>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>s</mi>
          <mo>,</mo>
          <msup>
           <mi>s</mi>
           <mo>′</mo>
          </msup>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>+</mo>
        <mrow>
         <mi>γ</mi>
         <mi>V</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <msup>
           <mi>s</mi>
           <mo>′</mo>
          </msup>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>Q</ci>
     <interval closure="open">
      <ci>s</ci>
      <ci>a</ci>
     </interval>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>s</ci>
       <ci>normal-′</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>P</ci>
       <ci>a</ci>
      </apply>
      <interval closure="open">
       <ci>s</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>s</ci>
        <ci>normal-′</ci>
       </apply>
      </interval>
      <apply>
       <plus></plus>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>R</ci>
         <ci>a</ci>
        </apply>
        <interval closure="open">
         <ci>s</ci>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>s</ci>
          <ci>normal-′</ci>
         </apply>
        </interval>
       </apply>
       <apply>
        <times></times>
        <ci>γ</ci>
        <ci>V</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>s</ci>
         <ci>normal-′</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ Q(s,a)=\sum_{s^{\prime}}P_{a}(s,s^{\prime})(R_{a}(s,s^{\prime})+\gamma V(s^{%
\prime})).
  </annotation>
 </semantics>
</math>

</p>

<p>While this function is also unknown, experience during learning is based on 

<math display="inline" id="Markov_decision_process:68">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>s</mi>
   <mo>,</mo>
   <mi>a</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>s</ci>
    <ci>a</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (s,a)
  </annotation>
 </semantics>
</math>


 pairs (together with the outcome 

<math display="inline" id="Markov_decision_process:69">
 <semantics>
  <msup>
   <mi>s</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>s</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s^{\prime}
  </annotation>
 </semantics>
</math>

); that is, "I was in state 

<math display="inline" id="Markov_decision_process:70">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

 and I tried doing 

<math display="inline" id="Markov_decision_process:71">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Markov_decision_process:72">
 <semantics>
  <msup>
   <mi>s</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>s</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s^{\prime}
  </annotation>
 </semantics>
</math>

 happened"). Thus, one has an array 

<math display="inline" id="Markov_decision_process:73">
 <semantics>
  <mi>Q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q
  </annotation>
 </semantics>
</math>


 and uses experience to update it directly. This is known as <a href="Q-learning" title="wikilink">Q‑learning</a>.</p>

<p>Reinforcement learning can solve Markov decision processes without explicit specification of the transition probabilities; the values of the transition probabilities are needed in value and policy iteration. In reinforcement learning, instead of explicit specification of the transition probabilities, the transition probabilities are accessed through a simulator that is typically restarted many times from a uniformly random initial state. Reinforcement learning can also be combined with function approximation to address problems with a very large number of states.</p>
<h3 id="category-theoretic-interpretation">Category theoretic interpretation</h3>

<p>Other than the rewards, a Markov decision process 

<math display="inline" id="Markov_decision_process:74">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>S</mi>
   <mo>,</mo>
   <mi>A</mi>
   <mo>,</mo>
   <mi>P</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <ci>S</ci>
    <ci>A</ci>
    <ci>P</ci>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (S,A,P)
  </annotation>
 </semantics>
</math>

 can be understood in terms of <a href="Category_theory" title="wikilink">Category theory</a>. Namely, let 

<math display="inline" id="Markov_decision_process:75">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒜</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒜</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{A}
  </annotation>
 </semantics>
</math>

 denote the <a href="free_monoid" title="wikilink">free monoid</a> with generating set <em>A</em>. Let <strong>Dist</strong> denote the <a href="Kleisli_category" title="wikilink">Kleisli category</a> of the <a href="http://ncatlab.org/nlab/show/Giry+monad">Giry monad</a>. Then a functor 

<math display="inline" id="Markov_decision_process:76">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">𝒜</mi>
   <mo>→</mo>
   <mi>𝐃𝐢𝐬𝐭</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>𝒜</ci>
    <ci>𝐃𝐢𝐬𝐭</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{A}\to\mathbf{Dist}
  </annotation>
 </semantics>
</math>

 encodes both the set <em>S</em> of states and the probability function <em>P</em>.</p>

<p>In this way, Markov decision processes could be generalized from monoids (categories with one object) to arbitrary categories. One can call the result 

<math display="inline" id="Markov_decision_process:77">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi class="ltx_font_mathcaligraphic">𝒞</mi>
   <mo>,</mo>
   <mi>F</mi>
   <mo>:</mo>
   <mi class="ltx_font_mathcaligraphic">𝒞</mi>
   <mo>→</mo>
   <mi>𝐃𝐢𝐬𝐭</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-(</ci>
    <csymbol cd="unknown">C</csymbol>
    <ci>normal-,</ci>
    <csymbol cd="unknown">F</csymbol>
    <ci>normal-:</ci>
    <csymbol cd="unknown">C</csymbol>
    <ci>normal-→</ci>
    <csymbol cd="unknown">Dist</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\mathcal{C},F:\mathcal{C}\to\mathbf{Dist}
  </annotation>
 </semantics>
</math>

 a <em>context-dependent Markov decision process</em>, because moving from one object to another in 

<math display="inline" id="Markov_decision_process:78">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒞</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒞</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{C}
  </annotation>
 </semantics>
</math>


 changes the set of available actions and the set of possible states.</p>
<h2 id="continuous-time-markov-decision-process">Continuous-time Markov Decision Process</h2>

<p>In discrete-time Markov Decision Processes, decisions are made at discrete time intervals. However, for <strong>Continuous-time Markov Decision Processes</strong>, decisions can be made at any time the decision maker chooses. In comparison to discrete-time Markov Decision Process, Continuous-time Markov Decision Process can better model the decision making process for a system that has <a href="Continuous_time" title="wikilink">continuous dynamics</a>, i.e., the system dynamics is defined by <a href="partial_differential_equation" title="wikilink">partial differential equations</a> (PDEs).</p>
<h3 id="definition-1">Definition</h3>

<p>In order to discuss the continuous-time Markov Decision Process, we introduce two sets of notations:</p>

<p>If the state space and action space are finite,</p>
<ul>
<li>

<math display="inline" id="Markov_decision_process:79">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒮</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒮</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{S}
  </annotation>
 </semantics>
</math>

: State space;</li>
<li>

<math display="inline" id="Markov_decision_process:80">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒜</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒜</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{A}
  </annotation>
 </semantics>
</math>

: Action space;</li>
<li>

<math display="inline" id="Markov_decision_process:81">
 <semantics>
  <mrow>
   <mi>q</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>i</mi>
    <mo stretchy="false">|</mo>
    <mi>j</mi>
    <mo>,</mo>
    <mi>a</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">q</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">i</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">j</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">a</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q(i|j,a)
  </annotation>
 </semantics>
</math>



<math display="block" id="Markov_decision_process:82">
 <semantics>
  <mrow>
   <mrow>
    <mi class="ltx_font_mathcaligraphic">𝒮</mi>
    <mo>×</mo>
    <mi class="ltx_font_mathcaligraphic">𝒜</mi>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mi mathvariant="normal">△</mi>
    <mi class="ltx_font_mathcaligraphic">𝒮</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <times></times>
     <ci>𝒮</ci>
     <ci>𝒜</ci>
    </apply>
    <apply>
     <times></times>
     <ci>normal-△</ci>
     <ci>𝒮</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{S}\times\mathcal{A}\rightarrow\triangle\mathcal{S}
  </annotation>
 </semantics>
</math>

, transition rate function;</li>
<li>

<math display="inline" id="Markov_decision_process:83">
 <semantics>
  <mrow>
   <mi>R</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>i</mi>
    <mo>,</mo>
    <mi>a</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>R</ci>
    <interval closure="open">
     <ci>i</ci>
     <ci>a</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R(i,a)
  </annotation>
 </semantics>
</math>




<math display="block" id="Markov_decision_process:84">
 <semantics>
  <mrow>
   <mrow>
    <mi class="ltx_font_mathcaligraphic">𝒮</mi>
    <mo>×</mo>
    <mi class="ltx_font_mathcaligraphic">𝒜</mi>
   </mrow>
   <mo>→</mo>
   <mi>ℝ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <times></times>
     <ci>𝒮</ci>
     <ci>𝒜</ci>
    </apply>
    <ci>ℝ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{S}\times\mathcal{A}\rightarrow\mathbb{R}
  </annotation>
 </semantics>
</math>

, a reward function.</li>
</ul>

<p>If the state space and action space are continuous,</p>
<ul>
<li>

<math display="inline" id="Markov_decision_process:85">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒳</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒳</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{X}
  </annotation>
 </semantics>
</math>

: State space.;</li>
<li>

<math display="inline" id="Markov_decision_process:86">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒰</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒰</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{U}
  </annotation>
 </semantics>
</math>

: Space of possible control;</li>
<li>

<math display="inline" id="Markov_decision_process:87">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>u</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <interval closure="open">
     <ci>x</ci>
     <ci>u</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x,u)
  </annotation>
 </semantics>
</math>



<math display="block" id="Markov_decision_process:88">
 <semantics>
  <mrow>
   <mrow>
    <mi class="ltx_font_mathcaligraphic">𝒳</mi>
    <mo>×</mo>
    <mi class="ltx_font_mathcaligraphic">𝒰</mi>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mi mathvariant="normal">△</mi>
    <mi class="ltx_font_mathcaligraphic">𝒳</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <times></times>
     <ci>𝒳</ci>
     <ci>𝒰</ci>
    </apply>
    <apply>
     <times></times>
     <ci>normal-△</ci>
     <ci>𝒳</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{X}\times\mathcal{U}\rightarrow\triangle\mathcal{X}
  </annotation>
 </semantics>
</math>

, a transition rate function;</li>
<li>

<math display="inline" id="Markov_decision_process:89">
 <semantics>
  <mrow>
   <mi>r</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>u</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>r</ci>
    <interval closure="open">
     <ci>x</ci>
     <ci>u</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r(x,u)
  </annotation>
 </semantics>
</math>



<math display="block" id="Markov_decision_process:90">
 <semantics>
  <mrow>
   <mrow>
    <mi class="ltx_font_mathcaligraphic">𝒳</mi>
    <mo>×</mo>
    <mi class="ltx_font_mathcaligraphic">𝒰</mi>
   </mrow>
   <mo>→</mo>
   <mi>ℝ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <times></times>
     <ci>𝒳</ci>
     <ci>𝒰</ci>
    </apply>
    <ci>ℝ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{X}\times\mathcal{U}\rightarrow\mathbb{R}
  </annotation>
 </semantics>
</math>

, a reward rate function such that 

<math display="inline" id="Markov_decision_process:91">
 <semantics>
  <mrow>
   <mrow>
    <mi>r</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>x</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mi>u</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>d</mi>
    <mi>t</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>d</mi>
    <mi>R</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>x</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mi>u</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>r</ci>
     <interval closure="open">
      <apply>
       <times></times>
       <ci>x</ci>
       <ci>t</ci>
      </apply>
      <apply>
       <times></times>
       <ci>u</ci>
       <ci>t</ci>
      </apply>
     </interval>
     <ci>d</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <times></times>
     <ci>d</ci>
     <ci>R</ci>
     <interval closure="open">
      <apply>
       <times></times>
       <ci>x</ci>
       <ci>t</ci>
      </apply>
      <apply>
       <times></times>
       <ci>u</ci>
       <ci>t</ci>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r(x(t),u(t))dt=dR(x(t),u(t))
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Markov_decision_process:92">
 <semantics>
  <mrow>
   <mi>R</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>u</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>R</ci>
    <interval closure="open">
     <ci>x</ci>
     <ci>u</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R(x,u)
  </annotation>
 </semantics>
</math>

 is the reward function we discussed in previous case.</li>
</ul>
<h3 id="problem-1">Problem</h3>

<p>Like the Discrete-time Markov Decision Processes, in Continuous-time Markov Decision Process we want to find the optimal <em>policy</em> or <em>control</em> which could give us the optimal expected integrated reward:</p>

<p>

<math display="block" id="Markov_decision_process:93">
 <semantics>
  <mrow>
   <mi>m</mi>
   <mi>a</mi>
   <mi>x</mi>
   <msub>
    <mi>𝔼</mi>
    <mi>u</mi>
   </msub>
   <mrow>
    <mo stretchy="false">[</mo>
    <msubsup>
     <mo largeop="true" symmetric="true">∫</mo>
     <mn>0</mn>
     <mi mathvariant="normal">∞</mi>
    </msubsup>
    <msup>
     <mi>γ</mi>
     <mi>t</mi>
    </msup>
    <mi>r</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>,</mo>
     <mi>u</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi>d</mi>
   <mi>t</mi>
   <mo stretchy="false">|</mo>
   <msub>
    <mi>x</mi>
    <mn>0</mn>
   </msub>
   <mo stretchy="false">]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">m</csymbol>
    <csymbol cd="unknown">a</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <ci></ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝔼</ci>
     <ci>u</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <int></int>
       <cn type="integer">0</cn>
      </apply>
      <infinity></infinity>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>γ</ci>
      <ci>t</ci>
     </apply>
     <csymbol cd="unknown">r</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">t</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-,</ci>
      <csymbol cd="unknown">u</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">t</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">d</csymbol>
    <csymbol cd="unknown">t</csymbol>
    <ci>normal-|</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">0</cn>
    </apply>
    <ci>normal-]</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   max\quad\mathbb{E}_{u}[\int_{0}^{\infty}\gamma^{t}r(x(t),u(t)))dt|x_{0}]
  </annotation>
 </semantics>
</math>

 Where 

<math display="inline" id="Markov_decision_process:94">
 <semantics>
  <mrow>
   <mn>0</mn>
   <mo>≤</mo>
   <mi>γ</mi>
   <mo><</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <cn type="integer">0</cn>
     <ci>γ</ci>
    </apply>
    <apply>
     <lt></lt>
     <share href="#.cmml">
     </share>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0\leq\gamma<1
  </annotation>
 </semantics>
</math>

</p>
<h3 id="linear-programming-formulation">Linear programming formulation</h3>

<p>If the state space and action space are finite, we could use linear programming to find the optimal policy, which was one of the earliest approaches applied. Here we only consider the ergodic model, which means our continuous-time MDP becomes an <a href="Ergodicity" title="wikilink">ergodic</a> continuous-time Markov Chain under a stationary <a class="uri" href="policy" title="wikilink">policy</a>. Under this assumption, although the decision maker can make a decision at any time at the current state, he could not benefit more by taking more than one action. It is better for him to take an action only at the time when system is transitioning from the current state to another state. Under some conditions,(for detail check Corollary 3.14 of <a href="http://www.springer.com/mathematics/applications/book/978-3-642-02546-4"><em>Continuous-Time Markov Decision Processes</em></a>), if our optimal value function 

<math display="inline" id="Markov_decision_process:95">
 <semantics>
  <msup>
   <mi>V</mi>
   <mo>*</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>V</ci>
    <times></times>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V^{*}
  </annotation>
 </semantics>
</math>

 is independent of state i, we will have the following inequality:</p>

<p>

<math display="block" id="Markov_decision_process:96">
 <semantics>
  <mrow>
   <mi>g</mi>
   <mo>≥</mo>
   <mi>R</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>i</mi>
    <mo>,</mo>
    <mi>a</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>+</mo>
   <munder>
    <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
    <mrow>
     <mi>j</mi>
     <mo>∈</mo>
     <mi>S</mi>
    </mrow>
   </munder>
   <mi>q</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>j</mi>
    <mo stretchy="false">|</mo>
    <mi>i</mi>
    <mo>,</mo>
    <mi>a</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi>h</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>j</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∀</mo>
   <mi>i</mi>
   <mo>∈</mo>
   <mpadded width="+3.4pt">
    <mi>S</mi>
   </mpadded>
   <mi>a</mi>
   <mi>n</mi>
   <mpadded width="+3.4pt">
    <mi>d</mi>
   </mpadded>
   <mi>a</mi>
   <mo>∈</mo>
   <mi>A</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>i</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">g</csymbol>
    <geq></geq>
    <csymbol cd="unknown">R</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">i</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">a</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <plus></plus>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <sum></sum>
     <apply>
      <in></in>
      <ci>j</ci>
      <ci>S</ci>
     </apply>
    </apply>
    <csymbol cd="unknown">q</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">j</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">i</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">a</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">h</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">j</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci></ci>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">i</csymbol>
    <in></in>
    <csymbol cd="unknown">S</csymbol>
    <csymbol cd="unknown">a</csymbol>
    <csymbol cd="unknown">n</csymbol>
    <csymbol cd="unknown">d</csymbol>
    <csymbol cd="unknown">a</csymbol>
    <in></in>
    <csymbol cd="unknown">A</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">i</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g\geq R(i,a)+\sum_{j\in S}q(j|i,a)h(j)\quad\forall i\in S\,\,and\,\,a\in A(i)
  </annotation>
 </semantics>
</math>

 If there exists a function 

<math display="inline" id="Markov_decision_process:97">
 <semantics>
  <mi>h</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>h</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h
  </annotation>
 </semantics>
</math>

, then 

<math display="inline" id="Markov_decision_process:98">
 <semantics>
  <msup>
   <mover accent="true">
    <mi>V</mi>
    <mo stretchy="false">¯</mo>
   </mover>
   <mo>*</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <ci>normal-¯</ci>
     <ci>V</ci>
    </apply>
    <times></times>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bar{V}^{*}
  </annotation>
 </semantics>
</math>

 will be the smallest g satisfying the above equation. In order to find 

<math display="inline" id="Markov_decision_process:99">
 <semantics>
  <msup>
   <mover accent="true">
    <mi>V</mi>
    <mo stretchy="false">¯</mo>
   </mover>
   <mo>*</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <ci>normal-¯</ci>
     <ci>V</ci>
    </apply>
    <times></times>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bar{V}^{*}
  </annotation>
 </semantics>
</math>

, we could use the following linear programming model:</p>
<ul>
<li>Primal linear program(P-LP)</li>
</ul>

<p>

<math display="inline" id="Markov_decision_process:100">
 <semantics>
  <mrow>
   <mi>g</mi>
   <mo>;</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <ci>g</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle g;
  </annotation>
 </semantics>
</math>


</p>
<ul>
<li>Dual linear program(D-LP)</li>
</ul>

<p>

<math display="inline" id="Markov_decision_process:101">
 <semantics>
  <mrow>
   <mstyle displaystyle="true">
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>i</mi>
      <mo>∈</mo>
      <mi>S</mi>
     </mrow>
    </munder>
   </mstyle>
   <mrow>
    <mstyle displaystyle="true">
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>a</mi>
       <mo>∈</mo>
       <mrow>
        <mi>A</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>i</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
     </munder>
    </mstyle>
    <mrow>
     <mi>R</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>i</mi>
      <mo>,</mo>
      <mi>a</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>y</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>i</mi>
      <mo>,</mo>
      <mi>a</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <sum></sum>
     <apply>
      <in></in>
      <ci>i</ci>
      <ci>S</ci>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <in></in>
       <ci>a</ci>
       <apply>
        <times></times>
        <ci>A</ci>
        <ci>i</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>R</ci>
      <interval closure="open">
       <ci>i</ci>
       <ci>a</ci>
      </interval>
      <ci>y</ci>
      <interval closure="open">
       <ci>i</ci>
       <ci>a</ci>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle\sum_{i\in S}\sum_{a\in A(i)}R(i,a)y(i,a)
  </annotation>
 </semantics>
</math>


 

<math display="inline" id="Markov_decision_process:102">
 <semantics>
  <mrow>
   <mi>y</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>i</mi>
    <mo>,</mo>
    <mi>a</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>y</ci>
    <interval closure="open">
     <ci>i</ci>
     <ci>a</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y(i,a)
  </annotation>
 </semantics>
</math>

 is a feasible solution to the D-LP if 

<math display="inline" id="Markov_decision_process:103">
 <semantics>
  <mrow>
   <mi>y</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>i</mi>
    <mo>,</mo>
    <mi>a</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>y</ci>
    <interval closure="open">
     <ci>i</ci>
     <ci>a</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y(i,a)
  </annotation>
 </semantics>
</math>

 is nonnative and satisfied the constraints in the D-LP problem. A feasible solution 

<math display="inline" id="Markov_decision_process:104">
 <semantics>
  <mrow>
   <msup>
    <mi>y</mi>
    <mo>*</mo>
   </msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>i</mi>
    <mo>,</mo>
    <mi>a</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>y</ci>
     <times></times>
    </apply>
    <interval closure="open">
     <ci>i</ci>
     <ci>a</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y^{*}(i,a)
  </annotation>
 </semantics>
</math>

 to the D-LP is said to be an optimal solution if</p>

<p>

<math display="inline" id="Markov_decision_process:105">
 <semantics>
  <mrow>
   <mrow>
    <mstyle displaystyle="true">
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>i</mi>
       <mo>∈</mo>
       <mi>S</mi>
      </mrow>
     </munder>
    </mstyle>
    <mrow>
     <mstyle displaystyle="true">
      <munder>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mrow>
        <mi>a</mi>
        <mo>∈</mo>
        <mrow>
         <mi>A</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>i</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
      </munder>
     </mstyle>
     <mrow>
      <mi>R</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>i</mi>
       <mo>,</mo>
       <mi>a</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <msup>
       <mi>y</mi>
       <mo>*</mo>
      </msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>i</mi>
       <mo>,</mo>
       <mi>a</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>≥</mo>
   <mrow>
    <mstyle displaystyle="true">
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>i</mi>
       <mo>∈</mo>
       <mi>S</mi>
      </mrow>
     </munder>
    </mstyle>
    <mrow>
     <mstyle displaystyle="true">
      <munder>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mrow>
        <mi>a</mi>
        <mo>∈</mo>
        <mrow>
         <mi>A</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>i</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
      </munder>
     </mstyle>
     <mrow>
      <mi>R</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>i</mi>
       <mo>,</mo>
       <mi>a</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>y</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>i</mi>
       <mo>,</mo>
       <mi>a</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <in></in>
       <ci>i</ci>
       <ci>S</ci>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <in></in>
        <ci>a</ci>
        <apply>
         <times></times>
         <ci>A</ci>
         <ci>i</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>R</ci>
       <interval closure="open">
        <ci>i</ci>
        <ci>a</ci>
       </interval>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>y</ci>
        <times></times>
       </apply>
       <interval closure="open">
        <ci>i</ci>
        <ci>a</ci>
       </interval>
      </apply>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <in></in>
       <ci>i</ci>
       <ci>S</ci>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <in></in>
        <ci>a</ci>
        <apply>
         <times></times>
         <ci>A</ci>
         <ci>i</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>R</ci>
       <interval closure="open">
        <ci>i</ci>
        <ci>a</ci>
       </interval>
       <ci>y</ci>
       <interval closure="open">
        <ci>i</ci>
        <ci>a</ci>
       </interval>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle\sum_{i\in S}\sum_{a\in A(i)}R(i,a)y^{*}(i,a)\geq\sum_{i\in S}%
\sum_{a\in A(i)}R(i,a)y(i,a)
  </annotation>
 </semantics>
</math>


 for all feasible solution y(i,a) to the D-LP. Once we found the optimal solution 

<math display="inline" id="Markov_decision_process:106">
 <semantics>
  <mrow>
   <msup>
    <mi>y</mi>
    <mo>*</mo>
   </msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>i</mi>
    <mo>,</mo>
    <mi>a</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>y</ci>
     <times></times>
    </apply>
    <interval closure="open">
     <ci>i</ci>
     <ci>a</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y^{*}(i,a)
  </annotation>
 </semantics>
</math>

, we could use those optimal solution to establish the optimal policies.</p>
<h3 id="hamilton-jacobi-bellman-equation">Hamilton-Jacobi-Bellman equation</h3>

<p>In continuous-time MDP, if the state space and action space are continuous, the optimal criterion could be found by solving Hamilton-Jacobi-Bellman (HJB) partial differential equation. In order to discuss the HJB equation, we need to reformulate our problem</p>

<p>

<math display="inline" id="Markov_decision_process:107">
 <semantics>
  <mrow>
   <mrow>
    <mi>V</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>x</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mn>0</mn>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mn>0</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi></mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>V</ci>
     <interval closure="open">
      <apply>
       <times></times>
       <ci>x</ci>
       <cn type="integer">0</cn>
      </apply>
      <cn type="integer">0</cn>
     </interval>
    </apply>
    <csymbol cd="latexml">absent</csymbol>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle V(x(0),0)=
  </annotation>
 </semantics>
</math>


</p>

<p>D(

<math display="inline" id="Markov_decision_process:108">
 <semantics>
  <mo>⋅</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-⋅</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \cdot
  </annotation>
 </semantics>
</math>

) is the terminal reward function, 

<math display="inline" id="Markov_decision_process:109">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>x</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x(t)
  </annotation>
 </semantics>
</math>

 is the system state vector, 

<math display="inline" id="Markov_decision_process:110">
 <semantics>
  <mrow>
   <mi>u</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>u</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u(t)
  </annotation>
 </semantics>
</math>

 is the system control vector we try to find. f(

<math display="inline" id="Markov_decision_process:111">
 <semantics>
  <mo>⋅</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-⋅</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \cdot
  </annotation>
 </semantics>
</math>

) shows how the state vector change over time. Hamilton-Jacobi-Bellman equation is as follows:</p>

<p>

<math display="block" id="Markov_decision_process:112">
 <semantics>
  <mrow>
   <mn>0</mn>
   <mo>=</mo>
   <mrow>
    <msub>
     <mtext>max</mtext>
     <mi>u</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mi>r</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>t</mi>
        <mo>,</mo>
        <mi>x</mi>
        <mo>,</mo>
        <mi>u</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>+</mo>
      <mrow>
       <mfrac>
        <mrow>
         <mrow>
          <mo>∂</mo>
          <mi>V</mi>
         </mrow>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>t</mi>
          <mo>,</mo>
          <mi>x</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mrow>
         <mo>∂</mo>
         <mi>x</mi>
        </mrow>
       </mfrac>
       <mi>f</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>t</mi>
        <mo>,</mo>
        <mi>x</mi>
        <mo>,</mo>
        <mi>u</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <cn type="integer">0</cn>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <mtext>max</mtext>
      <ci>u</ci>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>r</ci>
       <vector>
        <ci>t</ci>
        <ci>x</ci>
        <ci>u</ci>
       </vector>
      </apply>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <apply>
         <times></times>
         <apply>
          <partialdiff></partialdiff>
          <ci>V</ci>
         </apply>
         <interval closure="open">
          <ci>t</ci>
          <ci>x</ci>
         </interval>
        </apply>
        <apply>
         <partialdiff></partialdiff>
         <ci>x</ci>
        </apply>
       </apply>
       <ci>f</ci>
       <vector>
        <ci>t</ci>
        <ci>x</ci>
        <ci>u</ci>
       </vector>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0=\text{max}_{u}(r(t,x,u)+\frac{\partial V(t,x)}{\partial x}f(t,x,u))
  </annotation>
 </semantics>
</math>

 We could solve the equation to find the optimal control 

<math display="inline" id="Markov_decision_process:113">
 <semantics>
  <mrow>
   <mi>u</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>u</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u(t)
  </annotation>
 </semantics>
</math>

, which could give us the optimal value 

<math display="inline" id="Markov_decision_process:114">
 <semantics>
  <msup>
   <mi>V</mi>
   <mo>*</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>V</ci>
    <times></times>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V^{*}
  </annotation>
 </semantics>
</math>

</p>
<h3 id="application">Application</h3>

<p>Continuous-time Markov decision processes have applications in queueing systems, epidemic processes, and <a href="population_process" title="wikilink">population processes</a>.</p>
<h2 id="alternative-notations">Alternative notations</h2>

<p>The terminology and notation for MDPs are not entirely settled. There are two main streams — one focuses on maximization problems from contexts like economics, using the terms action, reward, value, and calling the discount factor 

<math display="inline" id="Markov_decision_process:115">
 <semantics>
  <mi>β</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>β</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta
  </annotation>
 </semantics>
</math>

 or 

<math display="inline" id="Markov_decision_process:116">
 <semantics>
  <mi>γ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>γ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gamma
  </annotation>
 </semantics>
</math>

, while the other focuses on minimization problems from engineering and navigation, using the terms control, cost, cost-to-go, and calling the discount factor 

<math display="inline" id="Markov_decision_process:117">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>

. In addition, the notation for the transition probability varies.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>in this article</p></th>
<th style="text-align: left;">
<p>alternative</p></th>
<th style="text-align: left;">
<p>comment</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>action 

<math display="inline" id="Markov_decision_process:118">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>control 

<math display="inline" id="Markov_decision_process:119">
 <semantics>
  <mi>u</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>u</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>reward 

<math display="inline" id="Markov_decision_process:120">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>cost 

<math display="inline" id="Markov_decision_process:121">
 <semantics>
  <mi>g</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>g</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Markov_decision_process:122">
 <semantics>
  <mi>g</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>g</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g
  </annotation>
 </semantics>
</math>

 is the negative of 

<math display="inline" id="Markov_decision_process:123">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>value 

<math display="inline" id="Markov_decision_process:124">
 <semantics>
  <mi>V</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>V</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>cost-to-go 

<math display="inline" id="Markov_decision_process:125">
 <semantics>
  <mi>J</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>J</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   J
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Markov_decision_process:126">
 <semantics>
  <mi>J</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>J</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   J
  </annotation>
 </semantics>
</math>

 is the negative of 

<math display="inline" id="Markov_decision_process:127">
 <semantics>
  <mi>V</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>V</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>policy 

<math display="inline" id="Markov_decision_process:128">
 <semantics>
  <mi>π</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>π</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>policy 

<math display="inline" id="Markov_decision_process:129">
 <semantics>
  <mi>μ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>μ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>discounting factor 

<math display="inline" id="Markov_decision_process:130">
 <semantics>
  <mpadded lspace="5pt" width="+5pt">
   <mi>γ</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>γ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ \gamma
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>discounting factor 

<math display="inline" id="Markov_decision_process:131">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>transition probability 

<math display="inline" id="Markov_decision_process:132">
 <semantics>
  <mrow>
   <msub>
    <mi>P</mi>
    <mi>a</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>s</mi>
    <mo>,</mo>
    <msup>
     <mi>s</mi>
     <mo>′</mo>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>P</ci>
     <ci>a</ci>
    </apply>
    <interval closure="open">
     <ci>s</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>s</ci>
      <ci>normal-′</ci>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{a}(s,s^{\prime})
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>transition probability 

<math display="inline" id="Markov_decision_process:133">
 <semantics>
  <mrow>
   <msub>
    <mi>p</mi>
    <mrow>
     <mi>s</mi>
     <msup>
      <mi>s</mi>
      <mo>′</mo>
     </msup>
    </mrow>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>a</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>p</ci>
     <apply>
      <times></times>
      <ci>s</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>s</ci>
       <ci>normal-′</ci>
      </apply>
     </apply>
    </apply>
    <ci>a</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{ss^{\prime}}(a)
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>

<p>In addition, transition probability is sometimes written 

<math display="inline" id="Markov_decision_process:134">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mi>r</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>s</mi>
    <mo>,</mo>
    <mi>a</mi>
    <mo>,</mo>
    <msup>
     <mi>s</mi>
     <mo>′</mo>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <ci>r</ci>
    <vector>
     <ci>s</ci>
     <ci>a</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>s</ci>
      <ci>normal-′</ci>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Pr(s,a,s^{\prime})
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Markov_decision_process:135">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mi>r</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>s</mi>
     <mo>′</mo>
    </msup>
    <mo stretchy="false">|</mo>
    <mi>s</mi>
    <mo>,</mo>
    <mi>a</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <csymbol cd="unknown">r</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>s</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>normal-|</ci>
     <csymbol cd="unknown">s</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">a</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Pr(s^{\prime}|s,a)
  </annotation>
 </semantics>
</math>

 or, rarely, 

<math display="inline" id="Markov_decision_process:136">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>p</mi>
     <mrow>
      <msup>
       <mi>s</mi>
       <mo>′</mo>
      </msup>
      <mi>s</mi>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>a</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>p</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>s</ci>
       <ci>normal-′</ci>
      </apply>
      <ci>s</ci>
     </apply>
    </apply>
    <ci>a</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{s^{\prime}s}(a).
  </annotation>
 </semantics>
</math>

</p>
<h2 id="constrained-markov-decision-processes">Constrained Markov Decision Processes</h2>

<p>Constrained Markov Decision Processes (CMDPs) are extensions to Markov Decision Process(MDPs). There are three fundamental differences between MDPs and CMDPs.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>
<ul>
<li>There are multiple costs incurred after applying an action instead of one.</li>
<li>CMDPs are solved with Linear Programs only, and Dynamic programming does not work.</li>
<li>The final policy is dependant of the starting state.</li>
</ul>

<p>There are lots of applications for CMDP. It is recently being used in motion planning scenarios in robotics. <a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Probabilistic_automata" title="wikilink">Probabilistic automata</a></li>
<li><a href="Quantum_finite_automata" title="wikilink">Quantum finite automata</a></li>
<li><a href="Partially_observable_Markov_decision_process" title="wikilink">Partially observable Markov decision process</a></li>
<li><a href="Dynamic_programming" title="wikilink">Dynamic programming</a></li>
<li><a href="Bellman_equation" title="wikilink">Bellman equation</a> for applications to economics.</li>
<li><a href="Hamilton–Jacobi–Bellman_equation" title="wikilink">Hamilton–Jacobi–Bellman equation</a></li>
<li><a href="Optimal_control" title="wikilink">Optimal control</a></li>
<li><a href="Recursive_economics" title="wikilink">Recursive economics</a></li>
<li><a href="Mabinogion_sheep_problem" title="wikilink">Mabinogion sheep problem</a></li>
<li><a href="Stochastic_games" title="wikilink">Stochastic games</a></li>
<li><a class="uri" href="Q-learning" title="wikilink">Q-learning</a></li>
</ul>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<ul>
<li>R. Bellman. <a href="http://www.iumj.indiana.edu/IUMJ/FULLTEXT/1957/6/56038"><em>A Markovian Decision Process</em></a>. Journal of Mathematics and Mechanics 6, 1957.</li>
<li>R. E. Bellman. <em>Dynamic Programming</em>. Princeton University Press, Princeton, NJ, 1957. Dover paperback edition (2003), ISBN 0-486-42809-5.</li>
<li>Ronald A. Howard <em>Dynamic Programming and Markov Processes</em>, The M.I.T. Press, 1960.</li>
<li>D. Bertsekas. Dynamic Programming and Optimal Control. Volume 2, Athena, MA, 1995.</li>
<li>Burnetas, A.N. and M. N. Katehakis. "Optimal Adaptive Policies for Markov Decision Processes'', Mathematics of Operations Research, 22,(1), 1995.</li>
<li>E.A. Feinberg and A. Shwartz (eds.) Handbook of Markov Decision Processes, Kluwer, Boston, MA, 2002.</li>
<li>C. Derman. <em>Finite state Markovian decision processes</em>, Academic Press, 1970.</li>
<li>M. L. Puterman. <em>Markov Decision Processes</em>. Wiley, 1994.</li>
<li>H.C. Tijms. <em>A First Course in Stochastic Models</em>. Wiley, 2003.</li>
<li>Sutton, R. S. and Barto A. G. <em>Reinforcement Learning: An Introduction</em>. The MIT Press, Cambridge, MA, 1998.</li>
<li>J.A. E. E van Nunen. A set of successive approximation methods for discounted Markovian decision problems. Z. Operations Research, 20:203-208, 1976.</li>
<li>S. P. Meyn, 2007. <a href="https://netfiles.uiuc.edu/meyn/www/spm_files/CTCN/CTCN.html">Control Techniques for Complex Networks</a>, Cambridge University Press, 2007. ISBN 978-0-521-88441-9. Appendix contains abridged <a href="https://netfiles.uiuc.edu/meyn/www/spm_files/book.html">Meyn &amp; Tweedie</a>.</li>
<li>S. M. Ross. 1983. Introduction to stochastic dynamic programming. Academic press</li>
<li>X. Guo and O. Hernández-Lerma. <a href="http://www.springer.com/mathematics/applications/book/978-3-642-02546-4"><em>Continuous-Time Markov Decision Processes</em></a>, Springer, 2009.</li>
<li>M. L. Puterman and Shin M. C. Modified Policy Iteration Algorithms for Discounted Markov Decision Problems, <em>Management Science</em> 24, 1978.</li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.ai.mit.edu/~murphyk/Software/MDP/mdp.html">MDP Toolbox for Matlab</a> - An excellent tutorial and Matlab toolbox for working with MDPs.</li>
<li><a href="https://pypi.python.org/pypi/pymdptoolbox">MDP Toolbox for Python</a> A package for solving MDPs</li>
<li><a href="http://www.cs.ualberta.ca/~sutton/book/ebook">Reinforcement Learning</a> An Introduction by Richard S. Sutton and Andrew G. Barto</li>
<li><a href="http://www.cs.uwaterloo.ca/~jhoey/research/spudd/index.php">SPUDD</a> A structured MDP solver for download by Jesse Hoey</li>
<li><a href="http://www.eecs.umich.edu/~baveja/Papers/Thesis.ps.gz">Learning to Solve Markovian Decision Processes</a> by <a href="http://www.eecs.umich.edu/~baveja/">Satinder P. Singh</a></li>
<li><a href="http://www.jstor.org/stable/3690147">Optimal Adaptive Policies for Markov Decision Processes</a> by Burnetas and Katehakis (1997).</li>
</ul>

<p>"</p>

<p><a href="Category:Optimal_decisions" title="wikilink">Category:Optimal decisions</a> <a href="Category:Dynamic_programming" title="wikilink">Category:Dynamic programming</a> <a href="Category:Markov_processes" title="wikilink">Category:Markov processes</a> <a href="Category:Stochastic_control" title="wikilink">Category:Stochastic control</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Lodewijk Kallenberg, <em>Finite state and action MDPs</em>, in Eugene A. Feinberg, Adam Shwartz (eds.) <em>Handbook of Markov decision processes: methods and applications</em>, Springer, 2002, ISBN 0-7923-7459-2<a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3">Altman, Eitan. Constrained Markov decision processes. Vol. 7. CRC Press, 1999.<a href="#fnref3">↩</a></li>
<li id="fn4">Feyzabadi, S.; Carpin, S., "Risk-aware path planning using hierarchical constrained Markov Decision Processes," Automation Science and Engineering (CASE), 2014 IEEE International Conference on , vol., no., pp.297,303, 18-22 Aug. 2014<a href="#fnref4">↩</a></li>
</ol>
</section>
</body>
</html>
