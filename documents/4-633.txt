   System F      System F   System F , also known as the (Girardâ€“Reynolds) polymorphic lambda calculus or the second-order lambda calculus , is a typed lambda calculus that differs from the simply typed lambda calculus by the introduction of a mechanism of universal quantification over types. System F thus formalizes the notion of parametric polymorphism in programming languages , and forms a theoretical basis for languages such as Haskell and ML . System F was discovered independently by logician  Jean-Yves Girard (1972) and computer scientist  John C. Reynolds (1974).  Whereas simply typed lambda calculus has variables ranging over functions, and binders for them, System F additionally has variables ranging over types , and binders for them. As an example, the fact that the identity function can have any type of the form Aâ†’ A would be formalized in System F as the judgment      âŠ¢  Î›  Î±  .  Î»   x  Î±   .  x  :  âˆ€  Î±  .  Î±  â†’  Î±     fragments  proves  Î›  Î±  normal-.  Î»   superscript  x  Î±   normal-.  x  normal-:  for-all  Î±  normal-.  Î±  normal-â†’  Î±    \vdash\Lambda\alpha.\lambda x^{\alpha}.x:\forall\alpha.\alpha\to\alpha     where   Î±   Î±   \alpha   is a type variable . The upper-case   Î›   normal-Î›   \Lambda   is traditionally used to denote type-level functions, as opposed to the lower-case   Î»   Î»   \lambda   which is used for value-level functions. (The superscripted   Î±   Î±   \alpha   means that the bound x is of type   Î±   Î±   \alpha   ; the expression after the colon is the type of the lambda expression preceding it.)  As a term rewriting system , System F is strongly normalizing . However, type inference in System F (without explicit type annotations) is undecidable. Under the Curryâ€“Howard isomorphism , System F corresponds to the fragment of second-order intuitionistic logic that uses only universal quantification. System F can be seen as part of the lambda cube , together with even more expressive typed lambda calculi, including those with dependent types .  Logic and predicates  The   ğ–¡ğ—ˆğ—ˆğ—…ğ–¾ğ–ºğ—‡   ğ–¡ğ—ˆğ—ˆğ—…ğ–¾ğ–ºğ—‡   \scriptstyle\mathsf{Boolean}   type is defined as:     âˆ€  Î±   .   Î±  â†’  Î±  â†’  Î±      formulae-sequence   for-all  Î±      normal-â†’  Î±  Î±    normal-â†’    Î±      \scriptstyle\forall\alpha.\alpha\to\alpha\to\alpha   , where   Î±   Î±   \scriptstyle\alpha   is a type variable . This means   ğ–¡ğ—ˆğ—ˆğ—…ğ–¾ğ–ºğ—‡   ğ–¡ğ—ˆğ—ˆğ—…ğ–¾ğ–ºğ—‡   \scriptstyle\mathsf{Boolean}   is the type of all functions which take as input a type Î± and two expressions of type Î±, and produce as output an expression of type Î± (note that we consider   â†’   normal-â†’   \to   to be right-associative.)  The following two definitions for the boolean values   ğ“   ğ“   \scriptstyle\mathbf{T}   and   ğ…   ğ…   \scriptstyle\mathbf{F}   are used, extending the definition of Church booleans :       ğ“  =   Î›  Î±    .   Î»   x  Î±   Î»   y  Î±    .  x     formulae-sequence    ğ“    normal-Î›  Î±      Î»   superscript  x  Î±   Î»   superscript  y  Î±    x    \mathbf{T}=\Lambda\alpha{.}\lambda x^{\alpha}\lambda y^{\alpha}{.}x          ğ…  =   Î›  Î±    .   Î»   x  Î±   Î»   y  Î±    .  y     formulae-sequence    ğ…    normal-Î›  Î±      Î»   superscript  x  Î±   Î»   superscript  y  Î±    y    \mathbf{F}=\Lambda\alpha{.}\lambda x^{\alpha}\lambda y^{\alpha}{.}y     (Note that the above two functions require three â€” not two â€” parameters. The latter two should be lambda expressions, but the first one should be a type. This fact is reflected in the fact that the type of these expressions is     âˆ€  Î±   .   Î±  â†’  Î±  â†’  Î±      formulae-sequence   for-all  Î±      normal-â†’  Î±  Î±    normal-â†’    Î±      \scriptstyle\forall\alpha.\alpha\to\alpha\to\alpha   ; the universal quantifier binding the Î± corresponds to the Î› binding the alpha in the lambda expression itself. Also, note that   ğ–¡ğ—ˆğ—ˆğ—…ğ–¾ğ–ºğ—‡   ğ–¡ğ—ˆğ—ˆğ—…ğ–¾ğ–ºğ—‡   \scriptstyle\mathsf{Boolean}   is a convenient shorthand for     âˆ€  Î±   .   Î±  â†’  Î±  â†’  Î±      formulae-sequence   for-all  Î±      normal-â†’  Î±  Î±    normal-â†’    Î±      \scriptstyle\forall\alpha.\alpha\to\alpha\to\alpha   , but it is not a symbol of System F itself, but rather a "meta-symbol". Likewise,   ğ“   ğ“   \scriptstyle\mathbf{T}   and   ğ…   ğ…   \scriptstyle\mathbf{F}   are also "meta-symbols", convenient shorthands, of System F "assemblies" (in the [ http://books.google.com/books?id=IL-SI67hjI4C&printsec; ;=frontcover&dq;=Nicolas+Bourbaki&source;=bl&ots;=nbfmxi9gJK&sig;=4nPo8EFXrQYwAC2y0pD0uGv-EGY&hl;=en&sa;=X&ei;=3sYBUOukIMLW2AX4t_inCw&ved;=0CD8Q6AEwAg#v=onepage&q;=Nicolas%20Bourbaki&f;=false Bourbaki sense]); otherwise, if such functions could be named (within System F), then there would be no need for the lambda-expressive apparatus capable of defining functions anonymously.)  Then, with these two   Î»   Î»   \scriptstyle\lambda   -terms, we can define some logic operators (which are of type    ğ–¡ğ—ˆğ—ˆğ—…ğ–¾ğ–ºğ—‡  â†’  ğ–¡ğ—ˆğ—ˆğ—…ğ–¾ğ–ºğ—‡  â†’  ğ–¡ğ—ˆğ—ˆğ—…ğ–¾ğ–ºğ—‡       normal-â†’  ğ–¡ğ—ˆğ—ˆğ—…ğ–¾ğ–ºğ—‡  ğ–¡ğ—ˆğ—ˆğ—…ğ–¾ğ–ºğ—‡    normal-â†’    ğ–¡ğ—ˆğ—ˆğ—…ğ–¾ğ–ºğ—‡     \scriptstyle\mathsf{Boolean}\rightarrow\mathsf{Boolean}\rightarrow\mathsf{Boolean}   ):       AND  =   Î»   x  ğ–¡ğ—ˆğ—ˆğ—…ğ–¾ğ–ºğ—‡   Î»   y  ğ–¡ğ—ˆğ—ˆğ—…ğ–¾ğ–ºğ—‡     .    x    ğ–¡ğ—ˆğ—ˆğ—…ğ–¾ğ–ºğ—‡    y   ğ…      formulae-sequence    AND    Î»   superscript  x  ğ–¡ğ—ˆğ—ˆğ—…ğ–¾ğ–ºğ—‡   Î»   superscript  y  ğ–¡ğ—ˆğ—ˆğ—…ğ–¾ğ–ºğ—‡       x  ğ–¡ğ—ˆğ—ˆğ—…ğ–¾ğ–ºğ—‡  y  ğ…     \mathrm{AND}=\lambda x^{\mathsf{Boolean}}\lambda y^{\mathsf{Boolean}}{.}x\,%
 \mathsf{Boolean}\,y\,\mathbf{F}          OR  =   Î»   x  ğ–¡ğ—ˆğ—ˆğ—…ğ–¾ğ–ºğ—‡   Î»   y  ğ–¡ğ—ˆğ—ˆğ—…ğ–¾ğ–ºğ—‡     .    x    ğ–¡ğ—ˆğ—ˆğ—…ğ–¾ğ–ºğ—‡    ğ“   y      formulae-sequence    OR    Î»   superscript  x  ğ–¡ğ—ˆğ—ˆğ—…ğ–¾ğ–ºğ—‡   Î»   superscript  y  ğ–¡ğ—ˆğ—ˆğ—…ğ–¾ğ–ºğ—‡       x  ğ–¡ğ—ˆğ—ˆğ—…ğ–¾ğ–ºğ—‡  ğ“  y     \mathrm{OR}=\lambda x^{\mathsf{Boolean}}\lambda y^{\mathsf{Boolean}}{.}x\,%
 \mathsf{Boolean}\,\mathbf{T}\,y          NOT  =   Î»   x  ğ–¡ğ—ˆğ—ˆğ—…ğ–¾ğ–ºğ—‡     .    x    ğ–¡ğ—ˆğ—ˆğ—…ğ–¾ğ–ºğ—‡    ğ…   ğ“      formulae-sequence    NOT    Î»   superscript  x  ğ–¡ğ—ˆğ—ˆğ—…ğ–¾ğ–ºğ—‡       x  ğ–¡ğ—ˆğ—ˆğ—…ğ–¾ğ–ºğ—‡  ğ…  ğ“     \mathrm{NOT}=\lambda x^{\mathsf{Boolean}}{.}x\,\mathsf{Boolean}\,\mathbf{F}\,%
 \mathbf{T}     As in Church encodings, there is no need for an IFTHENELSE function as one can just use raw   ğ–¡ğ—ˆğ—ˆğ—…ğ–¾ğ–ºğ—‡   ğ–¡ğ—ˆğ—ˆğ—…ğ–¾ğ–ºğ—‡   \scriptstyle\mathsf{Boolean}   -typed terms as decision functions. However, if one is requested:       IFTHENELSE  =   Î›  Î±    .   Î»   x  ğ–¡ğ—ˆğ—ˆğ—…ğ–¾ğ–ºğ—‡   Î»   y  Î±   Î»   z  Î±    .   x  Î±  y  z      formulae-sequence    IFTHENELSE    normal-Î›  Î±      Î»   superscript  x  ğ–¡ğ—ˆğ—ˆğ—…ğ–¾ğ–ºğ—‡   Î»   superscript  y  Î±   Î»   superscript  z  Î±      x  Î±  y  z     \mathrm{IFTHENELSE}=\Lambda\alpha.\lambda x^{\mathsf{Boolean}}\lambda y^{%
 \alpha}\lambda z^{\alpha}.x\alpha yz   will do. A predicate is a function which returns a   ğ–¡ğ—ˆğ—ˆğ—…ğ–¾ğ–ºğ—‡   ğ–¡ğ—ˆğ—ˆğ—…ğ–¾ğ–ºğ—‡   \scriptstyle\mathsf{Boolean}   -typed value. The most fundamental predicate is ISZERO which returns   ğ“   ğ“   \scriptstyle\mathbf{T}   if and only if its argument is the Church numeral  0 :      ISZERO  =  Î»   n   âˆ€  Î±  .   (  Î±  â†’  Î±  )   â†’  Î±  â†’  Î±    .   n    ğ–¡ğ—ˆğ—ˆğ—…ğ–¾ğ–ºğ—‡    (  Î»   x  ğ–¡ğ—ˆğ—ˆğ—…ğ–¾ğ–ºğ—‡   .  ğ…  )   ğ“     fragments  ISZERO   Î»   superscript  n   fragments  for-all  Î±  normal-.   fragments  normal-(  Î±  normal-â†’  Î±  normal-)   normal-â†’  Î±  normal-â†’  Î±    normal-.  n  Boolean   fragments  normal-(  Î»   superscript  x  ğ–¡ğ—ˆğ—ˆğ—…ğ–¾ğ–ºğ—‡   normal-.  F  normal-)   T    \mathrm{ISZERO}=\lambda n^{\forall\alpha.(\alpha\rightarrow\alpha)\rightarrow%
 \alpha\rightarrow\alpha}{.}n\,\mathsf{Boolean}\,(\lambda x^{\mathsf{Boolean}}{%
 .}\mathbf{F})\,\mathbf{T}     System F Structures  System F allows recursive constructions to be embedded in a natural manner, related to that in Martin-LÃ¶f's type theory . Abstract structures (S) are created using constructors . These are functions typed as:       K  1   â†’   K  2   â†’  â€¦  â†’  S       normal-â†’   subscript  K  1    subscript  K  2     normal-â†’    normal-â€¦    normal-â†’    S     K_{1}\rightarrow K_{2}\rightarrow\dots\rightarrow S   .  Recursivity is manifested when   S   S   S   itself appears within one of the types    K  i     subscript  K  i    K_{i}   . If you have   m   m   m   of these constructors, you can define the type of   S   S   S   as:      âˆ€  Î±  .   (   K  1  1    [  Î±  /  S  ]   â†’  â€¦  â†’  Î±  )   â€¦  â†’   (   K  1  m    [  Î±  /  S  ]   â†’  â€¦  â†’  Î±  )   â†’  Î±     fragments  for-all  Î±  normal-.   fragments  normal-(   superscript   subscript  K  1   1    fragments  normal-[  Î±   S  normal-]   normal-â†’  normal-â€¦  normal-â†’  Î±  normal-)   normal-â€¦  normal-â†’   fragments  normal-(   superscript   subscript  K  1   m    fragments  normal-[  Î±   S  normal-]   normal-â†’  normal-â€¦  normal-â†’  Î±  normal-)   normal-â†’  Î±    \forall\alpha.(K_{1}^{1}[\alpha/S]\rightarrow\dots\rightarrow\alpha)\dots%
 \rightarrow(K_{1}^{m}[\alpha/S]\rightarrow\dots\rightarrow\alpha)\rightarrow\alpha     For instance, the natural numbers can be defined as an inductive datatype   N   N   N   with constructors      ğ‘§ğ‘’ğ‘Ÿğ‘œ  :  N     normal-:  ğ‘§ğ‘’ğ‘Ÿğ‘œ  normal-N    \mathit{zero}:\mathrm{N}         ğ‘ ğ‘¢ğ‘ğ‘  :   N  â†’  N      normal-:  ğ‘ ğ‘¢ğ‘ğ‘   normal-â†’  normal-N  normal-N     \mathit{succ}:\mathrm{N}\rightarrow\mathrm{N}   The System F type corresponding to this structure is    âˆ€  Î±  .  Î±  â†’   (  Î±  â†’  Î±  )   â†’  Î±     fragments  for-all  Î±  normal-.  Î±  normal-â†’   fragments  normal-(  Î±  normal-â†’  Î±  normal-)   normal-â†’  Î±    \forall\alpha.\alpha\to(\alpha\to\alpha)\to\alpha   . The terms of this type comprise a typed version of the Church numerals , the first few of which are:   0 :=      Î›  Î±   .   Î»   x  Î±    .   Î»   f   Î±  â†’  Î±     .  x     formulae-sequence    normal-Î›  Î±     Î»   superscript  x  Î±      Î»   superscript  f   normal-â†’  Î±  Î±     x    \Lambda\alpha.\lambda x^{\alpha}.\lambda f^{\alpha\to\alpha}.x     1 :=      Î›  Î±   .   Î»   x  Î±    .   Î»   f   Î±  â†’  Î±     .   f  x      formulae-sequence    normal-Î›  Î±     Î»   superscript  x  Î±      Î»   superscript  f   normal-â†’  Î±  Î±       f  x     \Lambda\alpha.\lambda x^{\alpha}.\lambda f^{\alpha\to\alpha}.fx     2 :=      Î›  Î±   .   Î»   x  Î±    .   Î»   f   Î±  â†’  Î±     .   f   (   f  x   )       formulae-sequence    normal-Î›  Î±     Î»   superscript  x  Î±      Î»   superscript  f   normal-â†’  Î±  Î±       f    f  x      \Lambda\alpha.\lambda x^{\alpha}.\lambda f^{\alpha\to\alpha}.f(fx)     3 :=      Î›  Î±   .   Î»   x  Î±    .   Î»   f   Î±  â†’  Î±     .   f   (   f   (   f  x   )    )       formulae-sequence    normal-Î›  Î±     Î»   superscript  x  Î±      Î»   superscript  f   normal-â†’  Î±  Î±       f    f    f  x       \Lambda\alpha.\lambda x^{\alpha}.\lambda f^{\alpha\to\alpha}.f(f(fx))      If we reverse the order of the curried arguments ( i.e.,     âˆ€  Î±  .   (  Î±  â†’  Î±  )   â†’  Î±  â†’  Î±     fragments  for-all  Î±  normal-.   fragments  normal-(  Î±  normal-â†’  Î±  normal-)   normal-â†’  Î±  normal-â†’  Î±    \forall\alpha.(\alpha\rightarrow\alpha)\rightarrow\alpha\rightarrow\alpha   ), then the Church numeral for   n   n   n   is a function that takes a function ''f'' as argument and returns the   n   n   n    th power of ''f'' . That is to say, a Church numeral is a higher-order function â€“ it takes a single-argument function ''f'' , and returns another single-argument function.  Use in programming languages  The version of System F used in this article is as an explicitly typed, or Church-style, calculus. The typing information contained in Î»-terms makes type-checking straightforward. Joe Wells (1994) settled an "embarrassing open problem" by proving that type checking is undecidable for a Curry-style variant of System F, that is, one that lacks explicit typing annotations. 1 2  Wells' result implies that type inference for System F is impossible. A restriction of System F known as " Hindleyâ€“Milner ", or simply "HM", does have an easy type inference algorithm and is used for many statically typed  functional programming languages such as Haskell 98 and ML . Over time, as the restrictions of HM-style type systems have become apparent, languages have steadily moved to more expressive logics for their type systems. As of 2008, GHC , a Haskell compiler, goes beyond HM, and now uses System F extended with non-syntactic type equality, for example.  System F Ï‰  While System F corresponds to the first axis of the Barendregt's lambda cube , System F Ï‰ or the higher-order polymorphic lambda calculus combines the first axis (polymorphism) with the second axis ( type operators ); it is a different, more complex system.  System F Ï‰ can be defined inductively on a family of systems, where induction is based on the kinds permitted in each system:       F  n     subscript  F  n    F_{n}   permits kinds:     â‹†   normal-â‹†   \star   (the kind of types) and      J  â‡’  K     normal-â‡’  J  K    J\Rightarrow K   where    J  âˆˆ   F   n  -  1        J   subscript  F    n  1      J\in F_{n-1}   and    K  âˆˆ   F  n       K   subscript  F  n     K\in F_{n}   (the kind of functions from types to types, where the argument type is of a lower order)    In the limit, we can define system    F  Ï‰     subscript  F  Ï‰    F_{\omega}   to be        F  Ï‰   =    â‹ƒ   1  â‰¤  i     F  i         subscript  F  Ï‰        1  i      subscript  F  i      F_{\omega}=\underset{1\leq i}{\bigcup}F_{i}      That is, F Ï‰ is the system which allows functions from types to types where the argument (and result) may be of any order.  Note that although F Ï‰ places no restrictions on the order of the arguments in these mappings, it does restrict the universe of the arguments for these mappings: they must be types rather than values. System F Ï‰ does not permit mappings from values to types ( Dependent types ), though it does permit mappings from values to values (   Î»   Î»   \lambda   abstraction), mappings from types to values (   Î›   normal-Î›   \Lambda   abstraction, sometimes written   âˆ€   for-all   \forall   ) and mappings from types to types (   Î»   Î»   \lambda   abstraction at the level of types)  See also   Existential types are the existentially quantified counterparts of universal types.  System F <:> : extends system F with subtyping , bringing it a lot closer to actual programming languages from the ML family.   Notes  References     .   Girard, Lafont and Taylor, Proofs and Types . Cambridge University Press, 1989, ISBN 0-521-37181-3.  J. B. Wells. "Typability and type checking in the second-order lambda-calculus are equivalent and undecidable." In Proceedings of the 9th Annual IEEE Symposium on Logic in Computer Science (LICS), pages 176â€“185, 1994. 1   Further reading    , Chapter 23: Universal Types, and Chapter 25: An ML Implementation of System F   {{-}}  External links   Summary of System F by Franck Binard.  System F Ï‰ : the workhorse of modern compilers by Greg Morrisett   "  Category:1971 in computer science  Category:1974 in computer science  Category:Lambda calculus  Category:Type theory  Category:Polymorphism (computer science)     http://www.macs.hw.ac.uk/~jbw/research-summary.html â†©  http://web.archive.org/web/20070929211126/http://www.church-project.org/reports/Wells:APAL-1999-v98-no-note.html â†©     