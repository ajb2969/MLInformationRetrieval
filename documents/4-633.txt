   System F      System F   System F , also known as the (Girard–Reynolds) polymorphic lambda calculus or the second-order lambda calculus , is a typed lambda calculus that differs from the simply typed lambda calculus by the introduction of a mechanism of universal quantification over types. System F thus formalizes the notion of parametric polymorphism in programming languages , and forms a theoretical basis for languages such as Haskell and ML . System F was discovered independently by logician  Jean-Yves Girard (1972) and computer scientist  John C. Reynolds (1974).  Whereas simply typed lambda calculus has variables ranging over functions, and binders for them, System F additionally has variables ranging over types , and binders for them. As an example, the fact that the identity function can have any type of the form A→ A would be formalized in System F as the judgment      ⊢  Λ  α  .  λ   x  α   .  x  :  ∀  α  .  α  →  α     fragments  proves  Λ  α  normal-.  λ   superscript  x  α   normal-.  x  normal-:  for-all  α  normal-.  α  normal-→  α    \vdash\Lambda\alpha.\lambda x^{\alpha}.x:\forall\alpha.\alpha\to\alpha     where   α   α   \alpha   is a type variable . The upper-case   Λ   normal-Λ   \Lambda   is traditionally used to denote type-level functions, as opposed to the lower-case   λ   λ   \lambda   which is used for value-level functions. (The superscripted   α   α   \alpha   means that the bound x is of type   α   α   \alpha   ; the expression after the colon is the type of the lambda expression preceding it.)  As a term rewriting system , System F is strongly normalizing . However, type inference in System F (without explicit type annotations) is undecidable. Under the Curry–Howard isomorphism , System F corresponds to the fragment of second-order intuitionistic logic that uses only universal quantification. System F can be seen as part of the lambda cube , together with even more expressive typed lambda calculi, including those with dependent types .  Logic and predicates  The   𝖡𝗈𝗈𝗅𝖾𝖺𝗇   𝖡𝗈𝗈𝗅𝖾𝖺𝗇   \scriptstyle\mathsf{Boolean}   type is defined as:     ∀  α   .   α  →  α  →  α      formulae-sequence   for-all  α      normal-→  α  α    normal-→    α      \scriptstyle\forall\alpha.\alpha\to\alpha\to\alpha   , where   α   α   \scriptstyle\alpha   is a type variable . This means   𝖡𝗈𝗈𝗅𝖾𝖺𝗇   𝖡𝗈𝗈𝗅𝖾𝖺𝗇   \scriptstyle\mathsf{Boolean}   is the type of all functions which take as input a type α and two expressions of type α, and produce as output an expression of type α (note that we consider   →   normal-→   \to   to be right-associative.)  The following two definitions for the boolean values   𝐓   𝐓   \scriptstyle\mathbf{T}   and   𝐅   𝐅   \scriptstyle\mathbf{F}   are used, extending the definition of Church booleans :       𝐓  =   Λ  α    .   λ   x  α   λ   y  α    .  x     formulae-sequence    𝐓    normal-Λ  α      λ   superscript  x  α   λ   superscript  y  α    x    \mathbf{T}=\Lambda\alpha{.}\lambda x^{\alpha}\lambda y^{\alpha}{.}x          𝐅  =   Λ  α    .   λ   x  α   λ   y  α    .  y     formulae-sequence    𝐅    normal-Λ  α      λ   superscript  x  α   λ   superscript  y  α    y    \mathbf{F}=\Lambda\alpha{.}\lambda x^{\alpha}\lambda y^{\alpha}{.}y     (Note that the above two functions require three — not two — parameters. The latter two should be lambda expressions, but the first one should be a type. This fact is reflected in the fact that the type of these expressions is     ∀  α   .   α  →  α  →  α      formulae-sequence   for-all  α      normal-→  α  α    normal-→    α      \scriptstyle\forall\alpha.\alpha\to\alpha\to\alpha   ; the universal quantifier binding the α corresponds to the Λ binding the alpha in the lambda expression itself. Also, note that   𝖡𝗈𝗈𝗅𝖾𝖺𝗇   𝖡𝗈𝗈𝗅𝖾𝖺𝗇   \scriptstyle\mathsf{Boolean}   is a convenient shorthand for     ∀  α   .   α  →  α  →  α      formulae-sequence   for-all  α      normal-→  α  α    normal-→    α      \scriptstyle\forall\alpha.\alpha\to\alpha\to\alpha   , but it is not a symbol of System F itself, but rather a "meta-symbol". Likewise,   𝐓   𝐓   \scriptstyle\mathbf{T}   and   𝐅   𝐅   \scriptstyle\mathbf{F}   are also "meta-symbols", convenient shorthands, of System F "assemblies" (in the [ http://books.google.com/books?id=IL-SI67hjI4C&printsec; ;=frontcover&dq;=Nicolas+Bourbaki&source;=bl&ots;=nbfmxi9gJK&sig;=4nPo8EFXrQYwAC2y0pD0uGv-EGY&hl;=en&sa;=X&ei;=3sYBUOukIMLW2AX4t_inCw&ved;=0CD8Q6AEwAg#v=onepage&q;=Nicolas%20Bourbaki&f;=false Bourbaki sense]); otherwise, if such functions could be named (within System F), then there would be no need for the lambda-expressive apparatus capable of defining functions anonymously.)  Then, with these two   λ   λ   \scriptstyle\lambda   -terms, we can define some logic operators (which are of type    𝖡𝗈𝗈𝗅𝖾𝖺𝗇  →  𝖡𝗈𝗈𝗅𝖾𝖺𝗇  →  𝖡𝗈𝗈𝗅𝖾𝖺𝗇       normal-→  𝖡𝗈𝗈𝗅𝖾𝖺𝗇  𝖡𝗈𝗈𝗅𝖾𝖺𝗇    normal-→    𝖡𝗈𝗈𝗅𝖾𝖺𝗇     \scriptstyle\mathsf{Boolean}\rightarrow\mathsf{Boolean}\rightarrow\mathsf{Boolean}   ):       AND  =   λ   x  𝖡𝗈𝗈𝗅𝖾𝖺𝗇   λ   y  𝖡𝗈𝗈𝗅𝖾𝖺𝗇     .    x    𝖡𝗈𝗈𝗅𝖾𝖺𝗇    y   𝐅      formulae-sequence    AND    λ   superscript  x  𝖡𝗈𝗈𝗅𝖾𝖺𝗇   λ   superscript  y  𝖡𝗈𝗈𝗅𝖾𝖺𝗇       x  𝖡𝗈𝗈𝗅𝖾𝖺𝗇  y  𝐅     \mathrm{AND}=\lambda x^{\mathsf{Boolean}}\lambda y^{\mathsf{Boolean}}{.}x\,%
 \mathsf{Boolean}\,y\,\mathbf{F}          OR  =   λ   x  𝖡𝗈𝗈𝗅𝖾𝖺𝗇   λ   y  𝖡𝗈𝗈𝗅𝖾𝖺𝗇     .    x    𝖡𝗈𝗈𝗅𝖾𝖺𝗇    𝐓   y      formulae-sequence    OR    λ   superscript  x  𝖡𝗈𝗈𝗅𝖾𝖺𝗇   λ   superscript  y  𝖡𝗈𝗈𝗅𝖾𝖺𝗇       x  𝖡𝗈𝗈𝗅𝖾𝖺𝗇  𝐓  y     \mathrm{OR}=\lambda x^{\mathsf{Boolean}}\lambda y^{\mathsf{Boolean}}{.}x\,%
 \mathsf{Boolean}\,\mathbf{T}\,y          NOT  =   λ   x  𝖡𝗈𝗈𝗅𝖾𝖺𝗇     .    x    𝖡𝗈𝗈𝗅𝖾𝖺𝗇    𝐅   𝐓      formulae-sequence    NOT    λ   superscript  x  𝖡𝗈𝗈𝗅𝖾𝖺𝗇       x  𝖡𝗈𝗈𝗅𝖾𝖺𝗇  𝐅  𝐓     \mathrm{NOT}=\lambda x^{\mathsf{Boolean}}{.}x\,\mathsf{Boolean}\,\mathbf{F}\,%
 \mathbf{T}     As in Church encodings, there is no need for an IFTHENELSE function as one can just use raw   𝖡𝗈𝗈𝗅𝖾𝖺𝗇   𝖡𝗈𝗈𝗅𝖾𝖺𝗇   \scriptstyle\mathsf{Boolean}   -typed terms as decision functions. However, if one is requested:       IFTHENELSE  =   Λ  α    .   λ   x  𝖡𝗈𝗈𝗅𝖾𝖺𝗇   λ   y  α   λ   z  α    .   x  α  y  z      formulae-sequence    IFTHENELSE    normal-Λ  α      λ   superscript  x  𝖡𝗈𝗈𝗅𝖾𝖺𝗇   λ   superscript  y  α   λ   superscript  z  α      x  α  y  z     \mathrm{IFTHENELSE}=\Lambda\alpha.\lambda x^{\mathsf{Boolean}}\lambda y^{%
 \alpha}\lambda z^{\alpha}.x\alpha yz   will do. A predicate is a function which returns a   𝖡𝗈𝗈𝗅𝖾𝖺𝗇   𝖡𝗈𝗈𝗅𝖾𝖺𝗇   \scriptstyle\mathsf{Boolean}   -typed value. The most fundamental predicate is ISZERO which returns   𝐓   𝐓   \scriptstyle\mathbf{T}   if and only if its argument is the Church numeral  0 :      ISZERO  =  λ   n   ∀  α  .   (  α  →  α  )   →  α  →  α    .   n    𝖡𝗈𝗈𝗅𝖾𝖺𝗇    (  λ   x  𝖡𝗈𝗈𝗅𝖾𝖺𝗇   .  𝐅  )   𝐓     fragments  ISZERO   λ   superscript  n   fragments  for-all  α  normal-.   fragments  normal-(  α  normal-→  α  normal-)   normal-→  α  normal-→  α    normal-.  n  Boolean   fragments  normal-(  λ   superscript  x  𝖡𝗈𝗈𝗅𝖾𝖺𝗇   normal-.  F  normal-)   T    \mathrm{ISZERO}=\lambda n^{\forall\alpha.(\alpha\rightarrow\alpha)\rightarrow%
 \alpha\rightarrow\alpha}{.}n\,\mathsf{Boolean}\,(\lambda x^{\mathsf{Boolean}}{%
 .}\mathbf{F})\,\mathbf{T}     System F Structures  System F allows recursive constructions to be embedded in a natural manner, related to that in Martin-Löf's type theory . Abstract structures (S) are created using constructors . These are functions typed as:       K  1   →   K  2   →  …  →  S       normal-→   subscript  K  1    subscript  K  2     normal-→    normal-…    normal-→    S     K_{1}\rightarrow K_{2}\rightarrow\dots\rightarrow S   .  Recursivity is manifested when   S   S   S   itself appears within one of the types    K  i     subscript  K  i    K_{i}   . If you have   m   m   m   of these constructors, you can define the type of   S   S   S   as:      ∀  α  .   (   K  1  1    [  α  /  S  ]   →  …  →  α  )   …  →   (   K  1  m    [  α  /  S  ]   →  …  →  α  )   →  α     fragments  for-all  α  normal-.   fragments  normal-(   superscript   subscript  K  1   1    fragments  normal-[  α   S  normal-]   normal-→  normal-…  normal-→  α  normal-)   normal-…  normal-→   fragments  normal-(   superscript   subscript  K  1   m    fragments  normal-[  α   S  normal-]   normal-→  normal-…  normal-→  α  normal-)   normal-→  α    \forall\alpha.(K_{1}^{1}[\alpha/S]\rightarrow\dots\rightarrow\alpha)\dots%
 \rightarrow(K_{1}^{m}[\alpha/S]\rightarrow\dots\rightarrow\alpha)\rightarrow\alpha     For instance, the natural numbers can be defined as an inductive datatype   N   N   N   with constructors      𝑧𝑒𝑟𝑜  :  N     normal-:  𝑧𝑒𝑟𝑜  normal-N    \mathit{zero}:\mathrm{N}         𝑠𝑢𝑐𝑐  :   N  →  N      normal-:  𝑠𝑢𝑐𝑐   normal-→  normal-N  normal-N     \mathit{succ}:\mathrm{N}\rightarrow\mathrm{N}   The System F type corresponding to this structure is    ∀  α  .  α  →   (  α  →  α  )   →  α     fragments  for-all  α  normal-.  α  normal-→   fragments  normal-(  α  normal-→  α  normal-)   normal-→  α    \forall\alpha.\alpha\to(\alpha\to\alpha)\to\alpha   . The terms of this type comprise a typed version of the Church numerals , the first few of which are:   0 :=      Λ  α   .   λ   x  α    .   λ   f   α  →  α     .  x     formulae-sequence    normal-Λ  α     λ   superscript  x  α      λ   superscript  f   normal-→  α  α     x    \Lambda\alpha.\lambda x^{\alpha}.\lambda f^{\alpha\to\alpha}.x     1 :=      Λ  α   .   λ   x  α    .   λ   f   α  →  α     .   f  x      formulae-sequence    normal-Λ  α     λ   superscript  x  α      λ   superscript  f   normal-→  α  α       f  x     \Lambda\alpha.\lambda x^{\alpha}.\lambda f^{\alpha\to\alpha}.fx     2 :=      Λ  α   .   λ   x  α    .   λ   f   α  →  α     .   f   (   f  x   )       formulae-sequence    normal-Λ  α     λ   superscript  x  α      λ   superscript  f   normal-→  α  α       f    f  x      \Lambda\alpha.\lambda x^{\alpha}.\lambda f^{\alpha\to\alpha}.f(fx)     3 :=      Λ  α   .   λ   x  α    .   λ   f   α  →  α     .   f   (   f   (   f  x   )    )       formulae-sequence    normal-Λ  α     λ   superscript  x  α      λ   superscript  f   normal-→  α  α       f    f    f  x       \Lambda\alpha.\lambda x^{\alpha}.\lambda f^{\alpha\to\alpha}.f(f(fx))      If we reverse the order of the curried arguments ( i.e.,     ∀  α  .   (  α  →  α  )   →  α  →  α     fragments  for-all  α  normal-.   fragments  normal-(  α  normal-→  α  normal-)   normal-→  α  normal-→  α    \forall\alpha.(\alpha\rightarrow\alpha)\rightarrow\alpha\rightarrow\alpha   ), then the Church numeral for   n   n   n   is a function that takes a function ''f'' as argument and returns the   n   n   n    th power of ''f'' . That is to say, a Church numeral is a higher-order function – it takes a single-argument function ''f'' , and returns another single-argument function.  Use in programming languages  The version of System F used in this article is as an explicitly typed, or Church-style, calculus. The typing information contained in λ-terms makes type-checking straightforward. Joe Wells (1994) settled an "embarrassing open problem" by proving that type checking is undecidable for a Curry-style variant of System F, that is, one that lacks explicit typing annotations. 1 2  Wells' result implies that type inference for System F is impossible. A restriction of System F known as " Hindley–Milner ", or simply "HM", does have an easy type inference algorithm and is used for many statically typed  functional programming languages such as Haskell 98 and ML . Over time, as the restrictions of HM-style type systems have become apparent, languages have steadily moved to more expressive logics for their type systems. As of 2008, GHC , a Haskell compiler, goes beyond HM, and now uses System F extended with non-syntactic type equality, for example.  System F ω  While System F corresponds to the first axis of the Barendregt's lambda cube , System F ω or the higher-order polymorphic lambda calculus combines the first axis (polymorphism) with the second axis ( type operators ); it is a different, more complex system.  System F ω can be defined inductively on a family of systems, where induction is based on the kinds permitted in each system:       F  n     subscript  F  n    F_{n}   permits kinds:     ⋆   normal-⋆   \star   (the kind of types) and      J  ⇒  K     normal-⇒  J  K    J\Rightarrow K   where    J  ∈   F   n  -  1        J   subscript  F    n  1      J\in F_{n-1}   and    K  ∈   F  n       K   subscript  F  n     K\in F_{n}   (the kind of functions from types to types, where the argument type is of a lower order)    In the limit, we can define system    F  ω     subscript  F  ω    F_{\omega}   to be        F  ω   =    ⋃   1  ≤  i     F  i         subscript  F  ω        1  i      subscript  F  i      F_{\omega}=\underset{1\leq i}{\bigcup}F_{i}      That is, F ω is the system which allows functions from types to types where the argument (and result) may be of any order.  Note that although F ω places no restrictions on the order of the arguments in these mappings, it does restrict the universe of the arguments for these mappings: they must be types rather than values. System F ω does not permit mappings from values to types ( Dependent types ), though it does permit mappings from values to values (   λ   λ   \lambda   abstraction), mappings from types to values (   Λ   normal-Λ   \Lambda   abstraction, sometimes written   ∀   for-all   \forall   ) and mappings from types to types (   λ   λ   \lambda   abstraction at the level of types)  See also   Existential types are the existentially quantified counterparts of universal types.  System F <:> : extends system F with subtyping , bringing it a lot closer to actual programming languages from the ML family.   Notes  References     .   Girard, Lafont and Taylor, Proofs and Types . Cambridge University Press, 1989, ISBN 0-521-37181-3.  J. B. Wells. "Typability and type checking in the second-order lambda-calculus are equivalent and undecidable." In Proceedings of the 9th Annual IEEE Symposium on Logic in Computer Science (LICS), pages 176–185, 1994. 1   Further reading    , Chapter 23: Universal Types, and Chapter 25: An ML Implementation of System F   {{-}}  External links   Summary of System F by Franck Binard.  System F ω : the workhorse of modern compilers by Greg Morrisett   "  Category:1971 in computer science  Category:1974 in computer science  Category:Lambda calculus  Category:Type theory  Category:Polymorphism (computer science)     http://www.macs.hw.ac.uk/~jbw/research-summary.html ↩  http://web.archive.org/web/20070929211126/http://www.church-project.org/reports/Wells:APAL-1999-v98-no-note.html ↩     