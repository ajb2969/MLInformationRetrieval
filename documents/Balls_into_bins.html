<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1144">Balls into bins</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Balls into bins</h1>
<hr/>

<p>The <strong>balls-into-bins</strong> problem is a classic problem in <a href="probability_theory" title="wikilink">probability theory</a> that has many applications in <a href="computer_science" title="wikilink">computer science</a>. The problem involves <em>m</em> balls and <em>n</em> boxes (or "bins"). Each time, a single ball is placed into one of the bins. After all balls are in the bins, we look at the number of balls in each bin; we call this number the <em>load</em> on the bin and ask: what is the maximum load on a single bin?</p>

<p>Obviously, it is possible to make the load as small as <em>m</em>/<em>n</em> by putting each ball into the least loaded bin. The interesting case is when the bin is selected at random, or at least partially at random.</p>
<h2 id="random-allocation">Random allocation</h2>

<p>When the bin for each ball is selected at random, independent of other choices, the maximum load might be as large as <em>m</em>. However, it is possible to calculate a tighter bound that holds with high probability. A "high probability" is a probability 1-o(1), i.e. the probability tends to 1 when <em>n</em> grows.</p>

<p>For the case <em>m</em>=<em>n</em>, with high probability the maximum load is:<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> <a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> 

<math display="inline" id="Balls_into_bins:0">
 <semantics>
  <mrow>
   <mfrac>
    <mrow>
     <mi>log</mi>
     <mi>n</mi>
    </mrow>
    <mrow>
     <mi>log</mi>
     <mrow>
      <mi>log</mi>
      <mi>n</mi>
     </mrow>
    </mrow>
   </mfrac>
   <mo>⋅</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mn>1</mn>
     <mo>+</mo>
     <mrow>
      <mi>o</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mn>1</mn>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-⋅</ci>
    <apply>
     <divide></divide>
     <apply>
      <log></log>
      <ci>n</ci>
     </apply>
     <apply>
      <log></log>
      <apply>
       <log></log>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <cn type="integer">1</cn>
     <apply>
      <times></times>
      <ci>o</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{\log n}{\log\log n}\cdot(1+o(1))
  </annotation>
 </semantics>
</math>

</p>

<p>The maximum load can also be calculated for <em>m</em><em>n</em>.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>
<h2 id="partially-random-allocation">Partially random allocation</h2>

<p>Instead of just selecting a random bin for each ball, it is possible to select two or more bins for each ball and then put the ball in the least loaded bin. This is a compromise between a deterministic allocation, in which all bins are checked and the least loaded bin is selected, and a totally random allocation, in which a single bin is selected without checking other bins.</p>

<p>In this case, if <em>m</em>≥<em>n</em> and <em>d≥2</em> bins are checked at each step, then with high probability the maximum load is:<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> 

<math display="inline" id="Balls_into_bins:1">
 <semantics>
  <mrow>
   <mrow>
    <mfrac>
     <mrow>
      <mi>log</mi>
      <mrow>
       <mi>log</mi>
       <mi>n</mi>
      </mrow>
     </mrow>
     <mrow>
      <mi>log</mi>
      <mi>d</mi>
     </mrow>
    </mfrac>
    <mo>⋅</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mn>1</mn>
      <mo>+</mo>
      <mrow>
       <mi>o</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mn>1</mn>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>+</mo>
   <mrow>
    <mi mathvariant="normal">Θ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mfrac>
      <mi>m</mi>
      <mi>n</mi>
     </mfrac>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <ci>normal-⋅</ci>
     <apply>
      <divide></divide>
      <apply>
       <log></log>
       <apply>
        <log></log>
        <ci>n</ci>
       </apply>
      </apply>
      <apply>
       <log></log>
       <ci>d</ci>
      </apply>
     </apply>
     <apply>
      <plus></plus>
      <cn type="integer">1</cn>
      <apply>
       <times></times>
       <ci>o</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>normal-Θ</ci>
     <apply>
      <divide></divide>
      <ci>m</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{\log\log n}{\log d}\cdot(1+o(1))+\Theta(\frac{m}{n})
  </annotation>
 </semantics>
</math>

</p>

<p>In particular, for <em>m</em>=<em>n</em> the maximum load is:</p>

<p>

<math display="inline" id="Balls_into_bins:2">
 <semantics>
  <mrow>
   <mrow>
    <mfrac>
     <mrow>
      <mi>log</mi>
      <mrow>
       <mi>log</mi>
       <mi>n</mi>
      </mrow>
     </mrow>
     <mrow>
      <mi>log</mi>
      <mi>d</mi>
     </mrow>
    </mfrac>
    <mo>⋅</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mn>1</mn>
      <mo>+</mo>
      <mrow>
       <mi>o</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mn>1</mn>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>+</mo>
   <mrow>
    <mi mathvariant="normal">Θ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>1</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <ci>normal-⋅</ci>
     <apply>
      <divide></divide>
      <apply>
       <log></log>
       <apply>
        <log></log>
        <ci>n</ci>
       </apply>
      </apply>
      <apply>
       <log></log>
       <ci>d</ci>
      </apply>
     </apply>
     <apply>
      <plus></plus>
      <cn type="integer">1</cn>
      <apply>
       <times></times>
       <ci>o</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>normal-Θ</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{\log\log n}{\log d}\cdot(1+o(1))+\Theta(1)
  </annotation>
 </semantics>
</math>

</p>

<p>which is exponentially less than with totally random allocation.</p>
<h2 id="infinite-stream-of-balls">Infinite stream of balls</h2>

<p>Instead of just putting <em>m</em> balls, it is possible to consider an infinite process in which, at each time step, a single ball is added and a single ball is taken, such that the number of balls remains constant. For <em>m</em>=<em>n</em>, after a sufficiently long time, with high probability the maximum load is similar to the finite version, both with random allocation and with partially random allocation.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>
<h2 id="applications">Applications</h2>

<p><strong>Dynamic resource allocation</strong>: consider a set of <em>n</em> identical computers. There are <em>n</em> users who need computing services. The users are not coordinated - each users comes on his own and selects which computer to use. Each user would of course like to select the least loaded computer, but this requires to check the load on each computer, which might take a long time. Another option is to select a computer at random; this leads, with high probability, to a maximum load of approximately 

<math display="inline" id="Balls_into_bins:3">
 <semantics>
  <mfrac>
   <mrow>
    <mi>log</mi>
    <mi>n</mi>
   </mrow>
   <mrow>
    <mi>log</mi>
    <mrow>
     <mi>log</mi>
     <mi>n</mi>
    </mrow>
   </mrow>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <log></log>
     <ci>n</ci>
    </apply>
    <apply>
     <log></log>
     <apply>
      <log></log>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{\log n}{\log\log n}
  </annotation>
 </semantics>
</math>

. A possible compromise is that the user will check only two computers, and use the least loaded of the two. This leads, with high probability, to a much smaller maximum load of approximately 

<math display="inline" id="Balls_into_bins:4">
 <semantics>
  <mfrac>
   <mrow>
    <mi>log</mi>
    <mrow>
     <mi>log</mi>
     <mi>n</mi>
    </mrow>
   </mrow>
   <mrow>
    <mi>log</mi>
    <mn>2</mn>
   </mrow>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <log></log>
     <apply>
      <log></log>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <log></log>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{\log\log n}{\log 2}
  </annotation>
 </semantics>
</math>

.</p>

<p><strong>Hashing</strong>: consider a <a href="hash_table" title="wikilink">hash table</a> in which all keys mapped to the same location are stored in a linked list. The efficiency of accessing a key depends on the length of its list. If we use a single hash function which selects locations with uniform probability, with high probability the longest chain has 

<math display="inline" id="Balls_into_bins:5">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo>(</mo>
    <mfrac>
     <mrow>
      <mi>log</mi>
      <mi>n</mi>
     </mrow>
     <mrow>
      <mi>log</mi>
      <mrow>
       <mi>log</mi>
       <mi>n</mi>
      </mrow>
     </mrow>
    </mfrac>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <divide></divide>
     <apply>
      <log></log>
      <ci>n</ci>
     </apply>
     <apply>
      <log></log>
      <apply>
       <log></log>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O\left(\frac{\log n}{\log\log n}\right)
  </annotation>
 </semantics>
</math>

 keys. A possible improvement is to use two hash functions, and put each new key in the shorter of the two lists. In this case, with high probability the longest chain has only 

<math display="inline" id="Balls_into_bins:6">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>log</mi>
     <mrow>
      <mi>log</mi>
      <mi>n</mi>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <log></log>
     <apply>
      <log></log>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(\log\log n)
  </annotation>
 </semantics>
</math>

 elements.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>

<p><strong><a href="Proportional_division" title="wikilink">Proportional division</a></strong>. <a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>
<h2 id="references">References</h2>
<references>
</references>

<p>"</p>

<p><a href="Category:Named_probability_problems" title="wikilink">Category:Named probability problems</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
</ol>
</section>
</body>
</html>
