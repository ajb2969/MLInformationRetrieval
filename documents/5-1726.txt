   Language model      Language model   A statistical language model is a probability distribution over sequences of words. Given such a sequence, say of length   m   m   m   , it assigns a probability    P   (   w  1   ,  …  ,   w  m   )       P    subscript  w  1   normal-…   subscript  w  m      P(w_{1},\ldots,w_{m})   to the whole sequence. Having a way to estimate the relative likelihood of different phrases is useful in many natural language processing applications. Language modeling is used in speech recognition , machine translation , part-of-speech tagging , parsing , handwriting recognition , information retrieval and other applications.  In speech recognition, the computer tries to match sounds with word sequences. The language model provides context to distinguish between words and phrases that sound similar. For example, in American English , the phrases "recognize speech" and "wreck a nice beach" are pronounced almost the same but mean very different things. These ambiguities are easier to resolve when evidence from the language model is incorporated with the pronunciation model and the acoustic model .  Language models are used in information retrieval in the query likelihood model . Here a separate language model is associated with each document in a collection. Documents are ranked based on the probability of the query Q in the document's language model    P   (  Q  ∣   M  d   )      fragments  P   fragments  normal-(  Q  normal-∣   subscript  M  d   normal-)     P(Q\mid M_{d})   . Commonly, the unigram language model is used for this purpose—otherwise known as the bag of words model .  Data sparsity is a major problem in building language models. Most possible word sequences will not be observed in training. One solution is to make the assumption that the probability of a word only depends on the previous n words. This is known as an n -gram model or unigram model when n = 1.  Unigram models  A unigram model used in information retrieval can be treated as the combination of several one-state finite automata . 1 It splits the probabilities of different terms in a context, e.g. from    P   (   t  1    t  2    t  3   )   =  P   (   t  1   )   P   (   t  2   ∣   t  1   )   P   (   t  3   ∣   t  1    t  2   )      fragments  P   fragments  normal-(   subscript  t  1    subscript  t  2    subscript  t  3   normal-)    P   fragments  normal-(   subscript  t  1   normal-)   P   fragments  normal-(   subscript  t  2   normal-∣   subscript  t  1   normal-)   P   fragments  normal-(   subscript  t  3   normal-∣   subscript  t  1    subscript  t  2   normal-)     P(t_{1}t_{2}t_{3})=P(t_{1})P(t_{2}\mid t_{1})P(t_{3}\mid t_{1}t_{2})   to      P  uni    (    t  1    t  2    t  3    )    =   P   (   t  1   )   P   (   t  2   )   P   (   t  3   )           subscript  P  uni      subscript  t  1    subscript  t  2    subscript  t  3       P   subscript  t  1   P   subscript  t  2   P   subscript  t  3      P_{\text{uni}}(t_{1}t_{2}t_{3})=P(t_{1})P(t_{2})P(t_{3})   .  In this model, the probability to hit each word all depends on its own, so we only have one-state finite automata as units. For each automaton, we only have one way to hit its only state, assigned with one probability. Viewing from the whole model, the sum of all the one-state-hitting probabilities should be 1. Followed is an illustration of a unigram model of a document.      Terms   Probability in doc       a   0.1     world   0.2     likes   0.05     we   0.05     share   0.3     ...   ...           ∑  term in doc    P   (  term  )     =   1         subscript   term in doc     P  term    1    \sum_{\text{term in doc}}P(\text{term})=1\,     The probability generated for a specific query is calculated as       P   (  query  )    =    ∏  term in query    P   (  term  )           P  query     subscript  product  term in query     P  term      P(\text{query})=\prod_{\text{term in query}}P(\text{term})     For different documents, we can build their own unigram models, with different hitting probabilities of words in it. And we use probabilities from different documents to generate different hitting probabilities for a query. Then we can rank documents for a query according to the generating probabilities. Next is an example of two unigram models of two documents.      Terms   Probability in Doc1   Probability in Doc2       a   0.1   0.3     world   0.2   0.1     likes   0.05   0.03     we   0.05   0.02     share   0.3   0.2     ...   ...   ...     In information retrieval contexts, unigram language models are often smoothed to avoid instances where P (term) = 0. A common approach is to generate a maximum-likelihood model for the entire collection and linearly interpolate the collection model with a maximum-likelihood model for each document to create a smoothed document model. 2  n -gram models  In an n -gram model, the probability    P   (   w  1   ,  …  ,   w  m   )       P    subscript  w  1   normal-…   subscript  w  m      P(w_{1},\ldots,w_{m})   of observing the sentence     w  1   ,  …  ,   w  m       subscript  w  1   normal-…   subscript  w  m     w_{1},\ldots,w_{m}   is approximated as      P   (   w  1   ,  …  ,   w  m   )   =   ∏   i  =  1   m   P   (   w  i   ∣   w  1   ,  …  ,   w   i  -  1    )   ≈   ∏   i  =  1   m   P   (   w  i   ∣   w   i  -   (   n  -  1   )     ,  …  ,   w   i  -  1    )      fragments  P   fragments  normal-(   subscript  w  1   normal-,  normal-…  normal-,   subscript  w  m   normal-)     subscript   superscript  product  m     i  1    P   fragments  normal-(   subscript  w  i   normal-∣   subscript  w  1   normal-,  normal-…  normal-,   subscript  w    i  1    normal-)     subscript   superscript  product  m     i  1    P   fragments  normal-(   subscript  w  i   normal-∣   subscript  w    i    n  1     normal-,  normal-…  normal-,   subscript  w    i  1    normal-)     P(w_{1},\ldots,w_{m})=\prod^{m}_{i=1}P(w_{i}\mid w_{1},\ldots,w_{i-1})\approx%
 \prod^{m}_{i=1}P(w_{i}\mid w_{i-(n-1)},\ldots,w_{i-1})     Here, it is assumed that the probability of observing the i th word w i in the context history of the preceding i − 1 words can be approximated by the probability of observing it in the shortened context history of the preceding n − 1 words ( n th order Markov property ).  The conditional probability can be calculated from n -gram model frequency counts:      P   (   w  i   ∣   w   i  -   (   n  -  1   )     ,  …  ,   w   i  -  1    )   =    count   (   w   i  -   (   n  -  1   )     ,  …  ,   w   i  -  1    ,   w  i   )     count   (   w   i  -   (   n  -  1   )     ,  …  ,   w   i  -  1    )        fragments  P   fragments  normal-(   subscript  w  i   normal-∣   subscript  w    i    n  1     normal-,  normal-…  normal-,   subscript  w    i  1    normal-)        count    subscript  w    i    n  1     normal-…   subscript  w    i  1     subscript  w  i       count    subscript  w    i    n  1     normal-…   subscript  w    i  1         P(w_{i}\mid w_{i-(n-1)},\ldots,w_{i-1})=\frac{\mathrm{count}(w_{i-(n-1)},%
 \ldots,w_{i-1},w_{i})}{\mathrm{count}(w_{i-(n-1)},\ldots,w_{i-1})}     The words bigram and trigram language model denote n -gram model language models with n = 2 and n = 3, respectively. 3  Typically, however, the n -gram model probabilities are not derived directly from the frequency counts, because models derived this way have severe problems when confronted with any n -grams that have not explicitly been seen before. Instead, some form of smoothing is necessary, assigning some of the total probability mass to unseen words or n -grams. Various methods are used, from simple "add-one" smoothing (assign a count of 1 to unseen n -grams) to more sophisticated models, such as Good-Turing discounting or back-off models .  Example  In a bigram ( n = 2) language model, the probability of the sentence I saw the red house is approximated as      P   (  I, saw, the, red, house  )       P  I, saw, the, red, house    \displaystyle P(\text{I, saw, the, red, house})     whereas in a trigram ( n = 3) language model, the approximation is      P   (  I, saw, the, red, house  )       P  I, saw, the, red, house    \displaystyle P(\text{I, saw, the, red, house})     Note that the context of the first n – 1 n -grams is filled with start-of-sentence markers, typically denoted .  Additionally, without an end-of-sentence marker, the probability of an ungrammatical sequence *I saw the would always be higher than that of the longer sentence I saw the red house.  Neural net language models  A neural net language model is a neural network trained to predict word probabilities. Such networks alleviate the curse of dimensionality in language modeling: as language models are trained on larger and larger texts, the number of unique words (the vocabulary) increases and the number of possible sequences of words increases exponentially with the size of the vocabulary, causing a data sparsity problem because for each of the exponentially many sequences, statistics are needed to properly estimate probabilities. Neural networks avoid this problem by representing words in a distributed way, as non-linear combinations of weights in a neural net. 4 The neural net architecture might be feed-forward or recurrent .  Typically, neural net language models are constructed and trained as probabilistic classifiers that learn to predict a probability distribution      P   (   w  t   |  context  )   ∀  t  ∈  V     fragments  P   fragments  normal-(   subscript  w  t   normal-|  context  normal-)   for-all  t   V    P(w_{t}|\mathrm{context})\,\forall t\in V   .  I.e., the network is trained to predict a probability distribution over the vocabulary, given some linguistic context. This is done using standard neural net training algorithms such as stochastic gradient descent with backpropagation . The context might be a fixed-size window of previous words, so that the network predicts      P   (   w  t   |   w   t  -  k    ,  …  ,   w   t  -  1    )      fragments  P   fragments  normal-(   subscript  w  t   normal-|   subscript  w    t  k    normal-,  normal-…  normal-,   subscript  w    t  1    normal-)     P(w_{t}|w_{t-k},\dots,w_{t-1})     from a feature vector representing the previous   k   k   k   words. Another option is to use "future" words as well as "past" words as features, so that the estimated probability is 5      P   (   w  t   |   w   t  -  k    ,  …  ,   w   t  -  1    ,   w   t  +  1    ,  …  ,   w   t  +  k    )      fragments  P   fragments  normal-(   subscript  w  t   normal-|   subscript  w    t  k    normal-,  normal-…  normal-,   subscript  w    t  1    normal-,   subscript  w    t  1    normal-,  normal-…  normal-,   subscript  w    t  k    normal-)     P(w_{t}|w_{t-k},\dots,w_{t-1},w_{t+1},\dots,w_{t+k})   .  A third option, that allows faster training, is to invert the previous problem and make a neural network learn the context, given a word. One then maximizes the log-probability 6       ∑     -  k   ≤   j  -  1    ,   j  ≤  k     log  P   (   w   t  +  j    |   w  t   )      fragments   subscript    formulae-sequence      k     j  1      j  k      P   fragments  normal-(   subscript  w    t  j    normal-|   subscript  w  t   normal-)     \sum_{-k\leq j-1,\,j\leq k}\log P(w_{t+j}|w_{t})     This is called a skip-gram language model, and is the basis of the popular 7 word2vec program.  Instead of using neural net language models to produce actual probabilities, it is common to instead use the distributed representation encoded in the networks' "hidden" layers as representations of words; each word is then mapped onto an   n   n   n   -dimensional real vector called the word embedding , where   n   n   n   is the size of the layer just before the output layer. The representations in skip-gram models have the distinct characteristic that they model semantic relations between words as linear combinations , capturing a form of compositionality . For example, in some such models, if   v   v   v   is the function that maps a word   w   w   w   to its   n   n   n   -d vector representation, then         v   (  king  )    -   v   (  male  )     +   v   (  female  )     ≈   v   (  queen  )              v  king     v  male      v  female      v  queen     v(\mathrm{king})-v(\mathrm{male})+v(\mathrm{female})\approx v(\mathrm{queen})     where ≈ is made precise by stipulating that its right-hand side must be the nearest neighbor of the value of the left-hand side.  Other models  A positional language model 8 is one that describes the probability of given words occurring close to one another in a text, not necessarily immediately adjacent. Similarly, bag-of-concepts models 9 leverage on the semantics associated with multi-word expressions such as buy_christmas_present , even when they are used in information-rich sentences like "today I bought a lot of very nice Christmas presents".  See also   Factored language model  Cache language model  Katz's back-off model   Notes  References  Further reading       External links   Lecture notes on language models, parsing and machine translation with PCFG, CRF, MaxEnt, MEMM, EM, GLM, HMM by Michael Collins(Columbia University)  CSLM – Free toolkit for feedforward neural language models  DALM – Fast, Free software for language model queries  IRSTLM – Free software for language modeling  Kylm (Kyoto Language Modeling Toolkit) – Free language modeling toolkit in Java  KenLM – Fast, Free software for language modeling  LMSharp – Free language model toolkit for Kneser–Ney-smoothed  n -gram models and recurrent neural network models  MITLM – MIT Language Modeling toolkit. Free software  NPLM – Free toolkit for feedforward neural language models  OpenGrm NGram library – Free software for language modeling. Built on OpenFst .  OxLM – Free toolkit for feedforward neural language models  Positional Language Model  RandLM – Free software for randomised language modeling  RNNLM – Free recurrent neural network language model toolkit  SRILM – Proprietary software for language modeling  VariKN – Free software for creating, growing and pruning Kneser-Ney smoothed n -gram models.  Language models trained on newswire data   "  *  Category:Statistical natural language processing  Category:Markov models     Christopher D. Manning, Prabhakar Raghavan, Hinrich Schütze: An Introduction to Information Retrieval, pages 237–240. Cambridge University Press, 2009 ↩  Buttcher, Clarke, and Cormack. Information Retrieval: Implementing and Evaluating Search Engines. pg. 289–291. MIT Press. ↩  Craig Trim, What is Language Modeling? , April 26th, 2013. ↩  ↩  ↩  ↩  ↩  Yuanhua Lv and ChengXiang Zhai, Positional Language Models for Information Retrieval , in Proceedings of the 32nd international ACM SIGIR conference on Research and development in information retrieval (SIGIR), 2009. ↩  E. Cambria and A. Hussain. Sentic Computing: Techniques, Tools, and Applications. Dordrecht, Netherlands: Springer, ISBN 978-94-007-5069-2 (2012) ↩     