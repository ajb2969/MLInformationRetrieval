<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1216">Hessian form of an elliptic curve</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Hessian form of an elliptic curve</h1>
<hr/>

<p>In <a class="uri" href="geometry" title="wikilink">geometry</a>, the <strong>Hessian curve</strong> is a <a href="plane_curve" title="wikilink">plane curve</a> similar to <a href="folium_of_Descartes" title="wikilink">folium of Descartes</a>. It is named after the German mathematician <a href="Otto_Hesse" title="wikilink">Otto Hesse</a>. This curve was suggested for application in <a href="elliptic_curve_cryptography" title="wikilink">elliptic curve cryptography</a>, because arithmetic in this curve representation is faster and needs less memory than arithmetic in standard <a href="elliptic_curves" title="wikilink">Weierstrass form</a>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>
<h2 id="definition">Definition</h2>

<p> Let 

<math display="inline" id="Hessian_form_of_an_elliptic_curve:0">
 <semantics>
  <mi>K</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>K</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K
  </annotation>
 </semantics>
</math>

 be a <a href="field_(mathematics)" title="wikilink">field</a> and consider an <a href="elliptic_curve" title="wikilink">elliptic curve</a> 

<math display="inline" id="Hessian_form_of_an_elliptic_curve:1">
 <semantics>
  <mi>E</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>E</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E
  </annotation>
 </semantics>
</math>

 in the following special case of <a href="Weierstrass_form" title="wikilink">Weierstrass form</a> over 

<math display="inline" id="Hessian_form_of_an_elliptic_curve:2">
 <semantics>
  <mi>K</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>K</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K
  </annotation>
 </semantics>
</math>

:</p>

<p>

<math display="block" id="Hessian_form_of_an_elliptic_curve:3">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>Y</mi>
     <mn>2</mn>
    </msup>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>a</mi>
      <mn>1</mn>
     </msub>
     <mi>X</mi>
     <mi>Y</mi>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>a</mi>
      <mn>3</mn>
     </msub>
     <mi>Y</mi>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msup>
    <mi>X</mi>
    <mn>3</mn>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>Y</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>X</ci>
      <ci>Y</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <cn type="integer">3</cn>
      </apply>
      <ci>Y</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>X</ci>
     <cn type="integer">3</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y^{2}+a_{1}XY+a_{3}Y=X^{3}
  </annotation>
 </semantics>
</math>

</p>

<p>where the curve has <a class="uri" href="discriminant" title="wikilink">discriminant</a> 

<math display="inline" id="Hessian_form_of_an_elliptic_curve:4">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">Δ</mi>
    <mo>=</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msubsup>
       <mi>a</mi>
       <mn>3</mn>
       <mn>3</mn>
      </msubsup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <msubsup>
         <mi>a</mi>
         <mn>1</mn>
         <mn>3</mn>
        </msubsup>
        <mo>-</mo>
        <mrow>
         <mn>27</mn>
         <msub>
          <mi>a</mi>
          <mn>3</mn>
         </msub>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msubsup>
      <mi>a</mi>
      <mn>3</mn>
      <mn>3</mn>
     </msubsup>
     <mi>δ</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>normal-Δ</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <cn type="integer">3</cn>
       </apply>
       <cn type="integer">3</cn>
      </apply>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>a</ci>
         <cn type="integer">1</cn>
        </apply>
        <cn type="integer">3</cn>
       </apply>
       <apply>
        <times></times>
        <cn type="integer">27</cn>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>a</ci>
         <cn type="integer">3</cn>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <cn type="integer">3</cn>
       </apply>
       <cn type="integer">3</cn>
      </apply>
      <ci>δ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta=(a_{3}^{3}(a_{1}^{3}-27a_{3}))=a_{3}^{3}\delta.
  </annotation>
 </semantics>
</math>

 Then the point 

<math display="inline" id="Hessian_form_of_an_elliptic_curve:5">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mn>0</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>P</ci>
    <interval closure="open">
     <cn type="integer">0</cn>
     <cn type="integer">0</cn>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P=(0,0)
  </annotation>
 </semantics>
</math>

 has order 3.</p>

<p>To prove that 

<math display="inline" id="Hessian_form_of_an_elliptic_curve:6">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mn>0</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>P</ci>
    <interval closure="open">
     <cn type="integer">0</cn>
     <cn type="integer">0</cn>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P=(0,0)
  </annotation>
 </semantics>
</math>

 has order 3, note that the tangent to 

<math display="inline" id="Hessian_form_of_an_elliptic_curve:7">
 <semantics>
  <mi>E</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>E</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E
  </annotation>
 </semantics>
</math>

 at 

<math display="inline" id="Hessian_form_of_an_elliptic_curve:8">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>


 is the line 

<math display="inline" id="Hessian_form_of_an_elliptic_curve:9">
 <semantics>
  <mrow>
   <mi>Y</mi>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>Y</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y=0
  </annotation>
 </semantics>
</math>

 which intersects 

<math display="inline" id="Hessian_form_of_an_elliptic_curve:10">
 <semantics>
  <mi>E</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>E</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E
  </annotation>
 </semantics>
</math>

 with multiplicity 3 at 

<math display="inline" id="Hessian_form_of_an_elliptic_curve:11">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

.</p>

<p>Conversely, given a point 

<math display="inline" id="Hessian_form_of_an_elliptic_curve:12">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 of order 3 on an elliptic curve 

<math display="inline" id="Hessian_form_of_an_elliptic_curve:13">
 <semantics>
  <mi>E</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>E</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E
  </annotation>
 </semantics>
</math>


 both defined over a field 

<math display="inline" id="Hessian_form_of_an_elliptic_curve:14">
 <semantics>
  <mi>K</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>K</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K
  </annotation>
 </semantics>
</math>

 one can put the curve into Weierstrass form with 

<math display="inline" id="Hessian_form_of_an_elliptic_curve:15">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mn>0</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>P</ci>
    <interval closure="open">
     <cn type="integer">0</cn>
     <cn type="integer">0</cn>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P=(0,0)
  </annotation>
 </semantics>
</math>

 so that the tangent at 

<math display="inline" id="Hessian_form_of_an_elliptic_curve:16">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 is the line 

<math display="inline" id="Hessian_form_of_an_elliptic_curve:17">
 <semantics>
  <mrow>
   <mi>Y</mi>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>Y</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y=0
  </annotation>
 </semantics>
</math>

. Then the equation of the curve is 

<math display="inline" id="Hessian_form_of_an_elliptic_curve:18">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>Y</mi>
     <mn>2</mn>
    </msup>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>a</mi>
      <mn>1</mn>
     </msub>
     <mi>X</mi>
     <mi>Y</mi>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>a</mi>
      <mn>3</mn>
     </msub>
     <mi>Y</mi>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msup>
    <mi>X</mi>
    <mn>3</mn>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>Y</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>X</ci>
      <ci>Y</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <cn type="integer">3</cn>
      </apply>
      <ci>Y</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>X</ci>
     <cn type="integer">3</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y^{2}+a_{1}XY+a_{3}Y=X^{3}
  </annotation>
 </semantics>
</math>


 with 

<math display="inline" id="Hessian_form_of_an_elliptic_curve:19">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>a</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>a</mi>
     <mn>3</mn>
    </msub>
   </mrow>
   <mo>∈</mo>
   <mi>K</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <list>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <cn type="integer">3</cn>
     </apply>
    </list>
    <ci>K</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{1},a_{3}\in K
  </annotation>
 </semantics>
</math>

.</p>

<p>Now, to obtain the Hessian curve, it is necessary to do the following <a href="map_(mathematics)" title="wikilink">transformation</a>:</p>

<p>First let 

<math display="inline" id="Hessian_form_of_an_elliptic_curve:20">
 <semantics>
  <mi>μ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>μ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu
  </annotation>
 </semantics>
</math>

 denote a <a href="equation_solving" title="wikilink">root</a> of the polynomial</p>

<p>

<math display="block" id="Hessian_form_of_an_elliptic_curve:21">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msup>
      <mi>T</mi>
      <mn>3</mn>
     </msup>
     <mo>-</mo>
     <mrow>
      <mi>δ</mi>
      <msup>
       <mi>T</mi>
       <mn>2</mn>
      </msup>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mfrac>
      <msup>
       <mi>δ</mi>
       <mn>2</mn>
      </msup>
      <mn>3</mn>
     </mfrac>
     <mi>T</mi>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>a</mi>
      <mn>3</mn>
     </msub>
     <msup>
      <mi>δ</mi>
      <mn>2</mn>
     </msup>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0.</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>T</ci>
       <cn type="integer">3</cn>
      </apply>
      <apply>
       <times></times>
       <ci>δ</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>T</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>δ</ci>
        <cn type="integer">2</cn>
       </apply>
       <cn type="integer">3</cn>
      </apply>
      <ci>T</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <cn type="integer">3</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>δ</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
    <cn type="float">0.</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T^{3}-\delta T^{2}+{\delta^{2}\over 3}T+a_{3}\delta^{2}=0.
  </annotation>
 </semantics>
</math>

</p>

<p>Then</p>

<p>

<math display="block" id="Hessian_form_of_an_elliptic_curve:22">
 <semantics>
  <mrow>
   <mrow>
    <mi>μ</mi>
    <mo>=</mo>
    <mfrac>
     <mrow>
      <mi>δ</mi>
      <mo>-</mo>
      <mrow>
       <msub>
        <mi>a</mi>
        <mn>1</mn>
       </msub>
       <msup>
        <mi>δ</mi>
        <mrow>
         <mn>2</mn>
         <mo>/</mo>
         <mn>3</mn>
        </mrow>
       </msup>
      </mrow>
     </mrow>
     <mn>3</mn>
    </mfrac>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>μ</ci>
    <apply>
     <divide></divide>
     <apply>
      <minus></minus>
      <ci>δ</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>δ</ci>
        <apply>
         <divide></divide>
         <cn type="integer">2</cn>
         <cn type="integer">3</cn>
        </apply>
       </apply>
      </apply>
     </apply>
     <cn type="integer">3</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu={\delta-a_{1}\delta^{2/3}\over 3}.
  </annotation>
 </semantics>
</math>

</p>

<p>Note that if 

<math display="inline" id="Hessian_form_of_an_elliptic_curve:23">
 <semantics>
  <mi>K</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>K</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K
  </annotation>
 </semantics>
</math>


 has a finite field of order 

<math display="inline" id="Hessian_form_of_an_elliptic_curve:24">
 <semantics>
  <mrow>
   <mi>q</mi>
   <mo>≡</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <ci>q</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q\equiv 2
  </annotation>
 </semantics>
</math>

 (mod 3), then every element of 

<math display="inline" id="Hessian_form_of_an_elliptic_curve:25">
 <semantics>
  <mi>K</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>K</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K
  </annotation>
 </semantics>
</math>

 has a unique <a href="cube_root" title="wikilink">cube root</a>; in general, 

<math display="inline" id="Hessian_form_of_an_elliptic_curve:26">
 <semantics>
  <mi>μ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>μ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu
  </annotation>
 </semantics>
</math>

 lies in an extension field of <em>K</em>.</p>

<p>Now by defining the following value 

<math display="inline" id="Hessian_form_of_an_elliptic_curve:27">
 <semantics>
  <mrow>
   <mi>D</mi>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mn>3</mn>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>μ</mi>
       <mo>-</mo>
       <mi>δ</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mi>μ</mi>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>D</ci>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <cn type="integer">3</cn>
      <apply>
       <minus></minus>
       <ci>μ</ci>
       <ci>δ</ci>
      </apply>
     </apply>
     <ci>μ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D=\frac{3(\mu-\delta)}{\mu}
  </annotation>
 </semantics>
</math>

 another curve, C, is obtained, that is <a href="birational_geometry" title="wikilink">birationally equivalent</a> to E:</p>

<p>

<math display="block" id="Hessian_form_of_an_elliptic_curve:28">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

 

<math display="block" id="Hessian_form_of_an_elliptic_curve:29">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>x</mi>
     <mn>3</mn>
    </msup>
    <mo>+</mo>
    <msup>
     <mi>y</mi>
     <mn>3</mn>
    </msup>
    <mo>+</mo>
    <msup>
     <mi>z</mi>
     <mn>3</mn>
    </msup>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>D</mi>
    <mi>x</mi>
    <mi>y</mi>
    <mi>z</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <cn type="integer">3</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>y</ci>
      <cn type="integer">3</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>z</ci>
      <cn type="integer">3</cn>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>D</ci>
     <ci>x</ci>
     <ci>y</ci>
     <ci>z</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{3}+y^{3}+z^{3}=Dxyz
  </annotation>
 </semantics>
</math>

</p>

<p>which is called <em>cubic Hessian form</em> (in <a href="projective_space" title="wikilink">projective coordinates</a>)</p>

<p>

<math display="block" id="Hessian_form_of_an_elliptic_curve:30">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

 

<math display="block" id="Hessian_form_of_an_elliptic_curve:31">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>x</mi>
     <mn>3</mn>
    </msup>
    <mo>+</mo>
    <msup>
     <mi>y</mi>
     <mn>3</mn>
    </msup>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>D</mi>
    <mi>x</mi>
    <mi>y</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <cn type="integer">3</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>y</ci>
      <cn type="integer">3</cn>
     </apply>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <times></times>
     <ci>D</ci>
     <ci>x</ci>
     <ci>y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{3}+y^{3}+1=Dxy
  </annotation>
 </semantics>
</math>

</p>

<p>in the <em>affine plane</em> ( satisfying 

<math display="inline" id="Hessian_form_of_an_elliptic_curve:32">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>=</mo>
   <mfrac>
    <mi>X</mi>
    <mi>Z</mi>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>x</ci>
    <apply>
     <divide></divide>
     <ci>X</ci>
     <ci>Z</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x=\frac{X}{Z}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Hessian_form_of_an_elliptic_curve:33">
 <semantics>
  <mrow>
   <mi>y</mi>
   <mo>=</mo>
   <mfrac>
    <mi>Y</mi>
    <mi>Z</mi>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>y</ci>
    <apply>
     <divide></divide>
     <ci>Y</ci>
     <ci>Z</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y=\frac{Y}{Z}
  </annotation>
 </semantics>
</math>


 ).</p>

<p>Furthermore, 

<math display="inline" id="Hessian_form_of_an_elliptic_curve:34">
 <semantics>
  <mrow>
   <msup>
    <mi>D</mi>
    <mn>3</mn>
   </msup>
   <mo>≠</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <neq></neq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>D</ci>
     <cn type="integer">3</cn>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D^{3}\neq 1
  </annotation>
 </semantics>
</math>

 (otherwise, the curve would be <a href="singular_point_of_an_algebraic_variety" title="wikilink">singular</a>).</p>

<p>Starting from the Hessian curve, a <a href="birationally_equivalent" title="wikilink">birationally equivalent</a> <a href="Weierstrass_equation" title="wikilink">Weierstrass equation</a> is given by</p>

<p>

<math display="block" id="Hessian_form_of_an_elliptic_curve:35">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>v</mi>
     <mn>2</mn>
    </msup>
    <mo>=</mo>
    <mrow>
     <mrow>
      <msup>
       <mi>u</mi>
       <mn>3</mn>
      </msup>
      <mo>-</mo>
      <mrow>
       <mn>27</mn>
       <mi>D</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <msup>
          <mi>D</mi>
          <mn>3</mn>
         </msup>
         <mo>+</mo>
         <mn>8</mn>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mi>u</mi>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mn>54</mn>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <msup>
         <mi>D</mi>
         <mn>6</mn>
        </msup>
        <mo>-</mo>
        <mrow>
         <mn>20</mn>
         <msup>
          <mi>D</mi>
          <mn>3</mn>
         </msup>
        </mrow>
        <mo>-</mo>
        <mn>8</mn>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>v</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>u</ci>
       <cn type="integer">3</cn>
      </apply>
      <apply>
       <times></times>
       <cn type="integer">27</cn>
       <ci>D</ci>
       <apply>
        <plus></plus>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>D</ci>
         <cn type="integer">3</cn>
        </apply>
        <cn type="integer">8</cn>
       </apply>
       <ci>u</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">54</cn>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>D</ci>
        <cn type="integer">6</cn>
       </apply>
       <apply>
        <times></times>
        <cn type="integer">20</cn>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>D</ci>
         <cn type="integer">3</cn>
        </apply>
       </apply>
       <cn type="integer">8</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v^{2}=u^{3}-27D(D^{3}+8)u+54(D^{6}-20D^{3}-8),\,
  </annotation>
 </semantics>
</math>

</p>

<p>under the transformations:</p>

<p>

<math display="block" id="Hessian_form_of_an_elliptic_curve:36">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>η</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>u</mi>
       <mo>+</mo>
       <mrow>
        <mn>9</mn>
        <msup>
         <mi>D</mi>
         <mn>2</mn>
        </msup>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mi>η</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mrow>
         <mn>3</mn>
         <msup>
          <mi>D</mi>
          <mn>3</mn>
         </msup>
        </mrow>
        <mo>-</mo>
        <mrow>
         <mi>D</mi>
         <mi>x</mi>
        </mrow>
        <mo>-</mo>
        <mn>12</mn>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo rspace="4.2pt" stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <interval closure="open">
     <ci>x</ci>
     <ci>y</ci>
    </interval>
    <interval closure="open">
     <apply>
      <times></times>
      <ci>η</ci>
      <apply>
       <plus></plus>
       <ci>u</ci>
       <apply>
        <times></times>
        <cn type="integer">9</cn>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>D</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <times></times>
       <ci>η</ci>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <cn type="integer">3</cn>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>D</ci>
          <cn type="integer">3</cn>
         </apply>
        </apply>
        <apply>
         <times></times>
         <ci>D</ci>
         <ci>x</ci>
        </apply>
        <cn type="integer">12</cn>
       </apply>
      </apply>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x,y)=(\eta(u+9D^{2}),-1+\eta(3D^{3}-Dx-12))\,
  </annotation>
 </semantics>
</math>

</p>

<p>and</p>

<p>

<math display="block" id="Hessian_form_of_an_elliptic_curve:37">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>u</mi>
    <mo>,</mo>
    <mi>v</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mrow>
      <mo>-</mo>
      <mrow>
       <mn>9</mn>
       <msup>
        <mi>D</mi>
        <mn>2</mn>
       </msup>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mi>ε</mi>
      <mi>x</mi>
     </mrow>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mn>3</mn>
     <mi>ε</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>y</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo rspace="4.2pt" stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <interval closure="open">
     <ci>u</ci>
     <ci>v</ci>
    </interval>
    <interval closure="open">
     <apply>
      <plus></plus>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <cn type="integer">9</cn>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>D</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>ε</ci>
       <ci>x</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">3</cn>
      <ci>ε</ci>
      <apply>
       <minus></minus>
       <ci>y</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (u,v)=(-9D^{2}+\varepsilon x,3\varepsilon(y-1))\,
  </annotation>
 </semantics>
</math>

</p>

<p>where:</p>

<p>

<math display="block" id="Hessian_form_of_an_elliptic_curve:38">
 <semantics>
  <mrow>
   <mi>η</mi>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mn>6</mn>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msup>
        <mi>D</mi>
        <mn>3</mn>
       </msup>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <mi>v</mi>
        <mo>+</mo>
        <mrow>
         <mn>9</mn>
         <msup>
          <mi>D</mi>
          <mn>3</mn>
         </msup>
        </mrow>
       </mrow>
       <mo>-</mo>
       <mrow>
        <mn>3</mn>
        <mi>D</mi>
        <mi>u</mi>
       </mrow>
       <mo>-</mo>
       <mn>36</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mrow>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>u</mi>
        <mo>+</mo>
        <mrow>
         <mn>9</mn>
         <msup>
          <mi>D</mi>
          <mn>2</mn>
         </msup>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mn>3</mn>
     </msup>
     <mo>+</mo>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mrow>
         <mn>3</mn>
         <mi>D</mi>
         <mi>d</mi>
        </mrow>
        <mo>-</mo>
        <mrow>
         <mi>D</mi>
         <mi>u</mi>
        </mrow>
        <mo>-</mo>
        <mn>12</mn>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mn>3</mn>
     </msup>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>η</ci>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <cn type="integer">6</cn>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>D</ci>
        <cn type="integer">3</cn>
       </apply>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <minus></minus>
       <apply>
        <plus></plus>
        <ci>v</ci>
        <apply>
         <times></times>
         <cn type="integer">9</cn>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>D</ci>
          <cn type="integer">3</cn>
         </apply>
        </apply>
       </apply>
       <apply>
        <times></times>
        <cn type="integer">3</cn>
        <ci>D</ci>
        <ci>u</ci>
       </apply>
       <cn type="integer">36</cn>
      </apply>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <plus></plus>
        <ci>u</ci>
        <apply>
         <times></times>
         <cn type="integer">9</cn>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>D</ci>
          <cn type="integer">2</cn>
         </apply>
        </apply>
       </apply>
       <cn type="integer">3</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <cn type="integer">3</cn>
         <ci>D</ci>
         <ci>d</ci>
        </apply>
        <apply>
         <times></times>
         <ci>D</ci>
         <ci>u</ci>
        </apply>
        <cn type="integer">12</cn>
       </apply>
       <cn type="integer">3</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \eta=\frac{6(D^{3}-1)(v+9D^{3}-3Du-36)}{(u+9D^{2})^{3}+(3Dd-Du-12)^{3}}
  </annotation>
 </semantics>
</math>

</p>

<p>and</p>

<p>

<math display="block" id="Hessian_form_of_an_elliptic_curve:39">
 <semantics>
  <mrow>
   <mi>ε</mi>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mn>12</mn>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msup>
        <mi>D</mi>
        <mn>3</mn>
       </msup>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mrow>
     <mrow>
      <mi>D</mi>
      <mi>x</mi>
     </mrow>
     <mo>+</mo>
     <mi>y</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>ε</ci>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <cn type="integer">12</cn>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>D</ci>
        <cn type="integer">3</cn>
       </apply>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>D</ci>
       <ci>x</ci>
      </apply>
      <ci>y</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varepsilon=\frac{12(D^{3}-1)}{Dx+y+1}
  </annotation>
 </semantics>
</math>

</p>
<h2 id="group-law">Group law</h2>

<p>It is interesting to analyze the <a href="elliptic_curve#The_group_law" title="wikilink">group law</a> of the elliptic curve, defining the addition and doubling formulas (because the <a href="Power_analysis#Simple_power_analysis" title="wikilink">SPA</a> and <a href="Power_analysis#Differential_power_analysis" title="wikilink">DPA</a> attacks are based on the running time of these operations). Furthermore, in this case, we only need to use the same procedure to compute the addition, doubling or subtraction of points to get efficient results, as said above. In general, the group law is defined in the following way: <em>if three points lie in the same line then they sum up to zero</em>. So, by this property, the group laws are different for every curve.</p>

<p>In this case, the correct way is to use the Cauchy-Desboves´ formulas, obtaining the point at infinity 

<math display="inline" id="Hessian_form_of_an_elliptic_curve:40">
 <semantics>
  <mi>θ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>θ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta
  </annotation>
 </semantics>
</math>

 = ( 1 : -1: 0), that is, the <a href="identity_element" title="wikilink">neutral element</a> (the inverse of 

<math display="inline" id="Hessian_form_of_an_elliptic_curve:41">
 <semantics>
  <mi>θ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>θ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta
  </annotation>
 </semantics>
</math>

 is 

<math display="inline" id="Hessian_form_of_an_elliptic_curve:42">
 <semantics>
  <mi>θ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>θ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta
  </annotation>
 </semantics>
</math>

 again). Let P=(x<sub>1</sub>,y<sub>1</sub>) be a point on the curve. The line 

<math display="inline" id="Hessian_form_of_an_elliptic_curve:43">
 <semantics>
  <mrow>
   <mi>y</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo>-</mo>
     <mi>x</mi>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>x</mi>
       <mn>1</mn>
      </msub>
      <mo>+</mo>
      <msub>
       <mi>y</mi>
       <mn>1</mn>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>y</ci>
    <apply>
     <plus></plus>
     <apply>
      <minus></minus>
      <ci>x</ci>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y=-x+(x_{1}+y_{1})
  </annotation>
 </semantics>
</math>


 contains the point 

<math display="inline" id="Hessian_form_of_an_elliptic_curve:44">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 and the point at infinity 

<math display="inline" id="Hessian_form_of_an_elliptic_curve:45">
 <semantics>
  <mi>θ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>θ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta
  </annotation>
 </semantics>
</math>

. Therefore, -P is the third point of the intersection of this line with the curve. Intersecting the elliptic curve with the line, the following condition is obtained 

<math display="inline" id="Hessian_form_of_an_elliptic_curve:46">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>x</mi>
      <mn>2</mn>
     </msub>
     <mo>-</mo>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <msub>
         <mi>x</mi>
         <mn>1</mn>
        </msub>
        <mo>+</mo>
        <msub>
         <mi>y</mi>
         <mn>1</mn>
        </msub>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>⋅</mo>
      <mi>x</mi>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo>⋅</mo>
     <msub>
      <mi>y</mi>
      <mn>1</mn>
     </msub>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>θ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <ci>normal-⋅</ci>
       <apply>
        <plus></plus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <cn type="integer">1</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>y</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>x</ci>
      </apply>
     </apply>
     <apply>
      <ci>normal-⋅</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
    <ci>θ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{2}-(x_{1}+y_{1})\cdot x+x_{1}\cdot y_{1}=\theta
  </annotation>
 </semantics>
</math>

</p>

<p>Since 

<math display="inline" id="Hessian_form_of_an_elliptic_curve:47">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mn>1</mn>
   </msub>
   <mo>+</mo>
   <msub>
    <mi>y</mi>
    <mn>1</mn>
   </msub>
   <mo>+</mo>
   <mi>D</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>D</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1}+y_{1}+D
  </annotation>
 </semantics>
</math>

 is non zero (because 

<math display="inline" id="Hessian_form_of_an_elliptic_curve:48">
 <semantics>
  <msup>
   <mi>D</mi>
   <mn>3</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>D</ci>
    <cn type="integer">3</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D^{3}
  </annotation>
 </semantics>
</math>


 is distinct to 1), the x-coordinate of 

<math display="inline" id="Hessian_form_of_an_elliptic_curve:49">
 <semantics>
  <mrow>
   <mo>-</mo>
   <mi>P</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   -P
  </annotation>
 </semantics>
</math>

 is 

<math display="inline" id="Hessian_form_of_an_elliptic_curve:50">
 <semantics>
  <msub>
   <mi>y</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>y</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{1}
  </annotation>
 </semantics>
</math>

 and the y-coordinate of 

<math display="inline" id="Hessian_form_of_an_elliptic_curve:51">
 <semantics>
  <mrow>
   <mo>-</mo>
   <mi>P</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   -P
  </annotation>
 </semantics>
</math>

 is 

<math display="inline" id="Hessian_form_of_an_elliptic_curve:52">
 <semantics>
  <msub>
   <mi>x</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1}
  </annotation>
 </semantics>
</math>

, i.e., 

<math display="inline" id="Hessian_form_of_an_elliptic_curve:53">
 <semantics>
  <mrow>
   <mrow>
    <mo>-</mo>
    <mi>P</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>y</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <minus></minus>
     <ci>P</ci>
    </apply>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   -P=(y_{1},x_{1})
  </annotation>
 </semantics>
</math>


 or in projective coordinates 

<math display="inline" id="Hessian_form_of_an_elliptic_curve:54">
 <semantics>
  <mrow>
   <mo>-</mo>
   <mi>P</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>Y</mi>
     <mn>1</mn>
    </msub>
    <mo>:</mo>
    <msub>
     <mi>X</mi>
     <mn>1</mn>
    </msub>
    <mo>:</mo>
    <msub>
     <mi>Z</mi>
     <mn>1</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <minus></minus>
    <csymbol cd="unknown">P</csymbol>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Y</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-:</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-:</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Z</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   -P=(Y_{1}:X_{1}:Z_{1})
  </annotation>
 </semantics>
</math>

 .</p>

<p>In some application of <a href="elliptic_curve_cryptography" title="wikilink">elliptic curve cryptography</a> and the elliptic curve method of factorization (<a href="Lenstra_elliptic_curve_factorization" title="wikilink">ECM</a>) it is necessary to compute the scalar multiplications of <em>P</em>, say <em>[n]P</em> for some <a class="uri" href="integer" title="wikilink">integer</a> <em>n</em>, and they are based on the <a href="Exponentiation_by_squaring" title="wikilink">double-and-add method</a>; these operations need the addition and dobling formulas.</p>

<p><strong>Doubling</strong></p>

<p>Now, if 

<math display="inline" id="Hessian_form_of_an_elliptic_curve:55">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>X</mi>
     <mn>1</mn>
    </msub>
    <mo>:</mo>
    <msub>
     <mi>Y</mi>
     <mn>1</mn>
    </msub>
    <mo>:</mo>
    <msub>
     <mi>Z</mi>
     <mn>1</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-:</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Y</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-:</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Z</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P=(X_{1}:Y_{1}:Z_{1})
  </annotation>
 </semantics>
</math>

 is a point on the elliptic curve, it is possible to define a "doubling" operation using Cauchy-Desboves´ formulae:</p>

<p>

<math display="inline" id="Hessian_form_of_an_elliptic_curve:56">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mn>2</mn>
    <mo stretchy="false">]</mo>
   </mrow>
   <mi>P</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>Y</mi>
     <mn>1</mn>
    </msub>
    <mo>⋅</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <msubsup>
      <mi>X</mi>
      <mn>1</mn>
      <mn>3</mn>
     </msubsup>
     <mo>-</mo>
     <msubsup>
      <mi>Z</mi>
      <mn>1</mn>
      <mn>3</mn>
     </msubsup>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>:</mo>
    <msub>
     <mi>X</mi>
     <mn>1</mn>
    </msub>
    <mo>⋅</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <msubsup>
      <mi>Z</mi>
      <mn>1</mn>
      <mn>3</mn>
     </msubsup>
     <mo>-</mo>
     <msubsup>
      <mi>Y</mi>
      <mn>1</mn>
      <mn>3</mn>
     </msubsup>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>:</mo>
    <msub>
     <mi>Z</mi>
     <mn>1</mn>
    </msub>
    <mo>⋅</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <msubsup>
      <mi>Y</mi>
      <mn>1</mn>
      <mn>3</mn>
     </msubsup>
     <mo>-</mo>
     <msubsup>
      <mi>X</mi>
      <mn>1</mn>
      <mn>3</mn>
     </msubsup>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <cn type="integer">2</cn>
     <ci>normal-]</ci>
    </cerror>
    <csymbol cd="unknown">P</csymbol>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Y</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-⋅</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>X</ci>
        <cn type="integer">1</cn>
       </apply>
       <cn type="integer">3</cn>
      </apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Z</ci>
        <cn type="integer">1</cn>
       </apply>
       <cn type="integer">3</cn>
      </apply>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-:</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-⋅</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Z</ci>
        <cn type="integer">1</cn>
       </apply>
       <cn type="integer">3</cn>
      </apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Y</ci>
        <cn type="integer">1</cn>
       </apply>
       <cn type="integer">3</cn>
      </apply>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-:</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Z</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-⋅</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Y</ci>
        <cn type="integer">1</cn>
       </apply>
       <cn type="integer">3</cn>
      </apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>X</ci>
        <cn type="integer">1</cn>
       </apply>
       <cn type="integer">3</cn>
      </apply>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [2]P=(Y_{1}\cdot(X_{1}^{3}-Z_{1}^{3}):X_{1}\cdot(Z_{1}^{3}-Y_{1}^{3}):Z_{1}%
\cdot(Y_{1}^{3}-X_{1}^{3}))
  </annotation>
 </semantics>
</math>

</p>

<p><strong>Addition</strong></p>

<p>In the same way, for two different points, say 

<math display="inline" id="Hessian_form_of_an_elliptic_curve:57">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>X</mi>
     <mn>1</mn>
    </msub>
    <mo>:</mo>
    <msub>
     <mi>Y</mi>
     <mn>1</mn>
    </msub>
    <mo>:</mo>
    <msub>
     <mi>Z</mi>
     <mn>1</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-:</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Y</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-:</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Z</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P=(X_{1}:Y_{1}:Z_{1})
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Hessian_form_of_an_elliptic_curve:58">
 <semantics>
  <mrow>
   <mi>Q</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>X</mi>
     <mn>2</mn>
    </msub>
    <mo>:</mo>
    <msub>
     <mi>Y</mi>
     <mn>2</mn>
    </msub>
    <mo>:</mo>
    <msub>
     <mi>Z</mi>
     <mn>2</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">Q</csymbol>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-:</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Y</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-:</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Z</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q=(X_{2}:Y_{2}:Z_{2})
  </annotation>
 </semantics>
</math>


, it is possible to define the addition formula. Let 

<math display="inline" id="Hessian_form_of_an_elliptic_curve:59">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

 denote the sum of these points, 

<math display="inline" id="Hessian_form_of_an_elliptic_curve:60">
 <semantics>
  <mrow>
   <mi>R</mi>
   <mo>=</mo>
   <mrow>
    <mi>P</mi>
    <mo>+</mo>
    <mi>Q</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>R</ci>
    <apply>
     <plus></plus>
     <ci>P</ci>
     <ci>Q</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R=P+Q
  </annotation>
 </semantics>
</math>

, then its coordinates are given by:</p>

<p>

<math display="inline" id="Hessian_form_of_an_elliptic_curve:61">
 <semantics>
  <mrow>
   <mi>R</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>Y</mi>
     <mn>1</mn>
    </msub>
    <mo>⋅</mo>
    <msub>
     <mi>X</mi>
     <mn>2</mn>
    </msub>
    <mo>⋅</mo>
    <msub>
     <mi>Z</mi>
     <mn>2</mn>
    </msub>
    <mo>-</mo>
    <msub>
     <mi>Y</mi>
     <mn>2</mn>
    </msub>
    <mo>⋅</mo>
    <msub>
     <mi>X</mi>
     <mn>1</mn>
    </msub>
    <mo>⋅</mo>
    <msub>
     <mi>Z</mi>
     <mn>1</mn>
    </msub>
    <mo>:</mo>
    <msub>
     <mi>X</mi>
     <mn>1</mn>
    </msub>
    <mo>⋅</mo>
    <msub>
     <mi>Y</mi>
     <mn>2</mn>
    </msub>
    <mo>⋅</mo>
    <msub>
     <mi>Z</mi>
     <mn>2</mn>
    </msub>
    <mo>-</mo>
    <msub>
     <mi>X</mi>
     <mn>2</mn>
    </msub>
    <mo>⋅</mo>
    <msub>
     <mi>Y</mi>
     <mn>1</mn>
    </msub>
    <mo>⋅</mo>
    <msub>
     <mi>Z</mi>
     <mn>1</mn>
    </msub>
    <mo>:</mo>
    <msub>
     <mi>Z</mi>
     <mn>1</mn>
    </msub>
    <mo>⋅</mo>
    <msub>
     <mi>X</mi>
     <mn>2</mn>
    </msub>
    <mo>⋅</mo>
    <msub>
     <mi>Y</mi>
     <mn>2</mn>
    </msub>
    <mo>-</mo>
    <msub>
     <mi>Z</mi>
     <mn>2</mn>
    </msub>
    <mo>⋅</mo>
    <msub>
     <mi>X</mi>
     <mn>1</mn>
    </msub>
    <mo>⋅</mo>
    <msub>
     <mi>Y</mi>
     <mn>1</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">R</csymbol>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Y</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-⋅</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-⋅</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Z</ci>
      <cn type="integer">2</cn>
     </apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Y</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-⋅</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-⋅</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Z</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-:</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-⋅</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Y</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-⋅</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Z</ci>
      <cn type="integer">2</cn>
     </apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-⋅</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Y</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-⋅</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Z</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-:</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Z</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-⋅</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-⋅</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Y</ci>
      <cn type="integer">2</cn>
     </apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Z</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-⋅</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-⋅</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Y</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R=(Y_{1}\cdot X_{2}\cdot Z_{2}-Y_{2}\cdot X_{1}\cdot Z_{1}:X_{1}\cdot Y_{2}%
\cdot Z_{2}-X_{2}\cdot Y_{1}\cdot Z_{1}:Z_{1}\cdot X_{2}\cdot Y_{2}-Z_{2}\cdot
X%
_{1}\cdot Y_{1})
  </annotation>
 </semantics>
</math>

</p>
<h2 id="algorithms-and-examples">Algorithms and examples</h2>

<p>There is one <a href="algorithms" title="wikilink">algorithm</a> that can be used to add two different points or to double; it is given by <a href="Marc_Joye" title="wikilink">Joye</a> and <a href="Jean-Jacques_Quisquater" title="wikilink">Quisquater</a>. Then, the following result gives the possibility the obtain the doubling operation by the addition:</p>

<p><strong>Proposition</strong>. Let <em>P = (X,Y,Z)</em> be a point on a Hessian elliptic curve <em>E(K)</em>. Then: <em>2(X:Y:Z) = (Z:X:Y) + (Y:Z:X)</em> (2). Furthermore, we have <em>(Z:X:Y)≠(Y:Z:X).</em></p>

<p>Finally, contrary to other <a href="parametrization" title="wikilink">parameterizations</a>, there is no subtraction to compute the negation of a point. Hence, this addition algorithm can also be used for subtracting two points 

<math display="inline" id="Hessian_form_of_an_elliptic_curve:62">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>X</mi>
     <mn>1</mn>
    </msub>
    <mo>:</mo>
    <msub>
     <mi>Y</mi>
     <mn>1</mn>
    </msub>
    <mo>:</mo>
    <msub>
     <mi>Z</mi>
     <mn>1</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-:</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Y</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-:</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Z</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P=(X_{1}:Y_{1}:Z_{1})
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Hessian_form_of_an_elliptic_curve:63">
 <semantics>
  <mrow>
   <mi>Q</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>X</mi>
     <mn>2</mn>
    </msub>
    <mo>:</mo>
    <msub>
     <mi>Y</mi>
     <mn>2</mn>
    </msub>
    <mo>:</mo>
    <msub>
     <mi>Z</mi>
     <mn>2</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">Q</csymbol>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-:</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Y</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-:</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Z</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q=(X_{2}:Y_{2}:Z_{2})
  </annotation>
 </semantics>
</math>


 on a Hessian elliptic curve:</p>

<p>( X<sub>1</sub>:Y<sub>1</sub>:Z<sub>1</sub>) - ( X<sub>2</sub>:Y<sub>2</sub>:Z<sub>2</sub>) = ( X<sub>1</sub>:Y<sub>1</sub>:Z<sub>1</sub>) + (Y<sub>2</sub>:X<sub>2</sub>:Z<sub>2</sub>) (3)</p>

<p>To sum up, by adapting the order of the inputs according to equation (2) or (3), the addition algorithm presented above can be used indifferently for: Adding 2 (diff.) points, Doubling a point and Subtracting 2 points with only 12 multiplications and 7 auxiliary variables including the 3 result variables. Before the invention of <a href="Edwards_curves" title="wikilink">Edwards curves</a>, these results represent the fastest known method for implementing the elliptic curve scalar multiplication towards resistance against <a href="side-channel_attack" title="wikilink">side-channel attacks</a>.</p>

<p>For some <a class="uri" href="algorithms" title="wikilink">algorithms</a> protection against side-channel attacks is not necessary. So, for these doublings can be faster. Since there are many algorithms, only the best for the addition and doubling formulas is given here, with one example for each one:</p>
<h3 id="addition">Addition</h3>

<p>Let P<sub>1</sub> = (X<sub>1</sub>:Y<sub>1</sub>:Z<sub>1</sub>) and P<sub>2</sub> = (X<sub>2</sub>:Y<sub>2</sub>:Z<sub>2</sub>) be two points distinct to 

<math display="inline" id="Hessian_form_of_an_elliptic_curve:64">
 <semantics>
  <mi>θ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>θ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta
  </annotation>
 </semantics>
</math>

. Assuming that Z<sub>1</sub>=Z<sub>2</sub>=1 then the algorithm is given by:</p>

<p>A = X<sub>1</sub> Y<sub>2</sub></p>

<p>B = Y<sub>1</sub> X<sub>2</sub></p>
<dl>
<dd>X<sub>3</sub> = B Y<sub>1</sub>-Y<sub>2</sub> A
</dd>
<dd>Y<sub>3</sub> = X<sub>1</sub> A-B X<sub>2</sub>
</dd>
<dd>Z<sub>3</sub> = Y<sub>2</sub> X<sub>2</sub>-X<sub>1</sub> Y<sub>1</sub>
</dd>
</dl>

<p>The cost needed is 8 multiplications and 3 additions readdition cost of 7 multiplications and 3 additions, depending on the first point.</p>
<dl>
<dt>Example</dt>
</dl>

<p>Given the following points in the curve for d=-1 P<sub>1</sub>=(1:0:-1) and P<sub>2</sub>=(0:-1:1), then if P<sub>3</sub>=P<sub>1</sub>+P<sub>2</sub> we have:</p>
<dl>
<dd>X<sub>3</sub> = 0-1=-1
</dd>
<dd>Y<sub>3</sub> = -1-0=-1
</dd>
<dd>Z<sub>3</sub> = 0-0=0
</dd>
</dl>

<p>Then: P<sub>3</sub> = (-1:-1:0)</p>
<h3 id="doubling">Doubling</h3>

<p>Let <em>P</em> = (<em>X</em><sub>1</sub> : <em>Y</em><sub>1</sub> : <em>Z</em><sub>1</sub>) be a point, then the doubling formula is given by:</p>
<ul>
<li><em>A</em> = <em>X</em><sub>1</sub><sup>2</sup></li>
<li><em>B</em> = <em>Y</em><sub>1</sub><sup>2</sup></li>
<li><em>D</em> = <em>A</em> + <em>B</em></li>
<li><em>G</em> = (<em>X</em><sub>1</sub> + <em>Y</em><sub>1</sub>)<sup>2</sup> − <em>D</em></li>
<li><em>X</em><sub>3</sub> = (2<em>Y</em><sub>1</sub> − <em>G</em>) × (<em>X</em><sub>1</sub> + <em>A</em> + 1)</li>
<li><em>Y</em><sub>3</sub> = (<em>G</em> − 2<em>X</em><sub>1</sub>) × (<em>Y</em><sub>1</sub> + <em>B</em> + 1)</li>
<li><em>Z</em><sub>3</sub> = (<em>X</em><sub>1</sub> − <em>Y</em><sub>1</sub>) × (<em>G</em> + 2<em>D</em>)</li>
</ul>

<p>The cost of this algorithm is three multiplications + three squarings + 11 additions + 3×2.</p>
<dl>
<dt>Example</dt>
</dl>

<p>If 

<math display="inline" id="Hessian_form_of_an_elliptic_curve:65">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>-</mo>
    <mn>1</mn>
    <mo>:</mo>
    <mo>-</mo>
    <mn>1</mn>
    <mo>:</mo>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <minus></minus>
     <cn type="integer">1</cn>
     <ci>normal-:</ci>
     <minus></minus>
     <cn type="integer">1</cn>
     <ci>normal-:</ci>
     <cn type="integer">1</cn>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P=(-1:-1:1)
  </annotation>
 </semantics>
</math>

 is a point over the Hessian curve with parameter d=-1, then the coordinates of 

<math display="inline" id="Hessian_form_of_an_elliptic_curve:66">
 <semantics>
  <mrow>
   <mn>2</mn>
   <mi>P</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo>:</mo>
    <mi>Y</mi>
    <mo>:</mo>
    <mi>Z</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cn type="integer">2</cn>
    <csymbol cd="unknown">P</csymbol>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">X</csymbol>
     <ci>normal-:</ci>
     <csymbol cd="unknown">Y</csymbol>
     <ci>normal-:</ci>
     <csymbol cd="unknown">Z</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2P=(X:Y:Z)
  </annotation>
 </semantics>
</math>

 are given by:</p>

<p>X = (2.(-1)-2)(-1+1+1) = -4</p>

<p>Y = (-4-2.(-1))((-1)+1+1) = -2</p>

<p>Z = (-1-(-1))((-4)+2.2) = 0</p>

<p>That is, 

<math display="inline" id="Hessian_form_of_an_elliptic_curve:67">
 <semantics>
  <mrow>
   <mn>2</mn>
   <mi>P</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>-</mo>
    <mn>4</mn>
    <mo>:</mo>
    <mo>-</mo>
    <mn>2</mn>
    <mo>:</mo>
    <mn>0</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cn type="integer">2</cn>
    <csymbol cd="unknown">P</csymbol>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <minus></minus>
     <cn type="integer">4</cn>
     <ci>normal-:</ci>
     <minus></minus>
     <cn type="integer">2</cn>
     <ci>normal-:</ci>
     <cn type="integer">0</cn>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2P=(-4:-2:0)
  </annotation>
 </semantics>
</math>

</p>
<h2 id="extended-coordinates">Extended coordinates</h2>

<p>There is another coordinates system with which a Hessian curve can be represented; these new coordinates are called <strong>extended coordinates</strong>. They can speed up the addition and doubling. To have more information about operations with the extended coordinates see:</p>

<p><a class="uri" href="http://hyperelliptic.org/EFD/g1p/auto-hessian-extended.html#addition-add-20080225-hwcd">http://hyperelliptic.org/EFD/g1p/auto-hessian-extended.html#addition-add-20080225-hwcd</a></p>

<p>

<math display="inline" id="Hessian_form_of_an_elliptic_curve:68">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>


 and 

<math display="inline" id="Hessian_form_of_an_elliptic_curve:69">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

 are represented by 

<math display="inline" id="Hessian_form_of_an_elliptic_curve:70">
 <semantics>
  <mrow>
   <mi>X</mi>
   <mo>,</mo>
   <mi>Y</mi>
   <mo>,</mo>
   <mi>Z</mi>
   <mo>,</mo>
   <mrow>
    <mi>X</mi>
    <mi>X</mi>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>Y</mi>
    <mi>Y</mi>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>Z</mi>
    <mi>Z</mi>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>X</mi>
    <mi>Y</mi>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>Y</mi>
    <mi>Z</mi>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>X</mi>
    <mi>Z</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>X</ci>
    <ci>Y</ci>
    <ci>Z</ci>
    <apply>
     <times></times>
     <ci>X</ci>
     <ci>X</ci>
    </apply>
    <apply>
     <times></times>
     <ci>Y</ci>
     <ci>Y</ci>
    </apply>
    <apply>
     <times></times>
     <ci>Z</ci>
     <ci>Z</ci>
    </apply>
    <apply>
     <times></times>
     <ci>X</ci>
     <ci>Y</ci>
    </apply>
    <apply>
     <times></times>
     <ci>Y</ci>
     <ci>Z</ci>
    </apply>
    <apply>
     <times></times>
     <ci>X</ci>
     <ci>Z</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X,Y,Z,XX,YY,ZZ,XY,YZ,XZ
  </annotation>
 </semantics>
</math>

 satisfying the following equations:</p>

<p>

<math display="inline" id="Hessian_form_of_an_elliptic_curve:71">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>=</mo>
   <mrow>
    <mi>X</mi>
    <mo>/</mo>
    <mi>Z</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>x</ci>
    <apply>
     <divide></divide>
     <ci>X</ci>
     <ci>Z</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x=X/Z
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Hessian_form_of_an_elliptic_curve:72">
 <semantics>
  <mrow>
   <mi>y</mi>
   <mo>=</mo>
   <mrow>
    <mi>Y</mi>
    <mo>/</mo>
    <mi>Z</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>y</ci>
    <apply>
     <divide></divide>
     <ci>Y</ci>
     <ci>Z</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y=Y/Z
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Hessian_form_of_an_elliptic_curve:73">
 <semantics>
  <mrow>
   <mrow>
    <mi>X</mi>
    <mi>X</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>X</mi>
    <mo>⋅</mo>
    <mi>X</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>X</ci>
     <ci>X</ci>
    </apply>
    <apply>
     <ci>normal-⋅</ci>
     <ci>X</ci>
     <ci>X</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   XX=X\cdot X
  </annotation>
 </semantics>
</math>


 

<math display="inline" id="Hessian_form_of_an_elliptic_curve:74">
 <semantics>
  <mrow>
   <mrow>
    <mi>Y</mi>
    <mi>Y</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>Y</mi>
    <mo>⋅</mo>
    <mi>Y</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>Y</ci>
     <ci>Y</ci>
    </apply>
    <apply>
     <ci>normal-⋅</ci>
     <ci>Y</ci>
     <ci>Y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   YY=Y\cdot Y
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Hessian_form_of_an_elliptic_curve:75">
 <semantics>
  <mrow>
   <mrow>
    <mi>Z</mi>
    <mi>Z</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>Z</mi>
    <mo>⋅</mo>
    <mi>Z</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>Z</ci>
     <ci>Z</ci>
    </apply>
    <apply>
     <ci>normal-⋅</ci>
     <ci>Z</ci>
     <ci>Z</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ZZ=Z\cdot Z
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Hessian_form_of_an_elliptic_curve:76">
 <semantics>
  <mrow>
   <mrow>
    <mi>X</mi>
    <mi>Y</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mn>2</mn>
    <mo>⋅</mo>
    <mi>X</mi>
    <mo>⋅</mo>
    <mi>Y</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>X</ci>
     <ci>Y</ci>
    </apply>
    <apply>
     <ci>normal-⋅</ci>
     <cn type="integer">2</cn>
     <ci>X</ci>
     <ci>Y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   XY=2\cdot X\cdot Y
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Hessian_form_of_an_elliptic_curve:77">
 <semantics>
  <mrow>
   <mrow>
    <mi>Y</mi>
    <mi>Z</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mn>2</mn>
    <mo>⋅</mo>
    <mi>Y</mi>
    <mo>⋅</mo>
    <mi>Z</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>Y</ci>
     <ci>Z</ci>
    </apply>
    <apply>
     <ci>normal-⋅</ci>
     <cn type="integer">2</cn>
     <ci>Y</ci>
     <ci>Z</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   YZ=2\cdot Y\cdot Z
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Hessian_form_of_an_elliptic_curve:78">
 <semantics>
  <mrow>
   <mrow>
    <mi>X</mi>
    <mi>Z</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mn>2</mn>
    <mo>⋅</mo>
    <mi>X</mi>
    <mo>⋅</mo>
    <mi>Z</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>X</ci>
     <ci>Z</ci>
    </apply>
    <apply>
     <ci>normal-⋅</ci>
     <cn type="integer">2</cn>
     <ci>X</ci>
     <ci>Z</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   XZ=2\cdot X\cdot Z
  </annotation>
 </semantics>
</math>


</p>
<h2 id="see-also">See also</h2>

<p>For more information about the running-time required in a specific case, see <a href="Table_of_costs_of_operations_in_elliptic_curves" title="wikilink">Table of costs of operations in elliptic curves</a></p>

<p><a href="Twisted_Hessian_curves" title="wikilink">Twisted Hessian curves</a></p>
<h2 id="external-links">External links</h2>
<ul>
<li><a class="uri" href="http://hyperelliptic.org/EFD/g1p/index.html">http://hyperelliptic.org/EFD/g1p/index.html</a></li>
</ul>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<ul>
<li><a href="Otto_Hesse" title="wikilink">Otto Hesse</a> (1844), "Über die Elimination der Variabeln aus drei algebraischen Gleichungen vom zweiten Grade mit zwei Variabeln", <em>Journal für die reine und angewandte Mathematik</em>, 10, pp. 68–96</li>
<li></li>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Elliptic_curves" title="wikilink">Category:Elliptic curves</a> <a href="Category:Elliptic_curve_cryptography" title="wikilink">Category:Elliptic curve cryptography</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Cauchy-Desbove's Formulae: <em>Hessian-elliptic Curves and Side-Channel Attacks</em>, Marc Joye and Jean-Jacques Quisquarter<a href="#fnref1">↩</a></li>
</ol>
</section>
</body>
</html>
