<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1991">Constructive set theory</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Constructive set theory</h1>
<hr/>

<p><strong>Constructive set theory</strong> is an approach to <a href="constructivism_(mathematics)" title="wikilink">mathematical constructivism</a> following the program of <a href="axiomatic_set_theory" title="wikilink">axiomatic set theory</a>. That is, it uses the usual <a href="first-order_logic" title="wikilink">first-order</a> language of classical set theory, and although of course the logic is <a href="constructive_logic" title="wikilink">constructive</a>, there is no explicit use of <a href="constructive_type_theory" title="wikilink">constructive types</a>. Rather, there are just <a href="Set_(mathematics)" title="wikilink">sets</a>, thus it can look very much like classical mathematics done on the most common <a href="foundation_of_mathematics" title="wikilink">foundations</a>, namely the <a href="Zermelo–Fraenkel_axioms" title="wikilink">Zermelo–Fraenkel axioms</a> (ZFC).</p>
<h2 id="intuitionistic-zermelofraenkel">Intuitionistic Zermelo–Fraenkel</h2>

<p>In 1973, <a href="John_Myhill" title="wikilink">John Myhill</a> proposed a system of set theory based on intuitionistic logic<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> taking the most common foundation, ZFC, and throwing away the <a href="axiom_of_choice" title="wikilink">axiom of choice</a> (AC) and the <a href="law_of_the_excluded_middle" title="wikilink">law of the excluded middle</a> (LEM), leaving everything else as is. However, different forms of some of the ZFC axioms which are equivalent in the classical setting are inequivalent in the constructive setting, and some forms imply LEM.</p>

<p>The system, which has come to be known as IZF, or Intuitionistic Zermelo–Fraenkel (ZF refers to ZFC without the axiom of choice), has the usual axioms of <a href="axiom_of_extensionality" title="wikilink">extensionality</a>, <a href="axiom_of_pairing" title="wikilink">pairing</a>, <a href="axiom_of_union" title="wikilink">union</a>, <a href="axiom_of_infinity" title="wikilink">infinity</a>, <a href="axiom_schema_of_separation" title="wikilink">separation</a> and <a href="axiom_of_power_set" title="wikilink">power set</a>. The <a href="axiom_of_regularity" title="wikilink">axiom of regularity</a> is stated in the form of an <a href="epsilon-induction" title="wikilink">axiom schema of set induction</a>. Also, while Myhill used the <a href="axiom_schema_of_replacement" title="wikilink">axiom schema of replacement</a> in his system, IZF usually stands for the version with <a href="Axiom_schema_of_replacement#Axiom_schema_of_collection" title="wikilink">collection</a></p>

<p>While the axiom of replacement requires the relation <em>φ</em> to be a <a href="function_(set_theory)" title="wikilink">function</a> over the set <em>A</em> (that is, for every <em>x</em> in <em>A</em> there is associated exactly one <em>y</em>), the axiom of collection does not: it merely requires there be associated at least one <em>y</em>, and it asserts the existence of a set which collects at least one such <em>y</em> for each such <em>x</em>. The <a href="axiom_of_regularity" title="wikilink">axiom of regularity</a> as it is normally stated implies LEM, whereas the form of set induction does not. The formal statements of these two schemata are:</p>

<p>

<math display="inline" id="Constructive_set_theory:0">
 <semantics>
  <mrow>
   <mo>∀</mo>
   <mpadded width="+2.8pt">
    <mi>A</mi>
   </mpadded>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">[</mo>
     <mo>∀</mo>
     <mi>x</mi>
     <mo>∈</mo>
     <mpadded width="+2.8pt">
      <mi>A</mi>
     </mpadded>
     <mo>∃</mo>
     <mpadded width="+2.8pt">
      <mi>y</mi>
     </mpadded>
     <mi>ϕ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mi>y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
    <mo>→</mo>
    <mo>∃</mo>
    <mpadded width="+2.8pt">
     <mi>B</mi>
    </mpadded>
    <mo>∀</mo>
    <mi>x</mi>
    <mo>∈</mo>
    <mpadded width="+2.8pt">
     <mi>A</mi>
    </mpadded>
    <mo>∃</mo>
    <mi>y</mi>
    <mo>∈</mo>
    <mpadded width="+2.8pt">
     <mi>B</mi>
    </mpadded>
    <mi>ϕ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">A</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-[</ci>
      <csymbol cd="latexml">for-all</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <in></in>
      <csymbol cd="unknown">A</csymbol>
      <exists></exists>
      <csymbol cd="unknown">y</csymbol>
      <csymbol cd="unknown">ϕ</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">x</csymbol>
       <ci>normal-,</ci>
       <csymbol cd="unknown">y</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-]</ci>
     </cerror>
     <ci>normal-→</ci>
     <exists></exists>
     <csymbol cd="unknown">B</csymbol>
     <csymbol cd="latexml">for-all</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <in></in>
     <csymbol cd="unknown">A</csymbol>
     <exists></exists>
     <csymbol cd="unknown">y</csymbol>
     <in></in>
     <csymbol cd="unknown">B</csymbol>
     <csymbol cd="unknown">ϕ</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-,</ci>
      <csymbol cd="unknown">y</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall A\;([\forall x\in A\;\exists y\;\phi(x,y)]\to\exists B\;\forall x\in A%
\;\exists y\in B\;\phi(x,y))
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Constructive_set_theory:1">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mo>∀</mo>
    <mpadded width="+2.8pt">
     <mi>y</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo stretchy="false">[</mo>
      <mo>∀</mo>
      <mi>x</mi>
      <mo>∈</mo>
      <mpadded width="+2.8pt">
       <mi>y</mi>
      </mpadded>
      <mi>ϕ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo stretchy="false">]</mo>
     </mrow>
     <mo>→</mo>
     <mi>ϕ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>→</mo>
   <mo>∀</mo>
   <mpadded width="+2.8pt">
    <mi>y</mi>
   </mpadded>
   <mi>ϕ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="latexml">for-all</csymbol>
     <csymbol cd="unknown">y</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-[</ci>
       <csymbol cd="latexml">for-all</csymbol>
       <csymbol cd="unknown">x</csymbol>
       <in></in>
       <csymbol cd="unknown">y</csymbol>
       <csymbol cd="unknown">ϕ</csymbol>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <csymbol cd="unknown">x</csymbol>
        <ci>normal-)</ci>
       </cerror>
       <ci>normal-]</ci>
      </cerror>
      <ci>normal-→</ci>
      <csymbol cd="unknown">ϕ</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">y</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-]</ci>
    </cerror>
    <ci>normal-→</ci>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">y</csymbol>
    <csymbol cd="unknown">ϕ</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [\forall y\;([\forall x\in y\;\phi(x)]\to\phi(y))]\to\forall y\;\phi(y)
  </annotation>
 </semantics>
</math>

</p>

<p>Adding LEM back to IZF results in ZF, as LEM makes collection equivalent to replacement and set induction equivalent to regularity. Even without LEM, IZF's proof-theoretical power equals that of ZF.</p>
<h3 id="predicativity">Predicativity</h3>

<p>While IZF is based on constructive rather than classical logic, it is considered <a class="uri" href="impredicative" title="wikilink">impredicative</a>. It allows formation of sets using the <a href="axiom_of_separation" title="wikilink">axiom of separation</a> with any proposition, including ones which contain <a href="quantifier_(logic)" title="wikilink">quantifiers</a> which are not bounded. Thus new sets can be formed in terms of the universe of all sets. Additionally the power set axiom implies the existence of a set of <a href="truth_value" title="wikilink">truth values</a>. In the presence of LEM, this set exists and has two elements. In the absence of it, the set of truth values is also considered impredicative.</p>
<h2 id="myhills-constructive-set-theory">Myhill's constructive set theory</h2>

<p>The subject was begun by <a href="John_Myhill" title="wikilink">John Myhill</a> to provide a formal foundation for <a href="Errett_Bishop" title="wikilink">Errett Bishop</a>'s program of constructive mathematics. As he presented it, Myhill's system CST is a constructive first-order logic with three <a href="many-sorted_logic" title="wikilink">sorts</a>: <a href="natural_numbers" title="wikilink">natural numbers</a>, <a href="function_(mathematics)" title="wikilink">functions</a>, and sets. The system is:</p>
<ul>
<li>Constructive first-order predicate logic with identity, and basic axioms related to the three sorts.</li>
<li>The usual <a href="Peano_axioms" title="wikilink">Peano axioms</a> for natural numbers.</li>
<li>The usual <a href="axiom_of_extensionality" title="wikilink">axiom of extensionality</a> for sets, as well as one for functions, and the usual <a href="axiom_of_union" title="wikilink">axiom of union</a>.</li>
<li>A form of the <a href="axiom_of_infinity" title="wikilink">axiom of infinity</a> asserting that the collection of natural numbers (for which he introduces a constant <strong>N</strong>) is in fact a set.</li>
<li>Axioms asserting that the <a href="domain_(mathematics)" title="wikilink">domain</a> and <a href="range_(mathematics)" title="wikilink">range</a> of a function are both sets. Additionally, an <a href="axiom_of_non-choice" title="wikilink">axiom of non-choice</a> asserts the existence of a choice function in cases where the choice is already made. Together these act like the usual <a href="axiom_schema_of_replacement" title="wikilink">replacement axiom</a> in classical set theory.</li>
<li>The <a href="axiom_of_exponentiation" title="wikilink">axiom of exponentiation</a>, asserting that for any two sets, there is a third set which contains all (and only) the functions whose domain is the first set, and whose range is the second set. This is a greatly weakened form of the <a href="axiom_of_power_set" title="wikilink">axiom of power set</a> in classical set theory, to which Myhill, among others, objected on the grounds of its <a href="impredicative" title="wikilink">impredicativity</a>.</li>
<li>The <a href="axiom_schema_of_predicative_separation" title="wikilink">axiom of restricted, or predicative, separation</a>, which is a weakened form of the <a href="axiom_schema_of_separation" title="wikilink">separation axiom</a> in classical set theory, requiring that any <a href="quantification_(logic)" title="wikilink">quantifications</a> be bounded to another set.</li>
<li>An <a href="axiom_of_dependent_choice" title="wikilink">axiom of dependent choice</a>, which is much weaker than the usual <a href="axiom_of_choice" title="wikilink">axiom of choice</a>.</li>
</ul>
<h2 id="aczels-constructive-zermelofraenkel">Aczel's constructive Zermelo–Fraenkel</h2>

<p><a href="Peter_Aczel" title="wikilink">Peter Aczel</a>'s <em>constructive Zermelo-Fraenkel</em>,<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> or <strong>CZF</strong>, is essentially IZF with its impredicative features removed. It strengthens the collection scheme, and then drops the impredicative power set axiom and replaces it with another collection scheme. Finally the separation axiom is restricted, as in Myhill's CST. This theory has a relatively simple interpretation in a version of <a href="constructive_type_theory" title="wikilink">constructive type theory</a> and has modest proof theoretic strength as well as a fairly direct constructive and predicative justification, while retaining the language of set theory. Adding LEM to this theory also recovers full ZF.</p>

<p>The collection axioms are:</p>

<p><strong>Strong collection schema</strong>: This is the constructive replacement for the <a href="axiom_schema_of_replacement" title="wikilink">axiom schema of replacement</a>. It states that if φ is a <a href="binary_relation" title="wikilink">binary relation</a> between sets which is <em><a href="binary_relation#Special_types_of_binary_relations" title="wikilink">total</a></em> over a certain domain set (that is, it has at least one image of every element in the domain), then there exists a set which contains at least one image under φ of every element of the domain, and only images of elements of the domain. Formally, for any formula φ:</p>

<p>

<math display="inline" id="Constructive_set_theory:2">
 <semantics>
  <mrow>
   <mo>∀</mo>
   <mi>a</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mo>∀</mo>
     <mi>x</mi>
     <mo>∈</mo>
     <mpadded width="+2.8pt">
      <mi>a</mi>
     </mpadded>
     <mo>∃</mo>
     <mpadded width="+2.8pt">
      <mi>y</mi>
     </mpadded>
     <mi>ϕ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mi>y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>→</mo>
    <mo>∃</mo>
    <mpadded width="+2.8pt">
     <mi>b</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mo>∀</mo>
     <mi>x</mi>
     <mo>∈</mo>
     <mpadded width="+2.8pt">
      <mi>a</mi>
     </mpadded>
     <mo>∃</mo>
     <mi>y</mi>
     <mo>∈</mo>
     <mpadded width="+2.8pt">
      <mi>b</mi>
     </mpadded>
     <mi>ϕ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mi>y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∧</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mo>∀</mo>
     <mi>y</mi>
     <mo>∈</mo>
     <mpadded width="+2.8pt">
      <mi>b</mi>
     </mpadded>
     <mo>∃</mo>
     <mi>x</mi>
     <mo>∈</mo>
     <mpadded width="+2.8pt">
      <mi>a</mi>
     </mpadded>
     <mi>ϕ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mi>y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">a</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="latexml">for-all</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <in></in>
      <csymbol cd="unknown">a</csymbol>
      <exists></exists>
      <csymbol cd="unknown">y</csymbol>
      <csymbol cd="unknown">ϕ</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">x</csymbol>
       <ci>normal-,</ci>
       <csymbol cd="unknown">y</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-→</ci>
     <exists></exists>
     <csymbol cd="unknown">b</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="latexml">for-all</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <in></in>
      <csymbol cd="unknown">a</csymbol>
      <exists></exists>
      <csymbol cd="unknown">y</csymbol>
      <in></in>
      <csymbol cd="unknown">b</csymbol>
      <csymbol cd="unknown">ϕ</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">x</csymbol>
       <ci>normal-,</ci>
       <csymbol cd="unknown">y</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <and></and>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="latexml">for-all</csymbol>
      <csymbol cd="unknown">y</csymbol>
      <in></in>
      <csymbol cd="unknown">b</csymbol>
      <exists></exists>
      <csymbol cd="unknown">x</csymbol>
      <in></in>
      <csymbol cd="unknown">a</csymbol>
      <csymbol cd="unknown">ϕ</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">x</csymbol>
       <ci>normal-,</ci>
       <csymbol cd="unknown">y</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall a((\forall x\in a\;\exists y\;\phi(x,y))\to\exists b\;(\forall x\in a%
\;\exists y\in b\;\phi(x,y))\wedge(\forall y\in b\;\exists x\in a\;\phi(x,y)))
  </annotation>
 </semantics>
</math>

</p>

<p><strong>Subset collection schema</strong>: This is the constructive version of the <a href="power_set_axiom" title="wikilink">power set axiom</a>. Formally, for any formula φ:</p>

<p>

<math display="inline" id="Constructive_set_theory:3">
 <semantics>
  <mrow>
   <mo>∀</mo>
   <mi>a</mi>
   <mo>,</mo>
   <mpadded width="+2.8pt">
    <mi>b</mi>
   </mpadded>
   <mo>∃</mo>
   <mpadded width="+2.8pt">
    <mi>u</mi>
   </mpadded>
   <mo>∀</mo>
   <mi>z</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mo>∀</mo>
     <mi>x</mi>
     <mo>∈</mo>
     <mpadded width="+2.8pt">
      <mi>a</mi>
     </mpadded>
     <mo>∃</mo>
     <mi>y</mi>
     <mo>∈</mo>
     <mpadded width="+2.8pt">
      <mi>b</mi>
     </mpadded>
     <mi>ϕ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mi>y</mi>
      <mo>,</mo>
      <mi>z</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>→</mo>
    <mo>∃</mo>
    <mi>v</mi>
    <mo>∈</mo>
    <mpadded width="+2.8pt">
     <mi>u</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mo>∀</mo>
     <mi>x</mi>
     <mo>∈</mo>
     <mpadded width="+2.8pt">
      <mi>a</mi>
     </mpadded>
     <mo>∃</mo>
     <mi>y</mi>
     <mo>∈</mo>
     <mpadded width="+2.8pt">
      <mi>v</mi>
     </mpadded>
     <mi>ϕ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mi>y</mi>
      <mo>,</mo>
      <mi>z</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∧</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mo>∀</mo>
     <mi>y</mi>
     <mo>∈</mo>
     <mpadded width="+2.8pt">
      <mi>v</mi>
     </mpadded>
     <mo>∃</mo>
     <mi>x</mi>
     <mo>∈</mo>
     <mpadded width="+2.8pt">
      <mi>a</mi>
     </mpadded>
     <mi>ϕ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mi>y</mi>
      <mo>,</mo>
      <mi>z</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">a</csymbol>
    <ci>normal-,</ci>
    <csymbol cd="unknown">b</csymbol>
    <exists></exists>
    <csymbol cd="unknown">u</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">z</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="latexml">for-all</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <in></in>
      <csymbol cd="unknown">a</csymbol>
      <exists></exists>
      <csymbol cd="unknown">y</csymbol>
      <in></in>
      <csymbol cd="unknown">b</csymbol>
      <csymbol cd="unknown">ϕ</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">x</csymbol>
       <ci>normal-,</ci>
       <csymbol cd="unknown">y</csymbol>
       <ci>normal-,</ci>
       <csymbol cd="unknown">z</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-→</ci>
     <exists></exists>
     <csymbol cd="unknown">v</csymbol>
     <in></in>
     <csymbol cd="unknown">u</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="latexml">for-all</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <in></in>
      <csymbol cd="unknown">a</csymbol>
      <exists></exists>
      <csymbol cd="unknown">y</csymbol>
      <in></in>
      <csymbol cd="unknown">v</csymbol>
      <csymbol cd="unknown">ϕ</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">x</csymbol>
       <ci>normal-,</ci>
       <csymbol cd="unknown">y</csymbol>
       <ci>normal-,</ci>
       <csymbol cd="unknown">z</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <and></and>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="latexml">for-all</csymbol>
      <csymbol cd="unknown">y</csymbol>
      <in></in>
      <csymbol cd="unknown">v</csymbol>
      <exists></exists>
      <csymbol cd="unknown">x</csymbol>
      <in></in>
      <csymbol cd="unknown">a</csymbol>
      <csymbol cd="unknown">ϕ</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">x</csymbol>
       <ci>normal-,</ci>
       <csymbol cd="unknown">y</csymbol>
       <ci>normal-,</ci>
       <csymbol cd="unknown">z</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall a,b\;\exists u\;\forall z((\forall x\in a\;\exists y\in b\;\phi(x,y,z)%
)\to\exists v\in u\;(\forall x\in a\;\exists y\in v\;\phi(x,y,z))\wedge(%
\forall y\in v\;\exists x\in a\;\phi(x,y,z)))
  </annotation>
 </semantics>
</math>

</p>

<p>This is equivalent to a single and somewhat clearer <strong>axiom of fullness</strong>: between any two sets <em>a</em> and <em>b</em>, there is a set <em>c</em> which contains a total subrelation of any total relation between <em>a</em> and <em>b</em> that can be encoded as a set of <a href="ordered_pair" title="wikilink">ordered pairs</a>. Formally:</p>

<p>

<math display="inline" id="Constructive_set_theory:4">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>∀</mo>
     <mi>a</mi>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mpadded width="+2.8pt">
      <mi>b</mi>
     </mpadded>
     <mrow>
      <mo>∃</mo>
      <mi>c</mi>
     </mrow>
    </mrow>
   </mrow>
   <mo>⊆</mo>
   <mrow>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>a</mi>
     <mo>,</mo>
     <mi>b</mi>
     <mo rspace="5.3pt" stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo>∀</mo>
     <mi>R</mi>
    </mrow>
   </mrow>
   <mo>∈</mo>
   <mrow>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>a</mi>
     <mo>,</mo>
     <mi>b</mi>
     <mo rspace="5.3pt" stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo>∃</mo>
     <mi>S</mi>
    </mrow>
   </mrow>
   <mo>∈</mo>
   <mrow>
    <mpadded width="+2.8pt">
     <mi>c</mi>
    </mpadded>
    <mi>S</mi>
   </mrow>
   <mo>⊆</mo>
   <mi>R</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <subset></subset>
     <list>
      <apply>
       <csymbol cd="latexml">for-all</csymbol>
       <ci>a</ci>
      </apply>
      <apply>
       <times></times>
       <ci>b</ci>
       <apply>
        <exists></exists>
        <ci>c</ci>
       </apply>
      </apply>
     </list>
     <apply>
      <times></times>
      <ci>P</ci>
      <interval closure="open">
       <ci>a</ci>
       <ci>b</ci>
      </interval>
      <apply>
       <csymbol cd="latexml">for-all</csymbol>
       <ci>R</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <in></in>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>P</ci>
      <interval closure="open">
       <ci>a</ci>
       <ci>b</ci>
      </interval>
      <apply>
       <exists></exists>
       <ci>S</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <in></in>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>c</ci>
      <ci>S</ci>
     </apply>
    </apply>
    <apply>
     <subset></subset>
     <share href="#.cmml">
     </share>
     <ci>R</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall a,b\;\exists c\subseteq P(a,b)\;\forall R\in P(a,b)\;\exists S\in c\;S\subseteq
R
  </annotation>
 </semantics>
</math>

</p>

<p>where the references to <em>P(a,b)</em> are defined by:</p>

<p>

<math display="inline" id="Constructive_set_theory:5">
 <semantics>
  <mrow>
   <mi>R</mi>
   <mo>∈</mo>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>a</mi>
    <mo>,</mo>
    <mi>b</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>⇔</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>∀</mo>
    <mi>u</mi>
    <mo>∈</mo>
    <mpadded width="+2.8pt">
     <mi>R</mi>
    </mpadded>
    <mo>∃</mo>
    <mi>x</mi>
    <mo>∈</mo>
    <mpadded width="+2.8pt">
     <mi>a</mi>
    </mpadded>
    <mo>∃</mo>
    <mi>y</mi>
    <mo>∈</mo>
    <mpadded width="+2.8pt">
     <mi>b</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mo>=</mo>
    <mi>u</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∧</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>∀</mo>
    <mi>x</mi>
    <mo>∈</mo>
    <mpadded width="+2.8pt">
     <mi>a</mi>
    </mpadded>
    <mo>∃</mo>
    <mi>y</mi>
    <mo>∈</mo>
    <mpadded width="+2.8pt">
     <mi>b</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mo>∈</mo>
    <mi>R</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">R</csymbol>
    <in></in>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">a</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">b</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="latexml">iff</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="latexml">for-all</csymbol>
     <csymbol cd="unknown">u</csymbol>
     <in></in>
     <csymbol cd="unknown">R</csymbol>
     <exists></exists>
     <csymbol cd="unknown">x</csymbol>
     <in></in>
     <csymbol cd="unknown">a</csymbol>
     <exists></exists>
     <csymbol cd="unknown">y</csymbol>
     <in></in>
     <csymbol cd="unknown">b</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-⟨</ci>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-,</ci>
      <csymbol cd="unknown">y</csymbol>
      <ci>normal-⟩</ci>
     </cerror>
     <eq></eq>
     <csymbol cd="unknown">u</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <and></and>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="latexml">for-all</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <in></in>
     <csymbol cd="unknown">a</csymbol>
     <exists></exists>
     <csymbol cd="unknown">y</csymbol>
     <in></in>
     <csymbol cd="unknown">b</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-⟨</ci>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-,</ci>
      <csymbol cd="unknown">y</csymbol>
      <ci>normal-⟩</ci>
     </cerror>
     <in></in>
     <csymbol cd="unknown">R</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R\in P(a,b)\iff(\forall u\in R\;\exists x\in a\;\exists y\in b\;\langle x,y%
\rangle=u)\wedge(\forall x\in a\;\exists y\in b\;\langle x,y\rangle\in R)
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Constructive_set_theory:6">
 <semantics>
  <mrow>
   <mrow>
    <mi>c</mi>
    <mo>⊆</mo>
    <mrow>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>a</mi>
      <mo>,</mo>
      <mi>b</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>⇔</mo>
   <mrow>
    <mrow>
     <mo>∀</mo>
     <mi>R</mi>
    </mrow>
    <mo>∈</mo>
    <mrow>
     <mpadded width="+2.8pt">
      <mi>c</mi>
     </mpadded>
     <mi>R</mi>
    </mrow>
    <mo>∈</mo>
    <mrow>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>a</mi>
      <mo>,</mo>
      <mi>b</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">iff</csymbol>
    <apply>
     <subset></subset>
     <ci>c</ci>
     <apply>
      <times></times>
      <ci>P</ci>
      <interval closure="open">
       <ci>a</ci>
       <ci>b</ci>
      </interval>
     </apply>
    </apply>
    <apply>
     <and></and>
     <apply>
      <in></in>
      <apply>
       <csymbol cd="latexml">for-all</csymbol>
       <ci>R</ci>
      </apply>
      <apply>
       <times></times>
       <ci>c</ci>
       <ci>R</ci>
      </apply>
     </apply>
     <apply>
      <in></in>
      <share href="#.cmml">
      </share>
      <apply>
       <times></times>
       <ci>P</ci>
       <interval closure="open">
        <ci>a</ci>
        <ci>b</ci>
       </interval>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c\subseteq P(a,b)\iff\forall R\in c\;R\in P(a,b)
  </annotation>
 </semantics>
</math>

</p>

<p>and some set-encoding of the ordered pair <x> is assumed.</x></p>

<p>The axiom of fullness implies CST's axiom of exponentiation: given two sets, the collection of all total functions from one to the other is also in fact a set.</p>

<p>The remaining axioms of CZF are: the axioms of <a href="axiom_of_extensionality" title="wikilink">extensionality</a>, <a href="axiom_of_pairing" title="wikilink">pairing</a>, <a href="axiom_of_union" title="wikilink">union</a>, and <a href="axiom_of_infinity" title="wikilink">infinity</a> are the same as in ZF; and <a href="epsilon-induction" title="wikilink">set induction</a> and <a href="axiom_schema_of_predicative_separation" title="wikilink">predicative separation</a> are the same as above.</p>
<h2 id="interpretability-in-type-theory">Interpretability in type theory</h2>

<p>In 1977 Aczel showed that CZF can be interpreted in <a href="Martin-Löf_type_theory" title="wikilink">Martin-Löf type theory</a>,<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> (using the now consecrated <a class="uri" href="propositions-as-types" title="wikilink">propositions-as-types</a> approach) providing what is now seen a standard model of CZF in type theory.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> In 1989 Ingrid Lindström showed that <a href="non-well-founded_set" title="wikilink">non-well-founded sets</a> obtained by replacing the <a href="axiom_of_foundation" title="wikilink">axiom of foundation</a> in CZF with <a href="Aczel's_anti-foundation_axiom" title="wikilink">Aczel's anti-foundation axiom</a> (CZFA) can also be interpreted in Martin-Löf type theory.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>
<h2 id="interpretability-in-category-theory">Interpretability in category theory</h2>

<p><a href="Presheaf_(category_theory)" title="wikilink">Presheaf</a> models for constructive set theory were introduced by Nicola Gambino in 2004. They are analogous to the Presheaf models for intuitionistic set theory developed by <a href="Dana_Scott" title="wikilink">Dana Scott</a> in the 1980s (which remained unpublished).<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a><a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>
<h2 id="references">References</h2>
<h2 id="further-reading">Further reading</h2>
<ul>
<li></li>
<li>Aczel, P. and Rathjen, M. (2001). <a href="http://www.ml.kva.se/preprints/meta/AczelMon_Sep_24_09_16_56.rdf.html">Notes on constructive set theory</a>. Technical Report 40, 2000/2001. Mittag-Leffler Institute, Sweden.</li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li>Laura Crosilla, <a href="http://plato.stanford.edu/entries/set-theory-constructive/">Set Theory: Constructive and Intuitionistic ZF</a>, <a href="Stanford_Encyclopedia_of_Philosophy" title="wikilink">Stanford Encyclopedia of Philosophy</a>, Feb 20, 2009</li>
<li>Benno van den Berg, <a href="http://www.illc.uva.nl/KNAW/Heyting/uploaded_files/inlineitem/vdberg-slides.pdf">Constructive set theory – an overview</a>, slides from Heyting dag, Amsterdam, 7 September 2012</li>
</ul>

<p>"</p>

<p><a href="Category:Systems_of_set_theory" title="wikilink">Category:Systems of set theory</a> <a href="Category:Constructivism_(mathematics)" title="wikilink">Category:Constructivism (mathematics)</a> <a class="uri" href="Category:Intuitionism" title="wikilink">Category:Intuitionism</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Myhill, '' "Some properties of Intuitionistic Zermelo-Fraenkel set theory"'', Proceedings of the 1971 Cambridge Summer School in Mathematical Logic (Lecture Notes in Mathematics 337) (1973) pp 206-231<a href="#fnref1">↩</a></li>
<li id="fn2">Peter Aczel and Michael Rathjen, <a href="https://www.mittag-leffler.se/preprints/files/IML-0001-40.pdf"><em>Notes on Constructive Set Theory</em></a>, Reports Institut Mittag-Leffler, Mathematical Logic - 2000/2001, No. 40<a href="#fnref2">↩</a></li>
<li id="fn3">Aczel, Peter: 1978. The type theoretic interpretation of constructive set theory. In: A. MacIntyre et al. (eds.), Logic Colloquium '77, Amsterdam: North-Holland, 55–66.<a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5">Lindström, Ingrid: 1989. A construction of non-well-founded sets within Martin-Löf type theory. Journal of Symbolic Logic 54: 57–64.<a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7">Scott, D. S. (1985). Category-theoretic models for Intuitionistic Set Theory. Manuscript slides of a talk given at Carnegie-Mellon University<a href="#fnref7">↩</a></li>
</ol>
</section>
</body>
</html>
