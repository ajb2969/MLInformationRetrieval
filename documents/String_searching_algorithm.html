<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title offset="985">String searching algorithm</title>
   <script type="text/javascript"
      src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js">
    </script>
</head>
<body>
<h1>String searching algorithm</h1>
<hr/>
<p>In <a href="computer_science" title="wikilink">computer science</a>, <strong>string searching algorithms</strong>, sometimes called <strong>string matching algorithms</strong>, are an important class of <a href="string_algorithm" title="wikilink">string algorithms</a> that try to find a place where one or several <a href="string_(computer_science)" title="wikilink">strings</a> (also called <a href="pattern" title="wikilink">patterns</a>) are found within a larger string or text.</p>
<p>Let Σ be an <a href="Alphabet_(computer_science)" title="wikilink">alphabet</a> (<a href="finite_set" title="wikilink">finite set</a>). Formally, both the pattern and searched text are vectors of elements of Σ. The Σ may be a usual human alphabet (for example, the letters A through Z in the Latin alphabet). Other applications may use <em>binary alphabet</em> (Σ = {0,1}) or <em>DNA alphabet</em> (Σ = {A,C,G,T}) in <a class="uri" href="bioinformatics" title="wikilink">bioinformatics</a>.</p>
<p>In practice, how the string is encoded can affect the feasible string search algorithms. In particular if a <a href="variable_width_encoding" title="wikilink">variable width encoding</a> is in use then it is slow (time proportional to N) to find the Nth character. This will significantly slow down many of the more advanced search algorithms. A possible solution is to search for the sequence of code units instead, but doing so may produce false matches unless the encoding is specifically designed to avoid it.</p>
<h2 id="basic-classification">Basic classification</h2>
<p>The various <a href="algorithm" title="wikilink">algorithms</a> can be classified by the number of patterns each uses.</p>
<h3 id="single-pattern-algorithms">Single pattern algorithms</h3>
<p>Let <em>m</em> be the length of the pattern and let <em>n</em> be the length of the searchable text.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;"><p>Algorithm</p></th>
<th style="text-align: left;"><p>Preprocessing time</p></th>
<th style="text-align: left;"><p>Matching time<sup>1</sup></p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p>Naïve string search algorithm</p></td>
<td style="text-align: left;"><p>0 (no preprocessing)</p></td>
<td style="text-align: left;"><p>Θ((n−m) m)</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><a href="Rabin–Karp_string_search_algorithm" title="wikilink">Rabin–Karp string search algorithm</a></p></td>
<td style="text-align: left;"><p>Θ(m)</p></td>
<td style="text-align: left;"><p>average Θ(n+m),<br/>
worst Θ((n−m) m)</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><a href="Finite-state_machine" title="wikilink">Finite-state automaton</a> based search</p></td>
<td style="text-align: left;"><p>Θ(m |Σ|)</p></td>
<td style="text-align: left;"><p>Θ(n)</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><a href="Knuth–Morris–Pratt_algorithm" title="wikilink">Knuth–Morris–Pratt algorithm</a></p></td>
<td style="text-align: left;"><p>Θ(m)</p></td>
<td style="text-align: left;"><p>Θ(n)</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><a href="Boyer–Moore_string_search_algorithm" title="wikilink">Boyer–Moore string search algorithm</a></p></td>
<td style="text-align: left;"><p>Θ(m + |Σ|)</p></td>
<td style="text-align: left;"><p>Ω(n/m), O(nm)</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><a href="Bitap_algorithm" title="wikilink">Bitap algorithm</a> (<em>shift-or</em>, <em>shift-and</em>, <em>Baeza–Yates–Gonnet</em>)</p></td>
<td style="text-align: left;"><p>Θ(m + |Σ|)</p></td>
<td style="text-align: left;"><p>O(mn)</p></td>
</tr>
</tbody>
</table>
<p><sup>1</sup>Asymptotic times are expressed using <a href="Big_O_notation" title="wikilink">O, Ω, and Θ notation</a></p>
<p>The <strong>Boyer–Moore string search algorithm</strong> has been the standard benchmark for the practical string search literature.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>
<h3 id="algorithms-using-a-finite-set-of-patterns">Algorithms using a finite set of patterns</h3>
<ul>
<li><a href="Aho–Corasick_string_matching_algorithm" title="wikilink">Aho–Corasick string matching algorithm</a></li>
<li><a href="Commentz-Walter_algorithm" title="wikilink">Commentz-Walter algorithm</a></li>
<li><a href="Rabin–Karp_string_search_algorithm" title="wikilink">Rabin–Karp string search algorithm</a></li>
</ul>
<h3 id="algorithms-using-an-infinite-number-of-patterns">Algorithms using an infinite number of patterns</h3>
<p>Naturally, the patterns can not be enumerated in this case. They are represented usually by a <a href="regular_grammar" title="wikilink">regular grammar</a> or <a href="regular_expression" title="wikilink">regular expression</a>.</p>
<h2 id="other-classification">Other classification</h2>
<p>Other classification approaches are possible. One of the most common uses preprocessing as main criteria.</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p>Classes of string searching algorithms<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"><p>Text not preprocessed</p></td>
<td style="text-align: left;"><p>Text preprocessed</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>Patterns not preprocessed</p></td>
<td style="text-align: left;"><p>Elementary algorithms</p></td>
<td style="text-align: left;"><p>Index methods</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p>Patterns preprocessed</p></td>
<td style="text-align: left;"><p>Constructed search engines</p></td>
<td style="text-align: left;"><p>Signature methods</p></td>
</tr>
</tbody>
</table>
<h3 id="naïve-string-search">Naïve string search</h3>
<p>A simple but inefficient way to see where one string occurs inside another is to check each place it could be, one by one, to see if it's there. So first we see if there's a copy of the needle in the first character of the haystack; if not, we look to see if there's a copy of the needle starting at the second character of the haystack; if not, we look starting at the third character, and so forth. In the normal case, we only have to look at one or two characters for each wrong position to see that it is a wrong position, so in the average case, this takes <a href="Big_O_notation" title="wikilink">O</a>(<em>n</em> + <em>m</em>) steps, where <em>n</em> is the length of the haystack and <em>m</em> is the length of the needle; but in the worst case, searching for a string like "aaaab" in a string like "aaaaaaaaab", it takes <a href="Big_O_notation" title="wikilink">O</a>(<em>nm</em>)</p>
<h3 id="finite-state-automaton-based-search">Finite state automaton based search</h3>
<p> In this approach, we avoid backtracking by constructing a <a href="deterministic_finite_automaton" title="wikilink">deterministic finite automaton</a> (DFA) that recognizes stored search string. These are expensive to construct—they are usually created using the <a href="powerset_construction" title="wikilink">powerset construction</a>—but are very quick to use. For example, the <a href="deterministic_finite_automaton" title="wikilink">DFA</a> shown to the right recognizes the word "MOMMY". This approach is frequently generalized in practice to search for arbitrary <a href="regular_expression" title="wikilink">regular expressions</a>.</p>
<h3 id="stubs">Stubs</h3>
<p><a href="Knuth–Morris–Pratt_algorithm" title="wikilink">Knuth–Morris–Pratt</a> computes a <a href="deterministic_finite_automaton" title="wikilink">DFA</a> that recognizes inputs with the string to search for as a suffix, <a href="Boyer–Moore_string_search_algorithm" title="wikilink">Boyer–Moore</a> starts searching from the end of the needle, so it can usually jump ahead a whole needle-length at each step. Baeza–Yates keeps track of whether the previous <em>j</em> characters were a prefix of the search string, and is therefore adaptable to <a href="fuzzy_string_searching" title="wikilink">fuzzy string searching</a>. The <a href="bitap_algorithm" title="wikilink">bitap algorithm</a> is an application of Baeza–Yates' approach.</p>
<h3 id="index-methods">Index methods</h3>
<p>Faster search algorithms are based on preprocessing of the text. After building a <a href="substring_index" title="wikilink">substring index</a>, for example a <a href="suffix_tree" title="wikilink">suffix tree</a> or <a href="suffix_array" title="wikilink">suffix array</a>, the occurrences of a pattern can be found quickly. As an example, a suffix tree can be built in <span class="LaTeX">$\Theta(n)$</span> time, and all <span class="LaTeX">$z$</span> occurrences of a pattern can be found in <span class="LaTeX">$O(m)$</span> time under the assumption that the alphabet has a constant size and all inner nodes in the suffix tree know what leaves are underneath them. The latter can be accomplished by running a <a href="Depth-first_search" title="wikilink">DFS algorithm</a> from the root of the suffix tree.</p>
<h3 id="other-variants">Other variants</h3>
<p>Some search methods, for instance <a href="trigram_search" title="wikilink">trigram search</a>, are intended to find a "closeness" score between the search string and the text rather than a "match/non-match". These are sometimes called <a href="Approximate_string_matching" title="wikilink">"fuzzy" searches</a>.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Sequence_alignment" title="wikilink">Sequence alignment</a></li>
<li><a href="Pattern_matching" title="wikilink">Pattern matching</a></li>
<li><a href="Compressed_pattern_matching" title="wikilink">Compressed pattern matching</a></li>
<li><a href="Approximate_string_matching" title="wikilink">Approximate string matching</a></li>
<li><a href="String_metric" title="wikilink">String metric</a></li>
</ul>
<h2 id="academic-conferences-on-text-searching">Academic conferences on text searching</h2>
<ul>
<li><a href="Combinatorial_pattern_matching" title="wikilink">Combinatorial pattern matching</a> (CPM), a conference on combinatorial algorithms for strings, sequences, and trees.</li>
<li><a href="String_Processing_and_Information_Retrieval" title="wikilink">String Processing and Information Retrieval</a> (SPIRE), an annual symposium on string processing and information retrieval.</li>
<li><a href="Prague_Stringology_Conference" title="wikilink">Prague Stringology Conference</a> (PSC), an annual conference on algorithms on strings and sequences.</li>
<li><a href="Competition_on_Applied_Text_Searching" title="wikilink">Competition on Applied Text Searching</a> (CATS), an annual series of evaluations of text searching algorithms.</li>
</ul>
<h2 id="references">References</h2>
<references>
</references>
<ul>
<li>R. S. Boyer and J. S. Moore, <em><a href="http://www.cs.utexas.edu/~moore/publications/fstrpos.pdf">A fast string searching algorithm</a>,</em> Carom. ACM 20, (10), 262–272(1977).</li>
<li><a href="Thomas_H._Cormen" title="wikilink">Thomas H. Cormen</a>, <a href="Charles_E._Leiserson" title="wikilink">Charles E. Leiserson</a>, <a href="Ronald_L._Rivest" title="wikilink">Ronald L. Rivest</a>, and <a href="Clifford_Stein" title="wikilink">Clifford Stein</a>. <em><a href="Introduction_to_Algorithms" title="wikilink">Introduction to Algorithms</a></em>, Second Edition. MIT Press and McGraw-Hill, 2001. ISBN 0-262-03293-7. Chapter 32: String Matching, pp.906–932.</li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.cs.ucr.edu/%7Estelo/pattern.html">Huge (maintained) list of pattern matching links</a> Last updated:12/27/2008 20:18:38</li>
<li><a href="http://johannburkard.de/software/stringsearch/">StringSearch – high-performance pattern matching algorithms in Java</a> – Implementations of many String-Matching-Algorithms in Java (BNDM, Boyer-Moore-Horspool, Boyer-Moore-Horspool-Raita, Shift-Or)</li>
<li><a href="http://www-igm.univ-mlv.fr/~lecroq/string/index.html">Exact String Matching Algorithms</a> — Animation in Java, Detailed description and C implementation of many algorithms.</li>
<li><a href="http://www.concentric.net/~Ttwang/tech/stringscan.htm">Boyer-Moore-Raita-Thomas</a></li>
<li><a href="http://www.cs.ucr.edu/~stelo/cpm/cpm04/35_Navarro.pdf">(PDF) Improved Single and Multiple Approximate String Matching</a></li>
<li><a href="http://www.ncbi.nlm.nih.gov/pmc/articles/PMC2647288/">Kalign2: high-performance multiple alignment of protein and nucleotide sequences allowing external features</a></li>
<li><a href="http://www.geeksforgeeks.org/suffix-tree-application-2-searching-all-patterns/">C implementation of Suffix Tree based Pattern Searching</a></li>
</ul>
<p>"</p>
<p><a href="Category:String_matching_algorithms" title="wikilink"> </a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2">Melichar, Borivoj, Jan Holub, and J. Polcar. Text Searching Algorithms. Volume I: Forward String Matching. Vol. 1. 2 vols., 2005. <a class="uri" href="http://stringology.org/athens/TextSearchingAlgorithms/">http://stringology.org/athens/TextSearchingAlgorithms/</a>.<a href="#fnref2">↩</a></li>
</ol>
</section>
</body>
</html>
