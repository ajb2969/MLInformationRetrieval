<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1709">Heat kernel signature</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Heat kernel signature</h1>
<hr/>

<p>A <strong>heat kernel signature (HKS)</strong> is a feature descriptor for use in deformable <a href="Shape_analysis_(digital_geometry)" title="wikilink">shape analysis</a> and belongs to the group of <a href="spectral_shape_analysis" title="wikilink">spectral shape analysis</a> methods. For each point in the shape, HKS defines its <a href="feature_vector" title="wikilink">feature vector</a> representing the point's local and global geometric properties. Applications include segmentation, classification, structure discovery, shape matching and shape retrieval.</p>

<p>HKS was introduced in 2009 by Jian Sun, Maks Ovsjanikov and <a href="Leonidas_Guibas" title="wikilink">Leonidas Guibas</a>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> It is based on <a href="heat_kernel" title="wikilink">heat kernel</a>, which is a fundamental solution to the <a href="heat_equation" title="wikilink">heat equation</a>. HKS is one of the many recently introduced shape descriptors which are based on the <a href="Laplace–Beltrami_operator" title="wikilink">Laplace–Beltrami operator</a> associated with the shape.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>
<h2 id="overview">Overview</h2>

<p><a href="Shape_analysis_(digital_geometry)" title="wikilink">Shape analysis</a> is the field of automatic digital analysis of shapes, e.g., 3D objects. For many shape analysis tasks (such as shape matching/retrieval), <a href="feature_vector" title="wikilink">feature vectors</a> for certain key points are used instead of using the complete <a href="3D_model" title="wikilink">3D model</a> of the shape. An important requirement of such feature descriptors is for them to be invariant under certain transformations. For <a href="rigid_transformation" title="wikilink">rigid transformations</a>, commonly used feature descriptors include <a href="shape_context" title="wikilink">shape context</a>, spin images, integral volume descriptors and multiscale local features, among others.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> HKS allows <a href="isometric_transformation" title="wikilink">isometric transformations</a> which generalizes rigid transformations.</p>

<p>HKS is based on the concept of <a href="heat_diffusion" title="wikilink">heat diffusion</a> over a surface. Given an initial heat distribution 

<math display="inline" id="Heat_kernel_signature:0">
 <semantics>
  <mrow>
   <msub>
    <mi>u</mi>
    <mn>0</mn>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>u</ci>
     <cn type="integer">0</cn>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u_{0}(x)
  </annotation>
 </semantics>
</math>

 over the surface, the heat kernel 

<math display="inline" id="Heat_kernel_signature:1">
 <semantics>
  <mrow>
   <msub>
    <mi>h</mi>
    <mi>t</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>h</ci>
     <ci>t</ci>
    </apply>
    <interval closure="open">
     <ci>x</ci>
     <ci>y</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h_{t}(x,y)
  </annotation>
 </semantics>
</math>

 relates the amount of heat transferred from 

<math display="inline" id="Heat_kernel_signature:2">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Heat_kernel_signature:3">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

 after time 

<math display="inline" id="Heat_kernel_signature:4">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

. The heat kernel is invariant under isometric transformations and stable under small perturbations to the isometry.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> In addition, the heat kernel fully characterizes shapes up to an isometry and represents increasingly global properties of the shape with increasing time.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> Since 

<math display="inline" id="Heat_kernel_signature:5">
 <semantics>
  <mrow>
   <msub>
    <mi>h</mi>
    <mi>t</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>h</ci>
     <ci>t</ci>
    </apply>
    <interval closure="open">
     <ci>x</ci>
     <ci>y</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h_{t}(x,y)
  </annotation>
 </semantics>
</math>

 is defined for a pair of points over a temporal domain, using heat kernels directly as features would lead to a high complexity. HKS instead restricts itself to just the temporal domain by considering only 

<math display="inline" id="Heat_kernel_signature:6">
 <semantics>
  <mrow>
   <msub>
    <mi>h</mi>
    <mi>t</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>h</ci>
     <ci>t</ci>
    </apply>
    <interval closure="open">
     <ci>x</ci>
     <ci>x</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h_{t}(x,x)
  </annotation>
 </semantics>
</math>

. HKS inherits most of the properties of heat kernels under certain conditions.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>
<h2 id="technical-details">Technical details</h2>

<p>The <a href="heat_diffusion" title="wikilink">heat diffusion</a> equation over a <a href="Compact_space" title="wikilink">compact</a> <a href="Riemannian_manifold" title="wikilink">Riemannian manifold</a> 

<math display="inline" id="Heat_kernel_signature:7">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 (possibly with a boundary) is given by,</p>

<p>

<math display="block" id="Heat_kernel_signature:8">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mi mathvariant="normal">Δ</mi>
      <mo>+</mo>
      <mfrac>
       <mo>∂</mo>
       <mrow>
        <mo>∂</mo>
        <mi>t</mi>
       </mrow>
      </mfrac>
     </mrow>
     <mo>)</mo>
    </mrow>
    <mi>u</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <plus></plus>
      <ci>normal-Δ</ci>
      <apply>
       <divide></divide>
       <partialdiff></partialdiff>
       <apply>
        <partialdiff></partialdiff>
        <ci>t</ci>
       </apply>
      </apply>
     </apply>
     <ci>u</ci>
     <interval closure="open">
      <ci>x</ci>
      <ci>t</ci>
     </interval>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left(\Delta+\frac{\partial}{\partial t}\right)u(x,t)=0
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Heat_kernel_signature:9">
 <semantics>
  <mi mathvariant="normal">Δ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Δ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta
  </annotation>
 </semantics>
</math>

 is the <a href="Laplace–Beltrami_operator" title="wikilink">Laplace–Beltrami operator</a> and 

<math display="inline" id="Heat_kernel_signature:10">
 <semantics>
  <mrow>
   <mi>u</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>u</ci>
    <interval closure="open">
     <ci>x</ci>
     <ci>t</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u(x,t)
  </annotation>
 </semantics>
</math>

 is the heat distribution at a point 

<math display="inline" id="Heat_kernel_signature:11">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 at time 

<math display="inline" id="Heat_kernel_signature:12">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

. The solution to this equation can be expressed as,<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>

<p>

<math display="block" id="Heat_kernel_signature:13">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>u</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo largeop="true" symmetric="true">∫</mo>
     <mrow>
      <msub>
       <mi>h</mi>
       <mi>t</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo>,</mo>
       <mi>y</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <msub>
       <mi>u</mi>
       <mn>0</mn>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>y</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>d</mi>
      <mi>y</mi>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>u</ci>
     <interval closure="open">
      <ci>x</ci>
      <ci>t</ci>
     </interval>
    </apply>
    <apply>
     <int></int>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>h</ci>
       <ci>t</ci>
      </apply>
      <interval closure="open">
       <ci>x</ci>
       <ci>y</ci>
      </interval>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>u</ci>
       <cn type="integer">0</cn>
      </apply>
      <ci>y</ci>
      <ci>d</ci>
      <ci>y</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u(x,t)=\int h_{t}(x,y)u_{0}(y)dy.
  </annotation>
 </semantics>
</math>

 The eigen decomposition of the heat kernel is expressed as,</p>

<p>

<math display="block" id="Heat_kernel_signature:14">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>h</mi>
     <mi>t</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>0</mn>
     </mrow>
     <mi mathvariant="normal">∞</mi>
    </munderover>
    <mrow>
     <mrow>
      <mi>exp</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mo>-</mo>
        <mrow>
         <msub>
          <mi>λ</mi>
          <mi>i</mi>
         </msub>
         <mi>t</mi>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <msub>
      <mi>ϕ</mi>
      <mi>i</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <msub>
      <mi>ϕ</mi>
      <mi>i</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>h</ci>
      <ci>t</ci>
     </apply>
     <interval closure="open">
      <ci>x</ci>
      <ci>y</ci>
     </interval>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <infinity></infinity>
     </apply>
     <apply>
      <times></times>
      <apply>
       <exp></exp>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>λ</ci>
          <ci>i</ci>
         </apply>
         <ci>t</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ϕ</ci>
       <ci>i</ci>
      </apply>
      <ci>x</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ϕ</ci>
       <ci>i</ci>
      </apply>
      <ci>y</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h_{t}(x,y)=\sum_{i=0}^{\infty}\exp(-\lambda_{i}t)\phi_{i}(x)\phi_{i}(y)
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Heat_kernel_signature:15">
 <semantics>
  <msub>
   <mi>λ</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>λ</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda_{i}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Heat_kernel_signature:16">
 <semantics>
  <msub>
   <mi>ϕ</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ϕ</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi_{i}
  </annotation>
 </semantics>
</math>

 are the 

<math display="inline" id="Heat_kernel_signature:17">
 <semantics>
  <msup>
   <mi>i</mi>
   <mrow>
    <mi>t</mi>
    <mi>h</mi>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>i</ci>
    <apply>
     <times></times>
     <ci>t</ci>
     <ci>h</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i^{th}
  </annotation>
 </semantics>
</math>

 eigenvalue and eigenfunction of 

<math display="inline" id="Heat_kernel_signature:18">
 <semantics>
  <mi mathvariant="normal">Δ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Δ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta
  </annotation>
 </semantics>
</math>

. The heat kernel fully characterizes a surface up to an isometry: For any <a href="surjective_map" title="wikilink">surjective map</a> 

<math display="inline" id="Heat_kernel_signature:19">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mo>:</mo>
   <mrow>
    <mi>M</mi>
    <mo>→</mo>
    <mi>N</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>T</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>M</ci>
     <ci>N</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T:M\rightarrow N
  </annotation>
 </semantics>
</math>

 between two Riemannian manifolds 

<math display="inline" id="Heat_kernel_signature:20">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Heat_kernel_signature:21">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

, if 

<math display="inline" id="Heat_kernel_signature:22">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>h</mi>
     <mi>t</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>h</mi>
     <mi>t</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>T</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mi>T</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>y</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>h</ci>
      <ci>t</ci>
     </apply>
     <interval closure="open">
      <ci>x</ci>
      <ci>y</ci>
     </interval>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>h</ci>
      <ci>t</ci>
     </apply>
     <interval closure="open">
      <apply>
       <times></times>
       <ci>T</ci>
       <ci>x</ci>
      </apply>
      <apply>
       <times></times>
       <ci>T</ci>
       <ci>y</ci>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h_{t}(x,y)=h_{t}(T(x),T(y))
  </annotation>
 </semantics>
</math>

 then 

<math display="inline" id="Heat_kernel_signature:23">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

 is an isometry, and vice versa.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> For a concise feature descriptor, HKS restricts the heat kernel only to the temporal domain,</p>

<p>

<math display="block" id="Heat_kernel_signature:24">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>h</mi>
      <mi>t</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>0</mn>
      </mrow>
      <mi mathvariant="normal">∞</mi>
     </munderover>
     <mrow>
      <mrow>
       <mi>exp</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mo>-</mo>
         <mrow>
          <msub>
           <mi>λ</mi>
           <mi>i</mi>
          </msub>
          <mi>t</mi>
         </mrow>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <msubsup>
       <mi>ϕ</mi>
       <mi>i</mi>
       <mn>2</mn>
      </msubsup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>h</ci>
      <ci>t</ci>
     </apply>
     <interval closure="open">
      <ci>x</ci>
      <ci>x</ci>
     </interval>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <infinity></infinity>
     </apply>
     <apply>
      <times></times>
      <apply>
       <exp></exp>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>λ</ci>
          <ci>i</ci>
         </apply>
         <ci>t</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ϕ</ci>
        <ci>i</ci>
       </apply>
       <cn type="integer">2</cn>
      </apply>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h_{t}(x,x)=\sum_{i=0}^{\infty}\exp(-\lambda_{i}t)\phi_{i}^{2}(x).
  </annotation>
 </semantics>
</math>

 HKS, similar to the heat kernel, characterizes surfaces under the condition that the eigenvalues of 

<math display="inline" id="Heat_kernel_signature:25">
 <semantics>
  <mi mathvariant="normal">Δ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Δ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta
  </annotation>
 </semantics>
</math>

 for 

<math display="inline" id="Heat_kernel_signature:26">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Heat_kernel_signature:27">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

 are non-repeating. The terms 

<math display="inline" id="Heat_kernel_signature:28">
 <semantics>
  <mrow>
   <mi>exp</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo>-</mo>
     <mrow>
      <msub>
       <mi>λ</mi>
       <mi>i</mi>
      </msub>
      <mi>t</mi>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <exp></exp>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>λ</ci>
       <ci>i</ci>
      </apply>
      <ci>t</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \exp(-\lambda_{i}t)
  </annotation>
 </semantics>
</math>

 can be intuited as a bank of low-pass filters, with 

<math display="inline" id="Heat_kernel_signature:29">
 <semantics>
  <msub>
   <mi>λ</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>λ</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda_{i}
  </annotation>
 </semantics>
</math>

 determining the cutoff frequencies.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></p>
<h3 id="practical-considerations">Practical considerations</h3>

<p>Since 

<math display="inline" id="Heat_kernel_signature:30">
 <semantics>
  <mrow>
   <msub>
    <mi>h</mi>
    <mi>t</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>h</ci>
     <ci>t</ci>
    </apply>
    <interval closure="open">
     <ci>x</ci>
     <ci>x</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h_{t}(x,x)
  </annotation>
 </semantics>
</math>

 is, in general, a non-parametric continuous function, HKS is in practice represented as a discrete sequence of 

<math display="inline" id="Heat_kernel_signature:31">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mrow>
    <msub>
     <mi>h</mi>
     <msub>
      <mi>t</mi>
      <mn>1</mn>
     </msub>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <mrow>
    <msub>
     <mi>h</mi>
     <msub>
      <mi>t</mi>
      <mi>n</mi>
     </msub>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>h</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>t</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <interval closure="open">
      <ci>x</ci>
      <ci>x</ci>
     </interval>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>h</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>t</ci>
       <ci>n</ci>
      </apply>
     </apply>
     <interval closure="open">
      <ci>x</ci>
      <ci>x</ci>
     </interval>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{h_{t_{1}}(x,x),\ldots,h_{t_{n}}(x,x)\}
  </annotation>
 </semantics>
</math>

 values sampled at times 

<math display="inline" id="Heat_kernel_signature:32">
 <semantics>
  <mrow>
   <msub>
    <mi>t</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>t</mi>
    <mi>n</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>t</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>t</ci>
     <ci>n</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t_{1},\ldots,t_{n}
  </annotation>
 </semantics>
</math>

.</p>

<p>In most applications, the underlying manifold for an object is not known. The HKS can be computed if a <a href="Polygon_mesh" title="wikilink">mesh</a> representation of the manifold is available, by using a discrete approximation to 

<math display="inline" id="Heat_kernel_signature:33">
 <semantics>
  <mi mathvariant="normal">Δ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Δ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta
  </annotation>
 </semantics>
</math>

 and using the discrete analogue of the heat equation. In the discrete case, the Laplace–Beltrami operator is a sparse matrix and can be written as,<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a></p>

<p>

<math display="block" id="Heat_kernel_signature:34">
 <semantics>
  <mrow>
   <mi>L</mi>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>A</mi>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <mi>W</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>L</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>A</ci>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>W</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L=A^{-1}W
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Heat_kernel_signature:35">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 is a positive diagonal matrix with entries 

<math display="inline" id="Heat_kernel_signature:36">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>i</mi>
    <mo>,</mo>
    <mi>i</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>A</ci>
    <interval closure="open">
     <ci>i</ci>
     <ci>i</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A(i,i)
  </annotation>
 </semantics>
</math>

 corresponding to the area of the triangles in the mesh sharing the vertex 

<math display="inline" id="Heat_kernel_signature:37">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="Heat_kernel_signature:38">
 <semantics>
  <mi>W</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>W</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W
  </annotation>
 </semantics>
</math>

 is a symmetric semi-definite weighting matrix. 

<math display="inline" id="Heat_kernel_signature:39">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

 can be decomposed into 

<math display="inline" id="Heat_kernel_signature:40">
 <semantics>
  <mrow>
   <mi>L</mi>
   <mo>=</mo>
   <mrow>
    <mi mathvariant="normal">Φ</mi>
    <mi mathvariant="normal">Λ</mi>
    <msup>
     <mi mathvariant="normal">Φ</mi>
     <mi>T</mi>
    </msup>
    <mi>A</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>L</ci>
    <apply>
     <times></times>
     <ci>normal-Φ</ci>
     <ci>normal-Λ</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>normal-Φ</ci>
      <ci>T</ci>
     </apply>
     <ci>A</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L=\Phi\Lambda\Phi^{T}A
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Heat_kernel_signature:41">
 <semantics>
  <mi mathvariant="normal">Λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Lambda
  </annotation>
 </semantics>
</math>

 is a diagonal matrix of the eigenvalues of 

<math display="inline" id="Heat_kernel_signature:42">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

 arranged in the ascending order, and 

<math display="inline" id="Heat_kernel_signature:43">
 <semantics>
  <mi mathvariant="normal">Φ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Φ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Phi
  </annotation>
 </semantics>
</math>

 is the matrix with the corresponding orthonormal eigenvectors. The discrete heat kernel is the matrix given by,</p>

<p>

<math display="block" id="Heat_kernel_signature:44">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>K</mi>
     <mi>t</mi>
    </msub>
    <mo>=</mo>
    <mrow>
     <mi mathvariant="normal">Φ</mi>
     <mrow>
      <mi>exp</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mo>-</mo>
        <mrow>
         <mi>t</mi>
         <mi mathvariant="normal">Λ</mi>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <msup>
      <mi mathvariant="normal">Φ</mi>
      <mi>T</mi>
     </msup>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>K</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <times></times>
     <ci>normal-Φ</ci>
     <apply>
      <exp></exp>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <ci>t</ci>
        <ci>normal-Λ</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>normal-Φ</ci>
      <ci>T</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K_{t}=\Phi\exp(-t\Lambda)\Phi^{T}.
  </annotation>
 </semantics>
</math>

 The elements 

<math display="inline" id="Heat_kernel_signature:45">
 <semantics>
  <mrow>
   <msub>
    <mi>k</mi>
    <mi>t</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>i</mi>
    <mo>,</mo>
    <mi>j</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>k</ci>
     <ci>t</ci>
    </apply>
    <interval closure="open">
     <ci>i</ci>
     <ci>j</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k_{t}(i,j)
  </annotation>
 </semantics>
</math>

 represents the heat diffusion between vertices 

<math display="inline" id="Heat_kernel_signature:46">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Heat_kernel_signature:47">
 <semantics>
  <mi>j</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>j</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   j
  </annotation>
 </semantics>
</math>

 after time 

<math display="inline" id="Heat_kernel_signature:48">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

. The HKS is then given by the diagonal entries of this matrix, sampled at discrete time intervals. Similar to the continuous case, the discrete HKS is robust to noise.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a></p>
<h2 id="limitations">Limitations</h2>
<h3 id="non-repeating-eigenvalues">Non-repeating eigenvalues</h3>

<p>The main property that characterizes surfaces using HKS up to an isometry holds only when the eigenvalues of the surfaces are non-repeating. There are certain surfaces (especially those with symmetry) where this condition is violated. A sphere is a simple example of such a surface.</p>
<h3 id="time-parameter-selection">Time parameter selection</h3>

<p>The time parameter in the HKS is closely related to the scale of global information. However, there is no direct way to choose the time discretization. The existing method chooses time samples logarithmically which is a heuristic with no guarantees<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a></p>
<h3 id="time-complexity">Time complexity</h3>

<p>The discrete heat kernel requires eigendecomposition of a matrix of size 

<math display="inline" id="Heat_kernel_signature:49">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>×</mo>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>n</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n\times n
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Heat_kernel_signature:50">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 is the number of vertices in the mesh representation of the manifold. Computing the eigendecomposition is an expensive operation, especially as 

<math display="inline" id="Heat_kernel_signature:51">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 increases. Note, however, that because of the inverse exponential dependence on the eigenvalue, typically only a small (less than 100) eigenvectors are sufficient to obtain a good approximation of the HKS.</p>
<h3 id="non-isometric-transformations">Non-isometric transformations</h3>

<p>The performance guarantees for HKS only hold for truly isometric transformations. However, deformations for real shapes are often not isometric. A simple example of such transformation is closing of the fist by a person, where the geodesic distances between two fingers changes.</p>
<h2 id="relation-with-other-methods">Relation with other methods<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a></h2>
<h3 id="curvature">Curvature</h3>

<p>The (continuous) HKS at a point 

<math display="inline" id="Heat_kernel_signature:52">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Heat_kernel_signature:53">
 <semantics>
  <mrow>
   <msub>
    <mi>h</mi>
    <mi>t</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>h</ci>
     <ci>t</ci>
    </apply>
    <interval closure="open">
     <ci>x</ci>
     <ci>x</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h_{t}(x,x)
  </annotation>
 </semantics>
</math>

 on the Riemannian manifold is related to the <a href="scalar_curvature" title="wikilink">scalar curvature</a> 

<math display="inline" id="Heat_kernel_signature:54">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>s</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s(x)
  </annotation>
 </semantics>
</math>

 by,</p>

<p>

<math display="block" id="Heat_kernel_signature:55">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>h</mi>
      <mi>t</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <mrow>
       <mn>4</mn>
       <mi>π</mi>
       <mi>t</mi>
      </mrow>
     </mfrac>
     <mo>+</mo>
     <mfrac>
      <mrow>
       <mi>s</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mrow>
       <mn>12</mn>
       <mi>π</mi>
      </mrow>
     </mfrac>
     <mo>+</mo>
     <mrow>
      <mi>O</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>h</ci>
      <ci>t</ci>
     </apply>
     <interval closure="open">
      <ci>x</ci>
      <ci>x</ci>
     </interval>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <times></times>
       <cn type="integer">4</cn>
       <ci>π</ci>
       <ci>t</ci>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <ci>s</ci>
       <ci>x</ci>
      </apply>
      <apply>
       <times></times>
       <cn type="integer">12</cn>
       <ci>π</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>O</ci>
      <ci>t</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h_{t}(x,x)=\frac{1}{4\pi t}+\frac{s(x)}{12\pi}+O(t).
  </annotation>
 </semantics>
</math>

 Hence, HKS can as be interpreted as the curvature of 

<math display="inline" id="Heat_kernel_signature:56">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 at scale 

<math display="inline" id="Heat_kernel_signature:57">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

.</p>
<h3 id="wave-kernel-signature-wks">Wave kernel signature (WKS)</h3>

<p>The WKS<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a> follows a similar idea to the HKS, replacing the heat equation with the <a href="Schrödinger_equation" title="wikilink">Schrödinger wave equation</a>,</p>

<p>

<math display="block" id="Heat_kernel_signature:58">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mrow>
       <mi>i</mi>
       <mi mathvariant="normal">Δ</mi>
      </mrow>
      <mo>+</mo>
      <mfrac>
       <mo>∂</mo>
       <mrow>
        <mo>∂</mo>
        <mi>t</mi>
       </mrow>
      </mfrac>
     </mrow>
     <mo>)</mo>
    </mrow>
    <mi>ψ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>i</ci>
       <ci>normal-Δ</ci>
      </apply>
      <apply>
       <divide></divide>
       <partialdiff></partialdiff>
       <apply>
        <partialdiff></partialdiff>
        <ci>t</ci>
       </apply>
      </apply>
     </apply>
     <ci>ψ</ci>
     <interval closure="open">
      <ci>x</ci>
      <ci>t</ci>
     </interval>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left(i\Delta+\frac{\partial}{\partial t}\right)\psi(x,t)=0
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Heat_kernel_signature:59">
 <semantics>
  <mrow>
   <mi>ψ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>ψ</ci>
    <interval closure="open">
     <ci>x</ci>
     <ci>t</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \psi(x,t)
  </annotation>
 </semantics>
</math>

 is the complex wave function. The average probability of measuring the particle at a point 

<math display="inline" id="Heat_kernel_signature:60">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 is given by,</p>

<p>

<math display="block" id="Heat_kernel_signature:61">
 <semantics>
  <mrow>
   <mrow>
    <mi>p</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>0</mn>
     </mrow>
     <mi mathvariant="normal">∞</mi>
    </munderover>
    <mrow>
     <msup>
      <mi>f</mi>
      <mn>2</mn>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>λ</mi>
       <mi>i</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
     <msubsup>
      <mi>ϕ</mi>
      <mi>i</mi>
      <mn>2</mn>
     </msubsup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>p</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <infinity></infinity>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>f</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>λ</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ϕ</ci>
        <ci>i</ci>
       </apply>
       <cn type="integer">2</cn>
      </apply>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(x)=\sum_{i=0}^{\infty}f^{2}(\lambda_{i})\phi_{i}^{2}(x)
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Heat_kernel_signature:62">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 is the initial energy distribution. By fixing a family of this energy distributions 

<math display="inline" id="Heat_kernel_signature:63">
 <semantics>
  <mrow>
   <msub>
    <mi>f</mi>
    <mi>i</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>f</ci>
     <ci>i</ci>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{i}(x)
  </annotation>
 </semantics>
</math>

, the WKS can be obtained as a discrete sequence 

<math display="inline" id="Heat_kernel_signature:64">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mrow>
    <msub>
     <mi>p</mi>
     <msub>
      <mi>f</mi>
      <mn>1</mn>
     </msub>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <mrow>
    <msub>
     <mi>p</mi>
     <msub>
      <mi>f</mi>
      <mi>n</mi>
     </msub>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>p</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>f</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>x</ci>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>p</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>f</ci>
       <ci>n</ci>
      </apply>
     </apply>
     <ci>x</ci>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{p_{f_{1}}(x),\ldots,p_{f_{n}}(x)\}
  </annotation>
 </semantics>
</math>

. Unlike HKS, the WKS can be intuited as a set of band-pass filters leading to better feature localization. However, the WKS does not represent large-scale features well (as they are <em>filtered</em> out) yielding poor performance at shape matching applications.</p>
<h3 id="global-point-signature-gps">Global point signature (GPS)</h3>

<p>Similar to the HKS, the GPS<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a> is based on the Laplace-Beltrami operator. GPS at a point 

<math display="inline" id="Heat_kernel_signature:65">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 is a vector of scaled eigenfunctions of the Laplace–Beltrami operator computed at 

<math display="inline" id="Heat_kernel_signature:66">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

. The GPS is a global feature whereas the scale of the HKS can be varied by varying the time parameter for heat diffusion. Hence, the HKS can be used in partial shape matching applications whereas the GPS cannot.</p>
<h2 id="extensions">Extensions</h2>
<h3 id="scale-invariance">Scale invariance</h3>

<p>Even though the HKS represents the shape at multiple scales, it is not inherently scale invariant. For example, the HKS for a shape and its scaled version are not the same without pre-normalization. A simple way to ensure scale invariance is by pre-scaling each shape to have the same surface area (e.g. 1). Using the notation above, this means:</p>

<p>

<math display="inline" id="Heat_kernel_signature:67">
 <semantics>
  <mtable>
   <mtr>
    <mtd columnalign="right">
     <mi>s</mi>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mi></mi>
      <mo>=</mo>
      <mrow>
       <mstyle displaystyle="true">
        <munder>
         <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
         <mi>j</mi>
        </munder>
       </mstyle>
       <msub>
        <mi>A</mi>
        <mi>j</mi>
       </msub>
      </mrow>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="right">
     <mi>A</mi>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mi></mi>
      <mo>=</mo>
      <mrow>
       <mi>A</mi>
       <mo>/</mo>
       <mi>s</mi>
      </mrow>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="right">
     <msub>
      <mi>λ</mi>
      <mi>i</mi>
     </msub>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mi></mi>
      <mo>=</mo>
      <mrow>
       <mi>s</mi>
       <msub>
        <mi>λ</mi>
        <mi>i</mi>
       </msub>
       <mtext>for each</mtext>
       <mi>i</mi>
      </mrow>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="right">
     <msub>
      <mi>ϕ</mi>
      <mi>i</mi>
     </msub>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mi></mi>
      <mo>=</mo>
      <mrow>
       <msqrt>
        <mi>s</mi>
       </msqrt>
       <msub>
        <mi>ϕ</mi>
        <mi>i</mi>
       </msub>
       <mtext>for each</mtext>
       <mi>i</mi>
      </mrow>
     </mrow>
    </mtd>
   </mtr>
  </mtable>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <ci>s</ci>
     <apply>
      <eq></eq>
      <csymbol cd="latexml">absent</csymbol>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <ci>j</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>A</ci>
        <ci>j</ci>
       </apply>
      </apply>
     </apply>
    </matrixrow>
    <matrixrow>
     <ci>A</ci>
     <apply>
      <eq></eq>
      <csymbol cd="latexml">absent</csymbol>
      <apply>
       <divide></divide>
       <ci>A</ci>
       <ci>s</ci>
      </apply>
     </apply>
    </matrixrow>
    <matrixrow>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>λ</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <eq></eq>
      <csymbol cd="latexml">absent</csymbol>
      <apply>
       <times></times>
       <ci>s</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>λ</ci>
        <ci>i</ci>
       </apply>
       <mtext>for each</mtext>
       <ci>i</ci>
      </apply>
     </apply>
    </matrixrow>
    <matrixrow>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ϕ</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <eq></eq>
      <csymbol cd="latexml">absent</csymbol>
      <apply>
       <times></times>
       <apply>
        <root></root>
        <ci>s</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ϕ</ci>
        <ci>i</ci>
       </apply>
       <mtext>for each</mtext>
       <ci>i</ci>
      </apply>
     </apply>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{aligned}\displaystyle s&\displaystyle=\sum_{j}A_{j}\\
\displaystyle A&\displaystyle=A/s\\
\displaystyle\lambda_{i}&\displaystyle=s\lambda_{i}\text{ for each }i\\
\displaystyle\phi_{i}&\displaystyle=\sqrt{s}\phi_{i}\text{ for each }i\\
\end{aligned}
  </annotation>
 </semantics>
</math>

</p>

<p>Alternatively, scale-invariant version of the HKS can also be constructed by generating a <a href="Scale_space_representation" title="wikilink">Scale space representation</a>.<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a> In the scale-space, the HKS of a scaled shape corresponds to a translation up to a multiplicative factor. The fourier transform of this HKS changes the time-translation into the complex plane, and the dependency on translation can be eliminated by considering the modulus of the transform. </p>
<h3 id="volumetric-hks">Volumetric HKS</h3>

<p>The HKS is defined for a boundary surface of a 3D shape, represented as a 2D Riemannian manifold. Instead of considering only the boundary, the entire volume of the 3D shape can be considered to define the volumetric version of the HKS.<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a> The Volumetric HKS is defined analogous to the normal HKS by considering the heat equation over the entire volume (as a 3-submanifold) and defining a <a href="Neumann_boundary_conditions" title="wikilink">Neumann boundary condition</a> over the 2-manifold boundary of the shape. Volumetric HKS characterizes transformations up to a volume isometry, which represent the transformation for real 3D objects more faithfully than boundary isometry.<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a></p>
<h3 id="shape-search">Shape Search</h3>

<p>The scale-invariant HKS features can be used in the <a href="bag_of_words_model_in_computer_vision" title="wikilink">bag-of-features</a> model for shape retrieval applications.<a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a> The features are used to construct geometric words by taking into account their spatial relations, from which shapes can be constructed (analogous to using features as words and shapes as sentences). Shapes themselves are represented using compact binary codes to form an indexed collection. Given a query shape, similar shapes in the index with possibly isometric transformations can be retrieved by using the Hamming distance of the code as the nearness-measure.</p>
<h2 id="references">References</h2>
<references>
</references>

<p>"</p>

<p><a href="Category:Image_processing" title="wikilink">Category:Image processing</a> <a href="Category:Heat_transfer" title="wikilink">Category:Heat transfer</a> <a href="Category:Digital_geometry" title="wikilink">Category:Digital geometry</a> <a class="uri" href="Category:Topology" title="wikilink">Category:Topology</a> <a href="Category:Differential_geometry" title="wikilink">Category:Differential geometry</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"></li>
<li id="fn4"></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"></li>
<li id="fn7"></li>
<li id="fn8"></li>
<li id="fn9"></li>
<li id="fn10"></li>
<li id="fn11"></li>
<li id="fn12"><a href="#fnref12">↩</a></li>
<li id="fn13"></li>
<li id="fn14"></li>
<li id="fn15"><a href="#fnref15">↩</a></li>
<li id="fn16"><a href="#fnref16">↩</a></li>
<li id="fn17"><a href="#fnref17">↩</a></li>
<li id="fn18"></li>
<li id="fn19"><a href="#fnref19">↩</a></li>
</ol>
</section>
</body>
</html>
