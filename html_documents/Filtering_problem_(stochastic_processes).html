<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1923">Filtering problem (stochastic processes)</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Filtering problem (stochastic processes)</h1><hr/>

<p>In the theory of <a href="stochastic_processes" title="wikilink">stochastic processes</a>, the <strong>filtering problem</strong> is a mathematical model for a number of filtering problems in <a href="signal_processing" title="wikilink">signal processing</a> and the like. The general idea is to form some kind of "best estimate" for the true value of some system, given only some (potentially noisy) observations of that system. The problem of optimal non-linear filtering (even for the non-stationary case) was solved by <a href="Ruslan_L._Stratonovich" title="wikilink">Ruslan L. Stratonovich</a> (1959,<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> 1960<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a>), see also <a href="Harold_J._Kushner" title="wikilink">Harold J. Kushner</a>'s work <a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> and <a href="Moshe_Zakai" title="wikilink">Moshe Zakai</a>'s, who introduced a simplified dynamics for the unnormalized conditional law of the filter<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> known as <a href="Zakai_equation" title="wikilink">Zakai equation</a>. The solution, however, is infinite-dimensional in the general case.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> Certain approximations and special cases are well-understood: for example, the linear filters are optimal for Gaussian random variables, and are known as the <a href="Wiener_filter" title="wikilink">Wiener filter</a> and the <a href="Kalman-Bucy_filter" title="wikilink">Kalman-Bucy filter</a>. More generally, as the solution is infinite dimensional, it requires finite dimensional approximations to be implemented in a computer with finite memory. A finite dimensional approximated <a href="nonlinear_filter" title="wikilink">nonlinear filter</a> may be more based on heuristics, such as the <a href="Extended_Kalman_Filter" title="wikilink">Extended Kalman Filter</a> or the Assumed Density Filters,<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> or more methodologically oriented such as for example the Projection Filters,<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> some sub-families of which are shown to coincide with the Assumed Density Filters.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></p>

<p>In general, if the <a href="separation_principle" title="wikilink">separation principle</a> applies, then filtering also arises as part of the solution of an <a href="optimal_control" title="wikilink">optimal control</a> problem. For example, the <a href="Kalman_filter" title="wikilink">Kalman filter</a> is the estimation part of the optimal control solution to the <a href="Linear-quadratic-Gaussian_control" title="wikilink">Linear-quadratic-Gaussian control</a> problem.</p>
<h2 id="the-mathematical-formalism">The mathematical formalism</h2>

<p>Consider a <a href="probability_space" title="wikilink">probability space</a> (Ω, Σ, <strong>P</strong>) and suppose that the (random) state <em>Y</em><sub><em>t</em></sub> in <em>n</em>-<a href="dimension" title="wikilink">dimensional</a> <a href="Euclidean_space" title="wikilink">Euclidean space</a> <strong>R</strong><sup><em>n</em></sup> of a system of interest at time <em>t</em> is a <a href="random_variable" title="wikilink">random variable</a> <em>Y</em><sub><em>t</em></sub> : Ω → <strong>R</strong><sup><em>n</em></sup> given by the solution to an <a href="Kiyoshi_Itō" title="wikilink">Itō</a> <a href="stochastic_differential_equation" title="wikilink">stochastic differential equation</a> of the form</p>

<p>

<math display="block" id="Filtering_problem_(stochastic_processes):0">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi mathvariant="normal">d</mi>
     <msub>
      <mi>Y</mi>
      <mi>t</mi>
     </msub>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mi>b</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo>,</mo>
       <msub>
        <mi>Y</mi>
        <mi>t</mi>
       </msub>
       <mo rspace="4.2pt" stretchy="false">)</mo>
      </mrow>
      <mi mathvariant="normal">d</mi>
      <mi>t</mi>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mi>σ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo>,</mo>
       <msub>
        <mi>Y</mi>
        <mi>t</mi>
       </msub>
       <mo rspace="4.2pt" stretchy="false">)</mo>
      </mrow>
      <mi mathvariant="normal">d</mi>
      <msub>
       <mi>B</mi>
       <mi>t</mi>
      </msub>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>normal-d</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Y</ci>
      <ci>t</ci>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>b</ci>
      <interval closure="open">
       <ci>t</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Y</ci>
        <ci>t</ci>
       </apply>
      </interval>
      <ci>normal-d</ci>
      <ci>t</ci>
     </apply>
     <apply>
      <times></times>
      <ci>σ</ci>
      <interval closure="open">
       <ci>t</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Y</ci>
        <ci>t</ci>
       </apply>
      </interval>
      <ci>normal-d</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>B</ci>
       <ci>t</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{d}Y_{t}=b(t,Y_{t})\,\mathrm{d}t+\sigma(t,Y_{t})\,\mathrm{d}B_{t},
  </annotation>
 </semantics>
</math>

</p>

<p>where <em>B</em> denotes standard <em>p</em>-dimensional <a href="Brownian_motion" title="wikilink">Brownian motion</a>, <em>b</em> : [0, +∞) × <strong>R</strong><sup><em>n</em></sup> → <strong>R</strong><sup><em>n</em></sup> is the drift field, and <em>σ</em> : [0, +∞) × <strong>R</strong><sup><em>n</em></sup> → <strong>R</strong><sup><em>n</em>×<em>p</em></sup> is the diffusion field. It is assumed that observations <em>H</em><sub><em>t</em></sub> in <strong>R</strong><sup><em>m</em></sup> (note that <em>m</em> and <em>n</em> may, in general, be unequal) are taken for each time <em>t</em> according to</p>

<p>

<math display="block" id="Filtering_problem_(stochastic_processes):1">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>H</mi>
     <mi>t</mi>
    </msub>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mi>c</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo>,</mo>
       <msub>
        <mi>Y</mi>
        <mi>t</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mrow>
       <mi>γ</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>t</mi>
        <mo>,</mo>
        <msub>
         <mi>Y</mi>
         <mi>t</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>⋅</mo>
      <mtext>noise</mtext>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>H</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>c</ci>
      <interval closure="open">
       <ci>t</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Y</ci>
        <ci>t</ci>
       </apply>
      </interval>
     </apply>
     <apply>
      <ci>normal-⋅</ci>
      <apply>
       <times></times>
       <ci>γ</ci>
       <interval closure="open">
        <ci>t</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>Y</ci>
         <ci>t</ci>
        </apply>
       </interval>
      </apply>
      <mtext>noise</mtext>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{t}=c(t,Y_{t})+\gamma(t,Y_{t})\cdot\mbox{noise}.
  </annotation>
 </semantics>
</math>

</p>

<p>Adopting the Itō interpretation of the stochastic differential and setting</p>

<p>

<math display="block" id="Filtering_problem_(stochastic_processes):2">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>Z</mi>
     <mi>t</mi>
    </msub>
    <mo>=</mo>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∫</mo>
      <mn>0</mn>
      <mi>t</mi>
     </msubsup>
     <mrow>
      <mpadded width="+1.7pt">
       <msub>
        <mi>H</mi>
        <mi>s</mi>
       </msub>
      </mpadded>
      <mi mathvariant="normal">d</mi>
      <mi>s</mi>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Z</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <int></int>
       <cn type="integer">0</cn>
      </apply>
      <ci>t</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>H</ci>
       <ci>s</ci>
      </apply>
      <ci>normal-d</ci>
      <ci>s</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z_{t}=\int_{0}^{t}H_{s}\,\mathrm{d}s,
  </annotation>
 </semantics>
</math>

</p>

<p>this gives the following stochastic integral representation for the observations <em>Z</em><sub><em>t</em></sub>:</p>

<p>

<math display="block" id="Filtering_problem_(stochastic_processes):3">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi mathvariant="normal">d</mi>
     <msub>
      <mi>Z</mi>
      <mi>t</mi>
     </msub>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mi>c</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo>,</mo>
       <msub>
        <mi>Y</mi>
        <mi>t</mi>
       </msub>
       <mo rspace="4.2pt" stretchy="false">)</mo>
      </mrow>
      <mi mathvariant="normal">d</mi>
      <mi>t</mi>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mi>γ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo>,</mo>
       <msub>
        <mi>Y</mi>
        <mi>t</mi>
       </msub>
       <mo rspace="4.2pt" stretchy="false">)</mo>
      </mrow>
      <mi mathvariant="normal">d</mi>
      <msub>
       <mi>W</mi>
       <mi>t</mi>
      </msub>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>normal-d</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Z</ci>
      <ci>t</ci>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>c</ci>
      <interval closure="open">
       <ci>t</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Y</ci>
        <ci>t</ci>
       </apply>
      </interval>
      <ci>normal-d</ci>
      <ci>t</ci>
     </apply>
     <apply>
      <times></times>
      <ci>γ</ci>
      <interval closure="open">
       <ci>t</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Y</ci>
        <ci>t</ci>
       </apply>
      </interval>
      <ci>normal-d</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>W</ci>
       <ci>t</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{d}Z_{t}=c(t,Y_{t})\,\mathrm{d}t+\gamma(t,Y_{t})\,\mathrm{d}W_{t},
  </annotation>
 </semantics>
</math>

</p>

<p>where <em>W</em> denotes standard <em>r</em>-dimensional <a href="Brownian_motion" title="wikilink">Brownian motion</a>, independent of <em>B</em> and the initial condition <em>X</em><sub>0</sub>, and <em>c</em> : [0, +∞) × <strong>R</strong><sup><em>n</em></sup> → <strong>R</strong><sup><em>n</em></sup> and <em>γ</em> : [0, +∞) × <strong>R</strong><sup><em>n</em></sup> → <strong>R</strong><sup><em>n</em>×<em>r</em></sup> satisfy</p>

<p>

<math display="block" id="Filtering_problem_(stochastic_processes):4">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo mathsize="120%" stretchy="false">|</mo>
     <mrow>
      <mi>c</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo>,</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo mathsize="120%" stretchy="false">|</mo>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mo mathsize="120%" stretchy="false">|</mo>
     <mrow>
      <mi>γ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo>,</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo mathsize="120%" stretchy="false">|</mo>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mi>C</mi>
    <mrow>
     <mo maxsize="120%" minsize="120%">(</mo>
     <mrow>
      <mn>1</mn>
      <mo>+</mo>
      <mrow>
       <mo stretchy="false">|</mo>
       <mi>x</mi>
       <mo stretchy="false">|</mo>
      </mrow>
     </mrow>
     <mo maxsize="120%" minsize="120%">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <plus></plus>
     <apply>
      <abs></abs>
      <apply>
       <times></times>
       <ci>c</ci>
       <interval closure="open">
        <ci>t</ci>
        <ci>x</ci>
       </interval>
      </apply>
     </apply>
     <apply>
      <abs></abs>
      <apply>
       <times></times>
       <ci>γ</ci>
       <interval closure="open">
        <ci>t</ci>
        <ci>x</ci>
       </interval>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>C</ci>
     <apply>
      <plus></plus>
      <cn type="integer">1</cn>
      <apply>
       <abs></abs>
       <ci>x</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \big|c(t,x)\big|+\big|\gamma(t,x)\big|\leq C\big(1+|x|\big)
  </annotation>
 </semantics>
</math>

</p>

<p>for all <em>t</em> and <em>x</em> and some constant <em>C</em>.</p>

<p>The <strong>filtering problem</strong> is the following: given observations <em>Z</em><sub><em>s</em></sub> for 0 ≤ <em>s</em> ≤ <em>t</em>, what is the best estimate <em>Ŷ</em><sub><em>t</em></sub> of the true state <em>Y</em><sub><em>t</em></sub> of the system based on those observations?</p>

<p>By "based on those observations" it is meant that <em>Ŷ</em><sub><em>t</em></sub> is <a href="measurable_function" title="wikilink">measurable</a> with respect to the <a href="sigma_algebra" title="wikilink"><em>σ</em>-algebra</a> <em>G</em><sub><em>t</em></sub> generated by the observations <em>Z</em><sub><em>s</em></sub>, 0 ≤ <em>s</em> ≤ <em>t</em>. Denote by <em>K</em> = <em>K</em>(<em>Z</em>, <em>t</em>) be collection of all <strong>R</strong><sup><em>n</em></sup>-valued random variables <em>Y</em> that are square-integrable and <em>G</em><sub><em>t</em></sub>-measurable:</p>

<p>

<math display="block" id="Filtering_problem_(stochastic_processes):5">
 <semantics>
  <mrow>
   <mrow>
    <mi>K</mi>
    <mo>=</mo>
    <mrow>
     <mi>K</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>Z</mi>
      <mo>,</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msup>
      <mi>L</mi>
      <mn>2</mn>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi mathvariant="normal">Ω</mi>
      <mo>,</mo>
      <msub>
       <mi>G</mi>
       <mi>t</mi>
      </msub>
      <mo>,</mo>
      <mi>𝐏</mi>
      <mo>;</mo>
      <msup>
       <mi>𝐑</mi>
       <mi>n</mi>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>K</ci>
     <apply>
      <times></times>
      <ci>K</ci>
      <interval closure="open">
       <ci>Z</ci>
       <ci>t</ci>
      </interval>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>L</ci>
       <cn type="integer">2</cn>
      </apply>
      <vector>
       <ci>normal-Ω</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>G</ci>
        <ci>t</ci>
       </apply>
       <ci>𝐏</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>𝐑</ci>
        <ci>n</ci>
       </apply>
      </vector>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K=K(Z,t)=L^{2}(\Omega,G_{t},\mathbf{P};\mathbf{R}^{n}).
  </annotation>
 </semantics>
</math>

</p>

<p>By "best estimate", it is meant that <em>Ŷ</em><sub><em>t</em></sub> minimizes the mean-square distance between <em>Y</em><sub><em>t</em></sub> and all candidates in <em>K</em>:</p>

<p>

<math display="block" id="Filtering_problem_(stochastic_processes):6">
 <semantics>
  <mrow>
   <mi>𝐄</mi>
   <mrow>
    <mo>[</mo>
    <mo mathsize="120%" stretchy="false">|</mo>
    <msub>
     <mi>Y</mi>
     <mi>t</mi>
    </msub>
    <mo>-</mo>
    <msub>
     <mover accent="true">
      <mi>Y</mi>
      <mo stretchy="false">^</mo>
     </mover>
     <mi>t</mi>
    </msub>
    <msup>
     <mo mathsize="120%" stretchy="false">|</mo>
     <mn>2</mn>
    </msup>
    <mo>]</mo>
   </mrow>
   <mo>=</mo>
   <munder>
    <mo movablelimits="false">inf</mo>
    <mrow>
     <mi>Y</mi>
     <mo>∈</mo>
     <mi>K</mi>
    </mrow>
   </munder>
   <mi>𝐄</mi>
   <mrow>
    <mo>[</mo>
    <mo mathsize="120%" stretchy="false">|</mo>
    <msub>
     <mi>Y</mi>
     <mi>t</mi>
    </msub>
    <mo>-</mo>
    <mover accent="true">
     <mi>Y</mi>
     <mo stretchy="false">^</mo>
    </mover>
    <msup>
     <mo mathsize="120%" stretchy="false">|</mo>
     <mn>2</mn>
    </msup>
    <mo>]</mo>
   </mrow>
   <mo>.</mo>
   <mtext>(M)</mtext>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">E</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <ci>normal-|</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Y</ci>
      <ci>t</ci>
     </apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <ci>normal-^</ci>
       <ci>Y</ci>
      </apply>
      <ci>t</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>normal-|</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-]</ci>
    </cerror>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">infimum</csymbol>
     <apply>
      <in></in>
      <ci>Y</ci>
      <ci>K</ci>
     </apply>
    </apply>
    <csymbol cd="unknown">E</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <ci>normal-|</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Y</ci>
      <ci>t</ci>
     </apply>
     <minus></minus>
     <apply>
      <ci>normal-^</ci>
      <ci>Y</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>normal-|</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-]</ci>
    </cerror>
    <ci>normal-.</ci>
    <ci>italic-</ci>
    <mtext>(M)</mtext>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{E}\left[\big|Y_{t}-\hat{Y}_{t}\big|^{2}\right]=\inf_{Y\in K}\mathbf{E}%
\left[\big|Y_{t}-\hat{Y}\big|^{2}\right].\qquad\mbox{(M)}
  </annotation>
 </semantics>
</math>

</p>
<h2 id="basic-result-orthogonal-projection">Basic result: orthogonal projection</h2>

<p>The space <em>K</em>(<em>Z</em>, <em>t</em>) of candidates is a <a href="Hilbert_space" title="wikilink">Hilbert space</a>, and the general theory of Hilbert spaces implies that the solution <em>Ŷ</em><sub><em>t</em></sub> of the minimization problem (M) is given by</p>

<p>

<math display="block" id="Filtering_problem_(stochastic_processes):7">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mover accent="true">
      <mi>Y</mi>
      <mo stretchy="false">^</mo>
     </mover>
     <mi>t</mi>
    </msub>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>P</mi>
      <mrow>
       <mi>K</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>Z</mi>
        <mo>,</mo>
        <mi>t</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </msub>
     <mrow>
      <mo maxsize="120%" minsize="120%">(</mo>
      <msub>
       <mi>X</mi>
       <mi>t</mi>
      </msub>
      <mo maxsize="120%" minsize="120%">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <ci>normal-^</ci>
      <ci>Y</ci>
     </apply>
     <ci>t</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>P</ci>
      <apply>
       <times></times>
       <ci>K</ci>
       <interval closure="open">
        <ci>Z</ci>
        <ci>t</ci>
       </interval>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <ci>t</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{Y}_{t}=P_{K(Z,t)}\big(X_{t}\big),
  </annotation>
 </semantics>
</math>

</p>

<p>where <em>P</em><sub><em>K</em>(<em>Z</em>,<em>t</em>)</sub> denotes the <a href="orthogonal_projection" title="wikilink">orthogonal projection</a> of <em>L</em><sup>2</sup>(Ω, Σ, <strong>P</strong>; <strong>R</strong><sup><em>n</em></sup>) onto the <a href="linear_subspace" title="wikilink">linear subspace</a> <em>K</em>(<em>Z</em>, <em>t</em>) = <em>L</em><sup>2</sup>(Ω, <em>G</em><sub><em>t</em></sub>, <strong>P</strong>; <strong>R</strong><sup><em>n</em></sup>). Furthermore, it is a general fact about <a href="conditional_expectation" title="wikilink">conditional expectations</a> that if <em>F</em> is any sub-<em>σ</em>-algebra of Σ then the orthogonal projection</p>

<p>

<math display="block" id="Filtering_problem_(stochastic_processes):8">
 <semantics>
  <mrow>
   <msub>
    <mi>P</mi>
    <mi>K</mi>
   </msub>
   <mo>:</mo>
   <mrow>
    <mrow>
     <msup>
      <mi>L</mi>
      <mn>2</mn>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi mathvariant="normal">Ω</mi>
      <mo>,</mo>
      <mi mathvariant="normal">Σ</mi>
      <mo>,</mo>
      <mi>𝐏</mi>
      <mo>;</mo>
      <msup>
       <mi>𝐑</mi>
       <mi>n</mi>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>→</mo>
    <mrow>
     <msup>
      <mi>L</mi>
      <mn>2</mn>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi mathvariant="normal">Ω</mi>
      <mo>,</mo>
      <mi>F</mi>
      <mo>,</mo>
      <mi>𝐏</mi>
      <mo>;</mo>
      <msup>
       <mi>𝐑</mi>
       <mi>n</mi>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>P</ci>
     <ci>K</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>L</ci>
       <cn type="integer">2</cn>
      </apply>
      <vector>
       <ci>normal-Ω</ci>
       <ci>normal-Σ</ci>
       <ci>𝐏</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>𝐑</ci>
        <ci>n</ci>
       </apply>
      </vector>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>L</ci>
       <cn type="integer">2</cn>
      </apply>
      <vector>
       <ci>normal-Ω</ci>
       <ci>F</ci>
       <ci>𝐏</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>𝐑</ci>
        <ci>n</ci>
       </apply>
      </vector>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{K}:L^{2}(\Omega,\Sigma,\mathbf{P};\mathbf{R}^{n})\to L^{2}(\Omega,F,\mathbf%
{P};\mathbf{R}^{n})
  </annotation>
 </semantics>
</math>

</p>

<p>is exactly the conditional expectation operator <strong>E</strong>[·|<em>F</em>], i.e.,</p>

<p>

<math display="block" id="Filtering_problem_(stochastic_processes):9">
 <semantics>
  <mrow>
   <msub>
    <mi>P</mi>
    <mi>K</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mi>𝐄</mi>
   <mrow>
    <mo maxsize="120%" minsize="120%">[</mo>
    <mi>X</mi>
    <mo mathsize="120%" stretchy="false">|</mo>
    <mi>F</mi>
    <mo maxsize="120%" minsize="120%">]</mo>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>P</ci>
     <ci>K</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">X</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">E</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">X</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">F</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <ci>normal-.</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{K}(X)=\mathbf{E}\big[X\big|F\big].
  </annotation>
 </semantics>
</math>

</p>

<p>Hence,</p>

<p>

<math display="block" id="Filtering_problem_(stochastic_processes):10">
 <semantics>
  <mrow>
   <msub>
    <mover accent="true">
     <mi>Y</mi>
     <mo stretchy="false">^</mo>
    </mover>
    <mi>t</mi>
   </msub>
   <mo>=</mo>
   <msub>
    <mi>P</mi>
    <mrow>
     <mi>K</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>Z</mi>
      <mo>,</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </msub>
   <mrow>
    <mo maxsize="120%" minsize="120%">(</mo>
    <msub>
     <mi>X</mi>
     <mi>t</mi>
    </msub>
    <mo maxsize="120%" minsize="120%">)</mo>
   </mrow>
   <mo>=</mo>
   <mi>𝐄</mi>
   <mrow>
    <mo maxsize="120%" minsize="120%">[</mo>
    <msub>
     <mi>X</mi>
     <mi>t</mi>
    </msub>
    <mo mathsize="120%" stretchy="false">|</mo>
    <msub>
     <mi>G</mi>
     <mi>t</mi>
    </msub>
    <mo maxsize="120%" minsize="120%">]</mo>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <ci>normal-^</ci>
      <ci>Y</ci>
     </apply>
     <ci>t</ci>
    </apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>P</ci>
     <apply>
      <times></times>
      <ci>K</ci>
      <interval closure="open">
       <ci>Z</ci>
       <ci>t</ci>
      </interval>
     </apply>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <ci>t</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">E</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <ci>t</ci>
     </apply>
     <ci>normal-|</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>G</ci>
      <ci>t</ci>
     </apply>
     <ci>normal-]</ci>
    </cerror>
    <ci>normal-.</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{Y}_{t}=P_{K(Z,t)}\big(X_{t}\big)=\mathbf{E}\big[X_{t}\big|G_{t}\big].
  </annotation>
 </semantics>
</math>

</p>

<p>This elementary result is the basis for the general Fujisaki-Kallianpur-Kunita equation of filtering theory.</p>
<h2 id="references">References</h2>
<ul>
<li></li>
<li>

<p>(See Section 6.1)</p></li>
</ul>
<references>
</references>

<p>"</p>

<p><a href="Category:Control_theory" title="wikilink">Category:Control theory</a> <a href="Category:Estimation_theory" title="wikilink">Category:Estimation theory</a> <a href="Category:Signal_processing" title="wikilink">Category:Signal processing</a> <a href="Category:Stochastic_differential_equations" title="wikilink">Category:Stochastic differential equations</a> <a href="Category:Stochastic_processes" title="wikilink">Category:Stochastic processes</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Stratonovich, R. L. (1959). <em>Optimum nonlinear systems which bring about a separation of a signal with constant parameters from noise</em>. Radiofizika, 2:6, pp. 892-901.<a href="#fnref1">↩</a></li>
<li id="fn2">Stratonovich, R.L. (1960). <em>Application of the Markov processes theory to optimal filtering</em>. Radio Engineering and Electronic Physics, 5:11, pp.1-19.<a href="#fnref2">↩</a></li>
<li id="fn3">Kushner, Harold. (1967). Nonlinear filtering: The exact dynamical equations satisfied by the conditional mode. Automatic Control, IEEE Transactions on Volume 12, Issue 3, Jun 1967 Page(s): 262 - 267<a href="#fnref3">↩</a></li>
<li id="fn4">Zakai, Moshe (1969), On the optimal filtering of diffusion processes. Zeit. Wahrsch. 11 230–243. , , <a href="#fnref4">↩</a></li>
<li id="fn5"><a href="Mireille_Chaleyat-Maurel" title="wikilink">Mireille Chaleyat-Maurel</a> and Dominique Michel. Des resultats de non existence de filtre de dimension finie. Stochastics, 13(1+2):83-102, 1984.<a href="#fnref5">↩</a></li>
<li id="fn6">Maybeck, Peter S., Stochastic models, estimation, and control, Volume 141, Series Mathematics in Science and Engineering, 1979, Academic Press<a href="#fnref6">↩</a></li>
<li id="fn7">Damiano Brigo, Bernard Hanzon and François LeGland, A Differential Geometric approach to nonlinear filtering: the Projection Filter, I.E.E.E. Transactions on Automatic Control Vol. 43, 2 (1998), pp 247--252.<a href="#fnref7">↩</a></li>
<li id="fn8"><a href="Damiano_Brigo" title="wikilink">Damiano Brigo</a>, <a href="Bernard_Hanzon" title="wikilink">Bernard Hanzon</a> and <a href="François_Le_Gland" title="wikilink">François Le Gland</a>, Approximate Nonlinear Filtering by Projection on Exponential Manifolds of Densities, Bernoulli, Vol. 5, N. 3 (1999), pp. 495--534<a href="#fnref8">↩</a></li>
</ol>
</section>
</body>
</html>
