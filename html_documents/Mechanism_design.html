<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="300">Mechanism design</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Mechanism design</h1>
<hr/>
<figure><b>(Figure)</b>
<figcaption> The Stanley Reiter diagram above illustrates a game of mechanism design. The upper-left space 

<math display="inline" id="Mechanism_design:0">
 <semantics>
  <mi mathvariant="normal">Θ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Θ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Theta
  </annotation>
 </semantics>
</math>

 depicts the type space and the upper-right space <em>X</em> the space of outcomes. The social choice function 

<math display="inline" id="Mechanism_design:1">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>θ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>θ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(\theta)
  </annotation>
 </semantics>
</math>

 maps a type profile to an outcome. In games of mechanism design, agents send messages 

<math display="inline" id="Mechanism_design:2">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 in a game environment 

<math display="inline" id="Mechanism_design:3">
 <semantics>
  <mi>g</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>g</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g
  </annotation>
 </semantics>
</math>

. The equilibrium in the game 

<math display="inline" id="Mechanism_design:4">
 <semantics>
  <mrow>
   <mi>ξ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>M</mi>
    <mo>,</mo>
    <mi>g</mi>
    <mo>,</mo>
    <mi>θ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>ξ</ci>
    <vector>
     <ci>M</ci>
     <ci>g</ci>
     <ci>θ</ci>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \xi(M,g,\theta)
  </annotation>
 </semantics>
</math>

 can be <strong>designed</strong> to implement some social choice function 

<math display="inline" id="Mechanism_design:5">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>θ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>θ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(\theta)
  </annotation>
 </semantics>
</math>

.</figcaption>
</figure>

<p><strong>Mechanism design</strong> (sometimes called <strong>reverse game theory</strong>) is a field in <a href="game_theory" title="wikilink">game theory</a> studying <a href="solution_concept" title="wikilink">solution concepts</a> for a class of private-information games. <a href="Leonid_Hurwicz" title="wikilink">Leonid Hurwicz</a> explains that 'in a design problem, the goal function is the main “given,” while the mechanism is the unknown. Therefore, the design problem is the “inverse” of traditional economic theory, which is typically devoted to the analysis of the performance of a given mechanism.'<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> So, two distinguishing features of these games are:</p>
<ul>
<li>that a game "designer" chooses the game structure rather than inheriting one</li>
</ul>
<ul>
<li>that the designer is interested in the game's outcome</li>
</ul>

<p>The 2007 <a href="Nobel_Memorial_Prize_in_Economic_Sciences" title="wikilink">Nobel Memorial Prize in Economic Sciences</a> was awarded to <a href="Leonid_Hurwicz" title="wikilink">Leonid Hurwicz</a>, <a href="Eric_Maskin" title="wikilink">Eric Maskin</a>, and <a href="Roger_Myerson" title="wikilink">Roger Myerson</a> "for having laid the foundations of mechanism design theory".<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>
<h2 id="intuition">Intuition</h2>

<p>In an interesting class of <a href="Bayesian_game" title="wikilink">Bayesian games</a>, one player, called the “principal,” would like to condition his behavior on information privately known to other players. For example, the principal would like to know the true quality of a used car a salesman is pitching. He cannot learn anything simply by asking the salesman, because it is in his interest to distort the truth. Fortunately, in mechanism design the principal does have one advantage: He may design a game whose rules can influence others to act the way he would like.</p>

<p>Without mechanism design theory, the principal's problem would be difficult to solve. He would have to consider all the possible games and choose the one that best influences other players' tactics. In addition, the principal would have to draw conclusions from agents who may lie to him. Thanks to mechanism design, and particularly the <a href="revelation_principle" title="wikilink">revelation principle</a>, the principal need only consider games in which agents truthfully report their private information.</p>
<h2 id="foundations">Foundations</h2>
<h3 id="mechanism">Mechanism</h3>

<p>A game of mechanism design is a game of private information in which one of the agents, called the principal, chooses the payoff structure. Following <a href="John_Harsanyi" title="wikilink">Harsanyi</a> (1967), the agents receive secret "messages" from nature containing information relevant to payoffs. For example, a message may contain information about their preferences or the quality of a good for sale. We call this information the agent's "type" (usually noted 

<math display="inline" id="Mechanism_design:6">
 <semantics>
  <mi>θ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>θ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta
  </annotation>
 </semantics>
</math>

 and accordingly the space of types 

<math display="inline" id="Mechanism_design:7">
 <semantics>
  <mi mathvariant="normal">Θ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Θ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Theta
  </annotation>
 </semantics>
</math>

). Agents then report a type to the principal (usually noted with a hat 

<math display="inline" id="Mechanism_design:8">
 <semantics>
  <mover accent="true">
   <mi>θ</mi>
   <mo stretchy="false">^</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-^</ci>
    <ci>θ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{\theta}
  </annotation>
 </semantics>
</math>

) that can be a strategic lie. After the report, the principal and the agents are paid according to the payoff structure the principal chose.</p>

<p>The timing of the game is:</p>
<ol>
<li>The principal commits to a mechanism 

<math display="inline" id="Mechanism_design:9">
 <semantics>
  <mrow>
   <mi>y</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>y</ci>
    <list></list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y()
  </annotation>
 </semantics>
</math>

 that grants an outcome 

<math display="inline" id="Mechanism_design:10">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

 as a function of reported type</li>
<li>The agents report, possibly dishonestly, a type profile 

<math display="inline" id="Mechanism_design:11">
 <semantics>
  <mover accent="true">
   <mi>θ</mi>
   <mo stretchy="false">^</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-^</ci>
    <ci>θ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{\theta}
  </annotation>
 </semantics>
</math>

</li>
<li>The mechanism is executed (agents receive outcome 

<math display="inline" id="Mechanism_design:12">
 <semantics>
  <mrow>
   <mi>y</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mover accent="true">
     <mi>θ</mi>
     <mo stretchy="false">^</mo>
    </mover>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>y</ci>
    <apply>
     <ci>normal-^</ci>
     <ci>θ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y(\hat{\theta})
  </annotation>
 </semantics>
</math>

)</li>
</ol>

<p>In order to understand who gets what, it is common to divide the outcome 

<math display="inline" id="Mechanism_design:13">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

 into a goods allocation and a money transfer, 

<math display="inline" id="Mechanism_design:14">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>y</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>θ</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mrow>
      <mi>x</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>θ</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mi>t</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>θ</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
   <mo rspace="7.5pt">,</mo>
   <mrow>
    <mrow>
     <mi>x</mi>
     <mo>∈</mo>
     <mi>X</mi>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mi>t</mi>
     <mo>∈</mo>
     <mi>T</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>y</ci>
      <ci>θ</ci>
     </apply>
     <set>
      <apply>
       <times></times>
       <ci>x</ci>
       <ci>θ</ci>
      </apply>
      <apply>
       <times></times>
       <ci>t</ci>
       <ci>θ</ci>
      </apply>
     </set>
    </apply>
    <apply>
     <csymbol cd="ambiguous">formulae-sequence</csymbol>
     <apply>
      <in></in>
      <ci>x</ci>
      <ci>X</ci>
     </apply>
     <apply>
      <in></in>
      <ci>t</ci>
      <ci>T</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y(\theta)=\{x(\theta),t(\theta)\},\ x\in X,t\in T
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Mechanism_design:15">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 stands for an allocation of goods rendered or received as a function of type, and 

<math display="inline" id="Mechanism_design:16">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 stands for a monetary transfer as a function of type.</p>

<p>As a benchmark the designer often defines what would happen under full information. Define a <strong>social choice function</strong> 

<math display="inline" id="Mechanism_design:17">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>θ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>θ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(\theta)
  </annotation>
 </semantics>
</math>

 mapping the (true) type profile directly to the allocation of goods received or rendered,</p>

<p>

<math display="block" id="Mechanism_design:18">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>θ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>:</mo>
   <mrow>
    <mi mathvariant="normal">Θ</mi>
    <mo>→</mo>
    <mi>X</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>θ</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <ci>normal-Θ</ci>
     <ci>X</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(\theta):\Theta\rightarrow X
  </annotation>
 </semantics>
</math>

</p>

<p>In contrast a <strong>mechanism</strong> maps the <em>reported</em> type profile to an <em>outcome</em> (again, both a goods allocation 

<math display="inline" id="Mechanism_design:19">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 and a money transfer 

<math display="inline" id="Mechanism_design:20">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

)</p>

<p>

<math display="block" id="Mechanism_design:21">
 <semantics>
  <mrow>
   <mrow>
    <mi>y</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mover accent="true">
      <mi>θ</mi>
      <mo stretchy="false">^</mo>
     </mover>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>:</mo>
   <mrow>
    <mi mathvariant="normal">Θ</mi>
    <mo>→</mo>
    <mi>Y</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <times></times>
     <ci>y</ci>
     <apply>
      <ci>normal-^</ci>
      <ci>θ</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <ci>normal-Θ</ci>
     <ci>Y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y(\hat{\theta}):\Theta\rightarrow Y
  </annotation>
 </semantics>
</math>

</p>
<h3 id="revelation-principle">Revelation principle</h3>

<p>A proposed mechanism constitutes a Bayesian game (a game of private information), and if it is well-behaved the game has a <a href="Bayesian_Nash_equilibrium" title="wikilink">Bayesian Nash equilibrium</a>. At equilibrium agents choose their reports strategically as a function of type</p>

<p>

<math display="block" id="Mechanism_design:22">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>θ</mi>
    <mo stretchy="false">^</mo>
   </mover>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>θ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <ci>normal-^</ci>
     <ci>θ</ci>
    </apply>
    <ci>θ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{\theta}(\theta)
  </annotation>
 </semantics>
</math>

</p>

<p>It is difficult to solve for Bayesian equilibria in such a setting because it involves solving for agents' best-response strategies and for the best inference from a possible strategic lie. Thanks to a sweeping result called the revelation principle, no matter the mechanism a designer can<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> confine attention to equilibria in which agents truthfully report type. The <strong>revelation principle</strong> states: "To every Bayesian Nash equilibrium there corresponds a Bayesian game with the same equilibrium outcome but in which players truthfully report type."</p>

<p>This is extremely useful. The principle allows one to solve for a Bayesian equilibrium by assuming all players truthfully report type (subject to an <a href="incentive_compatibility" title="wikilink">incentive compatibility</a> constraint). In one blow it eliminates the need to consider either strategic behavior or lying.</p>

<p>Its proof is quite direct. Assume a Bayesian game in which the agent's strategy and payoff are functions of its type and what others do, 

<math display="inline" id="Mechanism_design:23">
 <semantics>
  <mrow>
   <msub>
    <mi>u</mi>
    <mi>i</mi>
   </msub>
   <mrow>
    <mo>(</mo>
    <mrow>
     <msub>
      <mi>s</mi>
      <mi>i</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>θ</mi>
       <mi>i</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>,</mo>
    <mrow>
     <msub>
      <mi>s</mi>
      <mrow>
       <mo>-</mo>
       <mi>i</mi>
      </mrow>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>θ</mi>
       <mrow>
        <mo>-</mo>
        <mi>i</mi>
       </mrow>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>,</mo>
    <msub>
     <mi>θ</mi>
     <mi>i</mi>
    </msub>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>u</ci>
     <ci>i</ci>
    </apply>
    <vector>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>s</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>θ</ci>
       <ci>i</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>s</ci>
       <apply>
        <minus></minus>
        <ci>i</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>θ</ci>
       <apply>
        <minus></minus>
        <ci>i</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>θ</ci>
      <ci>i</ci>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u_{i}\left(s_{i}(\theta_{i}),s_{-i}(\theta_{-i}),\theta_{i}\right)
  </annotation>
 </semantics>
</math>

. By definition agent <em>i</em>'s equilibrium strategy 

<math display="inline" id="Mechanism_design:24">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>θ</mi>
     <mi>i</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>s</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>θ</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s(\theta_{i})
  </annotation>
 </semantics>
</math>

 is Nash in expected utility:</p>

<p>

<math display="block" id="Mechanism_design:25">
 <semantics>
  <mrow>
   <msub>
    <mi>s</mi>
    <mi>i</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>θ</mi>
     <mi>i</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∈</mo>
   <mi>arg</mi>
   <munder>
    <mi>max</mi>
    <mrow>
     <msubsup>
      <mi>s</mi>
      <mi>i</mi>
      <mo>′</mo>
     </msubsup>
     <mo>∈</mo>
     <msub>
      <mi>S</mi>
      <mi>i</mi>
     </msub>
    </mrow>
   </munder>
   <mpadded width="+5pt">
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <msub>
      <mi>θ</mi>
      <mrow>
       <mo>-</mo>
       <mi>i</mi>
      </mrow>
     </msub>
    </munder>
   </mpadded>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>θ</mi>
     <mrow>
      <mo>-</mo>
      <mi>i</mi>
     </mrow>
    </msub>
    <mo>∣</mo>
    <msub>
     <mi>θ</mi>
     <mi>i</mi>
    </msub>
    <mo rspace="7.5pt" stretchy="false">)</mo>
   </mrow>
   <msub>
    <mi>u</mi>
    <mi>i</mi>
   </msub>
   <mrow>
    <mo>(</mo>
    <msubsup>
     <mi>s</mi>
     <mi>i</mi>
     <mo>′</mo>
    </msubsup>
    <mo>,</mo>
    <msub>
     <mi>s</mi>
     <mrow>
      <mo>-</mo>
      <mi>i</mi>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>θ</mi>
      <mrow>
       <mo>-</mo>
       <mi>i</mi>
      </mrow>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>,</mo>
    <msub>
     <mi>θ</mi>
     <mi>i</mi>
    </msub>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>s</ci>
     <ci>i</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>θ</ci>
      <ci>i</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <in></in>
    <arg></arg>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <max></max>
     <apply>
      <in></in>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>s</ci>
        <ci>normal-′</ci>
       </apply>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>S</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <sum></sum>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>θ</ci>
      <apply>
       <minus></minus>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>θ</ci>
      <apply>
       <minus></minus>
       <ci>i</ci>
      </apply>
     </apply>
     <ci>normal-∣</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>θ</ci>
      <ci>i</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>u</ci>
     <ci>i</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>s</ci>
       <ci>normal-′</ci>
      </apply>
      <ci>i</ci>
     </apply>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>s</ci>
      <apply>
       <minus></minus>
       <ci>i</ci>
      </apply>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>θ</ci>
       <apply>
        <minus></minus>
        <ci>i</ci>
       </apply>
      </apply>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>θ</ci>
      <ci>i</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s_{i}(\theta_{i})\in\arg\max_{s^{\prime}_{i}\in S_{i}}\sum_{\theta_{-i}}\ p(%
\theta_{-i}\mid\theta_{i})\ u_{i}\left(s^{\prime}_{i},s_{-i}(\theta_{-i}),%
\theta_{i}\right)
  </annotation>
 </semantics>
</math>

</p>

<p>Simply define a mechanism that would induce agents to choose the same equilibrium. The easiest one to define is for the mechanism to commit to playing the agents' equilibrium strategies <em>for</em> them.</p>

<p>

<math display="block" id="Mechanism_design:26">
 <semantics>
  <mrow>
   <mrow>
    <mi>y</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mover accent="true">
      <mi>θ</mi>
      <mo stretchy="false">^</mo>
     </mover>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>:</mo>
   <mrow>
    <mi mathvariant="normal">Θ</mi>
    <mo>→</mo>
    <mrow>
     <mi>S</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi mathvariant="normal">Θ</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>→</mo>
    <mi>Y</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <times></times>
     <ci>y</ci>
     <apply>
      <ci>normal-^</ci>
      <ci>θ</ci>
     </apply>
    </apply>
    <apply>
     <and></and>
     <apply>
      <ci>normal-→</ci>
      <ci>normal-Θ</ci>
      <apply>
       <times></times>
       <ci>S</ci>
       <ci>normal-Θ</ci>
      </apply>
     </apply>
     <apply>
      <ci>normal-→</ci>
      <share href="#.cmml">
      </share>
      <ci>Y</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y(\hat{\theta}):\Theta\rightarrow S(\Theta)\rightarrow Y
  </annotation>
 </semantics>
</math>

</p>

<p>Under such a mechanism the agents of course find it optimal to reveal type since the mechanism plays the strategies they found optimal anyway. Formally, choose 

<math display="inline" id="Mechanism_design:27">
 <semantics>
  <mrow>
   <mi>y</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>θ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>y</ci>
    <ci>θ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y(\theta)
  </annotation>
 </semantics>
</math>

 such that</p>

<p>

<math display="block" id="Mechanism_design:28">
 <semantics>
  <mrow>
   <msub>
    <mover accent="true">
     <mi>θ</mi>
     <mo stretchy="false">^</mo>
    </mover>
    <mi>i</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>θ</mi>
     <mi>i</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∈</mo>
   <mi>arg</mi>
   <munder>
    <mi>max</mi>
    <mrow>
     <msubsup>
      <mi>θ</mi>
      <mi>i</mi>
      <mo>′</mo>
     </msubsup>
     <mo>∈</mo>
     <mi mathvariant="normal">Θ</mi>
    </mrow>
   </munder>
   <mpadded width="+5pt">
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <msub>
      <mi>θ</mi>
      <mrow>
       <mo>-</mo>
       <mi>i</mi>
      </mrow>
     </msub>
    </munder>
   </mpadded>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>θ</mi>
     <mrow>
      <mo>-</mo>
      <mi>i</mi>
     </mrow>
    </msub>
    <mo>∣</mo>
    <msub>
     <mi>θ</mi>
     <mi>i</mi>
    </msub>
    <mo rspace="7.5pt" stretchy="false">)</mo>
   </mrow>
   <msub>
    <mi>u</mi>
    <mi>i</mi>
   </msub>
   <mrow>
    <mo>(</mo>
    <mi>y</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msubsup>
      <mi>θ</mi>
      <mi>i</mi>
      <mo>′</mo>
     </msubsup>
     <mo>,</mo>
     <msub>
      <mi>θ</mi>
      <mrow>
       <mo>-</mo>
       <mi>i</mi>
      </mrow>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>,</mo>
    <msub>
     <mi>θ</mi>
     <mi>i</mi>
    </msub>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <ci>normal-^</ci>
      <ci>θ</ci>
     </apply>
     <ci>i</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>θ</ci>
      <ci>i</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <in></in>
    <arg></arg>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <max></max>
     <apply>
      <in></in>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>θ</ci>
        <ci>normal-′</ci>
       </apply>
       <ci>i</ci>
      </apply>
      <ci>normal-Θ</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <sum></sum>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>θ</ci>
      <apply>
       <minus></minus>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>θ</ci>
      <apply>
       <minus></minus>
       <ci>i</ci>
      </apply>
     </apply>
     <ci>normal-∣</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>θ</ci>
      <ci>i</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>u</ci>
     <ci>i</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">y</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>θ</ci>
        <ci>normal-′</ci>
       </apply>
       <ci>i</ci>
      </apply>
      <ci>normal-,</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>θ</ci>
       <apply>
        <minus></minus>
        <ci>i</ci>
       </apply>
      </apply>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>θ</ci>
      <ci>i</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{\theta}_{i}(\theta_{i})\in\arg\max_{\theta^{\prime}_{i}\in\Theta}\sum_{%
\theta_{-i}}\ p(\theta_{-i}\mid\theta_{i})\ u_{i}\left(y(\theta^{\prime}_{i},%
\theta_{-i}),\theta_{i}\right)
  </annotation>
 </semantics>
</math>

</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Mechanism_design:29">
 <semantics>
  <mrow>
   <mo>=</mo>
   <mpadded width="+5pt">
    <msub>
     <mo largeop="true" symmetric="true">∑</mo>
     <msub>
      <mi>θ</mi>
      <mrow>
       <mo>-</mo>
       <mi>i</mi>
      </mrow>
     </msub>
    </msub>
   </mpadded>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>θ</mi>
     <mrow>
      <mo>-</mo>
      <mi>i</mi>
     </mrow>
    </msub>
    <mo>∣</mo>
    <msub>
     <mi>θ</mi>
     <mi>i</mi>
    </msub>
    <mo rspace="7.5pt" stretchy="false">)</mo>
   </mrow>
   <msub>
    <mi>u</mi>
    <mi>i</mi>
   </msub>
   <mrow>
    <mo>(</mo>
    <msub>
     <mi>s</mi>
     <mi>i</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>θ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>,</mo>
    <msub>
     <mi>s</mi>
     <mrow>
      <mo>-</mo>
      <mi>i</mi>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>θ</mi>
      <mrow>
       <mo>-</mo>
       <mi>i</mi>
      </mrow>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>,</mo>
    <msub>
     <mi>θ</mi>
     <mi>i</mi>
    </msub>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <sum></sum>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>θ</ci>
      <apply>
       <minus></minus>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>θ</ci>
      <apply>
       <minus></minus>
       <ci>i</ci>
      </apply>
     </apply>
     <ci>normal-∣</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>θ</ci>
      <ci>i</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>u</ci>
     <ci>i</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>s</ci>
      <ci>i</ci>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">θ</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>s</ci>
      <apply>
       <minus></minus>
       <ci>i</ci>
      </apply>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>θ</ci>
       <apply>
        <minus></minus>
        <ci>i</ci>
       </apply>
      </apply>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>θ</ci>
      <ci>i</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =\sum_{\theta_{-i}}\ p(\theta_{-i}\mid\theta_{i})\ u_{i}\left(s_{i}(\theta),s_%
{-i}(\theta_{-i}),\theta_{i}\right)
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>
<h3 id="implementability">Implementability</h3>

<p>The designer of a mechanism generally hopes either</p>
<ul>
<li>to design a mechanism 

<math display="inline" id="Mechanism_design:30">
 <semantics>
  <mrow>
   <mi>y</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>y</ci>
    <list></list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y()
  </annotation>
 </semantics>
</math>

 that "implements" a social choice function</li>
<li>to find the mechanism 

<math display="inline" id="Mechanism_design:31">
 <semantics>
  <mrow>
   <mi>y</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>y</ci>
    <list></list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y()
  </annotation>
 </semantics>
</math>

 that maximizes some value criterion (e.g. profit)</li>
</ul>

<p>To <strong>implement</strong> a social choice function 

<math display="inline" id="Mechanism_design:32">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>θ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>θ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(\theta)
  </annotation>
 </semantics>
</math>

 is to find some 

<math display="inline" id="Mechanism_design:33">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>θ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>t</ci>
    <ci>θ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t(\theta)
  </annotation>
 </semantics>
</math>

 transfer function that motivates agents to pick outcome 

<math display="inline" id="Mechanism_design:34">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>θ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>x</ci>
    <ci>θ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x(\theta)
  </annotation>
 </semantics>
</math>

. Formally, if the equilibrium strategy profile under the mechanism maps to the same goods allocation as a social choice function,</p>

<p>

<math display="block" id="Mechanism_design:35">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>θ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>x</mi>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mover accent="true">
       <mi>θ</mi>
       <mo stretchy="false">^</mo>
      </mover>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>θ</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>θ</ci>
    </apply>
    <apply>
     <times></times>
     <ci>x</ci>
     <apply>
      <times></times>
      <apply>
       <ci>normal-^</ci>
       <ci>θ</ci>
      </apply>
      <ci>θ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(\theta)=x\left(\hat{\theta}(\theta)\right)
  </annotation>
 </semantics>
</math>

 we say the mechanism implements the social choice function.</p>

<p>Thanks to the revelation principle, the designer can usually find a transfer function 

<math display="inline" id="Mechanism_design:36">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>θ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>t</ci>
    <ci>θ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t(\theta)
  </annotation>
 </semantics>
</math>

 to implement a social choice by solving an associated truthtelling game. If agents find it optimal to truthfully report type,</p>

<p>

<math display="block" id="Mechanism_design:37">
 <semantics>
  <mrow>
   <mrow>
    <mover accent="true">
     <mi>θ</mi>
     <mo stretchy="false">^</mo>
    </mover>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>θ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>θ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <ci>normal-^</ci>
      <ci>θ</ci>
     </apply>
     <ci>θ</ci>
    </apply>
    <ci>θ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{\theta}(\theta)=\theta
  </annotation>
 </semantics>
</math>

 we say such a mechanism is <strong>truthfully implementable</strong> (or just "implementable"). The task is then to solve for a truthfully implementable 

<math display="inline" id="Mechanism_design:38">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>θ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>t</ci>
    <ci>θ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t(\theta)
  </annotation>
 </semantics>
</math>

 and impute this transfer function to the original game. An allocation 

<math display="inline" id="Mechanism_design:39">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>θ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>x</ci>
    <ci>θ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x(\theta)
  </annotation>
 </semantics>
</math>

 is truthfully implementable if there exists a transfer function 

<math display="inline" id="Mechanism_design:40">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>θ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>t</ci>
    <ci>θ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t(\theta)
  </annotation>
 </semantics>
</math>

 such that</p>

<p>

<math display="block" id="Mechanism_design:41">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>u</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>x</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>θ</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>,</mo>
      <mrow>
       <mi>t</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>θ</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>,</mo>
      <mi>θ</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>≥</mo>
    <mrow>
     <mi>u</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>x</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mover accent="true">
         <mi>θ</mi>
         <mo stretchy="false">^</mo>
        </mover>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>,</mo>
      <mrow>
       <mi>t</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mover accent="true">
         <mi>θ</mi>
         <mo stretchy="false">^</mo>
        </mover>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>,</mo>
      <mi>θ</mi>
      <mo rspace="7.5pt" stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo>∀</mo>
      <mi>θ</mi>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mover accent="true">
     <mi>θ</mi>
     <mo stretchy="false">^</mo>
    </mover>
    <mo>∈</mo>
    <mi mathvariant="normal">Θ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <geq></geq>
     <apply>
      <times></times>
      <ci>u</ci>
      <vector>
       <apply>
        <times></times>
        <ci>x</ci>
        <ci>θ</ci>
       </apply>
       <apply>
        <times></times>
        <ci>t</ci>
        <ci>θ</ci>
       </apply>
       <ci>θ</ci>
      </vector>
     </apply>
     <apply>
      <times></times>
      <ci>u</ci>
      <vector>
       <apply>
        <times></times>
        <ci>x</ci>
        <apply>
         <ci>normal-^</ci>
         <ci>θ</ci>
        </apply>
       </apply>
       <apply>
        <times></times>
        <ci>t</ci>
        <apply>
         <ci>normal-^</ci>
         <ci>θ</ci>
        </apply>
       </apply>
       <ci>θ</ci>
      </vector>
      <apply>
       <csymbol cd="latexml">for-all</csymbol>
       <ci>θ</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <in></in>
     <apply>
      <ci>normal-^</ci>
      <ci>θ</ci>
     </apply>
     <ci>normal-Θ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u(x(\theta),t(\theta),\theta)\geq u(x(\hat{\theta}),t(\hat{\theta}),\theta)\ %
\forall\theta,\hat{\theta}\in\Theta
  </annotation>
 </semantics>
</math>

 which is also called the <strong>incentive compatibility</strong> (IC) constraint.</p>

<p>In applications, the IC condition is the key to describing the shape of 

<math display="inline" id="Mechanism_design:42">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>θ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>t</ci>
    <ci>θ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t(\theta)
  </annotation>
 </semantics>
</math>

 in any useful way. Under certain conditions it can even isolate the transfer function analytically! Additionally, a participation (<a href="individual_rationality" title="wikilink">individual rationality</a>) constraint is sometimes added if agents have the option of not playing.</p>
<h4 id="necessity">Necessity</h4>

<p>Consider a setting in which all agents have a type-contingent utility function 

<math display="inline" id="Mechanism_design:43">
 <semantics>
  <mrow>
   <mi>u</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>t</mi>
    <mo>,</mo>
    <mi>θ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>u</ci>
    <vector>
     <ci>x</ci>
     <ci>t</ci>
     <ci>θ</ci>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u(x,t,\theta)
  </annotation>
 </semantics>
</math>

. Consider also a goods allocation 

<math display="inline" id="Mechanism_design:44">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>θ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>x</ci>
    <ci>θ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x(\theta)
  </annotation>
 </semantics>
</math>

 that is vector-valued and size 

<math display="inline" id="Mechanism_design:45">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 (which permits 

<math display="inline" id="Mechanism_design:46">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 number of goods) and assume it is piecewise continuous with respect to its arguments.</p>

<p>The function 

<math display="inline" id="Mechanism_design:47">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>θ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>x</ci>
    <ci>θ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x(\theta)
  </annotation>
 </semantics>
</math>

 is implementable only if</p>

<p>

<math display="block" id="Mechanism_design:48">
 <semantics>
  <mrow>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>k</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>n</mi>
    </munderover>
    <mrow>
     <mfrac>
      <mo>∂</mo>
      <mrow>
       <mo>∂</mo>
       <mi>θ</mi>
      </mrow>
     </mfrac>
     <mrow>
      <mo>(</mo>
      <mfrac>
       <mrow>
        <mrow>
         <mo>∂</mo>
         <mi>u</mi>
        </mrow>
        <mo>/</mo>
        <mrow>
         <mo>∂</mo>
         <msub>
          <mi>x</mi>
          <mi>k</mi>
         </msub>
        </mrow>
       </mrow>
       <mrow>
        <mo>|</mo>
        <mrow>
         <mrow>
          <mo>∂</mo>
          <mi>u</mi>
         </mrow>
         <mo>/</mo>
         <mrow>
          <mo>∂</mo>
          <mi>t</mi>
         </mrow>
        </mrow>
        <mo>|</mo>
       </mrow>
      </mfrac>
      <mo>)</mo>
     </mrow>
     <mfrac>
      <mrow>
       <mo>∂</mo>
       <mi>x</mi>
      </mrow>
      <mrow>
       <mo>∂</mo>
       <mi>θ</mi>
      </mrow>
     </mfrac>
    </mrow>
   </mrow>
   <mo>≥</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <sum></sum>
       <ci>n</ci>
      </apply>
      <apply>
       <eq></eq>
       <ci>k</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <partialdiff></partialdiff>
       <apply>
        <partialdiff></partialdiff>
        <ci>θ</ci>
       </apply>
      </apply>
      <apply>
       <divide></divide>
       <apply>
        <divide></divide>
        <apply>
         <partialdiff></partialdiff>
         <ci>u</ci>
        </apply>
        <apply>
         <partialdiff></partialdiff>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <ci>k</ci>
         </apply>
        </apply>
       </apply>
       <apply>
        <abs></abs>
        <apply>
         <divide></divide>
         <apply>
          <partialdiff></partialdiff>
          <ci>u</ci>
         </apply>
         <apply>
          <partialdiff></partialdiff>
          <ci>t</ci>
         </apply>
        </apply>
       </apply>
      </apply>
      <apply>
       <divide></divide>
       <apply>
        <partialdiff></partialdiff>
        <ci>x</ci>
       </apply>
       <apply>
        <partialdiff></partialdiff>
        <ci>θ</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum^{n}_{k=1}\frac{\partial}{\partial\theta}\left(\frac{\partial u/\partial x%
_{k}}{\left|\partial u/\partial t\right|}\right)\frac{\partial x}{\partial%
\theta}\geq 0
  </annotation>
 </semantics>
</math>

 whenever 

<math display="inline" id="Mechanism_design:49">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>=</mo>
   <mrow>
    <mi>x</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>θ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>x</ci>
    <apply>
     <times></times>
     <ci>x</ci>
     <ci>θ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x=x(\theta)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Mechanism_design:50">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mo>=</mo>
   <mrow>
    <mi>t</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>θ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>t</ci>
    <apply>
     <times></times>
     <ci>t</ci>
     <ci>θ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t=t(\theta)
  </annotation>
 </semantics>
</math>

 and <em>x</em> is continuous at 

<math display="inline" id="Mechanism_design:51">
 <semantics>
  <mi>θ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>θ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta
  </annotation>
 </semantics>
</math>

. This is a necessary condition and is derived from the first- and second-order conditions of the agent's optimization problem assuming truth-telling.</p>

<p>Its meaning can be understood in two pieces. The first piece says the agent's <a href="marginal_rate_of_substitution" title="wikilink">marginal rate of substitution</a> increases as a function of the type,</p>

<p>

<math display="block" id="Mechanism_design:52">
 <semantics>
  <mrow>
   <mrow>
    <mfrac>
     <mo>∂</mo>
     <mrow>
      <mo>∂</mo>
      <mi>θ</mi>
     </mrow>
    </mfrac>
    <mrow>
     <mo>(</mo>
     <mfrac>
      <mrow>
       <mrow>
        <mo>∂</mo>
        <mi>u</mi>
       </mrow>
       <mo>/</mo>
       <mrow>
        <mo>∂</mo>
        <msub>
         <mi>x</mi>
         <mi>k</mi>
        </msub>
       </mrow>
      </mrow>
      <mrow>
       <mo>|</mo>
       <mrow>
        <mrow>
         <mo>∂</mo>
         <mi>u</mi>
        </mrow>
        <mo>/</mo>
        <mrow>
         <mo>∂</mo>
         <mi>t</mi>
        </mrow>
       </mrow>
       <mo>|</mo>
      </mrow>
     </mfrac>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mo>∂</mo>
     <mrow>
      <mo>∂</mo>
      <mi>θ</mi>
     </mrow>
    </mfrac>
    <mi>M</mi>
    <mi>R</mi>
    <msub>
     <mi>S</mi>
     <mrow>
      <mi>x</mi>
      <mo>,</mo>
      <mi>t</mi>
     </mrow>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <partialdiff></partialdiff>
      <apply>
       <partialdiff></partialdiff>
       <ci>θ</ci>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <divide></divide>
       <apply>
        <partialdiff></partialdiff>
        <ci>u</ci>
       </apply>
       <apply>
        <partialdiff></partialdiff>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>k</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <abs></abs>
       <apply>
        <divide></divide>
        <apply>
         <partialdiff></partialdiff>
         <ci>u</ci>
        </apply>
        <apply>
         <partialdiff></partialdiff>
         <ci>t</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <partialdiff></partialdiff>
      <apply>
       <partialdiff></partialdiff>
       <ci>θ</ci>
      </apply>
     </apply>
     <ci>M</ci>
     <ci>R</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>S</ci>
      <list>
       <ci>x</ci>
       <ci>t</ci>
      </list>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{\partial}{\partial\theta}\left(\frac{\partial u/\partial x_{k}}{\left|%
\partial u/\partial t\right|}\right)=\frac{\partial}{\partial\theta}MRS_{x,t}
  </annotation>
 </semantics>
</math>

 In short, agents will not tell the truth if the mechanism does not offer higher agent types a better deal. Otherwise, higher types facing any mechanism that punishes high types for reporting will lie and declare they are lower types, violating the truthtelling IC constraint. The second piece is a monotonicity condition waiting to happen,</p>

<p>

<math display="block" id="Mechanism_design:53">
 <semantics>
  <mfrac>
   <mrow>
    <mo>∂</mo>
    <mi>x</mi>
   </mrow>
   <mrow>
    <mo>∂</mo>
    <mi>θ</mi>
   </mrow>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <partialdiff></partialdiff>
     <ci>x</ci>
    </apply>
    <apply>
     <partialdiff></partialdiff>
     <ci>θ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{\partial x}{\partial\theta}
  </annotation>
 </semantics>
</math>

 which, to be positive, means higher types must be given more of the good.</p>

<p>There is potential for the two pieces to interact. If for some type range the contract offered less quantity to higher types 

<math display="inline" id="Mechanism_design:54">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>∂</mo>
     <mi>x</mi>
    </mrow>
    <mo>/</mo>
    <mrow>
     <mo>∂</mo>
     <mi>θ</mi>
    </mrow>
   </mrow>
   <mo><</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <divide></divide>
     <apply>
      <partialdiff></partialdiff>
      <ci>x</ci>
     </apply>
     <apply>
      <partialdiff></partialdiff>
      <ci>θ</ci>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \partial x/\partial\theta<0
  </annotation>
 </semantics>
</math>

, it is possible the mechanism could compensate by giving higher types a discount. But such a contract already exists for low-type agents, so this solution is pathological. Such a solution sometimes occurs in the process of solving for a mechanism. In these cases it must be "<a href="Mechanism_design#Myerson_ironing" title="wikilink">ironed</a>." In a multiple-good environment it is also possible for the designer to reward the agent with more of one good to substitute for less of another (e.g. <a class="uri" href="butter" title="wikilink">butter</a> for <a class="uri" href="margarine" title="wikilink">margarine</a>). Multiple-good mechanisms are an ongoing problem in mechanism design theory.</p>
<h4 id="sufficiency">Sufficiency</h4>

<p>Mechanism design papers usually make two assumptions to ensure implementability:</p>

<p>

<math display="block" id="Mechanism_design:55">
 <semantics>
  <mrow>
   <mrow>
    <mpadded width="+5pt">
     <mn>1.</mn>
    </mpadded>
    <mfrac>
     <mo>∂</mo>
     <mrow>
      <mo>∂</mo>
      <mi>θ</mi>
     </mrow>
    </mfrac>
    <mfrac>
     <mrow>
      <mrow>
       <mo>∂</mo>
       <mi>u</mi>
      </mrow>
      <mo>/</mo>
      <mrow>
       <mo>∂</mo>
       <msub>
        <mi>x</mi>
        <mi>k</mi>
       </msub>
      </mrow>
     </mrow>
     <mrow>
      <mo>|</mo>
      <mrow>
       <mrow>
        <mo>∂</mo>
        <mi>u</mi>
       </mrow>
       <mo>/</mo>
       <mrow>
        <mo>∂</mo>
        <mi>t</mi>
       </mrow>
      </mrow>
      <mo>|</mo>
     </mrow>
    </mfrac>
   </mrow>
   <mo>></mo>
   <mrow>
    <mpadded width="+5pt">
     <mn>0</mn>
    </mpadded>
    <mrow>
     <mo>∀</mo>
     <mi>k</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <apply>
     <times></times>
     <cn type="float">1.</cn>
     <apply>
      <divide></divide>
      <partialdiff></partialdiff>
      <apply>
       <partialdiff></partialdiff>
       <ci>θ</ci>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <divide></divide>
       <apply>
        <partialdiff></partialdiff>
        <ci>u</ci>
       </apply>
       <apply>
        <partialdiff></partialdiff>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>k</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <abs></abs>
       <apply>
        <divide></divide>
        <apply>
         <partialdiff></partialdiff>
         <ci>u</ci>
        </apply>
        <apply>
         <partialdiff></partialdiff>
         <ci>t</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <cn type="integer">0</cn>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <ci>k</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1.\ \frac{\partial}{\partial\theta}\frac{\partial u/\partial x_{k}}{\left|%
\partial u/\partial t\right|}>0\ \forall k
  </annotation>
 </semantics>
</math>

 This is known by several names: the <a href="single-crossing_condition" title="wikilink">single-crossing condition</a>, the sorting condition and the Spence–Mirrlees condition. It means the utility function is of such a shape that the agent's MRS is increasing in type.</p>

<p>

<math display="block" id="Mechanism_design:56">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mpadded width="+5pt">
      <mn>2.</mn>
     </mpadded>
     <mrow>
      <mo>∃</mo>
      <msub>
       <mi>K</mi>
       <mn>0</mn>
      </msub>
     </mrow>
    </mrow>
    <mo>,</mo>
    <mrow>
     <msub>
      <mi>K</mi>
      <mn>1</mn>
     </msub>
     <mtext>such that</mtext>
     <mrow>
      <mo>|</mo>
      <mfrac>
       <mrow>
        <mrow>
         <mo>∂</mo>
         <mi>u</mi>
        </mrow>
        <mo>/</mo>
        <mrow>
         <mo>∂</mo>
         <msub>
          <mi>x</mi>
          <mi>k</mi>
         </msub>
        </mrow>
       </mrow>
       <mrow>
        <mrow>
         <mo>∂</mo>
         <mi>u</mi>
        </mrow>
        <mo>/</mo>
        <mrow>
         <mo>∂</mo>
         <mi>t</mi>
        </mrow>
       </mrow>
      </mfrac>
      <mo>|</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <msub>
     <mi>K</mi>
     <mn>0</mn>
    </msub>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>K</mi>
      <mn>1</mn>
     </msub>
     <mrow>
      <mo stretchy="false">|</mo>
      <mi>t</mi>
      <mo stretchy="false">|</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <list>
     <apply>
      <times></times>
      <cn type="float">2.</cn>
      <apply>
       <exists></exists>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>K</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>K</ci>
       <cn type="integer">1</cn>
      </apply>
      <mtext>such that</mtext>
      <apply>
       <abs></abs>
       <apply>
        <divide></divide>
        <apply>
         <divide></divide>
         <apply>
          <partialdiff></partialdiff>
          <ci>u</ci>
         </apply>
         <apply>
          <partialdiff></partialdiff>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>x</ci>
           <ci>k</ci>
          </apply>
         </apply>
        </apply>
        <apply>
         <divide></divide>
         <apply>
          <partialdiff></partialdiff>
          <ci>u</ci>
         </apply>
         <apply>
          <partialdiff></partialdiff>
          <ci>t</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </list>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>K</ci>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>K</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <abs></abs>
       <ci>t</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2.\ \exists K_{0},K_{1}\text{ such that }\left|\frac{\partial u/\partial x_{k}%
}{\partial u/\partial t}\right|\leq K_{0}+K_{1}|t|
  </annotation>
 </semantics>
</math>

 This is a technical condition bounding the rate of growth of the MRS.</p>

<p>These assumptions are sufficient to provide that any monotonic 

<math display="inline" id="Mechanism_design:57">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>θ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>x</ci>
    <ci>θ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x(\theta)
  </annotation>
 </semantics>
</math>

 is implementable (a 

<math display="inline" id="Mechanism_design:58">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>θ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>t</ci>
    <ci>θ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t(\theta)
  </annotation>
 </semantics>
</math>

 exists that can implement it). In addition, in the single-good setting the single-crossing condition is sufficient to provide that only a monotonic 

<math display="inline" id="Mechanism_design:59">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>θ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>x</ci>
    <ci>θ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x(\theta)
  </annotation>
 </semantics>
</math>

 is implementable, so the designer can confine his search to a monotonic 

<math display="inline" id="Mechanism_design:60">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>θ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>x</ci>
    <ci>θ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x(\theta)
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="highlighted-results">Highlighted results</h2>
<h3 id="revenue-equivalence-theorem">Revenue equivalence theorem</h3>

<p>Vickrey (1961) gives a celebrated result that any member of a large class of auctions assures the seller of the same expected revenue and that the expected revenue is the best the seller can do. This is the case if</p>
<ol>
<li>The buyers have identical valuation functions (which may be a function of type)</li>
<li>The buyers' types are independently distributed</li>
<li>The buyers types are drawn from a <a href="Continuous_distribution#Continuous_probability_distribution" title="wikilink">continuous distribution</a></li>
<li>The type distribution bears the monotone hazard rate property</li>
<li>The mechanism sells the good to the buyer with the highest valuation</li>
</ol>

<p>The last condition is crucial to the theorem. An implication is that for the seller to achieve higher revenue he must take a chance on giving the item to an agent with a lower valuation. Usually this means he must risk not selling the item at all.</p>
<h3 id="vickreyclarkegroves-mechanisms">Vickrey–Clarke–Groves mechanisms</h3>

<p>The Vickrey (1961) auction model was later expanded by Clarke (1971) and Groves (1973) to treat a public choice problem in which a public project's cost is borne by all agents, e.g. whether to build a municipal bridge. The resulting "Vickrey–Clarke–Groves" mechanism can motivate agents to choose the socially efficient allocation of the public good even if agents have privately known valuations. In other words, it can solve the "<a href="tragedy_of_the_commons" title="wikilink">tragedy of the commons</a>"—under certain conditions, in particular quasilinear utility or if budget balance is not required.</p>

<p>Consider a setting in which 

<math display="inline" id="Mechanism_design:61">
 <semantics>
  <mi>I</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>I</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I
  </annotation>
 </semantics>
</math>

 number of agents have quasilinear utility with private valuations 

<math display="inline" id="Mechanism_design:62">
 <semantics>
  <mrow>
   <mi>v</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>t</mi>
    <mo>,</mo>
    <mi>θ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>v</ci>
    <vector>
     <ci>x</ci>
     <ci>t</ci>
     <ci>θ</ci>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v(x,t,\theta)
  </annotation>
 </semantics>
</math>

 where the currency 

<math display="inline" id="Mechanism_design:63">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 is valued linearly. The VCG designer designs an incentive compatible (hence truthfully implementable) mechanism to obtain the true type profile, from which the designer implements the socially optimal allocation</p>

<p>

<math display="block" id="Mechanism_design:64">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mi>x</mi>
     <mi>I</mi>
     <mo>*</mo>
    </msubsup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>θ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>∈</mo>
   <mrow>
    <mrow>
     <mi>arg</mi>
     <munder>
      <mi>max</mi>
      <mrow>
       <mi>x</mi>
       <mo>∈</mo>
       <mi>X</mi>
      </mrow>
     </munder>
    </mrow>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>i</mi>
       <mo>∈</mo>
       <mi>I</mi>
      </mrow>
     </munder>
     <mrow>
      <mi>v</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo>,</mo>
       <msub>
        <mi>θ</mi>
        <mi>i</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <times></times>
      </apply>
      <ci>I</ci>
     </apply>
     <ci>θ</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <arg></arg>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <max></max>
       <apply>
        <in></in>
        <ci>x</ci>
        <ci>X</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <in></in>
        <ci>i</ci>
        <ci>I</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>v</ci>
       <interval closure="open">
        <ci>x</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>θ</ci>
         <ci>i</ci>
        </apply>
       </interval>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{*}_{I}(\theta)\in\arg\max_{x\in X}\sum_{i\in I}v(x,\theta_{i})
  </annotation>
 </semantics>
</math>

</p>

<p>The cleverness of the VCG mechanism is the way it motivates truthful revelation. It eliminates incentives to misreport by penalizing any agent by the cost of the distortion he causes. Among the reports the agent may make, the VCG mechanism permits a "null" report saying he is indifferent to the public good and cares only about the money transfer. This effectively removes the agent from the game. If an agent does choose to report a type, the VCG mechanism charges the agent a fee if his report is <strong>pivotal</strong>, that is if his report changes the optimal allocation <em>x</em> so as to harm other agents. The payment is calculated</p>

<p>

<math display="block" id="Mechanism_design:65">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>t</mi>
     <mi>i</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mover accent="true">
      <mi>θ</mi>
      <mo stretchy="false">^</mo>
     </mover>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>j</mi>
       <mo>∈</mo>
       <mrow>
        <mi>I</mi>
        <mo>-</mo>
        <mi>i</mi>
       </mrow>
      </mrow>
     </munder>
     <mrow>
      <msub>
       <mi>v</mi>
       <mi>j</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <msubsup>
         <mi>x</mi>
         <mrow>
          <mi>I</mi>
          <mo>-</mo>
          <mi>i</mi>
         </mrow>
         <mo>*</mo>
        </msubsup>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>θ</mi>
          <mrow>
           <mi>I</mi>
           <mo>-</mo>
           <mi>i</mi>
          </mrow>
         </msub>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>,</mo>
       <msub>
        <mi>θ</mi>
        <mi>j</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>j</mi>
       <mo>∈</mo>
       <mrow>
        <mi>I</mi>
        <mo>-</mo>
        <mi>i</mi>
       </mrow>
      </mrow>
     </munder>
     <mrow>
      <msub>
       <mi>v</mi>
       <mi>j</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <msubsup>
         <mi>x</mi>
         <mi>I</mi>
         <mo>*</mo>
        </msubsup>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mover accent="true">
           <mi>θ</mi>
           <mo stretchy="false">^</mo>
          </mover>
          <mi>i</mi>
         </msub>
         <mo>,</mo>
         <msub>
          <mi>θ</mi>
          <mi>I</mi>
         </msub>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>,</mo>
       <msub>
        <mi>θ</mi>
        <mi>j</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>t</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <ci>normal-^</ci>
      <ci>θ</ci>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <in></in>
        <ci>j</ci>
        <apply>
         <minus></minus>
         <ci>I</ci>
         <ci>i</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>v</ci>
        <ci>j</ci>
       </apply>
       <interval closure="open">
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>x</ci>
           <times></times>
          </apply>
          <apply>
           <minus></minus>
           <ci>I</ci>
           <ci>i</ci>
          </apply>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>θ</ci>
          <apply>
           <minus></minus>
           <ci>I</ci>
           <ci>i</ci>
          </apply>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>θ</ci>
         <ci>j</ci>
        </apply>
       </interval>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <in></in>
        <ci>j</ci>
        <apply>
         <minus></minus>
         <ci>I</ci>
         <ci>i</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>v</ci>
        <ci>j</ci>
       </apply>
       <interval closure="open">
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>x</ci>
           <times></times>
          </apply>
          <ci>I</ci>
         </apply>
         <interval closure="open">
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <apply>
            <ci>normal-^</ci>
            <ci>θ</ci>
           </apply>
           <ci>i</ci>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>θ</ci>
           <ci>I</ci>
          </apply>
         </interval>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>θ</ci>
         <ci>j</ci>
        </apply>
       </interval>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t_{i}(\hat{\theta})=\sum_{j\in I-i}v_{j}(x^{*}_{I-i}(\theta_{I-i}),\theta_{j})%
-\sum_{j\in I-i}v_{j}(x^{*}_{I}(\hat{\theta}_{i},\theta_{I}),\theta_{j})
  </annotation>
 </semantics>
</math>

 which sums the distortion in the utilities of the other agents (and not his own) caused by one agent reporting.</p>
<h3 id="gibbardsatterthwaite-theorem">Gibbard–Satterthwaite theorem</h3>

<p>Gibbard (1973) and Satterthwaite (1975) give an impossibility result similar in spirit to <a href="Arrow's_impossibility_theorem" title="wikilink">Arrow's impossibility theorem</a>. For a very general class of games, only "dictatorial" social choice functions can be implemented.</p>

<p>A social choice function <em>f</em>() is <strong>dictatorial</strong> if one agent always receives his most-favored goods allocation,</p>

<p>

<math display="block" id="Mechanism_design:66">
 <semantics>
  <mrow>
   <mrow>
    <mtext>for</mtext>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi mathvariant="normal">Θ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mtext>,</mtext>
    <mrow>
     <mo>∃</mo>
     <mi>i</mi>
    </mrow>
   </mrow>
   <mo>∈</mo>
   <mrow>
    <mi>I</mi>
    <mtext>such that</mtext>
    <msub>
     <mi>u</mi>
     <mi>i</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <msub>
      <mi>θ</mi>
      <mi>i</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≥</mo>
   <mrow>
    <msub>
     <mi>u</mi>
     <mi>i</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>x</mi>
      <mo>′</mo>
     </msup>
     <mo>,</mo>
     <msub>
      <mi>θ</mi>
      <mi>i</mi>
     </msub>
     <mo rspace="7.5pt" stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo>∀</mo>
     <msup>
      <mi>x</mi>
      <mo>′</mo>
     </msup>
    </mrow>
   </mrow>
   <mo>∈</mo>
   <mi>X</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <in></in>
     <apply>
      <times></times>
      <mtext>for</mtext>
      <ci>f</ci>
      <ci>normal-Θ</ci>
      <mtext>,</mtext>
      <apply>
       <exists></exists>
       <ci>i</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>I</ci>
      <mtext>such that</mtext>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>u</ci>
       <ci>i</ci>
      </apply>
      <interval closure="open">
       <ci>x</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>θ</ci>
        <ci>i</ci>
       </apply>
      </interval>
     </apply>
    </apply>
    <apply>
     <geq></geq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>u</ci>
       <ci>i</ci>
      </apply>
      <interval closure="open">
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>x</ci>
        <ci>normal-′</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>θ</ci>
        <ci>i</ci>
       </apply>
      </interval>
      <apply>
       <csymbol cd="latexml">for-all</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>x</ci>
        <ci>normal-′</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <in></in>
     <share href="#.cmml">
     </share>
     <ci>X</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{for }f(\Theta)\text{, }\exists i\in I\text{ such that }u_{i}(x,\theta_{i%
})\geq u_{i}(x^{\prime},\theta_{i})\ \forall x^{\prime}\in X
  </annotation>
 </semantics>
</math>

</p>

<p>The theorem states that under general conditions any truthfully implementable social choice function must be dictatorial,</p>
<ol>
<li><em>X</em> finite and contains at least three elements</li>
<li>Preferences are rational</li>
<li>

<math display="inline" id="Mechanism_design:67">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi mathvariant="normal">Θ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>X</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>normal-Θ</ci>
    </apply>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(\Theta)=X
  </annotation>
 </semantics>
</math>

</li>
</ol>
<h3 id="myersonsatterthwaite-theorem">Myerson–Satterthwaite theorem</h3>

<p>Myerson and Satterthwaite (1983) show there is no efficient way for two parties to trade a good when they each have secret and probabilistically varying valuations for it, without the risk of forcing one party to trade at a loss. It is among the most remarkable negative results in economics—a kind of negative mirror to the <a href="fundamental_theorems_of_welfare_economics" title="wikilink">fundamental theorems of welfare economics</a>.</p>
<h2 id="examples">Examples</h2>
<h3 id="price-discrimination">Price discrimination</h3>

<p>Mirrlees (1971) introduces a setting in which the transfer function <em>t</em>() is easy to solve for. Due to its relevance and tractability it is a common setting in the literature. Consider a single-good, single-agent setting in which the agent has <a href="quasilinear_utility" title="wikilink">quasilinear utility</a> with an unknown type parameter 

<math display="inline" id="Mechanism_design:68">
 <semantics>
  <mi>θ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>θ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Mechanism_design:69">
 <semantics>
  <mrow>
   <mrow>
    <mi>u</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>t</mi>
     <mo>,</mo>
     <mi>θ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>V</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mi>θ</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mi>t</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>u</ci>
     <vector>
      <ci>x</ci>
      <ci>t</ci>
      <ci>θ</ci>
     </vector>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>V</ci>
      <interval closure="open">
       <ci>x</ci>
       <ci>θ</ci>
      </interval>
     </apply>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u(x,t,\theta)=V(x,\theta)-t
  </annotation>
 </semantics>
</math>

 and in which the principal has a prior <a href="Cumulative_distribution_function" title="wikilink">CDF</a> over the agent's type 

<math display="inline" id="Mechanism_design:70">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>θ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <ci>θ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(\theta)
  </annotation>
 </semantics>
</math>

. The principal can produce goods at a convex marginal cost <em>c</em>(<em>x</em>) and wants to maximize the expected profit from the transaction</p>

<p>

<math display="block" id="Mechanism_design:71">
 <semantics>
  <mrow>
   <mrow>
    <munder>
     <mi>max</mi>
     <mrow>
      <mrow>
       <mi>x</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>θ</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>,</mo>
      <mrow>
       <mi>t</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>θ</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </munder>
    <msub>
     <mi>𝔼</mi>
     <mi>θ</mi>
    </msub>
   </mrow>
   <mrow>
    <mo>[</mo>
    <mrow>
     <mrow>
      <mi>t</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>θ</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>-</mo>
     <mrow>
      <mi>c</mi>
      <mrow>
       <mo>(</mo>
       <mrow>
        <mi>x</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>θ</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <max></max>
      <list>
       <apply>
        <times></times>
        <ci>x</ci>
        <ci>θ</ci>
       </apply>
       <apply>
        <times></times>
        <ci>t</ci>
        <ci>θ</ci>
       </apply>
      </list>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝔼</ci>
      <ci>θ</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>t</ci>
       <ci>θ</ci>
      </apply>
      <apply>
       <times></times>
       <ci>c</ci>
       <apply>
        <times></times>
        <ci>x</ci>
        <ci>θ</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \max_{x(\theta),t(\theta)}\mathbb{E}_{\theta}\left[t(\theta)-c\left(x(\theta)%
\right)\right]
  </annotation>
 </semantics>
</math>

 subject to IC and IR conditions</p>

<p>

<math display="block" id="Mechanism_design:72">
 <semantics>
  <mrow>
   <mrow>
    <mi>u</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>x</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>θ</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mi>t</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>θ</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mi>θ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≥</mo>
   <mrow>
    <mrow>
     <mi>u</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>x</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msup>
         <mi>θ</mi>
         <mo>′</mo>
        </msup>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>,</mo>
      <mrow>
       <mi>t</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msup>
         <mi>θ</mi>
         <mo>′</mo>
        </msup>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>,</mo>
      <mi>θ</mi>
      <mo rspace="7.5pt" stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo>∀</mo>
      <mi>θ</mi>
     </mrow>
    </mrow>
    <mo>,</mo>
    <msup>
     <mi>θ</mi>
     <mo>′</mo>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <times></times>
     <ci>u</ci>
     <vector>
      <apply>
       <times></times>
       <ci>x</ci>
       <ci>θ</ci>
      </apply>
      <apply>
       <times></times>
       <ci>t</ci>
       <ci>θ</ci>
      </apply>
      <ci>θ</ci>
     </vector>
    </apply>
    <list>
     <apply>
      <times></times>
      <ci>u</ci>
      <vector>
       <apply>
        <times></times>
        <ci>x</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>θ</ci>
         <ci>normal-′</ci>
        </apply>
       </apply>
       <apply>
        <times></times>
        <ci>t</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>θ</ci>
         <ci>normal-′</ci>
        </apply>
       </apply>
       <ci>θ</ci>
      </vector>
      <apply>
       <csymbol cd="latexml">for-all</csymbol>
       <ci>θ</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>θ</ci>
      <ci>normal-′</ci>
     </apply>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u(x(\theta),t(\theta),\theta)\geq u(x(\theta^{\prime}),t(\theta^{\prime}),%
\theta)\ \forall\theta,\theta^{\prime}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Mechanism_design:73">
 <semantics>
  <mrow>
   <mrow>
    <mi>u</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>x</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>θ</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mi>t</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>θ</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mi>θ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≥</mo>
   <mrow>
    <munder accentunder="true">
     <mi>u</mi>
     <mo>¯</mo>
    </munder>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>θ</mi>
     <mo rspace="7.5pt" stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo>∀</mo>
     <mi>θ</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <times></times>
     <ci>u</ci>
     <vector>
      <apply>
       <times></times>
       <ci>x</ci>
       <ci>θ</ci>
      </apply>
      <apply>
       <times></times>
       <ci>t</ci>
       <ci>θ</ci>
      </apply>
      <ci>θ</ci>
     </vector>
    </apply>
    <apply>
     <times></times>
     <apply>
      <ci>normal-¯</ci>
      <ci>u</ci>
     </apply>
     <ci>θ</ci>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <ci>θ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u(x(\theta),t(\theta),\theta)\geq\underline{u}(\theta)\ \forall\theta
  </annotation>
 </semantics>
</math>

 The principal here is a monopolist trying to set a profit-maximizing price scheme in which it cannot identify the type of the customer. A common example is an airline setting fares for business, leisure and student travelers. Due to the IR condition it has to give every type a good enough deal to induce participation. Due to the IC condition it has to give every type a good enough deal that the type prefers its deal to that of any other.</p>

<p>A trick given by Mirrlees (1971) is to use the <a href="envelope_theorem" title="wikilink">envelope theorem</a> to eliminate the transfer function from the expectation to be maximized,</p>

<p>

<math display="block" id="Mechanism_design:74">
 <semantics>
  <mrow>
   <mrow>
    <mtext>let</mtext>
    <mi>U</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>θ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <munder>
      <mi>max</mi>
      <msup>
       <mi>θ</mi>
       <mo>′</mo>
      </msup>
     </munder>
     <mi>u</mi>
    </mrow>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mi>x</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msup>
        <mi>θ</mi>
        <mo>′</mo>
       </msup>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mi>t</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msup>
        <mi>θ</mi>
        <mo>′</mo>
       </msup>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mi>θ</mi>
     <mo>)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <mtext>let</mtext>
     <ci>U</ci>
     <ci>θ</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <max></max>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>θ</ci>
        <ci>normal-′</ci>
       </apply>
      </apply>
      <ci>u</ci>
     </apply>
     <vector>
      <apply>
       <times></times>
       <ci>x</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>θ</ci>
        <ci>normal-′</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>t</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>θ</ci>
        <ci>normal-′</ci>
       </apply>
      </apply>
      <ci>θ</ci>
     </vector>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{let }U(\theta)=\max_{\theta^{\prime}}u\left(x(\theta^{\prime}),t(\theta^%
{\prime}),\theta\right)
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Mechanism_design:75">
 <semantics>
  <mrow>
   <mfrac>
    <mrow>
     <mi>d</mi>
     <mi>U</mi>
    </mrow>
    <mrow>
     <mi>d</mi>
     <mi>θ</mi>
    </mrow>
   </mfrac>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mo>∂</mo>
     <mi>u</mi>
    </mrow>
    <mrow>
     <mo>∂</mo>
     <mi>θ</mi>
    </mrow>
   </mfrac>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mo>∂</mo>
     <mi>V</mi>
    </mrow>
    <mrow>
     <mo>∂</mo>
     <mi>θ</mi>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <ci>d</ci>
       <ci>U</ci>
      </apply>
      <apply>
       <times></times>
       <ci>d</ci>
       <ci>θ</ci>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <partialdiff></partialdiff>
       <ci>u</ci>
      </apply>
      <apply>
       <partialdiff></partialdiff>
       <ci>θ</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <divide></divide>
      <apply>
       <partialdiff></partialdiff>
       <ci>V</ci>
      </apply>
      <apply>
       <partialdiff></partialdiff>
       <ci>θ</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{dU}{d\theta}=\frac{\partial u}{\partial\theta}=\frac{\partial V}{%
\partial\theta}
  </annotation>
 </semantics>
</math>

 Integrating,</p>

<p>

<math display="block" id="Mechanism_design:76">
 <semantics>
  <mrow>
   <mrow>
    <mi>U</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>θ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <munder accentunder="true">
      <mi>u</mi>
      <mo>¯</mo>
     </munder>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>θ</mi>
       <mn>0</mn>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∫</mo>
      <msub>
       <mi>θ</mi>
       <mn>0</mn>
      </msub>
      <mi>θ</mi>
     </msubsup>
     <mrow>
      <mfrac>
       <mrow>
        <mo>∂</mo>
        <mi>V</mi>
       </mrow>
       <mrow>
        <mo>∂</mo>
        <mover accent="true">
         <mi>θ</mi>
         <mo stretchy="false">~</mo>
        </mover>
       </mrow>
      </mfrac>
      <mi>d</mi>
      <mover accent="true">
       <mi>θ</mi>
       <mo stretchy="false">~</mo>
      </mover>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>U</ci>
     <ci>θ</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <ci>normal-¯</ci>
       <ci>u</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>θ</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <int></int>
        <ci>θ</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>θ</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <apply>
         <partialdiff></partialdiff>
         <ci>V</ci>
        </apply>
        <apply>
         <partialdiff></partialdiff>
         <apply>
          <ci>normal-~</ci>
          <ci>θ</ci>
         </apply>
        </apply>
       </apply>
       <ci>d</ci>
       <apply>
        <ci>normal-~</ci>
        <ci>θ</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U(\theta)=\underline{u}(\theta_{0})+\int^{\theta}_{\theta_{0}}\frac{\partial V%
}{\partial\tilde{\theta}}d\tilde{\theta}
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Mechanism_design:77">
 <semantics>
  <msub>
   <mi>θ</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>θ</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta_{0}
  </annotation>
 </semantics>
</math>

 is some index type. Replacing the incentive-compatible 

<math display="inline" id="Mechanism_design:78">
 <semantics>
  <mrow>
   <mrow>
    <mi>t</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>θ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>V</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>x</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>θ</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>,</mo>
      <mi>θ</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mi>U</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>θ</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>t</ci>
     <ci>θ</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>V</ci>
      <interval closure="open">
       <apply>
        <times></times>
        <ci>x</ci>
        <ci>θ</ci>
       </apply>
       <ci>θ</ci>
      </interval>
     </apply>
     <apply>
      <times></times>
      <ci>U</ci>
      <ci>θ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t(\theta)=V(x(\theta),\theta)-U(\theta)
  </annotation>
 </semantics>
</math>

 in the maximand,</p>

<p>

<math display="block" id="Mechanism_design:79">
 <semantics>
  <mrow>
   <msub>
    <mi>𝔼</mi>
    <mi>θ</mi>
   </msub>
   <mrow>
    <mo>[</mo>
    <mrow>
     <mrow>
      <mi>V</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>x</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>θ</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>,</mo>
       <mi>θ</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>-</mo>
     <mrow>
      <munder accentunder="true">
       <mi>u</mi>
       <mo>¯</mo>
      </munder>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>θ</mi>
        <mn>0</mn>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>-</mo>
     <mrow>
      <msubsup>
       <mo largeop="true" symmetric="true">∫</mo>
       <msub>
        <mi>θ</mi>
        <mn>0</mn>
       </msub>
       <mi>θ</mi>
      </msubsup>
      <mrow>
       <mfrac>
        <mrow>
         <mo>∂</mo>
         <mi>V</mi>
        </mrow>
        <mrow>
         <mo>∂</mo>
         <mover accent="true">
          <mi>θ</mi>
          <mo stretchy="false">~</mo>
         </mover>
        </mrow>
       </mfrac>
       <mi>d</mi>
       <mover accent="true">
        <mi>θ</mi>
        <mo stretchy="false">~</mo>
       </mover>
      </mrow>
     </mrow>
     <mo>-</mo>
     <mrow>
      <mi>c</mi>
      <mrow>
       <mo>(</mo>
       <mrow>
        <mi>x</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>θ</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝔼</ci>
     <ci>θ</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>V</ci>
       <interval closure="open">
        <apply>
         <times></times>
         <ci>x</ci>
         <ci>θ</ci>
        </apply>
        <ci>θ</ci>
       </interval>
      </apply>
      <apply>
       <times></times>
       <apply>
        <ci>normal-¯</ci>
        <ci>u</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>θ</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <int></int>
         <ci>θ</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>θ</ci>
         <cn type="integer">0</cn>
        </apply>
       </apply>
       <apply>
        <times></times>
        <apply>
         <divide></divide>
         <apply>
          <partialdiff></partialdiff>
          <ci>V</ci>
         </apply>
         <apply>
          <partialdiff></partialdiff>
          <apply>
           <ci>normal-~</ci>
           <ci>θ</ci>
          </apply>
         </apply>
        </apply>
        <ci>d</ci>
        <apply>
         <ci>normal-~</ci>
         <ci>θ</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>c</ci>
       <apply>
        <times></times>
        <ci>x</ci>
        <ci>θ</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{E}_{\theta}\left[V(x(\theta),\theta)-\underline{u}(\theta_{0})-\int^{%
\theta}_{\theta_{0}}\frac{\partial V}{\partial\tilde{\theta}}d\tilde{\theta}-c%
\left(x(\theta)\right)\right]
  </annotation>
 </semantics>
</math>

</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Mechanism_design:80">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>𝔼</mi>
     <mi>θ</mi>
    </msub>
    <mrow>
     <mo>[</mo>
     <mrow>
      <mrow>
       <mi>V</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>x</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>θ</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>,</mo>
        <mi>θ</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>-</mo>
      <mrow>
       <munder accentunder="true">
        <mi>u</mi>
        <mo>¯</mo>
       </munder>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>θ</mi>
         <mn>0</mn>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>-</mo>
      <mrow>
       <mfrac>
        <mrow>
         <mn>1</mn>
         <mo>-</mo>
         <mrow>
          <mi>P</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>θ</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
        </mrow>
        <mrow>
         <mi>p</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>θ</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mfrac>
       <mfrac>
        <mrow>
         <mo>∂</mo>
         <mi>V</mi>
        </mrow>
        <mrow>
         <mo>∂</mo>
         <mi>θ</mi>
        </mrow>
       </mfrac>
      </mrow>
      <mo>-</mo>
      <mrow>
       <mi>c</mi>
       <mrow>
        <mo>(</mo>
        <mrow>
         <mi>x</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>θ</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo>]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <csymbol cd="latexml">absent</csymbol>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝔼</ci>
      <ci>θ</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <ci>V</ci>
        <interval closure="open">
         <apply>
          <times></times>
          <ci>x</ci>
          <ci>θ</ci>
         </apply>
         <ci>θ</ci>
        </interval>
       </apply>
       <apply>
        <times></times>
        <apply>
         <ci>normal-¯</ci>
         <ci>u</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>θ</ci>
         <cn type="integer">0</cn>
        </apply>
       </apply>
       <apply>
        <times></times>
        <apply>
         <divide></divide>
         <apply>
          <minus></minus>
          <cn type="integer">1</cn>
          <apply>
           <times></times>
           <ci>P</ci>
           <ci>θ</ci>
          </apply>
         </apply>
         <apply>
          <times></times>
          <ci>p</ci>
          <ci>θ</ci>
         </apply>
        </apply>
        <apply>
         <divide></divide>
         <apply>
          <partialdiff></partialdiff>
          <ci>V</ci>
         </apply>
         <apply>
          <partialdiff></partialdiff>
          <ci>θ</ci>
         </apply>
        </apply>
       </apply>
       <apply>
        <times></times>
        <ci>c</ci>
        <apply>
         <times></times>
         <ci>x</ci>
         <ci>θ</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =\mathbb{E}_{\theta}\left[V(x(\theta),\theta)-\underline{u}(\theta_{0})-\frac{%
1-P(\theta)}{p(\theta)}\frac{\partial V}{\partial\theta}-c\left(x(\theta)%
\right)\right]
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>after an integration by parts. This function can be maximized pointwise.</p>

<p>Because 

<math display="inline" id="Mechanism_design:81">
 <semantics>
  <mrow>
   <mi>U</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>θ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>U</ci>
    <ci>θ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U(\theta)
  </annotation>
 </semantics>
</math>

 is incentive-compatible already the designer can drop the IC constraint. If the utility function satisfies the Spence–Mirrlees condition then a monotonic 

<math display="inline" id="Mechanism_design:82">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>θ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>x</ci>
    <ci>θ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x(\theta)
  </annotation>
 </semantics>
</math>

 function exists. The IR constraint can be checked at equilibrium and the fee schedule raised or lowered accordingly. Additionally, note the presence of a <a href="hazard_rate" title="wikilink">hazard rate</a> in the expression. If the type distribution bears the monotone hazard ratio property, the FOC is sufficient to solve for <em>t</em>(). If not, then it is necessary to check whether the monotonicity constraint (see <a href="Mechanism_design#Sufficiency" title="wikilink">sufficiency</a>, above) is satisfied everywhere along the allocation and fee schedules. If not, then the designer must use Myerson ironing.</p>
<h3 id="myerson-ironing">Myerson ironing</h3>
<figure><b>(Figure)</b>
<figcaption> It is possible to solve for a goods or price schedule that satisfies the first-order conditions yet is not monotonic. If so it is necessary to "iron" the schedule by choosing some value at which to flatten the function.</figcaption>
</figure>

<p>In some applications the designer may solve the first-order conditions for the price and allocation schedules yet find they are not monotonic. For example, in the quasilinear setting this often happens when the hazard ratio is itself not monotone. By the Spence–Mirrlees condition the optimal price and allocation schedules must be monotonic, so the designer must eliminate any interval over which the schedule changes direction by flattening it.</p>

<p>Intuitively, what is going on is the designer finds it optimal to <strong>bunch</strong> certain types together and give them the same contract. Normally the designer motivates higher types to distinguish themselves by giving them a better deal. If there are insufficiently few higher types on the margin the designer does not find it worthwhile to grant lower types a concession (called their <a href="information_rent" title="wikilink">information rent</a>) in order to charge higher types a type-specific contract.</p>

<p>Consider a monopolist principal selling to agents with quasilinear utility, the example above. Suppose the allocation schedule 

<math display="inline" id="Mechanism_design:83">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>θ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>x</ci>
    <ci>θ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x(\theta)
  </annotation>
 </semantics>
</math>

 satisfying the first-order conditions has a single interior peak at 

<math display="inline" id="Mechanism_design:84">
 <semantics>
  <msub>
   <mi>θ</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>θ</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta_{1}
  </annotation>
 </semantics>
</math>

 and a single interior trough at 

<math display="inline" id="Mechanism_design:85">
 <semantics>
  <mrow>
   <msub>
    <mi>θ</mi>
    <mn>2</mn>
   </msub>
   <mo>></mo>
   <msub>
    <mi>θ</mi>
    <mn>1</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>θ</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>θ</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta_{2}>\theta_{1}
  </annotation>
 </semantics>
</math>

, illustrated at right.</p>
<ul>
<li>Following Myerson (1981) flatten it by choosing 

<math display="inline" id="Mechanism_design:86">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 satisfying</li>
</ul>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Mechanism_design:87">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∫</mo>
     <mrow>
      <msub>
       <mi>ϕ</mi>
       <mn>2</mn>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mrow>
      <msub>
       <mi>ϕ</mi>
       <mn>1</mn>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </msubsup>
    <mrow>
     <mrow>
      <mo>(</mo>
      <mrow>
       <mrow>
        <mfrac>
         <mrow>
          <mo>∂</mo>
          <mi>V</mi>
         </mrow>
         <mrow>
          <mo>∂</mo>
          <mi>x</mi>
         </mrow>
        </mfrac>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>x</mi>
         <mo>,</mo>
         <mi>θ</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>-</mo>
       <mrow>
        <mfrac>
         <mrow>
          <mn>1</mn>
          <mo>-</mo>
          <mrow>
           <mi>P</mi>
           <mrow>
            <mo stretchy="false">(</mo>
            <mi>θ</mi>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
         </mrow>
         <mrow>
          <mi>p</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>θ</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
        </mfrac>
        <mfrac>
         <mrow>
          <msup>
           <mo>∂</mo>
           <mn>2</mn>
          </msup>
          <mi>V</mi>
         </mrow>
         <mrow>
          <mrow>
           <mo>∂</mo>
           <mpadded width="+1.7pt">
            <mi>θ</mi>
           </mpadded>
          </mrow>
          <mrow>
           <mo>∂</mo>
           <mi>x</mi>
          </mrow>
         </mrow>
        </mfrac>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>x</mi>
         <mo>,</mo>
         <mi>θ</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>-</mo>
       <mrow>
        <mfrac>
         <mrow>
          <mo>∂</mo>
          <mi>c</mi>
         </mrow>
         <mrow>
          <mo>∂</mo>
          <mi>x</mi>
         </mrow>
        </mfrac>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>x</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
      <mo>)</mo>
     </mrow>
     <mi>d</mi>
     <mi>θ</mi>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <int></int>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>ϕ</ci>
         <cn type="integer">1</cn>
        </apply>
        <ci>x</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ϕ</ci>
        <cn type="integer">2</cn>
       </apply>
       <ci>x</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <apply>
         <divide></divide>
         <apply>
          <partialdiff></partialdiff>
          <ci>V</ci>
         </apply>
         <apply>
          <partialdiff></partialdiff>
          <ci>x</ci>
         </apply>
        </apply>
        <interval closure="open">
         <ci>x</ci>
         <ci>θ</ci>
        </interval>
       </apply>
       <apply>
        <times></times>
        <apply>
         <divide></divide>
         <apply>
          <minus></minus>
          <cn type="integer">1</cn>
          <apply>
           <times></times>
           <ci>P</ci>
           <ci>θ</ci>
          </apply>
         </apply>
         <apply>
          <times></times>
          <ci>p</ci>
          <ci>θ</ci>
         </apply>
        </apply>
        <apply>
         <divide></divide>
         <apply>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <partialdiff></partialdiff>
           <cn type="integer">2</cn>
          </apply>
          <ci>V</ci>
         </apply>
         <apply>
          <times></times>
          <apply>
           <partialdiff></partialdiff>
           <ci>θ</ci>
          </apply>
          <apply>
           <partialdiff></partialdiff>
           <ci>x</ci>
          </apply>
         </apply>
        </apply>
        <interval closure="open">
         <ci>x</ci>
         <ci>θ</ci>
        </interval>
       </apply>
       <apply>
        <times></times>
        <apply>
         <divide></divide>
         <apply>
          <partialdiff></partialdiff>
          <ci>c</ci>
         </apply>
         <apply>
          <partialdiff></partialdiff>
          <ci>x</ci>
         </apply>
        </apply>
        <ci>x</ci>
       </apply>
      </apply>
      <ci>d</ci>
      <ci>θ</ci>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \int^{\phi_{1}(x)}_{\phi_{2}(x)}\left(\frac{\partial V}{\partial x}(x,\theta)-%
\frac{1-P(\theta)}{p(\theta)}\frac{\partial^{2}V}{\partial\theta\,\partial x}(%
x,\theta)-\frac{\partial c}{\partial x}(x)\right)d\theta=0
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
<dd>where 

<math display="inline" id="Mechanism_design:88">
 <semantics>
  <mrow>
   <msub>
    <mi>ϕ</mi>
    <mn>1</mn>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ϕ</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi_{1}(x)
  </annotation>
 </semantics>
</math>

 is the inverse function of x mapping to 

<math display="inline" id="Mechanism_design:89">
 <semantics>
  <mrow>
   <mi>θ</mi>
   <mo>≤</mo>
   <msub>
    <mi>θ</mi>
    <mn>1</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <ci>θ</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>θ</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta\leq\theta_{1}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Mechanism_design:90">
 <semantics>
  <mrow>
   <msub>
    <mi>ϕ</mi>
    <mn>2</mn>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ϕ</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi_{2}(x)
  </annotation>
 </semantics>
</math>

is the inverse function of x mapping to 

<math display="inline" id="Mechanism_design:91">
 <semantics>
  <mrow>
   <mi>θ</mi>
   <mo>≥</mo>
   <msub>
    <mi>θ</mi>
    <mn>2</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <ci>θ</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>θ</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta\geq\theta_{2}
  </annotation>
 </semantics>
</math>

. That is, 

<math display="inline" id="Mechanism_design:92">
 <semantics>
  <msub>
   <mi>ϕ</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ϕ</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi_{1}
  </annotation>
 </semantics>
</math>

 returns a 

<math display="inline" id="Mechanism_design:93">
 <semantics>
  <mi>θ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>θ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta
  </annotation>
 </semantics>
</math>

 before the interior peak and 

<math display="inline" id="Mechanism_design:94">
 <semantics>
  <msub>
   <mi>ϕ</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ϕ</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi_{2}
  </annotation>
 </semantics>
</math>

 returns a 

<math display="inline" id="Mechanism_design:95">
 <semantics>
  <mi>θ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>θ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta
  </annotation>
 </semantics>
</math>

 after the interior trough.
</dd>
</dl>
<ul>
<li>If the nonmonotonic region of 

<math display="inline" id="Mechanism_design:96">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>θ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>x</ci>
    <ci>θ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x(\theta)
  </annotation>
 </semantics>
</math>

 borders the edge of the type space, simply set the appropriate 

<math display="inline" id="Mechanism_design:97">
 <semantics>
  <mrow>
   <mi>ϕ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>ϕ</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi(x)
  </annotation>
 </semantics>
</math>

 function (or both) to the boundary type. If there are multiple regions, see a textbook for an iterative procedure; it may be that more than one troughs should be ironed together.</li>
</ul>
<h4 id="proof">Proof</h4>

<p>The proof uses the theory of optimal control. It considers the set of intervals 

<math display="inline" id="Mechanism_design:98">
 <semantics>
  <mrow>
   <mo>[</mo>
   <munder accentunder="true">
    <mi>θ</mi>
    <mo>¯</mo>
   </munder>
   <mo>,</mo>
   <mover accent="true">
    <mi>θ</mi>
    <mo>¯</mo>
   </mover>
   <mo>]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="closed">
    <apply>
     <ci>normal-¯</ci>
     <ci>θ</ci>
    </apply>
    <apply>
     <ci>normal-¯</ci>
     <ci>θ</ci>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left[\underline{\theta},\overline{\theta}\right]
  </annotation>
 </semantics>
</math>

 in the nonmonotonic region of 

<math display="inline" id="Mechanism_design:99">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>θ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>x</ci>
    <ci>θ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x(\theta)
  </annotation>
 </semantics>
</math>

 over which it might flatten the schedule. It then writes a Hamiltonian to obtain necessary conditions for a 

<math display="inline" id="Mechanism_design:100">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>θ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>x</ci>
    <ci>θ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x(\theta)
  </annotation>
 </semantics>
</math>

 within the intervals</p>
<ol>
<li>that does satisfy monotonicity</li>
<li>for which the monotonicity constraint is not binding on the boundaries of the interval</li>
</ol>

<p>Condition two ensures that the 

<math display="inline" id="Mechanism_design:101">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>θ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>x</ci>
    <ci>θ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x(\theta)
  </annotation>
 </semantics>
</math>

 satisfying the optimal control problem reconnects to the schedule in the original problem at the interval boundaries (no jumps). Any 

<math display="inline" id="Mechanism_design:102">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>θ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>x</ci>
    <ci>θ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x(\theta)
  </annotation>
 </semantics>
</math>

 satisfying the necessary conditions must be flat because it must be monotonic and yet reconnect at the boundaries.</p>

<p>As before maximize the principal's expected payoff, but this time subject to the monotonicity constraint</p>

<p>

<math display="block" id="Mechanism_design:103">
 <semantics>
  <mrow>
   <mfrac>
    <mrow>
     <mo>∂</mo>
     <mi>x</mi>
    </mrow>
    <mrow>
     <mo>∂</mo>
     <mi>θ</mi>
    </mrow>
   </mfrac>
   <mo>≥</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <divide></divide>
     <apply>
      <partialdiff></partialdiff>
      <ci>x</ci>
     </apply>
     <apply>
      <partialdiff></partialdiff>
      <ci>θ</ci>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{\partial x}{\partial\theta}\geq 0
  </annotation>
 </semantics>
</math>

 and use a Hamiltonian to do it, with shadow price 

<math display="inline" id="Mechanism_design:104">
 <semantics>
  <mrow>
   <mi>ν</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>θ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>ν</ci>
    <ci>θ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \nu(\theta)
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Mechanism_design:105">
 <semantics>
  <mrow>
   <mi>H</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <mo>(</mo>
      <mrow>
       <mrow>
        <mi>V</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>x</mi>
         <mo>,</mo>
         <mi>θ</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>-</mo>
       <mrow>
        <munder accentunder="true">
         <mi>u</mi>
         <mo>¯</mo>
        </munder>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>θ</mi>
          <mn>0</mn>
         </msub>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>-</mo>
       <mrow>
        <mfrac>
         <mrow>
          <mn>1</mn>
          <mo>-</mo>
          <mrow>
           <mi>P</mi>
           <mrow>
            <mo stretchy="false">(</mo>
            <mi>θ</mi>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
         </mrow>
         <mrow>
          <mi>p</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>θ</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
        </mfrac>
        <mfrac>
         <mrow>
          <mo>∂</mo>
          <mi>V</mi>
         </mrow>
         <mrow>
          <mo>∂</mo>
          <mi>θ</mi>
         </mrow>
        </mfrac>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>x</mi>
         <mo>,</mo>
         <mi>θ</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>-</mo>
       <mrow>
        <mi>c</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>x</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
      <mo>)</mo>
     </mrow>
     <mi>p</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>θ</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>ν</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>θ</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mfrac>
      <mrow>
       <mo>∂</mo>
       <mi>x</mi>
      </mrow>
      <mrow>
       <mo>∂</mo>
       <mi>θ</mi>
      </mrow>
     </mfrac>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>H</ci>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <ci>V</ci>
        <interval closure="open">
         <ci>x</ci>
         <ci>θ</ci>
        </interval>
       </apply>
       <apply>
        <times></times>
        <apply>
         <ci>normal-¯</ci>
         <ci>u</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>θ</ci>
         <cn type="integer">0</cn>
        </apply>
       </apply>
       <apply>
        <times></times>
        <apply>
         <divide></divide>
         <apply>
          <minus></minus>
          <cn type="integer">1</cn>
          <apply>
           <times></times>
           <ci>P</ci>
           <ci>θ</ci>
          </apply>
         </apply>
         <apply>
          <times></times>
          <ci>p</ci>
          <ci>θ</ci>
         </apply>
        </apply>
        <apply>
         <divide></divide>
         <apply>
          <partialdiff></partialdiff>
          <ci>V</ci>
         </apply>
         <apply>
          <partialdiff></partialdiff>
          <ci>θ</ci>
         </apply>
        </apply>
        <interval closure="open">
         <ci>x</ci>
         <ci>θ</ci>
        </interval>
       </apply>
       <apply>
        <times></times>
        <ci>c</ci>
        <ci>x</ci>
       </apply>
      </apply>
      <ci>p</ci>
      <ci>θ</ci>
     </apply>
     <apply>
      <times></times>
      <ci>ν</ci>
      <ci>θ</ci>
      <apply>
       <divide></divide>
       <apply>
        <partialdiff></partialdiff>
        <ci>x</ci>
       </apply>
       <apply>
        <partialdiff></partialdiff>
        <ci>θ</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H=\left(V(x,\theta)-\underline{u}(\theta_{0})-\frac{1-P(\theta)}{p(\theta)}%
\frac{\partial V}{\partial\theta}(x,\theta)-c(x)\right)p(\theta)+\nu(\theta)%
\frac{\partial x}{\partial\theta}
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Mechanism_design:106">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 is a state variable and 

<math display="inline" id="Mechanism_design:107">
 <semantics>
  <mrow>
   <mrow>
    <mo>∂</mo>
    <mi>x</mi>
   </mrow>
   <mo>/</mo>
   <mrow>
    <mo>∂</mo>
    <mi>θ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <partialdiff></partialdiff>
     <ci>x</ci>
    </apply>
    <apply>
     <partialdiff></partialdiff>
     <ci>θ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \partial x/\partial\theta
  </annotation>
 </semantics>
</math>

 the control. As usual in optimal control the costate evolution equation must satisfy</p>

<p>

<math display="block" id="Mechanism_design:108">
 <semantics>
  <mrow>
   <mfrac>
    <mrow>
     <mo>∂</mo>
     <mi>ν</mi>
    </mrow>
    <mrow>
     <mo>∂</mo>
     <mi>θ</mi>
    </mrow>
   </mfrac>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <mfrac>
     <mrow>
      <mo>∂</mo>
      <mi>H</mi>
     </mrow>
     <mrow>
      <mo>∂</mo>
      <mi>x</mi>
     </mrow>
    </mfrac>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <mrow>
     <mrow>
      <mo>(</mo>
      <mrow>
       <mrow>
        <mfrac>
         <mrow>
          <mo>∂</mo>
          <mi>V</mi>
         </mrow>
         <mrow>
          <mo>∂</mo>
          <mi>x</mi>
         </mrow>
        </mfrac>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>x</mi>
         <mo>,</mo>
         <mi>θ</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>-</mo>
       <mrow>
        <mfrac>
         <mrow>
          <mn>1</mn>
          <mo>-</mo>
          <mrow>
           <mi>P</mi>
           <mrow>
            <mo stretchy="false">(</mo>
            <mi>θ</mi>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
         </mrow>
         <mrow>
          <mi>p</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>θ</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
        </mfrac>
        <mfrac>
         <mrow>
          <msup>
           <mo>∂</mo>
           <mn>2</mn>
          </msup>
          <mi>V</mi>
         </mrow>
         <mrow>
          <mrow>
           <mo>∂</mo>
           <mpadded width="+1.7pt">
            <mi>θ</mi>
           </mpadded>
          </mrow>
          <mrow>
           <mo>∂</mo>
           <mi>x</mi>
          </mrow>
         </mrow>
        </mfrac>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>x</mi>
         <mo>,</mo>
         <mi>θ</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>-</mo>
       <mrow>
        <mfrac>
         <mrow>
          <mo>∂</mo>
          <mi>c</mi>
         </mrow>
         <mrow>
          <mo>∂</mo>
          <mi>x</mi>
         </mrow>
        </mfrac>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>x</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
      <mo>)</mo>
     </mrow>
     <mi>p</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>θ</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <divide></divide>
      <apply>
       <partialdiff></partialdiff>
       <ci>ν</ci>
      </apply>
      <apply>
       <partialdiff></partialdiff>
       <ci>θ</ci>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <divide></divide>
       <apply>
        <partialdiff></partialdiff>
        <ci>H</ci>
       </apply>
       <apply>
        <partialdiff></partialdiff>
        <ci>x</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <apply>
          <divide></divide>
          <apply>
           <partialdiff></partialdiff>
           <ci>V</ci>
          </apply>
          <apply>
           <partialdiff></partialdiff>
           <ci>x</ci>
          </apply>
         </apply>
         <interval closure="open">
          <ci>x</ci>
          <ci>θ</ci>
         </interval>
        </apply>
        <apply>
         <times></times>
         <apply>
          <divide></divide>
          <apply>
           <minus></minus>
           <cn type="integer">1</cn>
           <apply>
            <times></times>
            <ci>P</ci>
            <ci>θ</ci>
           </apply>
          </apply>
          <apply>
           <times></times>
           <ci>p</ci>
           <ci>θ</ci>
          </apply>
         </apply>
         <apply>
          <divide></divide>
          <apply>
           <apply>
            <csymbol cd="ambiguous">superscript</csymbol>
            <partialdiff></partialdiff>
            <cn type="integer">2</cn>
           </apply>
           <ci>V</ci>
          </apply>
          <apply>
           <times></times>
           <apply>
            <partialdiff></partialdiff>
            <ci>θ</ci>
           </apply>
           <apply>
            <partialdiff></partialdiff>
            <ci>x</ci>
           </apply>
          </apply>
         </apply>
         <interval closure="open">
          <ci>x</ci>
          <ci>θ</ci>
         </interval>
        </apply>
        <apply>
         <times></times>
         <apply>
          <divide></divide>
          <apply>
           <partialdiff></partialdiff>
           <ci>c</ci>
          </apply>
          <apply>
           <partialdiff></partialdiff>
           <ci>x</ci>
          </apply>
         </apply>
         <ci>x</ci>
        </apply>
       </apply>
       <ci>p</ci>
       <ci>θ</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{\partial\nu}{\partial\theta}=-\frac{\partial H}{\partial x}=-\left(\frac%
{\partial V}{\partial x}(x,\theta)-\frac{1-P(\theta)}{p(\theta)}\frac{\partial%
^{2}V}{\partial\theta\,\partial x}(x,\theta)-\frac{\partial c}{\partial x}(x)%
\right)p(\theta)
  </annotation>
 </semantics>
</math>

 Taking advantage of condition 2, note the monotonicity constraint is not binding at the boundaries of the 

<math display="inline" id="Mechanism_design:109">
 <semantics>
  <mi>θ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>θ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta
  </annotation>
 </semantics>
</math>

 interval,</p>

<p>

<math display="block" id="Mechanism_design:110">
 <semantics>
  <mrow>
   <mrow>
    <mi>ν</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <munder accentunder="true">
      <mi>θ</mi>
      <mo>¯</mo>
     </munder>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>ν</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mover accent="true">
      <mi>θ</mi>
      <mo>¯</mo>
     </mover>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>ν</ci>
      <apply>
       <ci>normal-¯</ci>
       <ci>θ</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>ν</ci>
      <apply>
       <ci>normal-¯</ci>
       <ci>θ</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \nu(\underline{\theta})=\nu(\overline{\theta})=0
  </annotation>
 </semantics>
</math>

 meaning the costate variable condition can be integrated and also equals 0</p>

<p>

<math display="block" id="Mechanism_design:111">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∫</mo>
     <munder accentunder="true">
      <mi>θ</mi>
      <mo>¯</mo>
     </munder>
     <mover accent="true">
      <mi>θ</mi>
      <mo>¯</mo>
     </mover>
    </msubsup>
    <mrow>
     <mrow>
      <mo>(</mo>
      <mrow>
       <mrow>
        <mfrac>
         <mrow>
          <mo>∂</mo>
          <mi>V</mi>
         </mrow>
         <mrow>
          <mo>∂</mo>
          <mi>x</mi>
         </mrow>
        </mfrac>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>x</mi>
         <mo>,</mo>
         <mi>θ</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>-</mo>
       <mrow>
        <mfrac>
         <mrow>
          <mn>1</mn>
          <mo>-</mo>
          <mrow>
           <mi>P</mi>
           <mrow>
            <mo stretchy="false">(</mo>
            <mi>θ</mi>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
         </mrow>
         <mrow>
          <mi>p</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>θ</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
        </mfrac>
        <mfrac>
         <mrow>
          <msup>
           <mo>∂</mo>
           <mn>2</mn>
          </msup>
          <mi>V</mi>
         </mrow>
         <mrow>
          <mrow>
           <mo>∂</mo>
           <mpadded width="+1.7pt">
            <mi>θ</mi>
           </mpadded>
          </mrow>
          <mrow>
           <mo>∂</mo>
           <mi>x</mi>
          </mrow>
         </mrow>
        </mfrac>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>x</mi>
         <mo>,</mo>
         <mi>θ</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>-</mo>
       <mrow>
        <mfrac>
         <mrow>
          <mo>∂</mo>
          <mi>c</mi>
         </mrow>
         <mrow>
          <mo>∂</mo>
          <mi>x</mi>
         </mrow>
        </mfrac>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>x</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
      <mo>)</mo>
     </mrow>
     <mi>p</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>θ</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>d</mi>
     <mi>θ</mi>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <int></int>
       <apply>
        <ci>normal-¯</ci>
        <ci>θ</ci>
       </apply>
      </apply>
      <apply>
       <ci>normal-¯</ci>
       <ci>θ</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <apply>
         <divide></divide>
         <apply>
          <partialdiff></partialdiff>
          <ci>V</ci>
         </apply>
         <apply>
          <partialdiff></partialdiff>
          <ci>x</ci>
         </apply>
        </apply>
        <interval closure="open">
         <ci>x</ci>
         <ci>θ</ci>
        </interval>
       </apply>
       <apply>
        <times></times>
        <apply>
         <divide></divide>
         <apply>
          <minus></minus>
          <cn type="integer">1</cn>
          <apply>
           <times></times>
           <ci>P</ci>
           <ci>θ</ci>
          </apply>
         </apply>
         <apply>
          <times></times>
          <ci>p</ci>
          <ci>θ</ci>
         </apply>
        </apply>
        <apply>
         <divide></divide>
         <apply>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <partialdiff></partialdiff>
           <cn type="integer">2</cn>
          </apply>
          <ci>V</ci>
         </apply>
         <apply>
          <times></times>
          <apply>
           <partialdiff></partialdiff>
           <ci>θ</ci>
          </apply>
          <apply>
           <partialdiff></partialdiff>
           <ci>x</ci>
          </apply>
         </apply>
        </apply>
        <interval closure="open">
         <ci>x</ci>
         <ci>θ</ci>
        </interval>
       </apply>
       <apply>
        <times></times>
        <apply>
         <divide></divide>
         <apply>
          <partialdiff></partialdiff>
          <ci>c</ci>
         </apply>
         <apply>
          <partialdiff></partialdiff>
          <ci>x</ci>
         </apply>
        </apply>
        <ci>x</ci>
       </apply>
      </apply>
      <ci>p</ci>
      <ci>θ</ci>
      <ci>d</ci>
      <ci>θ</ci>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \int^{\overline{\theta}}_{\underline{\theta}}\left(\frac{\partial V}{\partial x%
}(x,\theta)-\frac{1-P(\theta)}{p(\theta)}\frac{\partial^{2}V}{\partial\theta\,%
\partial x}(x,\theta)-\frac{\partial c}{\partial x}(x)\right)p(\theta)d\theta=0
  </annotation>
 </semantics>
</math>

 The average distortion of the principal's surplus must be 0. To flatten the schedule, find an 

<math display="inline" id="Mechanism_design:112">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 such that its inverse image maps to a 

<math display="inline" id="Mechanism_design:113">
 <semantics>
  <mi>θ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>θ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta
  </annotation>
 </semantics>
</math>

 interval satisfying the condition above.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Algorithmic_mechanism_design" title="wikilink">Algorithmic mechanism design</a></li>
<li><a href="Assignment_problem" title="wikilink">Assignment problem</a></li>
<li><a href="Contract_theory" title="wikilink">Contract theory</a></li>
<li><a href="Implementation_theory" title="wikilink">Implementation theory</a></li>
<li><a href="Incentive_compatibility" title="wikilink">Incentive compatibility</a></li>
<li><a href="Revelation_principle" title="wikilink">Revelation principle</a></li>
<li><a href="Smart_market" title="wikilink">Smart market</a></li>
<li><a class="uri" href="Metagame" title="wikilink">Metagame</a></li>
</ul>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<ul>
<li>Chapter 7 of . A standard text for graduate game theory.</li>
<li>Chapter 23 of . A standard text for graduate microeconomics.</li>
<li>

<p>. <a href="Paul_Milgrom#Biography" title="wikilink">Applications</a> of mechanism design principles in the context of auctions.</p></li>
<li><a href="Noam_Nisan" title="wikilink">Noam Nisan</a>. A <a href="https://www.youtube.com/watch?v=Ps5aYsG8jY0">Google tech talk</a> on mechanism design.</li>
<li>Roger B. Myerson (2008). "mechanism design," ''The New Palgrave Dictionary of Economics Online, [<a class="uri" href="http://www.dictionaryofeconomics.com/article?id=pde2008_M000132&amp;q">http://www.dictionaryofeconomics.com/article?id=pde2008_M000132&amp;q;</a>;=Mechanism%20design&amp;topicid;=&amp;result;_number=2 Abstract.]</li>
</ul>

<p>"</p>

<p><a href="Category:Game_theory" title="wikilink">Category:Game theory</a> <a href="Category:Social_choice_theory" title="wikilink">Category:Social choice theory</a> <a href="Category:Mechanism_design" title="wikilink">*</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">L. Hurwicz &amp; S. Reiter (2006) <a href="Designing_Economic_Mechanisms" title="wikilink">Designing Economic Mechanisms</a>, p. 30<a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3">In unusual circumstances some truth-telling games have more equilibria than the Bayesian game they mapped from. See Fudenburg-Tirole Ch. 7.2 for some references.<a href="#fnref3">↩</a></li>
</ol>
</section>
</body>
</html>
