<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="116">Mealy machine</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Mealy machine</h1>
<hr/>

<p>In the <a href="theory_of_computation" title="wikilink">theory of computation</a>, a <strong>Mealy machine</strong> is a <a href="finite-state_machine" title="wikilink">finite-state machine</a> whose output values are determined both by its current <a href="state_(computer_science)" title="wikilink">state</a> and the current inputs. (This is in contrast to a <a href="Moore_machine" title="wikilink">Moore machine</a>, whose output values are determined solely by its current state.) A Mealy machine is a <a href="deterministic_automaton" title="wikilink">deterministic</a> <a href="finite_state_transducer" title="wikilink">finite state transducer</a>: for each state and input, at most one transition is possible.</p>
<h2 id="history">History</h2>

<p>The Mealy machine is named after <a href="George_H._Mealy" title="wikilink">George H. Mealy</a>, who presented the concept in a 1955 paper, “A Method for Synthesizing Sequential Circuits”.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>
<h2 id="formal-definition">Formal definition</h2>

<p>A Mealy machine is a <a href="N-tuple" title="wikilink">6-tuple</a> 

<math display="inline" id="Mealy_machine:0">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>S</mi>
   <mo>,</mo>
   <msub>
    <mi>S</mi>
    <mn>0</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">Σ</mi>
   <mo>,</mo>
   <mi mathvariant="normal">Λ</mi>
   <mo>,</mo>
   <mi>T</mi>
   <mo>,</mo>
   <mi>G</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <ci>S</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>S</ci>
     <cn type="integer">0</cn>
    </apply>
    <ci>normal-Σ</ci>
    <ci>normal-Λ</ci>
    <ci>T</ci>
    <ci>G</ci>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (S,S_{0},\Sigma,\Lambda,T,G)
  </annotation>
 </semantics>
</math>

 consisting of the following:</p>
<ul>
<li>a <a href="finite_set" title="wikilink">finite set</a> of <a href="State_(computer_science)" title="wikilink">states</a> 

<math display="inline" id="Mealy_machine:1">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

</li>
<li>a start state (also called initial state) 

<math display="inline" id="Mealy_machine:2">
 <semantics>
  <msub>
   <mi>S</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>S</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{0}
  </annotation>
 </semantics>
</math>

 which is an element of 

<math display="inline" id="Mealy_machine:3">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

</li>
<li>a <a href="finite_set" title="wikilink">finite set</a> called the input <a href="Alphabet_(computer_science)" title="wikilink">alphabet</a> 

<math display="inline" id="Mealy_machine:4">
 <semantics>
  <mi mathvariant="normal">Σ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma
  </annotation>
 </semantics>
</math>

</li>
<li>a <a href="finite_set" title="wikilink">finite set</a> called the output <a href="Alphabet_(computer_science)" title="wikilink">alphabet</a> 

<math display="inline" id="Mealy_machine:5">
 <semantics>
  <mi mathvariant="normal">Λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Lambda
  </annotation>
 </semantics>
</math>

</li>
<li>a transition <a href="function_(mathematics)" title="wikilink">function</a> 

<math display="inline" id="Mealy_machine:6">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mi>S</mi>
     <mo>×</mo>
     <mi mathvariant="normal">Σ</mi>
    </mrow>
    <mo>→</mo>
    <mi>S</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>T</ci>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <times></times>
      <ci>S</ci>
      <ci>normal-Σ</ci>
     </apply>
     <ci>S</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T:S\times\Sigma\rightarrow S
  </annotation>
 </semantics>
</math>

 mapping pairs of a state and an input symbol to the corresponding next state.</li>
<li>an output function 

<math display="inline" id="Mealy_machine:7">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mi>S</mi>
     <mo>×</mo>
     <mi mathvariant="normal">Σ</mi>
    </mrow>
    <mo>→</mo>
    <mi mathvariant="normal">Λ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>G</ci>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <times></times>
      <ci>S</ci>
      <ci>normal-Σ</ci>
     </apply>
     <ci>normal-Λ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G:S\times\Sigma\rightarrow\Lambda
  </annotation>
 </semantics>
</math>

 mapping pairs of a state and an input symbol to the corresponding output symbol.</li>
</ul>

<p>In some formulations, the transition and output functions are coalesced into a single function 

<math display="inline" id="Mealy_machine:8">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mi>S</mi>
     <mo>×</mo>
     <mi mathvariant="normal">Σ</mi>
    </mrow>
    <mo>→</mo>
    <mrow>
     <mi>S</mi>
     <mo>×</mo>
     <mi mathvariant="normal">Λ</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>T</ci>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <times></times>
      <ci>S</ci>
      <ci>normal-Σ</ci>
     </apply>
     <apply>
      <times></times>
      <ci>S</ci>
      <ci>normal-Λ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T:S\times\Sigma\rightarrow S\times\Lambda
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="comparison">Comparison</h2>
<ol>
<li>Mealy machine tend to have fewer states:
<ul>
<li>Different outputs on arcs (<em>n</em><sup>2</sup>) rather than states (<em>n</em>).</li>
</ul></li>
<li>Moore machine are safer to use:
<ul>
<li>Outputs change at clock edge (always one cycle later).</li>
<li>In Mealy machines, input change can cause output change as soon as logic is done—a big problem when two machines are interconnected – asynchronous feedback may occur if one isn't careful.</li>
</ul></li>
<li>Mealy machine react faster to inputs:
<ul>
<li>React in same cycle—don't need to wait for clock.</li>
<li>In Moore machines, more logic may be necessary to decode state into outputs—more gate delays after clock edge.</li>
</ul></li>
</ol>
<h2 id="diagram">Diagram</h2>

<p>The <a href="state_diagram" title="wikilink">state diagram</a> for a Mealy machine associates an output value with each transition edge (in contrast to the state diagram for a Moore machine, which associates an output value with each state).</p>

<p>When the input and output alphabet are both 

<math display="inline" id="Mealy_machine:9">
 <semantics>
  <mi mathvariant="normal">Σ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Σ
  </annotation>
 </semantics>
</math>

, one can also associate to a Mealy Automata an Helix <a href="directed_graph" title="wikilink">directed graph</a>.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> 

<math display="inline" id="Mealy_machine:10">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi>S</mi>
    <mi mathvariant="normal">×</mi>
    <mi mathvariant="normal">Σ</mi>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>i</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi mathvariant="normal">→</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>T</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo>,</mo>
       <mi>i</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mi>G</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo>,</mo>
       <mi>i</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <apply>
     <times></times>
     <ci>S</ci>
     <ci>normal-×</ci>
     <ci>normal-Σ</ci>
    </apply>
    <apply>
     <times></times>
     <interval closure="open">
      <ci>x</ci>
      <ci>i</ci>
     </interval>
     <ci>normal-→</ci>
     <interval closure="open">
      <apply>
       <times></times>
       <ci>T</ci>
       <interval closure="open">
        <ci>x</ci>
        <ci>i</ci>
       </interval>
      </apply>
      <apply>
       <times></times>
       <ci>G</ci>
       <interval closure="open">
        <ci>x</ci>
        <ci>i</ci>
       </interval>
      </apply>
     </interval>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (S×Σ,(x,i)→(T(x,i),G(x,i)))
  </annotation>
 </semantics>
</math>

 This graph has as vertices the couples of state and letters, every nodes are of out-degree one, and the successor of 

<math display="inline" id="Mealy_machine:11">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>x</mi>
   <mo>,</mo>
   <mi>i</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>x</ci>
    <ci>i</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x,i)
  </annotation>
 </semantics>
</math>

 is the next state of the automata and the letter that the automata output when it is instate 

<math display="inline" id="Mealy_machine:12">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 and it reads letter 

<math display="inline" id="Mealy_machine:13">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

. This graph is a union of disjoint cycles iff the automaton is bireversible.</p>
<h2 id="examples">Examples</h2>
<h3 id="simple">Simple</h3>

<p> A simple Mealy machine has one input and one output. Each transition edge is labeled with the value of the input (shown in red) and the value of the output (shown in blue). The machine starts in state <mtpl></mtpl>. (In this example, the output is the <a href="exclusive_or" title="wikilink">exclusive-or</a> of the two most-recent input values; thus, the machine implements an edge detector, outputting a one every time the input flips and a zero otherwise.)</p>
<h3 id="complex">Complex</h3>

<p>More complex Mealy machines can have multiple inputs as well as multiple outputs.</p>
<h2 id="applications">Applications</h2>

<p>Mealy machines provide a rudimentary mathematical model for cipher machines. Considering the input and output alphabet the <a href="Latin_alphabet" title="wikilink">Latin alphabet</a>, for example, then a Mealy machine can be designed that given a string of letters (a sequence of inputs) can process it into a ciphered string (a sequence of outputs). However, although one could use a Mealy model to describe the <a href="Enigma_machine" title="wikilink">Enigma</a>, the state diagram would be too complex to provide feasible means of designing complex ciphering machines.</p>

<p>Moore/Mealy machines, are DFAs that have also output at any tick of the clock. Modern CPUs, computers, cell phones, digital clocks and basic electronic devices/machines have some kind of finite state machine to control it.</p>

<p>Simple software systems, particularly ones that can be represented using regular expressions, can be modeled as Finite State Machines. There are many of such simple systems, such as vending machines or basic electronics.</p>

<p>By finding the intersection of two Finite state machines, one can design in a very simple manner concurrent systems that exchange messages for instance. For example, a traffic light is a system that consists of multiple subsystems, such as the different traffic lights, that work concurrently.</p>

<p>Some examples of applications:</p>
<ul>
<li>number classification</li>
<li>watch with timer</li>
<li>vending machine</li>
<li>traffic light</li>
<li>bar code scanner</li>
<li>gas pumps</li>
</ul>
<h2 id="summary">Summary</h2>

<p>Implementing a Moore or Mealy machine is not that hard, especially if one does not intend to minimize the circuit.</p>

<p>However, it does take practice to be able to do it reasonably fast, and is difficult to understand conceptually, at least, at first. One should trace out a few steps just to convince oneself of how it behaves. There is a subtle difference in the behavior of the implementation of a Mealy and Moore machine. Tracing out a few steps can show the differences more clearly.</p>

<p>Usually, it is harder to understand why the circuit does the right thing (i.e., implements the FSM) than it is to know how to build it. Certainly, one should devote time to both understanding why this technique works, as well as mastering the technique.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Synchronous_circuit" title="wikilink">Synchronous circuit</a></li>
<li><a href="Moore_machine" title="wikilink">Moore machine</a></li>
<li><a href="Algorithmic_state_machine" title="wikilink">Algorithmic state machine</a></li>
<li><a href="Richards_controller" title="wikilink">Richards controller</a></li>
</ul>
<h2 id="footnotes">Footnotes</h2>
<h2 id="references">References</h2>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Models_of_computation" title="wikilink">Category:Models of computation</a> <a href="Category:Automata_theory" title="wikilink">Category:Automata theory</a> <a href="Category:Digital_electronics" title="wikilink">Category:Digital electronics</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2">Akhavi et al (2012)<a href="#fnref2">↩</a></li>
</ol>
</section>
</body>
</html>
