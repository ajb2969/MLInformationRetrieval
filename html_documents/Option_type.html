<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="485">Option type</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Option type</h1>
<style>
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
<style>
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
</body></html>
<body>
<hr/>

<p>In <a href="programming_language" title="wikilink">programming languages</a> (especially <a href="functional_programming" title="wikilink">functional programming</a> languages) and <a href="type_theory" title="wikilink">type theory</a>, an <strong>option type</strong> or <strong>maybe type</strong> is a <a href="parametric_polymorphism" title="wikilink">polymorphic type</a> that represents encapsulation of an optional value; e.g. it is used as the return type of functions which may or may not return a meaningful value when they are applied. It consists of either an empty constructor (called <em>None</em> or <em>Nothing</em>), or a constructor encapsulating the original data type A (written <em>Just</em> A or <em>Some</em> A). Outside of functional programming, these are known as <a href="nullable_type" title="wikilink">nullable types</a>.</p>
<ul>
<li>In the <a href="Haskell_programming_language" title="wikilink">Haskell</a> language, the option type (called <em>Maybe</em>) is defined as <code>data Maybe a = Nothing | Just a</code>.</li>
<li>In the <a href="Idris_(programming_language)" title="wikilink">Idris</a> language, the option type is also defined as <code>data Maybe a = Nothing | Just a</code>.</li>
<li>In the <a href="Agda_(programming_language)" title="wikilink">Agda</a> language, the option type is called <code>Maybe</code> with variants <code>nothing</code> and <code>just a</code>.</li>
<li>In the <a class="uri" href="Coq" title="wikilink">Coq</a> language, the option type is defined as <code>Inductive option (A:Type) : Type :=</code><code>| Some : A -&gt; option A</code><code>| None : option A. </code>.</li>
<li>In the <a class="uri" href="OCaml" title="wikilink">OCaml</a> language, the option type is defined as <code>type 'a option = None | Some of 'a</code>.</li>
<li>In the <a href="Scala_(programming_language)" title="wikilink">Scala</a> language, the option type is defined as parameterized abstract class <code>  '.. Option[A] = if (x == null) None else Some(x)..</code>.</li>
<li>In the <a href="Standard_ML" title="wikilink">Standard ML</a> language, the option type is defined as <code>datatype 'a option = NONE | SOME of 'a</code>.</li>
<li>In the <a href="Rust_(programming_language)" title="wikilink">Rust</a> language, it is defined as <code>enum Option<t> { None, Some(T) }</t></code>.</li>
<li>In the <a href="Swift_(Apple_programming_language)" title="wikilink">Swift</a> language, it is defined as <code>enum Optional<t> { case None, Some(T) }</t></code> but is generally written as <code>T?</code> and is initialized with either a value or <code>nil</code>.</li>
<li>In the <a href="Java_(programming_language)" title="wikilink">Java</a> language since version 8, the option type is defined as parameterized final class <code>Optional<t></t></code>.</li>
<li>In the <a href="C++_(programming_language)" title="wikilink">C++</a> language proposed extensions, the option type is defined as the template class <code> template<class t=""> class optional</class></code>.</li>
</ul>

<p>In <a href="type_theory" title="wikilink">type theory</a>, it may be written as

<math display="block" id="Option_type:0">
 <semantics>
  <mrow>
   <msup>
    <mi>A</mi>
    <mi mathvariant="normal">?</mi>
   </msup>
   <mo>=</mo>
   <mrow>
    <mi>A</mi>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>A</ci>
     <ci>normal-?</ci>
    </apply>
    <apply>
     <plus></plus>
     <ci>A</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A^{?}=A+1
  </annotation>
 </semantics>
</math>

.</p>

<p>In languages that have <a href="tagged_union" title="wikilink">tagged unions</a>, as in most <a href="functional_programming" title="wikilink">functional programming</a> languages, option types can be expressed as the tagged union of a <a href="unit_type" title="wikilink">unit type</a> plus the encapsulated type.</p>

<p>In the <a href="Curry-Howard_correspondence" title="wikilink">Curry-Howard correspondence</a>, option types are related to the <a href="absorption_law" title="wikilink">annihilation law</a> for ∨: x∨1=1.</p>

<p>An option type can also be seen as a <a href="collection_(computing)" title="wikilink">collection</a> containing either a single element or zero elements.</p>
<h2 id="the-option-monad">The option monad</h2>

<p>The option type is a <a href="monads_in_functional_programming" title="wikilink">monad</a> under the following functions:</p>

<p>

<math display="block" id="Option_type:1">
 <semantics>
  <mrow>
   <mtext>return</mtext>
   <mo>:</mo>
   <mrow>
    <mi>A</mi>
    <mo>→</mo>
    <msup>
     <mi>A</mi>
     <mi mathvariant="normal">?</mi>
    </msup>
    <mo>=</mo>
    <mi>a</mi>
    <mo>↦</mo>
    <mrow>
     <mpadded width="+1.7pt">
      <mtext>Just</mtext>
     </mpadded>
     <mi>a</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <mtext>return</mtext>
    <apply>
     <and></and>
     <apply>
      <ci>normal-→</ci>
      <ci>A</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>A</ci>
       <ci>normal-?</ci>
      </apply>
     </apply>
     <apply>
      <eq></eq>
      <share href="#.cmml">
      </share>
      <ci>a</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">maps-to</csymbol>
      <share href="#.cmml">
      </share>
      <apply>
       <times></times>
       <mtext>Just</mtext>
       <ci>a</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{return}\colon A\to A^{?}=a\mapsto\text{Just}\,a
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Option_type:2">
 <semantics>
  <mrow>
   <mtext>bind</mtext>
   <mo>:</mo>
   <msup>
    <mi>A</mi>
    <mi mathvariant="normal">?</mi>
   </msup>
   <mo>→</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>A</mi>
    <mo>→</mo>
    <msup>
     <mi>B</mi>
     <mi mathvariant="normal">?</mi>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <msup>
    <mi>B</mi>
    <mi mathvariant="normal">?</mi>
   </msup>
   <mo>=</mo>
   <mi>a</mi>
   <mo>↦</mo>
   <mi>f</mi>
   <mo>↦</mo>
   <mrow>
    <mo>{</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="left">
       <mtext>Nothing</mtext>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mpadded width="+5pt">
          <mtext>if</mtext>
         </mpadded>
         <mi>a</mi>
        </mrow>
        <mo>=</mo>
        <mtext>Nothing</mtext>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="left">
       <mrow>
        <mpadded width="+1.7pt">
         <mi>f</mi>
        </mpadded>
        <msup>
         <mi>a</mi>
         <mo>′</mo>
        </msup>
       </mrow>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mpadded width="+5pt">
          <mtext>if</mtext>
         </mpadded>
         <mi>a</mi>
        </mrow>
        <mo>=</mo>
        <mrow>
         <mpadded width="+1.7pt">
          <mtext>Just</mtext>
         </mpadded>
         <msup>
          <mi>a</mi>
          <mo>′</mo>
         </msup>
        </mrow>
       </mrow>
      </mtd>
     </mtr>
    </mtable>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <mtext>bind</mtext>
    <ci>normal-:</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>A</ci>
     <ci>normal-?</ci>
    </apply>
    <ci>normal-→</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">A</csymbol>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>B</ci>
      <ci>normal-?</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>B</ci>
     <ci>normal-?</ci>
    </apply>
    <eq></eq>
    <csymbol cd="unknown">a</csymbol>
    <csymbol cd="latexml">maps-to</csymbol>
    <csymbol cd="unknown">f</csymbol>
    <csymbol cd="latexml">maps-to</csymbol>
    <apply>
     <csymbol cd="latexml">cases</csymbol>
     <mtext>Nothing</mtext>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <mtext>if</mtext>
       <ci>a</ci>
      </apply>
      <mtext>Nothing</mtext>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>a</ci>
       <ci>normal-′</ci>
      </apply>
     </apply>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <mtext>if</mtext>
       <ci>a</ci>
      </apply>
      <apply>
       <times></times>
       <mtext>Just</mtext>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>a</ci>
        <ci>normal-′</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{bind}\colon A^{?}\to(A\to B^{?})\to B^{?}=a\mapsto f\mapsto\begin{cases}%
\text{Nothing}&\text{if}\ a=\text{Nothing}\\
f\,a^{\prime}&\text{if}\ a=\text{Just}\,a^{\prime}\end{cases}
  </annotation>
 </semantics>
</math>

 We may also describe the option monad in terms of functions <em>return</em>, <em>fmap</em> and <em>join</em>, where the latter two are given by:</p>

<p>

<math display="block" id="Option_type:3">
 <semantics>
  <mrow>
   <mtext>fmap</mtext>
   <mo>:</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>A</mi>
    <mo>→</mo>
    <mi>B</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <msup>
    <mi>A</mi>
    <mi mathvariant="normal">?</mi>
   </msup>
   <mo>→</mo>
   <msup>
    <mi>B</mi>
    <mi mathvariant="normal">?</mi>
   </msup>
   <mo>=</mo>
   <mi>f</mi>
   <mo>↦</mo>
   <mi>a</mi>
   <mo>↦</mo>
   <mrow>
    <mo>{</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="left">
       <mtext>Nothing</mtext>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mpadded width="+5pt">
          <mtext>if</mtext>
         </mpadded>
         <mi>a</mi>
        </mrow>
        <mo>=</mo>
        <mtext>Nothing</mtext>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="left">
       <mrow>
        <mpadded width="+1.7pt">
         <mtext>Just</mtext>
        </mpadded>
        <mpadded width="+1.7pt">
         <mi>f</mi>
        </mpadded>
        <msup>
         <mi>a</mi>
         <mo>′</mo>
        </msup>
       </mrow>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mpadded width="+5pt">
          <mtext>if</mtext>
         </mpadded>
         <mi>a</mi>
        </mrow>
        <mo>=</mo>
        <mrow>
         <mpadded width="+1.7pt">
          <mtext>Just</mtext>
         </mpadded>
         <msup>
          <mi>a</mi>
          <mo>′</mo>
         </msup>
        </mrow>
       </mrow>
      </mtd>
     </mtr>
    </mtable>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <mtext>fmap</mtext>
    <ci>normal-:</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">A</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">B</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>A</ci>
     <ci>normal-?</ci>
    </apply>
    <ci>normal-→</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>B</ci>
     <ci>normal-?</ci>
    </apply>
    <eq></eq>
    <csymbol cd="unknown">f</csymbol>
    <csymbol cd="latexml">maps-to</csymbol>
    <csymbol cd="unknown">a</csymbol>
    <csymbol cd="latexml">maps-to</csymbol>
    <apply>
     <csymbol cd="latexml">cases</csymbol>
     <mtext>Nothing</mtext>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <mtext>if</mtext>
       <ci>a</ci>
      </apply>
      <mtext>Nothing</mtext>
     </apply>
     <apply>
      <times></times>
      <mtext>Just</mtext>
      <ci>f</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>a</ci>
       <ci>normal-′</ci>
      </apply>
     </apply>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <mtext>if</mtext>
       <ci>a</ci>
      </apply>
      <apply>
       <times></times>
       <mtext>Just</mtext>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>a</ci>
        <ci>normal-′</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{fmap}\colon(A\to B)\to A^{?}\to B^{?}=f\mapsto a\mapsto\begin{cases}%
\text{Nothing}&\text{if}\ a=\text{Nothing}\\
\text{Just}\,f\,a^{\prime}&\text{if}\ a=\text{Just}\,a^{\prime}\end{cases}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Option_type:4">
 <semantics>
  <mrow>
   <mtext>join</mtext>
   <mo>:</mo>
   <mrow>
    <mmultiscripts>
     <mi>A</mi>
     <none></none>
     <mi mathvariant="normal">?</mi>
     <none></none>
     <mi mathvariant="normal">?</mi>
    </mmultiscripts>
    <mo>→</mo>
    <msup>
     <mi>A</mi>
     <mi mathvariant="normal">?</mi>
    </msup>
    <mo>=</mo>
    <mi>a</mi>
    <mo>↦</mo>
    <mrow>
     <mo>{</mo>
     <mtable displaystyle="true">
      <mtr>
       <mtd columnalign="left">
        <mtext>Nothing</mtext>
       </mtd>
       <mtd columnalign="left">
        <mrow>
         <mrow>
          <mpadded width="+5pt">
           <mtext>if</mtext>
          </mpadded>
          <mi>a</mi>
         </mrow>
         <mo>=</mo>
         <mtext>Nothing</mtext>
        </mrow>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="left">
        <mtext>Nothing</mtext>
       </mtd>
       <mtd columnalign="left">
        <mrow>
         <mrow>
          <mpadded width="+5pt">
           <mtext>if</mtext>
          </mpadded>
          <mi>a</mi>
         </mrow>
         <mo>=</mo>
         <mrow>
          <mpadded width="+1.7pt">
           <mtext>Just</mtext>
          </mpadded>
          <mtext>Nothing</mtext>
         </mrow>
        </mrow>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="left">
        <mrow>
         <mpadded width="+1.7pt">
          <mtext>Just</mtext>
         </mpadded>
         <msup>
          <mi>a</mi>
          <mo>′</mo>
         </msup>
        </mrow>
       </mtd>
       <mtd columnalign="left">
        <mrow>
         <mrow>
          <mpadded width="+5pt">
           <mtext>if</mtext>
          </mpadded>
          <mi>a</mi>
         </mrow>
         <mo>=</mo>
         <mrow>
          <mpadded width="+1.7pt">
           <mtext>Just</mtext>
          </mpadded>
          <mpadded width="+1.7pt">
           <mtext>Just</mtext>
          </mpadded>
          <msup>
           <mi>a</mi>
           <mo>′</mo>
          </msup>
         </mrow>
        </mrow>
       </mtd>
      </mtr>
     </mtable>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <mtext>join</mtext>
    <apply>
     <and></and>
     <apply>
      <ci>normal-→</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>A</ci>
        <ci>normal-?</ci>
       </apply>
       <ci>normal-?</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>A</ci>
       <ci>normal-?</ci>
      </apply>
     </apply>
     <apply>
      <eq></eq>
      <share href="#.cmml">
      </share>
      <ci>a</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">maps-to</csymbol>
      <share href="#.cmml">
      </share>
      <apply>
       <csymbol cd="latexml">cases</csymbol>
       <mtext>Nothing</mtext>
       <apply>
        <eq></eq>
        <apply>
         <times></times>
         <mtext>if</mtext>
         <ci>a</ci>
        </apply>
        <mtext>Nothing</mtext>
       </apply>
       <mtext>Nothing</mtext>
       <apply>
        <eq></eq>
        <apply>
         <times></times>
         <mtext>if</mtext>
         <ci>a</ci>
        </apply>
        <apply>
         <times></times>
         <mtext>Just</mtext>
         <mtext>Nothing</mtext>
        </apply>
       </apply>
       <apply>
        <times></times>
        <mtext>Just</mtext>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>a</ci>
         <ci>normal-′</ci>
        </apply>
       </apply>
       <apply>
        <eq></eq>
        <apply>
         <times></times>
         <mtext>if</mtext>
         <ci>a</ci>
        </apply>
        <apply>
         <times></times>
         <mtext>Just</mtext>
         <mtext>Just</mtext>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>a</ci>
          <ci>normal-′</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{join}\colon{A^{?}}^{?}\to A^{?}=a\mapsto\begin{cases}\text{Nothing}&%
\text{if}\ a=\text{Nothing}\\
\text{Nothing}&\text{if}\ a=\text{Just}\,\text{Nothing}\\
\text{Just}\,a^{\prime}&\text{if}\ a=\text{Just}\,\text{Just}\,a^{\prime}\end{cases}
  </annotation>
 </semantics>
</math>

</p>

<p>The option monad is an additive monad: it has <em>Nothing</em> as a zero constructor and the following function as a monadic sum:</p>

<p>

<math display="block" id="Option_type:5">
 <semantics>
  <mrow>
   <mtext>mplus</mtext>
   <mo>:</mo>
   <mrow>
    <msup>
     <mi>A</mi>
     <mi mathvariant="normal">?</mi>
    </msup>
    <mo>→</mo>
    <msup>
     <mi>A</mi>
     <mi mathvariant="normal">?</mi>
    </msup>
    <mo>→</mo>
    <msup>
     <mi>A</mi>
     <mi mathvariant="normal">?</mi>
    </msup>
    <mo>=</mo>
    <msub>
     <mi>a</mi>
     <mn>1</mn>
    </msub>
    <mo>↦</mo>
    <msub>
     <mi>a</mi>
     <mn>2</mn>
    </msub>
    <mo>↦</mo>
    <mrow>
     <mo>{</mo>
     <mtable displaystyle="true">
      <mtr>
       <mtd columnalign="left">
        <mtext>Nothing</mtext>
       </mtd>
       <mtd columnalign="left">
        <mrow>
         <mrow>
          <mpadded width="+5pt">
           <mtext>if</mtext>
          </mpadded>
          <msub>
           <mi>a</mi>
           <mn>1</mn>
          </msub>
         </mrow>
         <mo>=</mo>
         <mrow>
          <mtext>Nothing</mtext>
          <mi mathvariant="italic">and</mi>
          <msub>
           <mi>a</mi>
           <mn>2</mn>
          </msub>
         </mrow>
         <mo>=</mo>
         <mtext>Nothing</mtext>
        </mrow>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="left">
        <mrow>
         <mpadded width="+1.7pt">
          <mtext>Just</mtext>
         </mpadded>
         <msubsup>
          <mi>a</mi>
          <mn>2</mn>
          <mo>′</mo>
         </msubsup>
        </mrow>
       </mtd>
       <mtd columnalign="left">
        <mrow>
         <mrow>
          <mpadded width="+5pt">
           <mtext>if</mtext>
          </mpadded>
          <msub>
           <mi>a</mi>
           <mn>1</mn>
          </msub>
         </mrow>
         <mo>=</mo>
         <mrow>
          <mtext>Nothing</mtext>
          <mi mathvariant="italic">and</mi>
          <msub>
           <mi>a</mi>
           <mn>2</mn>
          </msub>
         </mrow>
         <mo>=</mo>
         <mrow>
          <mpadded width="+1.7pt">
           <mtext>Just</mtext>
          </mpadded>
          <msubsup>
           <mi>a</mi>
           <mn>2</mn>
           <mo>′</mo>
          </msubsup>
         </mrow>
        </mrow>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="left">
        <mrow>
         <mpadded width="+1.7pt">
          <mtext>Just</mtext>
         </mpadded>
         <msubsup>
          <mi>a</mi>
          <mn>1</mn>
          <mo>′</mo>
         </msubsup>
        </mrow>
       </mtd>
       <mtd columnalign="left">
        <mrow>
         <mrow>
          <mpadded width="+5pt">
           <mtext>if</mtext>
          </mpadded>
          <msub>
           <mi>a</mi>
           <mn>1</mn>
          </msub>
         </mrow>
         <mo>=</mo>
         <mrow>
          <mpadded width="+1.7pt">
           <mtext>Just</mtext>
          </mpadded>
          <msubsup>
           <mi>a</mi>
           <mn>1</mn>
           <mo>′</mo>
          </msubsup>
         </mrow>
        </mrow>
       </mtd>
      </mtr>
     </mtable>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <mtext>mplus</mtext>
    <apply>
     <and></and>
     <apply>
      <ci>normal-→</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>A</ci>
       <ci>normal-?</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>A</ci>
       <ci>normal-?</ci>
      </apply>
     </apply>
     <apply>
      <ci>normal-→</ci>
      <share href="#.cmml">
      </share>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>A</ci>
       <ci>normal-?</ci>
      </apply>
     </apply>
     <apply>
      <eq></eq>
      <share href="#.cmml">
      </share>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">maps-to</csymbol>
      <share href="#.cmml">
      </share>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">maps-to</csymbol>
      <share href="#.cmml">
      </share>
      <apply>
       <csymbol cd="latexml">cases</csymbol>
       <mtext>Nothing</mtext>
       <apply>
        <and></and>
        <apply>
         <eq></eq>
         <apply>
          <times></times>
          <mtext>if</mtext>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>a</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
         <apply>
          <times></times>
          <mtext>Nothing</mtext>
          <ci>italic- and</ci>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>a</ci>
           <cn type="integer">2</cn>
          </apply>
         </apply>
        </apply>
        <apply>
         <eq></eq>
         <share href="#.cmml">
         </share>
         <mtext>Nothing</mtext>
        </apply>
       </apply>
       <apply>
        <times></times>
        <mtext>Just</mtext>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>a</ci>
          <ci>normal-′</ci>
         </apply>
         <cn type="integer">2</cn>
        </apply>
       </apply>
       <apply>
        <and></and>
        <apply>
         <eq></eq>
         <apply>
          <times></times>
          <mtext>if</mtext>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>a</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
         <apply>
          <times></times>
          <mtext>Nothing</mtext>
          <ci>italic- and</ci>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>a</ci>
           <cn type="integer">2</cn>
          </apply>
         </apply>
        </apply>
        <apply>
         <eq></eq>
         <share href="#.cmml">
         </share>
         <apply>
          <times></times>
          <mtext>Just</mtext>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <apply>
            <csymbol cd="ambiguous">superscript</csymbol>
            <ci>a</ci>
            <ci>normal-′</ci>
           </apply>
           <cn type="integer">2</cn>
          </apply>
         </apply>
        </apply>
       </apply>
       <apply>
        <times></times>
        <mtext>Just</mtext>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>a</ci>
          <ci>normal-′</ci>
         </apply>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <eq></eq>
        <apply>
         <times></times>
         <mtext>if</mtext>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>a</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <apply>
         <times></times>
         <mtext>Just</mtext>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>a</ci>
           <ci>normal-′</ci>
          </apply>
          <cn type="integer">1</cn>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{mplus}\colon A^{?}\to A^{?}\to A^{?}=a_{1}\mapsto a_{2}\mapsto\begin{%
cases}\text{Nothing}&\text{if}\ a_{1}=\text{Nothing}\and a_{2}=\text{Nothing}%
\\
\text{Just}\,a^{\prime}_{2}&\text{if}\ a_{1}=\text{Nothing}\and a_{2}=\text{%
Just}\,a^{\prime}_{2}\\
\text{Just}\,a^{\prime}_{1}&\text{if}\ a_{1}=\text{Just}\,a^{\prime}_{1}\end{cases}
  </annotation>
 </semantics>
</math>

</p>

<p>In fact, the resulting structure is an <a class="uri" href="idempotent" title="wikilink">idempotent</a> <a class="uri" href="monoid" title="wikilink">monoid</a>.</p>
<h2 id="examples">Examples</h2>
<h3 id="scala">Scala</h3>

<p><a href="Scala_(programming_language)" title="wikilink">Scala</a> implements Option as a parameterized type, so a variable can be an Option, accessed as follows:<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="co">// Defining variables that are Options of type Int</span>
<span class="kw">val</span> res1: Option[Int] = Some(<span class="dv">42</span>)
<span class="kw">val</span> res2: Option[Int] = None

<span class="co">// sample 1 :  This function uses pattern matching to deconstruct Options</span>
<span class="kw">def</span> <span class="fu">compute</span>(opt: Option[Int]) = opt <span class="kw">match</span> {
  <span class="kw">case</span> None =&gt; <span class="st">"No value"</span>
  <span class="kw">case</span> Some(x) =&gt; <span class="st">"The value is: "</span> + x
}

<span class="co">// sample 2 :  This function uses monad method</span>
<span class="kw">def</span> <span class="fu">compute</span>(opt: Option[Int]) = opt.<span class="fu">fold</span>(<span class="st">"No Value"</span>)(v =&gt; <span class="st">"The value is:"</span> + v )

<span class="fu">println</span>(<span class="fu">compute</span>(res1))  <span class="co">// The value is: 42</span>
<span class="fu">println</span>(<span class="fu">compute</span>(res2))  <span class="co">// No value</span></code></pre></div>

<p>There are two main ways to use an Option value. The first one, not the best, is the <a href="pattern_matching" title="wikilink">pattern matching</a> as in the first example. The second one, the best practice, is the monad method as in the second example. In this way, the program is safe as it cannot generate any exception or error (e.g. by trying to obtain the value of an <code>Option</code> variable that is equal to <code>None</code>). Therefore, it essentially works as a type-safe alternative to the null value.</p>
<h3 id="f">F#</h3>
<div class="sourceCode"><pre class="sourceCode ocaml"><code class="sourceCode ocaml">
<span class="co">(* This function uses pattern matching to deconstruct Options *)</span>
<span class="kw">let</span> compute = <span class="kw">function</span>
  | <span class="dt">None</span>   -&gt; <span class="st">"No value"</span>
  | <span class="dt">Some</span> x -&gt; sprintf <span class="st">"The value is: %d"</span> x

printfn <span class="st">"%s"</span> (compute &lt;| <span class="dt">Some</span> <span class="dv">42</span>)<span class="co">(* The value is: 42 *)</span>
printfn <span class="st">"%s"</span> (compute <span class="dt">None</span>)      <span class="co">(* No value         *)</span></code></pre></div>
<h3 id="haskell">Haskell</h3>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- This function uses pattern matching to deconstruct Maybes</span>
<span class="ot">compute ::</span> <span class="dt">Maybe</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
compute <span class="dt">Nothing</span>  <span class="fu">=</span> <span class="st">"No value"</span>
compute (<span class="dt">Just</span> x) <span class="fu">=</span> <span class="st">"The value is: "</span> <span class="fu">++</span> show x

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
    print <span class="fu">$</span> compute (<span class="dt">Just</span> <span class="dv">42</span>) <span class="co">-- The value is: 42</span>
    print <span class="fu">$</span> compute <span class="dt">Nothing</span> <span class="co">-- No value</span></code></pre></div>
<h3 id="swift">Swift</h3>
<pre><code>func compute(x: Int?) -&gt; String {
  // This function uses optional binding to deconstruct optionals
  if let y = x {
    return "The value is: \(y)"
  } else {
    return "No value"
  }
}

print(compute(42)) // The value is: 42
print(compute(nil)) // No value</code></pre>
<pre><code>func compute(x: Int?) -&gt; String {
  // This function explicitly unwraps an optional after comparing to nil
  return nil == x ? "No value" : "The value is: \(x!)"
}

print(compute(42)) // The value is: 42
print(compute(nil)) // No value</code></pre>
<pre><code>func compute(x: Int?) -&gt; String {
  // This function uses pattern matching to deconstruct optionals
  switch x {
  case .None: 
    return "No value"
  case .Some(let y): 
    return "The value is: \(y)"
  }
}

print(compute(42)) // The value is: 42
print(compute(nil)) // No value</code></pre>
<h3 id="rust">Rust</h3>

<p>In Rust you can use either pattern matching or optional binding to deconstruct the Option type:</p>
<pre><code>fn main() {
    // This function uses pattern matching to deconstruct optionals
    fn compute(x: Option<i32>) -&gt; String {
        match x {
            Some(a) =&gt; format!("The value is: {}", a),
            None    =&gt; format!("No value")
        }
    }

    println!("{}", compute(Some(42))); // The value is: 42
    println!("{}", compute(None)); // No value
}
</i32></code></pre>
<pre><code>fn main() {
    // This function uses optional binding to deconstruct optionals
    fn compute(x: Option<i32>) -&gt; String {
        if let Some(a) = x {
            format!("The value is: {}", a)
        } else {
            format!("No value")
        }
    }

    println!("{}", compute(Some(42))); // The value is: 42
    println!("{}", compute(None)); // No value
}
</i32></code></pre>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Tagged_union" title="wikilink">Tagged union</a></li>
<li><a href="Nullable_type" title="wikilink">Nullable type</a></li>
<li><a href="Null_Object_pattern" title="wikilink">Null Object pattern</a></li>
<li><a href="Sentinel_value" title="wikilink">Sentinel value</a></li>
</ul>
<h2 id="references">References</h2>
<references>
</references>

<p>"</p>

<p><a href="Category:Functional_programming" title="wikilink">Category:Functional programming</a> <a href="Category:Data_types" title="wikilink">Category:Data types</a> <a href="Category:Type_theory" title="wikilink">Category:Type theory</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
</ol>
</section>
</body>

