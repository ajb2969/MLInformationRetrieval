<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="851">Network congestion</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Network congestion</h1>
<hr/>

<p>In <a href="data_networking" title="wikilink">data networking</a> and <a href="queueing_theory" title="wikilink">queueing theory</a>, <strong>network congestion</strong> occurs when a link or node is carrying so much data that its <a href="quality_of_service" title="wikilink">quality of service</a> deteriorates. Typical effects include <a href="queueing_delay" title="wikilink">queueing delay</a>, <a href="packet_loss" title="wikilink">packet loss</a> or the <a href="blocking_probability" title="wikilink">blocking</a> of new connections. A consequence of the latter two effects is that an incremental increase in <a href="offered_load" title="wikilink">offered load</a> leads either only to a small increase in network <a class="uri" href="throughput" title="wikilink">throughput</a>, or to an actual reduction in network throughput.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>

<p><a href="Network_protocol" title="wikilink">Network protocols</a> which use aggressive <a href="Retransmission_(data_networks)" title="wikilink">retransmissions</a> to compensate for packet loss tend to keep systems in a state of network congestion, even after the initial load has been reduced to a level which would not normally have induced network congestion. Thus, networks using these protocols can exhibit two stable states under the same level of load. The stable state with low throughput is known as <strong>congestive collapse</strong>.</p>

<p>Modern networks use <a href="#Congestion_control" title="wikilink">congestion control</a> and <a href="#Avoidance" title="wikilink">congestion avoidance</a> techniques to try to avoid congestion collapse. These include: <a href="exponential_backoff" title="wikilink">exponential backoff</a> in protocols such as <a class="uri" href="802.11" title="wikilink">802.11</a> <a href="Carrier_sense_multiple_access_with_collision_avoidance" title="wikilink">CSMA/CA</a> and the original <a class="uri" href="Ethernet" title="wikilink">Ethernet</a>, <a href="sliding_window" title="wikilink">window</a> reduction in <a href="Transmission_control_protocol" title="wikilink">TCP</a>, and <a href="fair_queueing" title="wikilink">fair queueing</a> in devices such as <a href="Router_(computing)" title="wikilink">routers</a>. Another method to avoid the negative effects of network congestion is implementing priority schemes, so that some packets are transmitted with higher priority than others. Priority schemes do not solve network congestion by themselves, but they help to alleviate the effects of congestion for some services. An example of this is <a class="uri" href="802.1p" title="wikilink">802.1p</a>. A third method to avoid network congestion is the explicit allocation of network resources to specific flows. One example of this is the use of Contention-Free Transmission Opportunities (CFTXOPs) in the <a class="uri" href="ITU-T" title="wikilink">ITU-T</a> <a class="uri" href="G.hn" title="wikilink">G.hn</a> standard, which provides high-speed (up to 1 Gbit/s) <a href="local_area_network" title="wikilink">local area networking</a> over existing home wires (power lines, phone lines and coaxial cables).</p>

<p>RFC 2914 addresses the subject of congestion control in detail.</p>
<h2 id="network-capacity">Network capacity</h2>

<p>A fundamental problem is that all network resources are limited, including <a href="router_(computing)" title="wikilink">router</a> processing time and link <a class="uri" href="throughput" title="wikilink">throughput</a>.</p>

<p>For example:</p>
<ul>
<li>A <a href="wireless_LAN" title="wikilink">wireless LAN</a> is easily filled by a single <a href="personal_computer" title="wikilink">personal computer</a></li>
<li>Even on fast <a href="computer_network" title="wikilink">computer networks</a> (e.g. <a href="Gigabit_Ethernet" title="wikilink">Gigabit Ethernet</a>), the backbone can easily be congested by a small number of servers and client PCs</li>
<li>The aggregate transmission from <a href="Peer-to-peer" title="wikilink">P2P</a> networks have no problem filling an uplink or some other network bottleneck</li>
<li><a href="Denial-of-service_attack" title="wikilink">Denial-of-service attacks</a> by <a href="botnet" title="wikilink">botnets</a> are capable of filling even the largest <a href="Internet_backbone" title="wikilink">Internet backbone</a> network links, generating large-scale network congestion</li>
<li>In <a class="uri" href="telephone" title="wikilink">telephone</a> networks (particularly <a href="mobile_phone" title="wikilink">mobile phones</a>), a <a href="mass_call_event" title="wikilink">mass call event</a> can overwhelm digital <a href="telephone_circuit" title="wikilink">telephone circuits</a></li>
</ul>
<h2 id="congestive-collapse">Congestive collapse</h2>

<p><strong>Congestive collapse</strong> (or <strong>congestion collapse</strong>) is a condition that a <a href="Packet_Switched_Core_Network" title="wikilink">packet-switched computer network</a> can reach, when little or no useful communication is happening due to congestion. Congestion collapse generally occurs at "choke points" in the network, where the total incoming traffic to a node exceeds the outgoing bandwidth. Connection points between a <a href="local_area_network" title="wikilink">local area network</a> and a <a href="wide_area_network" title="wikilink">wide area network</a> are the most likely choke points.</p>

<p>When a network is in such a condition, it has settled (under overload) into a stable state where traffic demand is high but little useful throughput is available, and there are high levels of <a href="packet_(information_technology)" title="wikilink">packet</a> <a href="Network_delay" title="wikilink">delay</a> and loss (caused by routers discarding packets because their output <a href="Queue_(data_structure)" title="wikilink">queues</a> are too full) and general <a href="quality_of_service" title="wikilink">quality of service</a> is extremely poor.</p>

<p>Congestion collapse was identified as a possible problem as far back as 1984, for example in RFC 896, dated January 6, 1984. It was first observed on the early Internet in October 1986, when the <a class="uri" href="NSFnet" title="wikilink">NSFnet</a> phase-I backbone dropped three orders of magnitude from its capacity of 32 kbit/s to 40 bit/s, and this continued to occur until end nodes started implementing <a href="Van_Jacobson" title="wikilink">Van Jacobson</a>'s <a href="congestion_control" title="wikilink">congestion control</a> between 1987 and 1988.</p>

<p>When more <a href="Packet_(information_technology)" title="wikilink">packets</a> were sent than could be handled by intermediate routers, the intermediate routers discarded many packets, expecting the end points of the network to retransmit the information. However, early TCP implementations had very bad retransmission behaviour. When this packet loss occurred, the end points sent <em>extra</em> packets that repeated the information lost, doubling the data rate sent, exactly the opposite of what should be done during congestion. This pushed the entire network into a 'congestion collapse' where most packets were lost and the resultant throughput was negligible.</p>
<h2 id="congestion-control">Congestion control</h2>

<p><strong>Congestion control</strong> concerns controlling traffic entry into a <a href="telecommunications_network" title="wikilink">telecommunications network</a>, so as to avoid <a href="congestive_collapse" title="wikilink">congestive collapse</a> by attempting to avoid oversubscription of any of the processing or <a href="data_link" title="wikilink">link</a> capabilities of the intermediate nodes and networks and taking resource reducing steps, such as reducing the rate of sending <a href="packet_(information_technology)" title="wikilink">packets</a>. It should not be confused with <a href="flow_control_(data)" title="wikilink">flow control</a>, which prevents the sender from overwhelming the receiver.</p>
<h3 id="theory-of-congestion-control">Theory of congestion control</h3>

<p>The modern theory of congestion control was pioneered by <a href="Frank_Kelly_(professor)" title="wikilink">Frank Kelly</a>, who applied <a href="microeconomic_theory" title="wikilink">microeconomic theory</a> and <a href="convex_optimization" title="wikilink">convex optimization</a> theory to describe how individuals controlling their own rates can interact to achieve an "optimal" network-wide rate allocation.</p>

<p>Examples of "optimal" rate allocation are <a href="Max-min_fairness" title="wikilink">max-min fair allocation</a> and Kelly's suggestion of <a href="proportional_fairness" title="wikilink">proportional fair allocation</a>, although many others are possible.</p>

<p>The mathematical expression for optimal rate allocation is as follows. Let 

<math display="inline" id="Network_congestion:0">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i}
  </annotation>
 </semantics>
</math>

 be the rate of flow 

<math display="inline" id="Network_congestion:1">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Network_congestion:2">
 <semantics>
  <msub>
   <mi>C</mi>
   <mi>l</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>C</ci>
    <ci>l</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{l}
  </annotation>
 </semantics>
</math>

 be the capacity of link 

<math display="inline" id="Network_congestion:3">
 <semantics>
  <mi>l</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>l</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   l
  </annotation>
 </semantics>
</math>


, and 

<math display="inline" id="Network_congestion:4">
 <semantics>
  <msub>
   <mi>r</mi>
   <mrow>
    <mi>l</mi>
    <mi>i</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>r</ci>
    <apply>
     <times></times>
     <ci>l</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r_{li}
  </annotation>
 </semantics>
</math>

 be 1 if flow 

<math display="inline" id="Network_congestion:5">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

 uses link 

<math display="inline" id="Network_congestion:6">
 <semantics>
  <mi>l</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>l</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   l
  </annotation>
 </semantics>
</math>

 and 0 otherwise. Let 

<math display="inline" id="Network_congestion:7">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Network_congestion:8">
 <semantics>
  <mi>c</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>c</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c
  </annotation>
 </semantics>
</math>


 and 

<math display="inline" id="Network_congestion:9">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

 be the corresponding vectors and matrix. Let 

<math display="inline" id="Network_congestion:10">
 <semantics>
  <mrow>
   <mi>U</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>U</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U(x)
  </annotation>
 </semantics>
</math>

 be an increasing, strictly <a href="concave_function" title="wikilink">concave</a> function, called the <a class="uri" href="utility" title="wikilink">utility</a>, which measures how much benefit a user obtains by transmitting at rate 

<math display="inline" id="Network_congestion:11">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

. The optimal rate allocation then satisfies</p>

<p>

<math display="block" id="Network_congestion:12">
 <semantics>
  <mrow>
   <munder>
    <mi>max</mi>
    <mi>x</mi>
   </munder>
   <mrow>
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mi>i</mi>
    </munder>
    <mrow>
     <mi>U</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mi>i</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <max></max>
     <ci>x</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <ci>i</ci>
     </apply>
     <apply>
      <times></times>
      <ci>U</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \max\limits_{x}\sum_{i}U(x_{i})
  </annotation>
 </semantics>
</math>

</p>
<dl>
<dd>such that 

<math display="inline" id="Network_congestion:13">
 <semantics>
  <mrow>
   <mrow>
    <mi>R</mi>
    <mi>x</mi>
   </mrow>
   <mo>≤</mo>
   <mi>c</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <times></times>
     <ci>R</ci>
     <ci>x</ci>
    </apply>
    <ci>c</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Rx\leq c
  </annotation>
 </semantics>
</math>



</dd>
</dl>

<p>The <a href="Lagrange_duality" title="wikilink">Lagrange dual</a> of this problem decouples, so that each flow sets its own rate, based only on a "price" signalled by the network. Each link capacity imposes a constraint, which gives rise to a Lagrange multiplier, 

<math display="inline" id="Network_congestion:14">
 <semantics>
  <msub>
   <mi>p</mi>
   <mi>l</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>p</ci>
    <ci>l</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{l}
  </annotation>
 </semantics>
</math>

. The sum of these <a href="Lagrange_multiplier" title="wikilink">Lagrange multipliers</a>, 

<math display="inline" id="Network_congestion:15">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>y</mi>
     <mi>i</mi>
    </msub>
    <mo>=</mo>
    <mrow>
     <msub>
      <mo largeop="true" symmetric="true">∑</mo>
      <mi>l</mi>
     </msub>
     <mrow>
      <msub>
       <mi>p</mi>
       <mi>l</mi>
      </msub>
      <msub>
       <mi>r</mi>
       <mrow>
        <mi>l</mi>
        <mi>i</mi>
       </mrow>
      </msub>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <ci>l</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <ci>l</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>r</ci>
       <apply>
        <times></times>
        <ci>l</ci>
        <ci>i</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{i}=\sum_{l}p_{l}r_{li},
  </annotation>
 </semantics>
</math>

 is the price to which the flow responds.</p>

<p>Congestion control then becomes a distributed optimisation algorithm for solving the above problem. Many current congestion control algorithms can be modelled in this framework, with 

<math display="inline" id="Network_congestion:16">
 <semantics>
  <msub>
   <mi>p</mi>
   <mi>l</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>p</ci>
    <ci>l</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{l}
  </annotation>
 </semantics>
</math>

 being either the loss probability or the queueing delay at link 

<math display="inline" id="Network_congestion:17">
 <semantics>
  <mi>l</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>l</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   l
  </annotation>
 </semantics>
</math>

.</p>

<p>A major weakness of this model is that it assumes all flows observe the same price, while sliding window flow control causes "burstiness" which causes different flows to observe different loss or delay at a given link.</p>
<h3 id="classification-of-congestion-control-algorithms">Classification of congestion control algorithms</h3>

<p>There are many ways to classify congestion control algorithms:</p>
<ul>
<li>By the type and amount of feedback received from the network: Loss; delay; single-bit or multi-bit explicit signals</li>
<li>By incremental deployability on the current Internet: Only sender needs modification; sender and receiver need modification; only router needs modification; sender, receiver and routers need modification.</li>
<li>By the aspect of performance it aims to improve: high bandwidth-delay product networks; lossy links; fairness; advantage to short flows; variable-rate links</li>
<li>By the fairness criterion it uses: max-min, proportional, "minimum potential delay"</li>
</ul>
<h2 id="mitigation">Mitigation</h2>

<p>A couple of mechanisms have been invented to prevent network congestion or to deal with a network collapse:</p>
<ul>
<li><a href="Network_scheduler" title="wikilink">Network scheduler</a> a program in <a href="Router_(computing)" title="wikilink">routers</a> to do <a href="Active_Queue_Management" title="wikilink">Active Queue Management</a> (that is, the arbitrary reorder or drop of network packets under overload)</li>
<li><a href="Explicit_Congestion_Notification" title="wikilink">Explicit Congestion Notification</a> an extension to the IP and TCP communications protocol, which adds a flow control mechanism upon which both ends react appropriately</li>
<li><a href="TCP_congestion-avoidance_algorithm" title="wikilink">TCP congestion-avoidance algorithm</a> several implementations of efforts to deal with network congestion</li>
</ul>

<p>The correct end point behavior is usually still to repeat dropped information, but progressively slow the rate that information is repeated. Provided all end points do this, the congestion lifts and good use of the network occurs, and the end points all get a fair share of the available bandwidth. Other strategies such as <a class="uri" href="slow-start" title="wikilink">slow-start</a> ensure that new connections don't overwhelm the router before the congestion detection can kick in.</p>

<p>The most common router mechanisms used to prevent congestive collapses are <a href="fair_queuing" title="wikilink">fair queuing</a> and other <a href="scheduling_algorithms" title="wikilink">scheduling algorithms</a>, and <a href="random_early_detection" title="wikilink">random early detection</a>, or RED, where packets are randomly dropped proactively triggering the end points to slow transmission before congestion collapse actually occurs. Fair queuing is most useful in routers at choke points with a small number of connections passing through them. Larger routers must rely on RED.</p>

<p>Some end-to-end protocols are better behaved under congested conditions than others. <a href="Transmission_control_protocol" title="wikilink">TCP</a> is perhaps the best behaved. The first TCP implementations to handle congestion well were developed in 1984, but it was not until <a href="Van_Jacobson" title="wikilink">Van Jacobson</a>'s inclusion of an open source solution in the Berkeley Standard Distribution UNIX ("<a class="uri" href="BSD" title="wikilink">BSD</a>") in 1988 that good TCP implementations became widespread.</p>

<p><a href="User_Datagram_Protocol" title="wikilink">UDP</a> does not, in itself, have any congestion control mechanism. Protocols built atop UDP must handle congestion in their own way. Protocols atop UDP which transmit at a fixed rate, independent of congestion, can be troublesome. Real-time streaming protocols, including many <a href="Voice_over_IP" title="wikilink">Voice over IP</a> protocols, have this property. Thus, special measures, such as <a href="quality_of_service" title="wikilink">quality-of-service</a> routing, must be taken to keep packets from being dropped from streams.</p>

<p>In general, congestion in pure datagram networks must be kept out at the periphery of the network, where the mechanisms described above can handle it. Congestion in the <a href="Internet_backbone" title="wikilink">Internet backbone</a> is very difficult to deal with. Fortunately, cheap <a class="uri" href="fiber-optic" title="wikilink">fiber-optic</a> lines have reduced costs in the Internet backbone. The backbone can thus be provisioned with enough bandwidth to keep congestion at the periphery.</p>
<h3 id="practical-network-congestion-avoidance">Practical network congestion avoidance</h3>

<p>Implementations of connection-oriented <a href="communications_protocol" title="wikilink">protocols</a>, such as the widely used <a href="transmission_control_protocol" title="wikilink">TCP</a> protocol, generally watch for packet errors, losses, or delays (see <a href="Quality_of_Service" title="wikilink">Quality of Service</a>) in order to adjust the transmit speed. There are many different network congestion avoidance processes, since there are a number of different trade-offs available.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>
<h3 id="tcpip-congestion-avoidance">TCP/IP congestion avoidance</h3>

<p>The <a href="TCP_congestion_avoidance_algorithm" title="wikilink">TCP congestion avoidance algorithm</a> is the primary basis for <a href="congestion_control" title="wikilink">congestion control</a> in the Internet.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a><a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a><a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a><a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a><a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>

<p>Problems occur when many concurrent TCP flows are experiencing <a href="Computer_port_(software)" title="wikilink">port queue buffer</a> <a href="tail-drop" title="wikilink">tail-drops</a>. Then TCP's automatic congestion avoidance is not enough. All flows that experience port queue buffer tail-drop will begin a TCP retrain at the same moment – this is called <a href="TCP_global_synchronization" title="wikilink">TCP global synchronization</a>.</p>
<h3 id="active-queue-management-aqm">Active queue management (AQM)</h3>

<p><a href="Active_queue_management" title="wikilink">Active queue management</a> (AQM) is the reorder or drop of network packets inside a transmit buffer that is associated with a <a href="network_interface_controller" title="wikilink">network interface controller</a> (NIC). This task is performed by the <a href="network_scheduler" title="wikilink">network scheduler</a>, which for this purpose uses various algorithms described below.</p>
<h4 id="random-early-detection">Random early detection</h4>

<p>One solution is to use <a href="random_early_detection" title="wikilink">random early detection</a> (RED) on the network equipment's <a href="Computer_port_(software)" title="wikilink">port queue buffer</a>.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a><a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> On <a href="computer_networking_device" title="wikilink">network equipment</a> ports with more than one queue buffer, <a href="weighted_random_early_detection" title="wikilink">weighted random early detection</a> (WRED) could be used if available.</p>

<p>RED indirectly signals to sender and receiver by deleting some packets, e.g. when the average queue buffer lengths are more than e.g. 50% (lower threshold) filled and deletes <a href="Linear" title="wikilink">linearly more</a> or (better according to paper) <a href="Cubic_function" title="wikilink">cubical more</a> packets,<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> up to e.g. 100% (higher threshold). The average queue buffer lengths are computed over 1 second at a time.</p>
<h4 id="robust-random-early-detection-rred">Robust random early detection (RRED)</h4>

<p>The <a href="robust_random_early_detection" title="wikilink">robust random early detection</a> (RRED) algorithm was proposed to improve the TCP throughput against denial-of-service (DoS) attacks, particularly low-rate denial-of-service (LDoS) attacks. Experiments have confirmed<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> that the existing RED-like algorithms are notably vulnerable under Low-rate Denial-of-Service (LDoS) attacks due to the oscillating TCP queue size caused by the attacks.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> RRED algorithm can significantly improve the performance of TCP under Low-rate Denial-of-Service attacks.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a></p>
<h4 id="flowbased-redwred">Flowbased-RED/WRED</h4>

<p>Some network equipment are equipped with ports that can follow and measure each flow (<strong>flowbased-RED/WRED</strong>) and are hereby able to signal to a too big bandwidth flow according to some QoS policy. A policy could divide the bandwidth among all flows by some criteria.</p>
<h4 id="explicit-congestion-notification-ecn">Explicit Congestion Notification (ECN)</h4>

<p>Another approach is to use <a href="Internet_Protocol" title="wikilink">IP</a> <a href="Explicit_Congestion_Notification" title="wikilink">Explicit Congestion Notification</a> (ECN).<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a> ECN is only used when the two hosts signal that they want to use it. With this method, a protocol bit is used to signal explicit congestion. This is better than the indirect packet delete congestion notification performed by the RED/WRED algorithms, but it requires explicit support by both hosts to be effective.<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a> Some outdated or buggy <a href="network_equipment" title="wikilink">network equipment</a> drops packets with the ECN bit set, rather than ignoring the bit. <a href="Sally_Floyd" title="wikilink">Sally Floyd</a>, one of the authors of ECN has published detailed information on the status of ECN, including the version required for <a href="Cisco_IOS" title="wikilink">Cisco IOS</a>.<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a></p>

<p>When a router receives a packet marked as ECN capable and anticipates (using RED) congestion, it sets the ECN flag notifying the sender of congestion. The sender should respond by decreasing its transmission bandwidth, e.g., by decreasing the TCP window size (sending rate) or by other means.</p>
<h4 id="cisco-aqm-dynamic-buffer-limiting-dbl">Cisco AQM: Dynamic buffer limiting (DBL)</h4>

<p><a href="Cisco_Systems" title="wikilink">Cisco Systems</a> has taken a step further in the Catalyst 4000 series with engine IV and V. Engine IV and V has the capability to classify all flows as <em>aggressive</em> (bad) or <em>adaptive</em> (good). It ensures that no flows fill the port queues for a long time. <strong>DBL</strong> can utilize <strong>IP ECN</strong> instead of packet-delete-signalling.<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a><a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a></p>
<h4 id="tcp-window-shaping">TCP window shaping</h4>

<p>Congestion avoidance can also efficiently be achieved by reducing the amount of traffic flowing into a network. When an application requests a large file, graphic or web page, it usually advertises a "window" of between 32K and 64K. This results in the server sending a full window of data (assuming the file is larger than the window). When there are many applications simultaneously requesting downloads, this data creates a congestion point at an upstream provider by flooding the queue much faster than it can be emptied. By using a device to reduce the window advertisement, the remote servers will send less data, thus reducing the congestion and allowing traffic to flow more freely. This technique can reduce congestion in a network by a factor of 40.</p>
<h4 id="backward-ecn-becn">Backward ECN (BECN)</h4>

<p><em>Backward ECN</em> (BECN) is another proposed network congestion mechanism. It uses <a href="ICMP_source_quench" title="wikilink">ICMP source quench</a> messages as an already existing IP signalling mechanism to implement a basic ECN mechanism for IP networks, keeping the congestion notifications at the IP level and requiring no negotiation between network endpoints. Effective congestion notifications can be propagated to transport layer protocols, such as TCP and UDP, for the appropriate adjustments in their operations.<a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a></p>
<h3 id="side-effects-of-congestive-collapse-avoidance">Side effects of congestive collapse avoidance</h3>
<h4 id="radio-links">Radio links</h4>

<p>The protocols that avoid congestive collapse are often based on the idea that data loss on the Internet is caused by congestion. This is true in nearly all cases; errors during transmission are rare on today's fiber-based Internet. However, this causes <a class="uri" href="WiFi" title="wikilink">WiFi</a>, <a class="uri" href="3G" title="wikilink">3G</a> or other networks with a radio layer to have poor throughput in some cases since wireless networks are susceptible to data loss due to interference. The TCP connections running over a radio based <a href="physical_layer" title="wikilink">physical layer</a> see the data loss and tend to believe that congestion is occurring when it isn't and erroneously reduce the data rate sent.</p>
<h4 id="short-lived-connections">Short-lived connections</h4>

<p>The slow-start protocol performs badly for short-lived connections. Older <a href="web_browser" title="wikilink">web browsers</a> would create many consecutive short-lived connections to the web server, and would open and close the connection for each file requested. This kept most connections in the slow start mode, which resulted in poor response time.</p>

<p>To avoid this problem, modern browsers either open multiple connections simultaneously or <a href="HTTP_persistent_connections" title="wikilink">reuse one connection</a> for all files requested from a particular web server. However, the initial performance can be poor, and many connections never get out of the slow-start regime, significantly increasing latency.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Bandwidth_management" title="wikilink">Bandwidth management</a></li>
<li><a class="uri" href="Bufferbloat" title="wikilink">Bufferbloat</a></li>
<li><a href="Cascading_failure" title="wikilink">Cascading failure</a></li>
<li><a href="Choke_exchange" title="wikilink">Choke exchange</a></li>
<li><a href="Erlang_unit" title="wikilink">Erlang unit</a></li>
<li><a href="Max-min_fairness" title="wikilink">Max-min fairness</a></li>
<li><a href="Sorcerer's_Apprentice_Syndrome" title="wikilink">Sorcerer's Apprentice Syndrome</a></li>
<li><a href="TCP_congestion_avoidance_algorithm" title="wikilink">TCP congestion avoidance algorithm</a></li>
<li><a href="Teletraffic_engineering" title="wikilink">Teletraffic engineering</a></li>
<li><a href="Thrashing_(computer_science)" title="wikilink">Thrashing</a></li>
<li><a href="Traffic_shaping" title="wikilink">Traffic shaping</a></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li>"Deploying IP and MPLS QoS for Multiservice Networks: Theory and Practice" by John Evans, Clarence Filsfils (Morgan Kaufmann, 2007, ISBN 0-12-370549-5)</li>
</ul>
<references>
</references>
<ul>
<li><a href="http://tools.ietf.org/html/rfc2914">RFC 2914</a> - Congestion Control Principles, Sally Floyd, September, 2000</li>
<li><a href="http://tools.ietf.org/html/rfc896">RFC 896</a> - "Congestion Control in IP/TCP", John Nagle, 6 January 1984</li>
<li>Introduction to <em><a href="http://ee.lbl.gov/papers/congavoid.pdf">Congestion Avoidance and Control</a></em>, Van Jacobson and Michael J. Karels, November, 1988</li>
</ul>
<h2 id="books">Books</h2>
<ul>
<li>"Deploying IP and MPLS QoS for Multiservice Networks: Theory and Practice" by John Evans, Clarence Filsfils (Morgan Kaufmann, 2007, ISBN 0-12-370549-5)</li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li>Nagle, J. RFC 896: <em>Congestion control in IP/TCP internetworks</em> (1984)</li>
<li>Floyd, S. RFC 2914: <em>Congestion control principles</em> (2000)</li>
<li>Floyd, S. and K. Fall, <em><a href="http://www.aciri.org/floyd/end2end-paper.html">Promoting the Use of End-to-End Congestion Control in the Internet</a></em> (IEEE/ACM Transactions on Networking, August 1999)</li>
<li>Sally Floyd, <em><a href="http://www.ima.umn.edu/talks/workshops/10-22-24.99/floyd/floyd.pdf">On the Evolution of End-to-end Congestion Control in the Internet: An Idiosyncratic View</a></em> (IMA Workshop on Scaling Phenomena in Communication Networks, October 1999) (<em><a href="Portable_Document_Format" title="wikilink">pdf</a> format</em>)</li>
<li><a href="http://www.linktionary.com/q/queuing.html">Linktionary term: Queuing</a></li>
<li><a href="http://www.cse.wustl.edu/~jain/papers.html">Pierre-Francois Quet, Sriram Chellappan, Arjan Durresi, Mukundan Sridharan, Hitay Ozbay, Raj Jain, " Guidelines for optimizing Multi-Level ECN, using fluid flow based TCP model"</a></li>
<li><a href="http://www.cs.washington.edu/homes/ratul/red-pd/">Sally Floyd, Ratul Mahajan, David Wetherall: RED-PD: RED with Preferential Dropping</a></li>
<li><a href="http://code.google.com/p/guduz/">A Generic Simple RED Simulator for educational purposes by Mehmet Suzen</a></li>
<li><a href="http://utopia.duth.gr/~emamatas/jie2007.pdf">Approaches to Congestion Control in Packet Networks</a></li>
<li><a href="http://www.ecse.rpi.edu/Homepages/shivkuma/research/cong-papers.html">Papers in Congestion Control</a></li>
<li><a href="http://www.icir.org/floyd/red.html">Random Early Detection Homepage</a></li>
<li><a href="http://www.icir.org/floyd/ecn.html">Explicit Congestion Notification Homepage</a></li>
<li><a href="http://www.icir.org/tfrc/">TFRC Homepage</a></li>
<li><a href="http://www.ccs.neu.edu/home/ladrian/abstract/aimdfc.html">AIMD-FC Homepage</a></li>
<li>[<a class="uri" href="http://www.visualland.net/tcp_histrory.php?simu=tcp_fast_recovery&amp;protocol">http://www.visualland.net/tcp_histrory.php?simu=tcp_fast_recovery&amp;protocol;</a>;=TCP&amp;title;=5.%20Fast%20recovery&amp;ctype;=1 TCP congestion control simulation: Fast recovery]</li>
<li><a href="http://sites.google.com/site/cwzhangres/home/posts/recentpublicationsinlow-ratedosattacks">Recent Publications in low-rate denial-of-service (DoS) attacks</a></li>
</ul>

<p><a class="uri" href="de:Überlastkontrolle" title="wikilink">de:Überlastkontrolle</a>"</p>

<p><a href="Category:Network_performance" title="wikilink">Category:Network performance</a> <a class="uri" href="Category:Teletraffic" title="wikilink">Category:Teletraffic</a> <a href="Category:Transport_layer_protocols" title="wikilink">Category:Transport layer protocols</a> <a href="Category:Technological_problems" title="wikilink">Category:Technological problems</a> <a href="Category:Packets_(information_technology)" title="wikilink">Category:Packets (information technology)</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">(Al-Bahadili, 2012, p. 282) Al-Bahadili, H. (2012). [<a class="uri" href="http://books.google.com/books?id=uNlplf2C03QC&amp;lpg">http://books.google.com/books?id=uNlplf2C03QC&amp;lpg;</a>;=PA282&amp;dq;=network%20congestion%20occurs%20when%20a%20link%20or%20node%20is%20carrying%20so%20much%20data%20that%20its%20quality%20of%20service%20deteriorates.&amp;pg;=PA282#v=onepage&amp;q;=network%20congestion%20occurs%20when%20a%20link%20or%20node%20is%20carrying%20so%20much%20data%20that%20its%20quality%20of%20service%20deteriorates.&amp;f;=false Simulation in computer network design and modeling: Use and analysis]. Hershey, PA: IGI Global.<a href="#fnref1">↩</a></li>
<li id="fn2"><a href="http://citeseer.ist.psu.edu/lee00tcp.html">TCP Tunnels: Avoiding Congestion Collapse (2000)</a><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="Van_Jacobson" title="wikilink">Van Jacobson</a>, <a href="Michael_J._Karels" title="wikilink">Michael J. Karels</a>. <a href="http://citeseer.ist.psu.edu/484335.html">Congestion Avoidance and Control</a> (1988). <em>Proceedings of the Sigcomm '88 Symposium</em>, vol.18(4): pp.314–329. Stanford, CA. August, 1988. This paper originated many of the congestion avoidance algorithms used in TCP/IP.<a href="#fnref3">↩</a></li>
<li id="fn4">RFC 2001 - TCP Slow Start, Congestion Avoidance, Fast Retransmit, and Fast Recovery Algorithms<a href="#fnref4">↩</a></li>
<li id="fn5">RFC 2581 - TCP Congestion Control<a href="#fnref5">↩</a></li>
<li id="fn6">RFC 3390 - TCP Increasing TCP's Initial Window<a href="#fnref6">↩</a></li>
<li id="fn7"><a href="http://www.eventhelix.com/RealtimeMantra/Networking/TCP_Congestion_Avoidance.pdf">TCP Congestion Avoidance Explained via a Sequence Diagram</a><a href="#fnref7">↩</a></li>
<li id="fn8"><a href="http://www.icir.org/floyd/red.html">Sally Floyd: RED (Random Early Detection) Queue Management</a><a href="#fnref8">↩</a></li>
<li id="fn9">Sally Floyd, Van Jacobson. <a href="http://citeseer.ist.psu.edu/462978.html">Random Early Detection Gateways for Congestion Avoidance</a> (1993). <em>IEEE/ACM Transactions on Networking</em>, vol.1(4): pp.397–413. Invented Random Early Detection (RED) gateways.<a href="#fnref9">↩</a></li>
<li id="fn10"><a href="http://www.ist-mobydick.org/publications/aqm_iscc2003.pdf">An Analytical RED Function Design Guaranteeing Stable System Behavior</a> Quote: "...The advantage of this function lies not only in avoiding heavy oscillations but also in avoiding link under-utilization at low loads. The applicability of the derived function is independent of the load range, no parameters are to be adjusted. Compared to the original linear drop function applicability is extended by far...Our example with realistic system parameters gives an approximation function of the cubic of the queue size..."<a href="#fnref10">↩</a></li>
<li id="fn11"><a href="#fnref11">↩</a></li>
<li id="fn12">Changwang Zhang, Jianping Yin, Zhiping Cai, and Weifeng Chen, <a href="http://sites.google.com/site/cwzhangres/home/files/RREDRobustREDAlgorithmtoCounterLow-rateDenial-of-ServiceAttacks.pdf?attredirects=0">RRED: Robust RED Algorithm to Counter Low-rate Denial-of-Service Attacks</a>, IEEE Communications Letters, vol. 14, pp. 489-491, 2010. <a href="http://ieeexplore.ieee.org/xpl/freeabs_all.jsp?arnumber=5456075">Ref</a><a href="#fnref12">↩</a></li>
<li id="fn13"></li>
<li id="fn14">RFC 3168 - The Addition of Explicit Congestion Notification (ECN) to IP<a href="#fnref14">↩</a></li>
<li id="fn15"><a href="http://citeseer.ist.psu.edu/bagal99comparative.html">Comparative study of RED, ECN and TCP Rate Control (1999)</a><a href="#fnref15">↩</a></li>
<li id="fn16"></li>
<li id="fn17"><a href="http://www.cisco.com/univercd/cc/td/doc/product/lan/cat4000/12_1_19/config/qos.htm#1271743">Active Queue Management</a><a href="#fnref17">↩</a></li>
<li id="fn18"><a href="http://www.cisco.com/univercd/cc/td/doc/product/lan/cat4000/12_1_19/config/qos.htm#1271759">Enabling Dynamic Buffer Limiting</a><a href="#fnref18">↩</a></li>
<li id="fn19"><a href="http://tools.ietf.org/html/draft-salim-jhsbnns-ecn-00">A proposal for Backward ECN for the Internet Protocol</a><a href="#fnref19">↩</a></li>
</ol>
</section>
</body>
</html>
