<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1410">Method of analytic tableaux</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Method of analytic tableaux</h1>
<hr/>

<p> In <a href="proof_theory" title="wikilink">proof theory</a>, the <strong>semantic tableau</strong> (; singular: <em>tableau</em>; plural: <em>tableaux</em>), also called <strong>truth tree</strong>, is a <a href="decision_procedure" title="wikilink">decision procedure</a> for <a href="sentential_logic" title="wikilink">sentential</a> and related logics, and a <a href="proof_procedure" title="wikilink">proof procedure</a> for formulas of <a href="first-order_logic" title="wikilink">first-order logic</a>. The tableau method can also determine the <a class="uri" href="satisfiability" title="wikilink">satisfiability</a> of finite sets of <a href="formula" title="wikilink">formulas</a> of various logics. It is the most popular <a href="proof_procedure" title="wikilink">proof procedure</a> for <a href="modal_logic" title="wikilink">modal logics</a> (Girle 2000). The method of semantic tableaux was invented by the Dutch logician <a href="Evert_Willem_Beth" title="wikilink">Evert Willem Beth</a> (Beth 1955) and simplified, for classical logic, by <a href="Raymond_Smullyan" title="wikilink">Raymond Smullyan</a> (Smullyan 1968, 1995). It is Smullyan's simplification, "one-sided tableaux", that is described below. Smullyan's method has been generalized to arbitrary many-valued propositional and first-order logics by <a href="Walter_Carnielli" title="wikilink">Walter Carnielli</a> (Carnielli 1987).<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> Tableaux can be intuitively seen as sequent systems upside-down. This symmetrical relation between tableaux and <a href="Sequent_calculus" title="wikilink">sequent systems</a> was formally established in (Carnielli 1991).<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>

<p>An <strong>analytic tableau</strong> has, for each node, a subformula of the formula at the origin. In other words, it is a tableau satisfying the subformula property.</p>
<h2 id="introduction">Introduction</h2>

<p>For refutation tableaux, the objective is to show that the negation of a formula cannot be satisfied. There are rules for handling each of the usual <a href="logical_connective" title="wikilink">connectives</a>, starting with the main connective. In many cases, applying these rules causes the subtableau to divide into two. <a href="Quantifier_(logic)" title="wikilink">Quantifiers</a> are instantiated. If any branch of a tableau leads to an evident <a class="uri" href="contradiction" title="wikilink">contradiction</a>, the branch <em>closes</em>. If all branches close, the proof is complete and the original formula is a <a href="logical_truth" title="wikilink">logical truth</a>.</p>

<p>Although the fundamental idea behind the <strong>analytic tableau method</strong> is derived from the <a href="cut-elimination_theorem" title="wikilink">cut-elimination theorem</a> of <a href="structural_proof_theory" title="wikilink">structural proof theory</a>, the origins of tableau calculi lie in the meaning (or <a class="uri" href="semantics" title="wikilink">semantics</a>) of the logical connectives, as the connection with <a href="proof_theory" title="wikilink">proof theory</a> was made only in recent decades.</p>

<p>More specifically, a tableau calculus consists of a finite collection of rules with each rule specifying how to break down one logical connective into its constituent parts. The rules typically are expressed in terms of finite <a href="Set_(mathematics)" title="wikilink">sets</a> of formulae, although there are logics for which we must use more complicated data structures, such as <a href="multiset" title="wikilink">multisets</a>, <a href="list_(computing)" title="wikilink">lists</a>, or even <a href="tree_(data_structure)" title="wikilink">trees</a> of formulas. Henceforth, "set" denotes any of {set, multiset, list, tree}.</p>

<p>If there is such a rule for every logical connective then the procedure will eventually produce a set which consists only of <a href="atomic_formula" title="wikilink">atomic formulae</a> and their negations, which cannot be broken down any further. Such a set is easily recognizable as satisfiable or unsatisfiable with respect to the semantics of the logic in question. To keep track of this process, the nodes of a tableau itself are set out in the form of a tree and the branches of this tree are created and assessed in a systematic way. Such a systematic method for searching this tree gives rise to an algorithm for performing deduction and automated reasoning. Note that this larger tree is present regardless of whether the nodes contain sets, multisets, lists or trees.</p>
<h2 id="propositional-logic">Propositional logic</h2>

<p>This section presents the tableau calculus for classical propositional logic. A tableau checks whether a given set of formulae is satisfiable or not. It can be used to check either validity or entailment: a formula is valid if its negation is unsatisfiable and formulae 

<math display="inline" id="Method_of_analytic_tableaux:0">
 <semantics>
  <mrow>
   <msub>
    <mi>A</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>A</mi>
    <mi>n</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>A</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>A</ci>
     <ci>n</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{1},\ldots,A_{n}
  </annotation>
 </semantics>
</math>

 imply 

<math display="inline" id="Method_of_analytic_tableaux:1">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

 if 

<math display="inline" id="Method_of_analytic_tableaux:2">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <msub>
    <mi>A</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>A</mi>
    <mi>n</mi>
   </msub>
   <mo>,</mo>
   <mrow>
    <mi mathvariant="normal">¬</mi>
    <mi>B</mi>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>A</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>A</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <times></times>
     <not></not>
     <ci>B</ci>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{A_{1},\ldots,A_{n},\neg B\}
  </annotation>
 </semantics>
</math>

 is unsatisfiable.</p>

<p>The main principle of propositional tableaux is to attempt to "break" complex formulae into smaller ones until complementary pairs of literals are produced or no further expansion is possible.</p>

<p> The method works on a tree whose nodes are labeled with formulae. At each step, this tree is modified; in the propositional case, the only allowed changes are additions of a node as descendant of a leaf. The procedure starts by generating the tree made of a chain of all formulae in the set to prove unsatisfiability. A variant to this starting step is to begin with a single-node tree whose root is labeled by 

<math display="inline" id="Method_of_analytic_tableaux:3">
 <semantics>
  <mo>⊤</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">top</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \top
  </annotation>
 </semantics>
</math>

; in this second case, the procedure can always copy a formula in the set below a leaf. As a running example, the tableau for the set 

<math display="inline" id="Method_of_analytic_tableaux:4">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>a</mi>
      <mo>∨</mo>
      <mrow>
       <mi mathvariant="normal">¬</mi>
       <mi>b</mi>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∧</mo>
    <mi>b</mi>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi mathvariant="normal">¬</mi>
    <mi>a</mi>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <and></and>
     <apply>
      <or></or>
      <ci>a</ci>
      <apply>
       <times></times>
       <not></not>
       <ci>b</ci>
      </apply>
     </apply>
     <ci>b</ci>
    </apply>
    <apply>
     <times></times>
     <not></not>
     <ci>a</ci>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{(a\vee\neg b)\wedge b,\neg a\}
  </annotation>
 </semantics>
</math>

 is shown.</p>

<p>The principle of tableau is that formulae in nodes of the same branch are considered in conjunction while the different branches are considered to be disjuncted. As a result, a tableau is a tree-like representation of a formula that is a disjunction of conjunctions. This formula is equivalent to the set to prove unsatisfiability. The procedure modifies the tableau in such a way that the formula represented by the resulting tableau is equivalent to the original one. One of these conjunctions may contain a pair of complementary literals, in which case that conjunction is proved to be unsatisfiable. If all conjunctions are proved unsatisfiable, the original set of formulae is unsatisfiable.</p>
<h3 id="and">And</h3>

<p> Whenever a branch of a tableau contains a formula 

<math display="inline" id="Method_of_analytic_tableaux:5">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>∧</mo>
   <mi>B</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <ci>A</ci>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\wedge B
  </annotation>
 </semantics>
</math>

 that is the conjunction of two formulae, these two formulae are both consequences of that formula. This fact can be formalized by the following rule for expansion of a tableau:</p>
<blockquote>

<p>(

<math display="inline" id="Method_of_analytic_tableaux:6">
 <semantics>
  <mo>∧</mo>
  <annotation-xml encoding="MathML-Content">
   <and></and>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \wedge
  </annotation>
 </semantics>
</math>

) If a branch of the tableau contains a conjunctive formula 

<math display="inline" id="Method_of_analytic_tableaux:7">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>∧</mo>
   <mi>B</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <ci>A</ci>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\wedge B
  </annotation>
 </semantics>
</math>

, add to its leaf the chain of two nodes containing the formulae 

<math display="inline" id="Method_of_analytic_tableaux:8">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Method_of_analytic_tableaux:9">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

</p>
</blockquote>

<p>This rule is generally written as follows:</p>

<p>

<math display="block" id="Method_of_analytic_tableaux:10">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi mathvariant="italic">and</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mfrac>
    <mrow>
     <mi>A</mi>
     <mo>∧</mo>
     <mi>B</mi>
    </mrow>
    <mtable>
     <mtr>
      <mtd columnalign="center">
       <mi>A</mi>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mi>B</mi>
      </mtd>
     </mtr>
    </mtable>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>italic- and</ci>
    <apply>
     <divide></divide>
     <apply>
      <and></and>
      <ci>A</ci>
      <ci>B</ci>
     </apply>
     <matrix>
      <matrixrow>
       <ci>A</ci>
      </matrixrow>
      <matrixrow>
       <ci>B</ci>
      </matrixrow>
     </matrix>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\and)\frac{A\wedge B}{\begin{array}[]{c}A\\
B\end{array}}
  </annotation>
 </semantics>
</math>

</p>

<p>A variant of this rule allows a node to contain a set of formulae rather than a single one. In this case, the formulae in this set are considered in conjunction, so one can add 

<math display="inline" id="Method_of_analytic_tableaux:11">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mi>A</mi>
   <mo>,</mo>
   <mi>B</mi>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <ci>A</ci>
    <ci>B</ci>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{A,B\}
  </annotation>
 </semantics>
</math>

 at the end of a branch containing 

<math display="inline" id="Method_of_analytic_tableaux:12">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>∧</mo>
   <mi>B</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <ci>A</ci>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\wedge B
  </annotation>
 </semantics>
</math>

. More precisely, if a node on a branch is labeled 

<math display="inline" id="Method_of_analytic_tableaux:13">
 <semantics>
  <mrow>
   <mi>X</mi>
   <mo>∪</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mi>A</mi>
     <mo>∧</mo>
     <mi>B</mi>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <union></union>
    <ci>X</ci>
    <set>
     <apply>
      <and></and>
      <ci>A</ci>
      <ci>B</ci>
     </apply>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X\cup\{A\wedge B\}
  </annotation>
 </semantics>
</math>

, one can add to the branch the new leaf 

<math display="inline" id="Method_of_analytic_tableaux:14">
 <semantics>
  <mrow>
   <mi>X</mi>
   <mo>∪</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mi>A</mi>
    <mo>,</mo>
    <mi>B</mi>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <union></union>
    <ci>X</ci>
    <set>
     <ci>A</ci>
     <ci>B</ci>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X\cup\{A,B\}
  </annotation>
 </semantics>
</math>

.</p>
<h3 id="or">Or</h3>

<p> If a branch of a tableau contains a formula that is a disjunction of two formulae, such as 

<math display="inline" id="Method_of_analytic_tableaux:15">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>∨</mo>
   <mi>B</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <or></or>
    <ci>A</ci>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\vee B
  </annotation>
 </semantics>
</math>

, the following rule can be applied:</p>
<blockquote>

<p>(

<math display="inline" id="Method_of_analytic_tableaux:16">
 <semantics>
  <mo>∨</mo>
  <annotation-xml encoding="MathML-Content">
   <or></or>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vee
  </annotation>
 </semantics>
</math>

) If a node on a branch contains a disjunctive formula 

<math display="inline" id="Method_of_analytic_tableaux:17">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>∨</mo>
   <mi>B</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <or></or>
    <ci>A</ci>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\vee B
  </annotation>
 </semantics>
</math>

, then create two sibling children to the leaf of the branch, containing the formulae 

<math display="inline" id="Method_of_analytic_tableaux:18">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Method_of_analytic_tableaux:19">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

, respectively.</p>
</blockquote>

<p>This rule splits a branch into two, differing only for the final node. Since branches are considered in disjunction to each other, the two resulting branches are equivalent to the original one, as the disjunction of their non-common nodes is precisely 

<math display="inline" id="Method_of_analytic_tableaux:20">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>∨</mo>
   <mi>B</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <or></or>
    <ci>A</ci>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\vee B
  </annotation>
 </semantics>
</math>

. The rule for disjunction is generally formally written using the symbol 

<math display="inline" id="Method_of_analytic_tableaux:21">
 <semantics>
  <mo stretchy="false">|</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-|</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |
  </annotation>
 </semantics>
</math>

 for separating the formulae of the two distinct nodes to be created:</p>

<p>

<math display="block" id="Method_of_analytic_tableaux:22">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>∨</mo>
    <mo stretchy="false">)</mo>
   </mrow>
   <mfrac>
    <mrow>
     <mi>A</mi>
     <mo>∨</mo>
     <mi>B</mi>
    </mrow>
    <mrow>
     <mi>A</mi>
     <mo stretchy="false">|</mo>
     <mi>B</mi>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <or></or>
    <apply>
     <divide></divide>
     <apply>
      <or></or>
      <ci>A</ci>
      <ci>B</ci>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="unknown">A</csymbol>
      <ci>normal-|</ci>
      <csymbol cd="unknown">B</csymbol>
     </cerror>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\vee)\frac{A\vee B}{A|B}
  </annotation>
 </semantics>
</math>

</p>

<p>If nodes are assumed to contain sets of formulae, this rule is replaced by: if a node is labeled 

<math display="inline" id="Method_of_analytic_tableaux:23">
 <semantics>
  <mrow>
   <mi>Y</mi>
   <mo>∪</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mi>A</mi>
     <mo>∨</mo>
     <mi>B</mi>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <union></union>
    <ci>Y</ci>
    <set>
     <apply>
      <or></or>
      <ci>A</ci>
      <ci>B</ci>
     </apply>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y\cup\{A\vee B\}
  </annotation>
 </semantics>
</math>

, a leaf of the branch this node is in can be appended two sibling child nodes labeled 

<math display="inline" id="Method_of_analytic_tableaux:24">
 <semantics>
  <mrow>
   <mi>Y</mi>
   <mo>∪</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mi>A</mi>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <union></union>
    <ci>Y</ci>
    <set>
     <ci>A</ci>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y\cup\{A\}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Method_of_analytic_tableaux:25">
 <semantics>
  <mrow>
   <mi>Y</mi>
   <mo>∪</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mi>B</mi>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <union></union>
    <ci>Y</ci>
    <set>
     <ci>B</ci>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y\cup\{B\}
  </annotation>
 </semantics>
</math>

, respectively.</p>
<h3 id="not">Not</h3>

<p>The aim of tableaux is to generate progressively simpler formulae until pairs of opposite literals are produced or no other rule can be applied. Negation can be treated by initially making formulae in <a href="negation_normal_form" title="wikilink">negation normal form</a>, so that negation only occurs in front of literals. Alternatively, one can use <a href="De_Morgan's_laws" title="wikilink">De Morgan's laws</a> during the expansion of the tableau, so that for example 

<math display="inline" id="Method_of_analytic_tableaux:26">
 <semantics>
  <mrow>
   <mi mathvariant="normal">¬</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>A</mi>
     <mo>∧</mo>
     <mi>B</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <not></not>
    <apply>
     <and></and>
     <ci>A</ci>
     <ci>B</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg(A\wedge B)
  </annotation>
 </semantics>
</math>

 is treated as 

<math display="inline" id="Method_of_analytic_tableaux:27">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">¬</mi>
    <mi>A</mi>
   </mrow>
   <mo>∨</mo>
   <mrow>
    <mi mathvariant="normal">¬</mi>
    <mi>B</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <or></or>
    <apply>
     <times></times>
     <not></not>
     <ci>A</ci>
    </apply>
    <apply>
     <times></times>
     <not></not>
     <ci>B</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg A\vee\neg B
  </annotation>
 </semantics>
</math>

. Rules that introduce or remove a pair of negations (such as in 

<math display="inline" id="Method_of_analytic_tableaux:28">
 <semantics>
  <mrow>
   <mi mathvariant="normal">¬</mi>
   <mi mathvariant="normal">¬</mi>
   <mi>A</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <not></not>
    <not></not>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg\neg A
  </annotation>
 </semantics>
</math>

) are also used in this case (otherwise, there would be no way of expanding a formula like 

<math display="inline" id="Method_of_analytic_tableaux:29">
 <semantics>
  <mrow>
   <mi mathvariant="normal">¬</mi>
   <mrow>
    <mi mathvariant="normal">¬</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>A</mi>
      <mo>∧</mo>
      <mi>B</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <not></not>
    <apply>
     <not></not>
     <apply>
      <and></and>
      <ci>A</ci>
      <ci>B</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg\neg(A\wedge B)
  </annotation>
 </semantics>
</math>

:</p>

<p>

<math display="block" id="Method_of_analytic_tableaux:30">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi mathvariant="normal">¬</mi>
     <mn>1</mn>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mfrac>
    <mi>A</mi>
    <mrow>
     <mi mathvariant="normal">¬</mi>
     <mi mathvariant="normal">¬</mi>
     <mi>A</mi>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <times></times>
     <not></not>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <divide></divide>
     <ci>A</ci>
     <apply>
      <times></times>
      <not></not>
      <not></not>
      <ci>A</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\neg 1)\frac{A}{\neg\neg A}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Method_of_analytic_tableaux:31">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi mathvariant="normal">¬</mi>
     <mn>2</mn>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mfrac>
    <mrow>
     <mi mathvariant="normal">¬</mi>
     <mi mathvariant="normal">¬</mi>
     <mi>A</mi>
    </mrow>
    <mi>A</mi>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <times></times>
     <not></not>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <not></not>
      <not></not>
      <ci>A</ci>
     </apply>
     <ci>A</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\neg 2)\frac{\neg\neg A}{A}
  </annotation>
 </semantics>
</math>

</p>
<figure><b>(Figure)</b>
<figcaption>The tableau is closed</figcaption>
</figure>
<h3 id="closure">Closure</h3>

<p>Every tableau can be considered as a graphical representation of a formula, which is equivalent to the set the tableau is built from. This formula is as follows: each branch of the tableau represents the conjunction of its formulae; the tableau represents the disjunction of its branches. The expansion rules transforms a tableau into one having an equivalent represented formula. Since the tableau is initialized as a single branch containing the formulae of the input set, all subsequent tableaux obtained from it represent formulae which are equivalent to that set (in the variant where the initial tableau is the single node labeled true, the formulae represented by tableaux are consequences of the original set.)</p>

<p> The method of tableaux works by starting with the initial set of formulae and then adding to the tableau simpler and simpler formulae until contradiction is shown in the simple form of opposite literals. Since the formula represented by a tableau is the disjunction of the formulae represented by its branches, contradiction is obtained when every branch contains a pair of opposite literals.</p>

<p>Once a branch contains a literal and its negation, its corresponding formula is unsatisfiable. As a result, this branch can be now "closed", as there is no need to further expand it. If all branches of a tableau are closed, the formula represented by the tableau is unsatisfiable; therefore, the original set is unsatisfiable as well. Obtaining a tableau where all branches are closed is a way for proving the unsatisfiability of the original set. In the propositional case, one can also prove that satisfiability is proved by the impossibility of finding a closed tableau, provided that every expansion rule has been applied everywhere it could be applied. In particular, if a tableau contains some open (non-closed) branches and every formula that is not a literal has been used by a rule to generate a new node on every branch the formula is in, the set is satisfiable.</p>

<p>This rule takes into account that a formula may occur in more than one branch (this is the case if there is at least a branching point "below" the node). In this case, the rule for expanding the formula has to be applied so that its conclusion(s) are appended to all of these branches that are still open, before one can conclude that the tableau cannot be further expanded and that the formula is therefore satisfiable.</p>
<h3 id="set-labeled-tableau">Set-labeled tableau</h3>

<p>A variant of tableau is to label nodes with sets of formulae rather than single formulae. In this case, the initial tableau is a single node labeled with the set to be proved satisfiable. The formulae in a set are therefore considered to be in conjunction.</p>

<p>The rules of expansion of the tableau can now work on the leaves of the tableau, ignoring all internal nodes. For conjunction, the rule is based on the equivalence of a set containing a conjunction 

<math display="inline" id="Method_of_analytic_tableaux:32">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>∧</mo>
   <mi>B</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <ci>A</ci>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\wedge B
  </annotation>
 </semantics>
</math>

 with the set containing both 

<math display="inline" id="Method_of_analytic_tableaux:33">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Method_of_analytic_tableaux:34">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

 in place of it. In particular, if a leaf is labeled with 

<math display="inline" id="Method_of_analytic_tableaux:35">
 <semantics>
  <mrow>
   <mi>X</mi>
   <mo>∪</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mi>A</mi>
     <mo>∧</mo>
     <mi>B</mi>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <union></union>
    <ci>X</ci>
    <set>
     <apply>
      <and></and>
      <ci>A</ci>
      <ci>B</ci>
     </apply>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X\cup\{A\wedge B\}
  </annotation>
 </semantics>
</math>

, a node can be appended to it with label 

<math display="inline" id="Method_of_analytic_tableaux:36">
 <semantics>
  <mrow>
   <mi>X</mi>
   <mo>∪</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mi>A</mi>
    <mo>,</mo>
    <mi>B</mi>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <union></union>
    <ci>X</ci>
    <set>
     <ci>A</ci>
     <ci>B</ci>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X\cup\{A,B\}
  </annotation>
 </semantics>
</math>

:</p>

<p>

<math display="block" id="Method_of_analytic_tableaux:37">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>∧</mo>
    <mo stretchy="false">)</mo>
   </mrow>
   <mfrac>
    <mrow>
     <mi>X</mi>
     <mo>∪</mo>
     <mrow>
      <mo stretchy="false">{</mo>
      <mrow>
       <mi>A</mi>
       <mo>∧</mo>
       <mi>B</mi>
      </mrow>
      <mo stretchy="false">}</mo>
     </mrow>
    </mrow>
    <mrow>
     <mi>X</mi>
     <mo>∪</mo>
     <mrow>
      <mo stretchy="false">{</mo>
      <mi>A</mi>
      <mo>,</mo>
      <mi>B</mi>
      <mo stretchy="false">}</mo>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <and></and>
    <apply>
     <divide></divide>
     <apply>
      <union></union>
      <ci>X</ci>
      <set>
       <apply>
        <and></and>
        <ci>A</ci>
        <ci>B</ci>
       </apply>
      </set>
     </apply>
     <apply>
      <union></union>
      <ci>X</ci>
      <set>
       <ci>A</ci>
       <ci>B</ci>
      </set>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\wedge)\frac{X\cup\{A\wedge B\}}{X\cup\{A,B\}}
  </annotation>
 </semantics>
</math>

</p>

<p>For disjunction, a set 

<math display="inline" id="Method_of_analytic_tableaux:38">
 <semantics>
  <mrow>
   <mi>X</mi>
   <mo>∪</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mi>A</mi>
     <mo>∨</mo>
     <mi>B</mi>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <union></union>
    <ci>X</ci>
    <set>
     <apply>
      <or></or>
      <ci>A</ci>
      <ci>B</ci>
     </apply>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X\cup\{A\vee B\}
  </annotation>
 </semantics>
</math>

 is equivalent to the disjunction of the two sets 

<math display="inline" id="Method_of_analytic_tableaux:39">
 <semantics>
  <mrow>
   <mi>X</mi>
   <mo>∪</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mi>A</mi>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <union></union>
    <ci>X</ci>
    <set>
     <ci>A</ci>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X\cup\{A\}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Method_of_analytic_tableaux:40">
 <semantics>
  <mrow>
   <mi>X</mi>
   <mo>∪</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mi>B</mi>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <union></union>
    <ci>X</ci>
    <set>
     <ci>B</ci>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X\cup\{B\}
  </annotation>
 </semantics>
</math>

. As a result, if the first set labels a leaf, two children can be appended to it, labeled with the latter two formulae.</p>

<p>

<math display="block" id="Method_of_analytic_tableaux:41">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>∨</mo>
    <mo stretchy="false">)</mo>
   </mrow>
   <mfrac>
    <mrow>
     <mi>X</mi>
     <mo>∪</mo>
     <mrow>
      <mo stretchy="false">{</mo>
      <mrow>
       <mi>A</mi>
       <mo>∨</mo>
       <mi>B</mi>
      </mrow>
      <mo stretchy="false">}</mo>
     </mrow>
    </mrow>
    <mrow>
     <mi>X</mi>
     <mo>∪</mo>
     <mrow>
      <mo stretchy="false">{</mo>
      <mi>A</mi>
      <mo stretchy="false">}</mo>
     </mrow>
     <mo stretchy="false">|</mo>
     <mi>X</mi>
     <mo>∪</mo>
     <mrow>
      <mo stretchy="false">{</mo>
      <mi>B</mi>
      <mo stretchy="false">}</mo>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <or></or>
    <apply>
     <divide></divide>
     <apply>
      <union></union>
      <ci>X</ci>
      <set>
       <apply>
        <or></or>
        <ci>A</ci>
        <ci>B</ci>
       </apply>
      </set>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="unknown">X</csymbol>
      <union></union>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-{</ci>
       <csymbol cd="unknown">A</csymbol>
       <ci>normal-}</ci>
      </cerror>
      <ci>normal-|</ci>
      <csymbol cd="unknown">X</csymbol>
      <union></union>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-{</ci>
       <csymbol cd="unknown">B</csymbol>
       <ci>normal-}</ci>
      </cerror>
     </cerror>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\vee)\frac{X\cup\{A\vee B\}}{X\cup\{A\}|X\cup\{B\}}
  </annotation>
 </semantics>
</math>

</p>

<p>Finally, if a set contains both a literal and its negation, this branch can be closed:</p>

<p>

<math display="block" id="Method_of_analytic_tableaux:42">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>i</mi>
     <mi>d</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mfrac>
    <mrow>
     <mi>X</mi>
     <mo>∪</mo>
     <mrow>
      <mo stretchy="false">{</mo>
      <mi>p</mi>
      <mo>,</mo>
      <mrow>
       <mi mathvariant="normal">¬</mi>
       <mi>p</mi>
      </mrow>
      <mo stretchy="false">}</mo>
     </mrow>
    </mrow>
    <mrow>
     <mi>c</mi>
     <mi>l</mi>
     <mi>o</mi>
     <mi>s</mi>
     <mi>e</mi>
     <mi>d</mi>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <times></times>
     <ci>i</ci>
     <ci>d</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <union></union>
      <ci>X</ci>
      <set>
       <ci>p</ci>
       <apply>
        <times></times>
        <not></not>
        <ci>p</ci>
       </apply>
      </set>
     </apply>
     <apply>
      <times></times>
      <ci>c</ci>
      <ci>l</ci>
      <ci>o</ci>
      <ci>s</ci>
      <ci>e</ci>
      <ci>d</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (id)\frac{X\cup\{p,\neg p\}}{closed}
  </annotation>
 </semantics>
</math>

</p>

<p>A tableau for a given finite set <em>X</em> is a finite (upside down) tree with root <em>X</em> in which all child nodes are obtained by applying the tableau rules to their parents. A branch in such a tableau is closed if its leaf node contains "closed". A tableau is closed if all its branches are closed. A tableau is open if at least one branch is not closed.</p>

<p>Here are two closed tableaux for the set <em>X</em> = {<em>r</em>0 &amp; ~<em>r</em>0, <em>p</em>0 &amp; ((~<em>p</em>0 ∨ <em>q</em>0) &amp; ~<em>q</em>0)} with each rule application marked at the right hand side (&amp; and ~ stand for 

<math display="inline" id="Method_of_analytic_tableaux:43">
 <semantics>
  <mo>∧</mo>
  <annotation-xml encoding="MathML-Content">
   <and></and>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \wedge
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Method_of_analytic_tableaux:44">
 <semantics>
  <mi mathvariant="normal">¬</mi>
  <annotation-xml encoding="MathML-Content">
   <not></not>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg
  </annotation>
 </semantics>
</math>

, respectively)</p>

<p><code> {r0 &amp; ~r0, p0 &amp; ((~p0 v q0) &amp; ~q0)}                                    {r0 &amp; ~r0, p0 &amp; ((~p0 v q0) &amp; ~q0)}</code><br/>
<code>--------------------------------------(&amp;)                        ------------------------------------------------------------(&amp;)</code><br/>
<code> {r0, ~r0, p0 &amp; ((~p0 v q0) &amp; ~q0)}                                    {r0 &amp; ~r0, p0, ((~p0 v q0) &amp; ~q0)}</code><br/>
<code> -------------------------------------(id)                         ----------------------------------------------------------(&amp;)</code><br/>
<code>            closed                                                      {r0 &amp; ~r0, p0,  (~p0 v q0),  ~q0} </code><br/>
<code>                                                                -------------------------------------------------------------(v)</code><br/>
<code>                                                                  {r0 &amp; ~r0, p0, ~p0, ~q0}       |   {r0 &amp; ~r0, p0, q0, ~q0}</code><br/>
<code>                                                                 -------------------------- (id)     ----------------------  (id)</code><br/>
<code>                                                                          closed                            closed</code></p>

<p>The left hand tableau closes after only one rule application while the right hand one misses the mark and takes a lot longer to close. Clearly, we would prefer to always find the shortest closed tableaux but it can be shown that one single algorithm that finds the shortest closed tableaux for all input sets of formulae cannot exist.</p>

<p>The three rules 

<math display="inline" id="Method_of_analytic_tableaux:45">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mo>∧</mo>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <and></and>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\wedge)
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Method_of_analytic_tableaux:46">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mo>∨</mo>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <or></or>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\vee)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Method_of_analytic_tableaux:47">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi>i</mi>
    <mi>d</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>i</ci>
    <ci>d</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (id)
  </annotation>
 </semantics>
</math>

 given above are then enough to decide if a given set 

<math display="inline" id="Method_of_analytic_tableaux:48">
 <semantics>
  <msup>
   <mi>X</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>X</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X^{\prime}
  </annotation>
 </semantics>
</math>

 of formulae in negated normal form are jointly satisfiable:</p>
<blockquote>

<p>Just apply all possible rules in all possible orders until we find a closed tableau for 

<math display="inline" id="Method_of_analytic_tableaux:49">
 <semantics>
  <msup>
   <mi>X</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>X</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X^{\prime}
  </annotation>
 </semantics>
</math>

 or until we exhaust all possibilities and conclude that every tableau for 

<math display="inline" id="Method_of_analytic_tableaux:50">
 <semantics>
  <msup>
   <mi>X</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>X</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X^{\prime}
  </annotation>
 </semantics>
</math>

 is open.</p>
</blockquote>

<p>In the first case, 

<math display="inline" id="Method_of_analytic_tableaux:51">
 <semantics>
  <msup>
   <mi>X</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>X</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X^{\prime}
  </annotation>
 </semantics>
</math>

 is jointly unsatisfiable and in the second the case the leaf node of the open branch gives an assignment to the atomic formulae and negated atomic formulae which makes 

<math display="inline" id="Method_of_analytic_tableaux:52">
 <semantics>
  <msup>
   <mi>X</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>X</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X^{\prime}
  </annotation>
 </semantics>
</math>

 jointly satisfiable. Classical logic actually has the rather nice property that we need to investigate only (any) one tableau completely: if it closes then 

<math display="inline" id="Method_of_analytic_tableaux:53">
 <semantics>
  <msup>
   <mi>X</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>X</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X^{\prime}
  </annotation>
 </semantics>
</math>

 is unsatisfiable and if it is open then 

<math display="inline" id="Method_of_analytic_tableaux:54">
 <semantics>
  <msup>
   <mi>X</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>X</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X^{\prime}
  </annotation>
 </semantics>
</math>

 is satisfiable. But this property is not generally enjoyed by other logics.</p>

<p>These rules suffice for all of classical logic by taking an initial set of formulae <em>X</em> and replacing each member <em>C</em> by its logically equivalent negated normal form ''C' '' giving a set of formulae ''X' ''. We know that <em>X</em> is satisfiable if and only if ''X' '' is satisfiable, so it suffices to search for a closed tableau for ''X' '' using the procedure outlined above.</p>

<p>By setting 

<math display="inline" id="Method_of_analytic_tableaux:55">
 <semantics>
  <mrow>
   <mi>X</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mi mathvariant="normal">¬</mi>
     <mi>A</mi>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>X</ci>
    <set>
     <apply>
      <times></times>
      <not></not>
      <ci>A</ci>
     </apply>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X=\{\neg A\}
  </annotation>
 </semantics>
</math>

 we can test whether the formula <em>A</em> is a <a href="tautology_(logic)" title="wikilink">tautology</a> of classical logic:</p>
<blockquote>

<p>If the tableau for 

<math display="inline" id="Method_of_analytic_tableaux:56">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mrow>
    <mi mathvariant="normal">¬</mi>
    <mi>A</mi>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <times></times>
     <not></not>
     <ci>A</ci>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{\neg A\}
  </annotation>
 </semantics>
</math>

 closes then 

<math display="inline" id="Method_of_analytic_tableaux:57">
 <semantics>
  <mrow>
   <mi mathvariant="normal">¬</mi>
   <mi>A</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <not></not>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg A
  </annotation>
 </semantics>
</math>

 is unsatisfiable and so <em>A</em> is a tautology since no assignment of <a href="truth_value" title="wikilink">truth values</a> will ever make <em>A</em> false. Otherwise any open leaf of any open branch of any open tableau for 

<math display="inline" id="Method_of_analytic_tableaux:58">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mrow>
    <mi mathvariant="normal">¬</mi>
    <mi>A</mi>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <times></times>
     <not></not>
     <ci>A</ci>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{\neg A\}
  </annotation>
 </semantics>
</math>

 gives an assignment that falsifies <em>A</em>.</p>
</blockquote>
<h3 id="conditional">Conditional</h3>

<p>Classical <a href="propositional_logic" title="wikilink">propositional logic</a> usually has a <a href="connective_(logic)" title="wikilink">connective</a> to denote <a href="material_conditional" title="wikilink">material implication</a>. If we write this connective as ⇒, then the formula <em>A</em> ⇒ <em>B</em> stands for "if <em>A</em> then <em>B</em>". It is possible to give a tableau rule for breaking down <em>A</em> ⇒ <em>B</em> into its constituent formulae. Similarly, we can give one rule each for breaking down each of ¬(<em>A</em> ∧ <em>B</em>), ¬(<em>A</em> ∨ <em>B</em>), ¬(¬<em>A</em>), and ¬(<em>A</em> ⇒ <em>B</em>). Together these rules would give a terminating procedure for deciding whether a given set of formulae is simultaneously <a class="uri" href="satisfiable" title="wikilink">satisfiable</a> in classical logic since each rule breaks down one formula into its constituents but no rule builds larger formulae out of smaller constituents. Thus we must eventually reach a node that contains only <a href="atom_(logic)" title="wikilink">atoms</a> and negations of atoms. If this last node matches (id) then we can close the branch, otherwise it remains open.</p>

<p>But note that the following equivalences hold in classical logic where (...) = (...) means that the left hand side formula is <a href="logically_equivalent" title="wikilink">logically equivalent</a> to the right hand side formula:</p>

<p>

<math display="inline" id="Method_of_analytic_tableaux:59">
 <semantics>
  <mtable>
   <mtr>
    <mtd columnalign="left">
     <mrow>
      <mi mathvariant="normal">¬</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>A</mi>
        <mi mathvariant="italic">and</mi>
        <mi>B</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mtd>
    <mtd columnalign="center">
     <mo>=</mo>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mi mathvariant="normal">¬</mi>
      <mi>A</mi>
      <mi mathvariant="normal">¬</mi>
      <mi>B</mi>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="left">
     <mrow>
      <mi mathvariant="normal">¬</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>A</mi>
        <mi>B</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mtd>
    <mtd columnalign="center">
     <mo>=</mo>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mi mathvariant="normal">¬</mi>
      <mi>A</mi>
      <mi mathvariant="italic">and</mi>
      <mi mathvariant="normal">¬</mi>
      <mi>B</mi>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="left">
     <mrow>
      <mi mathvariant="normal">¬</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi mathvariant="normal">¬</mi>
        <mi>A</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mtd>
    <mtd columnalign="center">
     <mo>=</mo>
    </mtd>
    <mtd columnalign="left">
     <mi>A</mi>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="left">
     <mrow>
      <mi mathvariant="normal">¬</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>A</mi>
        <mo>⇒</mo>
        <mi>B</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mtd>
    <mtd columnalign="center">
     <mo>=</mo>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mi>A</mi>
      <mi mathvariant="italic">and</mi>
      <mi mathvariant="normal">¬</mi>
      <mi>B</mi>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="left">
     <mrow>
      <mi>A</mi>
      <mo>⇒</mo>
      <mi>B</mi>
     </mrow>
    </mtd>
    <mtd columnalign="center">
     <mo>=</mo>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mi mathvariant="normal">¬</mi>
      <mi>A</mi>
      <mi>B</mi>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="left">
     <mrow>
      <mi>A</mi>
      <mo>⇔</mo>
      <mi>B</mi>
     </mrow>
    </mtd>
    <mtd columnalign="center">
     <mo>=</mo>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>A</mi>
        <mi mathvariant="italic">and</mi>
        <mi>B</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi mathvariant="normal">¬</mi>
        <mi>A</mi>
        <mi mathvariant="italic">and</mi>
        <mi mathvariant="normal">¬</mi>
        <mi>B</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="left">
     <mrow>
      <mi mathvariant="normal">¬</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>A</mi>
        <mo>⇔</mo>
        <mi>B</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mtd>
    <mtd columnalign="center">
     <mo>=</mo>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>A</mi>
        <mi mathvariant="italic">and</mi>
        <mi mathvariant="normal">¬</mi>
        <mi>B</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi mathvariant="normal">¬</mi>
        <mi>A</mi>
        <mi mathvariant="italic">and</mi>
        <mi>B</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mtd>
   </mtr>
  </mtable>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <apply>
      <not></not>
      <apply>
       <times></times>
       <ci>A</ci>
       <ci>italic- and</ci>
       <ci>B</ci>
      </apply>
     </apply>
     <eq></eq>
     <apply>
      <times></times>
      <not></not>
      <ci>A</ci>
      <not></not>
      <ci>B</ci>
     </apply>
    </matrixrow>
    <matrixrow>
     <apply>
      <not></not>
      <apply>
       <times></times>
       <ci>A</ci>
       <ci>B</ci>
      </apply>
     </apply>
     <eq></eq>
     <apply>
      <times></times>
      <not></not>
      <ci>A</ci>
      <ci>italic- and</ci>
      <not></not>
      <ci>B</ci>
     </apply>
    </matrixrow>
    <matrixrow>
     <apply>
      <not></not>
      <apply>
       <times></times>
       <not></not>
       <ci>A</ci>
      </apply>
     </apply>
     <eq></eq>
     <ci>A</ci>
    </matrixrow>
    <matrixrow>
     <apply>
      <not></not>
      <apply>
       <ci>normal-⇒</ci>
       <ci>A</ci>
       <ci>B</ci>
      </apply>
     </apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>A</ci>
      <ci>italic- and</ci>
      <not></not>
      <ci>B</ci>
     </apply>
    </matrixrow>
    <matrixrow>
     <apply>
      <ci>normal-⇒</ci>
      <ci>A</ci>
      <ci>B</ci>
     </apply>
     <eq></eq>
     <apply>
      <times></times>
      <not></not>
      <ci>A</ci>
      <ci>B</ci>
     </apply>
    </matrixrow>
    <matrixrow>
     <apply>
      <ci>normal-⇔</ci>
      <ci>A</ci>
      <ci>B</ci>
     </apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <times></times>
       <ci>A</ci>
       <ci>italic- and</ci>
       <ci>B</ci>
      </apply>
      <apply>
       <times></times>
       <not></not>
       <ci>A</ci>
       <ci>italic- and</ci>
       <not></not>
       <ci>B</ci>
      </apply>
     </apply>
    </matrixrow>
    <matrixrow>
     <apply>
      <not></not>
      <apply>
       <ci>normal-⇔</ci>
       <ci>A</ci>
       <ci>B</ci>
      </apply>
     </apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <times></times>
       <ci>A</ci>
       <ci>italic- and</ci>
       <not></not>
       <ci>B</ci>
      </apply>
      <apply>
       <times></times>
       <not></not>
       <ci>A</ci>
       <ci>italic- and</ci>
       <ci>B</ci>
      </apply>
     </apply>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{array}[]{lcl}\neg(A\and B)&=&\neg A\neg B\\
\neg(AB)&=&\neg A\and\neg B\\
\neg(\neg A)&=&A\\
\neg(A\Rightarrow B)&=&A\and\neg B\\
A\Rightarrow B&=&\neg AB\\
A\Leftrightarrow B&=&(A\and B)(\neg A\and\neg B)\\
\neg(A\Leftrightarrow B)&=&(A\and\neg B)(\neg A\and B)\end{array}
  </annotation>
 </semantics>
</math>

</p>

<p>If we start with an arbitrary formula <em>C</em> of <a href="classical_logic" title="wikilink">classical logic</a>, and apply these equivalences repeatedly to replace the left hand sides with the right hand sides in <em>C</em>, then we will obtain a formula ''C' '' which is logically equivalent to <em>C</em> but which has the property that ''C' '' contains no implications, and ¬ appears in front of atomic formulae only. Such a formula is said to be in <a href="negation_normal_form" title="wikilink">negation normal form</a> and it is possible to prove formally that every formula <em>C</em> of classical logic has a logically equivalent formula ''C' '' in negation normal form. That is, <em>C</em> is satisfiable if and only if ''C' '' is satisfiable.</p>
<h2 id="first-order-logic-tableau">First-order logic tableau</h2>

<p>Tableaux are extended to first order predicate logic by two rules for dealing with universal and existential quantifiers, respectively. Two different sets of rules can be used; both employ a form of <a href="Skolem_normal_form" title="wikilink">Skolemization</a> for handling existential quantifiers, but differ on the handling of universal quantifiers.</p>

<p>The set of formulae to check for validity is here supposed to contain no free variables; this is not a limitation as free variables are implicitly universally quantified, so universal quantifiers over these variables can be added, resulting in a formula with no free variables.</p>
<h3 id="first-order-tableau-without-unification">First-order tableau without unification</h3>

<p>A first-order formula 

<math display="inline" id="Method_of_analytic_tableaux:60">
 <semantics>
  <mrow>
   <mrow>
    <mo>∀</mo>
    <mi>x</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>γ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <csymbol cd="latexml">for-all</csymbol>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <ci>γ</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall x.\gamma(x)
  </annotation>
 </semantics>
</math>

 implies all formulae 

<math display="inline" id="Method_of_analytic_tableaux:61">
 <semantics>
  <mrow>
   <mi>γ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>γ</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gamma(t)
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Method_of_analytic_tableaux:62">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 is a ground term. The following inference rule is therefore correct:</p>

<p>

<math display="block" id="Method_of_analytic_tableaux:63">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>∀</mo>
    <mo stretchy="false">)</mo>
   </mrow>
   <mfrac>
    <mrow>
     <mrow>
      <mo>∀</mo>
      <mi>x</mi>
     </mrow>
     <mo>.</mo>
     <mrow>
      <mi>γ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mrow>
     <mi>γ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">for-all</csymbol>
    <apply>
     <divide></divide>
     <apply>
      <csymbol cd="ambiguous">formulae-sequence</csymbol>
      <apply>
       <csymbol cd="latexml">for-all</csymbol>
       <ci>x</ci>
      </apply>
      <apply>
       <times></times>
       <ci>γ</ci>
       <ci>x</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>γ</ci>
      <ci>t</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\forall)\frac{\forall x.\gamma(x)}{\gamma(t)}
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Method_of_analytic_tableaux:64">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 is an arbitrary ground term</p>

<p>Contrarily to the rules for the propositional connectives, multiple applications of this rule to the same formula may be necessary. As an example, the set 

<math display="inline" id="Method_of_analytic_tableaux:65">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mrow>
    <mrow>
     <mrow>
      <mrow>
       <mi mathvariant="normal">¬</mi>
       <mi>P</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>a</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>∨</mo>
      <mrow>
       <mi mathvariant="normal">¬</mi>
       <mi>P</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>b</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mo>∀</mo>
      <mi>x</mi>
     </mrow>
    </mrow>
    <mo>.</mo>
    <mrow>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <csymbol cd="ambiguous">formulae-sequence</csymbol>
     <list>
      <apply>
       <or></or>
       <apply>
        <times></times>
        <not></not>
        <ci>P</ci>
        <ci>a</ci>
       </apply>
       <apply>
        <times></times>
        <not></not>
        <ci>P</ci>
        <ci>b</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="latexml">for-all</csymbol>
       <ci>x</ci>
      </apply>
     </list>
     <apply>
      <times></times>
      <ci>P</ci>
      <ci>x</ci>
     </apply>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{\neg P(a)\vee\neg P(b),\forall x.P(x)\}
  </annotation>
 </semantics>
</math>

 can only be proved unsatisfiable if both 

<math display="inline" id="Method_of_analytic_tableaux:66">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>a</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <ci>a</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(a)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Method_of_analytic_tableaux:67">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>b</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <ci>b</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(b)
  </annotation>
 </semantics>
</math>

 are generated from 

<math display="inline" id="Method_of_analytic_tableaux:68">
 <semantics>
  <mrow>
   <mrow>
    <mo>∀</mo>
    <mi>x</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <csymbol cd="latexml">for-all</csymbol>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <ci>P</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall x.P(x)
  </annotation>
 </semantics>
</math>

.</p>

<p>Existential quantifiers are dealt with by means of Skolemization. In particular, a formula with a leading existential quantifier like 

<math display="inline" id="Method_of_analytic_tableaux:69">
 <semantics>
  <mrow>
   <mrow>
    <mo>∃</mo>
    <mi>x</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>δ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <exists></exists>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <ci>δ</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \exists x.\delta(x)
  </annotation>
 </semantics>
</math>

 generates its Skolemization 

<math display="inline" id="Method_of_analytic_tableaux:70">
 <semantics>
  <mrow>
   <mi>δ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>c</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>δ</ci>
    <ci>c</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta(c)
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Method_of_analytic_tableaux:71">
 <semantics>
  <mi>c</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>c</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c
  </annotation>
 </semantics>
</math>

 is a new constant symbol.</p>

<p>

<math display="block" id="Method_of_analytic_tableaux:72">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>∃</mo>
    <mo stretchy="false">)</mo>
   </mrow>
   <mfrac>
    <mrow>
     <mrow>
      <mo>∃</mo>
      <mi>x</mi>
     </mrow>
     <mo>.</mo>
     <mrow>
      <mi>δ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mrow>
     <mi>δ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>c</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <exists></exists>
    <apply>
     <divide></divide>
     <apply>
      <csymbol cd="ambiguous">formulae-sequence</csymbol>
      <apply>
       <exists></exists>
       <ci>x</ci>
      </apply>
      <apply>
       <times></times>
       <ci>δ</ci>
       <ci>x</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>δ</ci>
      <ci>c</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\exists)\frac{\exists x.\delta(x)}{\delta(c)}
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Method_of_analytic_tableaux:73">
 <semantics>
  <mi>c</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>c</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c
  </annotation>
 </semantics>
</math>

 is a new constant symbol</p>

<p> The Skolem term 

<math display="inline" id="Method_of_analytic_tableaux:74">
 <semantics>
  <mi>c</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>c</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c
  </annotation>
 </semantics>
</math>

 is a constant (a function of arity 0) because the quantification over 

<math display="inline" id="Method_of_analytic_tableaux:75">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 does not occur within the scope of any universal quantifier. If the original formula contained some universal quantifiers such that the quantification over 

<math display="inline" id="Method_of_analytic_tableaux:76">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 was within their scope, these quantifiers have evidently been removed by the application of the rule for universal quantifiers.</p>

<p>The rule for existential quantifiers introduces new constant symbols. These symbols can be used by the rule for universal quantifiers, so that 

<math display="inline" id="Method_of_analytic_tableaux:77">
 <semantics>
  <mrow>
   <mrow>
    <mo>∀</mo>
    <mi>y</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>γ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <csymbol cd="latexml">for-all</csymbol>
     <ci>y</ci>
    </apply>
    <apply>
     <times></times>
     <ci>γ</ci>
     <ci>y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall y.\gamma(y)
  </annotation>
 </semantics>
</math>

 can generate 

<math display="inline" id="Method_of_analytic_tableaux:78">
 <semantics>
  <mrow>
   <mi>γ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>c</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>γ</ci>
    <ci>c</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gamma(c)
  </annotation>
 </semantics>
</math>

 even if 

<math display="inline" id="Method_of_analytic_tableaux:79">
 <semantics>
  <mi>c</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>c</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c
  </annotation>
 </semantics>
</math>

 was not in the original formula but is a Skolem constant created by the rule for existential quantifiers.</p>

<p>The above two rules for universal and existential quantifiers are correct, and so are the propositional rules: if a set of formulae generates a closed tableau, this set is unsatisfiable. Completeness can also be proved: if a set of formulae is unsatisfiable, there exists a closed tableau built from it by these rules. However, actually finding such a closed tableau requires a suitable policy of application of rules. Otherwise, an unsatisfiable set can generate an infinite-growing tableau. As an example, the set 

<math display="inline" id="Method_of_analytic_tableaux:80">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mrow>
    <mrow>
     <mrow>
      <mi mathvariant="normal">¬</mi>
      <mi>P</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>f</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>c</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mo>∀</mo>
      <mi>x</mi>
     </mrow>
    </mrow>
    <mo>.</mo>
    <mrow>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <csymbol cd="ambiguous">formulae-sequence</csymbol>
     <list>
      <apply>
       <times></times>
       <not></not>
       <ci>P</ci>
       <apply>
        <times></times>
        <ci>f</ci>
        <ci>c</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="latexml">for-all</csymbol>
       <ci>x</ci>
      </apply>
     </list>
     <apply>
      <times></times>
      <ci>P</ci>
      <ci>x</ci>
     </apply>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{\neg P(f(c)),\forall x.P(x)\}
  </annotation>
 </semantics>
</math>

 is unsatisfiable, but a closed tableau is never obtained if one unwisely keeps applying the rule for universal quantifiers to 

<math display="inline" id="Method_of_analytic_tableaux:81">
 <semantics>
  <mrow>
   <mrow>
    <mo>∀</mo>
    <mi>x</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <csymbol cd="latexml">for-all</csymbol>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <ci>P</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall x.P(x)
  </annotation>
 </semantics>
</math>

, generating for example 

<math display="inline" id="Method_of_analytic_tableaux:82">
 <semantics>
  <mrow>
   <mrow>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>c</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>c</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>f</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>c</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <times></times>
     <ci>P</ci>
     <ci>c</ci>
    </apply>
    <apply>
     <times></times>
     <ci>P</ci>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>c</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>P</ci>
     <apply>
      <times></times>
      <ci>f</ci>
      <apply>
       <times></times>
       <ci>f</ci>
       <ci>c</ci>
      </apply>
     </apply>
    </apply>
    <ci>normal-…</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(c),P(f(c)),P(f(f(c))),\ldots
  </annotation>
 </semantics>
</math>

. A closed tableau can always be found by ruling out this and similar "unfair" policies of application of tableau rules.</p>

<p>The rule for universal quantifiers 

<math display="inline" id="Method_of_analytic_tableaux:83">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mo>∀</mo>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">for-all</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\forall)
  </annotation>
 </semantics>
</math>

 is the only non-deterministic rule, as it does not specify which term to instantiate with. Moreover, while the other rules need to be applied only once for each formula and each path the formula is in, this one may require multiple applications. Application of this rule can however be restricted by delaying the application of the rule until no other rule is applicable and by restricting the application of the rule to ground terms that already appear in the path of the tableau. The variant of tableaux with unification shown below aims at solving the problem of non-determinism.</p>
<h3 id="first-order-tableau-with-unification">First-order tableau with unification</h3>

<p>The main problem of tableau without unification is how to choose a ground term 

<math display="inline" id="Method_of_analytic_tableaux:84">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 for the universal quantifier rule. Indeed, every possible ground term can be used, but clearly most of them might be useless for closing the tableau.</p>

<p>A solution to this problem is to "delay" the choice of the term to the time when the consequent of the rule allows closing at least a branch of the tableau. This can be done by using a variable instead of a term, so that 

<math display="inline" id="Method_of_analytic_tableaux:85">
 <semantics>
  <mrow>
   <mrow>
    <mo>∀</mo>
    <mi>x</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>γ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <csymbol cd="latexml">for-all</csymbol>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <ci>γ</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall x.\gamma(x)
  </annotation>
 </semantics>
</math>

 generates 

<math display="inline" id="Method_of_analytic_tableaux:86">
 <semantics>
  <mrow>
   <mi>γ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>x</mi>
     <mo>′</mo>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>γ</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <ci>normal-′</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gamma(x^{\prime})
  </annotation>
 </semantics>
</math>

, and then allowing substitutions to later replace 

<math display="inline" id="Method_of_analytic_tableaux:87">
 <semantics>
  <msup>
   <mi>x</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>x</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{\prime}
  </annotation>
 </semantics>
</math>

 with a term. The rule for universal quantifiers becomes:</p>

<p>

<math display="block" id="Method_of_analytic_tableaux:88">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>∀</mo>
    <mo stretchy="false">)</mo>
   </mrow>
   <mfrac>
    <mrow>
     <mrow>
      <mo>∀</mo>
      <mi>x</mi>
     </mrow>
     <mo>.</mo>
     <mrow>
      <mi>γ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mrow>
     <mi>γ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msup>
       <mi>x</mi>
       <mo>′</mo>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">for-all</csymbol>
    <apply>
     <divide></divide>
     <apply>
      <csymbol cd="ambiguous">formulae-sequence</csymbol>
      <apply>
       <csymbol cd="latexml">for-all</csymbol>
       <ci>x</ci>
      </apply>
      <apply>
       <times></times>
       <ci>γ</ci>
       <ci>x</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>γ</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <ci>normal-′</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\forall)\frac{\forall x.\gamma(x)}{\gamma(x^{\prime})}
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Method_of_analytic_tableaux:89">
 <semantics>
  <msup>
   <mi>x</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>x</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{\prime}
  </annotation>
 </semantics>
</math>

 is a variable not occurring everywhere else in the tableau</p>

<p>While the initial set of formulae is supposed not to contain free variables, a formula of the tableau contain the free variables generated by this rule. These free variables are implicitly considered universally quantified.</p>

<p>This rule employs a variable instead of a ground term. The gain of this change is that these variables can be then given a value when a branch of the tableau can be closed, solving the problem of generating terms that might be useless.</p>
<dl>
<dd>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>

<math display="inline" id="Method_of_analytic_tableaux:90">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>σ</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <ci>σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\sigma)
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>if 

<math display="inline" id="Method_of_analytic_tableaux:91">
 <semantics>
  <mi>σ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma
  </annotation>
 </semantics>
</math>

 is the most general unifier of two literals 

<math display="inline" id="Method_of_analytic_tableaux:92">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Method_of_analytic_tableaux:93">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Method_of_analytic_tableaux:94">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 and the negation of 

<math display="inline" id="Method_of_analytic_tableaux:95">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

 occur in the same branch of the tableau, 

<math display="inline" id="Method_of_analytic_tableaux:96">
 <semantics>
  <mi>σ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma
  </annotation>
 </semantics>
</math>

 can be applied at the same time to all formulae of the tableau</p></td>
</tr>
</tbody>
</table>
</dd>
</dl>

<p>As an example, 

<math display="inline" id="Method_of_analytic_tableaux:97">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mrow>
    <mrow>
     <mrow>
      <mi mathvariant="normal">¬</mi>
      <mi>P</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>a</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mo>∀</mo>
      <mi>x</mi>
     </mrow>
    </mrow>
    <mo>.</mo>
    <mrow>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <csymbol cd="ambiguous">formulae-sequence</csymbol>
     <list>
      <apply>
       <times></times>
       <not></not>
       <ci>P</ci>
       <ci>a</ci>
      </apply>
      <apply>
       <csymbol cd="latexml">for-all</csymbol>
       <ci>x</ci>
      </apply>
     </list>
     <apply>
      <times></times>
      <ci>P</ci>
      <ci>x</ci>
     </apply>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{\neg P(a),\forall x.P(x)\}
  </annotation>
 </semantics>
</math>

 can be proved unsatisfiable by first generating 

<math display="inline" id="Method_of_analytic_tableaux:98">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(x_{1})
  </annotation>
 </semantics>
</math>

; the negation of this literal is unifiable with 

<math display="inline" id="Method_of_analytic_tableaux:99">
 <semantics>
  <mrow>
   <mi mathvariant="normal">¬</mi>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>a</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <not></not>
    <ci>P</ci>
    <ci>a</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg P(a)
  </annotation>
 </semantics>
</math>

, the most general unifier being the substitution that replaces 

<math display="inline" id="Method_of_analytic_tableaux:100">
 <semantics>
  <msub>
   <mi>x</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1}
  </annotation>
 </semantics>
</math>

 with 

<math display="inline" id="Method_of_analytic_tableaux:101">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

; applying this substitution results in replacing 

<math display="inline" id="Method_of_analytic_tableaux:102">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(x_{1})
  </annotation>
 </semantics>
</math>

 with 

<math display="inline" id="Method_of_analytic_tableaux:103">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>a</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <ci>a</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(a)
  </annotation>
 </semantics>
</math>

, which closes the tableau.</p>

<p>This rule closes at least a branch of the tableau -the one containing the considered pair of literals. However, the substitution has to be applied to the whole tableau, not only on these two literals. This is expressed by saying that the free variables of the tableau are <em>rigid</em>: if an occurrence of a variable is replaced by something else, all other occurrences of the same variable must be replaced in the same way. Formally, the free variables are (implicitly) universally quantified and all formulae of the tableau are within the scope of these quantifiers.</p>

<p>Existential quantifiers are dealt with by Skolemization. Contrary to the tableau without unification, Skolem terms may not be simple constant. Indeed, formulae in a tableau with unification may contain free variables, which are implicitly considered universally quantified. As a result, a formula like 

<math display="inline" id="Method_of_analytic_tableaux:104">
 <semantics>
  <mrow>
   <mrow>
    <mo>∃</mo>
    <mi>x</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>δ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <exists></exists>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <ci>δ</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \exists x.\delta(x)
  </annotation>
 </semantics>
</math>

 may be within the scope of universal quantifiers; if this is the case, the <a href="Skolem_term" title="wikilink">Skolem term</a> is not a simple constant but a term made of a new function symbol and the free variables of the formula.</p>

<p>

<math display="block" id="Method_of_analytic_tableaux:105">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>∃</mo>
    <mo stretchy="false">)</mo>
   </mrow>
   <mfrac>
    <mrow>
     <mrow>
      <mo>∃</mo>
      <mi>x</mi>
     </mrow>
     <mo>.</mo>
     <mrow>
      <mi>δ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mrow>
     <mi>δ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>f</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>x</mi>
         <mn>1</mn>
        </msub>
        <mo>,</mo>
        <mi mathvariant="normal">…</mi>
        <mo>,</mo>
        <msub>
         <mi>x</mi>
         <mi>n</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <exists></exists>
    <apply>
     <divide></divide>
     <apply>
      <csymbol cd="ambiguous">formulae-sequence</csymbol>
      <apply>
       <exists></exists>
       <ci>x</ci>
      </apply>
      <apply>
       <times></times>
       <ci>δ</ci>
       <ci>x</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>δ</ci>
      <apply>
       <times></times>
       <ci>f</ci>
       <vector>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <cn type="integer">1</cn>
        </apply>
        <ci>normal-…</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>n</ci>
        </apply>
       </vector>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\exists)\frac{\exists x.\delta(x)}{\delta(f(x_{1},\ldots,x_{n}))}
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Method_of_analytic_tableaux:106">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 is a new function symbol and 

<math display="inline" id="Method_of_analytic_tableaux:107">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>x</mi>
    <mi>n</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>n</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1},\ldots,x_{n}
  </annotation>
 </semantics>
</math>

 the free variables of 

<math display="inline" id="Method_of_analytic_tableaux:108">
 <semantics>
  <mi>δ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>δ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta
  </annotation>
 </semantics>
</math>

</p>

<p> This rule incorporates a simplification over a rule where 

<math display="inline" id="Method_of_analytic_tableaux:109">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>x</mi>
    <mi>n</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>n</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1},\ldots,x_{n}
  </annotation>
 </semantics>
</math>

 are the free variables of the branch, not of 

<math display="inline" id="Method_of_analytic_tableaux:110">
 <semantics>
  <mi>δ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>δ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta
  </annotation>
 </semantics>
</math>

 alone. This rule can be further simplified by the reuse of a function symbol if it has already been used in a formula that is identical to 

<math display="inline" id="Method_of_analytic_tableaux:111">
 <semantics>
  <mi>δ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>δ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta
  </annotation>
 </semantics>
</math>

 up to variable renaming.</p>

<p>The formula represented by a tableau is obtained in a way that is similar to the propositional case, with the additional assumption that free variables are considered universally quantified. As for the propositional case, formulae in each branch are conjoined and the resulting formulae are disjoined. In addition, all free variables of the resulting formula are universally quantified. All these quantifiers have the whole formula in their scope. In other words, if 

<math display="inline" id="Method_of_analytic_tableaux:112">
 <semantics>
  <mi>F</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>F</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F
  </annotation>
 </semantics>
</math>

 is the formula obtained by disjoining the conjunction of the formulae in each branch, and 

<math display="inline" id="Method_of_analytic_tableaux:113">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>x</mi>
    <mi>n</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>n</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1},\ldots,x_{n}
  </annotation>
 </semantics>
</math>

 are the free variables in it, then 

<math display="inline" id="Method_of_analytic_tableaux:114">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>∀</mo>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
    </mrow>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>x</mi>
     <mi>n</mi>
    </msub>
   </mrow>
   <mo>.</mo>
   <mi>F</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <list>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>n</ci>
     </apply>
    </list>
    <ci>F</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall x_{1},\ldots,x_{n}.F
  </annotation>
 </semantics>
</math>

 is the formula represented by the tableau. The following considerations apply:</p>
<ul>
<li>The assumption that free variables are universally quantified is what makes the application of a most general unifier a sound rule: since 

<math display="inline" id="Method_of_analytic_tableaux:115">
 <semantics>
  <mrow>
   <mi>γ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>x</mi>
     <mo>′</mo>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>γ</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <ci>normal-′</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gamma(x^{\prime})
  </annotation>
 </semantics>
</math>

 means that 

<math display="inline" id="Method_of_analytic_tableaux:116">
 <semantics>
  <mi>γ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>γ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gamma
  </annotation>
 </semantics>
</math>

 is true for every possible value of 

<math display="inline" id="Method_of_analytic_tableaux:117">
 <semantics>
  <msup>
   <mi>x</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>x</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{\prime}
  </annotation>
 </semantics>
</math>

, then 

<math display="inline" id="Method_of_analytic_tableaux:118">
 <semantics>
  <mrow>
   <mi>γ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>γ</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gamma(t)
  </annotation>
 </semantics>
</math>

 is true for the term 

<math display="inline" id="Method_of_analytic_tableaux:119">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 that the most general unifier replaces 

<math display="inline" id="Method_of_analytic_tableaux:120">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 with.</li>
</ul>
<ul>
<li>Free variables in a tableau are rigid: all occurrences of the same variable have to be replaced all with the same term. Every variable can be considered a symbol representing a term that is yet to be decided. This is a consequence of free variables being assumed universally quantified over the whole formula represented by the tableau: if the same variable occurs free in two different nodes, both occurrences are in the scope of the same quantifier. As an example, if the formulae in two nodes are 

<math display="inline" id="Method_of_analytic_tableaux:121">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>A</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A(x)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Method_of_analytic_tableaux:122">
 <semantics>
  <mrow>
   <mi>B</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>B</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B(x)
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Method_of_analytic_tableaux:123">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 is free in both, the formula represented by the tableau is something in the form 

<math display="inline" id="Method_of_analytic_tableaux:124">
 <semantics>
  <mrow>
   <mrow>
    <mo>∀</mo>
    <mi>x</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi mathvariant="normal">…</mi>
     <mi>A</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi mathvariant="normal">…</mi>
     <mi>B</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi mathvariant="normal">…</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <csymbol cd="latexml">for-all</csymbol>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <ci>normal-…</ci>
     <ci>A</ci>
     <ci>x</ci>
     <ci>normal-…</ci>
     <ci>B</ci>
     <ci>x</ci>
     <ci>normal-…</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall x.(...A(x)...B(x)...)
  </annotation>
 </semantics>
</math>

. This formula implies that 

<math display="inline" id="Method_of_analytic_tableaux:125">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi mathvariant="normal">…</mi>
    <mi>A</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi mathvariant="normal">…</mi>
    <mi>B</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi mathvariant="normal">…</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-…</ci>
    <ci>A</ci>
    <ci>x</ci>
    <ci>normal-…</ci>
    <ci>B</ci>
    <ci>x</ci>
    <ci>normal-…</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (...A(x)...B(x)...)
  </annotation>
 </semantics>
</math>

 is true for any value of 

<math display="inline" id="Method_of_analytic_tableaux:126">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

, but does not in general imply 

<math display="inline" id="Method_of_analytic_tableaux:127">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi mathvariant="normal">…</mi>
    <mi>A</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi mathvariant="normal">…</mi>
    <mi>A</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>t</mi>
      <mo>′</mo>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi mathvariant="normal">…</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-…</ci>
    <ci>A</ci>
    <ci>t</ci>
    <ci>normal-…</ci>
    <ci>A</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>t</ci>
     <ci>normal-′</ci>
    </apply>
    <ci>normal-…</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (...A(t)...A(t^{\prime})...)
  </annotation>
 </semantics>
</math>

 for two different terms 

<math display="inline" id="Method_of_analytic_tableaux:128">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Method_of_analytic_tableaux:129">
 <semantics>
  <msup>
   <mi>t</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>t</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t^{\prime}
  </annotation>
 </semantics>
</math>

, as these two terms may in general take different values. This means that 

<math display="inline" id="Method_of_analytic_tableaux:130">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 cannot be replaced by two different terms in 

<math display="inline" id="Method_of_analytic_tableaux:131">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>A</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A(x)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Method_of_analytic_tableaux:132">
 <semantics>
  <mrow>
   <mi>B</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>B</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B(x)
  </annotation>
 </semantics>
</math>

.</li>
</ul>
<ul>
<li>Free variables in a formula to check for validity are also considered universally quantified. However, these variables cannot be left free when building a tableau, because tableau rules works on the converse of the formula but still treats free variables as universally quantified. For example, 

<math display="inline" id="Method_of_analytic_tableaux:133">
 <semantics>
  <mrow>
   <mrow>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>c</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <times></times>
     <ci>P</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <ci>P</ci>
     <ci>c</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(x)\rightarrow P(c)
  </annotation>
 </semantics>
</math>

 is not valid (it is not true in the model where 

<math display="inline" id="Method_of_analytic_tableaux:134">
 <semantics>
  <mrow>
   <mrow>
    <mi>D</mi>
    <mo>=</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mn>1</mn>
     <mo>,</mo>
     <mn>2</mn>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mrow>
     <mrow>
      <mi>P</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mn>1</mn>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>=</mo>
     <mo>⊥</mo>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mrow>
      <mrow>
       <mi>P</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mn>2</mn>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>=</mo>
      <mo>⊤</mo>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mi>c</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <ci>D</ci>
     <set>
      <cn type="integer">1</cn>
      <cn type="integer">2</cn>
     </set>
    </apply>
    <apply>
     <csymbol cd="ambiguous">formulae-sequence</csymbol>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <ci>P</ci>
       <cn type="integer">1</cn>
      </apply>
      <csymbol cd="latexml">bottom</csymbol>
     </apply>
     <apply>
      <csymbol cd="ambiguous">formulae-sequence</csymbol>
      <apply>
       <eq></eq>
       <apply>
        <times></times>
        <ci>P</ci>
        <cn type="integer">2</cn>
       </apply>
       <csymbol cd="latexml">top</csymbol>
      </apply>
      <apply>
       <eq></eq>
       <ci>c</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D=\{1,2\},P(1)=\bot,P(2)=\top,c=1
  </annotation>
 </semantics>
</math>

, and the interpretation where 

<math display="inline" id="Method_of_analytic_tableaux:135">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>=</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>x</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x=2
  </annotation>
 </semantics>
</math>

). Consequently, 

<math display="inline" id="Method_of_analytic_tableaux:136">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mrow>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi mathvariant="normal">¬</mi>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>c</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <times></times>
     <ci>P</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <not></not>
     <ci>P</ci>
     <ci>c</ci>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{P(x),\neg P(c)\}
  </annotation>
 </semantics>
</math>

 is satisfiable (it is satisfied by the same model and interpretation). However, a closed tableau could be generated with 

<math display="inline" id="Method_of_analytic_tableaux:137">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(x)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Method_of_analytic_tableaux:138">
 <semantics>
  <mrow>
   <mi mathvariant="normal">¬</mi>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>c</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <not></not>
    <ci>P</ci>
    <ci>c</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg P(c)
  </annotation>
 </semantics>
</math>

, and substituting 

<math display="inline" id="Method_of_analytic_tableaux:139">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 with 

<math display="inline" id="Method_of_analytic_tableaux:140">
 <semantics>
  <mi>c</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>c</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c
  </annotation>
 </semantics>
</math>

 would generate a closure. A correct procedure is to first make universal quantifiers explicit, thus generating 

<math display="inline" id="Method_of_analytic_tableaux:141">
 <semantics>
  <mrow>
   <mo>∀</mo>
   <mi>x</mi>
   <mo>.</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>→</mo>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>c</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <ci>normal-.</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">P</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-→</ci>
     <csymbol cd="unknown">P</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">c</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall x.(P(x)\rightarrow P(c))
  </annotation>
 </semantics>
</math>

.</li>
</ul>

<p>The following two variants are also correct.</p>
<ul>
<li>Applying to the whole tableau a substitution to the free variables of the tableau is a correct rule, provided that this substitution is free for the formula representing the tableau. In other worlds, applying such a substitution leads to a tableau whose formula is still a consequence of the input set. Using most general unifiers automatically ensures that the condition of freeness for the tableau is met.</li>
</ul>
<ul>
<li>While in general every variable has to be replaced with the same term in the whole tableau, there are some special cases in which this is not necessary.</li>
</ul>

<p>Tableaux with unification can be proved complete: if a set of formulae is unsatisfiable, it has a tableau-with-unification proof. However, actually finding such a proof may be a difficult problem. Contrarily to the case without unification, applying a substitution can modify the existing part of a tableau; while applying a substitution closes at least a branch, it may make other branches impossible to close (even if the set is unsatisfiable).</p>

<p>A solution to this problem is that <em>delayed instantiation</em>: no substitution is applied until one that closes all branches at the same time is found. With this variant, a proof for an unsatisfiable set can always be found by a suitable policy of application of the other rules. This method however requires the whole tableau to be kept in memory: the general method closes branches which can be then discarded, while this variant does not close any branch until the end.</p>

<p>The problem that some tableaux that can be generated are impossible to close even if the set is unsatisfiable is common to other sets of tableau expansion rules: even if some specific sequences of application of these rules allow constructing a closed tableau (if the set is unsatisfiable), some other sequences lead to tableau that cannot be closed. General solutions for these cases are outlined in the "Searching for a tableau" section.</p>
<h2 id="tableau-calculi-and-their-properties">Tableau calculi and their properties</h2>

<p>A tableau calculus is a set of rules that allows building and modification of a tableau. Propositional tableau rules, tableau rules without unification, and tableau rules with unification, are all tableau calculi. Some important properties a tableau calculus may or may not possess are completeness, destructiveness, and proof confluence.</p>

<p>A tableau calculi is called complete if it allows building a tableau proof for every given unsatisfiable set of formulae. The tableau calculi mentioned above can be proved complete.</p>

<p>A remarkable difference between tableau with unification and the other two calculi is that the latter two calculi only modify a tableau by adding new nodes to it, while the former one allows substitutions to modify the existing part of the tableau. More generally, tableau calculi are classed as <em>destructive</em> or <em>non-destructive</em> depending on whether they only add new nodes to tableau or not. Tableau with unification is therefore destructive, while propositional tableau and tableau without unification are non-destructive.</p>

<p>Proof confluence is the property of a tableau calculus to obtain a proof for an arbitrary unsatisfiable set from an arbitrary tableau, assuming that this tableau has itself been obtained by applying the rules of the calculus. In other words, in a proof confluent tableau calculus, from an unsatisfiable set one can apply whatever set of rules and still obtain a tableau from which a closed one can be obtained by applying some other rules.</p>
<h2 id="proof-procedures">Proof procedures</h2>

<p>A tableau calculus is simply a set of rules that tells how a tableau can be modified. A proof procedure is a method for actually finding a proof (if one exists). In other words, a tableau calculus is a set of rules, while a proof procedure is a policy of application of these rules. Even if a calculus is complete, not every possible choice of application of rules leads to a proof of an unsatisfiable set. For example 

<math display="inline" id="Method_of_analytic_tableaux:142">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mrow>
    <mrow>
     <mrow>
      <mi>P</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>f</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>x</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mi>R</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>c</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mrow>
       <mi mathvariant="normal">¬</mi>
       <mi>P</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>f</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>c</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>∨</mo>
      <mrow>
       <mi mathvariant="normal">¬</mi>
       <mi>R</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>c</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mo>∀</mo>
      <mi>x</mi>
     </mrow>
    </mrow>
    <mo>.</mo>
    <mrow>
     <mi>Q</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <csymbol cd="ambiguous">formulae-sequence</csymbol>
     <list>
      <apply>
       <times></times>
       <ci>P</ci>
       <apply>
        <times></times>
        <ci>f</ci>
        <ci>x</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>R</ci>
       <ci>c</ci>
      </apply>
      <apply>
       <or></or>
       <apply>
        <times></times>
        <not></not>
        <ci>P</ci>
        <apply>
         <times></times>
         <ci>f</ci>
         <ci>c</ci>
        </apply>
       </apply>
       <apply>
        <times></times>
        <not></not>
        <ci>R</ci>
        <ci>c</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="latexml">for-all</csymbol>
       <ci>x</ci>
      </apply>
     </list>
     <apply>
      <times></times>
      <ci>Q</ci>
      <ci>x</ci>
     </apply>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{P(f(x)),R(c),\neg P(f(c))\vee\neg R(c),\forall x.Q(x)\}
  </annotation>
 </semantics>
</math>

 is unsatisfiable, but both tableaux with unification and tableaux without unification allow the rule for the universal quantifiers to be applied repeatedly to the last formula, while simply applying the rule for disjunction to the third one would directly lead to closure.</p>

<p>For proof procedures, a definition of completeness has been given: a proof procedure is strongly complete if it allows finding a closed tableau for any given unsatisfiable set of formulae. Proof confluence of the underlying calculus is relevant to completeness: proof confluence is the guarantee that a closed tableau can be always generated from an arbitrary partially constructed tableau (if the set is unsatisfiable). Without proof confluence, the application of a 'wrong' rule may result in the impossibility of making the tableau complete by applying other rules.</p>

<p>Propositional tableaux and tableaux without unification have strongly complete proof procedures. In particular, a complete proof procedure is that of applying the rules in a <em>fair</em> way. This is because the only way such calculi cannot generate a closed tableau from an unsatisfiable set is by not applying some applicable rules.</p>

<p>For propositional tableaux, fairness amounts to expanding every formula in every branch. More precisely, for every formula and every branch the formula is in, the rule having the formula as a precondition has been used to expand the branch. A fair proof procedure for propositional tableaux is strongly complete.</p>

<p>For first-order tableaux without unification, the condition of fairness is similar, with the exception that the rule for universal quantifier might require more than one application. Fairness amounts to expanding every universal quantifier infinitely often. In other words, a fair policy of application of rules cannot keep applying other rules without expanding every universal quantifier in every branch that is still open once in a while.</p>
<h2 id="searching-for-a-closed-tableau">Searching for a closed tableau</h2>

<p>If a tableau calculus is complete, every unsatisfiable set of formulae has an associated closed tableau. While this tableau can always be obtained by applying some of the rules of the calculus, the problem of which rules to apply for a given formula still remains. As a result, completeness does not automatically imply the existence of a feasible policy of application of rules that always leads to a closed tableau for every given unsatisfiable set of formulae. While a fair proof procedure is complete for ground tableau and tableau without unification, this is not the case for tableau with unification.</p>

<p> A general solution for this problem is that of searching the space of tableaux until a closed one is found (if any exists, that is, the set is unsatisfiable). In this approach, one starts with an empty tableau and then recursively applies every possible applicable rule. This procedure visits a (implicit) tree whose nodes are labeled with tableaux, and such that the tableau in a node is obtained from the tableau in its parent by applying one of the valid rules.</p>

<p>Since each branch can be infinite, this tree has to be visited breadth-first rather than depth-first. This requires a large amount of space, as the breadth of the tree can grow exponentially. A method that may visit some nodes more than once but works in polynomial space is to visit in a depth-first manner with <a href="iterative_deepening" title="wikilink">iterative deepening</a>: one first visits the tree up to a certain depth, then increases the depth and perform the visit again. This particular procedure uses the depth (which is also the number of tableau rules that have been applied) for deciding when to stop at each step. Various other parameters (such as the size of the tableau labeling a node) have been used instead.</p>
<h3 id="reducing-search">Reducing search</h3>

<p>The size of the search tree depends on the number of (children) tableau that can be generated from a given (parent) one. Reducing the number of such tableau therefore reduces the required search.</p>

<p>A way for reducing this number is to disallow the generation of some tableau based on their internal structure. An example is the condition of regularity: if a branch contains a literal, using an expansion rule that generates the same literal is useless because the branch containing two copies of the literals would have the same set of formulae of the original one. This expansion can be disallowed because if a closed tableau exists, it can be found without it. This restriction is structural because it can be checked by looking at the structure of the tableau to expand only.</p>

<p>Different methods for reducing search disallow the generation of some tableau on the ground that a closed tableau can still be found by expanding the other ones. These restrictions are called global. As an example of a global restriction, one may employ a rule that specify which of the open branches is to be expanded. As a result, if a tableau has for example two non-closed branches, the rule tells which one is to be expanded, disallowing the expansion of the second one. This restriction reduces the search space because one possible choice is now forbidden; completeness if however not harmed, as the second branch will still be expanded if the first one is eventually closed. As an example, a tableau with root 

<math display="inline" id="Method_of_analytic_tableaux:143">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">¬</mi>
    <mi>a</mi>
   </mrow>
   <mo>∧</mo>
   <mrow>
    <mi mathvariant="normal">¬</mi>
    <mi>b</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <times></times>
     <not></not>
     <ci>a</ci>
    </apply>
    <apply>
     <times></times>
     <not></not>
     <ci>b</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg a\wedge\neg b
  </annotation>
 </semantics>
</math>

, child 

<math display="inline" id="Method_of_analytic_tableaux:144">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo>∨</mo>
   <mi>b</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <or></or>
    <ci>a</ci>
    <ci>b</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a\vee b
  </annotation>
 </semantics>
</math>

, and two leaves 

<math display="inline" id="Method_of_analytic_tableaux:145">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Method_of_analytic_tableaux:146">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>

 can be closed in two ways: applying 

<math display="inline" id="Method_of_analytic_tableaux:147">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mo>∧</mo>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <and></and>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\wedge)
  </annotation>
 </semantics>
</math>

 first to 

<math display="inline" id="Method_of_analytic_tableaux:148">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 and then to 

<math display="inline" id="Method_of_analytic_tableaux:149">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>

, or vice versa. There is clearly no need to follow both possibilities; one may consider only the case in which 

<math display="inline" id="Method_of_analytic_tableaux:150">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mo>∧</mo>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <and></and>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\wedge)
  </annotation>
 </semantics>
</math>

 is first applied to 

<math display="inline" id="Method_of_analytic_tableaux:151">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 and disregard the case in which it is first applied to 

<math display="inline" id="Method_of_analytic_tableaux:152">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>

. This is a global restriction because what allows neglecting this second expansion is the presence of the other tableau, where expansion is applied to 

<math display="inline" id="Method_of_analytic_tableaux:153">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 first and 

<math display="inline" id="Method_of_analytic_tableaux:154">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>

 afterwards.</p>
<h2 id="clause-tableaux">Clause tableaux</h2>

<p>When applied to sets of <a href="Clause_(logic)" title="wikilink">clauses</a> (rather than of arbitrary formulae), tableaux methods allow for a number of efficiency improvements. A first-order clause is a formula 

<math display="inline" id="Method_of_analytic_tableaux:155">
 <semantics>
  <mrow>
   <mrow>
    <mo>∀</mo>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
   </mrow>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>x</mi>
      <mi>n</mi>
     </msub>
     <msub>
      <mi>L</mi>
      <mn>1</mn>
     </msub>
    </mrow>
    <mo>∨</mo>
    <mi mathvariant="normal">⋯</mi>
    <mo>∨</mo>
    <msub>
     <mi>L</mi>
     <mi>m</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="latexml">for-all</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <or></or>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>L</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>normal-⋯</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>L</ci>
      <ci>m</ci>
     </apply>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall x_{1},\ldots,x_{n}L_{1}\vee\cdots\vee L_{m}
  </annotation>
 </semantics>
</math>

 that does not contain free variables and such that each 

<math display="inline" id="Method_of_analytic_tableaux:156">
 <semantics>
  <msub>
   <mi>L</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>L</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L_{i}
  </annotation>
 </semantics>
</math>

 is a literal. The universal quantifiers are often omitted for clarity, so that for example 

<math display="inline" id="Method_of_analytic_tableaux:157">
 <semantics>
  <mrow>
   <mrow>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>∨</mo>
   <mrow>
    <mi>Q</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <or></or>
    <apply>
     <times></times>
     <ci>P</ci>
     <interval closure="open">
      <ci>x</ci>
      <ci>y</ci>
     </interval>
    </apply>
    <apply>
     <times></times>
     <ci>Q</ci>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(x,y)\vee Q(f(x))
  </annotation>
 </semantics>
</math>

 actually means 

<math display="inline" id="Method_of_analytic_tableaux:158">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>∀</mo>
     <mi>x</mi>
    </mrow>
    <mo>,</mo>
    <mi>y</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mrow>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mi>y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>∨</mo>
    <mrow>
     <mi>Q</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>f</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <list>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <ci>x</ci>
     </apply>
     <ci>y</ci>
    </list>
    <apply>
     <or></or>
     <apply>
      <times></times>
      <ci>P</ci>
      <interval closure="open">
       <ci>x</ci>
       <ci>y</ci>
      </interval>
     </apply>
     <apply>
      <times></times>
      <ci>Q</ci>
      <apply>
       <times></times>
       <ci>f</ci>
       <ci>x</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall x,y.P(x,y)\vee Q(f(x))
  </annotation>
 </semantics>
</math>

. Note that, if taken literally, these two formulae are not the same as for satisfiability: rather, the satisfiability 

<math display="inline" id="Method_of_analytic_tableaux:159">
 <semantics>
  <mrow>
   <mrow>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>∨</mo>
   <mrow>
    <mi>Q</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <or></or>
    <apply>
     <times></times>
     <ci>P</ci>
     <interval closure="open">
      <ci>x</ci>
      <ci>y</ci>
     </interval>
    </apply>
    <apply>
     <times></times>
     <ci>Q</ci>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(x,y)\vee Q(f(x))
  </annotation>
 </semantics>
</math>

 is the same as that of 

<math display="inline" id="Method_of_analytic_tableaux:160">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>∃</mo>
     <mi>x</mi>
    </mrow>
    <mo>,</mo>
    <mi>y</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mrow>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mi>y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>∨</mo>
    <mrow>
     <mi>Q</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>f</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <list>
     <apply>
      <exists></exists>
      <ci>x</ci>
     </apply>
     <ci>y</ci>
    </list>
    <apply>
     <or></or>
     <apply>
      <times></times>
      <ci>P</ci>
      <interval closure="open">
       <ci>x</ci>
       <ci>y</ci>
      </interval>
     </apply>
     <apply>
      <times></times>
      <ci>Q</ci>
      <apply>
       <times></times>
       <ci>f</ci>
       <ci>x</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \exists x,y.P(x,y)\vee Q(f(x))
  </annotation>
 </semantics>
</math>

. That free variables are universally quantified is not a consequence of the definition of first-order satisfiability; it is rather used as an implicit common assumption when dealing with clauses.</p>

<p>The only expansion rules that are applicable to a clause are 

<math display="inline" id="Method_of_analytic_tableaux:161">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mo>∀</mo>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">for-all</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\forall)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Method_of_analytic_tableaux:162">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mo>∨</mo>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <or></or>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\vee)
  </annotation>
 </semantics>
</math>

; these two rules can be replaced by their combination without losing completeness. In particular, the following rule corresponds to applying in sequence the rules 

<math display="inline" id="Method_of_analytic_tableaux:163">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mo>∀</mo>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">for-all</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\forall)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Method_of_analytic_tableaux:164">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mo>∨</mo>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <or></or>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\vee)
  </annotation>
 </semantics>
</math>

 of the first-order calculus with unification.</p>

<p>

<math display="block" id="Method_of_analytic_tableaux:165">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>C</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mfrac>
    <mrow>
     <msub>
      <mi>L</mi>
      <mn>1</mn>
     </msub>
     <mo>∨</mo>
     <mi mathvariant="normal">⋯</mi>
     <mo>∨</mo>
     <msub>
      <mi>L</mi>
      <mi>n</mi>
     </msub>
    </mrow>
    <mrow>
     <msubsup>
      <mi>L</mi>
      <mn>1</mn>
      <mo>′</mo>
     </msubsup>
     <mrow>
      <mo stretchy="false">|</mo>
      <mi mathvariant="normal">⋯</mi>
      <mo stretchy="false">|</mo>
     </mrow>
     <msubsup>
      <mi>L</mi>
      <mi>n</mi>
      <mo>′</mo>
     </msubsup>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>C</ci>
    <apply>
     <divide></divide>
     <apply>
      <or></or>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>L</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-⋯</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>L</ci>
       <ci>n</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>L</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>normal-′</ci>
      </apply>
      <apply>
       <abs></abs>
       <ci>normal-⋯</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>L</ci>
        <ci>n</ci>
       </apply>
       <ci>normal-′</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (C)\frac{L_{1}\vee\cdots\vee L_{n}}{L_{1}^{\prime}|\cdots|L_{n}^{\prime}}
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Method_of_analytic_tableaux:166">
 <semantics>
  <mrow>
   <msubsup>
    <mi>L</mi>
    <mn>1</mn>
    <mo>′</mo>
   </msubsup>
   <mo>∨</mo>
   <mi mathvariant="normal">⋯</mi>
   <mo>∨</mo>
   <msubsup>
    <mi>L</mi>
    <mi>n</mi>
    <mo>′</mo>
   </msubsup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <or></or>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>L</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-′</ci>
    </apply>
    <ci>normal-⋯</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>L</ci>
      <ci>n</ci>
     </apply>
     <ci>normal-′</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L_{1}^{\prime}\vee\cdots\vee L_{n}^{\prime}
  </annotation>
 </semantics>
</math>

 is obtained by replacing every variable with a new one in 

<math display="inline" id="Method_of_analytic_tableaux:167">
 <semantics>
  <mrow>
   <msub>
    <mi>L</mi>
    <mn>1</mn>
   </msub>
   <mo>∨</mo>
   <mi mathvariant="normal">⋯</mi>
   <mo>∨</mo>
   <msub>
    <mi>L</mi>
    <mi>n</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <or></or>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>L</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-⋯</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>L</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L_{1}\vee\cdots\vee L_{n}
  </annotation>
 </semantics>
</math>

</p>

<p>When the set to be checked for satisfiability is only composed of clauses, this and the unification rules are sufficient to prove unsatisfiability. In other worlds, the tableau calculi composed of 

<math display="inline" id="Method_of_analytic_tableaux:168">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>C</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (C)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Method_of_analytic_tableaux:169">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>σ</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <ci>σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\sigma)
  </annotation>
 </semantics>
</math>

 is complete.</p>

<p>Since the clause expansion rule only generates literals and never new clauses, the clauses to which it can be applied are only clauses of the input set. As a result, the clause expansion rule can be further restricted to the case where the clause is in the input set.</p>

<p>

<math display="block" id="Method_of_analytic_tableaux:170">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>C</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mfrac>
    <mrow>
     <msub>
      <mi>L</mi>
      <mn>1</mn>
     </msub>
     <mo>∨</mo>
     <mi mathvariant="normal">⋯</mi>
     <mo>∨</mo>
     <msub>
      <mi>L</mi>
      <mi>n</mi>
     </msub>
    </mrow>
    <mrow>
     <msubsup>
      <mi>L</mi>
      <mn>1</mn>
      <mo>′</mo>
     </msubsup>
     <mrow>
      <mo stretchy="false">|</mo>
      <mi mathvariant="normal">⋯</mi>
      <mo stretchy="false">|</mo>
     </mrow>
     <msubsup>
      <mi>L</mi>
      <mi>n</mi>
      <mo>′</mo>
     </msubsup>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>C</ci>
    <apply>
     <divide></divide>
     <apply>
      <or></or>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>L</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-⋯</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>L</ci>
       <ci>n</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>L</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>normal-′</ci>
      </apply>
      <apply>
       <abs></abs>
       <ci>normal-⋯</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>L</ci>
        <ci>n</ci>
       </apply>
       <ci>normal-′</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (C)\frac{L_{1}\vee\cdots\vee L_{n}}{L_{1}^{\prime}|\cdots|L_{n}^{\prime}}
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Method_of_analytic_tableaux:171">
 <semantics>
  <mrow>
   <msubsup>
    <mi>L</mi>
    <mn>1</mn>
    <mo>′</mo>
   </msubsup>
   <mo>∨</mo>
   <mi mathvariant="normal">⋯</mi>
   <mo>∨</mo>
   <msubsup>
    <mi>L</mi>
    <mi>n</mi>
    <mo>′</mo>
   </msubsup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <or></or>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>L</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-′</ci>
    </apply>
    <ci>normal-⋯</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>L</ci>
      <ci>n</ci>
     </apply>
     <ci>normal-′</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L_{1}^{\prime}\vee\cdots\vee L_{n}^{\prime}
  </annotation>
 </semantics>
</math>

 is obtained by replacing every variable with a new one in 

<math display="inline" id="Method_of_analytic_tableaux:172">
 <semantics>
  <mrow>
   <msub>
    <mi>L</mi>
    <mn>1</mn>
   </msub>
   <mo>∨</mo>
   <mi mathvariant="normal">⋯</mi>
   <mo>∨</mo>
   <msub>
    <mi>L</mi>
    <mi>n</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <or></or>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>L</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-⋯</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>L</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L_{1}\vee\cdots\vee L_{n}
  </annotation>
 </semantics>
</math>

, which is a clause of the input set</p>

<p>Since this rule directly exploit the clauses in the input set there is no need to initialize the tableau to the chain of the input clauses. The initial tableau can therefore be initialize with the single node labeled 

<math display="inline" id="Method_of_analytic_tableaux:173">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mi>r</mi>
   <mi>u</mi>
   <mi>e</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>t</ci>
    <ci>r</ci>
    <ci>u</ci>
    <ci>e</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   true
  </annotation>
 </semantics>
</math>

; this label is often omitted as implicit. As a result of this further simplification, every node of the tableau (apart from the root) is labeled with a literal.</p>

<p>A number of optimizations can be used for clause tableau. These optimization are aimed at reducing the number of possible tableaux to be explored when searching for a closed tableau as described in the "Searching for a closed tableau" section above.</p>
<h3 id="connection-tableau">Connection tableau</h3>

<p>Connection is a condition over tableau that forbids expanding a branch using clauses that are unrelated to the literals that are already in the branch. Connection can be defined in two ways:</p>
<dl>
<dt>strong connectedness : when expanding a branch, use an input clause only if it contains a literal that can be unified with the negation of the literal in the current leaf<br/>
weak connectedness : allow the use of clauses that contain a literal that unifies with the negation of a literal on the branch</dt>
</dl>

<p>Both conditions apply only to branches consisting not only of the root. The second definition allows for the use of a clause containing a literal that unifies with the negation of a literal in the branch, while the first only further constraint that literal to be in leaf of the current branch.</p>

<p>If clause expansion is restricted by connectedness (either strong or weak), its application produces a tableau in which substitution can applied to one of the new leaves, closing its branch. In particular, this is the leaf containing the literal of the clause that unifies with the negation of a literal in the branch (or the negation of the literal in the parent, in case of strong connection).</p>

<p>Both conditions of connectedness lead to a complete first-order calculus: if a set of clauses is unsatisfiable, it has a closed connected (strongly or weakly) tableau. Such a closed tableau can be found by searching in the space of tableaux as explained in the "Searching for a closed tableau" section. During this search, connectedness eliminates some possible choices of expansion, thus reducing search. In other worlds, while the tableau in a node of the tree can be in general expanded in several different ways, connection may allow only few of them, thus reducing the number of resulting tableaux that need to be further expanded.</p>

<p>This can be seen on the following (propositional) example. The tableau made of a chain 

<math display="inline" id="Method_of_analytic_tableaux:174">
 <semantics>
  <mrow>
   <mrow>
    <mi>t</mi>
    <mi>r</mi>
    <mi>u</mi>
    <mi>e</mi>
   </mrow>
   <mo>-</mo>
   <mi>a</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <apply>
     <times></times>
     <ci>t</ci>
     <ci>r</ci>
     <ci>u</ci>
     <ci>e</ci>
    </apply>
    <ci>a</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   true-a
  </annotation>
 </semantics>
</math>

 for the set of clauses 

<math display="inline" id="Method_of_analytic_tableaux:175">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mi>a</mi>
   <mo>,</mo>
   <mrow>
    <mrow>
     <mi mathvariant="normal">¬</mi>
     <mi>a</mi>
    </mrow>
    <mo>∨</mo>
    <mi>b</mi>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mrow>
     <mi mathvariant="normal">¬</mi>
     <mi>c</mi>
    </mrow>
    <mo>∨</mo>
    <mi>d</mi>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi mathvariant="normal">¬</mi>
    <mi>b</mi>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <ci>a</ci>
    <apply>
     <or></or>
     <apply>
      <times></times>
      <not></not>
      <ci>a</ci>
     </apply>
     <ci>b</ci>
    </apply>
    <apply>
     <or></or>
     <apply>
      <times></times>
      <not></not>
      <ci>c</ci>
     </apply>
     <ci>d</ci>
    </apply>
    <apply>
     <times></times>
     <not></not>
     <ci>b</ci>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{a,\neg a\vee b,\neg c\vee d,\neg b\}
  </annotation>
 </semantics>
</math>

 can be in general expanded using each of the four input clauses, but connection only allows the expansion that uses 

<math display="inline" id="Method_of_analytic_tableaux:176">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">¬</mi>
    <mi>a</mi>
   </mrow>
   <mo>∨</mo>
   <mi>b</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <or></or>
    <apply>
     <times></times>
     <not></not>
     <ci>a</ci>
    </apply>
    <ci>b</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg a\vee b
  </annotation>
 </semantics>
</math>

. This means that the tree of tableaux has four leaves in general but only one if connectedness is imposed. This means that connectedness leaves only one tableau to try to expand, instead of the four ones to consider in general. In spite of this reduction of choices, the completeness theorem implies that a closed tableau can be found if the set is unsatisfiable.</p>

<p>The connectedness conditions, when applied to the propositional (clausal) case, make the resulting calculus non-confluent. As an example, 

<math display="inline" id="Method_of_analytic_tableaux:177">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mi>a</mi>
   <mo>,</mo>
   <mi>b</mi>
   <mo>,</mo>
   <mrow>
    <mi mathvariant="normal">¬</mi>
    <mi>b</mi>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <ci>a</ci>
    <ci>b</ci>
    <apply>
     <times></times>
     <not></not>
     <ci>b</ci>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{a,b,\neg b\}
  </annotation>
 </semantics>
</math>

 is unsatisfiable, but applying 

<math display="inline" id="Method_of_analytic_tableaux:178">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>C</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (C)
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Method_of_analytic_tableaux:179">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 generates the chain 

<math display="inline" id="Method_of_analytic_tableaux:180">
 <semantics>
  <mrow>
   <mrow>
    <mi>t</mi>
    <mi>r</mi>
    <mi>u</mi>
    <mi>e</mi>
   </mrow>
   <mo>-</mo>
   <mi>a</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <apply>
     <times></times>
     <ci>t</ci>
     <ci>r</ci>
     <ci>u</ci>
     <ci>e</ci>
    </apply>
    <ci>a</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   true-a
  </annotation>
 </semantics>
</math>

, which is not closed and to which no other expansion rule can be applied without violating either strong or weak connectedness. In the case of weak connectedness, confluence holds provided that the clause used for expanding the root is relevant to unsatisfiability, that is, it is contained in a minimally unsatisfiable subset of the set of clauses. Unfortunately, the problem of checking whether a clause meets this condition is itself a hard problem. In spite of non-confluence, a closed tableau can be found using search, as presented in the "Searching for a closed tableau" section above. While search is made necessary, connectedness reduces the possible choices of expansion, thus making search more efficient.</p>
<h3 id="regular-tableaux">Regular tableaux</h3>

<p>A tableau is regular if no literal occurs twice in the same branch. Enforcing this condition allows for a reduction of the possible choices of tableau expansion, as the clauses that would generate a non-regular tableau cannot be expanded.</p>

<p>These disallowed expansion steps are however useless. If 

<math display="inline" id="Method_of_analytic_tableaux:181">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

 is a branch containing a literal 

<math display="inline" id="Method_of_analytic_tableaux:182">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="Method_of_analytic_tableaux:183">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

 is a clause whose expansion violates regularity, then 

<math display="inline" id="Method_of_analytic_tableaux:184">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

 contains 

<math display="inline" id="Method_of_analytic_tableaux:185">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

. In order to close the tableau, one needs to expand and close, among others, the branch where 

<math display="inline" id="Method_of_analytic_tableaux:186">
 <semantics>
  <mrow>
   <mi>B</mi>
   <mo>-</mo>
   <mi>L</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>B</ci>
    <ci>L</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B-L
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Method_of_analytic_tableaux:187">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

 occurs twice. However, the formulae in this branch are exactly the same as the formulae of 

<math display="inline" id="Method_of_analytic_tableaux:188">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

 alone. As a result, the same expansion steps that close 

<math display="inline" id="Method_of_analytic_tableaux:189">
 <semantics>
  <mrow>
   <mi>B</mi>
   <mo>-</mo>
   <mi>L</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>B</ci>
    <ci>L</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B-L
  </annotation>
 </semantics>
</math>

 also close 

<math display="inline" id="Method_of_analytic_tableaux:190">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

. This means that expanding 

<math display="inline" id="Method_of_analytic_tableaux:191">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

 was unnecessary; moreover, if 

<math display="inline" id="Method_of_analytic_tableaux:192">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

 contained other literals, its expansion generated other leaves that needed to be closed. In the propositional case, the expansion needed to close these leaves are completely useless; in the first-order case, they may only affect the rest of the tableau because of some unifications; these can however be combined to the substitutions used to close the rest of the tableau.</p>
<h2 id="tableaux-for-modal-logics">Tableaux for modal logics</h2>

<p>In a <a href="modal_logic" title="wikilink">modal logic</a>, a model comprises a set of <em>possible worlds</em>, each one associated to a truth evaluation; an <em>accessibility relation</em> tells when a world is <em>accessible</em> from another one. A modal formula may specify not only conditions over a possible world, but also on the ones that are accessible from it. As an example, 

<math display="inline" id="Method_of_analytic_tableaux:193">
 <semantics>
  <mrow>
   <mi mathvariant="normal">□</mi>
   <mi>A</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-□</ci>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Box A
  </annotation>
 </semantics>
</math>

 is true in a world if 

<math display="inline" id="Method_of_analytic_tableaux:194">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 is true in all worlds that are accessible from it.</p>

<p>As for propositional logic, tableaux for modal logics are based on recursively breaking formulae into its basic components. Expanding a modal formula may however require stating conditions over different worlds. As an example, if 

<math display="inline" id="Method_of_analytic_tableaux:195">
 <semantics>
  <mrow>
   <mi mathvariant="normal">¬</mi>
   <mi mathvariant="normal">□</mi>
   <mi>A</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <not></not>
    <ci>normal-□</ci>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg\Box A
  </annotation>
 </semantics>
</math>

 is true in a world then there exists a world accessible from it where 

<math display="inline" id="Method_of_analytic_tableaux:196">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 is false. However, one cannot simply add the following rule to the propositional ones.</p>

<p>

<math display="block" id="Method_of_analytic_tableaux:197">
 <semantics>
  <mfrac>
   <mrow>
    <mi mathvariant="normal">¬</mi>
    <mi mathvariant="normal">□</mi>
    <mi>A</mi>
   </mrow>
   <mrow>
    <mi mathvariant="normal">¬</mi>
    <mi>A</mi>
   </mrow>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <times></times>
     <not></not>
     <ci>normal-□</ci>
     <ci>A</ci>
    </apply>
    <apply>
     <times></times>
     <not></not>
     <ci>A</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{\neg\Box A}{\neg A}
  </annotation>
 </semantics>
</math>

</p>

<p>In propositional tableaux all formulae refer to the same truth evaluation, but the precondition of the rule above holds in a world while the consequence holds in another. Not taking into account this would generate wrong results. For example, formula 

<math display="inline" id="Method_of_analytic_tableaux:198">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo>∧</mo>
   <mrow>
    <mi mathvariant="normal">¬</mi>
    <mi mathvariant="normal">□</mi>
    <mi>a</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <ci>a</ci>
    <apply>
     <times></times>
     <not></not>
     <ci>normal-□</ci>
     <ci>a</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a\wedge\neg\Box a
  </annotation>
 </semantics>
</math>

 states that 

<math display="inline" id="Method_of_analytic_tableaux:199">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 is true in the current world and 

<math display="inline" id="Method_of_analytic_tableaux:200">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 is false in a world that is accessible from it. Simply applying 

<math display="inline" id="Method_of_analytic_tableaux:201">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mo>∧</mo>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <and></and>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\wedge)
  </annotation>
 </semantics>
</math>

 and the expansion rule above would produce 

<math display="inline" id="Method_of_analytic_tableaux:202">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Method_of_analytic_tableaux:203">
 <semantics>
  <mrow>
   <mi mathvariant="normal">¬</mi>
   <mi>a</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <not></not>
    <ci>a</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg a
  </annotation>
 </semantics>
</math>

, but these two formulae should not in general generate a contradiction, as they hold in different worlds. Modal tableaux calculi do contain rules of the kind of the one above, but include mechanisms to avoid the incorrect interaction of formulae referring to different worlds.</p>

<p>Technically, tableaux for modal logics check the satisfiability of a set of formulae: they check whether there exists a model 

<math display="inline" id="Method_of_analytic_tableaux:204">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 and world 

<math display="inline" id="Method_of_analytic_tableaux:205">
 <semantics>
  <mi>w</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>w</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w
  </annotation>
 </semantics>
</math>

 such that the formulae in the set are true in that model and world. In the example above, while 

<math display="inline" id="Method_of_analytic_tableaux:206">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 states the truth of 

<math display="inline" id="Method_of_analytic_tableaux:207">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 in 

<math display="inline" id="Method_of_analytic_tableaux:208">
 <semantics>
  <mi>w</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>w</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w
  </annotation>
 </semantics>
</math>

, the formula 

<math display="inline" id="Method_of_analytic_tableaux:209">
 <semantics>
  <mrow>
   <mi mathvariant="normal">¬</mi>
   <mi mathvariant="normal">□</mi>
   <mi>a</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <not></not>
    <ci>normal-□</ci>
    <ci>a</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg\Box a
  </annotation>
 </semantics>
</math>

 states the truth of 

<math display="inline" id="Method_of_analytic_tableaux:210">
 <semantics>
  <mrow>
   <mi mathvariant="normal">¬</mi>
   <mi>a</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <not></not>
    <ci>a</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg a
  </annotation>
 </semantics>
</math>

 in some world 

<math display="inline" id="Method_of_analytic_tableaux:211">
 <semantics>
  <msup>
   <mi>w</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>w</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w^{\prime}
  </annotation>
 </semantics>
</math>

 that is accessible from 

<math display="inline" id="Method_of_analytic_tableaux:212">
 <semantics>
  <mi>w</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>w</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w
  </annotation>
 </semantics>
</math>

 and which may in general be different from 

<math display="inline" id="Method_of_analytic_tableaux:213">
 <semantics>
  <mi>w</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>w</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w
  </annotation>
 </semantics>
</math>

. Tableaux calculi for modal logic take into account that formulae may refer to different worlds.</p>

<p>This fact has an important consequence: formulae that hold in a world may imply conditions over different successors of that world. Unsatisfiability may then be proved from the subset of formulae referring to the a single successor. This holds if a world may have more than one successor, which is true for most modal logic. If this is the case, a formula like 

<math display="inline" id="Method_of_analytic_tableaux:214">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">¬</mi>
    <mi mathvariant="normal">□</mi>
    <mi>A</mi>
   </mrow>
   <mo>∧</mo>
   <mrow>
    <mi mathvariant="normal">¬</mi>
    <mi mathvariant="normal">□</mi>
    <mi>B</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <times></times>
     <not></not>
     <ci>normal-□</ci>
     <ci>A</ci>
    </apply>
    <apply>
     <times></times>
     <not></not>
     <ci>normal-□</ci>
     <ci>B</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg\Box A\wedge\neg\Box B
  </annotation>
 </semantics>
</math>

 is true if a successor where 

<math display="inline" id="Method_of_analytic_tableaux:215">
 <semantics>
  <mrow>
   <mi mathvariant="normal">¬</mi>
   <mi>A</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <not></not>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg A
  </annotation>
 </semantics>
</math>

 holds exists and a successor where 

<math display="inline" id="Method_of_analytic_tableaux:216">
 <semantics>
  <mrow>
   <mi mathvariant="normal">¬</mi>
   <mi>B</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <not></not>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg B
  </annotation>
 </semantics>
</math>

 holds exists. In the other way around, if one can show unsatisfiability of 

<math display="inline" id="Method_of_analytic_tableaux:217">
 <semantics>
  <mrow>
   <mi mathvariant="normal">¬</mi>
   <mi>A</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <not></not>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg A
  </annotation>
 </semantics>
</math>

 in an arbitrary successor, the formula is proved unsatisfiable without checking for worlds where 

<math display="inline" id="Method_of_analytic_tableaux:218">
 <semantics>
  <mrow>
   <mi mathvariant="normal">¬</mi>
   <mi>B</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <not></not>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg B
  </annotation>
 </semantics>
</math>

 holds. At the same time, if one can show unsatisfiability of 

<math display="inline" id="Method_of_analytic_tableaux:219">
 <semantics>
  <mrow>
   <mi mathvariant="normal">¬</mi>
   <mi>B</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <not></not>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg B
  </annotation>
 </semantics>
</math>

, there is no need to check 

<math display="inline" id="Method_of_analytic_tableaux:220">
 <semantics>
  <mrow>
   <mi mathvariant="normal">¬</mi>
   <mi>A</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <not></not>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg A
  </annotation>
 </semantics>
</math>

. As a result, while there are two possible way to expand 

<math display="inline" id="Method_of_analytic_tableaux:221">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">¬</mi>
    <mi mathvariant="normal">□</mi>
    <mi>A</mi>
   </mrow>
   <mo>∧</mo>
   <mrow>
    <mi mathvariant="normal">¬</mi>
    <mi mathvariant="normal">□</mi>
    <mi>B</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <times></times>
     <not></not>
     <ci>normal-□</ci>
     <ci>A</ci>
    </apply>
    <apply>
     <times></times>
     <not></not>
     <ci>normal-□</ci>
     <ci>B</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg\Box A\wedge\neg\Box B
  </annotation>
 </semantics>
</math>

, one of these two ways is always sufficient to prove unsatisfiability if the formula is unsatisfiable. For example, one may expand the tableau by considering an arbitrary world where 

<math display="inline" id="Method_of_analytic_tableaux:222">
 <semantics>
  <mrow>
   <mi mathvariant="normal">¬</mi>
   <mi>A</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <not></not>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg A
  </annotation>
 </semantics>
</math>

 holds. If this expansion leads to unsatisfiability, the original formula is unsatisfiable. However, it is also possible that unsatisfiability cannot be proved this way, and that the world where 

<math display="inline" id="Method_of_analytic_tableaux:223">
 <semantics>
  <mrow>
   <mi mathvariant="normal">¬</mi>
   <mi>B</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <not></not>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg B
  </annotation>
 </semantics>
</math>

 holds should have been considered instead. As a result, one can always prove unsatisfiability by expanding either 

<math display="inline" id="Method_of_analytic_tableaux:224">
 <semantics>
  <mrow>
   <mi mathvariant="normal">¬</mi>
   <mi mathvariant="normal">□</mi>
   <mi>A</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <not></not>
    <ci>normal-□</ci>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg\Box A
  </annotation>
 </semantics>
</math>

 only or 

<math display="inline" id="Method_of_analytic_tableaux:225">
 <semantics>
  <mrow>
   <mi mathvariant="normal">¬</mi>
   <mi mathvariant="normal">□</mi>
   <mi>B</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <not></not>
    <ci>normal-□</ci>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg\Box B
  </annotation>
 </semantics>
</math>

 only; however, if the wrong choice is done the resulting tableau may not be closed. Expanding either subformula leads to tableau calculi that are complete but not proof-confluent. Searching as described in the "Searching for a closed tableau" may therefore be necessary.</p>

<p>Depending on whether the precondition and consequence of a tableau expansion rule refer to the same world or not, the rule is called static or transactional. While rules for propositional connectives are all static, not all rules for modal connectives are transactional: for example, in every modal logic including axiom <a href="T_(modal_logic)" title="wikilink">T</a>, it holds that 

<math display="inline" id="Method_of_analytic_tableaux:226">
 <semantics>
  <mrow>
   <mi mathvariant="normal">□</mi>
   <mi>A</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-□</ci>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Box A
  </annotation>
 </semantics>
</math>

 implies 

<math display="inline" id="Method_of_analytic_tableaux:227">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 in the same world. As a result, the relative (modal) tableau expansion rule is static, as both its precondition and consequence refer to the same world.</p>
<h3 id="formula-deleting-tableau">Formula-deleting tableau</h3>

<p>A way for making formulae referring to different worlds not interacting in the wrong way is to make sure that all formulae of a branch refer to the same world. This condition is initially true as all formulae in the set to be checked for consistency are assumed referring to the same world. When expanding a branch, two situations are possible: either the new formulae refer to the same world as the other one in the branch or not. In the first case, the rule is applied normally. In the second case, all formulae of the branch that do not also hold in the new world are deleted from the branch, and possibly added to all other branches that are still relative to the old world.</p>

<p>As an example, in <a href="S5_(modal_logic)" title="wikilink">S5</a> every formula 

<math display="inline" id="Method_of_analytic_tableaux:228">
 <semantics>
  <mrow>
   <mi mathvariant="normal">□</mi>
   <mi>A</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-□</ci>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Box A
  </annotation>
 </semantics>
</math>

 that is true in a world is also true in all accessible worlds (that is, in all accessible worlds both 

<math display="inline" id="Method_of_analytic_tableaux:229">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Method_of_analytic_tableaux:230">
 <semantics>
  <mrow>
   <mi mathvariant="normal">□</mi>
   <mi>A</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-□</ci>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Box A
  </annotation>
 </semantics>
</math>

 are true). Therefore, when applying 

<math display="inline" id="Method_of_analytic_tableaux:231">
 <semantics>
  <mfrac>
   <mrow>
    <mi mathvariant="normal">¬</mi>
    <mi mathvariant="normal">□</mi>
    <mi>A</mi>
   </mrow>
   <mrow>
    <mi mathvariant="normal">¬</mi>
    <mi>A</mi>
   </mrow>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <times></times>
     <not></not>
     <ci>normal-□</ci>
     <ci>A</ci>
    </apply>
    <apply>
     <times></times>
     <not></not>
     <ci>A</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{\neg\Box A}{\neg A}
  </annotation>
 </semantics>
</math>

, whose consequence holds in a different world, one deletes all formulae from the branch, but can keep all formulae 

<math display="inline" id="Method_of_analytic_tableaux:232">
 <semantics>
  <mrow>
   <mi mathvariant="normal">□</mi>
   <mi>A</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-□</ci>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Box A
  </annotation>
 </semantics>
</math>

, as these hold in the new world as well. In order to retain completeness, the deleted formulae are then added to all other branches that still refer to the old world.</p>
<h3 id="world-labeled-tableau">World-labeled tableau</h3>

<p>A different mechanism for ensuring the correct interaction between formulae referring to different worlds is to switch from formulae to labeled formulae: instead of writing 

<math display="inline" id="Method_of_analytic_tableaux:233">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

, one would write 

<math display="inline" id="Method_of_analytic_tableaux:234">
 <semantics>
  <mrow>
   <mi>w</mi>
   <mo>:</mo>
   <mi>A</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>w</ci>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w:A
  </annotation>
 </semantics>
</math>

 to make it explicit that 

<math display="inline" id="Method_of_analytic_tableaux:235">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 holds in world 

<math display="inline" id="Method_of_analytic_tableaux:236">
 <semantics>
  <mi>w</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>w</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w
  </annotation>
 </semantics>
</math>

.</p>

<p>All propositional expansion rules are adapted to this variant by stating that they all refer to formulae with the same world label. For example, 

<math display="inline" id="Method_of_analytic_tableaux:237">
 <semantics>
  <mrow>
   <mi>w</mi>
   <mo>:</mo>
   <mrow>
    <mi>A</mi>
    <mo>∧</mo>
    <mi>B</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>w</ci>
    <apply>
     <and></and>
     <ci>A</ci>
     <ci>B</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w:A\wedge B
  </annotation>
 </semantics>
</math>

 generates two nodes labeled with 

<math display="inline" id="Method_of_analytic_tableaux:238">
 <semantics>
  <mrow>
   <mi>w</mi>
   <mo>:</mo>
   <mi>A</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>w</ci>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w:A
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Method_of_analytic_tableaux:239">
 <semantics>
  <mrow>
   <mi>w</mi>
   <mo>:</mo>
   <mi>B</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>w</ci>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w:B
  </annotation>
 </semantics>
</math>

; a branch is closed only if it contains two opposite literals of the same world, like 

<math display="inline" id="Method_of_analytic_tableaux:240">
 <semantics>
  <mrow>
   <mi>w</mi>
   <mo>:</mo>
   <mi>a</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>w</ci>
    <ci>a</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w:a
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Method_of_analytic_tableaux:241">
 <semantics>
  <mrow>
   <mi>w</mi>
   <mo>:</mo>
   <mrow>
    <mi mathvariant="normal">¬</mi>
    <mi>a</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>w</ci>
    <apply>
     <times></times>
     <not></not>
     <ci>a</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w:\neg a
  </annotation>
 </semantics>
</math>

; no closure is generated if the two world labels are different, like in 

<math display="inline" id="Method_of_analytic_tableaux:242">
 <semantics>
  <mrow>
   <mi>w</mi>
   <mo>:</mo>
   <mi>a</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>w</ci>
    <ci>a</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w:a
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Method_of_analytic_tableaux:243">
 <semantics>
  <mrow>
   <msup>
    <mi>w</mi>
    <mo>′</mo>
   </msup>
   <mo>:</mo>
   <mrow>
    <mi mathvariant="normal">¬</mi>
    <mi>a</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>w</ci>
     <ci>normal-′</ci>
    </apply>
    <apply>
     <times></times>
     <not></not>
     <ci>a</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w^{\prime}:\neg a
  </annotation>
 </semantics>
</math>

.</p>

<p>The modal expansion rule may have a consequence that refer to a different worlds. For example, the rule for 

<math display="inline" id="Method_of_analytic_tableaux:244">
 <semantics>
  <mrow>
   <mi mathvariant="normal">¬</mi>
   <mi mathvariant="normal">□</mi>
   <mi>A</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <not></not>
    <ci>normal-□</ci>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg\Box A
  </annotation>
 </semantics>
</math>

 would be written as follows</p>

<p>

<math display="block" id="Method_of_analytic_tableaux:245">
 <semantics>
  <mfrac>
   <mrow>
    <mi>w</mi>
    <mo>:</mo>
    <mrow>
     <mi mathvariant="normal">¬</mi>
     <mi mathvariant="normal">□</mi>
     <mi>A</mi>
    </mrow>
   </mrow>
   <mrow>
    <msup>
     <mi>w</mi>
     <mo>′</mo>
    </msup>
    <mo>:</mo>
    <mrow>
     <mi mathvariant="normal">¬</mi>
     <mi>A</mi>
    </mrow>
   </mrow>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <ci>normal-:</ci>
     <ci>w</ci>
     <apply>
      <times></times>
      <not></not>
      <ci>normal-□</ci>
      <ci>A</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-:</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>w</ci>
      <ci>normal-′</ci>
     </apply>
     <apply>
      <times></times>
      <not></not>
      <ci>A</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{w:\neg\Box A}{w^{\prime}:\neg A}
  </annotation>
 </semantics>
</math>

</p>

<p>The precondition and consequent of this rule refer to worlds 

<math display="inline" id="Method_of_analytic_tableaux:246">
 <semantics>
  <mi>w</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>w</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Method_of_analytic_tableaux:247">
 <semantics>
  <msup>
   <mi>w</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>w</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w^{\prime}
  </annotation>
 </semantics>
</math>

, respectively. The various calculi use different methods for keeping track of the accessibility of the worlds used as labels. Some include pseudo-formulae like 

<math display="inline" id="Method_of_analytic_tableaux:248">
 <semantics>
  <mrow>
   <mi>w</mi>
   <mi>R</mi>
   <msup>
    <mi>w</mi>
    <mo>′</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>w</ci>
    <ci>R</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>w</ci>
     <ci>normal-′</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   wRw^{\prime}
  </annotation>
 </semantics>
</math>

 to denote that 

<math display="inline" id="Method_of_analytic_tableaux:249">
 <semantics>
  <msup>
   <mi>w</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>w</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w^{\prime}
  </annotation>
 </semantics>
</math>

 is accessible from 

<math display="inline" id="Method_of_analytic_tableaux:250">
 <semantics>
  <mi>w</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>w</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w
  </annotation>
 </semantics>
</math>

. Some others use sequences of integers as world labels, this notation implicitly representing the accessibility relation (for example, 

<math display="inline" id="Method_of_analytic_tableaux:251">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mn>1</mn>
   <mo>,</mo>
   <mn>4</mn>
   <mo>,</mo>
   <mn>2</mn>
   <mo>,</mo>
   <mn>3</mn>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <cn type="integer">1</cn>
    <cn type="integer">4</cn>
    <cn type="integer">2</cn>
    <cn type="integer">3</cn>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (1,4,2,3)
  </annotation>
 </semantics>
</math>

 is accessible from 

<math display="inline" id="Method_of_analytic_tableaux:252">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mn>1</mn>
   <mo>,</mo>
   <mn>4</mn>
   <mo>,</mo>
   <mn>2</mn>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <cn type="integer">1</cn>
    <cn type="integer">4</cn>
    <cn type="integer">2</cn>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (1,4,2)
  </annotation>
 </semantics>
</math>

.)</p>
<h3 id="set-labeling-tableaux">Set-labeling tableaux</h3>

<p>The problem of interaction between formulae holding in different worlds can be overcome by using set-labeling tableaux. These are trees whose nodes are labeled with sets of formulae; the expansion rules tell how to attach new nodes to a leaf, based only on the label of the leaf (and not on the label of other nodes in the branch).</p>

<p>Tableaux for modal logics are used to verify the satisfiability of a set of modal formulae in a given modal logic. Given a set of formulae 

<math display="inline" id="Method_of_analytic_tableaux:253">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

, they check the existence of a model 

<math display="inline" id="Method_of_analytic_tableaux:254">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 and a world 

<math display="inline" id="Method_of_analytic_tableaux:255">
 <semantics>
  <mi>w</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>w</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Method_of_analytic_tableaux:256">
 <semantics>
  <mrow>
   <mrow>
    <mi>M</mi>
    <mo>,</mo>
    <mi>w</mi>
   </mrow>
   <mo>⊧</mo>
   <mi>S</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">models</csymbol>
    <list>
     <ci>M</ci>
     <ci>w</ci>
    </list>
    <ci>S</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M,w\models S
  </annotation>
 </semantics>
</math>

.</p>

<p>The expansion rules depend on the particular modal logic used. A tableau system for the basic modal logic <a href="K_(modal_logic)" title="wikilink">K</a> can be obtained by adding to the propositional tableau rules the following one:</p>

<p>

<math display="block" id="Method_of_analytic_tableaux:257">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>K</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mfrac>
    <mrow>
     <mrow>
      <mi mathvariant="normal">□</mi>
      <msub>
       <mi>A</mi>
       <mn>1</mn>
      </msub>
     </mrow>
     <mo>;</mo>
     <mi mathvariant="normal">…</mi>
     <mo>;</mo>
     <mrow>
      <mi mathvariant="normal">□</mi>
      <msub>
       <mi>A</mi>
       <mi>n</mi>
      </msub>
     </mrow>
     <mo>;</mo>
     <mrow>
      <mi mathvariant="normal">¬</mi>
      <mi mathvariant="normal">□</mi>
      <mi>B</mi>
     </mrow>
    </mrow>
    <mrow>
     <msub>
      <mi>A</mi>
      <mn>1</mn>
     </msub>
     <mo>;</mo>
     <mi mathvariant="normal">…</mi>
     <mo>;</mo>
     <msub>
      <mi>A</mi>
      <mi>n</mi>
     </msub>
     <mo>;</mo>
     <mrow>
      <mi mathvariant="normal">¬</mi>
      <mi>B</mi>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>K</ci>
    <apply>
     <divide></divide>
     <list>
      <apply>
       <times></times>
       <ci>normal-□</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>A</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <times></times>
       <ci>normal-□</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>A</ci>
        <ci>n</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <not></not>
       <ci>normal-□</ci>
       <ci>B</ci>
      </apply>
     </list>
     <list>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>A</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>A</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <times></times>
       <not></not>
       <ci>B</ci>
      </apply>
     </list>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (K)\frac{\Box A_{1};\ldots;\Box A_{n};\neg\Box B}{A_{1};\ldots;A_{n};\neg B}
  </annotation>
 </semantics>
</math>

</p>

<p>Intuitively, the precondition of this rule expresses the truth of all formulae 

<math display="inline" id="Method_of_analytic_tableaux:258">
 <semantics>
  <mrow>
   <msub>
    <mi>A</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>A</mi>
    <mi>n</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>A</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>A</ci>
     <ci>n</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{1},\ldots,A_{n}
  </annotation>
 </semantics>
</math>

 at all accessible worlds, and truth of 

<math display="inline" id="Method_of_analytic_tableaux:259">
 <semantics>
  <mrow>
   <mi mathvariant="normal">¬</mi>
   <mi>B</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <not></not>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg B
  </annotation>
 </semantics>
</math>

 at some accessible worlds. The consequence of this rule is a formula that must be true at one of those worlds where 

<math display="inline" id="Method_of_analytic_tableaux:260">
 <semantics>
  <mrow>
   <mi mathvariant="normal">¬</mi>
   <mi>B</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <not></not>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg B
  </annotation>
 </semantics>
</math>

 is true.</p>

<p>More technically, modal tableaux methods check the existence of a model 

<math display="inline" id="Method_of_analytic_tableaux:261">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 and a world 

<math display="inline" id="Method_of_analytic_tableaux:262">
 <semantics>
  <mi>w</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>w</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w
  </annotation>
 </semantics>
</math>

 that make set of formulae true. If 

<math display="inline" id="Method_of_analytic_tableaux:263">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">□</mi>
    <msub>
     <mi>A</mi>
     <mn>1</mn>
    </msub>
   </mrow>
   <mo>;</mo>
   <mi mathvariant="normal">…</mi>
   <mo>;</mo>
   <mrow>
    <mi mathvariant="normal">□</mi>
    <msub>
     <mi>A</mi>
     <mi>n</mi>
    </msub>
   </mrow>
   <mo>;</mo>
   <mrow>
    <mi mathvariant="normal">¬</mi>
    <mi mathvariant="normal">□</mi>
    <mi>B</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <times></times>
     <ci>normal-□</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <times></times>
     <ci>normal-□</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <not></not>
     <ci>normal-□</ci>
     <ci>B</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Box A_{1};\ldots;\Box A_{n};\neg\Box B
  </annotation>
 </semantics>
</math>

 are true in 

<math display="inline" id="Method_of_analytic_tableaux:264">
 <semantics>
  <mi>w</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>w</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w
  </annotation>
 </semantics>
</math>

, there must be a world 

<math display="inline" id="Method_of_analytic_tableaux:265">
 <semantics>
  <msup>
   <mi>w</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>w</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w^{\prime}
  </annotation>
 </semantics>
</math>

 that is accessible from 

<math display="inline" id="Method_of_analytic_tableaux:266">
 <semantics>
  <mi>w</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>w</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w
  </annotation>
 </semantics>
</math>

 and that makes 

<math display="inline" id="Method_of_analytic_tableaux:267">
 <semantics>
  <mrow>
   <msub>
    <mi>A</mi>
    <mn>1</mn>
   </msub>
   <mo>;</mo>
   <mi mathvariant="normal">…</mi>
   <mo>;</mo>
   <msub>
    <mi>A</mi>
    <mi>n</mi>
   </msub>
   <mo>;</mo>
   <mrow>
    <mi mathvariant="normal">¬</mi>
    <mi>B</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>A</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>A</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <times></times>
     <not></not>
     <ci>B</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{1};\ldots;A_{n};\neg B
  </annotation>
 </semantics>
</math>

 true. This rule therefore amounts to deriving a set of formulae that must be satisfied in such 

<math display="inline" id="Method_of_analytic_tableaux:268">
 <semantics>
  <msup>
   <mi>w</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>w</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w^{\prime}
  </annotation>
 </semantics>
</math>

.</p>

<p>While the preconditions 

<math display="inline" id="Method_of_analytic_tableaux:269">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">□</mi>
    <msub>
     <mi>A</mi>
     <mn>1</mn>
    </msub>
   </mrow>
   <mo>;</mo>
   <mi mathvariant="normal">…</mi>
   <mo>;</mo>
   <mrow>
    <mi mathvariant="normal">□</mi>
    <msub>
     <mi>A</mi>
     <mi>n</mi>
    </msub>
   </mrow>
   <mo>;</mo>
   <mrow>
    <mi mathvariant="normal">¬</mi>
    <mi mathvariant="normal">□</mi>
    <mi>B</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <times></times>
     <ci>normal-□</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <times></times>
     <ci>normal-□</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <not></not>
     <ci>normal-□</ci>
     <ci>B</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Box A_{1};\ldots;\Box A_{n};\neg\Box B
  </annotation>
 </semantics>
</math>

 are assumed satisfied by 

<math display="inline" id="Method_of_analytic_tableaux:270">
 <semantics>
  <mrow>
   <mi>M</mi>
   <mo>,</mo>
   <mi>w</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>M</ci>
    <ci>w</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M,w
  </annotation>
 </semantics>
</math>

, the consequences 

<math display="inline" id="Method_of_analytic_tableaux:271">
 <semantics>
  <mrow>
   <msub>
    <mi>A</mi>
    <mn>1</mn>
   </msub>
   <mo>;</mo>
   <mi mathvariant="normal">…</mi>
   <mo>;</mo>
   <msub>
    <mi>A</mi>
    <mi>n</mi>
   </msub>
   <mo>;</mo>
   <mrow>
    <mi mathvariant="normal">¬</mi>
    <mi>B</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>A</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>A</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <times></times>
     <not></not>
     <ci>B</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{1};\ldots;A_{n};\neg B
  </annotation>
 </semantics>
</math>

 are assumed satisfied in 

<math display="inline" id="Method_of_analytic_tableaux:272">
 <semantics>
  <mrow>
   <mi>M</mi>
   <mo>,</mo>
   <msup>
    <mi>w</mi>
    <mo>′</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>M</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>w</ci>
     <ci>normal-′</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M,w^{\prime}
  </annotation>
 </semantics>
</math>

: same model but possibly different worlds. Set-labeled tableaux do not explicitly keep track of the world where each formula is assumed true: two nodes may or may not refer to the same world. However, the formulae labeling any given node are assumed true at the same world.</p>

<p>As a result of the possibly different worlds where formulae are assumed true, a formula in a node is not automatically valid in all its descendants, as every application of the modal rule correspond to a move from a world to another one. This condition is automatically captured by set-labeling tableaux, as expansion rules are based only on the leaf where they are applied and not on its ancestors.</p>

<p>Remarkably, 

<math display="inline" id="Method_of_analytic_tableaux:273">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>K</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <ci>K</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (K)
  </annotation>
 </semantics>
</math>

 does not directly extend to multiple negated boxed formulae such as in 

<math display="inline" id="Method_of_analytic_tableaux:274">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">□</mi>
    <msub>
     <mi>A</mi>
     <mn>1</mn>
    </msub>
   </mrow>
   <mo>;</mo>
   <mi mathvariant="normal">…</mi>
   <mo>;</mo>
   <mrow>
    <mi mathvariant="normal">□</mi>
    <msub>
     <mi>A</mi>
     <mi>n</mi>
    </msub>
   </mrow>
   <mo>;</mo>
   <mrow>
    <mi mathvariant="normal">¬</mi>
    <mi mathvariant="normal">□</mi>
    <msub>
     <mi>B</mi>
     <mn>1</mn>
    </msub>
   </mrow>
   <mo>;</mo>
   <mrow>
    <mi mathvariant="normal">¬</mi>
    <mi mathvariant="normal">□</mi>
    <msub>
     <mi>B</mi>
     <mn>2</mn>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <times></times>
     <ci>normal-□</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <times></times>
     <ci>normal-□</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <not></not>
     <ci>normal-□</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>B</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <times></times>
     <not></not>
     <ci>normal-□</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>B</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Box A_{1};\ldots;\Box A_{n};\neg\Box B_{1};\neg\Box B_{2}
  </annotation>
 </semantics>
</math>

: while there exists an accessible world where 

<math display="inline" id="Method_of_analytic_tableaux:275">
 <semantics>
  <msub>
   <mi>B</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>B</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B_{1}
  </annotation>
 </semantics>
</math>

 is false and one in which 

<math display="inline" id="Method_of_analytic_tableaux:276">
 <semantics>
  <msub>
   <mi>B</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>B</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B_{2}
  </annotation>
 </semantics>
</math>

 is false, these two worlds are not necessarily the same.</p>

<p>Differently from the propositional rules, 

<math display="inline" id="Method_of_analytic_tableaux:277">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>K</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <ci>K</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (K)
  </annotation>
 </semantics>
</math>

 states conditions over all its preconditions. For example, it cannot be applied to a node labeled by 

<math display="inline" id="Method_of_analytic_tableaux:278">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo>;</mo>
   <mi mathvariant="normal">□</mi>
   <mi>b</mi>
   <mo>;</mo>
   <mi mathvariant="normal">□</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>b</mi>
    <mo>→</mo>
    <mi>c</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>;</mo>
   <mi mathvariant="normal">¬</mi>
   <mi mathvariant="normal">□</mi>
   <mi>c</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">a</csymbol>
    <ci>normal-;</ci>
    <csymbol cd="unknown">□</csymbol>
    <csymbol cd="unknown">b</csymbol>
    <ci>normal-;</ci>
    <csymbol cd="unknown">□</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">b</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">c</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-;</ci>
    <not></not>
    <csymbol cd="unknown">□</csymbol>
    <csymbol cd="unknown">c</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a;\Box b;\Box(b\rightarrow c);\neg\Box c
  </annotation>
 </semantics>
</math>

; while this set is inconsistent and this could be easily proved by applying 

<math display="inline" id="Method_of_analytic_tableaux:279">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>K</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <ci>K</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (K)
  </annotation>
 </semantics>
</math>

, this rule cannot be applied because of formula 

<math display="inline" id="Method_of_analytic_tableaux:280">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

, which is not even relevant to inconsistency. Removal of such formulae is made possible by the rule:</p>

<p>

<math display="block" id="Method_of_analytic_tableaux:281">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>θ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mfrac>
    <mrow>
     <msub>
      <mi>A</mi>
      <mn>1</mn>
     </msub>
     <mo>;</mo>
     <mi mathvariant="normal">…</mi>
     <mo>;</mo>
     <msub>
      <mi>A</mi>
      <mi>n</mi>
     </msub>
     <mo>;</mo>
     <msub>
      <mi>B</mi>
      <mn>1</mn>
     </msub>
     <mo>;</mo>
     <mi mathvariant="normal">…</mi>
     <mo>;</mo>
     <msub>
      <mi>B</mi>
      <mi>m</mi>
     </msub>
    </mrow>
    <mrow>
     <msub>
      <mi>A</mi>
      <mn>1</mn>
     </msub>
     <mo>;</mo>
     <mi mathvariant="normal">…</mi>
     <mo>;</mo>
     <msub>
      <mi>A</mi>
      <mi>n</mi>
     </msub>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>θ</ci>
    <apply>
     <divide></divide>
     <list>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>A</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>A</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>B</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>B</ci>
       <ci>m</ci>
      </apply>
     </list>
     <list>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>A</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>A</ci>
       <ci>n</ci>
      </apply>
     </list>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\theta)\frac{A_{1};\ldots;A_{n};B_{1};\ldots;B_{m}}{A_{1};\ldots;A_{n}}
  </annotation>
 </semantics>
</math>

</p>

<p>The addition of this rule (thinning rule) makes the resulting calculus non-confluent: a tableau for an inconsistent set may be impossible to close, even if a closed tableau for the same set exists.</p>

<p>Rule 

<math display="inline" id="Method_of_analytic_tableaux:282">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>θ</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <ci>θ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\theta)
  </annotation>
 </semantics>
</math>

 is non-deterministic: the set of formulae to be removed (or to be kept) can be chosen arbitrarily; this creates the problem of choosing a set of formulae to discard that is not so large it makes the resulting set satisfiable and not so small it makes the necessary expansion rules inapplicable. Having a large number of possible choices makes the problem of searching for a closed tableau harder.</p>

<p>This non-determinism can be avoided by restricting the usage of 

<math display="inline" id="Method_of_analytic_tableaux:283">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>θ</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <ci>θ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\theta)
  </annotation>
 </semantics>
</math>

 so that it is only applied before a modal expansion rule, and so that it only removes the formulae that make that other rule inapplicable. This condition can be also formulated by merging the two rules in a single one. The resulting rule produces the same result as the old one, but implicitly discard all formulae that made the old rule inapplicable. This mechanism for removing 

<math display="inline" id="Method_of_analytic_tableaux:284">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>θ</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <ci>θ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\theta)
  </annotation>
 </semantics>
</math>

 has been proved to preserve completeness for many modal logics.</p>

<p>Axiom <a href="T_(modal_logic)" title="wikilink">T</a> expresses reflexivity of the accessibility relation: every world is accessible from itself. The corresponding tableau expansion rule is:</p>

<p>

<math display="block" id="Method_of_analytic_tableaux:285">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>T</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mfrac>
    <mrow>
     <msub>
      <mi>A</mi>
      <mn>1</mn>
     </msub>
     <mo>;</mo>
     <mi mathvariant="normal">…</mi>
     <mo>;</mo>
     <msub>
      <mi>A</mi>
      <mi>n</mi>
     </msub>
     <mo>;</mo>
     <mrow>
      <mi mathvariant="normal">□</mi>
      <mi>B</mi>
     </mrow>
    </mrow>
    <mrow>
     <msub>
      <mi>A</mi>
      <mn>1</mn>
     </msub>
     <mo>;</mo>
     <mi mathvariant="normal">…</mi>
     <mo>;</mo>
     <msub>
      <mi>A</mi>
      <mi>n</mi>
     </msub>
     <mo>;</mo>
     <mrow>
      <mi mathvariant="normal">□</mi>
      <mi>B</mi>
     </mrow>
     <mo>;</mo>
     <mi>B</mi>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>T</ci>
    <apply>
     <divide></divide>
     <list>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>A</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>A</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <times></times>
       <ci>normal-□</ci>
       <ci>B</ci>
      </apply>
     </list>
     <list>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>A</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>A</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <times></times>
       <ci>normal-□</ci>
       <ci>B</ci>
      </apply>
      <ci>B</ci>
     </list>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (T)\frac{A_{1};\ldots;A_{n};\Box B}{A_{1};\ldots;A_{n};\Box B;B}
  </annotation>
 </semantics>
</math>

</p>

<p>This rule relates conditions over the same world: if 

<math display="inline" id="Method_of_analytic_tableaux:286">
 <semantics>
  <mrow>
   <mi mathvariant="normal">□</mi>
   <mi>B</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-□</ci>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Box B
  </annotation>
 </semantics>
</math>

 is true in a world, by reflexivity 

<math display="inline" id="Method_of_analytic_tableaux:287">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

 is also true <em>in the same world</em>. This rule is static, not transactional, as both its precondition and consequent refer to the same world.</p>

<p>This rule copies 

<math display="inline" id="Method_of_analytic_tableaux:288">
 <semantics>
  <mrow>
   <mi mathvariant="normal">□</mi>
   <mi>B</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-□</ci>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Box B
  </annotation>
 </semantics>
</math>

 from the precondition to the consequent, in spite of this formula having been "used" to generate 

<math display="inline" id="Method_of_analytic_tableaux:289">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

. This is correct, as the considered world is the same, so 

<math display="inline" id="Method_of_analytic_tableaux:290">
 <semantics>
  <mrow>
   <mi mathvariant="normal">□</mi>
   <mi>B</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-□</ci>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Box B
  </annotation>
 </semantics>
</math>

 also holds there. This "copying" is necessary in some cases. It is for example necessary to prove the inconsistency of 

<math display="inline" id="Method_of_analytic_tableaux:291">
 <semantics>
  <mrow>
   <mi mathvariant="normal">□</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>a</mi>
     <mo>∧</mo>
     <mrow>
      <mi mathvariant="normal">¬</mi>
      <mi mathvariant="normal">□</mi>
      <mi>a</mi>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-□</ci>
    <apply>
     <and></and>
     <ci>a</ci>
     <apply>
      <times></times>
      <not></not>
      <ci>normal-□</ci>
      <ci>a</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Box(a\wedge\neg\Box a)
  </annotation>
 </semantics>
</math>

: the only applicable rules are in order 

<math display="inline" id="Method_of_analytic_tableaux:292">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>T</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>∧</mo>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>θ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>K</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>T</ci>
    <and></and>
    <ci>θ</ci>
    <ci>K</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (T),(\wedge),(\theta),(K)
  </annotation>
 </semantics>
</math>

, from which one is blocked if 

<math display="inline" id="Method_of_analytic_tableaux:293">
 <semantics>
  <mrow>
   <mi mathvariant="normal">□</mi>
   <mi>a</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-□</ci>
    <ci>a</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Box a
  </annotation>
 </semantics>
</math>

 is not copied.</p>
<h3 id="auxiliary-tableaux">Auxiliary tableaux</h3>

<p>A different method for dealing with formulae holding in alternate worlds is to start a different tableau for each new world that is introduced in the tableau. For example, 

<math display="inline" id="Method_of_analytic_tableaux:294">
 <semantics>
  <mrow>
   <mi mathvariant="normal">¬</mi>
   <mi mathvariant="normal">□</mi>
   <mi>A</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <not></not>
    <ci>normal-□</ci>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg\Box A
  </annotation>
 </semantics>
</math>

 implies that 

<math display="inline" id="Method_of_analytic_tableaux:295">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 is false in an accessible world, so one starts a new tableau rooted by 

<math display="inline" id="Method_of_analytic_tableaux:296">
 <semantics>
  <mrow>
   <mi mathvariant="normal">¬</mi>
   <mi>A</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <not></not>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg A
  </annotation>
 </semantics>
</math>

. This new tableau is attached to the node of the original tableau where the expansion rule has been applied; a closure of this tableau immediately generates a closure of all branches where that node is, regardless of whether the same node is associated other auxiliary tableaux. The expansion rules for the auxiliary tableaux are the same as for the original one; therefore, an auxiliary tableau can have in turns other (sub-)auxiliary tableaux.</p>
<h3 id="global-assumptions">Global assumptions</h3>

<p>The above modal tableaux establish the consistency of a set of formulae, and can be used for solving the local <a href="logical_consequence" title="wikilink">logical consequence</a> problem. This is the problem of telling whether, for each model 

<math display="inline" id="Method_of_analytic_tableaux:297">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

, if 

<math display="inline" id="Method_of_analytic_tableaux:298">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 is true in a world 

<math display="inline" id="Method_of_analytic_tableaux:299">
 <semantics>
  <mi>w</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>w</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w
  </annotation>
 </semantics>
</math>

, then 

<math display="inline" id="Method_of_analytic_tableaux:300">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

 is also true in the same world. This is the same as checking whether 

<math display="inline" id="Method_of_analytic_tableaux:301">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

 is true in a world of a model, in the assumption that 

<math display="inline" id="Method_of_analytic_tableaux:302">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 is also true in the same world of the same model.</p>

<p>A related problem is the global consequence problem, where the assumption is that a formula (or set of formulae) 

<math display="inline" id="Method_of_analytic_tableaux:303">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

 is true in all possible worlds of the model. The problem is that of checking whether, in all models 

<math display="inline" id="Method_of_analytic_tableaux:304">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Method_of_analytic_tableaux:305">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

 is true in all worlds, 

<math display="inline" id="Method_of_analytic_tableaux:306">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

 is also true in all worlds.</p>

<p>Local and global assumption differ on models where the assumed formula is true in some worlds but not in others. As an example, 

<math display="inline" id="Method_of_analytic_tableaux:307">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mi>P</mi>
   <mo>,</mo>
   <mrow>
    <mi mathvariant="normal">¬</mi>
    <mi mathvariant="normal">□</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>P</mi>
      <mo>∧</mo>
      <mi>Q</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <ci>P</ci>
    <apply>
     <times></times>
     <not></not>
     <ci>normal-□</ci>
     <apply>
      <and></and>
      <ci>P</ci>
      <ci>Q</ci>
     </apply>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{P,\neg\Box(P\wedge Q)\}
  </annotation>
 </semantics>
</math>

 entails 

<math display="inline" id="Method_of_analytic_tableaux:308">
 <semantics>
  <mrow>
   <mi mathvariant="normal">¬</mi>
   <mi mathvariant="normal">□</mi>
   <mi>Q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <not></not>
    <ci>normal-□</ci>
    <ci>Q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg\Box Q
  </annotation>
 </semantics>
</math>

 globally but not locally. Local <a class="uri" href="entailment" title="wikilink">entailment</a> does not hold in a model consisting of two worlds making 

<math display="inline" id="Method_of_analytic_tableaux:309">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Method_of_analytic_tableaux:310">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">¬</mi>
    <mi>P</mi>
   </mrow>
   <mo>,</mo>
   <mi>Q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <times></times>
     <not></not>
     <ci>P</ci>
    </apply>
    <ci>Q</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg P,Q
  </annotation>
 </semantics>
</math>

 true, respectively, and where the second is accessible from the first; in the first world, the assumption is true but 

<math display="inline" id="Method_of_analytic_tableaux:311">
 <semantics>
  <mrow>
   <mi mathvariant="normal">□</mi>
   <mi>Q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-□</ci>
    <ci>Q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Box Q
  </annotation>
 </semantics>
</math>

 is false. This counterexample works because 

<math display="inline" id="Method_of_analytic_tableaux:312">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 can be assumed true in a world and false in another one. If however the same assumption is considered global, 

<math display="inline" id="Method_of_analytic_tableaux:313">
 <semantics>
  <mrow>
   <mi mathvariant="normal">¬</mi>
   <mi>P</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <not></not>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg P
  </annotation>
 </semantics>
</math>

 is not allowed in any world of the model.</p>

<p>These two problems can be combined, so that one can check whether 

<math display="inline" id="Method_of_analytic_tableaux:314">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

 is a local consequence of 

<math display="inline" id="Method_of_analytic_tableaux:315">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 under the global assumption 

<math display="inline" id="Method_of_analytic_tableaux:316">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

. Tableaux calculi can deal with global assumption by a rule allowing its addition to every node, regardless of the world it refers to.</p>
<h2 id="notations">Notations</h2>

<p>The following conventions are sometimes used.</p>
<h3 id="uniform-notation">Uniform notation</h3>

<p>When writing tableaux expansion rules, formulae are often denoted using a convention, so that for example 

<math display="inline" id="Method_of_analytic_tableaux:317">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>

 is always considered to be 

<math display="inline" id="Method_of_analytic_tableaux:318">
 <semantics>
  <mrow>
   <msub>
    <mi>α</mi>
    <mn>1</mn>
   </msub>
   <mo>∧</mo>
   <msub>
    <mi>α</mi>
    <mn>2</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>α</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>α</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha_{1}\wedge\alpha_{2}
  </annotation>
 </semantics>
</math>

. The following table provides the notation for formulae in propositional, first-order, and modal logic.</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>Notation</p></td>
<td style="text-align: left;">
<p>Formulae</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>

<math display="inline" id="Method_of_analytic_tableaux:319">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Method_of_analytic_tableaux:320">
 <semantics>
  <mrow>
   <msub>
    <mi>α</mi>
    <mn>1</mn>
   </msub>
   <mo>∧</mo>
   <msub>
    <mi>α</mi>
    <mn>2</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>α</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>α</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha_{1}\wedge\alpha_{2}
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Method_of_analytic_tableaux:321">
 <semantics>
  <mrow>
   <mi mathvariant="normal">¬</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mover accent="true">
      <msub>
       <mi>α</mi>
       <mn>1</mn>
      </msub>
      <mo>¯</mo>
     </mover>
     <mo>∨</mo>
     <mover accent="true">
      <msub>
       <mi>α</mi>
       <mn>2</mn>
      </msub>
      <mo>¯</mo>
     </mover>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <not></not>
    <apply>
     <or></or>
     <apply>
      <ci>normal-¯</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>α</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <ci>normal-¯</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>α</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg(\overline{\alpha_{1}}\vee\overline{\alpha_{2}})
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>

<math display="inline" id="Method_of_analytic_tableaux:322">
 <semantics>
  <mi>β</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>β</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Method_of_analytic_tableaux:323">
 <semantics>
  <mrow>
   <msub>
    <mi>β</mi>
    <mn>1</mn>
   </msub>
   <mo>∨</mo>
   <msub>
    <mi>β</mi>
    <mn>2</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <or></or>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>β</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>β</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta_{1}\vee\beta_{2}
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Method_of_analytic_tableaux:324">
 <semantics>
  <mrow>
   <mover accent="true">
    <msub>
     <mi>β</mi>
     <mn>1</mn>
    </msub>
    <mo>¯</mo>
   </mover>
   <mo>→</mo>
   <msub>
    <mi>β</mi>
    <mn>2</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <ci>normal-¯</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>β</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>β</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \overline{\beta_{1}}\rightarrow\beta_{2}
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>

<math display="inline" id="Method_of_analytic_tableaux:325">
 <semantics>
  <mi>γ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>γ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gamma
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Method_of_analytic_tableaux:326">
 <semantics>
  <mrow>
   <mo>∀</mo>
   <mrow>
    <mi>x</mi>
    <msub>
     <mi>γ</mi>
     <mn>1</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">for-all</csymbol>
    <apply>
     <times></times>
     <ci>x</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>γ</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall x\gamma_{1}(x)
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Method_of_analytic_tableaux:327">
 <semantics>
  <mrow>
   <mi mathvariant="normal">¬</mi>
   <mrow>
    <mo>∃</mo>
    <mrow>
     <mi>x</mi>
     <mover accent="true">
      <mrow>
       <msub>
        <mi>γ</mi>
        <mn>1</mn>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>¯</mo>
     </mover>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <not></not>
    <apply>
     <exists></exists>
     <apply>
      <times></times>
      <ci>x</ci>
      <apply>
       <ci>normal-¯</ci>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>γ</ci>
         <cn type="integer">1</cn>
        </apply>
        <ci>x</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg\exists x\overline{\gamma_{1}(x)}
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>

<math display="inline" id="Method_of_analytic_tableaux:328">
 <semantics>
  <mi>δ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>δ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Method_of_analytic_tableaux:329">
 <semantics>
  <mrow>
   <mo>∃</mo>
   <mrow>
    <mi>x</mi>
    <msub>
     <mi>δ</mi>
     <mn>1</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <exists></exists>
    <apply>
     <times></times>
     <ci>x</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>δ</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \exists x\delta_{1}(x)
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Method_of_analytic_tableaux:330">
 <semantics>
  <mrow>
   <mi mathvariant="normal">¬</mi>
   <mrow>
    <mo>∀</mo>
    <mrow>
     <mi>x</mi>
     <mover accent="true">
      <mrow>
       <msub>
        <mi>δ</mi>
        <mn>1</mn>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>¯</mo>
     </mover>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <not></not>
    <apply>
     <csymbol cd="latexml">for-all</csymbol>
     <apply>
      <times></times>
      <ci>x</ci>
      <apply>
       <ci>normal-¯</ci>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>δ</ci>
         <cn type="integer">1</cn>
        </apply>
        <ci>x</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg\forall x\overline{\delta_{1}(x)}
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>

<math display="inline" id="Method_of_analytic_tableaux:331">
 <semantics>
  <mi>π</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>π</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Method_of_analytic_tableaux:332">
 <semantics>
  <mrow>
   <mi mathvariant="normal">◇</mi>
   <msub>
    <mi>π</mi>
    <mn>1</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-◇</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>π</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Diamond\pi_{1}
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Method_of_analytic_tableaux:333">
 <semantics>
  <mrow>
   <mi mathvariant="normal">¬</mi>
   <mi mathvariant="normal">□</mi>
   <mover accent="true">
    <msub>
     <mi>π</mi>
     <mn>1</mn>
    </msub>
    <mo>¯</mo>
   </mover>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <not></not>
    <ci>normal-□</ci>
    <apply>
     <ci>normal-¯</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>π</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg\Box\overline{\pi_{1}}
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>

<math display="inline" id="Method_of_analytic_tableaux:334">
 <semantics>
  <mi>υ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>υ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \upsilon
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Method_of_analytic_tableaux:335">
 <semantics>
  <mrow>
   <mi mathvariant="normal">□</mi>
   <msub>
    <mi>υ</mi>
    <mn>1</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-□</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>υ</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Box\upsilon_{1}
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Method_of_analytic_tableaux:336">
 <semantics>
  <mrow>
   <mi mathvariant="normal">¬</mi>
   <mi mathvariant="normal">◇</mi>
   <mover accent="true">
    <msub>
     <mi>υ</mi>
     <mn>1</mn>
    </msub>
    <mo>¯</mo>
   </mover>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <not></not>
    <ci>normal-◇</ci>
    <apply>
     <ci>normal-¯</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>υ</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg\Diamond\overline{\upsilon_{1}}
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
</tbody>
</table>

<p>Each label in the first column is taken to be either formula in the other columns. An overlined formula such as 

<math display="inline" id="Method_of_analytic_tableaux:337">
 <semantics>
  <mover accent="true">
   <msub>
    <mi>α</mi>
    <mn>1</mn>
   </msub>
   <mo>¯</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-¯</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>α</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \overline{\alpha_{1}}
  </annotation>
 </semantics>
</math>

 indicates that 

<math display="inline" id="Method_of_analytic_tableaux:338">
 <semantics>
  <msub>
   <mi>α</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>α</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha_{1}
  </annotation>
 </semantics>
</math>

 is the negation of whatever formula appears in its place, so that for example in formula 

<math display="inline" id="Method_of_analytic_tableaux:339">
 <semantics>
  <mrow>
   <mi mathvariant="normal">¬</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>a</mi>
     <mo>∨</mo>
     <mi>b</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <not></not>
    <apply>
     <or></or>
     <ci>a</ci>
     <ci>b</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg(a\vee b)
  </annotation>
 </semantics>
</math>

 the subformula 

<math display="inline" id="Method_of_analytic_tableaux:340">
 <semantics>
  <msub>
   <mi>α</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>α</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha_{1}
  </annotation>
 </semantics>
</math>

 is the negation of 

<math display="inline" id="Method_of_analytic_tableaux:341">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

.</p>

<p>Since every label indicates many equivalent formulae, this notation allows writing a single rule for all these equivalent formulae. For example, the conjunction expansion rule is formulated as:</p>

<p>

<math display="block" id="Method_of_analytic_tableaux:342">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>α</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mfrac>
    <mi>α</mi>
    <mtable>
     <mtr>
      <mtd columnalign="center">
       <msub>
        <mi>α</mi>
        <mn>1</mn>
       </msub>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <msub>
        <mi>α</mi>
        <mn>2</mn>
       </msub>
      </mtd>
     </mtr>
    </mtable>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>α</ci>
    <apply>
     <divide></divide>
     <ci>α</ci>
     <matrix>
      <matrixrow>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>α</ci>
        <cn type="integer">1</cn>
       </apply>
      </matrixrow>
      <matrixrow>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>α</ci>
        <cn type="integer">2</cn>
       </apply>
      </matrixrow>
     </matrix>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\alpha)\frac{\alpha}{\begin{array}[]{c}\alpha_{1}\\
\alpha_{2}\end{array}}
  </annotation>
 </semantics>
</math>

</p>
<h3 id="signed-formulae">Signed formulae</h3>

<p>A formula in a tableau is assumed true. Signed tableaux allows stating that a formula is false. This is generally achieved by adding a label to each formula, where the label <strong><em>T</em></strong> indicates formulae assumed true and <strong><em>F</em></strong> those assumed false. A different but equivalent notation is that to write formulae that are assumed true at the left of the node and formulae assumed false at its right.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Resolution_(logic)" title="wikilink">Resolution (logic)</a></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li>Beth, Evert W., 1955. "Semantic entailment and formal derivability", <em>Mededelingen van de Koninklijke Nederlandse Akademie van Wetenschappen, Afdeling Letterkunde</em>, N.R. Vol 18, no 13, 1955, pp 309–42. Reprinted in Jaakko Intikka (ed.) <em>The Philosophy of Mathematics</em>, Oxford University Press, 1969.</li>
<li>Bostock, David, 1997. <em>Intermediate Logic</em>. Oxford Univ. Press.</li>
<li>M D'Agostino, D Gabbay, R Haehnle, J Posegga (Eds), <em>Handbook of Tableau Methods</em>, Kluwer,1999.</li>
<li>Girle, Rod, 2000. <em>Modal Logics and Philosophy</em>. Teddington UK: Acumen.</li>
<li>Goré, Rajeev (1999) "Tableau Methods for Modal and Temporal Logics" in D'Agostino, M., Dov Gabbay, R. Haehnle, and J. Posegga, eds., <em>Handbook of Tableau Methods</em>. Kluwer: 297-396.</li>
<li><a href="Richard_Jeffrey" title="wikilink">Richard Jeffrey</a>, 1990 (1967). <em>Formal Logic: Its Scope and Limits</em>, 3rd ed. McGraw Hill.</li>
<li><a href="Raymond_Smullyan" title="wikilink">Raymond Smullyan</a>, 1995 (1968). <em>First Order-Logic</em>. Dover Publications.</li>
<li>Melvin Fitting (1996). <em>First-order logic and automated theorem proving</em> (2nd ed.). Springer-Verlag.</li>
<li>Reiner Hähnle (2001). Tableaux and Related Methods. <a href="Handbook_of_Automated_Reasoning" title="wikilink">Handbook of Automated Reasoning</a></li>
<li>Reinhold Letz, Gernot Stenz (2001). Model Elimination and Connection Tableau Procedures. <a href="Handbook_of_Automated_Reasoning" title="wikilink">Handbook of Automated Reasoning</a></li>
<li>Zeman, J. J. (1973) <em><a href="http://www.clas.ufl.edu/users/jzeman/modallogic/">Modal Logic.</a></em> Reidel.</li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://i12www.ira.uka.de/TABLEAUX/">TABLEAUX</a>: an annual international conference on automated reasoning with analytic tableaux and related methods.</li>
<li><a href="http://www.springer.com/computer/theoretical+computer+science/journal/10817">JAR</a>: Journal of Automated Reasoning.</li>
<li><a href="http://lolo.svn.sourceforge.net/viewvc/lolo/">lolo</a>: a simple theorem prover written in Haskell that uses analytic tableaux for propositional logic.</li>
<li><a href="http://hackage.haskell.org/package/tableaux">The tableaux package</a>: an interactive prover for propositional and first-order logic using tableaux.</li>
<li><a href="http://www.umsu.de/logik/trees/">Tree proof generator</a>: another interactive prover for propositional and first-order logic using tableaux.</li>
<li><a href="http://www.irit.fr/Lotrec/">LoTREC</a> A generic tableaux-based prover for modal logics from IRIT/Toulouse University</li>
</ul>

<p>"</p>

<p><a href="Category:Logical_calculi" title="wikilink">Category:Logical calculi</a> <a href="Category:Automated_theorem_proving" title="wikilink">Category:Automated theorem proving</a> <a href="Category:Methods_of_proof" title="wikilink">Category:Methods of proof</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
</ol>
</section>
</body>
</html>
