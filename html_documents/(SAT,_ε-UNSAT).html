<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="38">(SAT, ε-UNSAT)</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>(SAT, ε-UNSAT)</h1>
<hr/>

<p>In <a href="computational_complexity_theory" title="wikilink">computational complexity theory</a>, <strong>(SAT, ε-UNSAT)</strong> is a language that is used in the proof of the <a href="PCP_theorem" title="wikilink">PCP theorem</a>, which relates the language <a href="NP_(complexity)" title="wikilink">NP</a> to <a href="probabilistically_checkable_proof" title="wikilink">probabilistically checkable proof</a> systems.</p>

<p>For a given <a href="conjunctive_normal_form" title="wikilink">3-CNF</a> formula, Φ, and a constant, ε L \in \mbox{PCP}(O(\log n),O(1)), then 

<math display="inline" id="(SAT,_ε-UNSAT):0">
 <semantics>
  <mrow>
   <mi>L</mi>
   <mo>≤</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mtext>SAT</mtext>
    <mo>,</mo>
    <mrow>
     <mi>ϵ</mi>
     <mo>-</mo>
     <mtext>UNSAT</mtext>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <ci>L</ci>
    <interval closure="open">
     <mtext>SAT</mtext>
     <apply>
      <minus></minus>
      <ci>ϵ</ci>
      <mtext>UNSAT</mtext>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L\leq(\mbox{SAT},\epsilon-\mbox{UNSAT})
  </annotation>
 </semantics>
</math>

. (See <a href="PCP_theorem" title="wikilink">PCP theorem</a> for more information)<br/>
Let each bit in the proof <em>y</em> be 

<math display="inline" id="(SAT,_ε-UNSAT):1">
 <semantics>
  <mrow>
   <msub>
    <mi>y</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>y</mi>
    <mn>2</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>y</mi>
    <mi>m</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <ci>m</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{1},y_{2},\ldots,y_{m}
  </annotation>
 </semantics>
</math>

.</p>

<p>First, it is necessary to encode when the verifier accepts in 3CNF clauses 

<math display="inline" id="(SAT,_ε-UNSAT):2">
 <semantics>
  <mrow>
   <mi>ϕ</mi>
   <mo>=</mo>
   <mrow>
    <msub>
     <mo largeop="true" mathsize="160%" stretchy="false" symmetric="true">⋀</mo>
     <mi>r</mi>
    </msub>
    <msub>
     <mi>ϕ</mi>
     <mi>r</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>ϕ</ci>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <and></and>
      <ci>r</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ϕ</ci>
      <ci>r</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi=\bigwedge_{r}\phi_{r}
  </annotation>
 </semantics>
</math>

. Next, for each random string <em>r</em>, construct a sub-formula 

<math display="inline" id="(SAT,_ε-UNSAT):3">
 <semantics>
  <msub>
   <mi>ϕ</mi>
   <mi>r</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ϕ</ci>
    <ci>r</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi_{r}
  </annotation>
 </semantics>
</math>

. For a fixed <em>r</em>, its possible to determine all the variables queried, Enumerate each random string <em>r</em>, and add a clause 

<math display="inline" id="(SAT,_ε-UNSAT):4">
 <semantics>
  <mrow>
   <msub>
    <mi>ϕ</mi>
    <mi>r</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>f</mi>
     <mi>r</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>y</mi>
      <msub>
       <mi>i</mi>
       <mn>1</mn>
      </msub>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>y</mi>
      <msub>
       <mi>i</mi>
       <mn>2</mn>
      </msub>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <msub>
      <mi>y</mi>
      <msub>
       <mi>i</mi>
       <mi>q</mi>
      </msub>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ϕ</ci>
     <ci>r</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <ci>r</ci>
     </apply>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>i</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>i</ci>
        <ci>q</ci>
       </apply>
      </apply>
     </vector>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi_{r}=f_{r}(y_{i_{1}},y_{i_{2}},\ldots,y_{i_{q}})
  </annotation>
 </semantics>
</math>


, where 

<math display="inline" id="(SAT,_ε-UNSAT):5">
 <semantics>
  <msub>
   <mi>f</mi>
   <mi>r</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>f</ci>
    <ci>r</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{r}
  </annotation>
 </semantics>
</math>

 is true if and only if the PCP system accepts on reading the given random bits <em>r</em>. There are at most 

<math display="inline" id="(SAT,_ε-UNSAT):6">
 <semantics>
  <msup>
   <mn>2</mn>
   <mi>q</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <ci>q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{q}
  </annotation>
 </semantics>
</math>

 SAT clauses. After these clauses are converted into 3CNF clauses, there are at most 

<math display="inline" id="(SAT,_ε-UNSAT):7">
 <semantics>
  <mrow>
   <mi>q</mi>
   <msup>
    <mn>2</mn>
    <mi>q</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>q</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <ci>q</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q2^{q}
  </annotation>
 </semantics>
</math>

 clauses.</p>

<p>If 

<math display="inline" id="(SAT,_ε-UNSAT):8">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>∈</mo>
   <mi>L</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>x</ci>
    <ci>L</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\in L
  </annotation>
 </semantics>
</math>

, then there is a proof <em>y</em> such that is accepted for every random string <em>r</em>. Therefore 

<math display="inline" id="(SAT,_ε-UNSAT):9">
 <semantics>
  <mrow>
   <mi>ϕ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>y</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>y</mi>
     <mn>2</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>y</mi>
     <mi>m</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>ϕ</ci>
    <vector>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <ci>m</ci>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi(y_{1},y_{2},\ldots,y_{m})
  </annotation>
 </semantics>
</math>


 is satisfiable.<br/>
If 

<math display="inline" id="(SAT,_ε-UNSAT):10">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>∉</mo>
   <mi>L</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <notin></notin>
    <ci>x</ci>
    <ci>L</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\notin L
  </annotation>
 </semantics>
</math>

, then for every assignment to 

<math display="inline" id="(SAT,_ε-UNSAT):11">
 <semantics>
  <mrow>
   <msub>
    <mi>y</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>y</mi>
    <mn>2</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>y</mi>
    <mi>m</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <ci>m</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{1},y_{2},\ldots,y_{m}
  </annotation>
 </semantics>
</math>

 the corresponding proof causes the verifier to reject for half of the random strings <em>r</em>. For each <em>r</em> that is rejected one of the clauses in 

<math display="inline" id="(SAT,_ε-UNSAT):12">
 <semantics>
  <msub>
   <mi>f</mi>
   <mi>r</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>f</ci>
    <ci>r</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{r}
  </annotation>
 </semantics>
</math>

 fails. Therefore at least 

<math display="inline" id="(SAT,_ε-UNSAT):13">
 <semantics>
  <mrow>
   <mi>ϵ</mi>
   <mo>=</mo>
   <mfrac>
    <mn>1</mn>
    <mrow>
     <mn>2</mn>
     <mi>q</mi>
     <msup>
      <mn>2</mn>
      <mi>q</mi>
     </msup>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>ϵ</ci>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <ci>q</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">2</cn>
       <ci>q</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon=\frac{1}{2q2^{q}}
  </annotation>
 </semantics>
</math>

 fraction of the clauses fail.</p>

<p>Therefore 

<math display="inline" id="(SAT,_ε-UNSAT):14">
 <semantics>
  <mrow>
   <mi>L</mi>
   <mo>≤</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mtext>SAT</mtext>
    <mo>,</mo>
    <mrow>
     <mi>ϵ</mi>
     <mo>-</mo>
     <mtext>UNSAT</mtext>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <ci>L</ci>
    <interval closure="open">
     <mtext>SAT</mtext>
     <apply>
      <minus></minus>
      <ci>ϵ</ci>
      <mtext>UNSAT</mtext>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L\leq(\mbox{SAT},\epsilon-\mbox{UNSAT})
  </annotation>
 </semantics>
</math>


.</p>

<p>For 

<math display="inline" id="(SAT,_ε-UNSAT):15">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>S</mi>
     <mi>A</mi>
     <mi>T</mi>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mi>ϵ</mi>
     <mo>-</mo>
     <mrow>
      <mi>U</mi>
      <mi>N</mi>
      <mi>S</mi>
      <mi>A</mi>
      <mi>T</mi>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∈</mo>
   <mrow>
    <mi>P</mi>
    <mi>C</mi>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>O</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>log</mi>
        <mi>n</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mi>O</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mn>1</mn>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <interval closure="open">
     <apply>
      <times></times>
      <ci>S</ci>
      <ci>A</ci>
      <ci>T</ci>
     </apply>
     <apply>
      <minus></minus>
      <ci>ϵ</ci>
      <apply>
       <times></times>
       <ci>U</ci>
       <ci>N</ci>
       <ci>S</ci>
       <ci>A</ci>
       <ci>T</ci>
      </apply>
     </apply>
    </interval>
    <apply>
     <times></times>
     <ci>P</ci>
     <ci>C</ci>
     <ci>P</ci>
     <interval closure="open">
      <apply>
       <times></times>
       <ci>O</ci>
       <apply>
        <log></log>
        <ci>n</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>O</ci>
       <cn type="integer">1</cn>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (SAT,\epsilon-UNSAT)\in PCP(O(\log n),O(1))
  </annotation>
 </semantics>
</math>

, let the proof that the PCP system reads be a satisfying assignment for the input <a href="Conjunctive_normal_form" title="wikilink">3-CNF</a>, Φ. The system chooses 

<math display="inline" id="(SAT,_ε-UNSAT):16">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mn>1</mn>
     <mo>/</mo>
     <mi>ϵ</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <ci>ϵ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(1/\epsilon)
  </annotation>
 </semantics>
</math>

 clauses of the proof to check if they are truly satisfied. Note that only 

<math display="inline" id="(SAT,_ε-UNSAT):17">
 <semantics>
  <mrow>
   <mi>log</mi>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <log></log>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \log n
  </annotation>
 </semantics>
</math>

 random bits are needed to choose one of 

<math display="inline" id="(SAT,_ε-UNSAT):18">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 clauses, and thus only 

<math display="inline" id="(SAT,_ε-UNSAT):19">
 <semantics>
  <mrow>
   <mrow>
    <mi>O</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>log</mi>
      <mrow>
       <mi>n</mi>
       <mo>/</mo>
       <mi>ϵ</mi>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>O</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>log</mi>
      <mi>n</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>O</ci>
     <apply>
      <log></log>
      <apply>
       <divide></divide>
       <ci>n</ci>
       <ci>ϵ</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>O</ci>
     <apply>
      <log></log>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(\log n/\epsilon)=O(\log n)
  </annotation>
 </semantics>
</math>


 total random bits are needed. (Remember that ε is a constant.) For each clause to be checked, only 3 bits need to be read, and thus only 

<math display="inline" id="(SAT,_ε-UNSAT):20">
 <semantics>
  <mrow>
   <mrow>
    <mi>O</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mn>3</mn>
      <mo>/</mo>
      <mi>ϵ</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>O</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>1</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>O</ci>
     <apply>
      <divide></divide>
      <cn type="integer">3</cn>
      <ci>ϵ</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>O</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(3/\epsilon)=O(1)
  </annotation>
 </semantics>
</math>

 (a constant number) of bits from the proof need to be read. The system rejects if any of the clauses are not satisfied. If Φ is satisfiable, then there exists a proof (a truly satisfying assignment) that the system will always accept. If Φ is not in (SAT, ε-UNSAT), this means that an ε fraction of the clauses is not satisfiable. The probability that this system will accept in this case is 

<math display="inline" id="(SAT,_ε-UNSAT):21">
 <semantics>
  <mrow>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mn>1</mn>
      <mo>-</mo>
      <mi>ϵ</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mn>1</mn>
     <mo>/</mo>
     <mi>ϵ</mi>
    </mrow>
   </msup>
   <mo>≤</mo>
   <mrow>
    <mn>1</mn>
    <mo>/</mo>
    <mi>e</mi>
   </mrow>
   <mo><</mo>
   <mrow>
    <mn>1</mn>
    <mo>/</mo>
    <mn>2</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
       <ci>ϵ</ci>
      </apply>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <ci>ϵ</ci>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <ci>e</ci>
     </apply>
    </apply>
    <apply>
     <lt></lt>
     <share href="#.cmml">
     </share>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (1-\epsilon)^{1/\epsilon}\leq 1/e<1/2
  </annotation>
 </semantics>
</math>

. Therefore, 

<math display="inline" id="(SAT,_ε-UNSAT):22">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>S</mi>
     <mi>A</mi>
     <mi>T</mi>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mi>ϵ</mi>
     <mo>-</mo>
     <mrow>
      <mi>U</mi>
      <mi>N</mi>
      <mi>S</mi>
      <mi>A</mi>
      <mi>T</mi>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∈</mo>
   <mrow>
    <mi>P</mi>
    <mi>C</mi>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>O</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>log</mi>
        <mi>n</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mi>O</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mn>1</mn>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <interval closure="open">
     <apply>
      <times></times>
      <ci>S</ci>
      <ci>A</ci>
      <ci>T</ci>
     </apply>
     <apply>
      <minus></minus>
      <ci>ϵ</ci>
      <apply>
       <times></times>
       <ci>U</ci>
       <ci>N</ci>
       <ci>S</ci>
       <ci>A</ci>
       <ci>T</ci>
      </apply>
     </apply>
    </interval>
    <apply>
     <times></times>
     <ci>P</ci>
     <ci>C</ci>
     <ci>P</ci>
     <interval closure="open">
      <apply>
       <times></times>
       <ci>O</ci>
       <apply>
        <log></log>
        <ci>n</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>O</ci>
       <cn type="integer">1</cn>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (SAT,\epsilon-UNSAT)\in PCP(O(\log n),O(1))
  </annotation>
 </semantics>
</math>

.</p>

<p>(SAT, ε-UNSAT) is an <a class="uri" href="NP-hard" title="wikilink">NP-hard</a> language. As part of the proof of the <a href="PCP_theorem" title="wikilink">PCP theorem</a>, (SAT, ε-UNSAT) has also been shown to be in PCP(O(log n), O(1)).</p>

<p>"</p>

<p><a href="Category:NP-complete_problems" title="wikilink">Category:NP-complete problems</a></p>
</body>
</html>
