<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="790">Skolem normal form</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Skolem normal form</h1>
<hr/>

<p>In <a href="mathematical_logic" title="wikilink">mathematical logic</a>, reduction to <strong>Skolem normal form</strong> (SNF) is a method for removing <a href="existential_quantification" title="wikilink">existential quantifiers</a> from <a href="formal_logic" title="wikilink">formal logic</a> statements, often performed as the first step in an <a href="automated_theorem_prover" title="wikilink">automated theorem prover</a>.</p>

<p>A <a class="uri" href="formula" title="wikilink">formula</a> of <a href="first-order_logic" title="wikilink">first-order logic</a> is in Skolem normal form (named after <a href="Thoralf_Skolem" title="wikilink">Thoralf Skolem</a>) if it is in <a href="prenex_normal_form" title="wikilink">prenex normal form</a> with only <a href="Universal_quantification" title="wikilink">universal first-order quantifiers</a>. Every first-order <a href="Well-formed_formula" title="wikilink">formula</a> may be converted into Skolem normal form while not changing its <a class="uri" href="satisfiability" title="wikilink">satisfiability</a> via a process called <strong>Skolemization</strong> (sometimes spelled "Skolemnization"). The resulting formula is not necessarily <a href="logical_equivalence" title="wikilink">equivalent</a> to the original one, but is <a class="uri" href="equisatisfiable" title="wikilink">equisatisfiable</a> with it: it is satisfiable if and only if the original one is satisfiable.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>

<p>The simplest form of Skolemization is for existentially quantified variables which are not inside the scope of a universal quantifier. These may be replaced simply by creating new constants. For example, 

<math display="inline" id="Skolem_normal_form:0">
 <semantics>
  <mrow>
   <mo>∃</mo>
   <mrow>
    <mi>x</mi>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <exists></exists>
    <apply>
     <times></times>
     <ci>x</ci>
     <ci>P</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \exists xP(x)
  </annotation>
 </semantics>
</math>

 may be changed to 

<math display="inline" id="Skolem_normal_form:1">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>c</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <ci>c</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(c)
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Skolem_normal_form:2">
 <semantics>
  <mi>c</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>c</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c
  </annotation>
 </semantics>
</math>

 is a new constant (does not occur anywhere else in the formula).</p>

<p>More generally, Skolemization is performed by replacing every existentially quantified variable 

<math display="inline" id="Skolem_normal_form:3">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

 with a term 

<math display="inline" id="Skolem_normal_form:4">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>x</mi>
     <mi>n</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <vector>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>n</ci>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x_{1},\ldots,x_{n})
  </annotation>
 </semantics>
</math>

 whose function symbol 

<math display="inline" id="Skolem_normal_form:5">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 is new. The variables of this term are as follows. If the formula is in <a href="prenex_normal_form" title="wikilink">prenex normal form</a>, 

<math display="inline" id="Skolem_normal_form:6">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>x</mi>
    <mi>n</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>n</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1},\ldots,x_{n}
  </annotation>
 </semantics>
</math>

 are the variables that are universally quantified and whose quantifiers precede that of 

<math display="inline" id="Skolem_normal_form:7">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

. In general, they are the variables that are quantified universally  and such that 

<math display="inline" id="Skolem_normal_form:8">
 <semantics>
  <mrow>
   <mo>∃</mo>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <exists></exists>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \exists y
  </annotation>
 </semantics>
</math>

 occurs in the scope of their quantifiers. The function 

<math display="inline" id="Skolem_normal_form:9">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 introduced in this process is called a <strong>Skolem function</strong> (or <strong>Skolem constant</strong> if it is of zero <a class="uri" href="arity" title="wikilink">arity</a>) and the term is called a <strong>Skolem term</strong>.</p>

<p>As an example, the formula 

<math display="inline" id="Skolem_normal_form:10">
 <semantics>
  <mrow>
   <mrow>
    <mo>∀</mo>
    <mrow>
     <mi>x</mi>
     <mrow>
      <mo>∃</mo>
      <mrow>
       <mi>y</mi>
       <mrow>
        <mo>∀</mo>
        <mi>z</mi>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo>,</mo>
     <mi>z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <csymbol cd="latexml">for-all</csymbol>
     <apply>
      <times></times>
      <ci>x</ci>
      <apply>
       <exists></exists>
       <apply>
        <times></times>
        <ci>y</ci>
        <apply>
         <csymbol cd="latexml">for-all</csymbol>
         <ci>z</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>P</ci>
     <vector>
      <ci>x</ci>
      <ci>y</ci>
      <ci>z</ci>
     </vector>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall x\exists y\forall z.P(x,y,z)
  </annotation>
 </semantics>
</math>

 is not in Skolem normal form because it contains the existential quantifier 

<math display="inline" id="Skolem_normal_form:11">
 <semantics>
  <mrow>
   <mo>∃</mo>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <exists></exists>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \exists y
  </annotation>
 </semantics>
</math>

. Skolemization replaces 

<math display="inline" id="Skolem_normal_form:12">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

 with 

<math display="inline" id="Skolem_normal_form:13">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x)
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Skolem_normal_form:14">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 is a new function symbol, and removes the quantification over 

<math display="inline" id="Skolem_normal_form:15">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

. The resulting formula is 

<math display="inline" id="Skolem_normal_form:16">
 <semantics>
  <mrow>
   <mrow>
    <mo>∀</mo>
    <mrow>
     <mi>x</mi>
     <mrow>
      <mo>∀</mo>
      <mi>z</mi>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mi>z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <csymbol cd="latexml">for-all</csymbol>
     <apply>
      <times></times>
      <ci>x</ci>
      <apply>
       <csymbol cd="latexml">for-all</csymbol>
       <ci>z</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>P</ci>
     <vector>
      <ci>x</ci>
      <apply>
       <times></times>
       <ci>f</ci>
       <ci>x</ci>
      </apply>
      <ci>z</ci>
     </vector>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall x\forall z.P(x,f(x),z)
  </annotation>
 </semantics>
</math>

. The Skolem term 

<math display="inline" id="Skolem_normal_form:17">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x)
  </annotation>
 </semantics>
</math>

 contains 

<math display="inline" id="Skolem_normal_form:18">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

, but not 

<math display="inline" id="Skolem_normal_form:19">
 <semantics>
  <mi>z</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>z</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z
  </annotation>
 </semantics>
</math>

, because the quantifier to be removed 

<math display="inline" id="Skolem_normal_form:20">
 <semantics>
  <mrow>
   <mo>∃</mo>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <exists></exists>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \exists y
  </annotation>
 </semantics>
</math>

 is in the scope of 

<math display="inline" id="Skolem_normal_form:21">
 <semantics>
  <mrow>
   <mo>∀</mo>
   <mi>x</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">for-all</csymbol>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall x
  </annotation>
 </semantics>
</math>

, but not in that of 

<math display="inline" id="Skolem_normal_form:22">
 <semantics>
  <mrow>
   <mo>∀</mo>
   <mi>z</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">for-all</csymbol>
    <ci>z</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall z
  </annotation>
 </semantics>
</math>

; since this formula is in prenex normal form, this is equivalent to saying that, in the list of quantifers, 

<math display="inline" id="Skolem_normal_form:23">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 precedes 

<math display="inline" id="Skolem_normal_form:24">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

 while 

<math display="inline" id="Skolem_normal_form:25">
 <semantics>
  <mi>z</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>z</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z
  </annotation>
 </semantics>
</math>

 does not. The formula obtained by this transformation is satisfiable if and only if, the original formula is.</p>
<h2 id="how-skolemization-works">How Skolemization works</h2>

<p>Skolemization works by applying a <a href="second-order_logic" title="wikilink">second-order</a> equivalence in conjunction to the definition of first-order satisfiability. The equivalence provides a way for "moving" an existential quantifier before a universal one.</p>

<p>

<math display="block" id="Skolem_normal_form:26">
 <semantics>
  <mrow>
   <mrow>
    <mo>∀</mo>
    <mrow>
     <mi>x</mi>
     <mrow>
      <mo maxsize="160%" minsize="160%">(</mo>
      <mrow>
       <mrow>
        <mi>R</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mi>g</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>x</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>∨</mo>
       <mrow>
        <mo>∃</mo>
        <mrow>
         <mi>y</mi>
         <mi>R</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>x</mi>
          <mo>,</mo>
          <mi>y</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
      </mrow>
      <mo maxsize="160%" minsize="160%">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>⇔</mo>
   <mrow>
    <mo>∀</mo>
    <mrow>
     <mi>x</mi>
     <mrow>
      <mo maxsize="160%" minsize="160%">(</mo>
      <mrow>
       <mrow>
        <mi>R</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mi>g</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>x</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>∨</mo>
       <mrow>
        <mi>R</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>x</mi>
         <mo>,</mo>
         <mrow>
          <mi>f</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>x</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
      <mo maxsize="160%" minsize="160%">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">iff</csymbol>
    <apply>
     <csymbol cd="latexml">for-all</csymbol>
     <apply>
      <times></times>
      <ci>x</ci>
      <apply>
       <or></or>
       <apply>
        <times></times>
        <ci>R</ci>
        <apply>
         <times></times>
         <ci>g</ci>
         <ci>x</ci>
        </apply>
       </apply>
       <apply>
        <exists></exists>
        <apply>
         <times></times>
         <ci>y</ci>
         <ci>R</ci>
         <interval closure="open">
          <ci>x</ci>
          <ci>y</ci>
         </interval>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">for-all</csymbol>
     <apply>
      <times></times>
      <ci>x</ci>
      <apply>
       <or></or>
       <apply>
        <times></times>
        <ci>R</ci>
        <apply>
         <times></times>
         <ci>g</ci>
         <ci>x</ci>
        </apply>
       </apply>
       <apply>
        <times></times>
        <ci>R</ci>
        <interval closure="open">
         <ci>x</ci>
         <apply>
          <times></times>
          <ci>f</ci>
          <ci>x</ci>
         </apply>
        </interval>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall x\Big(R(g(x))\vee\exists yR(x,y)\Big)\iff\forall x\Big(R(g(x))\vee R(x%
,f(x))\Big)
  </annotation>
 </semantics>
</math>

 where</p>

<p>

<math display="block" id="Skolem_normal_form:27">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x)
  </annotation>
 </semantics>
</math>

 is a function that maps 

<math display="inline" id="Skolem_normal_form:28">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Skolem_normal_form:29">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

.</p>

<p>Intuitively, the sentence "for every 

<math display="inline" id="Skolem_normal_form:30">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 there exists a 

<math display="inline" id="Skolem_normal_form:31">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Skolem_normal_form:32">
 <semantics>
  <mrow>
   <mi>R</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>R</ci>
    <interval closure="open">
     <ci>x</ci>
     <ci>y</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R(x,y)
  </annotation>
 </semantics>
</math>

" is converted into the equivalent form "there exists a function 

<math display="inline" id="Skolem_normal_form:33">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 mapping every 

<math display="inline" id="Skolem_normal_form:34">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 into a 

<math display="inline" id="Skolem_normal_form:35">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

 such that, for every 

<math display="inline" id="Skolem_normal_form:36">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 it holds 

<math display="inline" id="Skolem_normal_form:37">
 <semantics>
  <mrow>
   <mi>R</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>R</ci>
    <interval closure="open">
     <ci>x</ci>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>x</ci>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R(x,f(x))
  </annotation>
 </semantics>
</math>

".</p>

<p>This equivalence is useful because the definition of first-order satisfiability implicitly existentially quantifies over the evaluation of function symbols. In particular, a first-order formula 

<math display="inline" id="Skolem_normal_form:38">
 <semantics>
  <mi mathvariant="normal">Φ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Φ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Phi
  </annotation>
 </semantics>
</math>

 is satisfiable if there exists a model 

<math display="inline" id="Skolem_normal_form:39">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 and an evaluation 

<math display="inline" id="Skolem_normal_form:40">
 <semantics>
  <mi>μ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>μ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu
  </annotation>
 </semantics>
</math>

 of the free variables of the formula that evaluate the formula to <em>true</em>. The model contains the evaluation of all function symbols; therefore, Skolem functions are implicitly, existentially quantified. In the example above, 

<math display="inline" id="Skolem_normal_form:41">
 <semantics>
  <mrow>
   <mrow>
    <mo>∀</mo>
    <mi>x</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>R</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <csymbol cd="latexml">for-all</csymbol>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <ci>R</ci>
     <interval closure="open">
      <ci>x</ci>
      <apply>
       <times></times>
       <ci>f</ci>
       <ci>x</ci>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall x.R(x,f(x))
  </annotation>
 </semantics>
</math>

 is satisfiable if and only if, there exists a model 

<math display="inline" id="Skolem_normal_form:42">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

, which contains an evaluation for 

<math display="inline" id="Skolem_normal_form:43">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

, such that 

<math display="inline" id="Skolem_normal_form:44">
 <semantics>
  <mrow>
   <mrow>
    <mo>∀</mo>
    <mi>x</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>R</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <csymbol cd="latexml">for-all</csymbol>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <ci>R</ci>
     <interval closure="open">
      <ci>x</ci>
      <apply>
       <times></times>
       <ci>f</ci>
       <ci>x</ci>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall x.R(x,f(x))
  </annotation>
 </semantics>
</math>

 is true for some evaluation of its free variables (none in this case). This may be expressed in second order as 

<math display="inline" id="Skolem_normal_form:45">
 <semantics>
  <mrow>
   <mrow>
    <mo>∃</mo>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo>∀</mo>
      <mi>x</mi>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>R</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <exists></exists>
     <apply>
      <times></times>
      <ci>f</ci>
      <apply>
       <csymbol cd="latexml">for-all</csymbol>
       <ci>x</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>R</ci>
     <interval closure="open">
      <ci>x</ci>
      <apply>
       <times></times>
       <ci>f</ci>
       <ci>x</ci>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \exists f\forall x.R(x,f(x))
  </annotation>
 </semantics>
</math>

. By the above equivalence, this is the same as the satisfiability of 

<math display="inline" id="Skolem_normal_form:46">
 <semantics>
  <mrow>
   <mrow>
    <mo>∀</mo>
    <mrow>
     <mi>x</mi>
     <mrow>
      <mo>∃</mo>
      <mi>y</mi>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>R</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <csymbol cd="latexml">for-all</csymbol>
     <apply>
      <times></times>
      <ci>x</ci>
      <apply>
       <exists></exists>
       <ci>y</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>R</ci>
     <interval closure="open">
      <ci>x</ci>
      <ci>y</ci>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall x\exists y.R(x,y)
  </annotation>
 </semantics>
</math>

.</p>

<p>At the meta-level, <a href="First-order_logic#Semantics" title="wikilink">first-order satisfiability</a> of a formula 

<math display="inline" id="Skolem_normal_form:47">
 <semantics>
  <mi mathvariant="normal">Φ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Φ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Phi
  </annotation>
 </semantics>
</math>

 may be written with a little abuse of notation as 

<math display="inline" id="Skolem_normal_form:48">
 <semantics>
  <mrow>
   <mo>∃</mo>
   <mi>M</mi>
   <mo>∃</mo>
   <mpadded width="+3.3pt">
    <mi>μ</mi>
   </mpadded>
   <mo rspace="5.8pt">.</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>M</mi>
    <mo>,</mo>
    <mi>μ</mi>
    <mo>⊧</mo>
    <mi mathvariant="normal">Φ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <exists></exists>
    <csymbol cd="unknown">M</csymbol>
    <exists></exists>
    <csymbol cd="unknown">μ</csymbol>
    <ci>normal-.</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">M</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">μ</csymbol>
     <csymbol cd="latexml">models</csymbol>
     <csymbol cd="unknown">Φ</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \exists M\exists\mu~{}.~{}(M,\mu\models\Phi)
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Skolem_normal_form:49">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 is a model, 

<math display="inline" id="Skolem_normal_form:50">
 <semantics>
  <mi>μ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>μ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu
  </annotation>
 </semantics>
</math>

 is an evaluation of the free variables, and 

<math display="inline" id="Skolem_normal_form:51">
 <semantics>
  <mo>⊧</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">models</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \models
  </annotation>
 </semantics>
</math>

 means that 

<math display="inline" id="Skolem_normal_form:52">
 <semantics>
  <mi mathvariant="normal">Φ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Φ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Phi
  </annotation>
 </semantics>
</math>

 is true in 

<math display="inline" id="Skolem_normal_form:53">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 under 

<math display="inline" id="Skolem_normal_form:54">
 <semantics>
  <mi>μ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>μ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu
  </annotation>
 </semantics>
</math>

. Since first-order models contain the evaluation of all function symbols, any Skolem function 

<math display="inline" id="Skolem_normal_form:55">
 <semantics>
  <mi mathvariant="normal">Φ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Φ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Phi
  </annotation>
 </semantics>
</math>

 contains is implicitly, existentially quantified by 

<math display="inline" id="Skolem_normal_form:56">
 <semantics>
  <mrow>
   <mo>∃</mo>
   <mi>M</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <exists></exists>
    <ci>M</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \exists M
  </annotation>
 </semantics>
</math>

. As a result, after replacing an existential quantifier over variables into an existential quantifiers over functions at the front of the formula, the formula still may be treated as a first-order one by removing these existential quantifiers. This final step of treating 

<math display="inline" id="Skolem_normal_form:57">
 <semantics>
  <mrow>
   <mrow>
    <mo>∃</mo>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo>∀</mo>
      <mi>x</mi>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>R</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <exists></exists>
     <apply>
      <times></times>
      <ci>f</ci>
      <apply>
       <csymbol cd="latexml">for-all</csymbol>
       <ci>x</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>R</ci>
     <interval closure="open">
      <ci>x</ci>
      <apply>
       <times></times>
       <ci>f</ci>
       <ci>x</ci>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \exists f\forall x.R(x,f(x))
  </annotation>
 </semantics>
</math>

 as 

<math display="inline" id="Skolem_normal_form:58">
 <semantics>
  <mrow>
   <mrow>
    <mo>∀</mo>
    <mi>x</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>R</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <csymbol cd="latexml">for-all</csymbol>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <ci>R</ci>
     <interval closure="open">
      <ci>x</ci>
      <apply>
       <times></times>
       <ci>f</ci>
       <ci>x</ci>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall x.R(x,f(x))
  </annotation>
 </semantics>
</math>

 may be completed because functions are implicitly existentially quantified by 

<math display="inline" id="Skolem_normal_form:59">
 <semantics>
  <mrow>
   <mo>∃</mo>
   <mi>M</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <exists></exists>
    <ci>M</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \exists M
  </annotation>
 </semantics>
</math>

 in the definition of first-order satisfiability.</p>

<p>Correctness of Skolemization may be shown on the example formula 

<math display="inline" id="Skolem_normal_form:60">
 <semantics>
  <mrow>
   <msub>
    <mi>F</mi>
    <mn>1</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo>∀</mo>
    <mrow>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mi mathvariant="normal">…</mi>
     <mrow>
      <mo>∀</mo>
      <mrow>
       <msub>
        <mi>x</mi>
        <mi>n</mi>
       </msub>
       <mrow>
        <mo>∃</mo>
        <mrow>
         <mi>y</mi>
         <mi>R</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <msub>
           <mi>x</mi>
           <mn>1</mn>
          </msub>
          <mo>,</mo>
          <mi mathvariant="normal">…</mi>
          <mo>,</mo>
          <msub>
           <mi>x</mi>
           <mi>n</mi>
          </msub>
          <mo>,</mo>
          <mi>y</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>F</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="latexml">for-all</csymbol>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="latexml">for-all</csymbol>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>n</ci>
        </apply>
        <apply>
         <exists></exists>
         <apply>
          <times></times>
          <ci>y</ci>
          <ci>R</ci>
          <vector>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>x</ci>
            <cn type="integer">1</cn>
           </apply>
           <ci>normal-…</ci>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>x</ci>
            <ci>n</ci>
           </apply>
           <ci>y</ci>
          </vector>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F_{1}=\forall x_{1}\dots\forall x_{n}\exists yR(x_{1},\dots,x_{n},y)
  </annotation>
 </semantics>
</math>

 as follows. This formula is satisfied by a <a href="model_(abstract)" title="wikilink">model</a> 

<math display="inline" id="Skolem_normal_form:61">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 if and only if, for each possible value for 

<math display="inline" id="Skolem_normal_form:62">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>x</mi>
    <mi>n</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>n</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1},\dots,x_{n}
  </annotation>
 </semantics>
</math>

 in the domain of the model there exists a value for 

<math display="inline" id="Skolem_normal_form:63">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

 in the domain of the model that makes 

<math display="inline" id="Skolem_normal_form:64">
 <semantics>
  <mrow>
   <mi>R</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>x</mi>
     <mi>n</mi>
    </msub>
    <mo>,</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>R</ci>
    <vector>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>n</ci>
     </apply>
     <ci>y</ci>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R(x_{1},\dots,x_{n},y)
  </annotation>
 </semantics>
</math>

 true. By the <a href="axiom_of_choice" title="wikilink">axiom of choice</a>, there exists a function 

<math display="inline" id="Skolem_normal_form:65">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Skolem_normal_form:66">
 <semantics>
  <mrow>
   <mi>y</mi>
   <mo>=</mo>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <msub>
      <mi>x</mi>
      <mi>n</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>y</ci>
    <apply>
     <times></times>
     <ci>f</ci>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>n</ci>
      </apply>
     </vector>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y=f(x_{1},\dots,x_{n})
  </annotation>
 </semantics>
</math>

. As a result, the formula 

<math display="inline" id="Skolem_normal_form:67">
 <semantics>
  <mrow>
   <msub>
    <mi>F</mi>
    <mn>2</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo>∀</mo>
    <mrow>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mi mathvariant="normal">…</mi>
     <mrow>
      <mo>∀</mo>
      <mrow>
       <msub>
        <mi>x</mi>
        <mi>n</mi>
       </msub>
       <mi>R</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>x</mi>
         <mn>1</mn>
        </msub>
        <mo>,</mo>
        <mi mathvariant="normal">…</mi>
        <mo>,</mo>
        <msub>
         <mi>x</mi>
         <mi>n</mi>
        </msub>
        <mo>,</mo>
        <mrow>
         <mi>f</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <msub>
           <mi>x</mi>
           <mn>1</mn>
          </msub>
          <mo>,</mo>
          <mi mathvariant="normal">…</mi>
          <mo>,</mo>
          <msub>
           <mi>x</mi>
           <mi>n</mi>
          </msub>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>F</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <csymbol cd="latexml">for-all</csymbol>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="latexml">for-all</csymbol>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>n</ci>
        </apply>
        <ci>R</ci>
        <vector>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <cn type="integer">1</cn>
         </apply>
         <ci>normal-…</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <ci>n</ci>
         </apply>
         <apply>
          <times></times>
          <ci>f</ci>
          <vector>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>x</ci>
            <cn type="integer">1</cn>
           </apply>
           <ci>normal-…</ci>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>x</ci>
            <ci>n</ci>
           </apply>
          </vector>
         </apply>
        </vector>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F_{2}=\forall x_{1}\dots\forall x_{n}R(x_{1},\dots,x_{n},f(x_{1},\dots,x_{n}))
  </annotation>
 </semantics>
</math>

 is satisfiable, because it has the model obtained by adding the evaluation of 

<math display="inline" id="Skolem_normal_form:68">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Skolem_normal_form:69">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

. This shows that 

<math display="inline" id="Skolem_normal_form:70">
 <semantics>
  <msub>
   <mi>F</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>F</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F_{1}
  </annotation>
 </semantics>
</math>

 is satisfiable only if 

<math display="inline" id="Skolem_normal_form:71">
 <semantics>
  <msub>
   <mi>F</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>F</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F_{2}
  </annotation>
 </semantics>
</math>

 is satisfiable as well. In the other way around, if 

<math display="inline" id="Skolem_normal_form:72">
 <semantics>
  <msub>
   <mi>F</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>F</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F_{2}
  </annotation>
 </semantics>
</math>

 is satisfiable, then there exists a model 

<math display="inline" id="Skolem_normal_form:73">
 <semantics>
  <msup>
   <mi>M</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>M</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M^{\prime}
  </annotation>
 </semantics>
</math>

 that satisfies it; this model includes an evaluation for the function 

<math display="inline" id="Skolem_normal_form:74">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 such that, for every value of 

<math display="inline" id="Skolem_normal_form:75">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>x</mi>
    <mi>n</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>n</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1},\dots,x_{n}
  </annotation>
 </semantics>
</math>

, the formula 

<math display="inline" id="Skolem_normal_form:76">
 <semantics>
  <mrow>
   <mi>R</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>x</mi>
     <mi>n</mi>
    </msub>
    <mo>,</mo>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mn>1</mn>
      </msub>
      <mo>,</mo>
      <mi mathvariant="normal">…</mi>
      <mo>,</mo>
      <msub>
       <mi>x</mi>
       <mi>n</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>R</ci>
    <vector>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <vector>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>normal-…</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>n</ci>
       </apply>
      </vector>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R(x_{1},\dots,x_{n},f(x_{1},\dots,x_{n}))
  </annotation>
 </semantics>
</math>

 holds. As a result, 

<math display="inline" id="Skolem_normal_form:77">
 <semantics>
  <msub>
   <mi>F</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>F</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F_{1}
  </annotation>
 </semantics>
</math>

 is satisfied by the same model because one may choose, for every value of 

<math display="inline" id="Skolem_normal_form:78">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>x</mi>
    <mi>n</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>n</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1},\ldots,x_{n}
  </annotation>
 </semantics>
</math>

, the value 

<math display="inline" id="Skolem_normal_form:79">
 <semantics>
  <mrow>
   <mi>y</mi>
   <mo>=</mo>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <msub>
      <mi>x</mi>
      <mi>n</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>y</ci>
    <apply>
     <times></times>
     <ci>f</ci>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>n</ci>
      </apply>
     </vector>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y=f(x_{1},\dots,x_{n})
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Skolem_normal_form:80">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 is evaluated according to 

<math display="inline" id="Skolem_normal_form:81">
 <semantics>
  <msup>
   <mi>M</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>M</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M^{\prime}
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="uses-of-skolemization">Uses of Skolemization</h2>

<p>One of the uses of Skolemization is <a href="automated_theorem_proving" title="wikilink">automated theorem proving</a>. For example, in the <a href="method_of_analytic_tableaux" title="wikilink">method of analytic tableaux</a>, whenever a formula whose leading quantifier is existential occurs, the formula obtained by removing that quantifier via Skolemization may be generated. For example, if 

<math display="inline" id="Skolem_normal_form:82">
 <semantics>
  <mrow>
   <mrow>
    <mo>∃</mo>
    <mi>x</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi mathvariant="normal">Φ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <msub>
      <mi>y</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <msub>
      <mi>y</mi>
      <mi>n</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <exists></exists>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <ci>normal-Φ</ci>
     <vector>
      <ci>x</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <ci>n</ci>
      </apply>
     </vector>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \exists x.\Phi(x,y_{1},\ldots,y_{n})
  </annotation>
 </semantics>
</math>

 occurs in a tableau, where 

<math display="inline" id="Skolem_normal_form:83">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>,</mo>
   <msub>
    <mi>y</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>y</mi>
    <mi>n</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>x</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <ci>n</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x,y_{1},\ldots,y_{n}
  </annotation>
 </semantics>
</math>

 are the free variables of 

<math display="inline" id="Skolem_normal_form:84">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Φ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <msub>
     <mi>y</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>y</mi>
     <mi>n</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Φ</ci>
    <vector>
     <ci>x</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <ci>n</ci>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Phi(x,y_{1},\ldots,y_{n})
  </annotation>
 </semantics>
</math>

, then 

<math display="inline" id="Skolem_normal_form:85">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Φ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>y</mi>
       <mn>1</mn>
      </msub>
      <mo>,</mo>
      <mi mathvariant="normal">…</mi>
      <mo>,</mo>
      <msub>
       <mi>y</mi>
       <mi>n</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>,</mo>
    <msub>
     <mi>y</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>y</mi>
     <mi>n</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Φ</ci>
    <vector>
     <apply>
      <times></times>
      <ci>f</ci>
      <vector>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>normal-…</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <ci>n</ci>
       </apply>
      </vector>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <ci>n</ci>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Phi(f(y_{1},\ldots,y_{n}),y_{1},\ldots,y_{n})
  </annotation>
 </semantics>
</math>

 may be added to the same branch of the tableau. This addition does not alter the satisfiability of the tableau: every model of the old formula may be extended, by adding a suitable evaluation of 

<math display="inline" id="Skolem_normal_form:86">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

, to a model of the new formula.</p>

<p>This form of Skolemization is an improvement over "classical" Skolemization in that, only variables that are free in the formula are placed in the Skolem term. This is an improvement because the semantics of tableau may implicitly place the formula in the <a href="Scope_(programming)" title="wikilink">scope</a> of some universally quantified variables that are not in the formula itself; these variables are not in the Skolem term, while they would be there according to the original definition of Skolemization. Another improvement that may be used is applying the same Skolem function symbol for formulae that are identical <a href="up_to" title="wikilink">up to</a> variable renaming.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>

<p>Another use is in the <a href="Resolution_(logic)#Resolution_in_first_order_logic" title="wikilink">resolution method for first order logic</a>, where formulas are represented as sets of <a href="clause_(logic)" title="wikilink">clauses</a> understood to be universally quantified. (For an example see <a href="drinker_paradox" title="wikilink">drinker paradox</a>.)</p>
<h2 id="skolem-theories">Skolem theories</h2>

<p>In general, if 

<math display="inline" id="Skolem_normal_form:87">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

 is a <a href="theory_(mathematical_logic)" title="wikilink">theory</a> and for each formula 

<math display="inline" id="Skolem_normal_form:88">
 <semantics>
  <mi>F</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>F</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F
  </annotation>
 </semantics>
</math>

 with <a href="free_variable" title="wikilink">free variables</a> 

<math display="inline" id="Skolem_normal_form:89">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>x</mi>
    <mi>n</mi>
   </msub>
   <mo>,</mo>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>n</ci>
    </apply>
    <ci>y</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1},\dots,x_{n},y
  </annotation>
 </semantics>
</math>

 there is a Skolem function, then 

<math display="inline" id="Skolem_normal_form:90">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

 is called a <strong>Skolem theory</strong>.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> For example, by the above, <a class="uri" href="arithmetic" title="wikilink">arithmetic</a> with the Axiom of Choice is a Skolem theory.</p>

<p>Every Skolem theory is <a href="model_complete_theory" title="wikilink">model complete</a>, i.e. every <a class="uri" href="substructure" title="wikilink">substructure</a> of a model is an <a href="elementary_equivalence" title="wikilink">elementary substructure</a>. Given a model <em>M</em> of a Skolem theory <em>T</em>, the smallest substructure containing a certain set <em>A</em> is called the <strong>Skolem hull</strong> of <em>A</em>. The Skolem hull of <em>A</em> is an <a href="atomic_model_(mathematical_logic)" title="wikilink">atomic</a> <a href="prime_model" title="wikilink">prime model</a> over <em>A</em>.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a class="uri" href="Herbrandization" title="wikilink">Herbrandization</a>, the dual of Skolemization</li>
<li><a href="Predicate_functor_logic" title="wikilink">Predicate functor logic</a></li>
</ul>
<h2 id="notes">Notes</h2>
<references>
</references>
<h2 id="references">References</h2>
<ul>
<li></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li></li>
<li><a href="http://planetmath.org/encyclopedia/Skolemization.html">Skolemization on PlanetMath.org</a></li>
<li><a href="http://demonstrations.wolfram.com/Skolemization/">Skolemization</a> by Hector Zenil, <a href="The_Wolfram_Demonstrations_Project" title="wikilink">The Wolfram Demonstrations Project</a>.</li>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Normal_forms_(logic)" title="wikilink">Category:Normal forms (logic)</a> <a href="Category:Model_theory" title="wikilink">Category:Model theory</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2">R. Hähnle. Tableaux and related methods. <a href="Handbook_of_Automated_Reasoning" title="wikilink">Handbook of Automated Reasoning</a>.<a href="#fnref2">↩</a></li>
<li id="fn3"><a href="http://www.math.uu.nl/people/jvoosten/syllabi/logicasyllmoeder.pdf">1</a><a href="#fnref3">↩</a></li>
</ol>
</section>
</body>
</html>
