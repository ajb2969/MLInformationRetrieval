<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1149">Sobel operator</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Sobel operator</h1>
<hr/>

<p> </p>

<p>The <strong>Sobel operator</strong>, sometimes called Sobel Filter, is used in <a href="image_processing" title="wikilink">image processing</a> and <a href="computer_vision" title="wikilink">computer vision</a>, particularly within <a href="edge_detection" title="wikilink">edge detection</a> algorithms, and creates an image which emphasizes edges and transitions. It is named after <a href="Irwin_Sobel" title="wikilink">Irwin Sobel</a>, who presented the idea of an "Isotropic 3x3 Image Gradient Operator" at a talk at the Stanford Artificial Intelligence Laboratory (SAIL) in 1968. It should properly be called the Sobel-Feldman operator since it was co-developed with Gary Feldman, a colleague at SAIL. <a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> Technically, it is a <a href="Difference_operator" title="wikilink">discrete differentiation operator</a>, computing an approximation of the <a href="Image_gradient" title="wikilink">gradient</a> of the image intensity function. At each point in the image, the result of the Sobel operator is either the corresponding gradient vector or the <a href="norm_(mathematics)" title="wikilink">norm</a> of this vector. The Sobel operator is based on convolving the image with a small, separable, and integer valued filter in horizontal and vertical direction and is therefore relatively inexpensive in terms of computations. On the other hand, the gradient approximation that it produces is relatively crude, in particular for high frequency variations in the image.</p>
<h2 id="formulation">Formulation</h2>

<p>The operator uses two 3√ó3 kernels which are <a href="convolution" title="wikilink">convolved</a> with the original image to calculate approximations of the <a href="Image_Derivatives" title="wikilink">derivatives</a> - one for horizontal changes, and one for vertical. If we define <strong>A</strong> as the source image, and <strong>G</strong><sub><em>x</em></sub> and <strong>G</strong><sub><em>y</em></sub> are two images which at each point contain the horizontal and vertical derivative approximations, the computations are as follows:<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>

<p>

<math display="block" id="Sobel_operator:0">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>ùêÜ</mi>
     <mi>x</mi>
    </msub>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mrow>
       <mo>[</mo>
       <mtable displaystyle="true">
        <mtr>
         <mtd columnalign="center">
          <mrow>
           <mo>-</mo>
           <mn>1</mn>
          </mrow>
         </mtd>
         <mtd columnalign="center">
          <mn>0</mn>
         </mtd>
         <mtd columnalign="center">
          <mrow>
           <mo>+</mo>
           <mn>1</mn>
          </mrow>
         </mtd>
        </mtr>
        <mtr>
         <mtd columnalign="center">
          <mrow>
           <mo>-</mo>
           <mn>2</mn>
          </mrow>
         </mtd>
         <mtd columnalign="center">
          <mn>0</mn>
         </mtd>
         <mtd columnalign="center">
          <mrow>
           <mo>+</mo>
           <mn>2</mn>
          </mrow>
         </mtd>
        </mtr>
        <mtr>
         <mtd columnalign="center">
          <mrow>
           <mo>-</mo>
           <mn>1</mn>
          </mrow>
         </mtd>
         <mtd columnalign="center">
          <mn>0</mn>
         </mtd>
         <mtd columnalign="center">
          <mrow>
           <mo>+</mo>
           <mn>1</mn>
          </mrow>
         </mtd>
        </mtr>
       </mtable>
       <mo>]</mo>
      </mrow>
      <mo>*</mo>
      <mi>ùêÄ</mi>
     </mrow>
     <mtext>and</mtext>
    </mrow>
   </mrow>
   <mrow>
    <msub>
     <mi>ùêÜ</mi>
     <mi>y</mi>
    </msub>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mo>[</mo>
      <mtable displaystyle="true">
       <mtr>
        <mtd columnalign="center">
         <mrow>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
        </mtd>
        <mtd columnalign="center">
         <mrow>
          <mo>-</mo>
          <mn>2</mn>
         </mrow>
        </mtd>
        <mtd columnalign="center">
         <mrow>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
        </mtd>
       </mtr>
       <mtr>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
       </mtr>
       <mtr>
        <mtd columnalign="center">
         <mrow>
          <mo>+</mo>
          <mn>1</mn>
         </mrow>
        </mtd>
        <mtd columnalign="center">
         <mrow>
          <mo>+</mo>
          <mn>2</mn>
         </mrow>
        </mtd>
        <mtd columnalign="center">
         <mrow>
          <mo>+</mo>
          <mn>1</mn>
         </mrow>
        </mtd>
       </mtr>
      </mtable>
      <mo>]</mo>
     </mrow>
     <mo>*</mo>
     <mi>ùêÄ</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ùêÜ</ci>
      <ci>x</ci>
     </apply>
     <list>
      <apply>
       <times></times>
       <matrix>
        <matrixrow>
         <apply>
          <minus></minus>
          <cn type="integer">1</cn>
         </apply>
         <cn type="integer">0</cn>
         <apply>
          <plus></plus>
          <cn type="integer">1</cn>
         </apply>
        </matrixrow>
        <matrixrow>
         <apply>
          <minus></minus>
          <cn type="integer">2</cn>
         </apply>
         <cn type="integer">0</cn>
         <apply>
          <plus></plus>
          <cn type="integer">2</cn>
         </apply>
        </matrixrow>
        <matrixrow>
         <apply>
          <minus></minus>
          <cn type="integer">1</cn>
         </apply>
         <cn type="integer">0</cn>
         <apply>
          <plus></plus>
          <cn type="integer">1</cn>
         </apply>
        </matrixrow>
       </matrix>
       <ci>ùêÄ</ci>
      </apply>
      <mtext>and</mtext>
     </list>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ùêÜ</ci>
      <ci>y</ci>
     </apply>
     <apply>
      <times></times>
      <matrix>
       <matrixrow>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
        </apply>
        <apply>
         <minus></minus>
         <cn type="integer">2</cn>
        </apply>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
        </apply>
       </matrixrow>
       <matrixrow>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
       </matrixrow>
       <matrixrow>
        <apply>
         <plus></plus>
         <cn type="integer">1</cn>
        </apply>
        <apply>
         <plus></plus>
         <cn type="integer">2</cn>
        </apply>
        <apply>
         <plus></plus>
         <cn type="integer">1</cn>
        </apply>
       </matrixrow>
      </matrix>
      <ci>ùêÄ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{G}_{x}=\begin{bmatrix}-1&0&+1\\
-2&0&+2\\
-1&0&+1\end{bmatrix}*\mathbf{A}\quad\mbox{and}\quad\mathbf{G}_{y}=\begin{%
bmatrix}-1&-2&-1\\
0&0&0\\
+1&+2&+1\end{bmatrix}*\mathbf{A}
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Sobel_operator:1">
 <semantics>
  <mo>*</mo>
  <annotation-xml encoding="MathML-Content">
   <times></times>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   *
  </annotation>
 </semantics>
</math>

 here denotes the 2-dimensional <a class="uri" href="convolution" title="wikilink">convolution</a> operation.</p>

<p>Since the Sobel kernels can be decomposed as the products of an averaging and a differentiation kernel, they compute the gradient with smoothing. For example, 

<math display="inline" id="Sobel_operator:2">
 <semantics>
  <msub>
   <mi>ùêÜ</mi>
   <mi>ùê±</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ùêÜ</ci>
    <ci>ùê±</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{G_{x}}
  </annotation>
 </semantics>
</math>

 can be written as</p>

<p>

<math display="block" id="Sobel_operator:3">
 <semantics>
  <mrow>
   <mrow>
    <mo>[</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mrow>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <mo>-</mo>
        <mn>2</mn>
       </mrow>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mrow>
        <mo>+</mo>
        <mn>2</mn>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mrow>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
      </mtd>
     </mtr>
    </mtable>
    <mo>]</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo>[</mo>
     <mtable displaystyle="true">
      <mtr>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>2</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
      </mtr>
     </mtable>
     <mo>]</mo>
    </mrow>
    <mrow>
     <mo>[</mo>
     <mtable displaystyle="true">
      <mtr>
       <mtd columnalign="center">
        <mrow>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mrow>
         <mo>+</mo>
         <mn>1</mn>
        </mrow>
       </mtd>
      </mtr>
     </mtable>
     <mo>]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <matrix>
     <matrixrow>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
      <cn type="integer">0</cn>
      <apply>
       <plus></plus>
       <cn type="integer">1</cn>
      </apply>
     </matrixrow>
     <matrixrow>
      <apply>
       <minus></minus>
       <cn type="integer">2</cn>
      </apply>
      <cn type="integer">0</cn>
      <apply>
       <plus></plus>
       <cn type="integer">2</cn>
      </apply>
     </matrixrow>
     <matrixrow>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
      <cn type="integer">0</cn>
      <apply>
       <plus></plus>
       <cn type="integer">1</cn>
      </apply>
     </matrixrow>
    </matrix>
    <apply>
     <times></times>
     <matrix>
      <matrixrow>
       <cn type="integer">1</cn>
      </matrixrow>
      <matrixrow>
       <cn type="integer">2</cn>
      </matrixrow>
      <matrixrow>
       <cn type="integer">1</cn>
      </matrixrow>
     </matrix>
     <matrix>
      <matrixrow>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
       <cn type="integer">0</cn>
       <apply>
        <plus></plus>
        <cn type="integer">1</cn>
       </apply>
      </matrixrow>
     </matrix>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{bmatrix}-1&0&+1\\
-2&0&+2\\
-1&0&+1\end{bmatrix}=\begin{bmatrix}1\\
2\\
1\end{bmatrix}\begin{bmatrix}-1&0&+1\end{bmatrix}
  </annotation>
 </semantics>
</math>

</p>

<p>The <em>x</em>-coordinate is defined here as increasing in the "right"-direction, and the <em>y</em>-coordinate is defined as increasing in the "down"-direction. At each point in the image, the resulting gradient approximations can be combined to give the gradient magnitude, using:</p>

<p>

<math display="block" id="Sobel_operator:4">
 <semantics>
  <mrow>
   <mi>ùêÜ</mi>
   <mo>=</mo>
   <msqrt>
    <mrow>
     <mmultiscripts>
      <mi>ùêÜ</mi>
      <mi>x</mi>
      <none></none>
      <none></none>
      <mn>2</mn>
     </mmultiscripts>
     <mo>+</mo>
     <mmultiscripts>
      <mi>ùêÜ</mi>
      <mi>y</mi>
      <none></none>
      <none></none>
      <mn>2</mn>
     </mmultiscripts>
    </mrow>
   </msqrt>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>ùêÜ</ci>
    <apply>
     <root></root>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ùêÜ</ci>
        <ci>x</ci>
       </apply>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ùêÜ</ci>
        <ci>y</ci>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{G}=\sqrt{{\mathbf{G}_{x}}^{2}+{\mathbf{G}_{y}}^{2}}
  </annotation>
 </semantics>
</math>

</p>

<p>Using this information, we can also calculate the gradient's direction:</p>

<p>

<math display="block" id="Sobel_operator:5">
 <semantics>
  <mrow>
   <mi>ùöØ</mi>
   <mo>=</mo>
   <mrow>
    <mo>atan2</mo>
    <mrow>
     <mo>(</mo>
     <msub>
      <mi>ùêÜ</mi>
      <mi>y</mi>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>ùêÜ</mi>
      <mi>x</mi>
     </msub>
     <mo>)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>ùöØ</ci>
    <apply>
     <ci>atan2</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ùêÜ</ci>
      <ci>y</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ùêÜ</ci>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{\Theta}=\operatorname{atan2}\left({\mathbf{G}_{y},\mathbf{G}_{x}}\right)
  </annotation>
 </semantics>
</math>

 where, for example, <strong>Œò</strong> is 0 for a vertical edge which is lighter on the right side.</p>
<h2 id="more-formally">More formally</h2>

<p>Since the intensity function of a digital image is only known at discrete points, derivatives of this function cannot be defined unless we assume that there is an underlying continuous intensity function which has been sampled at the image points. With some additional assumptions, the derivative of the continuous intensity function can be computed as a function on the sampled intensity function, i.e. the digital image. It turns out that the derivatives at any particular point are functions of the intensity values at virtually all image points. However, approximations of these derivative functions can be defined at lesser or larger degrees of accuracy.</p>

<p>The Sobel operator represents a rather inaccurate approximation of the image gradient, but is still of sufficient quality to be of practical use in many applications. More precisely, it uses intensity values only in a 3√ó3 region around each image point to approximate the corresponding image gradient, and it uses only integer values for the coefficients which weight the image intensities to produce the gradient approximation.</p>
<h2 id="extension-to-other-dimensions">Extension to other dimensions</h2>

<p>The Sobel operator consists of two separable operations:<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>
<ul>
<li>Smoothing perpendicular to the derivative direction with a triangle filter 

<math display="block" id="Sobel_operator:6">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>h</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mn>1</mn>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mrow>
     <mrow>
      <mi>h</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mn>0</mn>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>=</mo>
     <mn>2</mn>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mrow>
      <mi>h</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mn>1</mn>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>=</mo>
     <mn>1</mn>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>h</ci>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">formulae-sequence</csymbol>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <ci>h</ci>
       <cn type="integer">0</cn>
      </apply>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <ci>h</ci>
       <cn type="integer">1</cn>
      </apply>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h(-1)=1,h(0)=2,h(1)=1
  </annotation>
 </semantics>
</math>

</li>
<li>Simple central difference in the derivative direction 

<math display="block" id="Sobel_operator:7">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msup>
      <mi>h</mi>
      <mo>‚Ä≤</mo>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mn>1</mn>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mrow>
     <mrow>
      <msup>
       <mi>h</mi>
       <mo>‚Ä≤</mo>
      </msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mn>0</mn>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>=</mo>
     <mn>0</mn>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mrow>
      <msup>
       <mi>h</mi>
       <mo>‚Ä≤</mo>
      </msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mn>1</mn>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>=</mo>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>h</ci>
       <ci>normal-‚Ä≤</ci>
      </apply>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">formulae-sequence</csymbol>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>h</ci>
        <ci>normal-‚Ä≤</ci>
       </apply>
       <cn type="integer">0</cn>
      </apply>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>h</ci>
        <ci>normal-‚Ä≤</ci>
       </apply>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h^{\prime}(-1)=1,h^{\prime}(0)=0,h^{\prime}(1)=-1
  </annotation>
 </semantics>
</math>

</li>
</ul>

<p>Sobel filters for <a href="Image_Derivatives" title="wikilink">image derivatives</a> in different dimensions with 

<math display="inline" id="Sobel_operator:8">
 <semantics>
  <mrow>
   <mrow>
    <mi>x</mi>
    <mo>,</mo>
    <mi>y</mi>
    <mo>,</mo>
    <mi>z</mi>
    <mo>,</mo>
    <mi>t</mi>
   </mrow>
   <mo>‚àà</mo>
   <mrow>
    <mo>{</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mrow>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
    <mo>,</mo>
    <mn>1</mn>
    <mo>}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <list>
     <ci>x</ci>
     <ci>y</ci>
     <ci>z</ci>
     <ci>t</ci>
    </list>
    <set>
     <cn type="integer">0</cn>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
     <cn type="integer">1</cn>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x,y,z,t\in\left\{0,-1,1\right\}
  </annotation>
 </semantics>
</math>

 :</p>

<p>1D

<math display="block" id="Sobel_operator:9">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msubsup>
      <mi>h</mi>
      <mi>x</mi>
      <mo>‚Ä≤</mo>
     </msubsup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msup>
      <mi>h</mi>
      <mo>‚Ä≤</mo>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>;</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>h</ci>
       <ci>x</ci>
      </apply>
      <ci>normal-‚Ä≤</ci>
     </apply>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>h</ci>
      <ci>normal-‚Ä≤</ci>
     </apply>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h_{x}^{\prime}(x)=h^{\prime}(x);
  </annotation>
 </semantics>
</math>

</p>

<p>2D

<math display="block" id="Sobel_operator:10">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mi>h</mi>
     <mi>x</mi>
     <mo>‚Ä≤</mo>
    </msubsup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>h</mi>
     <mo>‚Ä≤</mo>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>h</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>h</ci>
       <ci>x</ci>
      </apply>
      <ci>normal-‚Ä≤</ci>
     </apply>
     <interval closure="open">
      <ci>x</ci>
      <ci>y</ci>
     </interval>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>h</ci>
      <ci>normal-‚Ä≤</ci>
     </apply>
     <ci>x</ci>
     <ci>h</ci>
     <ci>y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h_{x}^{\prime}(x,y)=h^{\prime}(x)h(y)
  </annotation>
 </semantics>
</math>

</p>

<p>3D

<math display="block" id="Sobel_operator:11">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mi>h</mi>
     <mi>x</mi>
     <mo>‚Ä≤</mo>
    </msubsup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo>,</mo>
     <mi>z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>h</mi>
     <mo>‚Ä≤</mo>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>h</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>h</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>h</ci>
       <ci>x</ci>
      </apply>
      <ci>normal-‚Ä≤</ci>
     </apply>
     <vector>
      <ci>x</ci>
      <ci>y</ci>
      <ci>z</ci>
     </vector>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>h</ci>
      <ci>normal-‚Ä≤</ci>
     </apply>
     <ci>x</ci>
     <ci>h</ci>
     <ci>y</ci>
     <ci>h</ci>
     <ci>z</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h_{x}^{\prime}(x,y,z)=h^{\prime}(x)h(y)h(z)
  </annotation>
 </semantics>
</math>

</p>

<p>4D

<math display="block" id="Sobel_operator:12">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mi>h</mi>
     <mi>x</mi>
     <mo>‚Ä≤</mo>
    </msubsup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo>,</mo>
     <mi>z</mi>
     <mo>,</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>h</mi>
     <mo>‚Ä≤</mo>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>h</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>h</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>h</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>h</ci>
       <ci>x</ci>
      </apply>
      <ci>normal-‚Ä≤</ci>
     </apply>
     <vector>
      <ci>x</ci>
      <ci>y</ci>
      <ci>z</ci>
      <ci>t</ci>
     </vector>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>h</ci>
      <ci>normal-‚Ä≤</ci>
     </apply>
     <ci>x</ci>
     <ci>h</ci>
     <ci>y</ci>
     <ci>h</ci>
     <ci>z</ci>
     <ci>h</ci>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h_{x}^{\prime}(x,y,z,t)=h^{\prime}(x)h(y)h(z)h(t)
  </annotation>
 </semantics>
</math>

</p>

<p>Thus as an example the 3D Sobel kernel in z-direction:</p>

<p>

<math display="block" id="Sobel_operator:13">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msubsup>
      <mi>h</mi>
      <mi>z</mi>
      <mo>‚Ä≤</mo>
     </msubsup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mo>:</mo>
      <mo>,</mo>
      <mo>:</mo>
      <mo>,</mo>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo>[</mo>
     <mtable displaystyle="true">
      <mtr>
       <mtd columnalign="center">
        <mrow>
         <mo>+</mo>
         <mn>1</mn>
        </mrow>
       </mtd>
       <mtd columnalign="center">
        <mrow>
         <mo>+</mo>
         <mn>2</mn>
        </mrow>
       </mtd>
       <mtd columnalign="center">
        <mrow>
         <mo>+</mo>
         <mn>1</mn>
        </mrow>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mrow>
         <mo>+</mo>
         <mn>2</mn>
        </mrow>
       </mtd>
       <mtd columnalign="center">
        <mrow>
         <mo>+</mo>
         <mn>4</mn>
        </mrow>
       </mtd>
       <mtd columnalign="center">
        <mrow>
         <mo>+</mo>
         <mn>2</mn>
        </mrow>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mrow>
         <mo>+</mo>
         <mn>1</mn>
        </mrow>
       </mtd>
       <mtd columnalign="center">
        <mrow>
         <mo>+</mo>
         <mn>2</mn>
        </mrow>
       </mtd>
       <mtd columnalign="center">
        <mrow>
         <mo>+</mo>
         <mn>1</mn>
        </mrow>
       </mtd>
      </mtr>
     </mtable>
     <mo>]</mo>
    </mrow>
   </mrow>
   <mrow>
    <mrow>
     <mrow>
      <msubsup>
       <mi>h</mi>
       <mi>z</mi>
       <mo>‚Ä≤</mo>
      </msubsup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mo>:</mo>
       <mo>,</mo>
       <mo>:</mo>
       <mo>,</mo>
       <mn>0</mn>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>=</mo>
     <mrow>
      <mo>[</mo>
      <mtable displaystyle="true">
       <mtr>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
       </mtr>
       <mtr>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
       </mtr>
       <mtr>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
       </mtr>
      </mtable>
      <mo>]</mo>
     </mrow>
    </mrow>
    <mrow>
     <mrow>
      <msubsup>
       <mi>h</mi>
       <mi>z</mi>
       <mo>‚Ä≤</mo>
      </msubsup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mo>:</mo>
       <mo>,</mo>
       <mo>:</mo>
       <mo>,</mo>
       <mn>1</mn>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>=</mo>
     <mrow>
      <mo>[</mo>
      <mtable displaystyle="true">
       <mtr>
        <mtd columnalign="center">
         <mrow>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
        </mtd>
        <mtd columnalign="center">
         <mrow>
          <mo>-</mo>
          <mn>2</mn>
         </mrow>
        </mtd>
        <mtd columnalign="center">
         <mrow>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
        </mtd>
       </mtr>
       <mtr>
        <mtd columnalign="center">
         <mrow>
          <mo>-</mo>
          <mn>2</mn>
         </mrow>
        </mtd>
        <mtd columnalign="center">
         <mrow>
          <mo>-</mo>
          <mn>4</mn>
         </mrow>
        </mtd>
        <mtd columnalign="center">
         <mrow>
          <mo>-</mo>
          <mn>2</mn>
         </mrow>
        </mtd>
       </mtr>
       <mtr>
        <mtd columnalign="center">
         <mrow>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
        </mtd>
        <mtd columnalign="center">
         <mrow>
          <mo>-</mo>
          <mn>2</mn>
         </mrow>
        </mtd>
        <mtd columnalign="center">
         <mrow>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
        </mtd>
       </mtr>
      </mtable>
      <mo>]</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>h</ci>
        <ci>z</ci>
       </apply>
       <ci>normal-‚Ä≤</ci>
      </apply>
      <vector>
       <ci>normal-:</ci>
       <ci>normal-:</ci>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </vector>
     </apply>
     <matrix>
      <matrixrow>
       <apply>
        <plus></plus>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <plus></plus>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <plus></plus>
        <cn type="integer">1</cn>
       </apply>
      </matrixrow>
      <matrixrow>
       <apply>
        <plus></plus>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <plus></plus>
        <cn type="integer">4</cn>
       </apply>
       <apply>
        <plus></plus>
        <cn type="integer">2</cn>
       </apply>
      </matrixrow>
      <matrixrow>
       <apply>
        <plus></plus>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <plus></plus>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <plus></plus>
        <cn type="integer">1</cn>
       </apply>
      </matrixrow>
     </matrix>
    </apply>
    <apply>
     <csymbol cd="ambiguous">formulae-sequence</csymbol>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>h</ci>
         <ci>z</ci>
        </apply>
        <ci>normal-‚Ä≤</ci>
       </apply>
       <vector>
        <ci>normal-:</ci>
        <ci>normal-:</ci>
        <cn type="integer">0</cn>
       </vector>
      </apply>
      <matrix>
       <matrixrow>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
       </matrixrow>
       <matrixrow>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
       </matrixrow>
       <matrixrow>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
       </matrixrow>
      </matrix>
     </apply>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>h</ci>
         <ci>z</ci>
        </apply>
        <ci>normal-‚Ä≤</ci>
       </apply>
       <vector>
        <ci>normal-:</ci>
        <ci>normal-:</ci>
        <cn type="integer">1</cn>
       </vector>
      </apply>
      <matrix>
       <matrixrow>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
        </apply>
        <apply>
         <minus></minus>
         <cn type="integer">2</cn>
        </apply>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
        </apply>
       </matrixrow>
       <matrixrow>
        <apply>
         <minus></minus>
         <cn type="integer">2</cn>
        </apply>
        <apply>
         <minus></minus>
         <cn type="integer">4</cn>
        </apply>
        <apply>
         <minus></minus>
         <cn type="integer">2</cn>
        </apply>
       </matrixrow>
       <matrixrow>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
        </apply>
        <apply>
         <minus></minus>
         <cn type="integer">2</cn>
        </apply>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
        </apply>
       </matrixrow>
      </matrix>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h_{z}^{\prime}(:,:,-1)=\begin{bmatrix}+1&+2&+1\\
+2&+4&+2\\
+1&+2&+1\end{bmatrix}\quad h_{z}^{\prime}(:,:,0)=\begin{bmatrix}0&0&0\\
0&0&0\\
0&0&0\end{bmatrix}\quad h_{z}^{\prime}(:,:,1)=\begin{bmatrix}-1&-2&-1\\
-2&-4&-2\\
-1&-2&-1\end{bmatrix}
  </annotation>
 </semantics>
</math>

</p>
<h2 id="technical-details">Technical details</h2>

<p>As a consequence of its definition, the Sobel operator can be implemented by simple means in both hardware and software: only eight image points around a point are needed to compute the corresponding result and only integer arithmetic is needed to compute the gradient vector approximation. Furthermore, the two discrete filters described above are both separable:</p>

<p>

<math display="block" id="Sobel_operator:14">
 <semantics>
  <mrow>
   <mrow>
    <mo>[</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="center">
       <mn>1</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mn>2</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mrow>
        <mo>-</mo>
        <mn>2</mn>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mn>1</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </mtd>
     </mtr>
    </mtable>
    <mo>]</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo>[</mo>
     <mtable displaystyle="true">
      <mtr>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>2</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
      </mtr>
     </mtable>
     <mo>]</mo>
    </mrow>
    <mrow>
     <mo>[</mo>
     <mtable displaystyle="true">
      <mtr>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mrow>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
       </mtd>
      </mtr>
     </mtable>
     <mo>]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <mrow>
       <mo>[</mo>
       <mtable displaystyle="true">
        <mtr>
         <mtd columnalign="center">
          <mn>1</mn>
         </mtd>
        </mtr>
        <mtr>
         <mtd columnalign="center">
          <mn>1</mn>
         </mtd>
        </mtr>
       </mtable>
       <mo>]</mo>
      </mrow>
      <mo>*</mo>
      <mrow>
       <mo>[</mo>
       <mtable displaystyle="true">
        <mtr>
         <mtd columnalign="center">
          <mn>1</mn>
         </mtd>
        </mtr>
        <mtr>
         <mtd columnalign="center">
          <mn>1</mn>
         </mtd>
        </mtr>
       </mtable>
       <mo>]</mo>
      </mrow>
     </mrow>
     <mrow>
      <mo>[</mo>
      <mtable displaystyle="true">
       <mtr>
        <mtd columnalign="center">
         <mn>1</mn>
        </mtd>
        <mtd columnalign="center">
         <mrow>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
        </mtd>
       </mtr>
      </mtable>
      <mo>]</mo>
     </mrow>
    </mrow>
    <mo>*</mo>
    <mrow>
     <mo>[</mo>
     <mtable displaystyle="true">
      <mtr>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
      </mtr>
     </mtable>
     <mo>]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <matrix>
      <matrixrow>
       <cn type="integer">1</cn>
       <cn type="integer">0</cn>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </matrixrow>
      <matrixrow>
       <cn type="integer">2</cn>
       <cn type="integer">0</cn>
       <apply>
        <minus></minus>
        <cn type="integer">2</cn>
       </apply>
      </matrixrow>
      <matrixrow>
       <cn type="integer">1</cn>
       <cn type="integer">0</cn>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </matrixrow>
     </matrix>
     <apply>
      <times></times>
      <matrix>
       <matrixrow>
        <cn type="integer">1</cn>
       </matrixrow>
       <matrixrow>
        <cn type="integer">2</cn>
       </matrixrow>
       <matrixrow>
        <cn type="integer">1</cn>
       </matrixrow>
      </matrix>
      <matrix>
       <matrixrow>
        <cn type="integer">1</cn>
        <cn type="integer">0</cn>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
        </apply>
       </matrixrow>
      </matrix>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <times></times>
       <apply>
        <times></times>
        <matrix>
         <matrixrow>
          <cn type="integer">1</cn>
         </matrixrow>
         <matrixrow>
          <cn type="integer">1</cn>
         </matrixrow>
        </matrix>
        <matrix>
         <matrixrow>
          <cn type="integer">1</cn>
         </matrixrow>
         <matrixrow>
          <cn type="integer">1</cn>
         </matrixrow>
        </matrix>
       </apply>
       <matrix>
        <matrixrow>
         <cn type="integer">1</cn>
         <apply>
          <minus></minus>
          <cn type="integer">1</cn>
         </apply>
        </matrixrow>
       </matrix>
      </apply>
      <matrix>
       <matrixrow>
        <cn type="integer">1</cn>
        <cn type="integer">1</cn>
       </matrixrow>
      </matrix>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{bmatrix}1&0&-1\\
2&0&-2\\
1&0&-1\end{bmatrix}=\begin{bmatrix}1\\
2\\
1\end{bmatrix}\begin{bmatrix}1&0&-1\end{bmatrix}=\begin{bmatrix}1\\
1\end{bmatrix}*\begin{bmatrix}1\\
1\end{bmatrix}\begin{bmatrix}1&-1\end{bmatrix}*\begin{bmatrix}1&1\end{bmatrix}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Sobel_operator:15">
 <semantics>
  <mrow>
   <mrow>
    <mo>[</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="center">
       <mn>1</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>2</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>1</mn>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </mtd>
      <mtd columnalign="center">
       <mrow>
        <mo>-</mo>
        <mn>2</mn>
       </mrow>
      </mtd>
      <mtd columnalign="center">
       <mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </mtd>
     </mtr>
    </mtable>
    <mo>]</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo>[</mo>
     <mtable displaystyle="true">
      <mtr>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mrow>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
       </mtd>
      </mtr>
     </mtable>
     <mo>]</mo>
    </mrow>
    <mrow>
     <mo>[</mo>
     <mtable displaystyle="true">
      <mtr>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>2</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
      </mtr>
     </mtable>
     <mo>]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <mrow>
       <mo>[</mo>
       <mtable displaystyle="true">
        <mtr>
         <mtd columnalign="center">
          <mn>1</mn>
         </mtd>
        </mtr>
        <mtr>
         <mtd columnalign="center">
          <mn>1</mn>
         </mtd>
        </mtr>
       </mtable>
       <mo>]</mo>
      </mrow>
      <mo>*</mo>
      <mrow>
       <mo>[</mo>
       <mtable displaystyle="true">
        <mtr>
         <mtd columnalign="center">
          <mn>1</mn>
         </mtd>
        </mtr>
        <mtr>
         <mtd columnalign="center">
          <mrow>
           <mo>-</mo>
           <mn>1</mn>
          </mrow>
         </mtd>
        </mtr>
       </mtable>
       <mo>]</mo>
      </mrow>
     </mrow>
     <mrow>
      <mo>[</mo>
      <mtable displaystyle="true">
       <mtr>
        <mtd columnalign="center">
         <mn>1</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>1</mn>
        </mtd>
       </mtr>
      </mtable>
      <mo>]</mo>
     </mrow>
    </mrow>
    <mo>*</mo>
    <mrow>
     <mo>[</mo>
     <mtable displaystyle="true">
      <mtr>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
      </mtr>
     </mtable>
     <mo>]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <matrix>
      <matrixrow>
       <cn type="float">1</cn>
       <cn type="float">2</cn>
       <cn type="float">1</cn>
      </matrixrow>
      <matrixrow>
       <cn type="float">0</cn>
       <cn type="float">0</cn>
       <cn type="float">0</cn>
      </matrixrow>
      <matrixrow>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <minus></minus>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </matrixrow>
     </matrix>
     <apply>
      <times></times>
      <matrix>
       <matrixrow>
        <cn type="float">1</cn>
       </matrixrow>
       <matrixrow>
        <cn type="float">0</cn>
       </matrixrow>
       <matrixrow>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
        </apply>
       </matrixrow>
      </matrix>
      <matrix>
       <matrixrow>
        <cn type="integer">1</cn>
        <cn type="integer">2</cn>
        <cn type="integer">1</cn>
       </matrixrow>
      </matrix>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <times></times>
       <apply>
        <times></times>
        <matrix>
         <matrixrow>
          <cn type="integer">1</cn>
         </matrixrow>
         <matrixrow>
          <cn type="integer">1</cn>
         </matrixrow>
        </matrix>
        <matrix>
         <matrixrow>
          <cn type="float">1</cn>
         </matrixrow>
         <matrixrow>
          <apply>
           <minus></minus>
           <cn type="integer">1</cn>
          </apply>
         </matrixrow>
        </matrix>
       </apply>
       <matrix>
        <matrixrow>
         <cn type="integer">1</cn>
         <cn type="integer">1</cn>
        </matrixrow>
       </matrix>
      </apply>
      <matrix>
       <matrixrow>
        <cn type="integer">1</cn>
        <cn type="integer">1</cn>
       </matrixrow>
      </matrix>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{bmatrix}\ \ 1&\ \ 2&\ \ 1\\
\ \ 0&\ \ 0&\ \ 0\\
-1&-2&-1\end{bmatrix}=\begin{bmatrix}\ \ 1\\
\ \ 0\\
-1\end{bmatrix}\begin{bmatrix}1&2&1\end{bmatrix}=\begin{bmatrix}1\\
1\end{bmatrix}*\begin{bmatrix}\ \ 1\\
-1\end{bmatrix}\begin{bmatrix}1&1\end{bmatrix}*\begin{bmatrix}1&1\end{bmatrix}
  </annotation>
 </semantics>
</math>

</p>

<p>and the two derivatives <strong>G</strong><sub><em>x</em></sub> and <strong>G</strong><sub><em>y</em></sub> can therefore be computed as</p>

<p>

<math display="block" id="Sobel_operator:16">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>ùêÜ</mi>
     <mi>x</mi>
    </msub>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mrow>
       <mo>[</mo>
       <mtable displaystyle="true">
        <mtr>
         <mtd columnalign="center">
          <mn>1</mn>
         </mtd>
        </mtr>
        <mtr>
         <mtd columnalign="center">
          <mn>2</mn>
         </mtd>
        </mtr>
        <mtr>
         <mtd columnalign="center">
          <mn>1</mn>
         </mtd>
        </mtr>
       </mtable>
       <mo>]</mo>
      </mrow>
      <mo>*</mo>
      <mrow>
       <mo>(</mo>
       <mrow>
        <mrow>
         <mo>[</mo>
         <mtable displaystyle="true">
          <mtr>
           <mtd columnalign="center">
            <mn>1</mn>
           </mtd>
           <mtd columnalign="center">
            <mn>0</mn>
           </mtd>
           <mtd columnalign="center">
            <mrow>
             <mo>-</mo>
             <mn>1</mn>
            </mrow>
           </mtd>
          </mtr>
         </mtable>
         <mo>]</mo>
        </mrow>
        <mo>*</mo>
        <mi>ùêÄ</mi>
       </mrow>
       <mo>)</mo>
      </mrow>
     </mrow>
     <mtext>and</mtext>
    </mrow>
   </mrow>
   <mrow>
    <msub>
     <mi>ùêÜ</mi>
     <mi>y</mi>
    </msub>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mo>[</mo>
      <mtable displaystyle="true">
       <mtr>
        <mtd columnalign="center">
         <mn>1</mn>
        </mtd>
       </mtr>
       <mtr>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
       </mtr>
       <mtr>
        <mtd columnalign="center">
         <mrow>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
        </mtd>
       </mtr>
      </mtable>
      <mo>]</mo>
     </mrow>
     <mo>*</mo>
     <mrow>
      <mo>(</mo>
      <mrow>
       <mrow>
        <mo>[</mo>
        <mtable displaystyle="true">
         <mtr>
          <mtd columnalign="center">
           <mn>1</mn>
          </mtd>
          <mtd columnalign="center">
           <mn>2</mn>
          </mtd>
          <mtd columnalign="center">
           <mn>1</mn>
          </mtd>
         </mtr>
        </mtable>
        <mo>]</mo>
       </mrow>
       <mo>*</mo>
       <mi>ùêÄ</mi>
      </mrow>
      <mo>)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ùêÜ</ci>
      <ci>x</ci>
     </apply>
     <list>
      <apply>
       <times></times>
       <matrix>
        <matrixrow>
         <cn type="integer">1</cn>
        </matrixrow>
        <matrixrow>
         <cn type="integer">2</cn>
        </matrixrow>
        <matrixrow>
         <cn type="integer">1</cn>
        </matrixrow>
       </matrix>
       <apply>
        <times></times>
        <matrix>
         <matrixrow>
          <cn type="integer">1</cn>
          <cn type="integer">0</cn>
          <apply>
           <minus></minus>
           <cn type="integer">1</cn>
          </apply>
         </matrixrow>
        </matrix>
        <ci>ùêÄ</ci>
       </apply>
      </apply>
      <mtext>and</mtext>
     </list>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ùêÜ</ci>
      <ci>y</ci>
     </apply>
     <apply>
      <times></times>
      <matrix>
       <matrixrow>
        <cn type="float">1</cn>
       </matrixrow>
       <matrixrow>
        <cn type="float">0</cn>
       </matrixrow>
       <matrixrow>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
        </apply>
       </matrixrow>
      </matrix>
      <apply>
       <times></times>
       <matrix>
        <matrixrow>
         <cn type="integer">1</cn>
         <cn type="integer">2</cn>
         <cn type="integer">1</cn>
        </matrixrow>
       </matrix>
       <ci>ùêÄ</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{G}_{x}=\begin{bmatrix}1\\
2\\
1\end{bmatrix}*\left(\begin{bmatrix}1&0&-1\end{bmatrix}*\mathbf{A}\right)\quad%
\mbox{and}\quad\mathbf{G}_{y}=\begin{bmatrix}\ \ 1\\
\ \ 0\\
-1\end{bmatrix}*\left(\begin{bmatrix}1&2&1\end{bmatrix}*\mathbf{A}\right)
  </annotation>
 </semantics>
</math>

</p>

<p>In certain implementations, this separable computation may be advantageous since it implies fewer arithmetic computations for each image point.</p>

<p>Applying convolution K to pixel group P can be represented in pseudocode as:</p>

<p>N(x,y) = Sum of { K(i,j).P(x-i,y-j)}, for i,j running from -1 to 1. N(x,y) represents the new matrix resulted after applying the Convolution K to P. where P is pixel matrix.</p>
<h2 id="example">Example</h2>

<p>The result of the Sobel operator is a 2-dimensional map of the gradient at each point. It can be processed and viewed as though it is itself an image, with the areas of high gradient (the likely edges) visible as white lines. The following images illustrates this, by showing the computation of the Sobel operator on a simple image.</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;"><figure><b>(Figure)</b>
<figcaption>Grayscale test image of brick wall and bike rack</figcaption>
</figure></td>
<td style="text-align: left;"><figure><b>(Figure)</b>
<figcaption>Normalized gradient magnitude from Sobel operator</figcaption>
</figure></td>
</tr>
<tr class="even">
<td style="text-align: left;"><figure><b>(Figure)</b>
<figcaption>Normalized x-gradient from Sobel operator</figcaption>
</figure></td>
<td style="text-align: left;"><figure><b>(Figure)</b>
<figcaption>Normalized y-gradient from Sobel operator</figcaption>
</figure></td>
</tr>
</tbody>
</table>
<h2 id="alternative-operators">Alternative operators</h2>

<p>The Sobel operator, while reducing artifacts associated with a pure central differences operator, does not have perfect rotational symmetry. Scharr looked into optimizing this property.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a><a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> Filter kernels up to size 5 x 5 have been presented there, but the most frequently used one is:</p>

<p>

<math display="inline" id="Sobel_operator:17">
 <semantics>
  <mrow>
   <mrow>
    <mo>[</mo>
    <mtable>
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <mo>+</mo>
        <mn>3</mn>
       </mrow>
      </mtd>
      <mtd columnalign="center">
       <mrow>
        <mo>+</mo>
        <mn>10</mn>
       </mrow>
      </mtd>
      <mtd columnalign="center">
       <mrow>
        <mo>+</mo>
        <mn>3</mn>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <mo>-</mo>
        <mn>3</mn>
       </mrow>
      </mtd>
      <mtd columnalign="center">
       <mrow>
        <mo>-</mo>
        <mn>10</mn>
       </mrow>
      </mtd>
      <mtd columnalign="center">
       <mrow>
        <mo>-</mo>
        <mn>3</mn>
       </mrow>
      </mtd>
     </mtr>
    </mtable>
    <mo>]</mo>
   </mrow>
   <mrow>
    <mo>[</mo>
    <mtable>
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <mo>+</mo>
        <mn>3</mn>
       </mrow>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mrow>
        <mo>-</mo>
        <mn>3</mn>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <mo>+</mo>
        <mn>10</mn>
       </mrow>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mrow>
        <mo>-</mo>
        <mn>10</mn>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <mo>+</mo>
        <mn>3</mn>
       </mrow>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mrow>
        <mo>-</mo>
        <mn>3</mn>
       </mrow>
      </mtd>
     </mtr>
    </mtable>
    <mo>]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <matrix>
     <matrixrow>
      <apply>
       <plus></plus>
       <cn type="integer">3</cn>
      </apply>
      <apply>
       <plus></plus>
       <cn type="integer">10</cn>
      </apply>
      <apply>
       <plus></plus>
       <cn type="integer">3</cn>
      </apply>
     </matrixrow>
     <matrixrow>
      <cn type="integer">0</cn>
      <cn type="integer">0</cn>
      <cn type="integer">0</cn>
     </matrixrow>
     <matrixrow>
      <apply>
       <minus></minus>
       <cn type="integer">3</cn>
      </apply>
      <apply>
       <minus></minus>
       <cn type="integer">10</cn>
      </apply>
      <apply>
       <minus></minus>
       <cn type="integer">3</cn>
      </apply>
     </matrixrow>
    </matrix>
    <matrix>
     <matrixrow>
      <apply>
       <plus></plus>
       <cn type="integer">3</cn>
      </apply>
      <cn type="integer">0</cn>
      <apply>
       <minus></minus>
       <cn type="integer">3</cn>
      </apply>
     </matrixrow>
     <matrixrow>
      <apply>
       <plus></plus>
       <cn type="integer">10</cn>
      </apply>
      <cn type="integer">0</cn>
      <apply>
       <minus></minus>
       <cn type="integer">10</cn>
      </apply>
     </matrixrow>
     <matrixrow>
      <apply>
       <plus></plus>
       <cn type="integer">3</cn>
      </apply>
      <cn type="integer">0</cn>
      <apply>
       <minus></minus>
       <cn type="integer">3</cn>
      </apply>
     </matrixrow>
    </matrix>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{bmatrix}+3&+10&+3\\
0&0&0\\
-3&-10&-3\end{bmatrix}\ \ \ \ \ \ \ \ \ \begin{bmatrix}+3&0&-3\\
+10&0&-10\\
+3&0&-3\end{bmatrix}
  </annotation>
 </semantics>
</math>

</p>

<p>This factors similarly:</p>

<p>

<math display="inline" id="Sobel_operator:18">
 <semantics>
  <mrow>
   <mrow>
    <mo>[</mo>
    <mtable>
     <mtr>
      <mtd columnalign="center">
       <mn>3</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>10</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>3</mn>
      </mtd>
     </mtr>
    </mtable>
    <mo>]</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo>[</mo>
     <mtable>
      <mtr>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>3</mn>
       </mtd>
      </mtr>
     </mtable>
     <mo>]</mo>
    </mrow>
    <mo>*</mo>
    <mrow>
     <mo>[</mo>
     <mtable>
      <mtr>
       <mtd columnalign="center">
        <mn>3</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
      </mtr>
     </mtable>
     <mo>]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <matrix>
     <matrixrow>
      <cn type="integer">3</cn>
      <cn type="integer">10</cn>
      <cn type="integer">3</cn>
     </matrixrow>
    </matrix>
    <apply>
     <times></times>
     <matrix>
      <matrixrow>
       <cn type="integer">1</cn>
       <cn type="integer">3</cn>
      </matrixrow>
     </matrix>
     <matrix>
      <matrixrow>
       <cn type="integer">3</cn>
       <cn type="integer">1</cn>
      </matrixrow>
     </matrix>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{bmatrix}3&10&3\end{bmatrix}=\begin{bmatrix}1&3\end{bmatrix}*\begin{%
bmatrix}3&1\end{bmatrix}
  </annotation>
 </semantics>
</math>

</p>

<p><a href="Scharr_operator" title="wikilink">Scharr operators</a> result from an optimization minimizing weighted mean squared angular error in Fourier domain. This optimization is done under the condition that resulting filters are numerically consistent. Therefore they really are derivative kernels rather than merely keeping symmetry constraints.</p>

<p>A similar optimization strategy and resulting filters were also presented by Farid and Simoncelli.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a><a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> They also investigate higher-order derivative schemes. In contrast to the work of Scharr, these filters are not enforced to be numerically consistent.</p>

<p>The problem of derivative filter design has been revisited e.g. by Kroon.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></p>

<p>Derivative filters based on arbitrary cubic splines was presented by Hast. <a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a>He showed how first and second order derivatives can be computed correctly using cubic or trigonometric splines by a double filtering approach giving filters of length 7.</p>

<p>Orientation-optimal derivative kernels drastically reduce systematic estimation errors in optical flow estimation. Larger schemes with even higher accuracy and optimized filter families for extended optical flow estimation have been presented in subsequent work by Scharr.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> Second order derivative filter sets have been investigated for transparent motion estimation.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> It has been observed that the larger the resulting kernels are, the better they approximate Derivative of Gaussian filters.</p>
<h2 id="example-comparisons">Example comparisons</h2>

<p>Here, four different gradient operators are used to estimate the magnitude of the gradient of the test image.</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;"><figure><b>(Figure)</b>
<figcaption>Grayscale test image of brick wall and bike rack</figcaption>
</figure></td>
<td style="text-align: left;"><figure><b>(Figure)</b>
<figcaption>Gradient magnitude from Sobel operator</figcaption>
</figure></td>
<td style="text-align: left;"><figure><b>(Figure)</b>
<figcaption>Gradient magnitude from Scharr operator</figcaption>
</figure></td>
</tr>
<tr class="even">
<td style="text-align: left;"><figure><b>(Figure)</b>
<figcaption>Gradient magnitude from <a href="Roberts_Cross" title="wikilink">Roberts Cross</a> operator</figcaption>
</figure></td>
<td style="text-align: left;"><figure><b>(Figure)</b>
<figcaption>Gradient magnitude from <a href="Prewitt_operator" title="wikilink">Prewitt operator</a></figcaption>
</figure></td>
</tr>
</tbody>
</table>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Digital_image_processing" title="wikilink">Digital image processing</a></li>
<li><a href="Computer_vision" title="wikilink">Computer vision</a></li>
<li><a href="Edge_detection" title="wikilink">Edge detection</a></li>
<li><a href="Feature_detection_(computer_vision)" title="wikilink">Feature detection (computer vision)</a></li>
<li><a href="Feature_extraction" title="wikilink">Feature extraction</a></li>
<li><a href="Image_gradient" title="wikilink">Image gradient</a></li>
<li><a href="Roberts_cross" title="wikilink">Roberts cross</a></li>
<li><a href="Prewitt_operator" title="wikilink">Prewitt operator</a></li>
<li><a href="Laplace_operator" title="wikilink">Laplace operator</a></li>
</ul>
<h2 id="references">References</h2>
<references>
</references>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://docs.opencv.org/doc/tutorials/imgproc/imgtrans/sobel_derivatives/sobel_derivatives.html">Sobel edge detection in Opencv</a></li>
<li><a href="http://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.filters.sobel.html#scipy.ndimage.filters.sobel">Sobel Filter</a>, in the <a class="uri" href="SciPy" title="wikilink">SciPy</a> Python Library</li>
<li><a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/s/Sobel:Irwin.html">Bibliographic citations for Irwin Sobel</a> in <a class="uri" href="DBLP" title="wikilink">DBLP</a></li>
<li><a href="http://hlevkin.com/articles/SobelScharrGradients5x5.pdf">Sobel and Scharr 5x5 gradients</a></li>
<li><a href="http://www.mathworks.com/discovery/edge-detection.html">Sobel edge detection example using computer algorithms</a></li>
</ul>

<p>"</p>

<p><a href="Category:Feature_detection_(computer_vision)" title="wikilink">Category:Feature detection (computer vision)</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Irwin Sobel, 2014, <a href="http://www.researchgate.net/publication/239398674_An_Isotropic_3_3_Image_Gradient_Operator"><em>History and Definition of the Sobel Operator</em></a><a href="#fnref1">‚Ü©</a></li>
<li id="fn2"><a href="http://homepages.inf.ed.ac.uk/rbf/HIPR2/sobel.htm">Feature Detectors - Sobel Edge Detector</a><a href="#fnref2">‚Ü©</a></li>
<li id="fn3"><a href="#fnref3">‚Ü©</a></li>
<li id="fn4">Scharr, Hanno, 2000, Dissertation (in German), <a href="http://nbn-resolving.de/urn/resolver.pl?urn=urn:nbn:de:bsz:16-opus-9622"><em>Optimal Operators in Digital Image Processing</em></a>.<a href="#fnref4">‚Ü©</a></li>
<li id="fn5">B. J√§hne, H. Scharr, and S. K√∂rkel. Principles of filter design. In Handbook of Computer Vision and Applications. Academic Press, 1999.<a href="#fnref5">‚Ü©</a></li>
<li id="fn6">H. Farid and E. P. Simoncelli, <a href="http://www.cs.dartmouth.edu/~farid/downloads/publications/caip97.pdf"><em>Optimally Rotation-Equivariant Directional Derivative Kernels</em></a>, Int'l Conf Computer Analysis of Images and Patterns, pp. 207--214, Sep 1997.<a href="#fnref6">‚Ü©</a></li>
<li id="fn7">H. Farid and E. P. Simoncelli, <a href="http://www.cns.nyu.edu/pub/lcv/farid03-reprint.pdf"><em>Differentiation of discrete multi-dimensional signals</em></a>, IEEE Trans Image Processing, vol.13(4), pp. 496--508, Apr 2004.<a href="#fnref7">‚Ü©</a></li>
<li id="fn8">D. Kroon, 2009, Short Paper University Twente, <a href="http://www.k-zone.nl/Kroon_DerivativePaper.pdf"><em>Numerical Optimization of Kernel Based Image Derivatives</em></a>.<a href="#fnref8">‚Ü©</a></li>
<li id="fn9">A. Hast., <a href="http://www.sciencedirect.com/science/article/pii/S0167865514000282">"Simple filter design for first and second order derivatives by a double filtering approach"</a>, Pattern Recognition Letters, Vol. 42, no.1 June, pp. 65--71. 2014.<a href="#fnref9">‚Ü©</a></li>
<li id="fn10">Scharr, Hanno, <a href="http://www.springerlink.com/content/w527h8j3348w5075/">''Optimal Filters for Extended Optical Flow ''</a> In: J√§hne, B., Mester, R., Barth, E., Scharr, H. (eds.) IWCM 2004. LNCS, vol. 3417, pp. 14‚Äì29. Springer, Heidelberg (2007).<a href="#fnref10">‚Ü©</a></li>
<li id="fn11">Scharr, Hanno, <a href="http://www.eurasip.org/Proceedings/Eusipco/Eusipco2007/Papers/a2l-g03.pdf"><em>OPTIMAL SECOND ORDER DERIVATIVE FILTER FAMILIES FOR TRANSPARENT MOTION ESTIMATION</em></a> 15th European Signal Processing Conference (EUSIPCO 2007), Poznan, Poland, September 3‚Äì7, 2007.<a href="#fnref11">‚Ü©</a></li>
</ol>
</section>
</body>
</html>
