<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="488">Propositional proof system</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Propositional proof system</h1>
<hr/>

<p>In <a href="propositional_calculus" title="wikilink">propositional calculus</a> and <a href="proof_complexity" title="wikilink">proof complexity</a> a <strong>propositional proof system (pps)</strong>, also called a <strong>Cook–Reckhow propositional proof system</strong>, is system for proving <a href="classical_logic" title="wikilink">classical</a> <a href="propositional_logic" title="wikilink">propositional</a> tautologies.</p>
<h2 id="mathematical-definition">Mathematical definition</h2>

<p>Formally a pps is a <a class="uri" href="polynomial-time" title="wikilink">polynomial-time</a> function <em>P</em> whose <a href="range_(mathematics)" title="wikilink">range</a> is the set of all propositional tautologies (denoted TAUT).<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> If <em>A</em> is a formula, then any <em>x</em> such that <em>P</em>(<em>x</em>) = <em>A</em> is called a <em>P</em>-proof of <em>A</em>. The condition defining pps can be broken up as follows:</p>
<ul>
<li><a href="Completeness_(logic)" title="wikilink">Completeness</a>: every propositional <a href="tautology_(logic)" title="wikilink">tautology</a> has a <em>P</em>-proof,</li>
<li><a class="uri" href="Soundness" title="wikilink">Soundness</a>: if a propositional formula has a <em>P</em>-proof then it is a tautology,</li>
<li><a class="uri" href="Efficiency" title="wikilink">Efficiency</a>: <em>P</em> runs in <a href="polynomial_time" title="wikilink">polynomial time</a>.</li>
</ul>

<p>In general, a proof system for a language <em>L</em> is a polynomial-time function whose range is <em>L</em>. Thus, a propositional proof system is a proof system for TAUT.</p>

<p>Sometimes the following alternative definition is considered: a pps is given as a proof-verification algorithm <em>P</em>(<em>A</em>,<em>x</em>) with two inputs. If <em>P</em> accepts the pair (<em>A</em>,<em>x</em>) we say that <em>x</em> is a <em>P</em>-proof of <em>A</em>. <em>P</em> is required to run in polynomial time, and moreover, it must hold that <em>A</em> has a <em>P</em>-proof if and only if it is a tautology.</p>

<p>If <em>P</em><sub>1</sub> is a pps according to the first definition, then <em>P</em><sub>2</sub> defined by <em>P</em><sub>2</sub>(<em>A</em>,<em>x</em>) if and only if <em>P</em><sub>1</sub>(<em>x</em>) = <em>A</em> is a pps according to the second definition. Conversely, if <em>P</em><sub>2</sub> is a pps according to the second definition, then <em>P</em><sub>1</sub> defined by</p>

<p>

<math display="block" id="Propositional_proof_system:0">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>P</mi>
     <mn>1</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo stretchy="false">⟨</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mi>A</mi>
      <mo stretchy="false">⟩</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>{</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="left">
       <mi>A</mi>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mtext>if</mtext>
        <msub>
         <mi>P</mi>
         <mn>2</mn>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>A</mi>
         <mo>,</mo>
         <mi>x</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="left">
       <mo>⊤</mo>
      </mtd>
      <mtd columnalign="left">
       <mtext>otherwise</mtext>
      </mtd>
     </mtr>
    </mtable>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>P</ci>
      <cn type="integer">1</cn>
     </apply>
     <list>
      <ci>x</ci>
      <ci>A</ci>
     </list>
    </apply>
    <apply>
     <csymbol cd="latexml">cases</csymbol>
     <ci>A</ci>
     <apply>
      <times></times>
      <mtext>if</mtext>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>P</ci>
       <cn type="integer">2</cn>
      </apply>
      <interval closure="open">
       <ci>A</ci>
       <ci>x</ci>
      </interval>
     </apply>
     <csymbol cd="latexml">top</csymbol>
     <mtext>otherwise</mtext>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{1}(\langle x,A\rangle)=\begin{cases}A&\text{if }P_{2}(A,x)\\
\top&\text{otherwise}\end{cases}
  </annotation>
 </semantics>
</math>

 (<em>P</em><sub>1</sub> takes pairs as input) is a pps according to the first definition, where 

<math display="inline" id="Propositional_proof_system:1">
 <semantics>
  <mo>⊤</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">top</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \top
  </annotation>
 </semantics>
</math>

 is a fixed tautology.</p>
<h2 id="algorithmic-interpretation">Algorithmic interpretation</h2>

<p>One can view the second definition as a non-deterministic algorithm for solving membership in TAUT. This means that proving a superpolynomial proof size lower-bound for pps would rule out existence of a certain class of polynomial-time algorithms based on that pps.</p>

<p>As an example, exponential proof size lower-bounds in <a href="Resolution_(logic)" title="wikilink">resolution</a> for the <a href="pigeon_hole_principle" title="wikilink">pigeon hole principle</a> imply that any algorithm based on resolution cannot decide TAUT or SAT efficiently and will fail on <a href="pigeon_hole_principle" title="wikilink">pigeon hole principle</a> tautologies. This is significant because the class of algorithms based on resolution includes most of current propositional proof search algorithms and modern industrial SAT solvers.</p>
<h2 id="history">History</h2>

<p>Historically, <a href="Frege's_propositional_calculus" title="wikilink">Frege's propositional calculus</a> was the first propositional proof system. The general definition of a propositional proof system is due to <a href="Stephen_Cook" title="wikilink">Stephen Cook</a> and <a href="Robert_A._Reckhow" title="wikilink">Robert A. Reckhow</a> (1979).<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>
<h2 id="relation-with-computational-complexity-theory">Relation with computational complexity theory</h2>

<p>Propositional proof system can be compared using the notion of <a class="uri" href="p-simulation" title="wikilink">p-simulation</a>. A propositional proof system <em>P</em> <em>p-simulates</em> <em>Q</em> (written as <em>P</em> ≤<sub><em>p</em></sub><em>Q</em>) when there is a polynomial-time function <em>F</em> such that <em>P</em>(<em>F</em>(<em>x</em>)) = <em>Q</em>(<em>x</em>) for every <em>x</em>.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> That is, given a <em>Q</em>-proof <em>x</em>, we can find in polynomial time a <em>P</em>-proof of the same tautology. If <em>P</em> ≤<sub><em>p</em></sub><em>Q</em> and <em>Q</em> ≤<sub><em>p</em></sub><em>P</em>, the proof systems <em>P</em> and <em>Q</em> are <em>p-equivalent</em>. There is also a weaker notion of simulation: a pps <em>P</em> <em>simulates</em> or <em>weakly p-simulates</em> a pps <em>Q</em> if there is a polynomial <em>p</em> such that for every <em>Q</em>-proof <em>x</em> of a tautology <em>A</em>, there is a <em>P</em>-proof <em>y</em> of <em>A</em> such that the length of <em>y</em>, |<em>y</em>| is at most <em>p</em>(|<em>x</em>|). (Some authors use the words p-simulation and simulation interchangeably for either of these two concepts, usually the latter.)</p>

<p>A propositional proof system is called <em>p-optimal</em> if it <em>p</em>-simulates all other propositional proof systems, and it is <em>optimal</em> if it simulates all other pps. A propositional proof system <em>P</em> is <em>polynomially bounded</em> (also called super) if every tautology has a short (i.e., polynomial-size) <em>P</em>-proof.</p>

<p>If <em>P</em> is polynomially bounded and <em>Q</em> simulates <em>P</em>, then <em>Q</em> is also polynomially bounded.</p>

<p>The set of propositional tautologies, TAUT, is a <a class="uri" href="coNP" title="wikilink">coNP</a>-complete set. A propositional proof system is a certificate-verifier for membership in TAUT. Existence of a polynomially bounded propositional proof system means that there is a verifier with polynomial-size certificates, i.e., TAUT is in <a href="NP_(complexity)" title="wikilink">NP</a>. In fact these two statements are equivalent, i.e., there is a polynomially bounded propositional proof system if and only if the complexity classes NP and <a class="uri" href="coNP" title="wikilink">coNP</a> are equal.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>

<p>Some equivalence classes of proof systems under simulation or <em>p</em>-simulation are closely related to theories of <a href="bounded_arithmetic" title="wikilink">bounded arithmetic</a>; they are essentially "non-uniform" versions of the bounded arithmetic, in the same way that circuit classes are non-uniform versions of resource-based complexity classes. "Extended Frege" systems (allowing the introduction of new variables by definition) correspond in this way to polynomially-bounded systems, for example. Where the bounded arithmetic in turn corresponds to a circuit-based complexity class, there are often similarities between the theory of proof systems and the theory of the circuit families, such as matching lower bound results and separations. For example, just as counting cannot be done by an <a href="AC0" title="wikilink">

<math display="inline" id="Propositional_proof_system:2">
 <semantics>
  <mrow>
   <mi>𝔸</mi>
   <msup>
    <mi>ℂ</mi>
    <mn>0</mn>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>𝔸</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ℂ</ci>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{AC}^{0}
  </annotation>
 </semantics>
</math>

</a> circuit family of subexponential size, many tautologies relating to the <a href="pigeonhole_principle" title="wikilink">pigeonhole principle</a> cannot have subexponential proofs in a proof system based on bounded-depth formulas (and in particular, not by resolution-based systems, since they rely solely on depth 1 formulas).</p>
<h2 id="examples-of-propositional-proof-systems">Examples of propositional proof systems</h2>

<p> Some examples of propositional proof systems studied are:</p>
<ul>
<li>Propositional <a href="Resolution_(logic)" title="wikilink">Resolution</a> and various restrictions and extensions of it like <a href="DPLL_algorithm" title="wikilink">DPLL algorithm</a></li>
<li><a href="Natural_deduction" title="wikilink">Natural deduction</a></li>
<li><a href="Sequent_calculus" title="wikilink">Sequent calculus</a></li>
<li><a href="Frege_system" title="wikilink">Frege system</a></li>
<li><a href="Extended_Frege" title="wikilink">Extended Frege</a></li>
<li><a href="Polynomial_calculus" title="wikilink">Polynomial calculus</a></li>
<li><a href="Nullstellensatz_system" title="wikilink">Nullstellensatz system</a></li>
<li><a href="Cutting-plane_method" title="wikilink">Cutting-plane method</a></li>
</ul>
<h2 id="references">References</h2>
<h2 id="further-reading">Further reading</h2>
<ul>
<li>Samuel Buss (1998), "An introduction to proof theory", in: Handbook of Proof Theory (ed. S.R.Buss), Elsevier (1998).</li>
<li>P. Pudlák (1998), "The lengths of proofs", in: Handbook of Proof Theory (ed. S.R.Buss), Elsevier, (1998).</li>
<li>P. Beame and <a href="Toniann_Pitassi" title="wikilink">T. Pitassi</a> (1998). <a href="http://eccc.uni-trier.de/eccc-reports/1998/TR98-067/index.html">Propositional proof complexity: past, present and future</a>. Technical Report TR98-067, Electronic Colloquium on Computational Complexity.</li>
<li>Nathan Segerlind (2007) <a href="http://www.math.ucla.edu/~asl/bsl/1304/1304-001.ps">"The Complexity of Propositional Proofs"</a>, Bulletin of Symbolic Logic 13(4): 417–481</li>
<li>J. Krajíček (1995), <em>Bounded Arithmetic, Propositional Logic, and Complexity Theory</em>, Cambridge University Press.</li>
<li>J. Krajíček, <a href="http://www.karlin.mff.cuni.cz/~krajicek/ecm.pdf">Proof complexity</a>, in: Proc. 4th European congress of mathematics (ed. A. Laptev), EMS, Zurich, pp. 221–231, (2005).</li>
<li>J. Krajíček, <a href="http://www.karlin.mff.cuni.cz/~krajicek/ds1.ps">Propositional proof complexity I.</a> and <a href="http://www.karlin.mff.cuni.cz/~krajicek/ds2.ps">Proof complexity and arithmetic</a>.</li>
<li>Stephen Cook and Phuong Nguyen, <a href="http://www.cup.es/us/catalogue/catalogue.asp?isbn=9780521517294">Logical Foundations of Proof Complexity</a>, Cambridge University Press, 2010 (<a href="http://www.cs.toronto.edu/~sacook/homepage/book">draft from 2008</a>)</li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.cs.cmu.edu/afs/cs/project/jair/pub/volume21/dixon04a-html/node9.html">Proof Complexity</a></li>
</ul>

<p>"</p>

<p><a href="Category:Articles_created_via_the_Article_Wizard" title="wikilink">Category:Articles created via the Article Wizard</a> <a href="Category:Computational_complexity_theory" title="wikilink">Category:Computational complexity theory</a> <a href="Category:Logic_in_computer_science" title="wikilink">Category:Logic in computer science</a> <a href="Category:Automated_theorem_proving" title="wikilink">Category:Automated theorem proving</a> <a href="Category:Propositional_calculus" title="wikilink">Category:Propositional calculus</a> <a href="Category:Systems_of_formal_logic" title="wikilink">Category:Systems of formal logic</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"></li>
<li id="fn4"></li>
</ol>
</section>
</body>
</html>
