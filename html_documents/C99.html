<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1886">C99</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>C99</h1>
<style>
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
<style>
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
</body></html>
<body>
<hr/>
<figure><b>(Figure)</b>
<figcaption>Cover of the C99 standards document</figcaption>
</figure>

<p><strong>C99</strong> (previously known as C9X) is an informal name for <strong><em>ISO/IEC 9899:1999</em></strong>, a past version of the <a href="C_programming_language" title="wikilink">C programming language</a> standard.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> It extends the previous version (<a href="C89_(C_version)" title="wikilink">C90</a>) with new features for the language and the <a href="C_standard_library" title="wikilink">standard library</a>, and helps implementations make better use of available computer hardware, such as the <a href="IEEE_754-1985" title="wikilink">IEEE 754-1985</a> arithmetic, and compiler technology.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>

<p>The <a href="C11_(C_standard_revision)" title="wikilink">C11</a> version of the C programming language standard, published in 2011, replaces C99.</p>
<h2 id="history">History</h2>

<p>After <a class="uri" href="ANSI" title="wikilink">ANSI</a> produced the official standard for the C programming language in 1989, which became an international standard in 1990, the C language specification remained relatively static for some time, while <a class="uri" href="C++" title="wikilink">C++</a> continued to evolve, largely during its own standardization effort. Normative Amendment 1 created a new standard for C in 1995, but only to correct some details of the 1989 standard and to add more extensive support for international character sets. The standard underwent further revision in the late 1990s, leading to the publication of ISO/IEC 9899:1999 in 1999, which was adopted as an ANSI standard in May 2000. The language defined by that version of the standard is commonly referred to as "C99". The international C standard is maintained by the <a href="working_group" title="wikilink">working group</a> <a href="SC22" title="wikilink">ISO/IEC JTC1/SC22</a>/WG14.</p>
<h2 id="design">Design</h2>

<p>C99 is, for the most part, backward compatible with C89, but it is stricter in some ways.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>

<p>In particular, a declaration that lacks a type specifier no longer has <code>int</code> implicitly assumed. The C standards committee decided that it was of more value for compilers to diagnose inadvertent omission of the type specifier than to silently process legacy code that relied on implicit <code>int</code>. In practice, compilers are likely to display a warning, then assume <code>int</code> and continue translating the program.</p>

<p>C99 introduced several new features, many of which had already been implemented as extensions in several compilers:<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>
<ul>
<li><a href="inline_function" title="wikilink">inline functions</a></li>
<li>intermingled declarations and code: <a href="Variable_(programming)" title="wikilink">variable</a> declaration is no longer restricted to file scope or the start of a compound statement (block), facilitating <a href="static_single_assignment" title="wikilink">static single assignment</a> form</li>
<li>several new <a href="data_type" title="wikilink">data types</a>, including <code>long long int</code>, optional extended integer types, an explicit <a href="Boolean_datatype" title="wikilink">boolean data type</a>, and a <code>complex</code> type to represent <a href="complex_number" title="wikilink">complex numbers</a></li>
<li><a href="variable-length_array" title="wikilink">variable-length arrays</a> (although subsequently relegated in <a href="C11_(C_standard_revision)" title="wikilink">C11</a> to a conditional feature which implementations are not required to support)</li>
<li><a href="flexible_array_member" title="wikilink">flexible array members</a></li>
<li>support for one-line <a href="comment_(programming)" title="wikilink">comments</a> beginning with <code>//</code>, as in <a class="uri" href="BCPL" title="wikilink">BCPL</a> or <a class="uri" href="C++" title="wikilink">C++</a></li>
<li>new library functions, such as <code>snprintf</code></li>
<li>new <a href="header_file" title="wikilink">headers</a>, such as <code>, <code>, <code>, and <code></code></code></code></code></li>
<li>type-generic math (macro) functions, in <code><tgmath.h></tgmath.h></code>, which select a math library function based upon <code>float</code>, <code>double</code>, or <code>long double</code> arguments, etc.</li>
<li>improved support for <a href="IEEE_floating_point" title="wikilink">IEEE floating point</a></li>
<li>designated initializers</li>
<li>compound literals</li>
<li>support for <a href="variadic_macro" title="wikilink">variadic macros</a> (macros with a variable number of arguments)</li>
<li><code>[[restrict]]</code> qualification allows more aggressive code <a href="optimization_(computer_science)" title="wikilink">optimization</a>, removing compile-time array access advantages previously held by <a class="uri" href="FORTRAN" title="wikilink">FORTRAN</a> over ANSI C<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></li>
<li>universal character names, which allows user variables to contain other characters than the standard character set</li>
</ul>

<p>Parts of the C99 standard are included in the current version of the C++ standard, <a class="uri" href="C++11" title="wikilink">C++11</a>, including integer types, headers, and library functions. Variable-length arrays are not among these included parts because C++'s <a href="Standard_Template_Library" title="wikilink">Standard Template Library</a> already includes similar functionality.</p>
<h2 id="ieee754-floating-point-support">IEEE 754 floating point support</h2>

<p>A major feature of C99 is its numerics support, and in particular its support for access to the features of <a href="IEEE_754-1985" title="wikilink">IEEE 754-1985</a> (also known as IEC 60559) <a href="floating_point" title="wikilink">floating point</a> hardware present in the vast majority of modern processors (defined in "Annex F IEC 60559 floating-point arithmetic"). Platforms without IEEE 754 hardware can also implement it in software.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>

<p>On platforms with IEEE 754 floating point:</p>
<ul>
<li><code>float</code> is defined as IEEE 754 <a href="Single-precision_floating-point_format" title="wikilink">single precision</a>, <code>double</code> is defined as <a href="Double-precision_floating-point_format" title="wikilink">double precision</a>, and <code>[[long double]]</code> is defined as IEEE 754 <a href="extended_precision" title="wikilink">extended precision</a> (e.g., Intel 80-bit <a href="extended_precision" title="wikilink">double extended</a> precision on <a class="uri" href="x86" title="wikilink">x86</a> or <a class="uri" href="x86-64" title="wikilink">x86-64</a> platforms), or some form of <a href="Quadruple-precision_floating-point_format" title="wikilink">quad precision</a> where available; otherwise, it is double precision.</li>
<li>The four arithmetic operations and square root are correctly rounded as defined by IEEE 754.</li>
</ul>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>FLT_EVAL_METHOD</p></th>
<th style="text-align: left;">
<p>float</p></th>
<th style="text-align: left;">
<p>double</p></th>
<th style="text-align: left;">
<p>long double</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>float</p></td>
<td style="text-align: left;">
<p>double</p></td>
<td style="text-align: left;">
<p>long double</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>double</p></td>
<td style="text-align: left;">
<p>double</p></td>
<td style="text-align: left;">
<p>long double</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>2</p></td>
<td style="text-align: left;">
<p>long double</p></td>
<td style="text-align: left;">
<p>long double</p></td>
<td style="text-align: left;">
<p>long double</p></td>
</tr>
</tbody>
</table>
<ul>
<li>Expression evaluation is defined to be performed in one of three well-defined methods, indicating whether floating point variables are first promoted to a more precise format in expressions: FLT_EVAL_METHOD == 2 indicates that all internal intermediate computations are performed by default at high precision (long double) where available (e.g., <a href="extended_precision" title="wikilink">80 bit double extended</a>), FLT_EVAL_METHOD == 1 performs all internal intermediate expressions in double precision (unless an operand is long double), while FLT_EVAL_METHOD == 0 specifies each operation is evaluated only at the precision of the widest operand of each operator. The intermediate result type for operands of a given precision are summarized in the table on the right.</li>
</ul>

<p>FLT_EVAL_METHOD == 2 tends to limit the risk of <a href="Round-off_error" title="wikilink">rounding errors</a> affecting numerically unstable expressions (see <a href="floating_point#IEEE_754_design_rationale" title="wikilink">IEEE 754 design rationale</a>) and is the designed default method for <a class="uri" href="x87" title="wikilink">x87</a> hardware, but yields unintuitive behavior for the unwary user;<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> FLT_EVAL_METHOD == 1 was the default evaluation method originally used in <a href="K&amp;R;_C" title="wikilink">K&amp;R; C</a>, which promoted all floats to double in expressions; and FLT_EVAL_METHOD == 0 is also commonly used and specifies a strict "evaluate to type" of the operands. (For <a href="GNU_Compiler_Collection" title="wikilink">gcc</a>, FLT_EVAL_METHOD == 2 is the default on 32 bit x86, and FLT_EVAL_METHOD == 0 is the default on 64 bit x86-64, but FLT_EVAL_METHOD == 2 can be specified on x86-64 with option -mfpmath=387). Note that prior to the precision of intermediate values being precisely specified in C99, C compilers could round intermediate results inconsistently, especially when using <a class="uri" href="x87" title="wikilink">x87</a> floating point hardware, leading to compiler-specific behaviour;<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> such inconsistencies are not permitted in compilers conforming to C99 (annex F).</p>
<h3 id="example">Example</h3>

<p>The following annotated example C99 code for computing a continued fraction function demonstrates the main features:</p>
<div class="sourceCode"><table class="sourceCode C numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
</pre></td><td class="sourceCode"><pre><code class="sourceCode c"><span class="ot">#include <stdio.h></stdio.h></span>
<span class="ot">#include <math.h></math.h></span>
<span class="ot">#include <float.h></float.h></span>
<span class="ot">#include <fenv.h></fenv.h></span>
<span class="ot">#include <tgmath.h></tgmath.h></span>
<span class="ot">#include <stdbool.h></stdbool.h></span>
<span class="ot">#include <assert.h></assert.h></span>

<span class="dt">double</span> compute_fn(<span class="dt">double</span> z)  <span class="co">// [1]</span>
{
        <span class="ot">#pragma STDC FENV_ACCESS ON  </span><span class="co">// [2]</span>

        assert(FLT_EVAL_METHOD == <span class="dv">2</span>);  <span class="co">// [3]</span>

        <span class="kw">if</span> (isnan(z))  <span class="co">// [4]</span>
                puts(<span class="st">"z is not a number"</span>);

        <span class="kw">if</span> (isinf(z))
                puts(<span class="st">"z is infinite"</span>);

        <span class="dt">long</span> <span class="dt">double</span> r = <span class="fl">7.0</span> - <span class="fl">3.0</span>/(z - <span class="fl">2.0</span> - <span class="fl">1.0</span>/(z - <span class="fl">7.0</span> + <span class="fl">10.0</span>/(z - <span class="fl">2.0</span> - <span class="fl">2.0</span>/(z - <span class="fl">3.0</span>)))); <span class="co">// [5, 6]</span>

        feclearexcept(FE_DIVBYZERO);  <span class="co">// [7]</span>

        bool raised = fetestexcept(FE_OVERFLOW);  <span class="co">// [8]</span>

        <span class="kw">if</span> (raised)
                puts(<span class="st">"Unanticipated overflow."</span>);

        <span class="kw">return</span> r;
}

<span class="dt">int</span> main(<span class="dt">void</span>)
{
<span class="ot">#ifndef __STDC_IEC_559__</span>
        puts(<span class="st">"Warning: __STDC_IEC_559__ not defined. IEEE 754 floating point not fully supported."</span>); <span class="co">// [9]</span>
<span class="ot">#endif</span>

       <span class="ot">#pragma STDC FENV_ACCESS ON</span>

        <span class="ot">#ifdef TEST_NUMERIC_STABILITY_UP</span>
        fesetround(FE_UPWARD);                   <span class="co">// [10]</span>
        <span class="ot">#elif TEST_NUMERIC_STABILITY_DOWN</span>
        fesetround(FE_DOWNWARD); 
        <span class="ot">#endif</span>

        printf(<span class="st">"%.7g</span><span class="ch">\n</span><span class="st">"</span>, compute_fn(<span class="fl">3.0</span>));
        printf(<span class="st">"%.7g</span><span class="ch">\n</span><span class="st">"</span>, compute_fn(NAN));

        <span class="kw">return</span> <span class="dv">0</span>;
}
</code></pre></td></tr></table></div></body><!--<span class="dt"-->float.h&gt;

<p>Footnotes:</p>
<ol>
<li>Compile with: </li>
<li>As the IEEE 754 status flags are manipulated in this function, this #pragma is needed to avoid the compiler incorrectly rearranging such tests when optimising.</li>
<li>C99 defines a limited number of expression evaluation methods: the current compilation mode can be checked to ensure it meets the assumptions the code was written under.</li>
<li>The special values such as <a class="uri" href="NaN" title="wikilink">NaN</a> and positive or negative infinity can be tested and set.</li>
<li><code>long double</code> is defined as IEEE 754 double extended or quad precision if available. Using higher precision than required for intermediate computations can minimize <a href="round-off_error" title="wikilink">round-off error</a><a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> (the typedef double_t can be used for code that is portable under all FLT_EVAL_METHODs).</li>
<li>The main function to be evaluated. Although it appears that some arguments to this continued fraction, e.g., 3.0, would lead to a divide-by-zero error, in fact the function is well-defined at 3.0 and division by 0 will simply return a +infinity that will then correctly lead to a finite result: IEEE 754 is defined not to trap on such exceptions by default and is designed so that they can very often be ignored, as in this case. (Note that if FLT_EVAL_METHOD is defined as 2 then all internal computations including constants will be performed in long double precision; if FLT_EVAL_METHOD is defined as 0 then additional care is need to ensure this, including possibly additional casts and explicit specification of constants as long double).</li>
<li>As the raised divide-by-zero flag is not an error in this case, it can simply be dismissed to clear the flag for use by later code.</li>
<li>In some cases, other exceptions may be regarded as an error, such as overflow (although it can in fact be shown that this cannot occur in this case).</li>
<li>__STDC_IEC_559__ is to be defined only if "Annex F IEC 60559 floating-point arithmetic" is fully implemented by the compiler and the C library (users should be aware that this macro is sometimes defined while it shouldn't be).</li>
<li>The default rounding mode is round to nearest (with the even rounding rule in the halfway cases) for IEEE 754, but explicitly setting the rounding mode toward + and - infinity (by defining TEST_NUMERIC_STABILITY_UP etc. in this example, when debugging) can be used to diagnose numerical instability.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> Note that this method can be used even if compute_fn() is part of a separately compiled binary library. But depending on the function, numerical instabilities cannot always be detected.</li>
</ol>
<h2 id="version-detection">Version detection</h2>

<p>A standard macro <code>__STDC_VERSION__</code> is defined with value <code>199901L</code> to indicate that C99 support is available. As with the <code>__STDC__</code> macro for C90, <code>__STDC_VERSION__</code> can be used to write code that will compile differently for C90 and C99 compilers, as in this example that ensures that <code>inline</code> is available in either case (by replacing it with <code>static</code> in C90 to avoid linker errors.)</p>
<div class="sourceCode"><pre class="sourceCode C"><code class="sourceCode c"><span class="ot">#if __STDC_VERSION__ &gt;= 199901L</span>
  <span class="co">/* "inline" is a keyword */</span>
<span class="ot">#else</span>
<span class="ot"># define inline static</span>
<span class="ot">#endif</span></code></pre></div>
<h2 id="implementations">Implementations</h2>

<p>Most C compilers provide support for at least some of the features introduced in C99. However, there has been less support from <a class="uri" href="Microsoft" title="wikilink">Microsoft</a>, which used to focus mainly on C++ and only started to implement C99 features in their 2013 offering.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a></p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>Implementation</p></th>
<th style="text-align: left;">
<p>Level of support</p></th>
<th style="text-align: left;">
<p>Details</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>AMD x86 <a href="Open64" title="wikilink"> Open64 Compiler Suite</a></p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>Has C99 support equal to that of GCC.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><a class="uri" href="cc65" title="wikilink">cc65</a></p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>Full <a href="C89_(C_version)" title="wikilink">C89</a> and C99 support is not implemented, partly due to platform limitations (<a href="MOS_Technology_6502" title="wikilink">MOS Technology 6502</a>). There is no support planned for some C99 types like _Complex and 64-bit integers (long long).<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><a href="Ch_(computer_programming)" title="wikilink">Ch</a></p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>Supports major C99 features.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><a class="uri" href="Clang" title="wikilink">Clang</a></p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>Supports all features except C99 floating-point pragmas.<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><a class="uri" href="CompCert" title="wikilink">CompCert</a></p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>A certified compiler, formally proved correct. Supports all features except C99 complex numbers, and minor restrictions on switch statement (no Duff's device) and bitfields.<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>cparser</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>Supports C99 features.<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><a href="C++_Builder" title="wikilink">C++ Builder</a></p></td>
<td style="text-align: left;">

<p><br/>
</p></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><a href="Digital_Mars" title="wikilink">Digital Mars C/C++ Compiler</a></p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>Lacks support for some features, such as <a class="uri" href="tgmath.h" title="wikilink">tgmath.h</a> and _Pragma.<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><a href="GNU_Compiler_Collection" title="wikilink">GCC</a></p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">

<p>in mainline GCC, extended identifiers, standard pragmas and IEEE 754/IEC 60559 floating point support are missing. Additionally, some features (such as extended integer types and new library functions) must be provided by the C standard library and are thus out of scope for GCC.<a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a> GCC's 4.6 and 4.7 releases also provides the same level of compliance.<a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a><a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a> Almost complete IEEE 754 support if the hardware is compliant.<a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><a href="Green_Hills_Software" title="wikilink">Green Hills Software</a></p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>IBM C for AIX, V6 <a class="footnoteRef" href="#fn23" id="fnref23"><sup>23</sup></a> and <a href="IBM_XL_C++" title="wikilink">XL C/C++</a> V11.1 for AIX <a class="footnoteRef" href="#fn24" id="fnref24"><sup>24</sup></a></p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><a href="IBM_Rational" title="wikilink">IBM Rational</a> logiscope</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>Until Logiscope 6.3, only basic constructs of C99 were supported. C99 is officially supported in Logiscope 6.4 and later versions.<a class="footnoteRef" href="#fn25" id="fnref25"><sup>25</sup></a></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><a href="The_Portland_Group" title="wikilink">The Portland Group</a> PGI C/C++</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><a href="IAR_Systems" title="wikilink">IAR Systems</a><br/>
 Embedded Workbench</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>Doesn't support UCN (universal character names). Compiler for embedded targets, such as ARM, Coldfire, MSP430, AVR, AVR32, 8051, ... No x86 targets.</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><a href="Intel_C++_compiler" title="wikilink">Intel C++ compiler</a></p></td>
<td style="text-align: left;">

<p><br/>
</p></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><a href="Microsoft_Visual_C++" title="wikilink">Microsoft Visual C++</a></p></td>
<td style="text-align: left;">

<p><a class="footnoteRef" href="#fn26" id="fnref26"><sup>26</sup></a></p></td>
<td style="text-align: left;">
<p>C99 is not supported as of Visual C++ 2012,<a class="footnoteRef" href="#fn27" id="fnref27"><sup>27</sup></a><a class="footnoteRef" href="#fn28" id="fnref28"><sup>28</sup></a><a class="footnoteRef" href="#fn29" id="fnref29"><sup>29</sup></a> while Visual C++ 2013 implements support for a limited subset of C99.<a class="footnoteRef" href="#fn30" id="fnref30"><sup>30</sup></a></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><a href="Open_Watcom" title="wikilink">Open Watcom</a></p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>Implements the most-used parts of the standard. However, they are enabled only through an undocumented command-line switch.<a class="footnoteRef" href="#fn31" id="fnref31"><sup>31</sup></a></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><a href="Pelles_C" title="wikilink">Pelles C</a></p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>Supports all C99 features.<a class="footnoteRef" href="#fn32" id="fnref32"><sup>32</sup></a></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><a href="Portable_C_compiler" title="wikilink">Portable C compiler</a></p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>Working towards becoming C99-compliant.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><a href="Sun_Studio_(software)" title="wikilink">Sun Studio</a></p></td>
<td style="text-align: left;">

<p><a class="footnoteRef" href="#fn33" id="fnref33"><sup>33</sup></a></p></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>The <a href="Amsterdam_Compiler_Kit" title="wikilink">Amsterdam Compiler Kit</a></p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>A C99 frontend is currently under investigation.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><a href="Tiny_C_Compiler" title="wikilink">Tiny C Compiler</a></p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>Does not support complex numbers.<a class="footnoteRef" href="#fn34" id="fnref34"><sup>34</sup></a><a class="footnoteRef" href="#fn35" id="fnref35"><sup>35</sup></a> The developers state that "TCC is heading toward full ISOC99 compliance".<a class="footnoteRef" href="#fn36" id="fnref36"><sup>36</sup></a></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><a class="uri" href="vbcc" title="wikilink">vbcc</a></p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
<h2 id="future-work">Future work</h2>

<p>Since ratification of the 1999 C standard, the standards working group prepared technical reports specifying improved support for embedded processing, additional character data types (<a class="uri" href="Unicode" title="wikilink">Unicode</a> support), and library functions with improved <a href="bounds_checking" title="wikilink">bounds checking</a>. Work continues on technical reports addressing decimal <a href="floating_point" title="wikilink">floating point</a>, additional mathematical <a href="special_functions" title="wikilink">special functions</a>, and additional <a href="dynamic_memory_allocation" title="wikilink">dynamic memory allocation</a> functions. The C and C++ standards committees have been collaborating on specifications for <a href="Thread_(computer_programming)" title="wikilink">threaded</a> programming.</p>

<p>The next revision of the C standard, <a href="C11_(C_standard_revision)" title="wikilink">C11</a>, was ratified in 2011.<a class="footnoteRef" href="#fn37" id="fnref37"><sup>37</sup></a> The C standards committee adopted guidelines that limited the adoption of new features that have not been tested by existing implementations. Much effort went into developing a <a href="memory_model_(programming)" title="wikilink">memory model</a>, in order to clarify <a href="sequence_point" title="wikilink">sequence points</a> and to support <a href="Thread_(computer_programming)" title="wikilink">threaded</a> programming.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="C11_(C_standard_revision)" title="wikilink">C11</a></li>
<li><a class="uri" href="C++11" title="wikilink">C++11</a></li>
<li><a href="C++_Technical_Report_1" title="wikilink">C++ Technical Report 1</a></li>
<li><a href="Floating_point" title="wikilink">Floating point</a>, for further discussion of usage of IEEE 754 hardware</li>
</ul>
<h2 id="references">References</h2>
<h2 id="further-reading">Further reading</h2>
<ul>
<li></li>
<li></li>
<li></li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg14/www/C99RationaleV5.10.pdf">Rationale for International Standard—Programming Languages—C Revision 5.10</a>, April-2003, Rationale for C99</li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.open-std.org/jtc1/sc22/wg14/www/newinc9x.htm">New things in C9X</a></li>
<li><a href="http://www.kuro5hin.org/story/2001/2/23/194544/139">Kuro5hin: Are you ready for C99?</a></li>
<li><a href="http://www.cplusplus.com/articles/iz3hAqkS/">Features of C99</a></li>
</ul>

<p><a href="bg:C_(език_за_програмиране)#C99" title="wikilink">bg:C (език за програмиране)#C99</a>"</p>

<p><a href="Category:C_(programming_language)" title="wikilink">Category:C (programming language)</a> <a href="Category:Programming_language_standards" title="wikilink">Category:Programming language standards</a> <a href="Category:Unix_programming_tools" title="wikilink">Category:Unix programming tools</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a class="uri" href="http://grouper.ieee.org/groups/754/meeting-materials/2001-07-18-c99.pdf">http://grouper.ieee.org/groups/754/meeting-materials/2001-07-18-c99.pdf</a><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
<li id="fn10"><a href="#fnref10">↩</a></li>
<li id="fn11"><a href="#fnref11">↩</a></li>
<li id="fn12"><a href="#fnref12">↩</a></li>
<li id="fn13"><a href="#fnref13">↩</a></li>
<li id="fn14"><a href="#fnref14">↩</a></li>
<li id="fn15"><a href="#fnref15">↩</a></li>
<li id="fn16"><a href="#fnref16">↩</a></li>
<li id="fn17"><a href="#fnref17">↩</a></li>
<li id="fn18"><a href="#fnref18">↩</a></li>
<li id="fn19"><a href="#fnref19">↩</a></li>
<li id="fn20"><a href="#fnref20">↩</a></li>
<li id="fn21"><a href="#fnref21">↩</a></li>
<li id="fn22"><a href="#fnref22">↩</a></li>
<li id="fn23">[<a class="uri" href="http://www-01.ibm.com/common/ssi/cgi-bin/ssialias?infotype=an&amp;subtype">http://www-01.ibm.com/common/ssi/cgi-bin/ssialias?infotype=an&amp;subtype;</a>;=ca&amp;supplier;=897&amp;appname;=IBMLinkRedirect&amp;letternum;=ENUS202-161 IBM C for AIX, V6.0 Now Supports the C99 Standard]<a href="#fnref23">↩</a></li>
<li id="fn24"><a href="http://www-01.ibm.com/software/awdtools/xlcpp/aix/features/">IBM - XL C/C++ for AIX - United States</a><a href="#fnref24">↩</a></li>
<li id="fn25"><a href="http://www-01.ibm.com/support/docview.wss?uid=swg21408170">IBM Rational Logiscope support for C99 standard - United States</a><a href="#fnref25">↩</a></li>
<li id="fn26"><a href="#fnref26">↩</a></li>
<li id="fn27"><a href="http://herbsutter.com/2012/05/03/reader-qa-what-about-vc-and-c99/">Reader Q&amp;A;: What about VC++ and C99? « Sutter’s Mill</a><a href="#fnref27">↩</a></li>
<li id="fn28"><a href="http://msdn.microsoft.com/en-us/library/zb1574zs%28v=VS.100%29.aspx">A.27 Use of C99 Variable Length Arrays</a><a href="#fnref28">↩</a></li>
<li id="fn29"><a href="http://www.infoq.com/news/2012/05/vs_c99_support">Microsoft to C99 Developers: Use ISO C</a><a href="#fnref29">↩</a></li>
<li id="fn30"><a href="#fnref30">↩</a></li>
<li id="fn31"><a href="#fnref31">↩</a></li>
<li id="fn32"><a href="#fnref32">↩</a></li>
<li id="fn33"><a href="#fnref33">↩</a></li>
<li id="fn34"><a href="http://bellard.org/tcc/tcc-doc.html#SEC7">Tiny C Compiler Reference Documentation</a><a href="#fnref34">↩</a></li>
<li id="fn35">According to the project's <a href="http://repo.or.cz/w/tinycc.git/blob/HEAD:/TODO">TODO list</a> complex types are the only missing C99 feature. Variable Length Arrays have been added in TCC 0.9.26 <a href="http://bellard.org/tcc/">1</a><a href="#fnref35">↩</a></li>
<li id="fn36"><a href="http://bellard.org/tcc/">TCC : Tiny C Compiler</a><a href="#fnref36">↩</a></li>
<li id="fn37"><a href="#fnref37">↩</a></li>
</ol>
</section>


