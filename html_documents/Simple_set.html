<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="700">Simple set</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Simple set</h1>
<hr/>

<p>In <a href="recursion_theory" title="wikilink">recursion theory</a> a subset of the natural numbers is called a <strong>simple set</strong> if it is co-infinite and <a href="recursively_enumerable" title="wikilink">recursively enumerable</a>, but every infinite subset of its complement fails to be enumerated recursively. Simple sets are examples of recursively enumerable sets that are not <a href="computable_set" title="wikilink">recursive</a>.</p>
<h2 id="relation-to-posts-problem">Relation to Post's problem</h2>

<p>Simple sets were devised by <a href="Emil_Leon_Post" title="wikilink">Emil Leon Post</a> in the search for a non-Turing-complete recursively enumerable set. Whether such sets exist is known as <a href="Post's_problem" title="wikilink">Post's problem</a>. Post had to prove two things in order to obtain his result, one is that the simple set, say <em>A</em>, does not Turing-reduce to the empty set, and that the <em>K</em>, the <a href="halting_problem" title="wikilink">halting problem</a>, does not Turing-reduce to <em>A</em>. He succeeded in the first part (which is obvious by definition), but for the other part, he managed only to prove a <a href="many-one_reduction" title="wikilink">many-one reduction</a>.</p>

<p>It was affirmed by Friedberg and Muchnik in the 1950s using a novel technique called the <a href="priority_method" title="wikilink">priority method</a>. They give a construction for a set that is simple (and thus non-recursive), but fails to compute the halting problem.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>
<h2 id="formal-definitions-and-some-properties">Formal definitions and some properties</h2>
<ul>
<li>A set 

<math display="inline" id="Simple_set:0">
<semantics>
<mrow>
<mi>I</mi>
<mo>⊆</mo>
<mi>ℕ</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<subset></subset>
<ci>I</ci>
<ci>ℕ</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   I\subseteq\mathbb{N}
  </annotation>
</semantics>
</math>

 is called <strong>immune</strong> if 

<math display="inline" id="Simple_set:1">
<semantics>
<mi>I</mi>
<annotation-xml encoding="MathML-Content">
<ci>I</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   I
  </annotation>
</semantics>
</math>

 is infinite, but for every index 

<math display="inline" id="Simple_set:2">
<semantics>
<mi>e</mi>
<annotation-xml encoding="MathML-Content">
<ci>e</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   e
  </annotation>
</semantics>
</math>

, we have 

<math display="inline" id="Simple_set:3">
<semantics>
<mrow>
<mrow>
<msub>
<mi>W</mi>
<mi>e</mi>
</msub>
<mtext>infinite</mtext>
</mrow>
<mo>⟹</mo>
<msub>
<mi>W</mi>
<mi>e</mi>
</msub>
<mo>⊈</mo>
<mi>I</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<and></and>
<apply>
<implies></implies>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>W</ci>
<ci>e</ci>
</apply>
<mtext>infinite</mtext>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>W</ci>
<ci>e</ci>
</apply>
</apply>
<apply>
<csymbol cd="latexml">not-subset-of-or-equals</csymbol>
<share href="#.cmml">
</share>
<ci>I</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   W_{e}\text{ infinite}\implies W_{e}\not\subseteq I
  </annotation>
</semantics>
</math>

. Or equivalently: there is no infinite subset of 

<math display="inline" id="Simple_set:4">
<semantics>
<mi>I</mi>
<annotation-xml encoding="MathML-Content">
<ci>I</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   I
  </annotation>
</semantics>
</math>

 that is recursively enumerable.</li>
<li>A set 

<math display="inline" id="Simple_set:5">
<semantics>
<mrow>
<mi>S</mi>
<mo>⊆</mo>
<mi>ℕ</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<subset></subset>
<ci>S</ci>
<ci>ℕ</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   S\subseteq\mathbb{N}
  </annotation>
</semantics>
</math>

 is called ''' simple ''' if it is recursively enumerable and its complement is immune.</li>
<li>A set 

<math display="inline" id="Simple_set:6">
<semantics>
<mrow>
<mi>I</mi>
<mo>⊆</mo>
<mi>ℕ</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<subset></subset>
<ci>I</ci>
<ci>ℕ</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   I\subseteq\mathbb{N}
  </annotation>
</semantics>
</math>

 is called <strong>effectively immune</strong> if 

<math display="inline" id="Simple_set:7">
<semantics>
<mi>I</mi>
<annotation-xml encoding="MathML-Content">
<ci>I</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   I
  </annotation>
</semantics>
</math>

 is infinite, but there exists a recursive function 

<math display="inline" id="Simple_set:8">
<semantics>
<mi>f</mi>
<annotation-xml encoding="MathML-Content">
<ci>f</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   f
  </annotation>
</semantics>
</math>

 such that for every index 

<math display="inline" id="Simple_set:9">
<semantics>
<mi>e</mi>
<annotation-xml encoding="MathML-Content">
<ci>e</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   e
  </annotation>
</semantics>
</math>

, we have that 

<math display="inline" id="Simple_set:10">
<semantics>
<mrow>
<msub>
<mi>W</mi>
<mi>e</mi>
</msub>
<mo>⊆</mo>
<mi>I</mi>
<mo>⟹</mo>
<mrow>
<mi mathvariant="normal">#</mi>
<mrow>
<mo stretchy="false">(</mo>
<msub>
<mi>W</mi>
<mi>e</mi>
</msub>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>&lt;</mo>
<mrow>
<mi>f</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>e</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<and></and>
<apply>
<subset></subset>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>W</ci>
<ci>e</ci>
</apply>
<ci>I</ci>
</apply>
<apply>
<implies></implies>
<share href="#.cmml">
</share>
<apply>
<times></times>
<ci>normal-#</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>W</ci>
<ci>e</ci>
</apply>
</apply>
</apply>
<apply>
<lt></lt>
<share href="#.cmml">
</share>
<apply>
<times></times>
<ci>f</ci>
<ci>e</ci>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   W_{e}\subseteq I\implies\#(W_{e})<f(e) <="" annotation="">
</f(e)></annotation></semantics>
</math>

.</li>
<li>A set 

<math display="inline" id="Simple_set:11">
<semantics>
<mrow>
<mi>S</mi>
<mo>⊆</mo>
<mi>ℕ</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<subset></subset>
<ci>S</ci>
<ci>ℕ</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   S\subseteq\mathbb{N}
  </annotation>
</semantics>
</math>

 is called <strong>effectively simple</strong> if it is recursively enumerable and its complement is effectively immune. Every effectively simple set, is simple and Turing-complete.</li>
<li>A set 

<math display="inline" id="Simple_set:12">
<semantics>
<mrow>
<mi>I</mi>
<mo>⊆</mo>
<mi>ℕ</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<subset></subset>
<ci>I</ci>
<ci>ℕ</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   I\subseteq\mathbb{N}
  </annotation>
</semantics>
</math>

 is called <strong>hyperimmune</strong> if 

<math display="inline" id="Simple_set:13">
<semantics>
<mi>I</mi>
<annotation-xml encoding="MathML-Content">
<ci>I</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   I
  </annotation>
</semantics>
</math>

 is infinite, but 

<math display="inline" id="Simple_set:14">
<semantics>
<msub>
<mi>p</mi>
<mi>I</mi>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>p</ci>
<ci>I</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   p_{I}
  </annotation>
</semantics>
</math>

 is not computably dominated, where 

<math display="inline" id="Simple_set:15">
<semantics>
<msub>
<mi>p</mi>
<mi>I</mi>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>p</ci>
<ci>I</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   p_{I}
  </annotation>
</semantics>
</math>

 is the list of members of 

<math display="inline" id="Simple_set:16">
<semantics>
<mi>I</mi>
<annotation-xml encoding="MathML-Content">
<ci>I</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   I
  </annotation>
</semantics>
</math>

 in order.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></li>
<li>A set 

<math display="inline" id="Simple_set:17">
<semantics>
<mrow>
<mi>S</mi>
<mo>⊆</mo>
<mi>ℕ</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<subset></subset>
<ci>S</ci>
<ci>ℕ</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   S\subseteq\mathbb{N}
  </annotation>
</semantics>
</math>

 is called <strong>hypersimple</strong> if it is simple and its complement is hyperimmune.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></li>
</ul>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<ul>
<li></li>
<li></li>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Computability_theory" title="wikilink">Category:Computability theory</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Nies (2009) p.35<a href="#fnref1">↩</a></li>
<li id="fn2">Nies (2009) p.27<a href="#fnref2">↩</a></li>
<li id="fn3">Nies (2009) p.37<a href="#fnref3">↩</a></li>
</ol>
</section>
</body>
</html>
