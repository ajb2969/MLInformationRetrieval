<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="697">Karmarkar's algorithm</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Karmarkar's algorithm</h1>
<hr/>

<p><strong>Karmarkar's algorithm</strong> is an <a class="uri" href="algorithm" title="wikilink">algorithm</a> introduced by <a href="Narendra_Karmarkar" title="wikilink">Narendra Karmarkar</a> in 1984 for solving <a href="linear_programming" title="wikilink">linear programming</a> problems. It was the first reasonably efficient algorithm that solves these problems in <a href="polynomial_time" title="wikilink">polynomial time</a>. The <a href="ellipsoid_method" title="wikilink">ellipsoid method</a> is also polynomial time but proved to be inefficient in practice.</p>

<p>Where 

<math display="inline" id="Karmarkar's_algorithm:0">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 is the number of variables and 

<math display="inline" id="Karmarkar's_algorithm:1">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

 is the number of bits of input to the algorithm, Karmarkar's algorithm requires 

<math display="inline" id="Karmarkar's_algorithm:2">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msup>
      <mi>n</mi>
      <mn>3.5</mn>
     </msup>
     <mi>L</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>n</ci>
      <cn type="float">3.5</cn>
     </apply>
     <ci>L</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n^{3.5}L)
  </annotation>
 </semantics>
</math>

 operations on 

<math display="inline" id="Karmarkar's_algorithm:3">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>L</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <ci>L</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(L)
  </annotation>
 </semantics>
</math>

 digit numbers, as compared to 

<math display="inline" id="Karmarkar's_algorithm:4">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msup>
      <mi>n</mi>
      <mn>6</mn>
     </msup>
     <mi>L</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>n</ci>
      <cn type="integer">6</cn>
     </apply>
     <ci>L</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n^{6}L)
  </annotation>
 </semantics>
</math>

 such operations for the ellipsoid algorithm. The runtime of Karmarkar's algorithm is thus</p>

<p>

<math display="block" id="Karmarkar's_algorithm:5">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mrow>
      <msup>
       <mi>n</mi>
       <mn>3.5</mn>
      </msup>
      <msup>
       <mi>L</mi>
       <mn>2</mn>
      </msup>
     </mrow>
     <mo>⋅</mo>
     <mrow>
      <mi>log</mi>
      <mrow>
       <mi>L</mi>
       <mo>⋅</mo>
       <mrow>
        <mi>log</mi>
        <mrow>
         <mi>log</mi>
         <mi>L</mi>
        </mrow>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <ci>normal-⋅</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>n</ci>
       <cn type="float">3.5</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>L</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <log></log>
      <apply>
       <ci>normal-⋅</ci>
       <ci>L</ci>
       <apply>
        <log></log>
        <apply>
         <log></log>
         <ci>L</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n^{3.5}L^{2}\cdot\log L\cdot\log\log L)
  </annotation>
 </semantics>
</math>

</p>

<p>using <a href="Schönhage–Strassen_algorithm" title="wikilink">FFT-based multiplication</a> (see <a href="Big_O_notation" title="wikilink">Big O notation</a>).</p>

<p>Karmarkar's algorithm falls within the class of <a href="interior_point_method" title="wikilink">interior point methods</a>: the current guess for the solution does not follow the boundary of the <a href="feasible_set" title="wikilink">feasible set</a> as in the <a href="simplex_method" title="wikilink">simplex method</a>, but it moves through the interior of the feasible region, improving the approximation of the optimal solution by a definite fraction with every iteration, and converging to an optimal solution with rational data.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>
<h2 id="the-algorithm">The Algorithm</h2>

<p>Consider a <a href="Linear_Programming" title="wikilink">Linear Programming</a> problem in matrix form:</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>maximize <em>c</em><sup><em>T</em></sup><em>x</em></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>subject to</p></td>
</tr>
<tr class="odd">
</tr>
</tbody>
</table>

<p>The algorithm determines the next feasible direction toward optimality and scales back by a factor 0 <a class="uri" href="http://dl.acm.org/citation.cfm?id=808695">http://dl.acm.org/citation.cfm?id=808695</a><a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a><a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> <a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> <a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> <a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> <a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> A simplified version, called the affine-scaling method, analyzed by others,<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> can be described succinctly as follows. Note that the affine-scaling algorithm, while applicable to small scale problems, is not a polynomial time algorithm. For large scale and complex problems the original approach needs to be followed. Karmarkar also has extended the methodology <a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a><a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a><a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a><a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> to solve problems with integer constraints and non-convex problems.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> </p>

<p><code>  Input:  A, b, c, </code>

<math display="inline" id="Karmarkar's_algorithm:6">
 <semantics>
  <msup>
   <mi>x</mi>
   <mn>0</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>x</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{0}
  </annotation>
 </semantics>
</math>

<code>, </code><em><code>stopping</code> <code>criterion</code></em><code>, </code>

<math display="inline" id="Karmarkar's_algorithm:7">
 <semantics>
  <mi>γ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>γ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gamma
  </annotation>
 </semantics>
</math>

<code>.</code></p>

<p><code>  </code>

<math display="inline" id="Karmarkar's_algorithm:8">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>←</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-←</ci>
    <ci>k</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k\leftarrow 0
  </annotation>
 </semantics>
</math>

<br/>
<code>  </code><strong><code>do</code> <code>while</code></strong><code> </code><em><code>stopping</code> <code>criterion</code></em><code> </code><strong><code>not</code> <code>satisfied</code></strong><br/>
<code>     </code>

<math display="inline" id="Karmarkar's_algorithm:9">
 <semantics>
  <mrow>
   <msup>
    <mi>v</mi>
    <mi>k</mi>
   </msup>
   <mo>←</mo>
   <mrow>
    <mi>b</mi>
    <mo>-</mo>
    <mrow>
     <mi>A</mi>
     <msup>
      <mi>x</mi>
      <mi>k</mi>
     </msup>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-←</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>v</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <minus></minus>
     <ci>b</ci>
     <apply>
      <times></times>
      <ci>A</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v^{k}\leftarrow b-Ax^{k}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="inline" id="Karmarkar's_algorithm:10">
 <semantics>
  <mrow>
   <msub>
    <mi>D</mi>
    <mi>v</mi>
   </msub>
   <mo>←</mo>
   <mrow>
    <mo>diag</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <msubsup>
      <mi>v</mi>
      <mn>1</mn>
      <mi>k</mi>
     </msubsup>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <msubsup>
      <mi>v</mi>
      <mi>m</mi>
      <mi>k</mi>
     </msubsup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-←</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>D</ci>
     <ci>v</ci>
    </apply>
    <apply>
     <ci>diag</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>v</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>k</ci>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>v</ci>
       <ci>m</ci>
      </apply>
      <ci>k</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D_{v}\leftarrow\operatorname{diag}(v_{1}^{k},\ldots,v_{m}^{k})
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Karmarkar's_algorithm:11">
 <semantics>
  <mrow>
   <msub>
    <mi>h</mi>
    <mi>x</mi>
   </msub>
   <mo>←</mo>
   <mrow>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msup>
        <mi>A</mi>
        <mi>T</mi>
       </msup>
       <msubsup>
        <mi>D</mi>
        <mi>v</mi>
        <mrow>
         <mo>-</mo>
         <mn>2</mn>
        </mrow>
       </msubsup>
       <mi>A</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <mi>c</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-←</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>h</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>A</ci>
        <ci>T</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>D</ci>
         <ci>v</ci>
        </apply>
        <apply>
         <minus></minus>
         <cn type="integer">2</cn>
        </apply>
       </apply>
       <ci>A</ci>
      </apply>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>c</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h_{x}\leftarrow(A^{T}D_{v}^{-2}A)^{-1}c
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Karmarkar's_algorithm:12">
 <semantics>
  <mrow>
   <msub>
    <mi>h</mi>
    <mi>v</mi>
   </msub>
   <mo>←</mo>
   <mrow>
    <mo>-</mo>
    <mrow>
     <mi>A</mi>
     <msub>
      <mi>h</mi>
      <mi>x</mi>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-←</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>h</ci>
     <ci>v</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>A</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>h</ci>
       <ci>x</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h_{v}\leftarrow-Ah_{x}
  </annotation>
 </semantics>
</math>

</p>

<p><code>     </code><strong><code>if</code></strong><code> </code>

<math display="inline" id="Karmarkar's_algorithm:13">
 <semantics>
  <mrow>
   <msub>
    <mi>h</mi>
    <mi>v</mi>
   </msub>
   <mo>≥</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>h</ci>
     <ci>v</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h_{v}\geq 0
  </annotation>
 </semantics>
</math>

<code> </code><strong><code>then</code></strong><br/>
<code>        </code><strong><code>return</code></strong><code> unbounded</code><br/>
<code>     </code><strong><code>end</code> <code>if</code></strong><br/>
<code>     </code>

<math display="inline" id="Karmarkar's_algorithm:14">
 <semantics>
  <mrow>
   <mi>α</mi>
   <mo>←</mo>
   <mrow>
    <mi>γ</mi>
    <mo>⋅</mo>
    <mrow>
     <mi>min</mi>
     <mrow>
      <mo stretchy="false">{</mo>
      <mrow>
       <mo>-</mo>
       <mrow>
        <msubsup>
         <mi>v</mi>
         <mi>i</mi>
         <mi>k</mi>
        </msubsup>
        <mo>/</mo>
        <mpadded width="+3.4pt">
         <msub>
          <mrow>
           <mo stretchy="false">(</mo>
           <msub>
            <mi>h</mi>
            <mi>v</mi>
           </msub>
           <mo stretchy="false">)</mo>
          </mrow>
          <mi>i</mi>
         </msub>
        </mpadded>
       </mrow>
      </mrow>
      <mo rspace="5.9pt" stretchy="false">|</mo>
      <mrow>
       <msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>h</mi>
          <mi>v</mi>
         </msub>
         <mo stretchy="false">)</mo>
        </mrow>
        <mi>i</mi>
       </msub>
       <mo><</mo>
       <mn>0</mn>
      </mrow>
      <mo rspace="4.2pt">,</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mo>,</mo>
      <mi mathvariant="normal">…</mi>
      <mo>,</mo>
      <mi>m</mi>
      <mo stretchy="false">}</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-←</ci>
    <ci>α</ci>
    <apply>
     <ci>normal-⋅</ci>
     <ci>γ</ci>
     <apply>
      <min></min>
      <apply>
       <minus></minus>
       <apply>
        <divide></divide>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>v</ci>
          <ci>i</ci>
         </apply>
         <ci>k</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>h</ci>
          <ci>v</ci>
         </apply>
         <ci>i</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <lt></lt>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>h</ci>
         <ci>v</ci>
        </apply>
        <ci>i</ci>
       </apply>
       <cn type="integer">0</cn>
      </apply>
      <apply>
       <eq></eq>
       <ci>i</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <ci>m</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha\leftarrow\gamma\cdot\min\{-v_{i}^{k}/(h_{v})_{i}\,\,|\,\,(h_{v})_{i}<0,%
\,i=1,\ldots,m\}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="inline" id="Karmarkar's_algorithm:15">
 <semantics>
  <mrow>
   <msup>
    <mi>x</mi>
    <mrow>
     <mi>k</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msup>
   <mo>←</mo>
   <mrow>
    <msup>
     <mi>x</mi>
     <mi>k</mi>
    </msup>
    <mo>+</mo>
    <mrow>
     <mi>α</mi>
     <msub>
      <mi>h</mi>
      <mi>x</mi>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-←</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <apply>
      <plus></plus>
      <ci>k</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <ci>k</ci>
     </apply>
     <apply>
      <times></times>
      <ci>α</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>h</ci>
       <ci>x</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{k+1}\leftarrow x^{k}+\alpha h_{x}
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Karmarkar's_algorithm:16">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>←</mo>
   <mrow>
    <mi>k</mi>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-←</ci>
    <ci>k</ci>
    <apply>
     <plus></plus>
     <ci>k</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k\leftarrow k+1
  </annotation>
 </semantics>
</math>

</p>

<p><code>  </code><strong><code>end</code> <code>do</code></strong></p>
<h2 id="example">Example</h2>

<p> Consider the linear program</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>maximize</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Karmarkar's_algorithm:17">
 <semantics>
  <msub>
   <mi>x</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1}
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>+</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Karmarkar's_algorithm:18">
 <semantics>
  <msub>
   <mi>x</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{2}
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>subject to</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Karmarkar's_algorithm:19">
 <semantics>
  <mrow>
   <mn>2</mn>
   <mi>p</mi>
   <msub>
    <mi>x</mi>
    <mn>1</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <cn type="integer">2</cn>
    <ci>p</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2px_{1}
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>+</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Karmarkar's_algorithm:20">
 <semantics>
  <msub>
   <mi>x</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{2}
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="odd">
</tr>
</tbody>
</table>

<p>That is, there are 2 variables 

<math display="inline" id="Karmarkar's_algorithm:21">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>x</mi>
    <mn>2</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">2</cn>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1},x_{2}
  </annotation>
 </semantics>
</math>

 and 11 constraints associated with varying values of 

<math display="inline" id="Karmarkar's_algorithm:22">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

. This figure shows each iteration of the algorithm as red circle points. The constraints are shown as blue lines.</p>
<h2 id="patent-controversy---can-mathematics-be-patented">Patent controversy - <em>Can Mathematics be patented?</em></h2>

<p>At the time he invented the algorithm, Narendra Karmarkar was employed by <a class="uri" href="AT&amp;T;" title="wikilink">AT&amp;T;</a>. After applying the algorithm to optimizing AT&amp;T; 's telephone network,<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a> they realized that his invention could be of practical importance. In April 1985, AT&amp;T; promptly applied for a patent on Karmarkar's algorithm and that became more fuel for the ongoing controversy over the issue of <a href="software_patent" title="wikilink">software patents</a>.<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a> This left many mathematicians uneasy, such as <a href="Ronald_Rivest" title="wikilink">Ronald Rivest</a> (himself one of the holders of the patent on the <a href="RSA_(algorithm)" title="wikilink">RSA</a> algorithm), who expressed the opinion that research proceeded on the basis that algorithms should be free. Even before the patent was actually granted, some claimed that there might have been <a href="prior_art" title="wikilink">prior art</a> that was applicable.<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a></p>

<p>Mathematicians who specialize in <a href="numerical_analysis" title="wikilink">numerical analysis</a> such as <a href="Philip_Gill" title="wikilink">Philip Gill</a> and others claimed that Karmarkar's algorithm is equivalent to a <a href="projected_Newton_barrier_method" title="wikilink">projected Newton barrier method</a> with a logarithmic <a href="barrier_function" title="wikilink">barrier function</a>, if the parameters are chosen suitably.<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a> However, Gill's argument is flawed, insofar as the method they describe does not even qualify as an "algorithm", since it requires choices of parameters that don't follow from the internal logic of the method, but rely on external guidance, essentially from Karmarkar's algorithm.<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a> Furthermore, Karmarkar's contributions are considered far from obvious in light of all prior work, including Fiacco-McCormick, Gill and others cited by Saltzman.<a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a><a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a><a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a> The patent was debated in the U.S. Senate and granted in recognition of the essential originality of Karmarkar's work, as : "Methods and apparatus for efficient resource allocation" in May 1988. AT&amp;T; supplied the <a class="uri" href="KORBX" title="wikilink">KORBX</a> system<a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a> <a class="footnoteRef" href="#fn23" id="fnref23"><sup>23</sup></a> based on this patent to the <a href="The_Pentagon" title="wikilink">Pentagon</a>,<a class="footnoteRef" href="#fn24" id="fnref24"><sup>24</sup></a><a class="footnoteRef" href="#fn25" id="fnref25"><sup>25</sup></a> which enabled them to solve mathematical programming problems which were previously considered unsolvable.</p>

<p>Opponents of software patents have further alleged that the patents ruined the positive interaction cycles that previously characterized the relationship between researchers in linear programming and industry, and specifically it isolated Karmarkar himself from the network of mathematical researchers in his field. <a class="footnoteRef" href="#fn26" id="fnref26"><sup>26</sup></a></p>

<p>The patent itself expired in April 2006, and the algorithm is presently in the public domain.</p>
<h2 id="references">References</h2>
<ul>
<li>Ilan Adler, Narendra Karmarkar, Mauricio G.C. Resende and Geraldo Veiga (1989). "An Implementation of Karmarkar's Algorithm for Linear Programming". <em>Mathematical Programming</em>, Vol 44, p. 297–335.</li>
<li>Narendra Karmarkar (1984). "<a href="http://retis.sssup.it/~bini/teaching/optim2010/karmarkar.pdf">A New Polynomial Time Algorithm for Linear Programming</a>", <em><a class="uri" href="Combinatorica" title="wikilink">Combinatorica</a></em>, Vol <strong>4</strong>, nr. 4, p. 373–395.</li>
</ul>

<p>"</p>

<p><a href="Category:Optimization_algorithms_and_methods" title="wikilink">Category:Optimization algorithms and methods</a> <a href="Category:Articles_with_example_pseudocode" title="wikilink">Category:Articles with example pseudocode</a> <a href="Category:Software_patent_law" title="wikilink">Category:Software patent law</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="http://link.springer.com/article/10.1007%2FBF02579150">http://link.springer.com/article/10.1007%2FBF02579150</a><a href="#fnref2">↩</a></li>
<li id="fn3"><a class="uri" href="http://onlinelibrary.wiley.com/doi/10.1002/j.1538-7305.1989.tb00316.x/abstract">http://onlinelibrary.wiley.com/doi/10.1002/j.1538-7305.1989.tb00316.x/abstract</a><a href="#fnref3">↩</a></li>
<li id="fn4">Karmarkar N.K., An InteriorPoint Approach to NPComplete Problems Part I, AMS series on Contemporary Mathematics 114, pp. 297308 (June 1990). <a class="uri" href="http://www.ams.org/books/conm/114/conm114-endmatter.pdf">http://www.ams.org/books/conm/114/conm114-endmatter.pdf</a><a href="#fnref4">↩</a></li>
<li id="fn5">Karmarkar, N.K.., Riemannian Geometry Underlying Interior Point Methods for Linear programming, AMS series on Contemporary Mathematics 114, pp. 5175 (June 1990). <a class="uri" href="http://www.ams.org/books/conm/114/conm114-endmatter.pdf">http://www.ams.org/books/conm/114/conm114-endmatter.pdf</a><a href="#fnref5">↩</a></li>
<li id="fn6">Karmarkar N. K., Lagarias, J.C., Slutsman, L., and Wang, P., Power Series Variants of KarmarkarType Algorithm, AT &amp; T technical Journal 68, No. 3, May/June (1989).<a href="#fnref6">↩</a></li>
<li id="fn7"><a href="http://sanghv.com/download/Ebook/Machine%20Learning/Kalyanmoy%20Deb,%20Arnab%20Bhattacharya,%20Nirupam%20Chakraborti,%20Partha%20Chakroborty,%20Swagatam%20Das,%20Joydeep%20Dutta,%20Santosh%20K.%20Gupta,%20Ashu%20Jain,%20Varun%20Aggarwal,%20Juergen%20Branke,%20Sushil%20J.%20Louis,%20Kay%20Chen%20Tan%20Simulated%20E.pdf">http://sanghv.com/download/Ebook/Machine%20Learning/Kalyanmoy%20Deb,%20Arnab%20Bhattacharya,%20Nirupam%20Chakraborti,%20Partha%20Chakroborty,%20Swagatam%20Das,%20Joydeep%20Dutta,%20Santosh%20K.%20Gupta,%20Ashu%20Jain,%20Varun%20Aggarwal,%20Juergen%20Branke,%20Sushil%20J.%20Louis,%20Kay%20Chen%20Tan%20Simulated%20E.pdf</a><a href="#fnref7">↩</a></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
<li id="fn9">Karmarkar, N.K.,Interior Point Methods in Optimization, Proceedings of the Second International Conference on Industrial and Applied Mathematics, SIAM, pp. 160181 (1991)<a href="#fnref9">↩</a></li>
<li id="fn10">Karmarkar, N. K. and Kamath, A. P., A continuous Approach to Deriving Upper Bounds in Quadratic Maximization Problems with Integer Constraints, Recent Advances in Global Optimization, pp. 125140, Princeton University Press (1992).<a href="#fnref10">↩</a></li>
<li id="fn11">26. Karmarkar, N. K., Thakur, S. A., An Interior Point Approach to a Tensor Optimisation Problem with Application to Upper Bounds in Integer Quadratic Optimization Problems, Proceedings of Second Conference on Integer Programming and Combinatorial Optimisation, (May 1992).<a href="#fnref11">↩</a></li>
<li id="fn12">27. Kamath, A., Karmarkar, N. K., A Continuous Method for Computing Bounds in Integer Quadratic Optimisation Problems, Journal of Global Optimization (1992).<a href="#fnref12">↩</a></li>
<li id="fn13">Karmarkar, N. K., Beyond Convexity: New Perspectives in Computational Optimization. Springer Lecture Notes in Computer Science LNCS 6457, Dec 2010<a href="#fnref13">↩</a></li>
<li id="fn14">Sinha L.P., Freedman, B. A., Karmarkar, N. K., Putcha, A., and Ramakrishnan K.G., Overseas Network Planning, Proceedings of the Third International Network Planning Symposium, NETWORKS' 86, Tarpon Springs, Florida (June 1986).<a href="#fnref14">↩</a></li>
<li id="fn15"><a href="#fnref15">↩</a></li>
<li id="fn16"><a href="http://www.cs.cmu.edu/afs/cs.cmu.edu/academic/class/15850c-s96/www/interiorpoint.txt">Various posts by Matthew Saltzman, Clemson University</a><a href="#fnref16">↩</a></li>
<li id="fn17"><a href="#fnref17">↩</a></li>
<li id="fn18"><a href="#fnref18">↩</a></li>
<li id="fn19"></li>
<li id="fn20">Mark A. Paley (1995). "The Karmarkar Patent: Why Congress Should “Open the Door” to Algorithms as Patentable Subject Matter". 22 COMPUTER L. REP. 7<a href="#fnref20">↩</a></li>
<li id="fn21"><a href="#fnref21">↩</a></li>
<li id="fn22"><a href="#fnref22">↩</a></li>
<li id="fn23"><a class="uri" href="http://www.nytimes.com/1988/08/13/business/big-at-t-computer-for-complexities.html">http://www.nytimes.com/1988/08/13/business/big-at-t-computer-for-complexities.html</a><a href="#fnref23">↩</a></li>
<li id="fn24"><a class="uri" href="http://www.apnewsarchive.com/1989/Military-Is-First-Announced-Customer-Of-AT-T-Software/id-8a376783cd62cdf141de700a7c948f61">http://www.apnewsarchive.com/1989/Military-Is-First-Announced-Customer-Of-AT-T-Software/id-8a376783cd62cdf141de700a7c948f61</a><a href="#fnref24">↩</a></li>
<li id="fn25"><a class="uri" href="http://ieeexplore.ieee.org/xpl/login.jsp?tp">http://ieeexplore.ieee.org/xpl/login.jsp?tp</a>=&amp;arnumber;=70419&amp;url;=http%3A%2F%2Fieeexplore.ieee.org%2Fxpls%2Fabs_all.jsp%3Farnumber%3D70419<a href="#fnref25">↩</a></li>
<li id="fn26"><a href="#fnref26">↩</a></li>
</ol>
</section>
</body>
</html>
