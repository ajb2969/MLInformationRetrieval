<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1495">Tautology (logic)</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Tautology (logic)</h1>
<hr/>

<p>In <a class="uri" href="logic" title="wikilink">logic</a>, a <strong>tautology</strong> (from the <a href="Greek_language" title="wikilink">Greek</a> word ταυτολογία) is a <a href="well-formed_formula" title="wikilink">formula</a> that is true in every possible <a href="interpretation_(logic)" title="wikilink">interpretation</a>.</p>

<p><a class="uri" href="Philosopher" title="wikilink">Philosopher</a> <a href="Ludwig_Wittgenstein" title="wikilink">Ludwig Wittgenstein</a> first applied the term to redundancies of <a href="propositional_logic" title="wikilink">propositional logic</a> in 1921. (It had been used earlier to refer to <a href="tautology_(rhetoric)" title="wikilink">rhetorical tautologies</a>, and continues to be used in that alternate sense.) A formula is <a href="Satisfiability_and_validity" title="wikilink">satisfiable</a> if it is true under at least one interpretation, and thus a tautology is a formula whose negation is unsatisfiable. Unsatisfiable statements, both through negation and affirmation, are known formally as <a href="contradiction" title="wikilink">contradictions</a>. A formula that is neither a tautology nor a contradiction is said to be <a href="Contingency_(philosophy)" title="wikilink">logically contingent</a>. Such a formula can be made either true or false based on the values assigned to its propositional variables. The <a href="double_turnstile" title="wikilink">double turnstile</a> notation 

<math display="inline" id="Tautology_(logic):0">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>⊨</mo>
   <mi>S</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-⊨</ci>
    <csymbol cd="latexml">absent</csymbol>
    <ci>S</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vDash S
  </annotation>
 </semantics>
</math>

 is used to indicate that <em>S</em> is a tautology. Tautology is sometimes symbolized by "V<em>pq</em>", and contradiction by "O<em>pq</em>". The <a href="tee_(symbol)" title="wikilink">tee</a> symbol 

<math display="inline" id="Tautology_(logic):1">
 <semantics>
  <mo>⊤</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">top</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \top
  </annotation>
 </semantics>
</math>

 is sometimes used to denote an arbitrary tautology, with the dual symbol 

<math display="inline" id="Tautology_(logic):2">
 <semantics>
  <mo>⊥</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">bottom</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bot
  </annotation>
 </semantics>
</math>

 (<a class="uri" href="falsum" title="wikilink">falsum</a>) representing an arbitrary contradiction; in any symbolism, a tautology may be substituted for the truth value "<a href="Logical_truth" title="wikilink">true</a>," as symbolized, for instance, by "1."</p>

<p>Tautologies are a key concept in <a href="propositional_logic" title="wikilink">propositional logic</a>, where a tautology is defined as a propositional formula that is true under any possible Boolean valuation of its <a href="propositional_variable" title="wikilink">propositional variables</a>. A key property of tautologies in propositional logic is that an <a href="effective_method" title="wikilink">effective method</a> exists for testing whether a given formula is always satisfied (or, equivalently, whether its negation is unsatisfiable).</p>

<p>The definition of <em>tautology</em> can be extended to sentences in <a href="predicate_logic" title="wikilink">predicate logic</a>, which may contain <a href="Quantification_(logic)" title="wikilink">quantifiers</a>, unlike sentences of propositional logic. In propositional logic, there is no distinction between a tautology and a <a href="Validity" title="wikilink">logically valid</a> formula. In the context of <a href="predicate_logic" title="wikilink">predicate logic</a>, many authors define a tautology to be a sentence that can be obtained by taking a tautology of propositional logic and uniformly replacing each propositional variable by a first-order formula (one formula per propositional variable). The set of such formulas is a <a href="proper_subset" title="wikilink">proper subset</a> of the set of logically valid sentences of predicate logic (which are the sentences that are true in every <a href="structure_(mathematical_logic)" title="wikilink">model</a>).</p>
<h2 id="history">History</h2>

<p>The word <em>tautology</em> was used by the ancient Greeks to describe a statement that was true merely by virtue of saying the same thing twice, a pejorative meaning that is still used for <a href="tautology_(rhetoric)" title="wikilink">rhetorical tautologies</a>. Between 1800 and 1940, the word gained new meaning in logic, and is currently used in <a href="mathematical_logic" title="wikilink">mathematical logic</a> to denote a certain type of propositional formula, without the pejorative connotations it originally possessed.</p>

<p>In 1800, <a href="Immanuel_Kant" title="wikilink">Immanuel Kant</a> wrote in his book <em>Logic</em>:</p>
<dl>
<dd>"The identity of concepts in analytical judgments can be either <em>explicit</em> (<em>explicita</em>) or <em>non-explicit</em> (<em>implicita</em>). In the former case analytic propositions are <em>tautological.</em>"
</dd>
</dl>

<p>Here <em>analytic proposition</em> refers to an <a href="analytic_truth" title="wikilink">analytic truth</a>, a statement in natural language that is true solely because of the terms involved.</p>

<p>In 1884, <a href="Gottlob_Frege" title="wikilink">Gottlob Frege</a> proposed in his <em>Grundlagen</em> that a truth is analytic exactly if it can be derived using logic. But he maintained a distinction between analytic truths (those true based only on the meanings of their terms) and tautologies (statements devoid of content).</p>

<p>In 1921, in his <em><a href="Tractatus_Logico-Philosophicus" title="wikilink">Tractatus Logico-Philosophicus</a></em>, Ludwig Wittgenstein proposed that statements that can be deduced by logical deduction are tautological (empty of meaning) as well as being analytic truths. <a href="Henri_Poincaré" title="wikilink">Henri Poincaré</a> had made similar remarks in <em><a href="Science_and_Hypothesis" title="wikilink">Science and Hypothesis</a></em> in 1905. Although <a href="Bertrand_Russell" title="wikilink">Bertrand Russell</a> at first argued against these remarks by Wittgenstein and Poincaré, claiming that mathematical truths were not only non-tautologous but were <a href="synthetic_truth" title="wikilink">synthetic</a>, he later spoke in favor of them in 1918:</p>
<dl>
<dd>"Everything that is a proposition of logic has got to be in some sense or the other like a tautology. It has got to be something that has some peculiar quality, which I do not know how to define, that belongs to logical propositions but not to others."
</dd>
</dl>

<p>Here <em>logical proposition</em> refers to a proposition that is provable using the laws of logic.</p>

<p>During the 1930s, the formalization of the semantics of propositional logic in terms of truth assignments was developed. The term <em>tautology</em> began to be applied to those propositional formulas that are true regardless of the truth or falsity of their propositional variables. Some early books on logic (such as <em>Symbolic Logic</em> by <a href="C._I._Lewis" title="wikilink">C. I. Lewis</a> and Langford, 1932) used the term for any proposition (in any formal logic) that is universally valid. It is common in presentations after this (such as <a href="Stephen_Kleene" title="wikilink">Stephen Kleene</a> 1967 and <a href="Herbert_Enderton" title="wikilink">Herbert Enderton</a> 2002) to use <em>tautology</em> to refer to a logically valid propositional formula, but to maintain a distinction between <em>tautology</em> and <em>logically valid</em> in the context of first-order logic (see <a href="Tautology_(logic)#Tautologies_versus_validities_in_first-order_logic" title="wikilink">below</a>).</p>
<h2 id="background">Background</h2>

<p>Propositional logic begins with <strong>propositional variables</strong>, atomic units that represent concrete propositions. A <strong>formula</strong> consists of propositional variables connected by logical connectives in a meaningful way, so that the truth of the overall formula can be uniquely deduced from the truth or falsity of each variable. A <strong>valuation</strong> is a function that assigns each propositional variable either T (for truth) or F (for falsity). So, for example, using the propositional variables <em>A</em> and <em>B</em>, the binary connectives 

<math display="inline" id="Tautology_(logic):3">
 <semantics>
  <mo>∨</mo>
  <annotation-xml encoding="MathML-Content">
   <or></or>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lor
  </annotation>
 </semantics>
</math>


 and 

<math display="inline" id="Tautology_(logic):4">
 <semantics>
  <mo>∧</mo>
  <annotation-xml encoding="MathML-Content">
   <and></and>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \land
  </annotation>
 </semantics>
</math>

 representing <a href="Logical_disjunction" title="wikilink">disjunction</a> and <a href="Logical_conjunction" title="wikilink">conjunction</a> respectively, and the unary connective 

<math display="inline" id="Tautology_(logic):5">
 <semantics>
  <mi mathvariant="normal">¬</mi>
  <annotation-xml encoding="MathML-Content">
   <not></not>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lnot
  </annotation>
 </semantics>
</math>

 representing <a class="uri" href="negation" title="wikilink">negation</a>, the following formula can be obtained:

<math display="block" id="Tautology_(logic):6">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>A</mi>
     <mo>∧</mo>
     <mi>B</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∨</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi mathvariant="normal">¬</mi>
     <mi>A</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∨</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi mathvariant="normal">¬</mi>
     <mi>B</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <or></or>
    <apply>
     <and></and>
     <ci>A</ci>
     <ci>B</ci>
    </apply>
    <apply>
     <times></times>
     <not></not>
     <ci>A</ci>
    </apply>
    <apply>
     <times></times>
     <not></not>
     <ci>B</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (A\land B)\lor(\lnot A)\lor(\lnot B)
  </annotation>
 </semantics>
</math>

. A valuation here must assign to each of <em>A</em> and <em>B</em> either T or F. But no matter how this assignment is made, the overall formula will come out true. For if the first conjunction 

<math display="inline" id="Tautology_(logic):7">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi>A</mi>
    <mo>∧</mo>
    <mi>B</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <ci>A</ci>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (A\land B)
  </annotation>
 </semantics>
</math>

 is not satisfied by a particular valuation, then one of <em>A</em> and <em>B</em> is assigned F, which will cause the corresponding later disjunct to be T.</p>
<h2 id="definition-and-examples">Definition and examples</h2>

<p>A formula of propositional logic is a <strong>tautology</strong> if the formula itself is always true regardless of which valuation is used for the propositional variables.</p>

<p>There are infinitely many tautologies. Examples include:</p>
<ul>
<li>

<math display="inline" id="Tautology_(logic):8">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi>A</mi>
    <mo>∨</mo>
    <mrow>
     <mi mathvariant="normal">¬</mi>
     <mi>A</mi>
    </mrow>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <or></or>
    <ci>A</ci>
    <apply>
     <times></times>
     <not></not>
     <ci>A</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (A\lor\lnot A)
  </annotation>
 </semantics>
</math>


 ("<em>A</em> or not <em>A</em>"), the <a href="law_of_the_excluded_middle" title="wikilink">law of the excluded middle</a>. This formula has only one propositional variable, <em>A</em>. Any valuation for this formula must, by definition, assign <em>A</em> one of the truth values <em>true</em> or <em>false</em>, and assign 

<math display="inline" id="Tautology_(logic):9">
 <semantics>
  <mi mathvariant="normal">¬</mi>
  <annotation-xml encoding="MathML-Content">
   <not></not>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lnot
  </annotation>
 </semantics>
</math>

<em>A</em> the other truth value.</li>
<li>

<math display="inline" id="Tautology_(logic):10">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>A</mi>
    <mo>→</mo>
    <mi>B</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>⇔</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi mathvariant="normal">¬</mi>
    <mi>B</mi>
    <mo>→</mo>
    <mi mathvariant="normal">¬</mi>
    <mi>A</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">A</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">B</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-⇔</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <not></not>
     <csymbol cd="unknown">B</csymbol>
     <ci>normal-→</ci>
     <not></not>
     <csymbol cd="unknown">A</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (A\to B)\Leftrightarrow(\lnot B\to\lnot A)
  </annotation>
 </semantics>
</math>

 ("if <em>A</em> implies <em>B</em>, then not-<em>B</em> implies not-<em>A</em>", and vice versa), which expresses the law of <a class="uri" href="contraposition" title="wikilink">contraposition</a>.</li>
<li>

<math display="inline" id="Tautology_(logic):11">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi mathvariant="normal">¬</mi>
     <mi>A</mi>
     <mo>→</mo>
     <mi>B</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∧</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi mathvariant="normal">¬</mi>
     <mi>A</mi>
     <mo>→</mo>
     <mi mathvariant="normal">¬</mi>
     <mi>B</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mi>A</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <not></not>
      <csymbol cd="unknown">A</csymbol>
      <ci>normal-→</ci>
      <csymbol cd="unknown">B</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <and></and>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <not></not>
      <csymbol cd="unknown">A</csymbol>
      <ci>normal-→</ci>
      <not></not>
      <csymbol cd="unknown">B</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <csymbol cd="unknown">A</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ((\lnot A\to B)\land(\lnot A\to\lnot B))\to A
  </annotation>
 </semantics>
</math>

 ("if not-<em>A</em> implies both <em>B</em> and its negation not-<em>B</em>, then not-<em>A</em> must be false, then <em>A</em> must be true"), which is the principle known as <em><a href="reductio_ad_absurdum" title="wikilink">reductio ad absurdum</a></em>.</li>
<li>

<math display="inline" id="Tautology_(logic):12">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">¬</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>A</mi>
      <mo>∧</mo>
      <mi>B</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>⇔</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mrow>
      <mi mathvariant="normal">¬</mi>
      <mi>A</mi>
     </mrow>
     <mo>∨</mo>
     <mrow>
      <mi mathvariant="normal">¬</mi>
      <mi>B</mi>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-⇔</ci>
    <apply>
     <not></not>
     <apply>
      <and></and>
      <ci>A</ci>
      <ci>B</ci>
     </apply>
    </apply>
    <apply>
     <or></or>
     <apply>
      <times></times>
      <not></not>
      <ci>A</ci>
     </apply>
     <apply>
      <times></times>
      <not></not>
      <ci>B</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lnot(A\land B)\Leftrightarrow(\lnot A\lor\lnot B)
  </annotation>
 </semantics>
</math>

 ("if not both <em>A</em> and <em>B</em>, then not-<em>A</em> or not-<em>B</em>", and vice versa), which is known as <a href="de_Morgan's_law" title="wikilink">de Morgan's law</a>.</li>
<li>

<math display="inline" id="Tautology_(logic):13">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>A</mi>
     <mo>→</mo>
     <mi>B</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∧</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>B</mi>
     <mo>→</mo>
     <mi>C</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>A</mi>
    <mo>→</mo>
    <mi>C</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">A</csymbol>
      <ci>normal-→</ci>
      <csymbol cd="unknown">B</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <and></and>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">B</csymbol>
      <ci>normal-→</ci>
      <csymbol cd="unknown">C</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">A</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">C</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ((A\to B)\land(B\to C))\to(A\to C)
  </annotation>
 </semantics>
</math>


 ("if <em>A</em> implies <em>B</em> and <em>B</em> implies <em>C</em>, then <em>A</em> implies <em>C</em>"), which is the principle known as <a class="uri" href="syllogism" title="wikilink">syllogism</a>.</li>
<li>

<math display="inline" id="Tautology_(logic):14">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>A</mi>
     <mo>∨</mo>
     <mi>B</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∧</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>A</mi>
     <mo>→</mo>
     <mi>C</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∧</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>B</mi>
     <mo>→</mo>
     <mi>C</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mi>C</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">A</csymbol>
      <or></or>
      <csymbol cd="unknown">B</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <and></and>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">A</csymbol>
      <ci>normal-→</ci>
      <csymbol cd="unknown">C</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <and></and>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">B</csymbol>
      <ci>normal-→</ci>
      <csymbol cd="unknown">C</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <csymbol cd="unknown">C</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ((A\lor B)\land(A\to C)\land(B\to C))\to C
  </annotation>
 </semantics>
</math>

 (if at least one of <em>A</em> or <em>B</em> is true, and each implies <em>C</em>, then <em>C</em> must be true as well), which is the principle known as <a href="proof_by_cases" title="wikilink">proof by cases</a>.</li>
</ul>

<p>A minimal tautology is a tautology that is not the instance of a shorter tautology.</p>
<ul>
<li>

<math display="inline" id="Tautology_(logic):15">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>A</mi>
     <mi>B</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>A</mi>
     <mi>B</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <times></times>
     <ci>A</ci>
     <ci>B</ci>
    </apply>
    <apply>
     <times></times>
     <ci>A</ci>
     <ci>B</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (AB)\to(AB)
  </annotation>
 </semantics>
</math>

 is a tautology, but not a minimal one, because it is an instantiation of 

<math display="inline" id="Tautology_(logic):16">
 <semantics>
  <mrow>
   <mi>C</mi>
   <mo>→</mo>
   <mi>C</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>C</ci>
    <ci>C</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C\to C
  </annotation>
 </semantics>
</math>

.</li>
</ul>
<h2 id="verifying-tautologies">Verifying tautologies</h2>

<p>The problem of determining whether a formula is a tautology is fundamental in propositional logic. If there are <em>n</em> variables occurring in a formula then there are 2<sup><em>n</em></sup> distinct valuations for the formula. Therefore the task of determining whether or not the formula is a tautology is a finite, mechanical one: one need only evaluate the <a href="truth_value" title="wikilink">truth value</a> of the formula under each of its possible valuations. One algorithmic method for verifying that every valuation causes this sentence to be true is to make a <a href="truth_table" title="wikilink">truth table</a> that includes every possible valuation.</p>

<p>For example, consider the formula</p>

<p>

<math display="block" id="Tautology_(logic):17">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>A</mi>
     <mo>∧</mo>
     <mi>B</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>→</mo>
    <mi>C</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>⇔</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>A</mi>
    <mo>→</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>B</mi>
     <mo>→</mo>
     <mi>C</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">A</csymbol>
      <and></and>
      <csymbol cd="unknown">B</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-→</ci>
     <csymbol cd="unknown">C</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-⇔</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">A</csymbol>
     <ci>normal-→</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">B</csymbol>
      <ci>normal-→</ci>
      <csymbol cd="unknown">C</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-.</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ((A\land B)\to C)\Leftrightarrow(A\to(B\to C)).
  </annotation>
 </semantics>
</math>

 There are 8 possible valuations for the propositional variables <em>A</em>, <em>B</em>, <em>C</em>, represented by the first three columns of the following table. The remaining columns show the truth of subformulas of the formula above, culminating in a column showing the truth value of the original formula under each valuation.</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>A</p></td>
<td style="text-align: left;">
<p>B</p></td>
<td style="text-align: left;">
<p>C</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Tautology_(logic):18">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>∧</mo>
   <mi>B</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <ci>A</ci>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\land B
  </annotation>
 </semantics>
</math>


</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Tautology_(logic):19">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>A</mi>
     <mo>∧</mo>
     <mi>B</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mi>C</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <and></and>
     <ci>A</ci>
     <ci>B</ci>
    </apply>
    <ci>C</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (A\land B)\to C
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Tautology_(logic):20">
 <semantics>
  <mrow>
   <mi>B</mi>
   <mo>→</mo>
   <mi>C</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>B</ci>
    <ci>C</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B\to C
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Tautology_(logic):21">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>→</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>B</mi>
    <mo>→</mo>
    <mi>C</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">A</csymbol>
    <ci>normal-→</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">B</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">C</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\to(B\to C)
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Tautology_(logic):22">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>A</mi>
     <mo>∧</mo>
     <mi>B</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>→</mo>
    <mi>C</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>⇔</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>A</mi>
    <mo>→</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>B</mi>
     <mo>→</mo>
     <mi>C</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">A</csymbol>
      <and></and>
      <csymbol cd="unknown">B</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-→</ci>
     <csymbol cd="unknown">C</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-⇔</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">A</csymbol>
     <ci>normal-→</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">B</csymbol>
      <ci>normal-→</ci>
      <csymbol cd="unknown">C</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ((A\land B)\to C)\Leftrightarrow(A\to(B\to C))
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>T</p></td>
<td style="text-align: left;">
<p>T</p></td>
<td style="text-align: left;">
<p>T</p></td>
<td style="text-align: left;">
<p>T</p></td>
<td style="text-align: left;">
<p>T</p></td>
<td style="text-align: left;">
<p>T</p></td>
<td style="text-align: left;">
<p>T</p></td>
<td style="text-align: left;">
<p>T</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>T</p></td>
<td style="text-align: left;">
<p>T</p></td>
<td style="text-align: left;">
<p>F</p></td>
<td style="text-align: left;">
<p>T</p></td>
<td style="text-align: left;">
<p>F</p></td>
<td style="text-align: left;">
<p>F</p></td>
<td style="text-align: left;">
<p>F</p></td>
<td style="text-align: left;">
<p>T</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>T</p></td>
<td style="text-align: left;">
<p>F</p></td>
<td style="text-align: left;">
<p>T</p></td>
<td style="text-align: left;">
<p>F</p></td>
<td style="text-align: left;">
<p>T</p></td>
<td style="text-align: left;">
<p>T</p></td>
<td style="text-align: left;">
<p>T</p></td>
<td style="text-align: left;">
<p>T</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>T</p></td>
<td style="text-align: left;">
<p>F</p></td>
<td style="text-align: left;">
<p>F</p></td>
<td style="text-align: left;">
<p>F</p></td>
<td style="text-align: left;">
<p>T</p></td>
<td style="text-align: left;">
<p>T</p></td>
<td style="text-align: left;">
<p>T</p></td>
<td style="text-align: left;">
<p>T</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>F</p></td>
<td style="text-align: left;">
<p>T</p></td>
<td style="text-align: left;">
<p>T</p></td>
<td style="text-align: left;">
<p>F</p></td>
<td style="text-align: left;">
<p>T</p></td>
<td style="text-align: left;">
<p>T</p></td>
<td style="text-align: left;">
<p>T</p></td>
<td style="text-align: left;">
<p>T</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>F</p></td>
<td style="text-align: left;">
<p>T</p></td>
<td style="text-align: left;">
<p>F</p></td>
<td style="text-align: left;">
<p>F</p></td>
<td style="text-align: left;">
<p>T</p></td>
<td style="text-align: left;">
<p>F</p></td>
<td style="text-align: left;">
<p>T</p></td>
<td style="text-align: left;">
<p>T</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>F</p></td>
<td style="text-align: left;">
<p>F</p></td>
<td style="text-align: left;">
<p>T</p></td>
<td style="text-align: left;">
<p>F</p></td>
<td style="text-align: left;">
<p>T</p></td>
<td style="text-align: left;">
<p>T</p></td>
<td style="text-align: left;">
<p>T</p></td>
<td style="text-align: left;">
<p>T</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>F</p></td>
<td style="text-align: left;">
<p>F</p></td>
<td style="text-align: left;">
<p>F</p></td>
<td style="text-align: left;">
<p>F</p></td>
<td style="text-align: left;">
<p>T</p></td>
<td style="text-align: left;">
<p>T</p></td>
<td style="text-align: left;">
<p>T</p></td>
<td style="text-align: left;">
<p>T</p></td>
</tr>
</tbody>
</table>

<p>Because each row of the final column shows <em>T</em>, the sentence in question is verified to be a tautology.</p>

<p>It is also possible to define a <a href="deductive_system" title="wikilink">deductive system</a> (proof system) for propositional logic, as a simpler variant of the deductive systems employed for first-order logic (see Kleene 1967, Sec 1.9 for one such system). A proof of a tautology in an appropriate deduction system may be much shorter than a complete truth table (a formula with <em>n</em> propositional variables requires a truth table with 2<sup><em>n</em></sup> lines, which quickly becomes infeasible as <em>n</em> increases). Proof systems are also required for the study of intuitionistic propositional logic, in which the method of truth tables cannot be employed because the law of the excluded middle is not assumed.</p>
<h2 id="tautological-implication">Tautological implication</h2>

<p>A formula <em>R</em> is said to <strong>tautologically imply</strong> a formula <em>S</em> if every valuation that causes <em>R</em> to be true also causes <em>S</em> to be true. This situation is denoted 

<math display="inline" id="Tautology_(logic):23">
 <semantics>
  <mrow>
   <mi>R</mi>
   <mo>⊧</mo>
   <mi>S</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">models</csymbol>
    <ci>R</ci>
    <ci>S</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R\models S
  </annotation>
 </semantics>
</math>


. It is equivalent to the formula 

<math display="inline" id="Tautology_(logic):24">
 <semantics>
  <mrow>
   <mi>R</mi>
   <mo>→</mo>
   <mi>S</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>R</ci>
    <ci>S</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R\to S
  </annotation>
 </semantics>
</math>

 being a tautology (Kleene 1967 p. 27).</p>

<p>For example, let <em>S</em> be 

<math display="inline" id="Tautology_(logic):25">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>∧</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>B</mi>
     <mo>∨</mo>
     <mrow>
      <mi mathvariant="normal">¬</mi>
      <mi>B</mi>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <ci>A</ci>
    <apply>
     <or></or>
     <ci>B</ci>
     <apply>
      <times></times>
      <not></not>
      <ci>B</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\land(B\lor\lnot B)
  </annotation>
 </semantics>
</math>

. Then <em>S</em> is not a tautology, because any valuation that makes <em>A</em> false will make <em>S</em> false. But any valuation that makes <em>A</em> true will make <em>S</em> true, because 

<math display="inline" id="Tautology_(logic):26">
 <semantics>
  <mrow>
   <mi>B</mi>
   <mo>∨</mo>
   <mrow>
    <mi mathvariant="normal">¬</mi>
    <mi>B</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <or></or>
    <ci>B</ci>
    <apply>
     <times></times>
     <not></not>
     <ci>B</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B\lor\lnot B
  </annotation>
 </semantics>
</math>

 is a tautology. Let <em>R</em> be the formula 

<math display="inline" id="Tautology_(logic):27">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>∧</mo>
   <mi>C</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <ci>A</ci>
    <ci>C</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\land C
  </annotation>
 </semantics>
</math>

. Then 

<math display="inline" id="Tautology_(logic):28">
 <semantics>
  <mrow>
   <mi>R</mi>
   <mo>⊧</mo>
   <mi>S</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">models</csymbol>
    <ci>R</ci>
    <ci>S</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R\models S
  </annotation>
 </semantics>
</math>


, because any valuation satisfying <em>R</em> makes <em>A</em> true and thus makes <em>S</em> true.</p>

<p>It follows from the definition that if a formula <em>R</em> is a contradiction then <em>R</em> tautologically implies every formula, because there is no truth valuation that causes <em>R</em> to be true and so the definition of tautological implication is trivially satisfied. Similarly, if <em>S</em> is a tautology then <em>S</em> is tautologically implied by every formula.</p>
<h2 id="substitution">Substitution</h2>

<p>There is a general procedure, the <strong>substitution rule</strong>, that allows additional tautologies to be constructed from a given tautology (Kleene 1967 sec. 3). Suppose that <em>S</em> is a tautology and for each propositional variable <em>A</em> in <em>S</em> a fixed sentence <em>S</em><sub><em>A</em></sub> is chosen. Then the sentence obtained by replacing each variable <em>A</em> in <em>S</em> with the corresponding sentence <em>S</em><sub><em>A</em></sub> is also a tautology.</p>

<p>For example, let <em>S</em> be 

<math display="inline" id="Tautology_(logic):29">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>A</mi>
     <mo>∧</mo>
     <mi>B</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∨</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi mathvariant="normal">¬</mi>
     <mi>A</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∨</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi mathvariant="normal">¬</mi>
     <mi>B</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <or></or>
    <apply>
     <and></and>
     <ci>A</ci>
     <ci>B</ci>
    </apply>
    <apply>
     <times></times>
     <not></not>
     <ci>A</ci>
    </apply>
    <apply>
     <times></times>
     <not></not>
     <ci>B</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (A\land B)\lor(\lnot A)\lor(\lnot B)
  </annotation>
 </semantics>
</math>

, a tautology. Let <em>S</em><sub><em>A</em></sub> be 

<math display="inline" id="Tautology_(logic):30">
 <semantics>
  <mrow>
   <mi>C</mi>
   <mo>∨</mo>
   <mi>D</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <or></or>
    <ci>C</ci>
    <ci>D</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C\lor D
  </annotation>
 </semantics>
</math>

 and let <em>S</em><sub><em>B</em></sub> be 

<math display="inline" id="Tautology_(logic):31">
 <semantics>
  <mrow>
   <mi>C</mi>
   <mo>→</mo>
   <mi>E</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>C</ci>
    <ci>E</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C\to E
  </annotation>
 </semantics>
</math>

. It follows from the substitution rule that the sentence</p>

<p>

<math display="block" id="Tautology_(logic):32">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>C</mi>
     <mo>∨</mo>
     <mi>D</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∧</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>C</mi>
     <mo>→</mo>
     <mi>E</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∨</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi mathvariant="normal">¬</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>C</mi>
     <mo>∨</mo>
     <mi>D</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∨</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi mathvariant="normal">¬</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>C</mi>
     <mo>→</mo>
     <mi>E</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">C</csymbol>
      <or></or>
      <csymbol cd="unknown">D</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <and></and>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">C</csymbol>
      <ci>normal-→</ci>
      <csymbol cd="unknown">E</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <or></or>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <not></not>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">C</csymbol>
      <or></or>
      <csymbol cd="unknown">D</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <or></or>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <not></not>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">C</csymbol>
      <ci>normal-→</ci>
      <csymbol cd="unknown">E</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ((C\lor D)\land(C\to E))\lor(\lnot(C\lor D))\lor(\lnot(C\to E))
  </annotation>
 </semantics>
</math>

 is a tautology. In turn, a tautology may be substituted for the truth value "<a href="Logical_truth" title="wikilink">true</a>": for instance, when "true" is symbolized by "1", a tautology may be substituted for "1".</p>
<h2 id="efficient-verification-and-the-boolean-satisfiability-problem">Efficient verification and the Boolean satisfiability problem</h2>

<p>The problem of constructing practical algorithms to determine whether sentences with large numbers of propositional variables are tautologies is an area of contemporary research in the area of <a href="automated_theorem_proving" title="wikilink">automated theorem proving</a>.</p>

<p>The method of <a href="truth_tables" title="wikilink">truth tables</a> illustrated above is provably correct – the truth table for a tautology will end in a column with only <em>T</em>, while the truth table for a sentence that is not a tautology will contain a row whose final column is <em>F</em>, and the valuation corresponding to that row is a valuation that does not satisfy the sentence being tested. This method for verifying tautologies is an <a href="effective_procedure" title="wikilink">effective procedure</a>, which means that given unlimited computational resources it can always be used to mechanistically determine whether a sentence is a tautology. This means, in particular, the set of tautologies over a fixed finite or countable alphabet is a <a href="decidable_set" title="wikilink">decidable set</a>.</p>

<p>As an <a href="efficient_procedure" title="wikilink">efficient procedure</a>, however, truth tables are constrained by the fact that the number of valuations that must be checked increases as 2<sup><em>k</em></sup>, where <em>k</em> is the number of variables in the formula. This exponential growth in the computation length renders the truth table method useless for formulas with thousands of propositional variables, as contemporary computing hardware cannot execute the algorithm in a feasible time period.</p>

<p>The problem of determining whether there is any valuation that makes a formula true is the <strong><a href="Boolean_satisfiability_problem" title="wikilink">Boolean satisfiability problem</a></strong>; the problem of checking tautologies is equivalent to this problem, because verifying that a sentence <em>S</em> is a tautology is equivalent to verifying that there is no valuation satisfying 

<math display="inline" id="Tautology_(logic):33">
 <semantics>
  <mrow>
   <mi mathvariant="normal">¬</mi>
   <mi>S</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <not></not>
    <ci>S</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lnot S
  </annotation>
 </semantics>
</math>


. It is known that the Boolean satisfiability problem is <a href="NP_complete" title="wikilink">NP complete</a>, and widely believed that there is no <a href="polynomial-time_algorithm" title="wikilink">polynomial-time algorithm</a> that can perform it. Current research focuses on finding algorithms that perform well on special classes of formulas, or terminate quickly on average even though some inputs may cause them to take much longer.</p>
<h2 id="tautologies-versus-validities-in-first-order-logic">Tautologies versus validities in first-order logic</h2>

<p>The fundamental definition of a tautology is in the context of propositional logic. The definition can be extended, however, to sentences in <a href="first-order_logic" title="wikilink">first-order logic</a> (see Enderton (2002, p. 114) and Kleene (1967 secs. 17–18)). These sentences may contain quantifiers, unlike sentences of propositional logic. In the context of first-order logic, a distinction is maintained between <strong>logical validities</strong>, sentences that are true in every model, and <strong>tautologies</strong>, which are a proper subset of the first-order logical validities. In the context of propositional logic, these two terms coincide.</p>

<p>A tautology in first-order logic is a sentence that can be obtained by taking a tautology of propositional logic and uniformly replacing each propositional variable by a first-order formula (one formula per propositional variable). For example, because 

<math display="inline" id="Tautology_(logic):34">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>∨</mo>
   <mrow>
    <mi mathvariant="normal">¬</mi>
    <mi>A</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <or></or>
    <ci>A</ci>
    <apply>
     <times></times>
     <not></not>
     <ci>A</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\lor\lnot A
  </annotation>
 </semantics>
</math>

 is a tautology of propositional logic, 

<math display="inline" id="Tautology_(logic):35">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>∀</mo>
    <mi>x</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>=</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∨</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi mathvariant="normal">¬</mi>
    <mo>∀</mo>
    <mi>x</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>=</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="latexml">for-all</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <eq></eq>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <or></or>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <not></not>
     <csymbol cd="latexml">for-all</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <eq></eq>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\forall x(x=x))\lor(\lnot\forall x(x=x))
  </annotation>
 </semantics>
</math>

 is a tautology in first order logic. Similarly, in a first-order language with a unary relation symbols <em>R</em>,<em>S</em>,<em>T</em>, the following sentence is a tautology:</p>

<p>

<math display="block" id="Tautology_(logic):36">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mo>∃</mo>
      <mi>x</mi>
      <mi>R</mi>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>∧</mo>
     <mi mathvariant="normal">¬</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mo>∃</mo>
      <mi>x</mi>
      <mi>S</mi>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>→</mo>
    <mo>∀</mo>
    <mi>x</mi>
    <mi>T</mi>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>⇔</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mo>∃</mo>
     <mi>x</mi>
     <mi>R</mi>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>→</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi mathvariant="normal">¬</mi>
      <mo>∃</mo>
      <mi>x</mi>
      <mi>S</mi>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>→</mo>
     <mo>∀</mo>
     <mi>x</mi>
     <mi>T</mi>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <exists></exists>
       <csymbol cd="unknown">x</csymbol>
       <csymbol cd="unknown">R</csymbol>
       <csymbol cd="unknown">x</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <and></and>
      <not></not>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <exists></exists>
       <csymbol cd="unknown">x</csymbol>
       <csymbol cd="unknown">S</csymbol>
       <csymbol cd="unknown">x</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-→</ci>
     <csymbol cd="latexml">for-all</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="unknown">T</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-⇔</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <exists></exists>
      <csymbol cd="unknown">x</csymbol>
      <csymbol cd="unknown">R</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-→</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <not></not>
       <exists></exists>
       <csymbol cd="unknown">x</csymbol>
       <csymbol cd="unknown">S</csymbol>
       <csymbol cd="unknown">x</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-→</ci>
      <csymbol cd="latexml">for-all</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <csymbol cd="unknown">T</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-.</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (((\exists xRx)\land\lnot(\exists xSx))\to\forall xTx)\Leftrightarrow((\exists
xRx%
)\to((\lnot\exists xSx)\to\forall xTx)).
  </annotation>
 </semantics>
</math>

 It is obtained by replacing 

<math display="inline" id="Tautology_(logic):37">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 with 

<math display="inline" id="Tautology_(logic):38">
 <semantics>
  <mrow>
   <mo>∃</mo>
   <mrow>
    <mi>x</mi>
    <mi>R</mi>
    <mi>x</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <exists></exists>
    <apply>
     <times></times>
     <ci>x</ci>
     <ci>R</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \exists xRx
  </annotation>
 </semantics>
</math>


, 

<math display="inline" id="Tautology_(logic):39">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

 with 

<math display="inline" id="Tautology_(logic):40">
 <semantics>
  <mrow>
   <mi mathvariant="normal">¬</mi>
   <mrow>
    <mo>∃</mo>
    <mrow>
     <mi>x</mi>
     <mi>S</mi>
     <mi>x</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <not></not>
    <apply>
     <exists></exists>
     <apply>
      <times></times>
      <ci>x</ci>
      <ci>S</ci>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lnot\exists xSx
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="Tautology_(logic):41">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

 with 

<math display="inline" id="Tautology_(logic):42">
 <semantics>
  <mrow>
   <mo>∀</mo>
   <mrow>
    <mi>x</mi>
    <mi>T</mi>
    <mi>x</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">for-all</csymbol>
    <apply>
     <times></times>
     <ci>x</ci>
     <ci>T</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall xTx
  </annotation>
 </semantics>
</math>

 in the propositional tautology 

<math display="inline" id="Tautology_(logic):43">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>A</mi>
     <mo>∧</mo>
     <mi>B</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>→</mo>
    <mi>C</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>⇔</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>A</mi>
    <mo>→</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>B</mi>
     <mo>→</mo>
     <mi>C</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">A</csymbol>
      <and></and>
      <csymbol cd="unknown">B</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-→</ci>
     <csymbol cd="unknown">C</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-⇔</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">A</csymbol>
     <ci>normal-→</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">B</csymbol>
      <ci>normal-→</ci>
      <csymbol cd="unknown">C</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ((A\land B)\to C)\Leftrightarrow(A\to(B\to C))
  </annotation>
 </semantics>
</math>


.</p>

<p>Not all logical validities are tautologies in first-order logic. For example, the sentence</p>

<p>

<math display="block" id="Tautology_(logic):44">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo>∀</mo>
     <mrow>
      <mi>x</mi>
      <mi>R</mi>
      <mi>x</mi>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mi mathvariant="normal">¬</mi>
    <mrow>
     <mo>∃</mo>
     <mrow>
      <mi>x</mi>
      <mi mathvariant="normal">¬</mi>
      <mi>R</mi>
      <mi>x</mi>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <csymbol cd="latexml">for-all</csymbol>
     <apply>
      <times></times>
      <ci>x</ci>
      <ci>R</ci>
      <ci>x</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <not></not>
     <apply>
      <exists></exists>
      <apply>
       <times></times>
       <ci>x</ci>
       <not></not>
       <ci>R</ci>
       <ci>x</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\forall xRx)\to\lnot\exists x\lnot Rx
  </annotation>
 </semantics>
</math>

 is true in any first-order interpretation, but it corresponds to the propositional sentence 

<math display="inline" id="Tautology_(logic):45">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>→</mo>
   <mi>B</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>A</ci>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\to B
  </annotation>
 </semantics>
</math>

 which is not a tautology of propositional logic.</p>
<h2 id="see-also">See also</h2>
<h3 id="normal-forms">Normal forms</h3>
<ul>
<li><a href="Algebraic_normal_form" title="wikilink">Algebraic normal form</a></li>
<li><a href="Conjunctive_normal_form" title="wikilink">Conjunctive normal form</a></li>
<li><a href="Disjunctive_normal_form" title="wikilink">Disjunctive normal form</a></li>
<li><a href="Logic_optimization" title="wikilink">Logic optimization</a></li>
</ul>
<h3 id="related-logical-topics">Related logical topics</h3>
<ul>
<li><a href="Boolean_algebra" title="wikilink">Boolean algebra</a></li>
<li><a href="Boolean_domain" title="wikilink">Boolean domain</a></li>
<li><a href="Boolean_function" title="wikilink">Boolean function</a></li>
<li><a class="uri" href="Contradiction" title="wikilink">Contradiction</a></li>
<li><a href="False_(logic)" title="wikilink">False (logic)</a></li>
<li><a href="List_of_logic_symbols" title="wikilink">List of logic symbols</a></li>
</ul>
<ul>
<li><a href="Logic_synthesis" title="wikilink">Logic synthesis</a></li>
<li><a href="Logical_consequence" title="wikilink">Logical consequence</a></li>
<li><a href="Logical_graph" title="wikilink">Logical graph</a></li>
<li><a href="Logical_truth" title="wikilink">Logical truth</a></li>
<li><a href="Vacuous_truth" title="wikilink">Vacuous truth</a></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li><a href="Józef_Maria_Bocheński" title="wikilink">Bocheński, J. M.</a> (1959) <em>Précis of Mathematical Logic</em>, translated from the French and German editions by Otto Bird, <a class="uri" href="Dordrecht" title="wikilink">Dordrecht</a>, <a href="South_Holland" title="wikilink">South Holland</a>: <a href="D._Reidel" title="wikilink">D. Reidel</a>.</li>
<li><a href="Herbert_Enderton" title="wikilink">Enderton, H. B.</a> (2002) <em>A Mathematical Introduction to Logic</em>, <a href="Harcourt_(publisher)" title="wikilink">Harcourt</a>/<a href="Academic_Press" title="wikilink">Academic Press</a>, ISBN 0-12-238452-0.</li>
<li><a href="Stephen_Kleene" title="wikilink">Kleene, S. C.</a> (1967) <em>Mathematical Logic</em>, reprinted 2002, <a href="Dover_Publications" title="wikilink">Dover Publications</a>, ISBN 0-486-42533-9.</li>
<li><a href="Hans_Reichenbach" title="wikilink">Reichenbach, H.</a> (1947). <em>Elements of Symbolic Logic</em>, reprinted 1980, Dover, ISBN 0-486-24004-5</li>
<li><a href="Ludwig_Wittgenstein" title="wikilink">Wittgenstein, L.</a> (1921). "Logisch-philosophiche Abhandlung", <em>Annalen der Naturphilosophie</em> (Leipzig), v. 14, pp. 185–262, reprinted in English translation as <em>Tractatus logico-philosophicus</em>, <a href="New_York" title="wikilink">New York</a> and <a class="uri" href="London" title="wikilink">London</a>, 1922.</li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li></li>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Logical_expressions" title="wikilink">Category:Logical expressions</a> <a href="Category:Logical_truth" title="wikilink">Category:Logical truth</a> <a href="Category:Mathematical_logic" title="wikilink">Category:Mathematical logic</a> <a href="Category:Propositional_calculus" title="wikilink">Category:Propositional calculus</a> <a class="uri" href="Category:Propositions" title="wikilink">Category:Propositions</a> <a class="uri" href="Category:Semantics" title="wikilink">Category:Semantics</a> <a href="Category:Sentences_by_type" title="wikilink">Category:Sentences by type</a></p>
</body>
</html>
