<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="396">Lambda lifting</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Lambda lifting</h1>
<style>
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
<style>
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
</body></html>
<body>
<hr/>

<p>'''Lambda lifting '''is a <a href="Metaprogramming" title="wikilink">meta-process</a> that restructures a <a href="computer_program" title="wikilink">computer program</a> so that functions are defined independently of each other in a global <a href="Scope_(computer_science)" title="wikilink">scope</a>. An individual "lift" transforms a local <a href="subroutine" title="wikilink">function</a> into a global function. It is a two step process, consisting of;</p>
<ul>
<li>Eliminating <a href="free_variables" title="wikilink">free variables</a> in the function by adding parameters.</li>
<li>Moving functions from a restricted scope to broader or global scope.</li>
</ul>

<p>Lambda lifting was historically considered as a mechanism for implementing <a href="functional_programming_language" title="wikilink">functional programming languages</a>. Lambda lifting is used in conjunction with other techniques in some modern <a href="compiler" title="wikilink">compilers</a>.</p>

<p>The term "lambda lifting" was first introduced by <a href="Thomas_Johnsson" title="wikilink">Thomas Johnsson</a> around 1982.</p>

<p>Lambda lifting is not the same as <a href="closure_conversion" title="wikilink">closure conversion</a>. Lambda lifting requires all <a href="call_site" title="wikilink">call sites</a> to be adjusted (adding extra arguments to calls) and does not introduce a <a href="closure_(computer_science)" title="wikilink">closure</a> for the lifted lambda expression. In contrast, closure conversion does not require call sites to be adjusted but does introduce a closure for the lambda expression mapping free variables to values.</p>

<p>Lambda lifts may be used on individual functions, in <a href="code_refactoring" title="wikilink">code refactoring</a>, to make a function usable outside the scope in which it was written. Lambda lifts may also be repeated, in order to transform the program. Repeated lambda lifts may be used to convert a program written in <a href="lambda_calculus" title="wikilink">lambda calculus</a> into a set of <a href="Recursion_(computer_science)" title="wikilink">recursive functions</a>, without lambdas. This demonstrates the equivalence of programs written in lambda calculus and programs written as functions.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> However it does not demonstrate the soundness of lambda calculus for deduction, as the <a href="Lambda_calculus#Reduction" title="wikilink">eta reduction</a> used in lambda lifting is the step that introduces <a href="Deductive_lambda_calculus#Logical_inconsistency" title="wikilink">cardinality problems</a> into the lambda calculus, because it removes the value from the variable, without first checking that there is only one value that satisfies the conditions on the variable (see <a href="Curry's_paradox#No_resolution_in_Lambda_Calculus" title="wikilink">Curry's paradox</a>).</p>

<p>Lambda lifting is expensive on processing time for the compiler. An efficient implementation of lambda lifting is 

<math display="inline" id="Lambda_lifting:0">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>n</mi>
     <mn>2</mn>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>n</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n^{2})
  </annotation>
 </semantics>
</math>

 on processing time for the compiler.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>

<p>In the <a href="Lambda_calculus" title="wikilink">untyped lambda calculus</a>, where the basic types are functions, lifting may change the result of beta reduction of a lambda expression. The resulting functions will have the same meaning, in a mathematical sense, but are not regarded as the same function in the untyped lambda calculus. See also <a href="Deductive_lambda_calculus#Intensional_versus_extensional_equality" title="wikilink">intensional versus extensional equality</a>.</p>

<p>The reverse operation to lambda lifting is <a href="#Lambda_dropping" title="wikilink">lambda dropping</a>.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>

<p>Lambda dropping may make the compilation of programs quicker for the compiler, and may also increase the efficiency of the resulting program, by reducing the number of parameters, and reducing the size of stack frames.</p>

<p>However lambda dropping makes a function harder to re-use. A dropped function is tied to its context, and can only be used in a different context if it is first lifted.</p>
<h2 id="algorithm">Algorithm</h2>

<p>The following algorithm is one way to lambda-lift an arbitrary program in a language which doesn't support closures as <a href="first-class_object" title="wikilink">first-class objects</a>:</p>
<ol>
<li>Rename the functions so that each function has a unique name.</li>
<li>Replace each free variable with an additional argument to the enclosing function, and pass that argument to every use of the function.</li>
<li>Replace every local function definition that has no free variables with an identical global function.</li>
<li>Repeat steps 2 and 3 until all free variables and local functions are eliminated.</li>
</ol>

<p>If the language has closures as first-class objects that can be passed as arguments or returned from other functions, the closure will need to be represented by a data structure that captures the bindings of the free variables.</p>
<h2 id="example">Example</h2>

<p>The following <a class="uri" href="OCaml" title="wikilink">OCaml</a> program computes the sum of the integers from 1 to 100:</p>
<div class="sourceCode"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="kw">let</span> <span class="kw">rec</span> sum n =
  <span class="kw">if</span> n = <span class="dv">1</span> <span class="kw">then</span>
    <span class="dv">1</span>
  <span class="kw">else</span>
    <span class="kw">let</span> f x =
      n + x <span class="kw">in</span>
    f (sum (n - <span class="dv">1</span>)) <span class="kw">in</span>
sum <span class="dv">100</span></code></pre></div>

<p>(The <code>let rec</code> declares <code>sum</code> as a function that may call itself.) The function f, which adds sum's argument to the sum of the numbers less than the argument, is a local function. Within the definition of f, n is a free variable. Start by converting the free variable to an argument:</p>
<div class="sourceCode"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="kw">let</span> <span class="kw">rec</span> sum n =
  <span class="kw">if</span> n = <span class="dv">1</span> <span class="kw">then</span>
    <span class="dv">1</span>
  <span class="kw">else</span>
    <span class="kw">let</span> f w x =
      w + x <span class="kw">in</span>
     f n (sum (n - <span class="dv">1</span>)) <span class="kw">in</span>
sum <span class="dv">100</span></code></pre></div>

<p>Next, lift f into a global function:</p>
<div class="sourceCode"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="kw">let</span> <span class="kw">rec</span> f w x =
  w + x
<span class="kw">and</span> sum n =
  <span class="kw">if</span> n = <span class="dv">1</span> <span class="kw">then</span>
    <span class="dv">1</span>
  <span class="kw">else</span>
    f n (sum (n - <span class="dv">1</span>)) <span class="kw">in</span>
sum <span class="dv">100</span> </code></pre></div>

<p>The following is the same example, this time written in <a class="uri" href="JavaScript" title="wikilink">JavaScript</a>:</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="co">// Initial version</span>

<span class="kw">function</span> <span class="at">sum</span>(n) <span class="op">{</span>
    <span class="kw">function</span> <span class="at">f</span>(x) <span class="op">{</span>
        <span class="cf">return</span> n <span class="op">+</span> x<span class="op">;</span>
    <span class="op">}</span>

    <span class="cf">if</span> (n <span class="op">==</span> <span class="dv">1</span>)
        <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span>
    <span class="cf">else</span>
        <span class="cf">return</span> <span class="at">f</span>(<span class="at">sum</span>(n <span class="op">-</span> <span class="dv">1</span>))<span class="op">;</span>
<span class="op">}</span>

<span class="co">// After converting the free variable n to a formal parameter w</span>

<span class="kw">function</span> <span class="at">sum</span>(n) <span class="op">{</span>
    <span class="kw">function</span> <span class="at">f</span>(w<span class="op">,</span> x) <span class="op">{</span>
        <span class="cf">return</span> w <span class="op">+</span> x<span class="op">;</span>
    <span class="op">}</span>

    <span class="cf">if</span> (n <span class="op">==</span> <span class="dv">1</span>)
        <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span>
    <span class="cf">else</span>
        <span class="cf">return</span> <span class="at">f</span>(n<span class="op">,</span> <span class="at">sum</span>(n <span class="op">-</span> <span class="dv">1</span>))<span class="op">;</span>
<span class="op">}</span>

<span class="co">// After lifting function f into the global scope</span>

<span class="kw">function</span> <span class="at">f</span>(w<span class="op">,</span> x) <span class="op">{</span>
    <span class="cf">return</span> w <span class="op">+</span> x<span class="op">;</span>
<span class="op">}</span>

<span class="kw">function</span> <span class="at">sum</span>(n) <span class="op">{</span>
    <span class="cf">if</span> (n <span class="op">==</span> <span class="dv">1</span>)
        <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span>
    <span class="cf">else</span>
        <span class="cf">return</span> <span class="at">f</span>(n<span class="op">,</span> <span class="at">sum</span>(n <span class="op">-</span> <span class="dv">1</span>))<span class="op">;</span>
<span class="op">}</span></code></pre></div>
<h2 id="lambda-lifting-versus-closures">Lambda lifting versus closures</h2>

<p>Lambda lifting and <a href="Closure_(computer_programming)" title="wikilink">closure</a> are both methods for implementing <a href="Block_(programming)" title="wikilink">block structured</a> programs. Lambda lifting implements block structure by eliminating it. All functions are lifted to the global level. Closure conversion provides a "closure" which links the current frame to other frames. Closure conversion takes less compile time.</p>

<p>Recursive functions, and block structured programs, with or without lifting, may be implemented using a <a href="Call_stack" title="wikilink">stack</a> based implementation, which is simple and efficient. However a stack frame based implementation must be <a href="Eager_evaluation" title="wikilink">strict (eager)</a>. The stack frame based implementation requires that the life of functions be <a href="fIFO_(computing_and_electronics)" title="wikilink">first-in, first-out</a> (FIFO). That is, the most recent function to start its calculation must be the first to end.</p>

<p>Some functional languages (such as <a href="Haskell_(programming_language)" title="wikilink">Haskell</a>) are implemented using <a href="lazy_evaluation" title="wikilink">lazy evaluation</a>, which delays calculation until the value is needed. The lazy implementation strategy gives flexibility to the programmer. Lazy evaluation requires delaying the call to a function until a request is made to the value calculated by the function. One implementation is to record a reference to a "frame" of data describing the calculation, in place of the value. Later when the value is required, the frame is used to calculate the value, just in time for when it is needed. The calculated value then replaces the reference.</p>

<p>The "frame" is similar to a <a href="stack_frame" title="wikilink">stack frame</a>, the difference being that it is not stored on the stack. Lazy evaluation requires that all the data required for the calculation be saved in the frame. If the function is "lifted", then the frame needs only record the function pointer, and the parameters to the function. Modern languages use <a href="Garbage_collection_(computer_science)" title="wikilink">garbage collection</a> in place of stack based allocation to manage the life of variables. In a managed, garbage collected environment, a <a href="Closure_(computer_science)" title="wikilink">closure</a> records references to the frames from which values may be obtained. In contrast a lifted function has parameters for each value needed in the calculation.</p>
<h2 id="let-expressions-and-lambda-calculus">Let expressions and lambda calculus</h2>

<p>The <a href="Let_expression" title="wikilink">Let expression</a>, is useful in describing lifting and dropping, and in describing the relationship between recursive equations and lambda expressions. Most functional languages have let expressions. Also block structured programming languages like <a class="uri" href="ALGOL" title="wikilink">ALGOL</a> and <a href="Pascal_(programming_language)" title="wikilink">Pascal</a> are similar in that they to allow the local definition of a function, for use in a restricted <a href="Scope_(computer_science)" title="wikilink">scope</a>.</p>

<p>The <em>let</em> expression used here is a fully mutually recursive version of <em>let rec</em>, as implemented in many functional languages.</p>

<p>Let expressions are related to <a href="Lambda_calculus" title="wikilink">Lambda calculus</a>. Lambda calculus has a simple syntax and semantics, and is good for describing Lambda lifting. It is convenient to describe lambda lifting as a translations from <em>lambda</em> to a <em>let</em> expression, and lambda dropping as the reverse. This is because <em>let</em> expressions allow mutual recursion, which is in a sense, more lifted than is supported in lambda calculus. Lambda calculus does not support mutual recursion and only one function may be defined at the outermost global scope.</p>

<p><a href="Let_expression#Rules_for_conversion_between_lambda_calculus_and_let_expressions" title="wikilink">Conversion rules</a> which describe translation without lifting are given in the <a href="Let_expression" title="wikilink">Let expression</a> article.</p>

<p>The following rules describe the equivalence of lambda and let expressions,</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>Name</p></th>
<th style="text-align: left;">
<p>Law</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>Eta-reduction equivalence</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Lambda_lifting:1">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mpadded width="+5pt">
      <mi>f</mi>
     </mpadded>
     <mi>x</mi>
    </mrow>
    <mo>=</mo>
    <mi>y</mi>
    <mo>≡</mo>
    <mi>f</mi>
    <mo>=</mo>
    <mrow>
     <mi>λ</mi>
     <mi>x</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <and></and>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <ci>f</ci>
       <ci>x</ci>
      </apply>
      <ci>y</ci>
     </apply>
     <apply>
      <equivalent></equivalent>
      <share href="#.cmml">
      </share>
      <ci>f</ci>
     </apply>
     <apply>
      <eq></eq>
      <share href="#.cmml">
      </share>
      <apply>
       <times></times>
       <ci>λ</ci>
       <ci>x</ci>
      </apply>
     </apply>
    </apply>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f\ x=y\equiv f=\lambda x.y
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Let-Lambda equivalence</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Lambda_lifting:2">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mo>∉</mo>
   <mi>F</mi>
   <mi>V</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>E</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>let</mo>
    <mi>f</mi>
    <mo>:</mo>
    <mi>f</mi>
    <mo>=</mo>
    <mi>E</mi>
    <mo>in</mo>
    <mi>L</mi>
    <mo>≡</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mi>f</mi>
     <mo>.</mo>
     <mi>L</mi>
     <mo rspace="7.5pt" stretchy="false">)</mo>
    </mrow>
    <mi>E</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">f</csymbol>
    <notin></notin>
    <csymbol cd="unknown">F</csymbol>
    <csymbol cd="unknown">V</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">E</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <ci>let</ci>
     <csymbol cd="unknown">f</csymbol>
     <ci>normal-:</ci>
     <csymbol cd="unknown">f</csymbol>
     <eq></eq>
     <csymbol cd="unknown">E</csymbol>
     <ci>in</ci>
     <csymbol cd="unknown">L</csymbol>
     <equivalent></equivalent>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">f</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">L</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <csymbol cd="unknown">E</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f\not\in FV(E)\to(\operatorname{let}f:f=E\operatorname{in}L\equiv(\lambda f.L)%
\ E)
  </annotation>
 </semantics>
</math>

 (where f is a variable name).</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>Let combination</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Lambda_lifting:3">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>∉</mo>
   <mi>F</mi>
   <mi>V</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>E</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>let</mo>
    <mi>v</mi>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mi>w</mi>
    <mo>,</mo>
    <mi>x</mi>
    <mo>:</mo>
    <mi>E</mi>
    <mi mathvariant="italic">and</mi>
    <mi>F</mi>
    <mo>in</mo>
    <mi>L</mi>
    <mo>≡</mo>
    <mo>let</mo>
    <mi>v</mi>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mi>w</mi>
    <mo>:</mo>
    <mi>E</mi>
    <mo>in</mo>
    <mo>let</mo>
    <mi>x</mi>
    <mo>:</mo>
    <mi>F</mi>
    <mo>in</mo>
    <mi>L</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <notin></notin>
    <csymbol cd="unknown">F</csymbol>
    <csymbol cd="unknown">V</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">E</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <ci>let</ci>
     <csymbol cd="unknown">v</csymbol>
     <ci>normal-,</ci>
     <ci>normal-…</ci>
     <ci>normal-,</ci>
     <csymbol cd="unknown">w</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-:</ci>
     <csymbol cd="unknown">E</csymbol>
     <csymbol cd="unknown">and</csymbol>
     <csymbol cd="unknown">F</csymbol>
     <ci>in</ci>
     <csymbol cd="unknown">L</csymbol>
     <equivalent></equivalent>
     <ci>let</ci>
     <csymbol cd="unknown">v</csymbol>
     <ci>normal-,</ci>
     <ci>normal-…</ci>
     <ci>normal-,</ci>
     <csymbol cd="unknown">w</csymbol>
     <ci>normal-:</ci>
     <csymbol cd="unknown">E</csymbol>
     <ci>in</ci>
     <ci>let</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-:</ci>
     <csymbol cd="unknown">F</csymbol>
     <ci>in</ci>
     <csymbol cd="unknown">L</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\not\in FV(E)\to(\operatorname{let}v,...,w,x:E\and F\operatorname{in}L\equiv%
\operatorname{let}v,...,w:E\operatorname{in}\operatorname{let}x:F\operatorname%
{in}L)
  </annotation>
 </semantics>
</math>


</p></td>
</tr>
</tbody>
</table>

<p>Meta-functions will be given that describe lambda lifting and dropping. A meta-function is a function that takes a program as a parameter. The program is data for the meta-program. The program and the meta program are at different meta-levels.</p>

<p>The following conventions will be used to distinguish program from the meta program,</p>
<ul>
<li>Square brackets [] will be used to represent function application in the meta program.</li>
<li>Capital letters will be used for variables in the meta program. Lower case letters represent variables in the program.</li>
<li>

<math display="inline" id="Lambda_lifting:4">
 <semantics>
  <mo>≡</mo>
  <annotation-xml encoding="MathML-Content">
   <equivalent></equivalent>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \equiv
  </annotation>
 </semantics>
</math>

 will be used for equals in the meta program.</li>
<li>

<math display="inline" id="Lambda_lifting:5">
 <semantics>
  <mi mathvariant="normal">_</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-_</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \_
  </annotation>
 </semantics>
</math>

 represents a dummy variable, or an unknown value.</li>
</ul>

<p>For simplicity the first rule given that matches will be applied. The rules also assume that the lambda expressions have been pre-processed so that each lambda abstraction has a unique name.</p>

<p>The substitution operator is used extensively. The expression 

<math display="inline" id="Lambda_lifting:6">
 <semantics>
  <mrow>
   <mi>L</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>G</mi>
    <mo>:=</mo>
    <mi>S</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">L</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">G</csymbol>
     <csymbol cd="latexml">assign</csymbol>
     <csymbol cd="unknown">S</csymbol>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L[G:=S]
  </annotation>
 </semantics>
</math>

 means substitute every occurrence of <em>G</em> in <em>L</em> by <em>S</em> and return the expression. The definition used is extended to cover the substitution of expressions, from the definition given on the <a href="Lambda_calculus" title="wikilink">Lambda calculus</a> page. The matching of expressions should compare expressions for alpha equivalence (renaming of variables).</p>
<h2 id="lambda-lifting-in-lambda-calculus">Lambda lifting in lambda calculus</h2>

<p>Each lambda lift takes a lambda abstraction which is a sub expression of a lambda expression and replaces it by a function call (application) to a function that it creates. The free variables in the sub expression are the parameters to the function call.</p>

<p>Lambda lifts may be used on individual functions, in <a href="code_refactoring" title="wikilink">code refactoring</a>, to make a function usable outside the scope in which it was written. Lambda lifts may also be repeated, until the expression has no lambda abstractions, in order to transform the program.</p>
<h3 id="lambda-lift">Lambda lift</h3>

<p>A lift is given a sub-expression within an expression to lift to the top of that expression. The expression may be part of a larger program. This allows control of where the sub-expression is lifted to. The lambda lift operation used to perform a lift within a program is,</p>

<p>

<math display="block" id="Lambda_lifting:7">
 <semantics>
  <mrow>
   <mrow>
    <mi>lambda</mi>
    <mo>-</mo>
    <mi>lift</mi>
    <mo>-</mo>
    <mi>op</mi>
   </mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>S</mi>
    <mo>,</mo>
    <mi>L</mi>
    <mo>,</mo>
    <mi>P</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>=</mo>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>L</mi>
    <mo>:=</mo>
    <mrow>
     <mi>lambda</mi>
     <mo>-</mo>
     <mi>lift</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>S</mi>
     <mo>,</mo>
     <mi>L</mi>
     <mo stretchy="false">]</mo>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <minus></minus>
     <ci>lambda</ci>
     <ci>lift</ci>
     <ci>op</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">S</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">L</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">P</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">L</csymbol>
     <csymbol cd="latexml">assign</csymbol>
     <apply>
      <minus></minus>
      <ci>lambda</ci>
      <ci>lift</ci>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-[</ci>
      <csymbol cd="unknown">S</csymbol>
      <ci>normal-,</ci>
      <csymbol cd="unknown">L</csymbol>
      <ci>normal-]</ci>
     </cerror>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{lambda-lift-op}[S,L,P]=P[L:=\operatorname{lambda-lift}[S,L]]
  </annotation>
 </semantics>
</math>

</p>

<p>The sub expression may be either a lambda abstraction, or a lambda abstraction applied to a parameter.</p>

<p>Two types of lift are possible.</p>
<ul>
<li><a href="#Anonymous_lift" title="wikilink">Anonymous lift</a></li>
<li><a href="#Named_lift" title="wikilink">Named lift</a></li>
</ul>

<p>An anonymous lift has a lift expression which is a lambda abstraction only. It is regarded as defining an anonymous function. A name must be created for the function.</p>

<p>A named lift expression has a lambda abstraction applied to an expression. This lift is regarded as a named definition of a function.</p>
<h4 id="anonymous-lift">Anonymous Lift</h4>

<p>An anonymous lift takes a lambda abstraction (called <em>S</em>). For <em>S</em>;</p>
<ul>
<li>Create a name for the function that will replace <em>S</em> (called <em>V</em>). Make sure that the name identified by <em>V</em> has not been used.</li>
<li>Add parameters to <em>V</em>, for all the free variables in <em>S</em>, to create an expression <em>G</em> (see <em>make-call</em>).</li>
</ul>

<p>The lambda lift is the substitution of the lambda abstraction <em>S</em> for a function application, along with the addition of a definition for the function.</p>

<p>

<math display="block" id="Lambda_lifting:8">
 <semantics>
  <mrow>
   <mrow>
    <mi>lambda</mi>
    <mo>-</mo>
    <mi>lift</mi>
   </mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>S</mi>
    <mo>,</mo>
    <mi>L</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>≡</mo>
   <mo>let</mo>
   <mi>V</mi>
   <mo>:</mo>
   <mrow>
    <mi>de</mi>
    <mo>-</mo>
    <mi>lambda</mi>
   </mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>G</mi>
    <mo>=</mo>
    <mi>S</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>in</mo>
   <mi>L</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>S</mi>
    <mo>:=</mo>
    <mi>G</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <minus></minus>
     <ci>lambda</ci>
     <ci>lift</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">S</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">L</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <equivalent></equivalent>
    <ci>let</ci>
    <csymbol cd="unknown">V</csymbol>
    <ci>normal-:</ci>
    <apply>
     <minus></minus>
     <ci>de</ci>
     <ci>lambda</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">G</csymbol>
     <eq></eq>
     <csymbol cd="unknown">S</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <ci>in</ci>
    <csymbol cd="unknown">L</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">S</csymbol>
     <csymbol cd="latexml">assign</csymbol>
     <csymbol cd="unknown">G</csymbol>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{lambda-lift}[S,L]\equiv\operatorname{let}V:\operatorname{de-%
lambda}[G=S]\operatorname{in}L[S:=G]
  </annotation>
 </semantics>
</math>

</p>

<p>The new lambda expression has <em>S</em> substituted for G. Note that <em>L[S:=G]</em> means substitution of <em>S</em> for <em>G</em> in <em>L</em>. The function definitions has the function definition <em>G = S</em> added.</p>

<p>In the above rule <em>G</em> is the function application that is substituted for the expression <em>S</em>. It is defined by,</p>

<p>

<math display="block" id="Lambda_lifting:9">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>make</mi>
     <mo>-</mo>
     <mi>call</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>V</mi>
     <mo>,</mo>
     <mrow>
      <mo>FV</mo>
      <mrow>
       <mo stretchy="false">[</mo>
       <mi>S</mi>
       <mo stretchy="false">]</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>G</ci>
    <apply>
     <apply>
      <minus></minus>
      <ci>make</ci>
      <ci>call</ci>
     </apply>
     <ci>V</ci>
     <apply>
      <ci>FV</ci>
      <ci>S</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G=\operatorname{make-call}[V,\operatorname{FV}[S]]
  </annotation>
 </semantics>
</math>

</p>

<p>where <em>V</em> is the function name. It must be a new variable, i.e. a name not already used in the lambda expression,</p>

<p>

<math display="block" id="Lambda_lifting:10">
 <semantics>
  <mrow>
   <mi>V</mi>
   <mo>∉</mo>
   <mrow>
    <mo>vars</mo>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mrow>
       <mo>let</mo>
       <mi>F</mi>
      </mrow>
      <mrow>
       <mo>in</mo>
       <mi>L</mi>
      </mrow>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <notin></notin>
    <ci>V</ci>
    <apply>
     <ci>vars</ci>
     <apply>
      <times></times>
      <apply>
       <ci>let</ci>
       <ci>F</ci>
      </apply>
      <apply>
       <ci>in</ci>
       <ci>L</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V\not\in\operatorname{vars}[\operatorname{let}F\operatorname{in}L]
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Lambda_lifting:11">
 <semantics>
  <mrow>
   <mo>vars</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>E</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>vars</ci>
    <ci>E</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{vars}[E]
  </annotation>
 </semantics>
</math>

 is a meta function that returns the set of variables used in <em>E</em>.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>Example for anonymous lift.</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>For example,</p>

<p>

<math display="block" id="Lambda_lifting:12">
 <semantics>
  <mrow>
   <mi>F</mi>
   <mo>=</mo>
   <mrow>
    <mi>t</mi>
    <mi>r</mi>
    <mi>u</mi>
    <mi>e</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>F</ci>
    <apply>
     <times></times>
     <ci>t</ci>
     <ci>r</ci>
     <ci>u</ci>
     <ci>e</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F=true
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Lambda_lifting:13">
 <semantics>
  <mrow>
   <mi>L</mi>
   <mo>=</mo>
   <mi>λ</mi>
   <mi>f</mi>
   <mo>.</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>x</mi>
    <mo>.</mo>
    <mpadded width="+5pt">
     <mi>f</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mpadded width="+5pt">
      <mi>x</mi>
     </mpadded>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo rspace="7.5pt" stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>x</mi>
    <mo>.</mo>
    <mpadded width="+5pt">
     <mi>f</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mpadded width="+5pt">
      <mi>x</mi>
     </mpadded>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">L</csymbol>
    <eq></eq>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">f</csymbol>
    <ci>normal-.</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">f</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">f</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L=\lambda f.(\lambda x.f\ (x\ x))\ (\lambda x.f\ (x\ x))
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Lambda_lifting:14">
 <semantics>
  <mrow>
   <mrow>
    <mi>S</mi>
    <mo>=</mo>
    <mrow>
     <mi>λ</mi>
     <mi>x</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mpadded width="+5pt">
     <mi>f</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>x</mi>
      </mpadded>
      <mi>x</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <ci>S</ci>
     <apply>
      <times></times>
      <ci>λ</ci>
      <ci>x</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>f</ci>
     <apply>
      <times></times>
      <ci>x</ci>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S=\lambda x.f\ (x\ x)
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Lambda_lifting:15">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mo>=</mo>
   <mrow>
    <mpadded width="+5pt">
     <mi>p</mi>
    </mpadded>
    <mi>f</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>G</ci>
    <apply>
     <times></times>
     <ci>p</ci>
     <ci>f</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G=p\ f
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Lambda_lifting:16">
 <semantics>
  <mrow>
   <mrow>
    <mi>de</mi>
    <mo>-</mo>
    <mi>lambda</mi>
   </mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mpadded width="+5pt">
     <mi>p</mi>
    </mpadded>
    <mi>f</mi>
    <mo>=</mo>
    <mi>λ</mi>
    <mi>x</mi>
    <mo>.</mo>
    <mpadded width="+5pt">
     <mi>f</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mpadded width="+5pt">
      <mi>x</mi>
     </mpadded>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>≡</mo>
   <mpadded width="+5pt">
    <mi>p</mi>
   </mpadded>
   <mpadded width="+5pt">
    <mi>f</mi>
   </mpadded>
   <mi>x</mi>
   <mo>=</mo>
   <mpadded width="+5pt">
    <mi>f</mi>
   </mpadded>
   <mrow>
    <mo stretchy="false">(</mo>
    <mpadded width="+5pt">
     <mi>x</mi>
    </mpadded>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <minus></minus>
     <ci>de</ci>
     <ci>lambda</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">p</csymbol>
     <csymbol cd="unknown">f</csymbol>
     <eq></eq>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">f</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-]</ci>
    </cerror>
    <equivalent></equivalent>
    <csymbol cd="unknown">p</csymbol>
    <csymbol cd="unknown">f</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <eq></eq>
    <csymbol cd="unknown">f</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{de-lambda}[p\ f=\lambda x.f\ (x\ x)]\equiv p\ f\ x=f\ (x\ x)
  </annotation>
 </semantics>
</math>

 See <em>de-lambda</em> in <a href="Let_expression#Conversion_from_lambda_to_let_expressions" title="wikilink">Conversion from lambda to let expressions</a>. The result is,</p>

<p>

<math display="block" id="Lambda_lifting:17">
 <semantics>
  <mrow>
   <mrow>
    <mi>lambda</mi>
    <mo>-</mo>
    <mi>lift</mi>
   </mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>λ</mi>
    <mi>x</mi>
    <mo>.</mo>
    <mpadded width="+5pt">
     <mi>f</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mpadded width="+5pt">
      <mi>x</mi>
     </mpadded>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>,</mo>
    <mo>let</mo>
    <mi>t</mi>
    <mi>r</mi>
    <mi>u</mi>
    <mi>e</mi>
    <mo>in</mo>
    <mi>λ</mi>
    <mi>f</mi>
    <mo>.</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mi>x</mi>
     <mo>.</mo>
     <mpadded width="+5pt">
      <mi>f</mi>
     </mpadded>
     <mrow>
      <mo stretchy="false">(</mo>
      <mpadded width="+5pt">
       <mi>x</mi>
      </mpadded>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo rspace="7.5pt" stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mi>x</mi>
     <mo>.</mo>
     <mpadded width="+5pt">
      <mi>f</mi>
     </mpadded>
     <mrow>
      <mo stretchy="false">(</mo>
      <mpadded width="+5pt">
       <mi>x</mi>
      </mpadded>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>≡</mo>
   <mo>let</mo>
   <mpadded width="+5pt">
    <mi>p</mi>
   </mpadded>
   <mpadded width="+5pt">
    <mi>f</mi>
   </mpadded>
   <mi>x</mi>
   <mo>=</mo>
   <mpadded width="+5pt">
    <mi>f</mi>
   </mpadded>
   <mrow>
    <mo stretchy="false">(</mo>
    <mpadded width="+5pt">
     <mi>x</mi>
    </mpadded>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>in</mo>
   <mi>λ</mi>
   <mi>f</mi>
   <mo>.</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mpadded width="+5pt">
     <mi>p</mi>
    </mpadded>
    <mi>f</mi>
    <mo rspace="7.5pt" stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mpadded width="+5pt">
     <mi>p</mi>
    </mpadded>
    <mi>f</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <minus></minus>
     <ci>lambda</ci>
     <ci>lift</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">f</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-,</ci>
     <ci>let</ci>
     <csymbol cd="unknown">t</csymbol>
     <csymbol cd="unknown">r</csymbol>
     <csymbol cd="unknown">u</csymbol>
     <csymbol cd="unknown">e</csymbol>
     <ci>in</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">f</csymbol>
     <ci>normal-.</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">f</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">x</csymbol>
       <csymbol cd="unknown">x</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">f</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">x</csymbol>
       <csymbol cd="unknown">x</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-]</ci>
    </cerror>
    <equivalent></equivalent>
    <ci>let</ci>
    <csymbol cd="unknown">p</csymbol>
    <csymbol cd="unknown">f</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <eq></eq>
    <csymbol cd="unknown">f</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>in</ci>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">f</csymbol>
    <ci>normal-.</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">p</csymbol>
     <csymbol cd="unknown">f</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">p</csymbol>
     <csymbol cd="unknown">f</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{lambda-lift}[\lambda x.f\ (x\ x),\operatorname{let}true%
\operatorname{in}\lambda f.(\lambda x.f\ (x\ x))\ (\lambda x.f\ (x\ x))]\equiv%
\operatorname{let}p\ f\ x=f\ (x\ x)\operatorname{in}\lambda f.(p\ f)\ (p\ f)
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
</tbody>
</table>
<h5 id="constructing-the-call">Constructing the call</h5>

<p>The function call <em>G</em> is constructed by adding parameters for each variable in the free variable set (represented by <em>V</em>), to the function <em>H</em>,</p>
<ul>
<li>

<math display="inline" id="Lambda_lifting:18">
 <semantics>
  <mrow>
   <mi>X</mi>
   <mo>∈</mo>
   <mi>V</mi>
   <mo>→</mo>
   <mrow>
    <mrow>
     <mi>make</mi>
     <mo>-</mo>
     <mi>call</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>H</mi>
     <mo>,</mo>
     <mi>V</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>≡</mo>
   <mrow>
    <mrow>
     <mrow>
      <mi>make</mi>
      <mo>-</mo>
      <mi>call</mi>
     </mrow>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>H</mi>
      <mo>,</mo>
      <mrow>
       <mi>V</mi>
       <mo>∩</mo>
       <mrow>
        <mi mathvariant="normal">¬</mi>
        <mrow>
         <mo stretchy="false">{</mo>
         <mi>X</mi>
         <mo stretchy="false">}</mo>
        </mrow>
       </mrow>
      </mrow>
      <mo rspace="7.5pt" stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mi>X</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <in></in>
     <ci>X</ci>
     <ci>V</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <apply>
       <minus></minus>
       <ci>make</ci>
       <ci>call</ci>
      </apply>
      <ci>H</ci>
      <ci>V</ci>
     </apply>
    </apply>
    <apply>
     <equivalent></equivalent>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <apply>
        <minus></minus>
        <ci>make</ci>
        <ci>call</ci>
       </apply>
       <ci>H</ci>
       <apply>
        <intersect></intersect>
        <ci>V</ci>
        <apply>
         <not></not>
         <ci>X</ci>
        </apply>
       </apply>
      </apply>
      <ci>X</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X\in V\to\operatorname{make-call}[H,V]\equiv\operatorname{make-call}[H,V\cap%
\neg\{X\}]\ X
  </annotation>
 </semantics>
</math>


</li>
<li>

<math display="inline" id="Lambda_lifting:19">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>make</mi>
     <mo>-</mo>
     <mi>call</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>H</mi>
     <mo>,</mo>
     <mrow>
      <mo stretchy="false">{</mo>
      <mo stretchy="false">}</mo>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>≡</mo>
   <mi>H</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <apply>
      <minus></minus>
      <ci>make</ci>
      <ci>call</ci>
     </apply>
     <ci>H</ci>
     <list></list>
    </apply>
    <ci>H</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{make-call}[H,\{\}]\equiv H
  </annotation>
 </semantics>
</math>

</li>
</ul>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>Example of call construction.</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>

<math display="block" id="Lambda_lifting:20">
 <semantics>
  <mrow>
   <mrow>
    <mi>S</mi>
    <mo>=</mo>
    <mrow>
     <mi>λ</mi>
     <mi>x</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mpadded width="+5pt">
     <mi>f</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>x</mi>
      </mpadded>
      <mi>x</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <ci>S</ci>
     <apply>
      <times></times>
      <ci>λ</ci>
      <ci>x</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>f</ci>
     <apply>
      <times></times>
      <ci>x</ci>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S=\lambda x.f\ (x\ x)
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Lambda_lifting:21">
 <semantics>
  <mrow>
   <mrow>
    <mo>FV</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>S</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mi>f</mi>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>FV</ci>
     <ci>S</ci>
    </apply>
    <set>
     <ci>f</ci>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{FV}(S)=\{f\}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Lambda_lifting:22">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mo>≡</mo>
   <mrow>
    <mrow>
     <mi>make</mi>
     <mo>-</mo>
     <mi>call</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>p</mi>
     <mo>,</mo>
     <mrow>
      <mo>FV</mo>
      <mrow>
       <mo stretchy="false">[</mo>
       <mi>S</mi>
       <mo stretchy="false">]</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>≡</mo>
   <mrow>
    <mrow>
     <mi>make</mi>
     <mo>-</mo>
     <mi>call</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>p</mi>
     <mo>,</mo>
     <mrow>
      <mo stretchy="false">{</mo>
      <mi>f</mi>
      <mo stretchy="false">}</mo>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>≡</mo>
   <mrow>
    <mrow>
     <mrow>
      <mi>make</mi>
      <mo>-</mo>
      <mi>call</mi>
     </mrow>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>p</mi>
      <mo>,</mo>
      <mrow>
       <mo stretchy="false">{</mo>
       <mo stretchy="false">}</mo>
      </mrow>
      <mo rspace="7.5pt" stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mi>f</mi>
   </mrow>
   <mo>≡</mo>
   <mrow>
    <mpadded width="+5pt">
     <mi>p</mi>
    </mpadded>
    <mi>f</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <equivalent></equivalent>
     <ci>G</ci>
     <apply>
      <apply>
       <minus></minus>
       <ci>make</ci>
       <ci>call</ci>
      </apply>
      <ci>p</ci>
      <apply>
       <ci>FV</ci>
       <ci>S</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <equivalent></equivalent>
     <share href="#.cmml">
     </share>
     <apply>
      <apply>
       <minus></minus>
       <ci>make</ci>
       <ci>call</ci>
      </apply>
      <ci>p</ci>
      <set>
       <ci>f</ci>
      </set>
     </apply>
    </apply>
    <apply>
     <equivalent></equivalent>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <apply>
        <minus></minus>
        <ci>make</ci>
        <ci>call</ci>
       </apply>
       <ci>p</ci>
       <list></list>
      </apply>
      <ci>f</ci>
     </apply>
    </apply>
    <apply>
     <equivalent></equivalent>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>p</ci>
      <ci>f</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G\equiv\operatorname{make-call}[p,\operatorname{FV}[S]]\equiv\operatorname{%
make-call}[p,\{f\}]\equiv\operatorname{make-call}[p,\{\}]\ f\equiv p\ f
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
</tbody>
</table>
<h4 id="named-lift">Named Lift</h4>

<p>The named lift is similar to the anonymous lift except that the function name <em>V</em> is provided.</p>

<p>

<math display="block" id="Lambda_lifting:23">
 <semantics>
  <mrow>
   <mrow>
    <mi>lambda</mi>
    <mo>-</mo>
    <mi>lift</mi>
   </mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mi>V</mi>
     <mo>.</mo>
     <mi>E</mi>
     <mo rspace="7.5pt" stretchy="false">)</mo>
    </mrow>
    <mi>S</mi>
    <mo>,</mo>
    <mi>L</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>≡</mo>
   <mo>let</mo>
   <mi>V</mi>
   <mo>:</mo>
   <mrow>
    <mi>de</mi>
    <mo>-</mo>
    <mi>lambda</mi>
   </mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>G</mi>
    <mo>=</mo>
    <mi>S</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>in</mo>
   <mi>L</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mi>V</mi>
     <mo>.</mo>
     <mi>E</mi>
     <mo rspace="7.5pt" stretchy="false">)</mo>
    </mrow>
    <mi>S</mi>
    <mo>:=</mo>
    <mi>E</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>V</mi>
     <mo>:=</mo>
     <mi>G</mi>
     <mo stretchy="false">]</mo>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <minus></minus>
     <ci>lambda</ci>
     <ci>lift</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">V</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">E</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <csymbol cd="unknown">S</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">L</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <equivalent></equivalent>
    <ci>let</ci>
    <csymbol cd="unknown">V</csymbol>
    <ci>normal-:</ci>
    <apply>
     <minus></minus>
     <ci>de</ci>
     <ci>lambda</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">G</csymbol>
     <eq></eq>
     <csymbol cd="unknown">S</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <ci>in</ci>
    <csymbol cd="unknown">L</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">V</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">E</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <csymbol cd="unknown">S</csymbol>
     <csymbol cd="latexml">assign</csymbol>
     <csymbol cd="unknown">E</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-[</ci>
      <csymbol cd="unknown">V</csymbol>
      <csymbol cd="latexml">assign</csymbol>
      <csymbol cd="unknown">G</csymbol>
      <ci>normal-]</ci>
     </cerror>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{lambda-lift}[(\lambda V.E)\ S,L]\equiv\operatorname{let}V:%
\operatorname{de-lambda}[G=S]\operatorname{in}L[(\lambda V.E)\ S:=E[V:=G]]
  </annotation>
 </semantics>
</math>

</p>

<p>As for the anonymous lift, the expression <em>G</em> is constructed from <em>V</em> by applying the free variables of <em>S</em>. It is defined by,</p>

<p>

<math display="block" id="Lambda_lifting:24">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>make</mi>
     <mo>-</mo>
     <mi>call</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>V</mi>
     <mo>,</mo>
     <mrow>
      <mo>FV</mo>
      <mrow>
       <mo stretchy="false">[</mo>
       <mi>S</mi>
       <mo stretchy="false">]</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>G</ci>
    <apply>
     <apply>
      <minus></minus>
      <ci>make</ci>
      <ci>call</ci>
     </apply>
     <ci>V</ci>
     <apply>
      <ci>FV</ci>
      <ci>S</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G=\operatorname{make-call}[V,\operatorname{FV}[S]]
  </annotation>
 </semantics>
</math>

</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>Example for named lift.</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>For example,</p>

<p>

<math display="block" id="Lambda_lifting:25">
 <semantics>
  <mrow>
   <mi>V</mi>
   <mo>=</mo>
   <mi>x</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>V</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V=x
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Lambda_lifting:26">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mo>=</mo>
   <mrow>
    <mpadded width="+5pt">
     <mi>f</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>x</mi>
      </mpadded>
      <mi>x</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>E</ci>
    <apply>
     <times></times>
     <ci>f</ci>
     <apply>
      <times></times>
      <ci>x</ci>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E=f\ (x\ x)
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Lambda_lifting:27">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>x</mi>
    <mo>.</mo>
    <mpadded width="+5pt">
     <mi>f</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mpadded width="+5pt">
      <mi>x</mi>
     </mpadded>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">S</csymbol>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">f</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S=(\lambda x.f\ (x\ x))
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Lambda_lifting:28">
 <semantics>
  <mrow>
   <mi>L</mi>
   <mo>=</mo>
   <mi>λ</mi>
   <mi>f</mi>
   <mo>.</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>x</mi>
    <mo>.</mo>
    <mpadded width="+5pt">
     <mi>f</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mpadded width="+5pt">
      <mi>x</mi>
     </mpadded>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo rspace="7.5pt" stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>x</mi>
    <mo>.</mo>
    <mpadded width="+5pt">
     <mi>f</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mpadded width="+5pt">
      <mi>x</mi>
     </mpadded>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">L</csymbol>
    <eq></eq>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">f</csymbol>
    <ci>normal-.</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">f</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">f</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L=\lambda f.(\lambda x.f\ (x\ x))\ (\lambda x.f\ (x\ x))
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Lambda_lifting:29">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mo>=</mo>
   <mrow>
    <mpadded width="+5pt">
     <mi>x</mi>
    </mpadded>
    <mi>f</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>G</ci>
    <apply>
     <times></times>
     <ci>x</ci>
     <ci>f</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G=x\ f
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Lambda_lifting:30">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>V</mi>
    <mo>:=</mo>
    <mi>G</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>=</mo>
   <mpadded width="+5pt">
    <mi>f</mi>
   </mpadded>
   <mrow>
    <mo stretchy="false">(</mo>
    <mpadded width="+5pt">
     <mi>x</mi>
    </mpadded>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>x</mi>
    <mo>:=</mo>
    <mpadded width="+5pt">
     <mi>x</mi>
    </mpadded>
    <mi>f</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>=</mo>
   <mpadded width="+5pt">
    <mi>f</mi>
   </mpadded>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mpadded width="+5pt">
      <mi>x</mi>
     </mpadded>
     <mi>f</mi>
     <mo rspace="7.5pt" stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mpadded width="+5pt">
      <mi>x</mi>
     </mpadded>
     <mi>f</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">E</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">V</csymbol>
     <csymbol cd="latexml">assign</csymbol>
     <csymbol cd="unknown">G</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">f</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="latexml">assign</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="unknown">f</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">f</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <csymbol cd="unknown">f</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <csymbol cd="unknown">f</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E[V:=G]=f\ (x\ x)[x:=x\ f]=f\ ((x\ f)\ (x\ f))
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Lambda_lifting:31">
 <semantics>
  <mrow>
   <mi>L</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mi>V</mi>
     <mo>.</mo>
     <mi>E</mi>
     <mo rspace="7.5pt" stretchy="false">)</mo>
    </mrow>
    <mi>F</mi>
    <mo>:=</mo>
    <mi>E</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>V</mi>
     <mo>:=</mo>
     <mi>G</mi>
     <mo stretchy="false">]</mo>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>=</mo>
   <mi>L</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mi>x</mi>
     <mo>.</mo>
     <mpadded width="+5pt">
      <mi>f</mi>
     </mpadded>
     <mrow>
      <mo stretchy="false">(</mo>
      <mpadded width="+5pt">
       <mi>x</mi>
      </mpadded>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo rspace="7.5pt" stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mi>x</mi>
     <mo>.</mo>
     <mpadded width="+5pt">
      <mi>f</mi>
     </mpadded>
     <mrow>
      <mo stretchy="false">(</mo>
      <mpadded width="+5pt">
       <mi>x</mi>
      </mpadded>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>:=</mo>
    <mpadded width="+5pt">
     <mi>f</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mpadded width="+5pt">
       <mi>x</mi>
      </mpadded>
      <mi>f</mi>
      <mo rspace="7.5pt" stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mpadded width="+5pt">
       <mi>x</mi>
      </mpadded>
      <mi>f</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>=</mo>
   <mi>λ</mi>
   <mi>f</mi>
   <mo>.</mo>
   <mpadded width="+5pt">
    <mi>f</mi>
   </mpadded>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mpadded width="+5pt">
      <mi>x</mi>
     </mpadded>
     <mi>f</mi>
     <mo rspace="7.5pt" stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mpadded width="+5pt">
      <mi>x</mi>
     </mpadded>
     <mi>f</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">L</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">V</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">E</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <csymbol cd="unknown">F</csymbol>
     <csymbol cd="latexml">assign</csymbol>
     <csymbol cd="unknown">E</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-[</ci>
      <csymbol cd="unknown">V</csymbol>
      <csymbol cd="latexml">assign</csymbol>
      <csymbol cd="unknown">G</csymbol>
      <ci>normal-]</ci>
     </cerror>
     <ci>normal-]</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">L</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">f</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">x</csymbol>
       <csymbol cd="unknown">x</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">f</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">x</csymbol>
       <csymbol cd="unknown">x</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <csymbol cd="latexml">assign</csymbol>
     <csymbol cd="unknown">f</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">x</csymbol>
       <csymbol cd="unknown">f</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">x</csymbol>
       <csymbol cd="unknown">f</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-]</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">f</csymbol>
    <ci>normal-.</ci>
    <csymbol cd="unknown">f</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <csymbol cd="unknown">f</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <csymbol cd="unknown">f</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L[(\lambda V.E)\ F:=E[V:=G]]=L[(\lambda x.f\ (x\ x))\ (\lambda x.f\ (x\ x)):=f%
\ ((x\ f)\ (x\ f))]=\lambda f.f\ ((x\ f)\ (x\ f))
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Lambda_lifting:32">
 <semantics>
  <mrow>
   <mrow>
    <mi>de</mi>
    <mo>-</mo>
    <mi>lambda</mi>
   </mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mpadded width="+5pt">
     <mi>x</mi>
    </mpadded>
    <mi>f</mi>
    <mo>=</mo>
    <mi>λ</mi>
    <mi>y</mi>
    <mo>.</mo>
    <mpadded width="+5pt">
     <mi>f</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mpadded width="+5pt">
      <mi>y</mi>
     </mpadded>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>≡</mo>
   <mpadded width="+5pt">
    <mi>x</mi>
   </mpadded>
   <mpadded width="+5pt">
    <mi>f</mi>
   </mpadded>
   <mi>y</mi>
   <mo>=</mo>
   <mpadded width="+5pt">
    <mi>f</mi>
   </mpadded>
   <mrow>
    <mo stretchy="false">(</mo>
    <mpadded width="+5pt">
     <mi>y</mi>
    </mpadded>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <minus></minus>
     <ci>de</ci>
     <ci>lambda</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="unknown">f</csymbol>
     <eq></eq>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">f</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">y</csymbol>
      <csymbol cd="unknown">y</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-]</ci>
    </cerror>
    <equivalent></equivalent>
    <csymbol cd="unknown">x</csymbol>
    <csymbol cd="unknown">f</csymbol>
    <csymbol cd="unknown">y</csymbol>
    <eq></eq>
    <csymbol cd="unknown">f</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">y</csymbol>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{de-lambda}[x\ f=\lambda y.f\ (y\ y)]\equiv x\ f\ y=f\ (y\ y)
  </annotation>
 </semantics>
</math>

 See <em>de-lambda</em> in <a href="Let_expression#Conversion_from_lambda_to_let_expressions" title="wikilink">Conversion from lambda to let expressions</a>. The result is, gives,</p>

<p>

<math display="block" id="Lambda_lifting:33">
 <semantics>
  <mrow>
   <mrow>
    <mi>lambda</mi>
    <mo>-</mo>
    <mi>lift</mi>
   </mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mi>x</mi>
     <mo>.</mo>
     <mpadded width="+5pt">
      <mi>f</mi>
     </mpadded>
     <mrow>
      <mo stretchy="false">(</mo>
      <mpadded width="+5pt">
       <mi>x</mi>
      </mpadded>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo rspace="7.5pt" stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mi>x</mi>
     <mo>.</mo>
     <mpadded width="+5pt">
      <mi>f</mi>
     </mpadded>
     <mrow>
      <mo stretchy="false">(</mo>
      <mpadded width="+5pt">
       <mi>x</mi>
      </mpadded>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>,</mo>
    <mi>λ</mi>
    <mi>f</mi>
    <mo>.</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mi>x</mi>
     <mo>.</mo>
     <mpadded width="+5pt">
      <mi>f</mi>
     </mpadded>
     <mrow>
      <mo stretchy="false">(</mo>
      <mpadded width="+5pt">
       <mi>x</mi>
      </mpadded>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo rspace="7.5pt" stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mi>x</mi>
     <mo>.</mo>
     <mpadded width="+5pt">
      <mi>f</mi>
     </mpadded>
     <mrow>
      <mo stretchy="false">(</mo>
      <mpadded width="+5pt">
       <mi>x</mi>
      </mpadded>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>≡</mo>
   <mo>let</mo>
   <mpadded width="+5pt">
    <mi>x</mi>
   </mpadded>
   <mpadded width="+5pt">
    <mi>f</mi>
   </mpadded>
   <mi>y</mi>
   <mo>=</mo>
   <mpadded width="+5pt">
    <mi>f</mi>
   </mpadded>
   <mrow>
    <mo stretchy="false">(</mo>
    <mpadded width="+5pt">
     <mi>y</mi>
    </mpadded>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>in</mo>
   <mi>λ</mi>
   <mi>f</mi>
   <mo>.</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mpadded width="+5pt">
     <mi>x</mi>
    </mpadded>
    <mi>f</mi>
    <mo rspace="7.5pt" stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mpadded width="+5pt">
     <mi>x</mi>
    </mpadded>
    <mi>f</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <minus></minus>
     <ci>lambda</ci>
     <ci>lift</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">f</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">x</csymbol>
       <csymbol cd="unknown">x</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">f</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">x</csymbol>
       <csymbol cd="unknown">x</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-,</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">f</csymbol>
     <ci>normal-.</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">f</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">x</csymbol>
       <csymbol cd="unknown">x</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">f</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">x</csymbol>
       <csymbol cd="unknown">x</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-]</ci>
    </cerror>
    <equivalent></equivalent>
    <ci>let</ci>
    <csymbol cd="unknown">x</csymbol>
    <csymbol cd="unknown">f</csymbol>
    <csymbol cd="unknown">y</csymbol>
    <eq></eq>
    <csymbol cd="unknown">f</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">y</csymbol>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>in</ci>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">f</csymbol>
    <ci>normal-.</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="unknown">f</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="unknown">f</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{lambda-lift}[(\lambda x.f\ (x\ x))\ (\lambda x.f\ (x\ x)),%
\lambda f.(\lambda x.f\ (x\ x))\ (\lambda x.f\ (x\ x))]\equiv\operatorname{let%
}x\ f\ y=f\ (y\ y)\operatorname{in}\lambda f.(x\ f)\ (x\ f)
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
</tbody>
</table>
<h3 id="lamba-lift-transformation">Lamba-lift transformation</h3>

<p>A lambda lift transformation takes a lambda expression and lifts all lambda abstractions to the top of the expression. The abstractions are then translated into <a href="Recursion_(computer_science)" title="wikilink">recursive functions</a>, which eliminates the lambda abstractions. The result is a functional program in the form,</p>
<ul>
<li>

<math display="inline" id="Lambda_lifting:34">
 <semantics>
  <mrow>
   <mrow>
    <mo>let</mo>
    <mi>M</mi>
   </mrow>
   <mrow>
    <mo>in</mo>
    <mi>N</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <ci>let</ci>
     <ci>M</ci>
    </apply>
    <apply>
     <ci>in</ci>
     <ci>N</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{let}M\operatorname{in}N
  </annotation>
 </semantics>
</math>

</li>
</ul>

<p>where <em>M</em> is a series of function definitions, and <em>N</em> is the expression representing the value returned.</p>

<p>For example,</p>

<p>

<math display="block" id="Lambda_lifting:35">
 <semantics>
  <mrow>
   <mrow>
    <mi>lambda</mi>
    <mo>-</mo>
    <mi>lift</mi>
    <mo>-</mo>
    <mi>tran</mi>
   </mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>λ</mi>
    <mi>f</mi>
    <mo>.</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mi>x</mi>
     <mo>.</mo>
     <mpadded width="+5pt">
      <mi>f</mi>
     </mpadded>
     <mrow>
      <mo stretchy="false">(</mo>
      <mpadded width="+5pt">
       <mi>x</mi>
      </mpadded>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo rspace="7.5pt" stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mi>x</mi>
     <mo>.</mo>
     <mpadded width="+5pt">
      <mi>f</mi>
     </mpadded>
     <mrow>
      <mo stretchy="false">(</mo>
      <mpadded width="+5pt">
       <mi>x</mi>
      </mpadded>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>≡</mo>
   <mo>let</mo>
   <mpadded width="+5pt">
    <mi>p</mi>
   </mpadded>
   <mpadded width="+5pt">
    <mi>f</mi>
   </mpadded>
   <mi>x</mi>
   <mo>=</mo>
   <mpadded width="+5pt">
    <mi>f</mi>
   </mpadded>
   <mrow>
    <mo stretchy="false">(</mo>
    <mpadded width="+5pt">
     <mi>x</mi>
    </mpadded>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi mathvariant="italic">and</mi>
   <mpadded width="+5pt">
    <mi>q</mi>
   </mpadded>
   <mpadded width="+5pt">
    <mi>p</mi>
   </mpadded>
   <mi>f</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mpadded width="+5pt">
     <mi>p</mi>
    </mpadded>
    <mi>f</mi>
    <mo rspace="7.5pt" stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mpadded width="+5pt">
     <mi>p</mi>
    </mpadded>
    <mi>f</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>in</mo>
   <mpadded width="+5pt">
    <mi>q</mi>
   </mpadded>
   <mi>p</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <minus></minus>
     <ci>lambda</ci>
     <ci>lift</ci>
     <ci>tran</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">f</csymbol>
     <ci>normal-.</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">f</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">x</csymbol>
       <csymbol cd="unknown">x</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">f</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">x</csymbol>
       <csymbol cd="unknown">x</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-]</ci>
    </cerror>
    <equivalent></equivalent>
    <ci>let</ci>
    <csymbol cd="unknown">p</csymbol>
    <csymbol cd="unknown">f</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <eq></eq>
    <csymbol cd="unknown">f</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">and</csymbol>
    <csymbol cd="unknown">q</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <csymbol cd="unknown">f</csymbol>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">p</csymbol>
     <csymbol cd="unknown">f</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">p</csymbol>
     <csymbol cd="unknown">f</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>in</ci>
    <csymbol cd="unknown">q</csymbol>
    <csymbol cd="unknown">p</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{lambda-lift-tran}[\lambda f.(\lambda x.f\ (x\ x))\ (\lambda x.f%
\ (x\ x))]\equiv\operatorname{let}p\ f\ x=f\ (x\ x)\and q\ p\ f=(p\ f)\ (p\ f)%
\operatorname{in}q\ p
  </annotation>
 </semantics>
</math>

</p>

<p>The <em>de-let</em> meta function may then be used to convert the result back into lambda calculus.</p>

<p>

<math display="block" id="Lambda_lifting:36">
 <semantics>
  <mrow>
   <mrow>
    <mi>de</mi>
    <mo>-</mo>
    <mi>let</mi>
   </mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mrow>
     <mi>lambda</mi>
     <mo>-</mo>
     <mi>lift</mi>
     <mo>-</mo>
     <mi>tran</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>λ</mi>
     <mi>f</mi>
     <mo>.</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>λ</mi>
      <mi>x</mi>
      <mo>.</mo>
      <mpadded width="+5pt">
       <mi>f</mi>
      </mpadded>
      <mrow>
       <mo stretchy="false">(</mo>
       <mpadded width="+5pt">
        <mi>x</mi>
       </mpadded>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo rspace="7.5pt" stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>λ</mi>
      <mi>x</mi>
      <mo>.</mo>
      <mpadded width="+5pt">
       <mi>f</mi>
      </mpadded>
      <mrow>
       <mo stretchy="false">(</mo>
       <mpadded width="+5pt">
        <mi>x</mi>
       </mpadded>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>≡</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>p</mi>
    <mo>.</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mi>q</mi>
     <mo>.</mo>
     <mpadded width="+5pt">
      <mi>q</mi>
     </mpadded>
     <mi>p</mi>
     <mo rspace="7.5pt" stretchy="false">)</mo>
    </mrow>
    <mi>λ</mi>
    <mi>p</mi>
    <mo>.</mo>
    <mi>λ</mi>
    <mi>f</mi>
    <mo>.</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mpadded width="+5pt">
      <mi>p</mi>
     </mpadded>
     <mi>f</mi>
     <mo rspace="7.5pt" stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mpadded width="+5pt">
      <mi>p</mi>
     </mpadded>
     <mi>f</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo rspace="7.5pt" stretchy="false">)</mo>
   </mrow>
   <mi>λ</mi>
   <mi>f</mi>
   <mo>.</mo>
   <mi>λ</mi>
   <mi>x</mi>
   <mo>.</mo>
   <mpadded width="+5pt">
    <mi>f</mi>
   </mpadded>
   <mrow>
    <mo stretchy="false">(</mo>
    <mpadded width="+5pt">
     <mi>x</mi>
    </mpadded>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <minus></minus>
     <ci>de</ci>
     <ci>let</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <apply>
      <minus></minus>
      <ci>lambda</ci>
      <ci>lift</ci>
      <ci>tran</ci>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-[</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">f</csymbol>
      <ci>normal-.</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">λ</csymbol>
       <csymbol cd="unknown">x</csymbol>
       <ci>normal-.</ci>
       <csymbol cd="unknown">f</csymbol>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <csymbol cd="unknown">x</csymbol>
        <csymbol cd="unknown">x</csymbol>
        <ci>normal-)</ci>
       </cerror>
       <ci>normal-)</ci>
      </cerror>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">λ</csymbol>
       <csymbol cd="unknown">x</csymbol>
       <ci>normal-.</ci>
       <csymbol cd="unknown">f</csymbol>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <csymbol cd="unknown">x</csymbol>
        <csymbol cd="unknown">x</csymbol>
        <ci>normal-)</ci>
       </cerror>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-]</ci>
     </cerror>
     <ci>normal-]</ci>
    </cerror>
    <equivalent></equivalent>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">p</csymbol>
     <ci>normal-.</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">q</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">q</csymbol>
      <csymbol cd="unknown">p</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">p</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">f</csymbol>
     <ci>normal-.</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">p</csymbol>
      <csymbol cd="unknown">f</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">p</csymbol>
      <csymbol cd="unknown">f</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">f</csymbol>
    <ci>normal-.</ci>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <ci>normal-.</ci>
    <csymbol cd="unknown">f</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{de-let}[\operatorname{lambda-lift-tran}[\lambda f.(\lambda x.f\ %
(x\ x))\ (\lambda x.f\ (x\ x))]]\equiv(\lambda p.(\lambda q.q\ p)\ \lambda p.%
\lambda f.(p\ f)\ (p\ f))\ \lambda f.\lambda x.f\ (x\ x)
  </annotation>
 </semantics>
</math>

</p>

<p>The processing of transforming the lambda expression is a series of lifts. Each lift has,</p>
<ul>
<li>A sub expression chosen for it by the function <em>lift-choice</em>. The sub expression should be chosen so that it may be converted into an equation with no lambdas.</li>
<li>The lift is performed by a call to the <em>lambda-lift</em> meta function, described in the next section,</li>
</ul>
<ol>
<li>

<math display="inline" id="Lambda_lifting:37">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>lambda</mi>
     <mo>-</mo>
     <mi>lift</mi>
     <mo>-</mo>
     <mi>tran</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>L</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>drop</mi>
     <mo>-</mo>
     <mi>params</mi>
     <mo>-</mo>
     <mi>tran</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mrow>
       <mi>merge</mi>
       <mo>-</mo>
       <mi>let</mi>
      </mrow>
      <mrow>
       <mo stretchy="false">[</mo>
       <mrow>
        <mrow>
         <mi>lambda</mi>
         <mo>-</mo>
         <mi>apply</mi>
        </mrow>
        <mrow>
         <mo stretchy="false">[</mo>
         <mi>L</mi>
         <mo stretchy="false">]</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">]</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <minus></minus>
      <ci>lambda</ci>
      <ci>lift</ci>
      <ci>tran</ci>
     </apply>
     <ci>L</ci>
    </apply>
    <apply>
     <apply>
      <minus></minus>
      <ci>drop</ci>
      <ci>params</ci>
      <ci>tran</ci>
     </apply>
     <apply>
      <apply>
       <minus></minus>
       <ci>merge</ci>
       <ci>let</ci>
      </apply>
      <apply>
       <apply>
        <minus></minus>
        <ci>lambda</ci>
        <ci>apply</ci>
       </apply>
       <ci>L</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{lambda-lift-tran}[L]=\operatorname{drop-params-tran}[%
\operatorname{merge-let}[\operatorname{lambda-apply}[L]]]
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="Lambda_lifting:38">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>lambda</mi>
     <mo>-</mo>
     <mi>apply</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>L</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>lambda</mi>
     <mo>-</mo>
     <mi>process</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mrow>
       <mi>lift</mi>
       <mo>-</mo>
       <mi>choice</mi>
      </mrow>
      <mrow>
       <mo stretchy="false">[</mo>
       <mi>L</mi>
       <mo stretchy="false">]</mo>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mi>L</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <minus></minus>
      <ci>lambda</ci>
      <ci>apply</ci>
     </apply>
     <ci>L</ci>
    </apply>
    <apply>
     <apply>
      <minus></minus>
      <ci>lambda</ci>
      <ci>process</ci>
     </apply>
     <apply>
      <apply>
       <minus></minus>
       <ci>lift</ci>
       <ci>choice</ci>
      </apply>
      <ci>L</ci>
     </apply>
     <ci>L</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{lambda-apply}[L]=\operatorname{lambda-process}[\operatorname{%
lift-choice}[L],L]
  </annotation>
 </semantics>
</math>


</li>
<li>

<math display="inline" id="Lambda_lifting:39">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>lambda</mi>
     <mo>-</mo>
     <mi>process</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">[</mo>
     <mo>none</mo>
     <mo>,</mo>
     <mi>L</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>L</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <minus></minus>
      <ci>lambda</ci>
      <ci>process</ci>
     </apply>
     <ci>none</ci>
     <ci>L</ci>
    </apply>
    <ci>L</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{lambda-process}[\operatorname{none},L]=L
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="Lambda_lifting:40">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>lambda</mi>
     <mo>-</mo>
     <mi>process</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>S</mi>
     <mo>,</mo>
     <mi>L</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>lambda</mi>
     <mo>-</mo>
     <mi>apply</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mrow>
       <mi>lambda</mi>
       <mo>-</mo>
       <mi>lift</mi>
      </mrow>
      <mrow>
       <mo stretchy="false">[</mo>
       <mi>S</mi>
       <mo>,</mo>
       <mi>L</mi>
       <mo stretchy="false">]</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <minus></minus>
      <ci>lambda</ci>
      <ci>process</ci>
     </apply>
     <ci>S</ci>
     <ci>L</ci>
    </apply>
    <apply>
     <apply>
      <minus></minus>
      <ci>lambda</ci>
      <ci>apply</ci>
     </apply>
     <apply>
      <apply>
       <minus></minus>
       <ci>lambda</ci>
       <ci>lift</ci>
      </apply>
      <ci>S</ci>
      <ci>L</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{lambda-process}[S,L]=\operatorname{lambda-apply}[\operatorname{%
lambda-lift}[S,L]]
  </annotation>
 </semantics>
</math>

</li>
</ol>

<p>After the lifts are applied the lets are combined together into a single let.</p>

<p>

<math display="block" id="Lambda_lifting:41">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>merge</mi>
     <mo>-</mo>
     <mi>let</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mrow>
       <mrow>
        <mo>let</mo>
        <mi>V</mi>
       </mrow>
       <mo>:</mo>
       <mrow>
        <mi>E</mi>
        <mrow>
         <mrow>
          <mo>in</mo>
          <mo>let</mo>
         </mrow>
         <mi>W</mi>
        </mrow>
       </mrow>
      </mrow>
      <mo>:</mo>
      <mrow>
       <mi>F</mi>
       <mrow>
        <mo>in</mo>
        <mi>G</mi>
       </mrow>
      </mrow>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>merge</mi>
     <mo>-</mo>
     <mi>let</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mo>let</mo>
      <mi>V</mi>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mi>W</mi>
      <mo>:</mo>
      <mrow>
       <mi>E</mi>
       <mi mathvariant="italic">and</mi>
       <mi>F</mi>
       <mrow>
        <mo>in</mo>
        <mi>G</mi>
       </mrow>
      </mrow>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <minus></minus>
      <ci>merge</ci>
      <ci>let</ci>
     </apply>
     <apply>
      <ci>normal-:</ci>
      <apply>
       <ci>normal-:</ci>
       <apply>
        <ci>let</ci>
        <ci>V</ci>
       </apply>
       <apply>
        <times></times>
        <ci>E</ci>
        <apply>
         <apply>
          <ci>in</ci>
          <ci>let</ci>
         </apply>
         <ci>W</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>F</ci>
       <apply>
        <ci>in</ci>
        <ci>G</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <apply>
      <minus></minus>
      <ci>merge</ci>
      <ci>let</ci>
     </apply>
     <apply>
      <ci>let</ci>
      <ci>V</ci>
     </apply>
     <apply>
      <ci>normal-:</ci>
      <ci>W</ci>
      <apply>
       <times></times>
       <ci>E</ci>
       <ci>italic- and</ci>
       <ci>F</ci>
       <apply>
        <ci>in</ci>
        <ci>G</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{merge-let}[\operatorname{let}V:E\operatorname{in}\operatorname{%
let}W:F\operatorname{in}G]=\operatorname{merge-let}[\operatorname{let}V,W:E%
\and F\operatorname{in}G]
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Lambda_lifting:42">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>merge</mi>
     <mo>-</mo>
     <mi>let</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>E</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>E</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <minus></minus>
      <ci>merge</ci>
      <ci>let</ci>
     </apply>
     <ci>E</ci>
    </apply>
    <ci>E</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{merge-let}[E]=E
  </annotation>
 </semantics>
</math>

</p>

<p>Then <a href="#Parameter_dropping" title="wikilink">Parameter dropping</a> is applied to remove parameters that are not necessary in the "let" expression. The let expression allows the function definitions to refer to each other directly, whereas lambda abstractions are strictly hierarchical, and a function may not directly refer to itself.</p>
<h4 id="choosing-the-expression-for-lifting">Choosing the expression for lifting</h4>

<p>There are two different ways that an expression may be selected for lifting. The first treats all lambda abstractions as defining anonymous functions. The second, treats lambda abstractions which are applied to a parameter as defining a function. Lambda abstractions applied to a parameter have a dual interpretation as either a let expression defining a function, or as defining an anonymous function. Both interpretations are valid.</p>

<p>These two predicates are needed for both definitions.</p>

<p><em>lambda-free</em> - An expression containing no lambda abstractions.</p>

<p>

<math display="block" id="Lambda_lifting:43">
 <semantics>
  <mrow>
   <mrow>
    <mi>lambda</mi>
    <mo>-</mo>
    <mi>free</mi>
   </mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>λ</mi>
    <mi>F</mi>
    <mo>.</mo>
    <mi>X</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>=</mo>
   <mo>false</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <minus></minus>
     <ci>lambda</ci>
     <ci>free</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">F</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">X</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <eq></eq>
    <ci>false</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{lambda-free}[\lambda F.X]=\operatorname{false}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Lambda_lifting:44">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>lambda</mi>
     <mo>-</mo>
     <mi>free</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>V</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mo>true</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <minus></minus>
      <ci>lambda</ci>
      <ci>free</ci>
     </apply>
     <ci>V</ci>
    </apply>
    <ci>true</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{lambda-free}[V]=\operatorname{true}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Lambda_lifting:45">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>lambda</mi>
     <mo>-</mo>
     <mi>free</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>M</mi>
      </mpadded>
      <mi>N</mi>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <mrow>
       <mi>lambda</mi>
       <mo>-</mo>
       <mi>free</mi>
      </mrow>
      <mrow>
       <mo stretchy="false">[</mo>
       <mi>M</mi>
       <mo stretchy="false">]</mo>
      </mrow>
     </mrow>
     <mi mathvariant="italic">and</mi>
    </mrow>
    <mrow>
     <mrow>
      <mi>lambda</mi>
      <mo>-</mo>
      <mi>free</mi>
     </mrow>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>N</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <minus></minus>
      <ci>lambda</ci>
      <ci>free</ci>
     </apply>
     <apply>
      <times></times>
      <ci>M</ci>
      <ci>N</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <apply>
       <apply>
        <minus></minus>
        <ci>lambda</ci>
        <ci>free</ci>
       </apply>
       <ci>M</ci>
      </apply>
      <ci>italic- and</ci>
     </apply>
     <apply>
      <apply>
       <minus></minus>
       <ci>lambda</ci>
       <ci>free</ci>
      </apply>
      <ci>N</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{lambda-free}[M\ N]=\operatorname{lambda-free}[M]\and%
\operatorname{lambda-free}[N]
  </annotation>
 </semantics>
</math>

</p>

<p><em>lambda-anon</em> - An anonymous function. An expression like 

<math display="inline" id="Lambda_lifting:46">
 <semantics>
  <mrow>
   <mrow>
    <mi>λ</mi>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
   </mrow>
   <mo rspace="7.5pt">.</mo>
   <mrow>
    <mpadded width="+5pt">
     <mi mathvariant="normal">…</mi>
    </mpadded>
    <mi>λ</mi>
    <msub>
     <mi>x</mi>
     <mi>n</mi>
    </msub>
   </mrow>
   <mo>.</mo>
   <mi>X</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <times></times>
     <ci>λ</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>normal-…</ci>
     <ci>λ</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda x_{1}.\ ...\ \lambda x_{n}.X
  </annotation>
 </semantics>
</math>

 where X is lambda free.</p>

<p>

<math display="block" id="Lambda_lifting:47">
 <semantics>
  <mrow>
   <mrow>
    <mi>lambda</mi>
    <mo>-</mo>
    <mi>anon</mi>
   </mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>λ</mi>
    <mi>F</mi>
    <mo>.</mo>
    <mi>X</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>lambda</mi>
    <mo>-</mo>
    <mi>free</mi>
   </mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>X</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mrow>
    <mi>lambda</mi>
    <mo>-</mo>
    <mi>anon</mi>
   </mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>X</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <minus></minus>
     <ci>lambda</ci>
     <ci>anon</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">F</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">X</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <eq></eq>
    <apply>
     <minus></minus>
     <ci>lambda</ci>
     <ci>free</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">X</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <apply>
     <minus></minus>
     <ci>lambda</ci>
     <ci>anon</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">X</csymbol>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{lambda-anon}[\lambda F.X]=\operatorname{lambda-free}[X]%
\operatorname{lambda-anon}[X]
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Lambda_lifting:48">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>lambda</mi>
     <mo>-</mo>
     <mi>anon</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>V</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mo>false</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <minus></minus>
      <ci>lambda</ci>
      <ci>anon</ci>
     </apply>
     <ci>V</ci>
    </apply>
    <ci>false</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{lambda-anon}[V]=\operatorname{false}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Lambda_lifting:49">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>lambda</mi>
     <mo>-</mo>
     <mi>anon</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>M</mi>
      </mpadded>
      <mi>N</mi>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mo>false</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <minus></minus>
      <ci>lambda</ci>
      <ci>anon</ci>
     </apply>
     <apply>
      <times></times>
      <ci>M</ci>
      <ci>N</ci>
     </apply>
    </apply>
    <ci>false</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{lambda-anon}[M\ N]=\operatorname{false}
  </annotation>
 </semantics>
</math>

</p>
<h5 id="choosing-anonymous-functions-only-for-lifting">Choosing anonymous functions only for lifting</h5>

<p>Search for the deepest anonymous abstraction, so that when the lift is applied the function lifted will become a simple equation. This definition does not recognize a lambda abstractions with a parameter as defining a function. All lambda abstractions are regarded as defining anonymous functions.</p>

<p><em>lift-choice</em> - The first anonymous found in traversing the expression or <em>none</em> if there is no function.</p>
<ol>
<li>

<math display="inline" id="Lambda_lifting:50">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>lambda</mi>
     <mo>-</mo>
     <mi>anon</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>X</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mrow>
     <mi>lift</mi>
     <mo>-</mo>
     <mi>choice</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>X</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>X</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <apply>
       <minus></minus>
       <ci>lambda</ci>
       <ci>anon</ci>
      </apply>
      <ci>X</ci>
     </apply>
     <apply>
      <apply>
       <minus></minus>
       <ci>lift</ci>
       <ci>choice</ci>
      </apply>
      <ci>X</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <ci>X</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{lambda-anon}[X]\to\operatorname{lift-choice}[X]=X
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="Lambda_lifting:51">
 <semantics>
  <mrow>
   <mrow>
    <mi>lift</mi>
    <mo>-</mo>
    <mi>choice</mi>
   </mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>λ</mi>
    <mi>F</mi>
    <mo>.</mo>
    <mi>X</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>lift</mi>
    <mo>-</mo>
    <mi>choice</mi>
   </mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>X</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <minus></minus>
     <ci>lift</ci>
     <ci>choice</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">F</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">X</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <eq></eq>
    <apply>
     <minus></minus>
     <ci>lift</ci>
     <ci>choice</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">X</csymbol>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{lift-choice}[\lambda F.X]=\operatorname{lift-choice}[X]
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="Lambda_lifting:52">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>lift</mi>
     <mo>-</mo>
     <mi>choice</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>M</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>≠</mo>
   <mo>none</mo>
   <mo>→</mo>
   <mrow>
    <mrow>
     <mi>lift</mi>
     <mo>-</mo>
     <mi>choice</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>M</mi>
      </mpadded>
      <mi>N</mi>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>lift</mi>
     <mo>-</mo>
     <mi>choice</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>M</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <neq></neq>
     <apply>
      <apply>
       <minus></minus>
       <ci>lift</ci>
       <ci>choice</ci>
      </apply>
      <ci>M</ci>
     </apply>
     <ci>none</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <apply>
       <minus></minus>
       <ci>lift</ci>
       <ci>choice</ci>
      </apply>
      <apply>
       <times></times>
       <ci>M</ci>
       <ci>N</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <apply>
       <minus></minus>
       <ci>lift</ci>
       <ci>choice</ci>
      </apply>
      <ci>M</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{lift-choice}[M]\neq\operatorname{none}\to\operatorname{lift-%
choice}[M\ N]=\operatorname{lift-choice}[M]
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="Lambda_lifting:53">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>lift</mi>
     <mo>-</mo>
     <mi>choice</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>M</mi>
      </mpadded>
      <mi>N</mi>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>lift</mi>
     <mo>-</mo>
     <mi>choice</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>N</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <minus></minus>
      <ci>lift</ci>
      <ci>choice</ci>
     </apply>
     <apply>
      <times></times>
      <ci>M</ci>
      <ci>N</ci>
     </apply>
    </apply>
    <apply>
     <apply>
      <minus></minus>
      <ci>lift</ci>
      <ci>choice</ci>
     </apply>
     <ci>N</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{lift-choice}[M\ N]=\operatorname{lift-choice}[N]
  </annotation>
 </semantics>
</math>


</li>
<li>

<math display="inline" id="Lambda_lifting:54">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>lift</mi>
     <mo>-</mo>
     <mi>choice</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>V</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mo>none</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <minus></minus>
      <ci>lift</ci>
      <ci>choice</ci>
     </apply>
     <ci>V</ci>
    </apply>
    <ci>none</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{lift-choice}[V]=\operatorname{none}
  </annotation>
 </semantics>
</math>

</li>
</ol>

<p>For example,</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>Lambda choice on 

<math display="inline" id="Lambda_lifting:55">
 <semantics>
  <mrow>
   <mi>λ</mi>
   <mi>f</mi>
   <mo>.</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>x</mi>
    <mo>.</mo>
    <mpadded width="+5pt">
     <mi>f</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mpadded width="+5pt">
      <mi>x</mi>
     </mpadded>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo rspace="7.5pt" stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>y</mi>
    <mo>.</mo>
    <mpadded width="+5pt">
     <mi>f</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mpadded width="+5pt">
      <mi>y</mi>
     </mpadded>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">f</csymbol>
    <ci>normal-.</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">f</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">f</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">y</csymbol>
      <csymbol cd="unknown">y</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda f.(\lambda x.f\ (x\ x))\ (\lambda y.f\ (y\ y))
  </annotation>
 </semantics>
</math>

 is 

<math display="inline" id="Lambda_lifting:56">
 <semantics>
  <mrow>
   <mrow>
    <mi>λ</mi>
    <mi>x</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mpadded width="+5pt">
     <mi>f</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>x</mi>
      </mpadded>
      <mi>x</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <ci>f</ci>
     <apply>
      <times></times>
      <ci>x</ci>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda x.f\ (x\ x)
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Rule</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>2</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>3</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>1</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>Lambda choice on 

<math display="inline" id="Lambda_lifting:57">
 <semantics>
  <mrow>
   <mrow>
    <mi>λ</mi>
    <mi>f</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>p</mi>
      </mpadded>
      <mi>f</mi>
     </mrow>
     <mo rspace="7.5pt" stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>p</mi>
      </mpadded>
      <mi>f</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>f</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <times></times>
      <ci>p</ci>
      <ci>f</ci>
     </apply>
     <apply>
      <times></times>
      <ci>p</ci>
      <ci>f</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda f.(p\ f)\ (p\ f)
  </annotation>
 </semantics>
</math>

 is 

<math display="inline" id="Lambda_lifting:58">
 <semantics>
  <mrow>
   <mrow>
    <mi>λ</mi>
    <mi>f</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>p</mi>
      </mpadded>
      <mi>f</mi>
     </mrow>
     <mo rspace="7.5pt" stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>p</mi>
      </mpadded>
      <mi>f</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>f</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <times></times>
      <ci>p</ci>
      <ci>f</ci>
     </apply>
     <apply>
      <times></times>
      <ci>p</ci>
      <ci>f</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda f.(p\ f)\ (p\ f)
  </annotation>
 </semantics>
</math>


</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Rule</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>2</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>2</p></td>
</tr>
</tbody>
</table>
<h5 id="choosing-named-and-anonymous-functions-for-lifting">Choosing named and anonymous functions for lifting</h5>

<p>Search for the deepest named or anonymous function definition, so that when the lift is applied the function lifted will become a simple equation. This definition recognizes a lambda abstraction with an actual parameter as defining a function. Only lambda abstractions without an application are treated as anonymous functions.</p>

<p><em>lambda-named</em> - A named function. An expression like 

<math display="inline" id="Lambda_lifting:59">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>F</mi>
    <mo>.</mo>
    <mi>M</mi>
    <mo rspace="7.5pt" stretchy="false">)</mo>
   </mrow>
   <mi>N</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">F</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">M</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">N</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\lambda F.M)\ N
  </annotation>
 </semantics>
</math>

 where M is lambda free and N is lambda free or an anonymous function.</p>

<p>

<math display="block" id="Lambda_lifting:60">
 <semantics>
  <mrow>
   <mrow>
    <mi>lambda</mi>
    <mo>-</mo>
    <mi>named</mi>
   </mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mi>F</mi>
     <mo>.</mo>
     <mi>M</mi>
     <mo rspace="7.5pt" stretchy="false">)</mo>
    </mrow>
    <mi>N</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>lambda</mi>
    <mo>-</mo>
    <mi>free</mi>
   </mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>M</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mi mathvariant="italic">and</mi>
   <mrow>
    <mi>lambda</mi>
    <mo>-</mo>
    <mi>anon</mi>
   </mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>N</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <minus></minus>
     <ci>lambda</ci>
     <ci>named</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">F</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">M</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <csymbol cd="unknown">N</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <eq></eq>
    <apply>
     <minus></minus>
     <ci>lambda</ci>
     <ci>free</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">M</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <csymbol cd="unknown">and</csymbol>
    <apply>
     <minus></minus>
     <ci>lambda</ci>
     <ci>anon</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">N</csymbol>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{lambda-named}[(\lambda F.M)\ N]=\operatorname{lambda-free}[M]%
\and\operatorname{lambda-anon}[N]
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Lambda_lifting:61">
 <semantics>
  <mrow>
   <mrow>
    <mi>lambda</mi>
    <mo>-</mo>
    <mi>named</mi>
   </mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>λ</mi>
    <mi>F</mi>
    <mo>.</mo>
    <mi>X</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>=</mo>
   <mo>false</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <minus></minus>
     <ci>lambda</ci>
     <ci>named</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">F</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">X</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <eq></eq>
    <ci>false</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{lambda-named}[\lambda F.X]=\operatorname{false}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Lambda_lifting:62">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>lambda</mi>
     <mo>-</mo>
     <mi>named</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>V</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mo>false</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <minus></minus>
      <ci>lambda</ci>
      <ci>named</ci>
     </apply>
     <ci>V</ci>
    </apply>
    <ci>false</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{lambda-named}[V]=\operatorname{false}
  </annotation>
 </semantics>
</math>

</p>

<p><em>lift-choice</em> - The first anonymous or named function found in traversing the expression or <em>none</em> if there is no function.</p>
<ol>
<li>

<math display="inline" id="Lambda_lifting:63">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mi>lambda</mi>
      <mo>-</mo>
      <mi>named</mi>
     </mrow>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>X</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mrow>
     <mrow>
      <mi>lambda</mi>
      <mo>-</mo>
      <mi>anon</mi>
     </mrow>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>X</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mrow>
     <mi>lift</mi>
     <mo>-</mo>
     <mi>choice</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>X</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>X</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <times></times>
      <apply>
       <apply>
        <minus></minus>
        <ci>lambda</ci>
        <ci>named</ci>
       </apply>
       <ci>X</ci>
      </apply>
      <apply>
       <apply>
        <minus></minus>
        <ci>lambda</ci>
        <ci>anon</ci>
       </apply>
       <ci>X</ci>
      </apply>
     </apply>
     <apply>
      <apply>
       <minus></minus>
       <ci>lift</ci>
       <ci>choice</ci>
      </apply>
      <ci>X</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <ci>X</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{lambda-named}[X]\operatorname{lambda-anon}[X]\to\operatorname{%
lift-choice}[X]=X
  </annotation>
 </semantics>
</math>


</li>
<li>

<math display="inline" id="Lambda_lifting:64">
 <semantics>
  <mrow>
   <mrow>
    <mi>lift</mi>
    <mo>-</mo>
    <mi>choice</mi>
   </mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>λ</mi>
    <mi>F</mi>
    <mo>.</mo>
    <mi>X</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>lift</mi>
    <mo>-</mo>
    <mi>choice</mi>
   </mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>X</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <minus></minus>
     <ci>lift</ci>
     <ci>choice</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">F</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">X</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <eq></eq>
    <apply>
     <minus></minus>
     <ci>lift</ci>
     <ci>choice</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">X</csymbol>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{lift-choice}[\lambda F.X]=\operatorname{lift-choice}[X]
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="Lambda_lifting:65">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>lift</mi>
     <mo>-</mo>
     <mi>choice</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>M</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>≠</mo>
   <mo>none</mo>
   <mo>→</mo>
   <mrow>
    <mrow>
     <mi>lift</mi>
     <mo>-</mo>
     <mi>choice</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>M</mi>
      </mpadded>
      <mi>N</mi>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>lift</mi>
     <mo>-</mo>
     <mi>choice</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>M</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <neq></neq>
     <apply>
      <apply>
       <minus></minus>
       <ci>lift</ci>
       <ci>choice</ci>
      </apply>
      <ci>M</ci>
     </apply>
     <ci>none</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <apply>
       <minus></minus>
       <ci>lift</ci>
       <ci>choice</ci>
      </apply>
      <apply>
       <times></times>
       <ci>M</ci>
       <ci>N</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <apply>
       <minus></minus>
       <ci>lift</ci>
       <ci>choice</ci>
      </apply>
      <ci>M</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{lift-choice}[M]\neq\operatorname{none}\to\operatorname{lift-%
choice}[M\ N]=\operatorname{lift-choice}[M]
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="Lambda_lifting:66">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>lift</mi>
     <mo>-</mo>
     <mi>choice</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>M</mi>
      </mpadded>
      <mi>N</mi>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>lift</mi>
     <mo>-</mo>
     <mi>choice</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>N</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <minus></minus>
      <ci>lift</ci>
      <ci>choice</ci>
     </apply>
     <apply>
      <times></times>
      <ci>M</ci>
      <ci>N</ci>
     </apply>
    </apply>
    <apply>
     <apply>
      <minus></minus>
      <ci>lift</ci>
      <ci>choice</ci>
     </apply>
     <ci>N</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{lift-choice}[M\ N]=\operatorname{lift-choice}[N]
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="Lambda_lifting:67">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>lift</mi>
     <mo>-</mo>
     <mi>choice</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>V</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mo>none</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <minus></minus>
      <ci>lift</ci>
      <ci>choice</ci>
     </apply>
     <ci>V</ci>
    </apply>
    <ci>none</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{lift-choice}[V]=\operatorname{none}
  </annotation>
 </semantics>
</math>

</li>
</ol>

<p>For example,</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>Lambda choice on 

<math display="inline" id="Lambda_lifting:68">
 <semantics>
  <mrow>
   <mi>λ</mi>
   <mi>f</mi>
   <mo>.</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>x</mi>
    <mo>.</mo>
    <mpadded width="+5pt">
     <mi>f</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mpadded width="+5pt">
      <mi>x</mi>
     </mpadded>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo rspace="7.5pt" stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>y</mi>
    <mo>.</mo>
    <mpadded width="+5pt">
     <mi>f</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mpadded width="+5pt">
      <mi>y</mi>
     </mpadded>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">f</csymbol>
    <ci>normal-.</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">f</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">f</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">y</csymbol>
      <csymbol cd="unknown">y</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda f.(\lambda x.f\ (x\ x))\ (\lambda y.f\ (y\ y))
  </annotation>
 </semantics>
</math>


 is 

<math display="inline" id="Lambda_lifting:69">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>x</mi>
    <mo>.</mo>
    <mpadded width="+5pt">
     <mi>f</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mpadded width="+5pt">
      <mi>x</mi>
     </mpadded>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo rspace="7.5pt" stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>y</mi>
    <mo>.</mo>
    <mpadded width="+5pt">
     <mi>f</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mpadded width="+5pt">
      <mi>y</mi>
     </mpadded>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">f</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">f</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">y</csymbol>
      <csymbol cd="unknown">y</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\lambda x.f\ (x\ x))\ (\lambda y.f\ (y\ y))
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Rule</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>2</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>1</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>Lambda choice on 

<math display="inline" id="Lambda_lifting:70">
 <semantics>
  <mrow>
   <mrow>
    <mi>λ</mi>
    <mi>f</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mpadded width="+5pt">
     <mi>f</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mpadded width="+5pt">
         <mi>x</mi>
        </mpadded>
        <mi>f</mi>
       </mrow>
       <mo rspace="7.5pt" stretchy="false">)</mo>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mpadded width="+5pt">
         <mi>x</mi>
        </mpadded>
        <mi>f</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>f</ci>
    </apply>
    <apply>
     <times></times>
     <ci>f</ci>
     <apply>
      <times></times>
      <apply>
       <times></times>
       <ci>x</ci>
       <ci>f</ci>
      </apply>
      <apply>
       <times></times>
       <ci>x</ci>
       <ci>f</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda f.f\ ((x\ f)\ (x\ f))
  </annotation>
 </semantics>
</math>

 is 

<math display="inline" id="Lambda_lifting:71">
 <semantics>
  <mrow>
   <mrow>
    <mi>λ</mi>
    <mi>f</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mpadded width="+5pt">
     <mi>f</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mpadded width="+5pt">
         <mi>x</mi>
        </mpadded>
        <mi>f</mi>
       </mrow>
       <mo rspace="7.5pt" stretchy="false">)</mo>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mpadded width="+5pt">
         <mi>x</mi>
        </mpadded>
        <mi>f</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>f</ci>
    </apply>
    <apply>
     <times></times>
     <ci>f</ci>
     <apply>
      <times></times>
      <apply>
       <times></times>
       <ci>x</ci>
       <ci>f</ci>
      </apply>
      <apply>
       <times></times>
       <ci>x</ci>
       <ci>f</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda f.f\ ((x\ f)\ (x\ f))
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Rule</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>1</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
<h3 id="examples">Examples</h3>

<p>For example the <a href="Fixed-point_combinator" title="wikilink">Y combinator</a>,</p>

<p>

<math display="block" id="Lambda_lifting:72">
 <semantics>
  <mrow>
   <mi>λ</mi>
   <mi>f</mi>
   <mo>.</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>x</mi>
    <mo>.</mo>
    <mpadded width="+5pt">
     <mi>f</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mpadded width="+5pt">
      <mi>x</mi>
     </mpadded>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo rspace="7.5pt" stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>x</mi>
    <mo>.</mo>
    <mpadded width="+5pt">
     <mi>f</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mpadded width="+5pt">
      <mi>x</mi>
     </mpadded>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">f</csymbol>
    <ci>normal-.</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">f</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">f</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda f.(\lambda x.f\ (x\ x))\ (\lambda x.f\ (x\ x))
  </annotation>
 </semantics>
</math>

 is lifted as,</p>

<p>

<math display="block" id="Lambda_lifting:73">
 <semantics>
  <mrow>
   <mrow>
    <mo>let</mo>
    <mrow>
     <mpadded width="+5pt">
      <mi>x</mi>
     </mpadded>
     <mpadded width="+5pt">
      <mi>f</mi>
     </mpadded>
     <mi>y</mi>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mpadded width="+5pt">
     <mi>f</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>y</mi>
      </mpadded>
      <mi>y</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi mathvariant="italic">and</mi>
    <mpadded width="+5pt">
     <mi>q</mi>
    </mpadded>
    <mpadded width="+5pt">
     <mi>x</mi>
    </mpadded>
    <mi>f</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mpadded width="+5pt">
     <mi>f</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mpadded width="+5pt">
         <mi>x</mi>
        </mpadded>
        <mi>f</mi>
       </mrow>
       <mo rspace="7.5pt" stretchy="false">)</mo>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mpadded width="+5pt">
         <mi>x</mi>
        </mpadded>
        <mi>f</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo>in</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>q</mi>
      </mpadded>
      <mi>x</mi>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <ci>let</ci>
      <apply>
       <times></times>
       <ci>x</ci>
       <ci>f</ci>
       <ci>y</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <apply>
       <times></times>
       <ci>y</ci>
       <ci>y</ci>
      </apply>
      <ci>italic- and</ci>
      <ci>q</ci>
      <ci>x</ci>
      <ci>f</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>f</ci>
      <apply>
       <times></times>
       <apply>
        <times></times>
        <ci>x</ci>
        <ci>f</ci>
       </apply>
       <apply>
        <times></times>
        <ci>x</ci>
        <ci>f</ci>
       </apply>
      </apply>
      <apply>
       <ci>in</ci>
       <apply>
        <times></times>
        <ci>q</ci>
        <ci>x</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{let}x\ f\ y=f\ (y\ y)\and q\ x\ f=f\ ((x\ f)\ (x\ f))%
\operatorname{in}q\ x
  </annotation>
 </semantics>
</math>

 and after <a href="#Parameter_dropping" title="wikilink">Parameter dropping</a>,</p>

<p>

<math display="block" id="Lambda_lifting:74">
 <semantics>
  <mrow>
   <mrow>
    <mo>let</mo>
    <mrow>
     <mpadded width="+5pt">
      <mi>x</mi>
     </mpadded>
     <mpadded width="+5pt">
      <mi>f</mi>
     </mpadded>
     <mi>y</mi>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mpadded width="+5pt">
     <mi>f</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>y</mi>
      </mpadded>
      <mi>y</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi mathvariant="italic">and</mi>
    <mpadded width="+5pt">
     <mi>q</mi>
    </mpadded>
    <mi>f</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mpadded width="+5pt">
     <mi>f</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mpadded width="+5pt">
         <mi>x</mi>
        </mpadded>
        <mi>f</mi>
       </mrow>
       <mo rspace="7.5pt" stretchy="false">)</mo>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mpadded width="+5pt">
         <mi>x</mi>
        </mpadded>
        <mi>f</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo>in</mo>
     <mi>q</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <ci>let</ci>
      <apply>
       <times></times>
       <ci>x</ci>
       <ci>f</ci>
       <ci>y</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <apply>
       <times></times>
       <ci>y</ci>
       <ci>y</ci>
      </apply>
      <ci>italic- and</ci>
      <ci>q</ci>
      <ci>f</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>f</ci>
      <apply>
       <times></times>
       <apply>
        <times></times>
        <ci>x</ci>
        <ci>f</ci>
       </apply>
       <apply>
        <times></times>
        <ci>x</ci>
        <ci>f</ci>
       </apply>
      </apply>
      <apply>
       <ci>in</ci>
       <ci>q</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{let}x\ f\ y=f\ (y\ y)\and q\ f=f\ ((x\ f)\ (x\ f))\operatorname{%
in}q
  </annotation>
 </semantics>
</math>

 As a lambda expression (see <a href="Let_expression#Conversion_from_let_to_lambda_expressions" title="wikilink">Conversion from let to lambda expressions</a>),</p>

<p>

<math display="block" id="Lambda_lifting:75">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>x</mi>
    <mo>.</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mi>q</mi>
     <mo>.</mo>
     <mi>q</mi>
     <mo rspace="7.5pt" stretchy="false">)</mo>
    </mrow>
    <mi>λ</mi>
    <mi>f</mi>
    <mo>.</mo>
    <mpadded width="+5pt">
     <mi>f</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mpadded width="+5pt">
      <mi>x</mi>
     </mpadded>
     <mi>f</mi>
     <mo rspace="7.5pt" stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mpadded width="+5pt">
      <mi>x</mi>
     </mpadded>
     <mi>f</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo rspace="7.5pt" stretchy="false">)</mo>
   </mrow>
   <mi>λ</mi>
   <mi>f</mi>
   <mo>.</mo>
   <mi>λ</mi>
   <mi>y</mi>
   <mo>.</mo>
   <mpadded width="+5pt">
    <mi>f</mi>
   </mpadded>
   <mrow>
    <mo stretchy="false">(</mo>
    <mpadded width="+5pt">
     <mi>y</mi>
    </mpadded>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-.</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">q</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">q</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">f</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">f</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <csymbol cd="unknown">f</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <csymbol cd="unknown">f</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">f</csymbol>
    <ci>normal-.</ci>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">y</csymbol>
    <ci>normal-.</ci>
    <csymbol cd="unknown">f</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">y</csymbol>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\lambda x.(\lambda q.q)\ \lambda f.f\ (x\ f)\ (x\ f))\ \lambda f.\lambda y.f%
\ (y\ y)
  </annotation>
 </semantics>
</math>

</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>Lifting named and anonymous functions</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>1</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>2</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>3</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>4</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>5</p></td>
</tr>
</tbody>
</table>

<p>If lifting anonymous functions only, the Y combinator is,</p>

<p>

<math display="block" id="Lambda_lifting:76">
 <semantics>
  <mrow>
   <mrow>
    <mo>let</mo>
    <mrow>
     <mpadded width="+5pt">
      <mi>p</mi>
     </mpadded>
     <mpadded width="+5pt">
      <mi>f</mi>
     </mpadded>
     <mi>x</mi>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mpadded width="+5pt">
     <mi>f</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>x</mi>
      </mpadded>
      <mi>x</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi mathvariant="italic">and</mi>
    <mpadded width="+5pt">
     <mi>q</mi>
    </mpadded>
    <mpadded width="+5pt">
     <mi>p</mi>
    </mpadded>
    <mi>f</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>p</mi>
      </mpadded>
      <mi>f</mi>
     </mrow>
     <mo rspace="7.5pt" stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>p</mi>
      </mpadded>
      <mi>f</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo>in</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>q</mi>
      </mpadded>
      <mi>p</mi>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <ci>let</ci>
      <apply>
       <times></times>
       <ci>p</ci>
       <ci>f</ci>
       <ci>x</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <apply>
       <times></times>
       <ci>x</ci>
       <ci>x</ci>
      </apply>
      <ci>italic- and</ci>
      <ci>q</ci>
      <ci>p</ci>
      <ci>f</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <times></times>
       <ci>p</ci>
       <ci>f</ci>
      </apply>
      <apply>
       <times></times>
       <ci>p</ci>
       <ci>f</ci>
      </apply>
      <apply>
       <ci>in</ci>
       <apply>
        <times></times>
        <ci>q</ci>
        <ci>p</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{let}p\ f\ x=f\ (x\ x)\and q\ p\ f=(p\ f)\ (p\ f)\operatorname{in%
}q\ p
  </annotation>
 </semantics>
</math>

 and after <a href="#Parameter_dropping" title="wikilink">Parameter dropping</a>,</p>

<p>

<math display="block" id="Lambda_lifting:77">
 <semantics>
  <mrow>
   <mrow>
    <mo>let</mo>
    <mrow>
     <mpadded width="+5pt">
      <mi>p</mi>
     </mpadded>
     <mpadded width="+5pt">
      <mi>f</mi>
     </mpadded>
     <mi>x</mi>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mpadded width="+5pt">
     <mi>f</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>x</mi>
      </mpadded>
      <mi>x</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi mathvariant="italic">and</mi>
    <mpadded width="+5pt">
     <mi>q</mi>
    </mpadded>
    <mi>f</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>p</mi>
      </mpadded>
      <mi>f</mi>
     </mrow>
     <mo rspace="7.5pt" stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>p</mi>
      </mpadded>
      <mi>f</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo>in</mo>
     <mi>q</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <ci>let</ci>
      <apply>
       <times></times>
       <ci>p</ci>
       <ci>f</ci>
       <ci>x</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <apply>
       <times></times>
       <ci>x</ci>
       <ci>x</ci>
      </apply>
      <ci>italic- and</ci>
      <ci>q</ci>
      <ci>f</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <times></times>
       <ci>p</ci>
       <ci>f</ci>
      </apply>
      <apply>
       <times></times>
       <ci>p</ci>
       <ci>f</ci>
      </apply>
      <apply>
       <ci>in</ci>
       <ci>q</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{let}p\ f\ x=f\ (x\ x)\and q\ f=(p\ f)\ (p\ f)\operatorname{in}q
  </annotation>
 </semantics>
</math>

 As a lambda expression,</p>

<p>

<math display="block" id="Lambda_lifting:78">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>p</mi>
    <mo>.</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mi>q</mi>
     <mo>.</mo>
     <mi>q</mi>
     <mo rspace="7.5pt" stretchy="false">)</mo>
    </mrow>
    <mi>λ</mi>
    <mi>f</mi>
    <mo>.</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mpadded width="+5pt">
      <mi>p</mi>
     </mpadded>
     <mi>f</mi>
     <mo rspace="7.5pt" stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mpadded width="+5pt">
      <mi>p</mi>
     </mpadded>
     <mi>f</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo rspace="7.5pt" stretchy="false">)</mo>
   </mrow>
   <mi>λ</mi>
   <mi>f</mi>
   <mo>.</mo>
   <mi>λ</mi>
   <mi>x</mi>
   <mo>.</mo>
   <mpadded width="+5pt">
    <mi>f</mi>
   </mpadded>
   <mrow>
    <mo stretchy="false">(</mo>
    <mpadded width="+5pt">
     <mi>x</mi>
    </mpadded>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">p</csymbol>
     <ci>normal-.</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">q</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">q</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">f</csymbol>
     <ci>normal-.</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">p</csymbol>
      <csymbol cd="unknown">f</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">p</csymbol>
      <csymbol cd="unknown">f</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">f</csymbol>
    <ci>normal-.</ci>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <ci>normal-.</ci>
    <csymbol cd="unknown">f</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\lambda p.(\lambda q.q)\ \lambda f.(p\ f)\ (p\ f))\ \lambda f.\lambda x.f\ (x%
\ x)
  </annotation>
 </semantics>
</math>

</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>Lifting anonymous functions only</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>1</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>2</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>3</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>4</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>5</p></td>
</tr>
</tbody>
</table>

<p>The first sub expression to be chosen for lifting is 

<math display="inline" id="Lambda_lifting:79">
 <semantics>
  <mrow>
   <mrow>
    <mi>λ</mi>
    <mi>x</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mpadded width="+5pt">
     <mi>f</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>x</mi>
      </mpadded>
      <mi>x</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <ci>f</ci>
     <apply>
      <times></times>
      <ci>x</ci>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda x.f\ (x\ x)
  </annotation>
 </semantics>
</math>

. This transforms the lambda expression into 

<math display="inline" id="Lambda_lifting:80">
 <semantics>
  <mrow>
   <mrow>
    <mi>λ</mi>
    <mi>f</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>p</mi>
      </mpadded>
      <mi>f</mi>
     </mrow>
     <mo rspace="7.5pt" stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>p</mi>
      </mpadded>
      <mi>f</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>f</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <times></times>
      <ci>p</ci>
      <ci>f</ci>
     </apply>
     <apply>
      <times></times>
      <ci>p</ci>
      <ci>f</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda f.(p\ f)\ (p\ f)
  </annotation>
 </semantics>
</math>

 and creates the equation 

<math display="inline" id="Lambda_lifting:81">
 <semantics>
  <mrow>
   <mrow>
    <mpadded width="+5pt">
     <mi>p</mi>
    </mpadded>
    <mpadded width="+5pt">
     <mi>f</mi>
    </mpadded>
    <mi>x</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>x</mi>
      </mpadded>
      <mi>x</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>p</ci>
     <ci>f</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <ci>f</ci>
     <apply>
      <times></times>
      <ci>x</ci>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\ f\ x=f(x\ x)
  </annotation>
 </semantics>
</math>

.</p>

<p>The second sub expression to be chosen for lifting is 

<math display="inline" id="Lambda_lifting:82">
 <semantics>
  <mrow>
   <mrow>
    <mi>λ</mi>
    <mi>f</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>p</mi>
      </mpadded>
      <mi>f</mi>
     </mrow>
     <mo rspace="7.5pt" stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>p</mi>
      </mpadded>
      <mi>f</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>f</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <times></times>
      <ci>p</ci>
      <ci>f</ci>
     </apply>
     <apply>
      <times></times>
      <ci>p</ci>
      <ci>f</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda f.(p\ f)\ (p\ f)
  </annotation>
 </semantics>
</math>

. This transforms the lambda expression into 

<math display="inline" id="Lambda_lifting:83">
 <semantics>
  <mrow>
   <mpadded width="+5pt">
    <mi>q</mi>
   </mpadded>
   <mi>p</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>q</ci>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q\ p
  </annotation>
 </semantics>
</math>


 and creates the equation 

<math display="inline" id="Lambda_lifting:84">
 <semantics>
  <mrow>
   <mrow>
    <mpadded width="+5pt">
     <mi>q</mi>
    </mpadded>
    <mpadded width="+5pt">
     <mi>p</mi>
    </mpadded>
    <mi>f</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>p</mi>
      </mpadded>
      <mi>f</mi>
     </mrow>
     <mo rspace="7.5pt" stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>p</mi>
      </mpadded>
      <mi>f</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>q</ci>
     <ci>p</ci>
     <ci>f</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <times></times>
      <ci>p</ci>
      <ci>f</ci>
     </apply>
     <apply>
      <times></times>
      <ci>p</ci>
      <ci>f</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q\ p\ f=(p\ f)\ (p\ f)
  </annotation>
 </semantics>
</math>

.</p>

<p>And the result is,</p>

<p>

<math display="block" id="Lambda_lifting:85">
 <semantics>
  <mrow>
   <mrow>
    <mo>let</mo>
    <mrow>
     <mpadded width="+5pt">
      <mi>p</mi>
     </mpadded>
     <mpadded width="+5pt">
      <mi>f</mi>
     </mpadded>
     <mi>x</mi>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mpadded width="+5pt">
     <mi>f</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>x</mi>
      </mpadded>
      <mi>x</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi mathvariant="italic">and</mi>
    <mpadded width="+5pt">
     <mi>q</mi>
    </mpadded>
    <mpadded width="+5pt">
     <mi>p</mi>
    </mpadded>
    <mi>f</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>p</mi>
      </mpadded>
      <mi>f</mi>
     </mrow>
     <mo rspace="7.5pt" stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>p</mi>
      </mpadded>
      <mi>f</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo>in</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>q</mi>
      </mpadded>
      <mi>p</mi>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <ci>let</ci>
      <apply>
       <times></times>
       <ci>p</ci>
       <ci>f</ci>
       <ci>x</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <apply>
       <times></times>
       <ci>x</ci>
       <ci>x</ci>
      </apply>
      <ci>italic- and</ci>
      <ci>q</ci>
      <ci>p</ci>
      <ci>f</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <times></times>
       <ci>p</ci>
       <ci>f</ci>
      </apply>
      <apply>
       <times></times>
       <ci>p</ci>
       <ci>f</ci>
      </apply>
      <apply>
       <ci>in</ci>
       <apply>
        <times></times>
        <ci>q</ci>
        <ci>p</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{let}p\ f\ x=f\ (x\ x)\and q\ p\ f=(p\ f)\ (p\ f)\operatorname{in%
}q\ p
  </annotation>
 </semantics>
</math>

</p>

<p>Surprisingly this result is simpler than the one obtained from lifting named functions.</p>
<h3 id="execution">Execution</h3>

<p>Apply function to,</p>

<p>

<math display="block" id="Lambda_lifting:86">
 <semantics>
  <mi>K</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>K</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K
  </annotation>
 </semantics>
</math>

</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>

<math display="inline" id="Lambda_lifting:87">
 <semantics>
  <mrow>
   <mi>λ</mi>
   <mi>f</mi>
   <mo>.</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>x</mi>
    <mo>.</mo>
    <mpadded width="+5pt">
     <mi>f</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mpadded width="+5pt">
      <mi>x</mi>
     </mpadded>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo rspace="7.5pt" stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>x</mi>
    <mo>.</mo>
    <mpadded width="+5pt">
     <mi>f</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mpadded width="+5pt">
      <mi>x</mi>
     </mpadded>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo rspace="7.5pt" stretchy="false">)</mo>
   </mrow>
   <mi>K</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">f</csymbol>
    <ci>normal-.</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">f</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">f</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">K</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda f.(\lambda x.f\ (x\ x))\ (\lambda x.f\ (x\ x))\ K
  </annotation>
 </semantics>
</math>

</p></th>
<th style="text-align: left;">
<p>

<math display="inline" id="Lambda_lifting:88">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>let</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>p</mi>
      </mpadded>
      <mpadded width="+5pt">
       <mi>f</mi>
      </mpadded>
      <mi>x</mi>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mpadded width="+5pt">
      <mi>f</mi>
     </mpadded>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mpadded width="+5pt">
        <mi>x</mi>
       </mpadded>
       <mi>x</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi mathvariant="italic">and</mi>
     <mpadded width="+5pt">
      <mi>q</mi>
     </mpadded>
     <mpadded width="+5pt">
      <mi>p</mi>
     </mpadded>
     <mi>f</mi>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mpadded width="+5pt">
        <mi>p</mi>
       </mpadded>
       <mi>f</mi>
      </mrow>
      <mo rspace="7.5pt" stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mpadded width="+5pt">
        <mi>p</mi>
       </mpadded>
       <mi>f</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo>in</mo>
      <mrow>
       <mpadded width="+5pt">
        <mi>q</mi>
       </mpadded>
       <mi>p</mi>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mi>K</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <and></and>
     <apply>
      <eq></eq>
      <apply>
       <ci>let</ci>
       <apply>
        <times></times>
        <ci>p</ci>
        <ci>f</ci>
        <ci>x</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>f</ci>
       <apply>
        <times></times>
        <ci>x</ci>
        <ci>x</ci>
       </apply>
       <ci>italic- and</ci>
       <ci>q</ci>
       <ci>p</ci>
       <ci>f</ci>
      </apply>
     </apply>
     <apply>
      <eq></eq>
      <share href="#.cmml">
      </share>
      <apply>
       <times></times>
       <apply>
        <times></times>
        <ci>p</ci>
        <ci>f</ci>
       </apply>
       <apply>
        <times></times>
        <ci>p</ci>
        <ci>f</ci>
       </apply>
       <apply>
        <ci>in</ci>
        <apply>
         <times></times>
         <ci>q</ci>
         <ci>p</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <ci>K</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{let}p\ f\ x=f\ (x\ x)\and q\ p\ f=(p\ f)\ (p\ f)\operatorname{in%
}q\ p\ \ K
  </annotation>
 </semantics>
</math>


</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>

<math display="inline" id="Lambda_lifting:89">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>x</mi>
    <mo>.</mo>
    <mpadded width="+5pt">
     <mi>K</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mpadded width="+5pt">
      <mi>x</mi>
     </mpadded>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo rspace="7.5pt" stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>x</mi>
    <mo>.</mo>
    <mpadded width="+5pt">
     <mi>K</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mpadded width="+5pt">
      <mi>x</mi>
     </mpadded>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">K</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">K</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\lambda x.K\ (x\ x))\ (\lambda x.K\ (x\ x))
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Lambda_lifting:90">
 <semantics>
  <mrow>
   <mrow>
    <mo>let</mo>
    <mrow>
     <mpadded width="+5pt">
      <mi>p</mi>
     </mpadded>
     <mpadded width="+5pt">
      <mi>f</mi>
     </mpadded>
     <mi>x</mi>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mpadded width="+5pt">
     <mi>f</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>x</mi>
      </mpadded>
      <mi>x</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi mathvariant="italic">and</mi>
    <mpadded width="+5pt">
     <mi>q</mi>
    </mpadded>
    <mpadded width="+5pt">
     <mi>p</mi>
    </mpadded>
    <mi>f</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>p</mi>
      </mpadded>
      <mi>f</mi>
     </mrow>
     <mo rspace="7.5pt" stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>p</mi>
      </mpadded>
      <mi>f</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo>in</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>p</mi>
      </mpadded>
      <mpadded width="+5pt">
       <mi>K</mi>
      </mpadded>
     </mrow>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>p</mi>
      </mpadded>
      <mi>K</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <ci>let</ci>
      <apply>
       <times></times>
       <ci>p</ci>
       <ci>f</ci>
       <ci>x</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <apply>
       <times></times>
       <ci>x</ci>
       <ci>x</ci>
      </apply>
      <ci>italic- and</ci>
      <ci>q</ci>
      <ci>p</ci>
      <ci>f</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <times></times>
       <ci>p</ci>
       <ci>f</ci>
      </apply>
      <apply>
       <times></times>
       <ci>p</ci>
       <ci>f</ci>
      </apply>
      <apply>
       <ci>in</ci>
       <apply>
        <times></times>
        <ci>p</ci>
        <ci>K</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>p</ci>
       <ci>K</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{let}p\ f\ x=f\ (x\ x)\and q\ p\ f=(p\ f)\ (p\ f)\operatorname{in%
}p\ K\ (p\ K)
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>

<math display="inline" id="Lambda_lifting:91">
 <semantics>
  <mrow>
   <mpadded width="+5pt">
    <mi>K</mi>
   </mpadded>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mi>x</mi>
     <mo>.</mo>
     <mpadded width="+5pt">
      <mi>K</mi>
     </mpadded>
     <mrow>
      <mo stretchy="false">(</mo>
      <mpadded width="+5pt">
       <mi>x</mi>
      </mpadded>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo rspace="7.5pt" stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mi>x</mi>
     <mo>.</mo>
     <mpadded width="+5pt">
      <mi>K</mi>
     </mpadded>
     <mrow>
      <mo stretchy="false">(</mo>
      <mpadded width="+5pt">
       <mi>x</mi>
      </mpadded>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">K</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">K</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">x</csymbol>
       <csymbol cd="unknown">x</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">K</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">x</csymbol>
       <csymbol cd="unknown">x</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K\ ((\lambda x.K\ (x\ x))\ (\lambda x.K\ (x\ x)))
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Lambda_lifting:92">
 <semantics>
  <mrow>
   <mrow>
    <mo>let</mo>
    <mrow>
     <mpadded width="+5pt">
      <mi>p</mi>
     </mpadded>
     <mpadded width="+5pt">
      <mi>f</mi>
     </mpadded>
     <mi>x</mi>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mpadded width="+5pt">
     <mi>f</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>x</mi>
      </mpadded>
      <mi>x</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi mathvariant="italic">and</mi>
    <mpadded width="+5pt">
     <mi>q</mi>
    </mpadded>
    <mpadded width="+5pt">
     <mi>p</mi>
    </mpadded>
    <mi>f</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mpadded width="+5pt">
     <mi>p</mi>
    </mpadded>
    <mpadded width="+5pt">
     <mi>f</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>p</mi>
      </mpadded>
      <mi>f</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo>in</mo>
     <mpadded width="+5pt">
      <mi>K</mi>
     </mpadded>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>p</mi>
      </mpadded>
      <mpadded width="+5pt">
       <mi>K</mi>
      </mpadded>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mpadded width="+5pt">
         <mi>p</mi>
        </mpadded>
        <mi>K</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <ci>let</ci>
      <apply>
       <times></times>
       <ci>p</ci>
       <ci>f</ci>
       <ci>x</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <apply>
       <times></times>
       <ci>x</ci>
       <ci>x</ci>
      </apply>
      <ci>italic- and</ci>
      <ci>q</ci>
      <ci>p</ci>
      <ci>f</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>p</ci>
      <ci>f</ci>
      <apply>
       <times></times>
       <ci>p</ci>
       <ci>f</ci>
      </apply>
      <apply>
       <ci>in</ci>
       <ci>K</ci>
      </apply>
      <apply>
       <times></times>
       <ci>p</ci>
       <ci>K</ci>
       <apply>
        <times></times>
        <ci>p</ci>
        <ci>K</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{let}p\ f\ x=f\ (x\ x)\and q\ p\ f=p\ f\ (p\ f)\operatorname{in}K%
\ (p\ K\ (p\ K))
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
</tbody>
</table>

<p>So,</p>
<ul>
<li>

<math display="inline" id="Lambda_lifting:93">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>x</mi>
    <mo>.</mo>
    <mpadded width="+5pt">
     <mi>K</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mpadded width="+5pt">
      <mi>x</mi>
     </mpadded>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo rspace="7.5pt" stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>x</mi>
    <mo>.</mo>
    <mpadded width="+5pt">
     <mi>K</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mpadded width="+5pt">
      <mi>x</mi>
     </mpadded>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mpadded width="+5pt">
    <mi>K</mi>
   </mpadded>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mi>x</mi>
     <mo>.</mo>
     <mpadded width="+5pt">
      <mi>K</mi>
     </mpadded>
     <mrow>
      <mo stretchy="false">(</mo>
      <mpadded width="+5pt">
       <mi>x</mi>
      </mpadded>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo rspace="7.5pt" stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mi>x</mi>
     <mo>.</mo>
     <mpadded width="+5pt">
      <mi>K</mi>
     </mpadded>
     <mrow>
      <mo stretchy="false">(</mo>
      <mpadded width="+5pt">
       <mi>x</mi>
      </mpadded>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">K</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">K</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">K</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">K</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">x</csymbol>
       <csymbol cd="unknown">x</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">K</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">x</csymbol>
       <csymbol cd="unknown">x</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-)</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\lambda x.K\ (x\ x))\ (\lambda x.K\ (x\ x))=K\ ((\lambda x.K\ (x\ x))\ (%
\lambda x.K\ (x\ x))))
  </annotation>
 </semantics>
</math>


</li>
</ul>

<p>or</p>
<ul>
<li>

<math display="inline" id="Lambda_lifting:94">
 <semantics>
  <mrow>
   <mrow>
    <mpadded width="+5pt">
     <mi>p</mi>
    </mpadded>
    <mpadded width="+5pt">
     <mi>K</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>p</mi>
      </mpadded>
      <mi>K</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mpadded width="+5pt">
     <mi>K</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>p</mi>
      </mpadded>
      <mpadded width="+5pt">
       <mi>K</mi>
      </mpadded>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mpadded width="+5pt">
         <mi>p</mi>
        </mpadded>
        <mi>K</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>p</ci>
     <ci>K</ci>
     <apply>
      <times></times>
      <ci>p</ci>
      <ci>K</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>K</ci>
     <apply>
      <times></times>
      <ci>p</ci>
      <ci>K</ci>
      <apply>
       <times></times>
       <ci>p</ci>
       <ci>K</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\ K\ (p\ K)=K\ (p\ K\ (p\ K))
  </annotation>
 </semantics>
</math>

</li>
</ul>

<p>The Y-Combinator calls its parameter (function) repeatedly on itself. The value is defined if the function has a <a href="Fixed_point_(mathematics)" title="wikilink">fixed point</a>. But the function will never terminate.</p>
<h2 id="lambda-dropping-in-lambda-calculus">Lambda dropping in lambda calculus</h2>

<p>Lambda dropping<ref> {{ cite book |</ref></p>

<p><code>first1 = Olivier | last1 = Danvy | first2 = Ulrik P. | last2 = Schultz |</code></p>

<p>title = Lambda-Dropping: Transforming Recursive Equations into Programs with Block Structure | year=2001 | url=<a class="uri" href="http://www.brics.dk/RS/99/27/BRICS-RS-99-27.pdf">http://www.brics.dk/RS/99/27/BRICS-RS-99-27.pdf</a> }}  is making the scope of functions smaller and using the context from the reduced scope to reduce the number of parameters to functions. Reducing the number of parameters makes functions easier to comprehend.</p>

<p>In the <a href="#Lambda_lifting" title="wikilink">Lambda lifting</a> section, a meta function for first lifting and then converting the resulting lambda expression into recursive equation was described. The Lamda Drop meta function performs the reverse by first converting recursive equations to lambda abstractions, and then dropping the resulting lambda expression, into the smallest scope which covers all references to the lambda abstraction.</p>

<p>Lambda dropping is performed in two steps,</p>
<ul>
<li><a href="#Abstraction_sinking" title="wikilink">Sinking</a></li>
<li><a href="#Parameter_dropping" title="wikilink">Parameter dropping</a></li>
</ul>
<h3 id="lambda-drop">Lambda drop</h3>

<p>A Lambda drop is applied to an expression which is part of a program. Dropping is controlled by a set of expressions from which the drop will be excluded.</p>

<p>

<math display="block" id="Lambda_lifting:95">
 <semantics>
  <mrow>
   <mrow>
    <mi>lambda</mi>
    <mo>-</mo>
    <mi>drop</mi>
    <mo>-</mo>
    <mi>op</mi>
   </mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>L</mi>
    <mo>,</mo>
    <mi>P</mi>
    <mo>,</mo>
    <mi>X</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>=</mo>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>L</mi>
    <mo>:=</mo>
    <mrow>
     <mi>drop</mi>
     <mo>-</mo>
     <mi>params</mi>
     <mo>-</mo>
     <mi>tran</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mi>sink</mi>
      <mo>-</mo>
      <mi>test</mi>
     </mrow>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>L</mi>
      <mo>,</mo>
      <mi>X</mi>
      <mo stretchy="false">]</mo>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <minus></minus>
     <ci>lambda</ci>
     <ci>drop</ci>
     <ci>op</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">L</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">P</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">X</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">L</csymbol>
     <csymbol cd="latexml">assign</csymbol>
     <apply>
      <minus></minus>
      <ci>drop</ci>
      <ci>params</ci>
      <ci>tran</ci>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-[</ci>
      <apply>
       <minus></minus>
       <ci>sink</ci>
       <ci>test</ci>
      </apply>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-[</ci>
       <csymbol cd="unknown">L</csymbol>
       <ci>normal-,</ci>
       <csymbol cd="unknown">X</csymbol>
       <ci>normal-]</ci>
      </cerror>
      <ci>normal-]</ci>
     </cerror>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{lambda-drop-op}[L,P,X]=P[L:=\operatorname{drop-params-tran}[%
\operatorname{sink-test}[L,X]]]
  </annotation>
 </semantics>
</math>

 where,</p>
<dl>
<dd><em>L</em> is the lambda abstraction to be dropped.
</dd>
<dd><em>P</em> is the program
</dd>
<dd><em>X</em> is a set of expressions to be excluded from dropping.
</dd>
</dl>
<h3 id="lambda-drop-transformation">Lambda drop transformation</h3>

<p>The lambda drop transformation sinks all abstractions in an expression. Sinking is excluded from expressions in a set of expressions,</p>

<p>

<math display="block" id="Lambda_lifting:96">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>lambda</mi>
     <mo>-</mo>
     <mi>drop</mi>
     <mo>-</mo>
     <mi>tran</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>L</mi>
     <mo>,</mo>
     <mi>X</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>drop</mi>
     <mo>-</mo>
     <mi>params</mi>
     <mo>-</mo>
     <mi>tran</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mrow>
       <mi>sink</mi>
       <mo>-</mo>
       <mi>tran</mi>
      </mrow>
      <mrow>
       <mo stretchy="false">[</mo>
       <mrow>
        <mrow>
         <mi>de</mi>
         <mo>-</mo>
         <mi>let</mi>
        </mrow>
        <mrow>
         <mo stretchy="false">[</mo>
         <mi>L</mi>
         <mo>,</mo>
         <mi>X</mi>
         <mo stretchy="false">]</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">]</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <minus></minus>
      <ci>lambda</ci>
      <ci>drop</ci>
      <ci>tran</ci>
     </apply>
     <ci>L</ci>
     <ci>X</ci>
    </apply>
    <apply>
     <apply>
      <minus></minus>
      <ci>drop</ci>
      <ci>params</ci>
      <ci>tran</ci>
     </apply>
     <apply>
      <apply>
       <minus></minus>
       <ci>sink</ci>
       <ci>tran</ci>
      </apply>
      <apply>
       <apply>
        <minus></minus>
        <ci>de</ci>
        <ci>let</ci>
       </apply>
       <ci>L</ci>
       <ci>X</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{lambda-drop-tran}[L,X]=\operatorname{drop-params-tran}[%
\operatorname{sink-tran}[\operatorname{de-let}[L,X]]]
  </annotation>
 </semantics>
</math>

 where,</p>
<dl>
<dd><em>L</em> is the expression to be transformed.
</dd>
<dd><em>X</em> is a set of sub expressions to be excluded from the dropping.
</dd>
</dl>

<p><em>sink-tran</em> sinks each abstraction, starting from the innermost,</p>

<p>

<math display="block" id="Lambda_lifting:97">
 <semantics>
  <mrow>
   <mrow>
    <mi>sink</mi>
    <mo>-</mo>
    <mi>tran</mi>
   </mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mi>N</mi>
     <mo>.</mo>
     <mi>B</mi>
     <mo rspace="7.5pt" stretchy="false">)</mo>
    </mrow>
    <mi>Y</mi>
    <mo>,</mo>
    <mi>X</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>sink</mi>
    <mo>-</mo>
    <mi>test</mi>
   </mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mi>N</mi>
     <mo>.</mo>
     <mrow>
      <mi>sink</mi>
      <mo>-</mo>
      <mi>tran</mi>
     </mrow>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>B</mi>
      <mo stretchy="false">]</mo>
     </mrow>
     <mo rspace="7.5pt" stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mi>sink</mi>
     <mo>-</mo>
     <mi>tran</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>Y</mi>
     <mo stretchy="false">]</mo>
    </mrow>
    <mo>,</mo>
    <mi>X</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <minus></minus>
     <ci>sink</ci>
     <ci>tran</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">N</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">B</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <csymbol cd="unknown">Y</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">X</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <eq></eq>
    <apply>
     <minus></minus>
     <ci>sink</ci>
     <ci>test</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">N</csymbol>
      <ci>normal-.</ci>
      <apply>
       <minus></minus>
       <ci>sink</ci>
       <ci>tran</ci>
      </apply>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-[</ci>
       <csymbol cd="unknown">B</csymbol>
       <ci>normal-]</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <apply>
      <minus></minus>
      <ci>sink</ci>
      <ci>tran</ci>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-[</ci>
      <csymbol cd="unknown">Y</csymbol>
      <ci>normal-]</ci>
     </cerror>
     <ci>normal-,</ci>
     <csymbol cd="unknown">X</csymbol>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{sink-tran}[(\lambda N.B)\ Y,X]=\operatorname{sink-test}[(\lambda
N%
.\operatorname{sink-tran}[B])\ \operatorname{sink-tran}[Y],X]
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Lambda_lifting:98">
 <semantics>
  <mrow>
   <mrow>
    <mi>sink</mi>
    <mo>-</mo>
    <mi>tran</mi>
   </mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>λ</mi>
    <mi>N</mi>
    <mo>.</mo>
    <mi>B</mi>
    <mo>,</mo>
    <mi>X</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>=</mo>
   <mi>λ</mi>
   <mi>N</mi>
   <mo>.</mo>
   <mrow>
    <mi>sink</mi>
    <mo>-</mo>
    <mi>tran</mi>
   </mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>B</mi>
    <mo>,</mo>
    <mi>X</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <minus></minus>
     <ci>sink</ci>
     <ci>tran</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">N</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">B</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">X</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">N</csymbol>
    <ci>normal-.</ci>
    <apply>
     <minus></minus>
     <ci>sink</ci>
     <ci>tran</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">B</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">X</csymbol>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{sink-tran}[\lambda N.B,X]=\lambda N.\operatorname{sink-tran}[B,X]
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Lambda_lifting:99">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>sink</mi>
     <mo>-</mo>
     <mi>tran</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>M</mi>
      </mpadded>
      <mi>N</mi>
     </mrow>
     <mo>,</mo>
     <mi>X</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <mi>sink</mi>
      <mo>-</mo>
      <mi>tran</mi>
     </mrow>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>M</mi>
      <mo>,</mo>
      <mi>X</mi>
      <mo rspace="7.5pt" stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mrow>
     <mrow>
      <mi>sink</mi>
      <mo>-</mo>
      <mi>tran</mi>
     </mrow>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>M</mi>
      <mo>,</mo>
      <mi>X</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <minus></minus>
      <ci>sink</ci>
      <ci>tran</ci>
     </apply>
     <apply>
      <times></times>
      <ci>M</ci>
      <ci>N</ci>
     </apply>
     <ci>X</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <apply>
       <minus></minus>
       <ci>sink</ci>
       <ci>tran</ci>
      </apply>
      <ci>M</ci>
      <ci>X</ci>
     </apply>
     <apply>
      <apply>
       <minus></minus>
       <ci>sink</ci>
       <ci>tran</ci>
      </apply>
      <ci>M</ci>
      <ci>X</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{sink-tran}[M\ N,X]=\operatorname{sink-tran}[M,X]\ \operatorname{%
sink-tran}[M,X]
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Lambda_lifting:100">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>sink</mi>
     <mo>-</mo>
     <mi>tran</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>V</mi>
     <mo>,</mo>
     <mi>X</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>V</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <minus></minus>
      <ci>sink</ci>
      <ci>tran</ci>
     </apply>
     <ci>V</ci>
     <ci>X</ci>
    </apply>
    <ci>V</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{sink-tran}[V,X]=V
  </annotation>
 </semantics>
</math>

</p>
<h3 id="abstraction-sinking">Abstraction sinking</h3>

<p>Sinking is moving a lambda abstraction inwards as far as possible such that it is still outside all references to the variable.</p>

<p><strong>Application</strong> - 4 cases.</p>

<p>

<math display="block" id="Lambda_lifting:101">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mo>∉</mo>
   <mo>FV</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>G</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mi mathvariant="italic">and</mi>
   <mi>E</mi>
   <mo>∉</mo>
   <mo>FV</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>H</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>→</mo>
   <mo>sink</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mi>E</mi>
     <mo>.</mo>
     <mpadded width="+5pt">
      <mi>G</mi>
     </mpadded>
     <mi>H</mi>
     <mo rspace="7.5pt" stretchy="false">)</mo>
    </mrow>
    <mi>Y</mi>
    <mo>,</mo>
    <mi>X</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>=</mo>
   <mpadded width="+5pt">
    <mi>G</mi>
   </mpadded>
   <mi>H</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">E</csymbol>
    <notin></notin>
    <ci>FV</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">G</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <csymbol cd="unknown">and</csymbol>
    <csymbol cd="unknown">E</csymbol>
    <notin></notin>
    <ci>FV</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">H</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <ci>normal-→</ci>
    <ci>sink</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">E</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">G</csymbol>
      <csymbol cd="unknown">H</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <csymbol cd="unknown">Y</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">X</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">G</csymbol>
    <csymbol cd="unknown">H</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E\not\in\operatorname{FV}[G]\and E\not\in\operatorname{FV}[H]\to\operatorname{%
sink}[(\lambda E.G\ H)\ Y,X]=G\ H
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Lambda_lifting:102">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mo>∉</mo>
   <mo>FV</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>G</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mi mathvariant="italic">and</mi>
   <mi>E</mi>
   <mo>∈</mo>
   <mo>FV</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>H</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>→</mo>
   <mo>sink</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mi>E</mi>
     <mo>.</mo>
     <mpadded width="+5pt">
      <mi>G</mi>
     </mpadded>
     <mi>H</mi>
     <mo rspace="7.5pt" stretchy="false">)</mo>
    </mrow>
    <mi>Y</mi>
    <mo>,</mo>
    <mi>X</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>sink</mi>
    <mo>-</mo>
    <mi>test</mi>
   </mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mpadded width="+5pt">
     <mi>G</mi>
    </mpadded>
    <mrow>
     <mi>sink</mi>
     <mo>-</mo>
     <mi>test</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>λ</mi>
      <mi>E</mi>
      <mo>.</mo>
      <mi>H</mi>
      <mo rspace="7.5pt" stretchy="false">)</mo>
     </mrow>
     <mi>Y</mi>
     <mo>,</mo>
     <mi>X</mi>
     <mo stretchy="false">]</mo>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">E</csymbol>
    <notin></notin>
    <ci>FV</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">G</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <csymbol cd="unknown">and</csymbol>
    <csymbol cd="unknown">E</csymbol>
    <in></in>
    <ci>FV</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">H</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <ci>normal-→</ci>
    <ci>sink</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">E</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">G</csymbol>
      <csymbol cd="unknown">H</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <csymbol cd="unknown">Y</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">X</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <eq></eq>
    <apply>
     <minus></minus>
     <ci>sink</ci>
     <ci>test</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">G</csymbol>
     <apply>
      <minus></minus>
      <ci>sink</ci>
      <ci>test</ci>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-[</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">λ</csymbol>
       <csymbol cd="unknown">E</csymbol>
       <ci>normal-.</ci>
       <csymbol cd="unknown">H</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <csymbol cd="unknown">Y</csymbol>
      <ci>normal-,</ci>
      <csymbol cd="unknown">X</csymbol>
      <ci>normal-]</ci>
     </cerror>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E\not\in\operatorname{FV}[G]\and E\in\operatorname{FV}[H]\to\operatorname{sink%
}[(\lambda E.G\ H)\ Y,X]=\operatorname{sink-test}[G\ \operatorname{sink-test}[%
(\lambda E.H)\ Y,X]]
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Lambda_lifting:103">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mo>∈</mo>
   <mo>FV</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>G</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mi mathvariant="italic">and</mi>
   <mi>E</mi>
   <mo>∉</mo>
   <mo>FV</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>H</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>→</mo>
   <mo>sink</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mi>E</mi>
     <mo>.</mo>
     <mpadded width="+5pt">
      <mi>G</mi>
     </mpadded>
     <mi>H</mi>
     <mo rspace="7.5pt" stretchy="false">)</mo>
    </mrow>
    <mi>Y</mi>
    <mo>,</mo>
    <mi>X</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>sink</mi>
     <mo>-</mo>
     <mi>test</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>λ</mi>
      <mi>E</mi>
      <mo>.</mo>
      <mi>G</mi>
      <mo rspace="7.5pt" stretchy="false">)</mo>
     </mrow>
     <mi>Y</mi>
     <mo>,</mo>
     <mi>X</mi>
     <mo stretchy="false">]</mo>
    </mrow>
    <mo rspace="7.5pt" stretchy="false">)</mo>
   </mrow>
   <mi>H</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">E</csymbol>
    <in></in>
    <ci>FV</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">G</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <csymbol cd="unknown">and</csymbol>
    <csymbol cd="unknown">E</csymbol>
    <notin></notin>
    <ci>FV</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">H</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <ci>normal-→</ci>
    <ci>sink</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">E</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">G</csymbol>
      <csymbol cd="unknown">H</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <csymbol cd="unknown">Y</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">X</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <minus></minus>
      <ci>sink</ci>
      <ci>test</ci>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-[</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">λ</csymbol>
       <csymbol cd="unknown">E</csymbol>
       <ci>normal-.</ci>
       <csymbol cd="unknown">G</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <csymbol cd="unknown">Y</csymbol>
      <ci>normal-,</ci>
      <csymbol cd="unknown">X</csymbol>
      <ci>normal-]</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">H</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E\in\operatorname{FV}[G]\and E\not\in\operatorname{FV}[H]\to\operatorname{sink%
}[(\lambda E.G\ H)\ Y,X]=(\operatorname{sink-test}[(\lambda E.G)\ Y,X])\ H
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Lambda_lifting:104">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mo>∈</mo>
   <mo>FV</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>G</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mi mathvariant="italic">and</mi>
   <mi>E</mi>
   <mo>∈</mo>
   <mo>FV</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>H</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>→</mo>
   <mo>sink</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mi>E</mi>
     <mo>.</mo>
     <mpadded width="+5pt">
      <mi>G</mi>
     </mpadded>
     <mi>H</mi>
     <mo rspace="7.5pt" stretchy="false">)</mo>
    </mrow>
    <mi>Y</mi>
    <mo>,</mo>
    <mi>X</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>E</mi>
    <mo>.</mo>
    <mpadded width="+5pt">
     <mi>G</mi>
    </mpadded>
    <mi>H</mi>
    <mo rspace="7.5pt" stretchy="false">)</mo>
   </mrow>
   <mi>Y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">E</csymbol>
    <in></in>
    <ci>FV</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">G</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <csymbol cd="unknown">and</csymbol>
    <csymbol cd="unknown">E</csymbol>
    <in></in>
    <ci>FV</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">H</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <ci>normal-→</ci>
    <ci>sink</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">E</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">G</csymbol>
      <csymbol cd="unknown">H</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <csymbol cd="unknown">Y</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">X</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">E</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">G</csymbol>
     <csymbol cd="unknown">H</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">Y</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E\in\operatorname{FV}[G]\and E\in\operatorname{FV}[H]\to\operatorname{sink}[(%
\lambda E.G\ H)\ Y,X]=(\lambda E.G\ H)\ Y
  </annotation>
 </semantics>
</math>

</p>

<p><strong>Abstraction</strong>. Use renaming to insure that the variable names are all distinct.</p>

<p>

<math display="block" id="Lambda_lifting:105">
 <semantics>
  <mrow>
   <mi>V</mi>
   <mo>≠</mo>
   <mi>W</mi>
   <mo>→</mo>
   <mo>sink</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mi>V</mi>
     <mo>.</mo>
     <mi>λ</mi>
     <mi>W</mi>
     <mo>.</mo>
     <mi>E</mi>
     <mo rspace="7.5pt" stretchy="false">)</mo>
    </mrow>
    <mi>Y</mi>
    <mo>,</mo>
    <mi>X</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>=</mo>
   <mi>λ</mi>
   <mi>W</mi>
   <mo>.</mo>
   <mrow>
    <mi>sink</mi>
    <mo>-</mo>
    <mi>test</mi>
   </mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mi>V</mi>
     <mo>.</mo>
     <mi>E</mi>
     <mo rspace="7.5pt" stretchy="false">)</mo>
    </mrow>
    <mi>Y</mi>
    <mo>,</mo>
    <mi>X</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">V</csymbol>
    <neq></neq>
    <csymbol cd="unknown">W</csymbol>
    <ci>normal-→</ci>
    <ci>sink</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">V</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">W</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">E</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <csymbol cd="unknown">Y</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">X</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">W</csymbol>
    <ci>normal-.</ci>
    <apply>
     <minus></minus>
     <ci>sink</ci>
     <ci>test</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">V</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">E</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <csymbol cd="unknown">Y</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">X</csymbol>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V\neq W\to\operatorname{sink}[(\lambda V.\lambda W.E)\ Y,X]=\lambda W.%
\operatorname{sink-test}[(\lambda V.E)\ Y,X]
  </annotation>
 </semantics>
</math>

</p>

<p><strong>Variable</strong> - 2 cases.</p>

<p>

<math display="block" id="Lambda_lifting:106">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mo>≠</mo>
   <mi>V</mi>
   <mo>→</mo>
   <mo>sink</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mi>E</mi>
     <mo>.</mo>
     <mi>V</mi>
     <mo rspace="7.5pt" stretchy="false">)</mo>
    </mrow>
    <mi>Y</mi>
    <mo>,</mo>
    <mi>X</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>=</mo>
   <mi>V</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">E</csymbol>
    <neq></neq>
    <csymbol cd="unknown">V</csymbol>
    <ci>normal-→</ci>
    <ci>sink</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">E</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">V</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <csymbol cd="unknown">Y</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">X</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">V</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E\neq V\to\operatorname{sink}[(\lambda E.V)\ Y,X]=V
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Lambda_lifting:107">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mo>=</mo>
   <mi>V</mi>
   <mo>→</mo>
   <mo>sink</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mi>E</mi>
     <mo>.</mo>
     <mi>V</mi>
     <mo rspace="7.5pt" stretchy="false">)</mo>
    </mrow>
    <mi>Y</mi>
    <mo>,</mo>
    <mi>X</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>=</mo>
   <mi>Y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">E</csymbol>
    <eq></eq>
    <csymbol cd="unknown">V</csymbol>
    <ci>normal-→</ci>
    <ci>sink</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">E</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">V</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <csymbol cd="unknown">Y</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">X</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">Y</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E=V\to\operatorname{sink}[(\lambda E.V)\ Y,X]=Y
  </annotation>
 </semantics>
</math>

</p>

<p>Sink test excludes expressions from dropping,</p>

<p>

<math display="block" id="Lambda_lifting:108">
 <semantics>
  <mrow>
   <mi>L</mi>
   <mo>∈</mo>
   <mi>X</mi>
   <mo>→</mo>
   <mrow>
    <mrow>
     <mi>sink</mi>
     <mo>-</mo>
     <mi>test</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>L</mi>
     <mo>,</mo>
     <mi>X</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>L</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <in></in>
     <ci>L</ci>
     <ci>X</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <apply>
       <minus></minus>
       <ci>sink</ci>
       <ci>test</ci>
      </apply>
      <ci>L</ci>
      <ci>X</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <ci>L</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L\in X\to\operatorname{sink-test}[L,X]=L
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Lambda_lifting:109">
 <semantics>
  <mrow>
   <mi>L</mi>
   <mo>∉</mo>
   <mi>X</mi>
   <mo>→</mo>
   <mrow>
    <mrow>
     <mi>sink</mi>
     <mo>-</mo>
     <mi>test</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>L</mi>
     <mo>,</mo>
     <mi>X</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>sink</mo>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>L</mi>
     <mo>,</mo>
     <mi>X</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <notin></notin>
     <ci>L</ci>
     <ci>X</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <apply>
       <minus></minus>
       <ci>sink</ci>
       <ci>test</ci>
      </apply>
      <ci>L</ci>
      <ci>X</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <ci>sink</ci>
      <ci>L</ci>
      <ci>X</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L\not\in X\to\operatorname{sink-test}[L,X]=\operatorname{sink}[L,X]
  </annotation>
 </semantics>
</math>

</p>
<h4 id="example-1">Example</h4>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>Example of sinking</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>For example,</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>Rule</p></th>
<th style="text-align: left;">
<p>Expression</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p><em>de-let</em></p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Lambda_lifting:110">
 <semantics>
  <mrow>
   <mrow>
    <mi>sink</mi>
    <mo>-</mo>
    <mi>tran</mi>
   </mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mrow>
     <mrow>
      <mi>de</mi>
      <mo>-</mo>
      <mi>let</mi>
     </mrow>
     <mrow>
      <mo stretchy="false">[</mo>
      <mrow>
       <mrow>
        <mo>let</mo>
        <mrow>
         <mpadded width="+5pt">
          <mi>p</mi>
         </mpadded>
         <mpadded width="+5pt">
          <mi>f</mi>
         </mpadded>
         <mi>x</mi>
        </mrow>
       </mrow>
       <mo>=</mo>
       <mrow>
        <mpadded width="+5pt">
         <mi>f</mi>
        </mpadded>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mpadded width="+5pt">
           <mi>x</mi>
          </mpadded>
          <mi>x</mi>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
        <mi mathvariant="italic">and</mi>
        <mpadded width="+5pt">
         <mi>q</mi>
        </mpadded>
        <mpadded width="+5pt">
         <mi>p</mi>
        </mpadded>
        <mi>f</mi>
       </mrow>
       <mo>=</mo>
       <mrow>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mpadded width="+5pt">
           <mi>p</mi>
          </mpadded>
          <mi>f</mi>
         </mrow>
         <mo rspace="7.5pt" stretchy="false">)</mo>
        </mrow>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mpadded width="+5pt">
           <mi>p</mi>
          </mpadded>
          <mi>f</mi>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
        <mrow>
         <mo>in</mo>
         <mrow>
          <mpadded width="+5pt">
           <mi>q</mi>
          </mpadded>
          <mi>p</mi>
         </mrow>
        </mrow>
       </mrow>
      </mrow>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <minus></minus>
     <ci>sink</ci>
     <ci>tran</ci>
    </apply>
    <apply>
     <apply>
      <minus></minus>
      <ci>de</ci>
      <ci>let</ci>
     </apply>
     <apply>
      <and></and>
      <apply>
       <eq></eq>
       <apply>
        <ci>let</ci>
        <apply>
         <times></times>
         <ci>p</ci>
         <ci>f</ci>
         <ci>x</ci>
        </apply>
       </apply>
       <apply>
        <times></times>
        <ci>f</ci>
        <apply>
         <times></times>
         <ci>x</ci>
         <ci>x</ci>
        </apply>
        <ci>italic- and</ci>
        <ci>q</ci>
        <ci>p</ci>
        <ci>f</ci>
       </apply>
      </apply>
      <apply>
       <eq></eq>
       <share href="#.cmml">
       </share>
       <apply>
        <times></times>
        <apply>
         <times></times>
         <ci>p</ci>
         <ci>f</ci>
        </apply>
        <apply>
         <times></times>
         <ci>p</ci>
         <ci>f</ci>
        </apply>
        <apply>
         <ci>in</ci>
         <apply>
          <times></times>
          <ci>q</ci>
          <ci>p</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{sink-tran}[\operatorname{de-let}[\operatorname{let}p\ f\ x=f\ (x%
\ x)\and q\ p\ f=(p\ f)\ (p\ f)\operatorname{in}q\ p]]
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><em>sink-tran</em></p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Lambda_lifting:111">
 <semantics>
  <mrow>
   <mrow>
    <mi>sink</mi>
    <mo>-</mo>
    <mi>tran</mi>
   </mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mi>p</mi>
     <mo>.</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>λ</mi>
      <mi>q</mi>
      <mo>.</mo>
      <mpadded width="+5pt">
       <mi>q</mi>
      </mpadded>
      <mi>p</mi>
      <mo rspace="7.5pt" stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>λ</mi>
      <mi>p</mi>
      <mo>.</mo>
      <mi>λ</mi>
      <mi>f</mi>
      <mo>.</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mpadded width="+5pt">
        <mi>p</mi>
       </mpadded>
       <mi>f</mi>
       <mo rspace="7.5pt" stretchy="false">)</mo>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mpadded width="+5pt">
        <mi>p</mi>
       </mpadded>
       <mi>f</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo rspace="7.5pt" stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mi>f</mi>
     <mo>.</mo>
     <mi>λ</mi>
     <mi>x</mi>
     <mo>.</mo>
     <mpadded width="+5pt">
      <mi>f</mi>
     </mpadded>
     <mrow>
      <mo stretchy="false">(</mo>
      <mpadded width="+5pt">
       <mi>x</mi>
      </mpadded>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <minus></minus>
     <ci>sink</ci>
     <ci>tran</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">p</csymbol>
      <ci>normal-.</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">λ</csymbol>
       <csymbol cd="unknown">q</csymbol>
       <ci>normal-.</ci>
       <csymbol cd="unknown">q</csymbol>
       <csymbol cd="unknown">p</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">λ</csymbol>
       <csymbol cd="unknown">p</csymbol>
       <ci>normal-.</ci>
       <csymbol cd="unknown">λ</csymbol>
       <csymbol cd="unknown">f</csymbol>
       <ci>normal-.</ci>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <csymbol cd="unknown">p</csymbol>
        <csymbol cd="unknown">f</csymbol>
        <ci>normal-)</ci>
       </cerror>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <csymbol cd="unknown">p</csymbol>
        <csymbol cd="unknown">f</csymbol>
        <ci>normal-)</ci>
       </cerror>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">f</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">f</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">x</csymbol>
       <csymbol cd="unknown">x</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{sink-tran}[(\lambda p.(\lambda q.q\ p)\ (\lambda p.\lambda f.(p%
\ f)\ (p\ f)))\ (\lambda f.\lambda x.f\ (x\ x))]
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>Application</p></td>
<td style="text-align: left;"><table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>

<math display="inline" id="Lambda_lifting:112">
 <semantics>
  <mrow>
   <mo>sink</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mi>p</mi>
     <mo>.</mo>
     <mo>sink</mo>
     <mrow>
      <mo stretchy="false">[</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>λ</mi>
       <mi>q</mi>
       <mo>.</mo>
       <mpadded width="+5pt">
        <mi>q</mi>
       </mpadded>
       <mi>p</mi>
       <mo rspace="7.5pt" stretchy="false">)</mo>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>λ</mi>
       <mi>p</mi>
       <mo>.</mo>
       <mi>λ</mi>
       <mi>f</mi>
       <mo>.</mo>
       <mrow>
        <mo stretchy="false">(</mo>
        <mpadded width="+5pt">
         <mi>p</mi>
        </mpadded>
        <mi>f</mi>
        <mo rspace="7.5pt" stretchy="false">)</mo>
       </mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mpadded width="+5pt">
         <mi>p</mi>
        </mpadded>
        <mi>f</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo stretchy="false">]</mo>
     </mrow>
     <mo rspace="7.5pt" stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mi>f</mi>
     <mo>.</mo>
     <mi>λ</mi>
     <mi>x</mi>
     <mo>.</mo>
     <mpadded width="+5pt">
      <mi>f</mi>
     </mpadded>
     <mrow>
      <mo stretchy="false">(</mo>
      <mpadded width="+5pt">
       <mi>x</mi>
      </mpadded>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>sink</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">p</csymbol>
      <ci>normal-.</ci>
      <ci>sink</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-[</ci>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <csymbol cd="unknown">λ</csymbol>
        <csymbol cd="unknown">q</csymbol>
        <ci>normal-.</ci>
        <csymbol cd="unknown">q</csymbol>
        <csymbol cd="unknown">p</csymbol>
        <ci>normal-)</ci>
       </cerror>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <csymbol cd="unknown">λ</csymbol>
        <csymbol cd="unknown">p</csymbol>
        <ci>normal-.</ci>
        <csymbol cd="unknown">λ</csymbol>
        <csymbol cd="unknown">f</csymbol>
        <ci>normal-.</ci>
        <cerror>
         <csymbol cd="ambiguous">fragments</csymbol>
         <ci>normal-(</ci>
         <csymbol cd="unknown">p</csymbol>
         <csymbol cd="unknown">f</csymbol>
         <ci>normal-)</ci>
        </cerror>
        <cerror>
         <csymbol cd="ambiguous">fragments</csymbol>
         <ci>normal-(</ci>
         <csymbol cd="unknown">p</csymbol>
         <csymbol cd="unknown">f</csymbol>
         <ci>normal-)</ci>
        </cerror>
        <ci>normal-)</ci>
       </cerror>
       <ci>normal-]</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">f</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">f</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">x</csymbol>
       <csymbol cd="unknown">x</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{sink}[(\lambda p.\operatorname{sink}[(\lambda q.q\ p)\ (\lambda p%
.\lambda f.(p\ f)\ (p\ f))])\ (\lambda f.\lambda x.f\ (x\ x))]
  </annotation>
 </semantics>
</math>

</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>

<math display="inline" id="Lambda_lifting:113">
 <semantics>
  <mrow>
   <mo>sink</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mi>q</mi>
     <mo>.</mo>
     <mpadded width="+5pt">
      <mi>q</mi>
     </mpadded>
     <mi>p</mi>
     <mo rspace="7.5pt" stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mi>p</mi>
     <mo>.</mo>
     <mi>λ</mi>
     <mi>f</mi>
     <mo>.</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mpadded width="+5pt">
       <mi>p</mi>
      </mpadded>
      <mi>f</mi>
      <mo rspace="7.5pt" stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mpadded width="+5pt">
       <mi>p</mi>
      </mpadded>
      <mi>f</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>sink</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">q</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">q</csymbol>
      <csymbol cd="unknown">p</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">p</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">f</csymbol>
      <ci>normal-.</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">p</csymbol>
       <csymbol cd="unknown">f</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">p</csymbol>
       <csymbol cd="unknown">f</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{sink}[(\lambda q.q\ p)\ (\lambda p.\lambda f.(p\ f)\ (p\ f))]
  </annotation>
 </semantics>
</math>


</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>

<math display="inline" id="Lambda_lifting:114">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mo>∈</mo>
   <mo>FV</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>G</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mi mathvariant="italic">and</mi>
   <mi>E</mi>
   <mo>∉</mo>
   <mo>FV</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>H</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>→</mo>
   <mo>sink</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mi>E</mi>
     <mo>.</mo>
     <mpadded width="+5pt">
      <mi>G</mi>
     </mpadded>
     <mi>H</mi>
     <mo rspace="7.5pt" stretchy="false">)</mo>
    </mrow>
    <mi>Y</mi>
    <mo>,</mo>
    <mi>X</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">E</csymbol>
    <in></in>
    <ci>FV</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">G</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <csymbol cd="unknown">and</csymbol>
    <csymbol cd="unknown">E</csymbol>
    <notin></notin>
    <ci>FV</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">H</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <ci>normal-→</ci>
    <ci>sink</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">E</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">G</csymbol>
      <csymbol cd="unknown">H</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <csymbol cd="unknown">Y</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">X</csymbol>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E\in\operatorname{FV}[G]\and E\not\in\operatorname{FV}[H]\to\operatorname{sink%
}[(\lambda E.G\ H)\ Y,X]
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>

<math display="inline" id="Lambda_lifting:115">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mo>=</mo>
   <mi>q</mi>
   <mo>,</mo>
   <mi>G</mi>
   <mo>=</mo>
   <mi>q</mi>
   <mo>,</mo>
   <mi>H</mi>
   <mo>=</mo>
   <mi>p</mi>
   <mo>,</mo>
   <mi>Y</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>p</mi>
    <mo>.</mo>
    <mi>λ</mi>
    <mi>f</mi>
    <mo>.</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mpadded width="+5pt">
      <mi>p</mi>
     </mpadded>
     <mi>f</mi>
     <mo rspace="7.5pt" stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mpadded width="+5pt">
      <mi>p</mi>
     </mpadded>
     <mi>f</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>,</mo>
   <mi>X</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">E</csymbol>
    <eq></eq>
    <csymbol cd="unknown">q</csymbol>
    <ci>normal-,</ci>
    <csymbol cd="unknown">G</csymbol>
    <eq></eq>
    <csymbol cd="unknown">q</csymbol>
    <ci>normal-,</ci>
    <csymbol cd="unknown">H</csymbol>
    <eq></eq>
    <csymbol cd="unknown">p</csymbol>
    <ci>normal-,</ci>
    <csymbol cd="unknown">Y</csymbol>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">p</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">f</csymbol>
     <ci>normal-.</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">p</csymbol>
      <csymbol cd="unknown">f</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">p</csymbol>
      <csymbol cd="unknown">f</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-,</ci>
    <csymbol cd="unknown">X</csymbol>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-{</ci>
     <ci>normal-}</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E=q,G=q,H=p,Y=(\lambda p.\lambda f.(p\ f)\ (p\ f)),X=\{\}
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>

<math display="inline" id="Lambda_lifting:116">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>sink</mo>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>λ</mi>
      <mi>E</mi>
      <mo>.</mo>
      <mi>G</mi>
      <mo rspace="7.5pt" stretchy="false">)</mo>
     </mrow>
     <mi>Y</mi>
     <mo>,</mo>
     <mi>X</mi>
     <mo stretchy="false">]</mo>
    </mrow>
    <mo rspace="7.5pt" stretchy="false">)</mo>
   </mrow>
   <mi>H</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <ci>sink</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-[</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">λ</csymbol>
       <csymbol cd="unknown">E</csymbol>
       <ci>normal-.</ci>
       <csymbol cd="unknown">G</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <csymbol cd="unknown">Y</csymbol>
      <ci>normal-,</ci>
      <csymbol cd="unknown">X</csymbol>
      <ci>normal-]</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">H</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\operatorname{sink}[(\lambda E.G)\ Y,X])\ H
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>

<math display="inline" id="Lambda_lifting:117">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>sink</mo>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>λ</mi>
      <mi>q</mi>
      <mo>.</mo>
      <mi>q</mi>
      <mo rspace="7.5pt" stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>λ</mi>
      <mi>p</mi>
      <mo>.</mo>
      <mi>λ</mi>
      <mi>f</mi>
      <mo>.</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mpadded width="+5pt">
        <mi>p</mi>
       </mpadded>
       <mi>f</mi>
       <mo rspace="7.5pt" stretchy="false">)</mo>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mpadded width="+5pt">
        <mi>p</mi>
       </mpadded>
       <mi>f</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>,</mo>
     <mi>X</mi>
     <mo stretchy="false">]</mo>
    </mrow>
    <mo rspace="7.5pt" stretchy="false">)</mo>
   </mrow>
   <mi>p</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <ci>sink</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-[</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">λ</csymbol>
       <csymbol cd="unknown">q</csymbol>
       <ci>normal-.</ci>
       <csymbol cd="unknown">q</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">λ</csymbol>
       <csymbol cd="unknown">p</csymbol>
       <ci>normal-.</ci>
       <csymbol cd="unknown">λ</csymbol>
       <csymbol cd="unknown">f</csymbol>
       <ci>normal-.</ci>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <csymbol cd="unknown">p</csymbol>
        <csymbol cd="unknown">f</csymbol>
        <ci>normal-)</ci>
       </cerror>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <csymbol cd="unknown">p</csymbol>
        <csymbol cd="unknown">f</csymbol>
        <ci>normal-)</ci>
       </cerror>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-,</ci>
      <csymbol cd="unknown">X</csymbol>
      <ci>normal-]</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">p</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\operatorname{sink}[(\lambda q.q)\ (\lambda p.\lambda f.(p\ f)\ (p\ f)),X])\ p
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
</tbody>
</table></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Variable</p></td>
<td style="text-align: left;"><table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>

<math display="inline" id="Lambda_lifting:118">
 <semantics>
  <mrow>
   <mo>sink</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mi>p</mi>
     <mo>.</mo>
     <mo>sink</mo>
     <mrow>
      <mo stretchy="false">[</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>λ</mi>
       <mi>q</mi>
       <mo>.</mo>
       <mi>q</mi>
       <mo rspace="7.5pt" stretchy="false">)</mo>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>λ</mi>
       <mi>p</mi>
       <mo>.</mo>
       <mi>λ</mi>
       <mi>f</mi>
       <mo>.</mo>
       <mrow>
        <mo stretchy="false">(</mo>
        <mpadded width="+5pt">
         <mi>p</mi>
        </mpadded>
        <mi>f</mi>
        <mo rspace="7.5pt" stretchy="false">)</mo>
       </mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mpadded width="+5pt">
         <mi>p</mi>
        </mpadded>
        <mi>f</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo rspace="7.5pt" stretchy="false">]</mo>
     </mrow>
     <mi>p</mi>
     <mo rspace="7.5pt" stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mi>f</mi>
     <mo>.</mo>
     <mi>λ</mi>
     <mi>x</mi>
     <mo>.</mo>
     <mpadded width="+5pt">
      <mi>f</mi>
     </mpadded>
     <mrow>
      <mo stretchy="false">(</mo>
      <mpadded width="+5pt">
       <mi>x</mi>
      </mpadded>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>sink</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">p</csymbol>
      <ci>normal-.</ci>
      <ci>sink</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-[</ci>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <csymbol cd="unknown">λ</csymbol>
        <csymbol cd="unknown">q</csymbol>
        <ci>normal-.</ci>
        <csymbol cd="unknown">q</csymbol>
        <ci>normal-)</ci>
       </cerror>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <csymbol cd="unknown">λ</csymbol>
        <csymbol cd="unknown">p</csymbol>
        <ci>normal-.</ci>
        <csymbol cd="unknown">λ</csymbol>
        <csymbol cd="unknown">f</csymbol>
        <ci>normal-.</ci>
        <cerror>
         <csymbol cd="ambiguous">fragments</csymbol>
         <ci>normal-(</ci>
         <csymbol cd="unknown">p</csymbol>
         <csymbol cd="unknown">f</csymbol>
         <ci>normal-)</ci>
        </cerror>
        <cerror>
         <csymbol cd="ambiguous">fragments</csymbol>
         <ci>normal-(</ci>
         <csymbol cd="unknown">p</csymbol>
         <csymbol cd="unknown">f</csymbol>
         <ci>normal-)</ci>
        </cerror>
        <ci>normal-)</ci>
       </cerror>
       <ci>normal-]</ci>
      </cerror>
      <csymbol cd="unknown">p</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">f</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">f</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">x</csymbol>
       <csymbol cd="unknown">x</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{sink}[(\lambda p.\operatorname{sink}[(\lambda q.q)\ (\lambda p.%
\lambda f.(p\ f)\ (p\ f))]\ p)\ (\lambda f.\lambda x.f\ (x\ x))]
  </annotation>
 </semantics>
</math>


</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>

<math display="inline" id="Lambda_lifting:119">
 <semantics>
  <mrow>
   <mo>sink</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mi>q</mi>
     <mo>.</mo>
     <mi>q</mi>
     <mo rspace="7.5pt" stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mi>p</mi>
     <mo>.</mo>
     <mi>λ</mi>
     <mi>f</mi>
     <mo>.</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mpadded width="+5pt">
       <mi>p</mi>
      </mpadded>
      <mi>f</mi>
      <mo rspace="7.5pt" stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mpadded width="+5pt">
       <mi>p</mi>
      </mpadded>
      <mi>f</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>sink</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">q</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">q</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">p</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">f</csymbol>
      <ci>normal-.</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">p</csymbol>
       <csymbol cd="unknown">f</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">p</csymbol>
       <csymbol cd="unknown">f</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{sink}[(\lambda q.q)\ (\lambda p.\lambda f.(p\ f)\ (p\ f))]
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>

<math display="inline" id="Lambda_lifting:120">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mo>=</mo>
   <mi>V</mi>
   <mo>→</mo>
   <mo>sink</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mi>E</mi>
     <mo>.</mo>
     <mi>V</mi>
     <mo rspace="7.5pt" stretchy="false">)</mo>
    </mrow>
    <mi>Y</mi>
    <mo>,</mo>
    <mi>X</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">E</csymbol>
    <eq></eq>
    <csymbol cd="unknown">V</csymbol>
    <ci>normal-→</ci>
    <ci>sink</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">E</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">V</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <csymbol cd="unknown">Y</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">X</csymbol>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E=V\to\operatorname{sink}[(\lambda E.V)\ Y,X]
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>

<math display="inline" id="Lambda_lifting:121">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mo>=</mo>
   <mi>q</mi>
   <mo>,</mo>
   <mi>V</mi>
   <mo>=</mo>
   <mi>q</mi>
   <mo>,</mo>
   <mi>Y</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>p</mi>
    <mo>.</mo>
    <mi>λ</mi>
    <mi>f</mi>
    <mo>.</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mpadded width="+5pt">
      <mi>p</mi>
     </mpadded>
     <mi>f</mi>
     <mo rspace="7.5pt" stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mpadded width="+5pt">
      <mi>p</mi>
     </mpadded>
     <mi>f</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>,</mo>
   <mi>X</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">E</csymbol>
    <eq></eq>
    <csymbol cd="unknown">q</csymbol>
    <ci>normal-,</ci>
    <csymbol cd="unknown">V</csymbol>
    <eq></eq>
    <csymbol cd="unknown">q</csymbol>
    <ci>normal-,</ci>
    <csymbol cd="unknown">Y</csymbol>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">p</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">f</csymbol>
     <ci>normal-.</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">p</csymbol>
      <csymbol cd="unknown">f</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">p</csymbol>
      <csymbol cd="unknown">f</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-,</ci>
    <csymbol cd="unknown">X</csymbol>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-{</ci>
     <ci>normal-}</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E=q,V=q,Y=(\lambda p.\lambda f.(p\ f)\ (p\ f)),X=\{\}
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>

<math display="inline" id="Lambda_lifting:122">
 <semantics>
  <mi>Y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>

<math display="inline" id="Lambda_lifting:123">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mrow>
     <mi>λ</mi>
     <mi>p</mi>
    </mrow>
    <mo>.</mo>
    <mrow>
     <mi>λ</mi>
     <mi>f</mi>
    </mrow>
    <mo>.</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mpadded width="+5pt">
        <mi>p</mi>
       </mpadded>
       <mi>f</mi>
      </mrow>
      <mo rspace="7.5pt" stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mpadded width="+5pt">
        <mi>p</mi>
       </mpadded>
       <mi>f</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>p</ci>
    </apply>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>f</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <times></times>
      <ci>p</ci>
      <ci>f</ci>
     </apply>
     <apply>
      <times></times>
      <ci>p</ci>
      <ci>f</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\lambda p.\lambda f.(p\ f)\ (p\ f))
  </annotation>
 </semantics>
</math>


</p></td>
</tr>
</tbody>
</table></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>Application</p></td>
<td style="text-align: left;"><table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>

<math display="inline" id="Lambda_lifting:124">
 <semantics>
  <mrow>
   <mo>sink</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mi>p</mi>
     <mo>.</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>λ</mi>
      <mi>p</mi>
      <mo>.</mo>
      <mi>λ</mi>
      <mi>f</mi>
      <mo>.</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mpadded width="+5pt">
        <mi>p</mi>
       </mpadded>
       <mi>f</mi>
       <mo rspace="7.5pt" stretchy="false">)</mo>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mpadded width="+5pt">
        <mi>p</mi>
       </mpadded>
       <mi>f</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo rspace="7.5pt" stretchy="false">)</mo>
     </mrow>
     <mi>p</mi>
     <mo rspace="7.5pt" stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mi>f</mi>
     <mo>.</mo>
     <mi>λ</mi>
     <mi>x</mi>
     <mo>.</mo>
     <mpadded width="+5pt">
      <mi>f</mi>
     </mpadded>
     <mrow>
      <mo stretchy="false">(</mo>
      <mpadded width="+5pt">
       <mi>x</mi>
      </mpadded>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>sink</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">p</csymbol>
      <ci>normal-.</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">λ</csymbol>
       <csymbol cd="unknown">p</csymbol>
       <ci>normal-.</ci>
       <csymbol cd="unknown">λ</csymbol>
       <csymbol cd="unknown">f</csymbol>
       <ci>normal-.</ci>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <csymbol cd="unknown">p</csymbol>
        <csymbol cd="unknown">f</csymbol>
        <ci>normal-)</ci>
       </cerror>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <csymbol cd="unknown">p</csymbol>
        <csymbol cd="unknown">f</csymbol>
        <ci>normal-)</ci>
       </cerror>
       <ci>normal-)</ci>
      </cerror>
      <csymbol cd="unknown">p</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">f</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">f</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">x</csymbol>
       <csymbol cd="unknown">x</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{sink}[(\lambda p.(\lambda p.\lambda f.(p\ f)\ (p\ f))\ p)\ (%
\lambda f.\lambda x.f\ (x\ x))]
  </annotation>
 </semantics>
</math>

</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>

<math display="inline" id="Lambda_lifting:125">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mo>∉</mo>
   <mo>FV</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>G</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mi mathvariant="italic">and</mi>
   <mi>E</mi>
   <mo>∈</mo>
   <mo>FV</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>H</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>→</mo>
   <mo>sink</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mi>E</mi>
     <mo>.</mo>
     <mpadded width="+5pt">
      <mi>G</mi>
     </mpadded>
     <mi>H</mi>
     <mo rspace="7.5pt" stretchy="false">)</mo>
    </mrow>
    <mi>Y</mi>
    <mo>,</mo>
    <mi>X</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">E</csymbol>
    <notin></notin>
    <ci>FV</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">G</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <csymbol cd="unknown">and</csymbol>
    <csymbol cd="unknown">E</csymbol>
    <in></in>
    <ci>FV</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">H</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <ci>normal-→</ci>
    <ci>sink</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">E</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">G</csymbol>
      <csymbol cd="unknown">H</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <csymbol cd="unknown">Y</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">X</csymbol>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E\not\in\operatorname{FV}[G]\and E\in\operatorname{FV}[H]\to\operatorname{sink%
}[(\lambda E.G\ H)\ Y,X]
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>

<math display="inline" id="Lambda_lifting:126">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mo>=</mo>
   <mi>p</mi>
   <mo>,</mo>
   <mi>G</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>p</mi>
    <mo>.</mo>
    <mi>λ</mi>
    <mi>f</mi>
    <mo>.</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mpadded width="+5pt">
      <mi>p</mi>
     </mpadded>
     <mi>f</mi>
     <mo rspace="7.5pt" stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mpadded width="+5pt">
      <mi>p</mi>
     </mpadded>
     <mi>f</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>,</mo>
   <mi>H</mi>
   <mo>=</mo>
   <mi>p</mi>
   <mo>,</mo>
   <mi>Y</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>f</mi>
    <mo>.</mo>
    <mi>λ</mi>
    <mi>x</mi>
    <mo>.</mo>
    <mpadded width="+5pt">
     <mi>f</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mpadded width="+5pt">
      <mi>x</mi>
     </mpadded>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">E</csymbol>
    <eq></eq>
    <csymbol cd="unknown">p</csymbol>
    <ci>normal-,</ci>
    <csymbol cd="unknown">G</csymbol>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">p</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">f</csymbol>
     <ci>normal-.</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">p</csymbol>
      <csymbol cd="unknown">f</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">p</csymbol>
      <csymbol cd="unknown">f</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-,</ci>
    <csymbol cd="unknown">H</csymbol>
    <eq></eq>
    <csymbol cd="unknown">p</csymbol>
    <ci>normal-,</ci>
    <csymbol cd="unknown">Y</csymbol>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">f</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">f</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E=p,G=(\lambda p.\lambda f.(p\ f)\ (p\ f)),H=p,Y=(\lambda f.\lambda x.f\ (x\ x))
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>

<math display="inline" id="Lambda_lifting:127">
 <semantics>
  <mrow>
   <mo>sink</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mpadded width="+5pt">
     <mi>G</mi>
    </mpadded>
    <mo>sink</mo>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>λ</mi>
      <mi>E</mi>
      <mo>.</mo>
      <mi>H</mi>
      <mo rspace="7.5pt" stretchy="false">)</mo>
     </mrow>
     <mi>Y</mi>
     <mo>,</mo>
     <mi>X</mi>
     <mo stretchy="false">]</mo>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>sink</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">G</csymbol>
     <ci>sink</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-[</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">λ</csymbol>
       <csymbol cd="unknown">E</csymbol>
       <ci>normal-.</ci>
       <csymbol cd="unknown">H</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <csymbol cd="unknown">Y</csymbol>
      <ci>normal-,</ci>
      <csymbol cd="unknown">X</csymbol>
      <ci>normal-]</ci>
     </cerror>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{sink}[G\ \operatorname{sink}[(\lambda E.H)\ Y,X]]
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
</tbody>
</table></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>Variable</p></td>
<td style="text-align: left;"><table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>

<math display="inline" id="Lambda_lifting:128">
 <semantics>
  <mrow>
   <mo>sink</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mi>p</mi>
     <mo>.</mo>
     <mi>λ</mi>
     <mi>f</mi>
     <mo>.</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mpadded width="+5pt">
       <mi>p</mi>
      </mpadded>
      <mi>f</mi>
      <mo rspace="7.5pt" stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mpadded width="+5pt">
       <mi>p</mi>
      </mpadded>
      <mi>f</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo rspace="7.5pt" stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mi>sink</mi>
     <mo>-</mo>
     <mi>test</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>λ</mi>
      <mi>p</mi>
      <mo>.</mo>
      <mi>p</mi>
      <mo rspace="7.5pt" stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>λ</mi>
      <mi>f</mi>
      <mo>.</mo>
      <mi>λ</mi>
      <mi>x</mi>
      <mo>.</mo>
      <mpadded width="+5pt">
       <mi>f</mi>
      </mpadded>
      <mrow>
       <mo stretchy="false">(</mo>
       <mpadded width="+5pt">
        <mi>x</mi>
       </mpadded>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>,</mo>
     <mi>X</mi>
     <mo stretchy="false">]</mo>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>sink</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">p</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">f</csymbol>
      <ci>normal-.</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">p</csymbol>
       <csymbol cd="unknown">f</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">p</csymbol>
       <csymbol cd="unknown">f</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <apply>
      <minus></minus>
      <ci>sink</ci>
      <ci>test</ci>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-[</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">λ</csymbol>
       <csymbol cd="unknown">p</csymbol>
       <ci>normal-.</ci>
       <csymbol cd="unknown">p</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">λ</csymbol>
       <csymbol cd="unknown">f</csymbol>
       <ci>normal-.</ci>
       <csymbol cd="unknown">λ</csymbol>
       <csymbol cd="unknown">x</csymbol>
       <ci>normal-.</ci>
       <csymbol cd="unknown">f</csymbol>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <csymbol cd="unknown">x</csymbol>
        <csymbol cd="unknown">x</csymbol>
        <ci>normal-)</ci>
       </cerror>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-,</ci>
      <csymbol cd="unknown">X</csymbol>
      <ci>normal-]</ci>
     </cerror>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{sink}[(\lambda p.\lambda f.(p\ f)\ (p\ f))\ \operatorname{sink-%
test}[(\lambda p.p)\ (\lambda f.\lambda x.f\ (x\ x)),X]]
  </annotation>
 </semantics>
</math>


</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>

<math display="inline" id="Lambda_lifting:129">
 <semantics>
  <mrow>
   <mo>sink</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mi>p</mi>
     <mo>.</mo>
     <mi>p</mi>
     <mo rspace="7.5pt" stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mi>f</mi>
     <mo>.</mo>
     <mi>λ</mi>
     <mi>x</mi>
     <mo>.</mo>
     <mpadded width="+5pt">
      <mi>f</mi>
     </mpadded>
     <mrow>
      <mo stretchy="false">(</mo>
      <mpadded width="+5pt">
       <mi>x</mi>
      </mpadded>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>,</mo>
    <mi>X</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>sink</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">p</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">p</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">f</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">f</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">x</csymbol>
       <csymbol cd="unknown">x</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-,</ci>
     <csymbol cd="unknown">X</csymbol>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{sink}[(\lambda p.p)\ (\lambda f.\lambda x.f\ (x\ x)),X]
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>

<math display="inline" id="Lambda_lifting:130">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mo>=</mo>
   <mi>V</mi>
   <mo>→</mo>
   <mo>sink</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mi>E</mi>
     <mo>.</mo>
     <mi>V</mi>
     <mo rspace="7.5pt" stretchy="false">)</mo>
    </mrow>
    <mi>Y</mi>
    <mo>,</mo>
    <mi>X</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">E</csymbol>
    <eq></eq>
    <csymbol cd="unknown">V</csymbol>
    <ci>normal-→</ci>
    <ci>sink</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">E</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">V</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <csymbol cd="unknown">Y</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">X</csymbol>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E=V\to\operatorname{sink}[(\lambda E.V)\ Y,X]
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>

<math display="inline" id="Lambda_lifting:131">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mo>=</mo>
   <mi>p</mi>
   <mo>,</mo>
   <mi>V</mi>
   <mo>=</mo>
   <mi>p</mi>
   <mo>,</mo>
   <mi>Y</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>f</mi>
    <mo>.</mo>
    <mi>λ</mi>
    <mi>x</mi>
    <mo>.</mo>
    <mpadded width="+5pt">
     <mi>f</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mpadded width="+5pt">
      <mi>x</mi>
     </mpadded>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>,</mo>
   <mi>X</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">E</csymbol>
    <eq></eq>
    <csymbol cd="unknown">p</csymbol>
    <ci>normal-,</ci>
    <csymbol cd="unknown">V</csymbol>
    <eq></eq>
    <csymbol cd="unknown">p</csymbol>
    <ci>normal-,</ci>
    <csymbol cd="unknown">Y</csymbol>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">f</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">f</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-,</ci>
    <csymbol cd="unknown">X</csymbol>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-{</ci>
     <ci>normal-}</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E=p,V=p,Y=(\lambda f.\lambda x.f\ (x\ x)),X=\{\}
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>

<math display="inline" id="Lambda_lifting:132">
 <semantics>
  <mi>Y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>

<math display="inline" id="Lambda_lifting:133">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mrow>
     <mi>λ</mi>
     <mi>f</mi>
    </mrow>
    <mo>.</mo>
    <mrow>
     <mi>λ</mi>
     <mi>x</mi>
    </mrow>
    <mo>.</mo>
    <mrow>
     <mpadded width="+5pt">
      <mi>f</mi>
     </mpadded>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mpadded width="+5pt">
        <mi>x</mi>
       </mpadded>
       <mi>x</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>f</ci>
    </apply>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <ci>f</ci>
     <apply>
      <times></times>
      <ci>x</ci>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\lambda f.\lambda x.f\ (x\ x))
  </annotation>
 </semantics>
</math>


</p></td>
</tr>
</tbody>
</table></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Abstraction</p></td>
<td style="text-align: left;"><table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>

<math display="inline" id="Lambda_lifting:134">
 <semantics>
  <mrow>
   <mo>sink</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mi>p</mi>
     <mo>.</mo>
     <mi>λ</mi>
     <mi>f</mi>
     <mo>.</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mpadded width="+5pt">
       <mi>p</mi>
      </mpadded>
      <mi>f</mi>
      <mo rspace="7.5pt" stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mpadded width="+5pt">
       <mi>p</mi>
      </mpadded>
      <mi>f</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo rspace="7.5pt" stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mi>f</mi>
     <mo>.</mo>
     <mi>λ</mi>
     <mi>x</mi>
     <mo>.</mo>
     <mpadded width="+5pt">
      <mi>f</mi>
     </mpadded>
     <mrow>
      <mo stretchy="false">(</mo>
      <mpadded width="+5pt">
       <mi>x</mi>
      </mpadded>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>sink</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">p</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">f</csymbol>
      <ci>normal-.</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">p</csymbol>
       <csymbol cd="unknown">f</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">p</csymbol>
       <csymbol cd="unknown">f</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">f</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">f</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">x</csymbol>
       <csymbol cd="unknown">x</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{sink}[(\lambda p.\lambda f.(p\ f)\ (p\ f))\ (\lambda f.\lambda x%
.f\ (x\ x))]
  </annotation>
 </semantics>
</math>

</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>

<math display="inline" id="Lambda_lifting:135">
 <semantics>
  <mrow>
   <mi>V</mi>
   <mo>≠</mo>
   <mi>W</mi>
   <mo>→</mo>
   <mo>sink</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mi>V</mi>
     <mo>.</mo>
     <mi>λ</mi>
     <mi>W</mi>
     <mo>.</mo>
     <mi>E</mi>
     <mo rspace="7.5pt" stretchy="false">)</mo>
    </mrow>
    <mi>Y</mi>
    <mo>,</mo>
    <mi>X</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">V</csymbol>
    <neq></neq>
    <csymbol cd="unknown">W</csymbol>
    <ci>normal-→</ci>
    <ci>sink</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">V</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">W</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">E</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <csymbol cd="unknown">Y</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">X</csymbol>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V\neq W\to\operatorname{sink}[(\lambda V.\lambda W.E)\ Y,X]
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>

<math display="inline" id="Lambda_lifting:136">
 <semantics>
  <mrow>
   <mi>V</mi>
   <mo>=</mo>
   <mi>p</mi>
   <mo>,</mo>
   <mi>W</mi>
   <mo>=</mo>
   <mi>f</mi>
   <mo>,</mo>
   <mi>E</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mpadded width="+5pt">
     <mi>p</mi>
    </mpadded>
    <mi>f</mi>
    <mo rspace="7.5pt" stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mpadded width="+5pt">
     <mi>p</mi>
    </mpadded>
    <mi>f</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>,</mo>
   <mi>Y</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>f</mi>
    <mo>.</mo>
    <mi>λ</mi>
    <mi>x</mi>
    <mo>.</mo>
    <mpadded width="+5pt">
     <mi>f</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mpadded width="+5pt">
      <mi>x</mi>
     </mpadded>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">V</csymbol>
    <eq></eq>
    <csymbol cd="unknown">p</csymbol>
    <ci>normal-,</ci>
    <csymbol cd="unknown">W</csymbol>
    <eq></eq>
    <csymbol cd="unknown">f</csymbol>
    <ci>normal-,</ci>
    <csymbol cd="unknown">E</csymbol>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">p</csymbol>
     <csymbol cd="unknown">f</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">p</csymbol>
     <csymbol cd="unknown">f</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-,</ci>
    <csymbol cd="unknown">Y</csymbol>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">f</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">f</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V=p,W=f,E=(p\ f)\ (p\ f),Y=(\lambda f.\lambda x.f\ (x\ x))
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>

<math display="inline" id="Lambda_lifting:137">
 <semantics>
  <mrow>
   <mi>λ</mi>
   <mi>W</mi>
   <mo>.</mo>
   <mo>sink</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mi>V</mi>
     <mo>.</mo>
     <mi>E</mi>
     <mo rspace="7.5pt" stretchy="false">)</mo>
    </mrow>
    <mi>Y</mi>
    <mo>,</mo>
    <mi>X</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">W</csymbol>
    <ci>normal-.</ci>
    <ci>sink</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">V</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">E</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <csymbol cd="unknown">Y</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">X</csymbol>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda W.\operatorname{sink}[(\lambda V.E)\ Y,X]
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
</tbody>
</table></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>Application</p></td>
<td style="text-align: left;"><table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>

<math display="inline" id="Lambda_lifting:138">
 <semantics>
  <mrow>
   <mi>λ</mi>
   <mi>f</mi>
   <mo>.</mo>
   <mo>sink</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mi>p</mi>
     <mo>.</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mpadded width="+5pt">
       <mi>p</mi>
      </mpadded>
      <mi>f</mi>
      <mo rspace="7.5pt" stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mpadded width="+5pt">
       <mi>p</mi>
      </mpadded>
      <mi>f</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo rspace="7.5pt" stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mi>f</mi>
     <mo>.</mo>
     <mi>λ</mi>
     <mi>x</mi>
     <mo>.</mo>
     <mpadded width="+5pt">
      <mi>f</mi>
     </mpadded>
     <mrow>
      <mo stretchy="false">(</mo>
      <mpadded width="+5pt">
       <mi>x</mi>
      </mpadded>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>,</mo>
    <mi>X</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">f</csymbol>
    <ci>normal-.</ci>
    <ci>sink</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">p</csymbol>
      <ci>normal-.</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">p</csymbol>
       <csymbol cd="unknown">f</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">p</csymbol>
       <csymbol cd="unknown">f</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">f</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">f</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">x</csymbol>
       <csymbol cd="unknown">x</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-,</ci>
     <csymbol cd="unknown">X</csymbol>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda f.\operatorname{sink}[(\lambda p.(p\ f)\ (p\ f))\ (\lambda f.\lambda x%
.f\ (x\ x)),X]
  </annotation>
 </semantics>
</math>


</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>

<math display="inline" id="Lambda_lifting:139">
 <semantics>
  <mrow>
   <mo>sink</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mi>p</mi>
     <mo>.</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mpadded width="+5pt">
       <mi>p</mi>
      </mpadded>
      <mi>f</mi>
      <mo rspace="7.5pt" stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mpadded width="+5pt">
       <mi>p</mi>
      </mpadded>
      <mi>f</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo rspace="7.5pt" stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mi>f</mi>
     <mo>.</mo>
     <mi>λ</mi>
     <mi>x</mi>
     <mo>.</mo>
     <mpadded width="+5pt">
      <mi>f</mi>
     </mpadded>
     <mrow>
      <mo stretchy="false">(</mo>
      <mpadded width="+5pt">
       <mi>x</mi>
      </mpadded>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>,</mo>
    <mi>X</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>sink</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">p</csymbol>
      <ci>normal-.</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">p</csymbol>
       <csymbol cd="unknown">f</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">p</csymbol>
       <csymbol cd="unknown">f</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">f</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">f</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">x</csymbol>
       <csymbol cd="unknown">x</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-,</ci>
     <csymbol cd="unknown">X</csymbol>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{sink}[(\lambda p.(p\ f)\ (p\ f))\ (\lambda f.\lambda x.f\ (x\ x)%
),X]
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>

<math display="inline" id="Lambda_lifting:140">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mo>∈</mo>
   <mo>FV</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>G</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mi mathvariant="italic">and</mi>
   <mi>E</mi>
   <mo>∈</mo>
   <mo>FV</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>H</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>→</mo>
   <mo>sink</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mi>E</mi>
     <mo>.</mo>
     <mpadded width="+5pt">
      <mi>G</mi>
     </mpadded>
     <mi>H</mi>
     <mo rspace="7.5pt" stretchy="false">)</mo>
    </mrow>
    <mi>Y</mi>
    <mo>,</mo>
    <mi>X</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">E</csymbol>
    <in></in>
    <ci>FV</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">G</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <csymbol cd="unknown">and</csymbol>
    <csymbol cd="unknown">E</csymbol>
    <in></in>
    <ci>FV</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">H</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <ci>normal-→</ci>
    <ci>sink</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">E</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">G</csymbol>
      <csymbol cd="unknown">H</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <csymbol cd="unknown">Y</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">X</csymbol>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E\in\operatorname{FV}[G]\and E\in\operatorname{FV}[H]\to\operatorname{sink}[(%
\lambda E.G\ H)\ Y,X]
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>

<math display="inline" id="Lambda_lifting:141">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mo>=</mo>
   <mi>p</mi>
   <mo>,</mo>
   <mi>G</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mpadded width="+5pt">
     <mi>p</mi>
    </mpadded>
    <mi>f</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>,</mo>
   <mi>H</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mpadded width="+5pt">
     <mi>p</mi>
    </mpadded>
    <mi>f</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>,</mo>
   <mi>Y</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>f</mi>
    <mo>.</mo>
    <mi>λ</mi>
    <mi>x</mi>
    <mo>.</mo>
    <mpadded width="+5pt">
     <mi>f</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mpadded width="+5pt">
      <mi>x</mi>
     </mpadded>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">E</csymbol>
    <eq></eq>
    <csymbol cd="unknown">p</csymbol>
    <ci>normal-,</ci>
    <csymbol cd="unknown">G</csymbol>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">p</csymbol>
     <csymbol cd="unknown">f</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-,</ci>
    <csymbol cd="unknown">H</csymbol>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">p</csymbol>
     <csymbol cd="unknown">f</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-,</ci>
    <csymbol cd="unknown">Y</csymbol>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">f</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">f</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E=p,G=(p\ f),H=(p\ f),Y=(\lambda f.\lambda x.f\ (x\ x))
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>

<math display="inline" id="Lambda_lifting:142">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>E</mi>
    <mo>.</mo>
    <mpadded width="+5pt">
     <mi>G</mi>
    </mpadded>
    <mi>H</mi>
    <mo rspace="7.5pt" stretchy="false">)</mo>
   </mrow>
   <mi>Y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">E</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">G</csymbol>
     <csymbol cd="unknown">H</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">Y</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\lambda E.G\ H)\ Y
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>

<math display="inline" id="Lambda_lifting:143">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>p</mi>
    <mo>.</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mpadded width="+5pt">
      <mi>p</mi>
     </mpadded>
     <mi>f</mi>
     <mo rspace="7.5pt" stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mpadded width="+5pt">
      <mi>p</mi>
     </mpadded>
     <mi>f</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo rspace="7.5pt" stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>f</mi>
    <mo>.</mo>
    <mi>λ</mi>
    <mi>x</mi>
    <mo>.</mo>
    <mpadded width="+5pt">
     <mi>f</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mpadded width="+5pt">
      <mi>x</mi>
     </mpadded>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">p</csymbol>
     <ci>normal-.</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">p</csymbol>
      <csymbol cd="unknown">f</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">p</csymbol>
      <csymbol cd="unknown">f</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">f</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">f</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\lambda p.(p\ f)\ (p\ f))\ (\lambda f.\lambda x.f\ (x\ x))
  </annotation>
 </semantics>
</math>


</p></td>
</tr>
</tbody>
</table></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Lambda_lifting:144">
 <semantics>
  <mrow>
   <mi>λ</mi>
   <mi>f</mi>
   <mo>.</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>p</mi>
    <mo>.</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mpadded width="+5pt">
      <mi>p</mi>
     </mpadded>
     <mi>f</mi>
     <mo rspace="7.5pt" stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mpadded width="+5pt">
      <mi>p</mi>
     </mpadded>
     <mi>f</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo rspace="7.5pt" stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>f</mi>
    <mo>.</mo>
    <mi>λ</mi>
    <mi>x</mi>
    <mo>.</mo>
    <mpadded width="+5pt">
     <mi>f</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mpadded width="+5pt">
      <mi>x</mi>
     </mpadded>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">f</csymbol>
    <ci>normal-.</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">p</csymbol>
     <ci>normal-.</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">p</csymbol>
      <csymbol cd="unknown">f</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">p</csymbol>
      <csymbol cd="unknown">f</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">f</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">f</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda f.(\lambda p.(p\ f)\ (p\ f))\ (\lambda f.\lambda x.f\ (x\ x))
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
</tbody>
</table></td>
</tr>
</tbody>
</table>
<h3 id="parameter-dropping">Parameter dropping</h3>

<p>Parameter dropping is optimizing a function for its position in the function. Lambda lifting added parameters that were necessary so that a function can be moved out of its context. In dropping, this process is reversed, and extra parameters that contain variables that are free may be removed.</p>

<p>Dropping a parameter is removing an unnecessary parameter from a function, where the actual parameter being passed in is always the same expression. The free variables of the expression must also be free where the function is defined. In this case the parameter that is dropped is replaced by the expression in the body of the function definition. This makes the parameter unnecessary.</p>

<p>For example, consider,</p>

<p>

<math display="block" id="Lambda_lifting:145">
 <semantics>
  <mrow>
   <mi>λ</mi>
   <mi>m</mi>
   <mo>,</mo>
   <mi>p</mi>
   <mo>,</mo>
   <mi>q</mi>
   <mo>.</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>g</mi>
    <mo>.</mo>
    <mi>λ</mi>
    <mi>n</mi>
    <mo>.</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mpadded width="+5pt">
      <mi>n</mi>
     </mpadded>
     <mrow>
      <mo stretchy="false">(</mo>
      <mpadded width="+5pt">
       <mi>g</mi>
      </mpadded>
      <mpadded width="+5pt">
       <mi>m</mi>
      </mpadded>
      <mpadded width="+5pt">
       <mi>p</mi>
      </mpadded>
      <mi>n</mi>
      <mo rspace="7.5pt" stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mpadded width="+5pt">
       <mi>g</mi>
      </mpadded>
      <mpadded width="+5pt">
       <mi>q</mi>
      </mpadded>
      <mpadded width="+5pt">
       <mi>p</mi>
      </mpadded>
      <mi>n</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo rspace="7.5pt" stretchy="false">)</mo>
   </mrow>
   <mi>λ</mi>
   <mi>x</mi>
   <mo>.</mo>
   <mi>λ</mi>
   <mi>o</mi>
   <mo>.</mo>
   <mi>λ</mi>
   <mi>y</mi>
   <mo>.</mo>
   <mpadded width="+5pt">
    <mi>o</mi>
   </mpadded>
   <mpadded width="+5pt">
    <mi>x</mi>
   </mpadded>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">m</csymbol>
    <ci>normal-,</ci>
    <csymbol cd="unknown">p</csymbol>
    <ci>normal-,</ci>
    <csymbol cd="unknown">q</csymbol>
    <ci>normal-.</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">g</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">n</csymbol>
     <ci>normal-.</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">n</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">g</csymbol>
       <csymbol cd="unknown">m</csymbol>
       <csymbol cd="unknown">p</csymbol>
       <csymbol cd="unknown">n</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">g</csymbol>
       <csymbol cd="unknown">q</csymbol>
       <csymbol cd="unknown">p</csymbol>
       <csymbol cd="unknown">n</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <ci>normal-.</ci>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">o</csymbol>
    <ci>normal-.</ci>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">y</csymbol>
    <ci>normal-.</ci>
    <csymbol cd="unknown">o</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <csymbol cd="unknown">y</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda m,p,q.(\lambda g.\lambda n.(n\ (g\ m\ p\ n)\ (g\ q\ p\ n)))\ \lambda x%
.\lambda o.\lambda y.o\ x\ y
  </annotation>
 </semantics>
</math>

</p>

<p>In this example the actual parameter for the formal parameter <em>o</em> is always <em>p</em>. As <em>p</em> is a free variable in the whole expression, the parameter may be dropped. The actual parameter for the formal parameter <em>y</em> is always <em>n</em>. However <em>n</em> is bound in a lambda abstraction. So this parameter may not be dropped.</p>

<p>The result of dropping the parameter is,</p>

<p>

<math display="block" id="Lambda_lifting:146">
 <semantics>
  <mrow>
   <mrow>
    <mi>drop</mi>
    <mo>-</mo>
    <mi>params</mi>
    <mo>-</mo>
    <mi>tran</mi>
   </mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>λ</mi>
    <mi>m</mi>
    <mo>,</mo>
    <mi>p</mi>
    <mo>,</mo>
    <mi>q</mi>
    <mo>.</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mi>g</mi>
     <mo>.</mo>
     <mi>λ</mi>
     <mi>n</mi>
     <mo>.</mo>
     <mpadded width="+5pt">
      <mi>n</mi>
     </mpadded>
     <mrow>
      <mo stretchy="false">(</mo>
      <mpadded width="+5pt">
       <mi>g</mi>
      </mpadded>
      <mpadded width="+5pt">
       <mi>m</mi>
      </mpadded>
      <mpadded width="+5pt">
       <mi>p</mi>
      </mpadded>
      <mi>n</mi>
      <mo rspace="7.5pt" stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mpadded width="+5pt">
       <mi>g</mi>
      </mpadded>
      <mpadded width="+5pt">
       <mi>q</mi>
      </mpadded>
      <mpadded width="+5pt">
       <mi>p</mi>
      </mpadded>
      <mi>n</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo rspace="7.5pt" stretchy="false">)</mo>
    </mrow>
    <mi>λ</mi>
    <mi>x</mi>
    <mo>.</mo>
    <mi>λ</mi>
    <mi>o</mi>
    <mo>.</mo>
    <mi>λ</mi>
    <mi>y</mi>
    <mo>.</mo>
    <mpadded width="+5pt">
     <mi>o</mi>
    </mpadded>
    <mpadded width="+5pt">
     <mi>x</mi>
    </mpadded>
    <mi>y</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <minus></minus>
     <ci>drop</ci>
     <ci>params</ci>
     <ci>tran</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">m</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">p</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">q</csymbol>
     <ci>normal-.</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">g</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">n</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">n</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">g</csymbol>
       <csymbol cd="unknown">m</csymbol>
       <csymbol cd="unknown">p</csymbol>
       <csymbol cd="unknown">n</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">g</csymbol>
       <csymbol cd="unknown">q</csymbol>
       <csymbol cd="unknown">p</csymbol>
       <csymbol cd="unknown">n</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">o</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">o</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="unknown">y</csymbol>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{drop-params-tran}[\lambda m,p,q.(\lambda g.\lambda n.n\ (g\ m\ p%
\ n)\ (g\ q\ p\ n))\ \lambda x.\lambda o.\lambda y.o\ x\ y
  </annotation>
 </semantics>
</math>

</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Lambda_lifting:147">
 <semantics>
  <mrow>
   <mo>≡</mo>
   <mi>λ</mi>
   <mi>m</mi>
   <mo>,</mo>
   <mi>p</mi>
   <mo>,</mo>
   <mi>q</mi>
   <mo>.</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>g</mi>
    <mo>.</mo>
    <mi>λ</mi>
    <mi>n</mi>
    <mo>.</mo>
    <mpadded width="+5pt">
     <mi>n</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mpadded width="+5pt">
      <mi>g</mi>
     </mpadded>
     <mpadded width="+5pt">
      <mi>m</mi>
     </mpadded>
     <mi>n</mi>
     <mo rspace="7.5pt" stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mpadded width="+5pt">
      <mi>g</mi>
     </mpadded>
     <mpadded width="+5pt">
      <mi>q</mi>
     </mpadded>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo rspace="7.5pt" stretchy="false">)</mo>
   </mrow>
   <mi>λ</mi>
   <mi>x</mi>
   <mo>.</mo>
   <mi>λ</mi>
   <mi>y</mi>
   <mo>.</mo>
   <mpadded width="+5pt">
    <mi>p</mi>
   </mpadded>
   <mpadded width="+5pt">
    <mi>x</mi>
   </mpadded>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <equivalent></equivalent>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">m</csymbol>
    <ci>normal-,</ci>
    <csymbol cd="unknown">p</csymbol>
    <ci>normal-,</ci>
    <csymbol cd="unknown">q</csymbol>
    <ci>normal-.</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">g</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">n</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">n</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">g</csymbol>
      <csymbol cd="unknown">m</csymbol>
      <csymbol cd="unknown">n</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">g</csymbol>
      <csymbol cd="unknown">q</csymbol>
      <csymbol cd="unknown">n</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <ci>normal-.</ci>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">y</csymbol>
    <ci>normal-.</ci>
    <csymbol cd="unknown">p</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <csymbol cd="unknown">y</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \equiv\lambda m,p,q.(\lambda g.\lambda n.n\ (g\ m\ n)\ (g\ q\ n))\ \lambda x.%
\lambda y.p\ x\ y
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>For the main example,</p>

<p>

<math display="block" id="Lambda_lifting:148">
 <semantics>
  <mrow>
   <mrow>
    <mi>drop</mi>
    <mo>-</mo>
    <mi>params</mi>
    <mo>-</mo>
    <mi>tran</mi>
   </mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>λ</mi>
    <mi>f</mi>
    <mo>.</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mi>p</mi>
     <mo>.</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mpadded width="+5pt">
       <mi>p</mi>
      </mpadded>
      <mi>f</mi>
      <mo rspace="7.5pt" stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mpadded width="+5pt">
       <mi>p</mi>
      </mpadded>
      <mi>f</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo rspace="7.5pt" stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mi>f</mi>
     <mo>.</mo>
     <mi>λ</mi>
     <mi>x</mi>
     <mo>.</mo>
     <mpadded width="+5pt">
      <mi>f</mi>
     </mpadded>
     <mrow>
      <mo stretchy="false">(</mo>
      <mpadded width="+5pt">
       <mi>x</mi>
      </mpadded>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <minus></minus>
     <ci>drop</ci>
     <ci>params</ci>
     <ci>tran</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">f</csymbol>
     <ci>normal-.</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">p</csymbol>
      <ci>normal-.</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">p</csymbol>
       <csymbol cd="unknown">f</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">p</csymbol>
       <csymbol cd="unknown">f</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">f</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">f</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">x</csymbol>
       <csymbol cd="unknown">x</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{drop-params-tran}[\lambda f.(\lambda p.(p\ f)\ (p\ f))\ (\lambda
f%
.\lambda x.f\ (x\ x))]
  </annotation>
 </semantics>
</math>

</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Lambda_lifting:149">
 <semantics>
  <mrow>
   <mo>≡</mo>
   <mi>λ</mi>
   <mi>f</mi>
   <mo>.</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>p</mi>
    <mo>.</mo>
    <mpadded width="+5pt">
     <mi>p</mi>
    </mpadded>
    <mi>p</mi>
    <mo rspace="7.5pt" stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>x</mi>
    <mo>.</mo>
    <mpadded width="+5pt">
     <mi>f</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mpadded width="+5pt">
      <mi>x</mi>
     </mpadded>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <equivalent></equivalent>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">f</csymbol>
    <ci>normal-.</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">p</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">p</csymbol>
     <csymbol cd="unknown">p</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">f</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \equiv\lambda f.(\lambda p.p\ p)\ (\lambda x.f\ (x\ x))
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>The definition of <em>drop-params-tran</em> is,</p>

<p>

<math display="block" id="Lambda_lifting:150">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>drop</mi>
     <mo>-</mo>
     <mi>params</mi>
     <mo>-</mo>
     <mi>tran</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>L</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>≡</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mrow>
      <mi>drop</mi>
      <mo>-</mo>
      <mi>params</mi>
     </mrow>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>L</mi>
      <mo>,</mo>
      <mi>D</mi>
      <mo>,</mo>
      <mrow>
       <mi>F</mi>
       <mi>V</mi>
       <mrow>
        <mo stretchy="false">[</mo>
        <mi>L</mi>
        <mo stretchy="false">]</mo>
       </mrow>
      </mrow>
      <mo>,</mo>
      <mrow>
       <mo stretchy="false">[</mo>
       <mo stretchy="false">]</mo>
      </mrow>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <apply>
      <minus></minus>
      <ci>drop</ci>
      <ci>params</ci>
      <ci>tran</ci>
     </apply>
     <ci>L</ci>
    </apply>
    <apply>
     <apply>
      <minus></minus>
      <ci>drop</ci>
      <ci>params</ci>
     </apply>
     <ci>L</ci>
     <ci>D</ci>
     <apply>
      <times></times>
      <ci>F</ci>
      <ci>V</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <ci>L</ci>
      </apply>
     </apply>
     <list></list>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{drop-params-tran}[L]\equiv(\operatorname{drop-params}[L,D,FV[L],%
[]])
  </annotation>
 </semantics>
</math>

 where,</p>

<p>

<math display="block" id="Lambda_lifting:151">
 <semantics>
  <mrow>
   <mrow>
    <mi>build</mi>
    <mo>-</mo>
    <mi>param</mi>
    <mo>-</mo>
    <mi>list</mi>
   </mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>L</mi>
    <mo>,</mo>
    <mi>D</mi>
    <mo>,</mo>
    <mi>V</mi>
    <mo>,</mo>
    <mi mathvariant="normal">_</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <minus></minus>
     <ci>build</ci>
     <ci>param</ci>
     <ci>list</ci>
    </apply>
    <ci>L</ci>
    <ci>D</ci>
    <ci>V</ci>
    <ci>normal-_</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{build-param-list}[L,D,V,\_]
  </annotation>
 </semantics>
</math>

</p>
<h4 id="build-parameter-lists">Build parameter lists</h4>

<p>For each abstraction that defines a function, build the information required to make decisions on dropping names. This information describes each parameter; the parameter name, the expression for the actual value, and an indication that all the expressions have the same value.</p>

<p>For example in,</p>

<p>

<math display="block" id="Lambda_lifting:152">
 <semantics>
  <mrow>
   <mi>λ</mi>
   <mi>m</mi>
   <mo>,</mo>
   <mi>p</mi>
   <mo>,</mo>
   <mi>q</mi>
   <mo>.</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>g</mi>
    <mo>.</mo>
    <mi>λ</mi>
    <mi>n</mi>
    <mo>.</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mpadded width="+5pt">
      <mi>n</mi>
     </mpadded>
     <mrow>
      <mo stretchy="false">(</mo>
      <mpadded width="+5pt">
       <mi>g</mi>
      </mpadded>
      <mpadded width="+5pt">
       <mi>m</mi>
      </mpadded>
      <mpadded width="+5pt">
       <mi>p</mi>
      </mpadded>
      <mi>n</mi>
      <mo rspace="7.5pt" stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mpadded width="+5pt">
       <mi>g</mi>
      </mpadded>
      <mpadded width="+5pt">
       <mi>q</mi>
      </mpadded>
      <mpadded width="+5pt">
       <mi>p</mi>
      </mpadded>
      <mi>n</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo rspace="7.5pt" stretchy="false">)</mo>
   </mrow>
   <mi>λ</mi>
   <mi>x</mi>
   <mo>.</mo>
   <mi>λ</mi>
   <mi>o</mi>
   <mo>.</mo>
   <mi>λ</mi>
   <mi>y</mi>
   <mo>.</mo>
   <mpadded width="+5pt">
    <mi>o</mi>
   </mpadded>
   <mpadded width="+5pt">
    <mi>x</mi>
   </mpadded>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">m</csymbol>
    <ci>normal-,</ci>
    <csymbol cd="unknown">p</csymbol>
    <ci>normal-,</ci>
    <csymbol cd="unknown">q</csymbol>
    <ci>normal-.</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">g</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">n</csymbol>
     <ci>normal-.</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">n</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">g</csymbol>
       <csymbol cd="unknown">m</csymbol>
       <csymbol cd="unknown">p</csymbol>
       <csymbol cd="unknown">n</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">g</csymbol>
       <csymbol cd="unknown">q</csymbol>
       <csymbol cd="unknown">p</csymbol>
       <csymbol cd="unknown">n</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <ci>normal-.</ci>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">o</csymbol>
    <ci>normal-.</ci>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">y</csymbol>
    <ci>normal-.</ci>
    <csymbol cd="unknown">o</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <csymbol cd="unknown">y</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda m,p,q.(\lambda g.\lambda n.(n\ (g\ m\ p\ n)\ (g\ q\ p\ n)))\ \lambda x%
.\lambda o.\lambda y.o\ x\ y
  </annotation>
 </semantics>
</math>

</p>

<p>the parameters to the function <em>g</em> are,</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>Formal Parameter</p></th>
<th style="text-align: left;">
<p>All Same Value</p></th>
<th style="text-align: left;">
<p>Actual parameter expression</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p><em>x</em></p></td>
<td style="text-align: left;">
<p>false</p></td>
<td style="text-align: left;">
<p>_</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><em>o</em></p></td>
<td style="text-align: left;">
<p>true</p></td>
<td style="text-align: left;">
<p><em>p</em></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><em>y</em></p></td>
<td style="text-align: left;">
<p>true</p></td>
<td style="text-align: left;">
<p><em>n</em></p></td>
</tr>
</tbody>
</table>

<p>Each abstraction is renamed with a unique name, and the parameter list is associated with the name of the abstraction. For example, <em>g</em> there is parameter list.</p>

<p>

<math display="block" id="Lambda_lifting:153">
 <semantics>
  <mrow>
   <mrow>
    <mi>D</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>g</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mo>false</mo>
     <mo>,</mo>
     <mi mathvariant="normal">_</mi>
     <mo stretchy="false">]</mo>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>o</mi>
     <mo>,</mo>
     <mi mathvariant="normal">_</mi>
     <mo>,</mo>
     <mi>p</mi>
     <mo stretchy="false">]</mo>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>y</mi>
     <mo>,</mo>
     <mi mathvariant="normal">_</mi>
     <mo>,</mo>
     <mi>n</mi>
     <mo stretchy="false">]</mo>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>D</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>g</ci>
     </apply>
    </apply>
    <list>
     <list>
      <ci>x</ci>
      <ci>false</ci>
      <ci>normal-_</ci>
     </list>
     <list>
      <ci>o</ci>
      <ci>normal-_</ci>
      <ci>p</ci>
     </list>
     <list>
      <ci>y</ci>
      <ci>normal-_</ci>
      <ci>n</ci>
     </list>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D[g]=[[x,\operatorname{false},\_],[o,\_,p],[y,\_,n]]
  </annotation>
 </semantics>
</math>

</p>

<p><em>build-param-lists</em> builds all the lists for an expression, by traversing the expression. It has four parameters;</p>
<ul>
<li>The lambda expression being analyzed.</li>
<li>The table parameter lists for names.</li>
<li>The table of values for parameters.</li>
<li>The returned parameter list, which is used internally by the</li>
</ul>

<p><strong>Abstraction</strong> - A lambda expression of the form 

<math display="inline" id="Lambda_lifting:154">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>N</mi>
    <mo>.</mo>
    <mi>S</mi>
    <mo rspace="7.5pt" stretchy="false">)</mo>
   </mrow>
   <mi>L</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">N</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">S</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">L</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\lambda N.S)\ L
  </annotation>
 </semantics>
</math>

 is analyzed to extract the names of parameters for the function.</p>

<p>

<math display="block" id="Lambda_lifting:155">
 <semantics>
  <mrow>
   <mrow>
    <mi>build</mi>
    <mo>-</mo>
    <mi>param</mi>
    <mo>-</mo>
    <mi>lists</mi>
   </mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mi>N</mi>
     <mo>.</mo>
     <mi>S</mi>
     <mo rspace="7.5pt" stretchy="false">)</mo>
    </mrow>
    <mi>L</mi>
    <mo>,</mo>
    <mi>D</mi>
    <mo>,</mo>
    <mi>V</mi>
    <mo>,</mo>
    <mi>R</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>≡</mo>
   <mrow>
    <mi>build</mi>
    <mo>-</mo>
    <mi>param</mi>
    <mo>-</mo>
    <mi>lists</mi>
   </mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>S</mi>
    <mo>,</mo>
    <mi>D</mi>
    <mo>,</mo>
    <mi>V</mi>
    <mo>,</mo>
    <mi>R</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mi mathvariant="italic">and</mi>
   <mrow>
    <mi>build</mi>
    <mo>-</mo>
    <mi>list</mi>
   </mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>L</mi>
    <mo>,</mo>
    <mi>D</mi>
    <mo>,</mo>
    <mi>V</mi>
    <mo>,</mo>
    <mi>D</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>N</mi>
     <mo stretchy="false">]</mo>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <minus></minus>
     <ci>build</ci>
     <ci>param</ci>
     <ci>lists</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">N</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">S</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <csymbol cd="unknown">L</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">D</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">V</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">R</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <equivalent></equivalent>
    <apply>
     <minus></minus>
     <ci>build</ci>
     <ci>param</ci>
     <ci>lists</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">S</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">D</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">V</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">R</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <csymbol cd="unknown">and</csymbol>
    <apply>
     <minus></minus>
     <ci>build</ci>
     <ci>list</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">L</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">D</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">V</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">D</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-[</ci>
      <csymbol cd="unknown">N</csymbol>
      <ci>normal-]</ci>
     </cerror>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{build-param-lists}[(\lambda N.S)\ L,D,V,R]\equiv\operatorname{%
build-param-lists}[S,D,V,R]\and\operatorname{build-list}[L,D,V,D[N]]
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Lambda_lifting:156">
 <semantics>
  <mrow>
   <mrow>
    <mi>build</mi>
    <mo>-</mo>
    <mi>param</mi>
    <mo>-</mo>
    <mi>lists</mi>
   </mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>λ</mi>
    <mi>N</mi>
    <mo>.</mo>
    <mi>S</mi>
    <mo>,</mo>
    <mi>D</mi>
    <mo>,</mo>
    <mi>V</mi>
    <mo>,</mo>
    <mi>R</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>≡</mo>
   <mrow>
    <mi>build</mi>
    <mo>-</mo>
    <mi>param</mi>
    <mo>-</mo>
    <mi>lists</mi>
   </mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>S</mi>
    <mo>,</mo>
    <mi>D</mi>
    <mo>,</mo>
    <mi>V</mi>
    <mo>,</mo>
    <mi>R</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <minus></minus>
     <ci>build</ci>
     <ci>param</ci>
     <ci>lists</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">N</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">S</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">D</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">V</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">R</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <equivalent></equivalent>
    <apply>
     <minus></minus>
     <ci>build</ci>
     <ci>param</ci>
     <ci>lists</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">S</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">D</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">V</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">R</csymbol>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{build-param-lists}[\lambda N.S,D,V,R]\equiv\operatorname{build-%
param-lists}[S,D,V,R]
  </annotation>
 </semantics>
</math>

</p>

<p>Locate the name and start building the parameter list for the name, filling in the formal parameter names. Also receive any actual parameter list from the body of the expression, and return it as the actual parameter list from this expression</p>

<p>

<math display="block" id="Lambda_lifting:157">
 <semantics>
  <mrow>
   <mrow>
    <mi>build</mi>
    <mo>-</mo>
    <mi>list</mi>
   </mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>λ</mi>
    <mi>P</mi>
    <mo>.</mo>
    <mi>B</mi>
    <mo>,</mo>
    <mi>D</mi>
    <mo>,</mo>
    <mi>V</mi>
    <mo>,</mo>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>X</mi>
     <mo>,</mo>
     <mi mathvariant="normal">_</mi>
     <mo>,</mo>
     <mi mathvariant="normal">_</mi>
     <mo stretchy="false">]</mo>
    </mrow>
    <mo>:</mo>
    <mo>:</mo>
    <mi>L</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>≡</mo>
   <mrow>
    <mi>build</mi>
    <mo>-</mo>
    <mi>list</mi>
   </mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>B</mi>
    <mo>,</mo>
    <mi>D</mi>
    <mo>,</mo>
    <mi>V</mi>
    <mo>,</mo>
    <mi>L</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <minus></minus>
     <ci>build</ci>
     <ci>list</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">P</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">B</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">D</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">V</csymbol>
     <ci>normal-,</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-[</ci>
      <csymbol cd="unknown">X</csymbol>
      <ci>normal-,</ci>
      <csymbol cd="unknown">_</csymbol>
      <ci>normal-,</ci>
      <csymbol cd="unknown">_</csymbol>
      <ci>normal-]</ci>
     </cerror>
     <ci>normal-:</ci>
     <ci>normal-:</ci>
     <csymbol cd="unknown">L</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <equivalent></equivalent>
    <apply>
     <minus></minus>
     <ci>build</ci>
     <ci>list</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">B</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">D</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">V</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">L</csymbol>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{build-list}[\lambda P.B,D,V,[X,\_,\_]::L]\equiv\operatorname{%
build-list}[B,D,V,L]
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Lambda_lifting:158">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>build</mi>
     <mo>-</mo>
     <mi>list</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>B</mi>
     <mo>,</mo>
     <mi>D</mi>
     <mo>,</mo>
     <mi>V</mi>
     <mo>,</mo>
     <mrow>
      <mo stretchy="false">[</mo>
      <mo stretchy="false">]</mo>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>≡</mo>
   <mrow>
    <mrow>
     <mi>build</mi>
     <mo>-</mo>
     <mi>param</mi>
     <mo>-</mo>
     <mi>lists</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>B</mi>
     <mo>,</mo>
     <mi>D</mi>
     <mo>,</mo>
     <mi>V</mi>
     <mo>,</mo>
     <mi mathvariant="normal">_</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <apply>
      <minus></minus>
      <ci>build</ci>
      <ci>list</ci>
     </apply>
     <ci>B</ci>
     <ci>D</ci>
     <ci>V</ci>
     <list></list>
    </apply>
    <apply>
     <apply>
      <minus></minus>
      <ci>build</ci>
      <ci>param</ci>
      <ci>lists</ci>
     </apply>
     <ci>B</ci>
     <ci>D</ci>
     <ci>V</ci>
     <ci>normal-_</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{build-list}[B,D,V,[]]\equiv\operatorname{build-param-lists}[B,D,%
V,\_]
  </annotation>
 </semantics>
</math>

</p>

<p><strong>Variable</strong> - A call to a function.</p>

<p>

<math display="block" id="Lambda_lifting:159">
 <semantics>
  <mrow>
   <mrow>
    <mi>build</mi>
    <mo>-</mo>
    <mi>param</mi>
    <mo>-</mo>
    <mi>lists</mi>
   </mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>N</mi>
    <mo>,</mo>
    <mi>D</mi>
    <mo>,</mo>
    <mi>V</mi>
    <mo>,</mo>
    <mrow>
     <mi>D</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>N</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <minus></minus>
     <ci>build</ci>
     <ci>param</ci>
     <ci>lists</ci>
    </apply>
    <ci>N</ci>
    <ci>D</ci>
    <ci>V</ci>
    <apply>
     <times></times>
     <ci>D</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>N</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{build-param-lists}[N,D,V,D[N]]
  </annotation>
 </semantics>
</math>

</p>

<p>For a function name or parameter start populating actual parameter list by outputting the parameter list for this name.</p>

<p><strong>Application</strong> - An application (function call) is processed to extract actual parameter details.</p>

<p>

<math display="block" id="Lambda_lifting:160">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>build</mi>
     <mo>-</mo>
     <mi>param</mi>
     <mo>-</mo>
     <mi>lists</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>E</mi>
      </mpadded>
      <mi>P</mi>
     </mrow>
     <mo>,</mo>
     <mi>D</mi>
     <mo>,</mo>
     <mi>V</mi>
     <mo>,</mo>
     <mi>R</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>≡</mo>
   <mrow>
    <mrow>
     <mrow>
      <mi>build</mi>
      <mo>-</mo>
      <mi>param</mi>
      <mo>-</mo>
      <mi>lists</mi>
     </mrow>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>E</mi>
      <mo>,</mo>
      <mi>D</mi>
      <mo>,</mo>
      <mi>V</mi>
      <mo>,</mo>
      <mi>T</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mi mathvariant="italic">and</mi>
    <mrow>
     <mrow>
      <mi>build</mi>
      <mo>-</mo>
      <mi>param</mi>
      <mo>-</mo>
      <mi>lists</mi>
     </mrow>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>P</mi>
      <mo>,</mo>
      <mi>D</mi>
      <mo>,</mo>
      <mi>V</mi>
      <mo>,</mo>
      <mi>K</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <apply>
      <minus></minus>
      <ci>build</ci>
      <ci>param</ci>
      <ci>lists</ci>
     </apply>
     <apply>
      <times></times>
      <ci>E</ci>
      <ci>P</ci>
     </apply>
     <ci>D</ci>
     <ci>V</ci>
     <ci>R</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <apply>
       <minus></minus>
       <ci>build</ci>
       <ci>param</ci>
       <ci>lists</ci>
      </apply>
      <ci>E</ci>
      <ci>D</ci>
      <ci>V</ci>
      <ci>T</ci>
     </apply>
     <ci>italic- and</ci>
     <apply>
      <apply>
       <minus></minus>
       <ci>build</ci>
       <ci>param</ci>
       <ci>lists</ci>
      </apply>
      <ci>P</ci>
      <ci>D</ci>
      <ci>V</ci>
      <ci>K</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{build-param-lists}[E\ P,D,V,R]\equiv\operatorname{build-param-%
lists}[E,D,V,T]\and\operatorname{build-param-lists}[P,D,V,K]
  </annotation>
 </semantics>
</math>

</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Lambda_lifting:161">
 <semantics>
  <mrow>
   <mi mathvariant="italic">and</mi>
   <mi>T</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>F</mi>
    <mo>,</mo>
    <mi>S</mi>
    <mo>,</mo>
    <mi>A</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>:</mo>
   <mo>:</mo>
   <mi>R</mi>
   <mi mathvariant="italic">and</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>S</mi>
    <mo>⟹</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mo>equate</mo>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>A</mi>
      <mo>,</mo>
      <mi>P</mi>
      <mo stretchy="false">]</mo>
     </mrow>
     <mi mathvariant="italic">and</mi>
     <mi>V</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>F</mi>
      <mo stretchy="false">]</mo>
     </mrow>
     <mo>=</mo>
     <mi>A</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi mathvariant="italic">and</mi>
   <mi>D</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>F</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>=</mo>
   <mi>K</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">and</csymbol>
    <csymbol cd="unknown">T</csymbol>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">F</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">S</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">A</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <ci>normal-:</ci>
    <ci>normal-:</ci>
    <csymbol cd="unknown">R</csymbol>
    <csymbol cd="unknown">and</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">S</csymbol>
     <implies></implies>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <ci>equate</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-[</ci>
       <csymbol cd="unknown">A</csymbol>
       <ci>normal-,</ci>
       <csymbol cd="unknown">P</csymbol>
       <ci>normal-]</ci>
      </cerror>
      <csymbol cd="unknown">and</csymbol>
      <csymbol cd="unknown">V</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-[</ci>
       <csymbol cd="unknown">F</csymbol>
       <ci>normal-]</ci>
      </cerror>
      <eq></eq>
      <csymbol cd="unknown">A</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">and</csymbol>
    <csymbol cd="unknown">D</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">F</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">K</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \and T=[F,S,A]::R\and(S\implies(\operatorname{equate}[A,P]\and V[F]=A))\and D[%
F]=K
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>Retrieve the parameter lists for the expression, and the parameter. Retrieve a parameter record from the parameter list from the expression, and check that the current parameter value matches this parameter. Record the value for the parameter name for use later in checking.</p>

<p>

<math display="block" id="Lambda_lifting:162">
 <semantics>
  <mrow>
   <mo>equate</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>A</mi>
    <mo>,</mo>
    <mi>N</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>≡</mo>
   <mi>A</mi>
   <mo>=</mo>
   <mi>N</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>def</mo>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>V</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>N</mi>
      <mo stretchy="false">]</mo>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
    <mi mathvariant="italic">and</mi>
    <mi>A</mi>
    <mo>=</mo>
    <mi>V</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>N</mi>
     <mo stretchy="false">]</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>equate</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">A</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">N</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <equivalent></equivalent>
    <csymbol cd="unknown">A</csymbol>
    <eq></eq>
    <csymbol cd="unknown">N</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <ci>def</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-[</ci>
      <csymbol cd="unknown">V</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-[</ci>
       <csymbol cd="unknown">N</csymbol>
       <ci>normal-]</ci>
      </cerror>
      <ci>normal-]</ci>
     </cerror>
     <csymbol cd="unknown">and</csymbol>
     <csymbol cd="unknown">A</csymbol>
     <eq></eq>
     <csymbol cd="unknown">V</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-[</ci>
      <csymbol cd="unknown">N</csymbol>
      <ci>normal-]</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{equate}[A,N]\equiv A=N(\operatorname{def}[V[N]]\and A=V[N])
  </annotation>
 </semantics>
</math>

 ... if N is a variable.</p>

<p>

<math display="block" id="Lambda_lifting:163">
 <semantics>
  <mrow>
   <mrow>
    <mo>equate</mo>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>A</mi>
     <mo>,</mo>
     <mi>E</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>≡</mo>
   <mi>A</mi>
   <mo>=</mo>
   <mi>E</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <equivalent></equivalent>
     <apply>
      <ci>equate</ci>
      <ci>A</ci>
      <ci>E</ci>
     </apply>
     <ci>A</ci>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <ci>E</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{equate}[A,E]\equiv A=E
  </annotation>
 </semantics>
</math>

 ... otherwise.</p>

<p>The above logic is quite subtle in the way that it works. The same value indicator is never set to true. It is only set to false if all the values cannot be matched. The value is retrieved by using <em>S</em> to build a set of the Boolean values allowed for <em>S</em>. If true is a member then all the values for this parameter are equal, and the parameter may be dropped.</p>

<p>

<math display="block" id="Lambda_lifting:164">
 <semantics>
  <mrow>
   <mrow>
    <mo>ask</mo>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>S</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>≡</mo>
   <mi>S</mi>
   <mo>∈</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mi>X</mi>
    <mo>:</mo>
    <mrow>
     <mi>X</mi>
     <mo>=</mo>
     <mi>S</mi>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <equivalent></equivalent>
     <apply>
      <ci>ask</ci>
      <ci>S</ci>
     </apply>
     <ci>S</ci>
    </apply>
    <apply>
     <in></in>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="latexml">conditional-set</csymbol>
      <ci>X</ci>
      <apply>
       <eq></eq>
       <ci>X</ci>
       <ci>S</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{ask}[S]\equiv S\in\{X:X=S\}
  </annotation>
 </semantics>
</math>

</p>

<p>Similarly, <em>def</em> uses set theory to query if a variable has been given a value;</p>

<p>

<math display="block" id="Lambda_lifting:165">
 <semantics>
  <mrow>
   <mrow>
    <mo>def</mo>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>F</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>≡</mo>
   <mrow>
    <mo stretchy="false">|</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mi>X</mi>
     <mo>:</mo>
     <mrow>
      <mi>X</mi>
      <mo>=</mo>
      <mi>F</mi>
     </mrow>
     <mo stretchy="false">}</mo>
    </mrow>
    <mo stretchy="false">|</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <ci>def</ci>
     <ci>F</ci>
    </apply>
    <apply>
     <abs></abs>
     <apply>
      <csymbol cd="latexml">conditional-set</csymbol>
      <ci>X</ci>
      <apply>
       <eq></eq>
       <ci>X</ci>
       <ci>F</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{def}[F]\equiv|\{X:X=F\}|
  </annotation>
 </semantics>
</math>

</p>

<p><strong>Let</strong> - Let expression.</p>

<p>

<math display="block" id="Lambda_lifting:166">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>build</mi>
     <mo>-</mo>
     <mi>param</mi>
     <mo>-</mo>
     <mi>list</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mrow>
       <mo>let</mo>
       <mi>V</mi>
      </mrow>
      <mo>:</mo>
      <mrow>
       <mrow>
        <mi>E</mi>
        <mrow>
         <mo>in</mo>
         <mi>L</mi>
        </mrow>
       </mrow>
       <mo>,</mo>
       <mi>D</mi>
       <mo>,</mo>
       <mi>V</mi>
       <mo>,</mo>
       <mi mathvariant="normal">_</mi>
      </mrow>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>≡</mo>
   <mrow>
    <mrow>
     <mrow>
      <mi>build</mi>
      <mo>-</mo>
      <mi>param</mi>
      <mo>-</mo>
      <mi>list</mi>
     </mrow>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>E</mi>
      <mo>,</mo>
      <mi>D</mi>
      <mo>,</mo>
      <mi>V</mi>
      <mo>,</mo>
      <mi mathvariant="normal">_</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mi mathvariant="italic">and</mi>
    <mrow>
     <mrow>
      <mi>build</mi>
      <mo>-</mo>
      <mi>param</mi>
      <mo>-</mo>
      <mi>list</mi>
     </mrow>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>L</mi>
      <mo>,</mo>
      <mi>D</mi>
      <mo>,</mo>
      <mi>V</mi>
      <mo>,</mo>
      <mi mathvariant="normal">_</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <apply>
      <minus></minus>
      <ci>build</ci>
      <ci>param</ci>
      <ci>list</ci>
     </apply>
     <apply>
      <ci>normal-:</ci>
      <apply>
       <ci>let</ci>
       <ci>V</ci>
      </apply>
      <list>
       <apply>
        <times></times>
        <ci>E</ci>
        <apply>
         <ci>in</ci>
         <ci>L</ci>
        </apply>
       </apply>
       <ci>D</ci>
       <ci>V</ci>
       <ci>normal-_</ci>
      </list>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <apply>
       <minus></minus>
       <ci>build</ci>
       <ci>param</ci>
       <ci>list</ci>
      </apply>
      <ci>E</ci>
      <ci>D</ci>
      <ci>V</ci>
      <ci>normal-_</ci>
     </apply>
     <ci>italic- and</ci>
     <apply>
      <apply>
       <minus></minus>
       <ci>build</ci>
       <ci>param</ci>
       <ci>list</ci>
      </apply>
      <ci>L</ci>
      <ci>D</ci>
      <ci>V</ci>
      <ci>normal-_</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{build-param-list}[\operatorname{let}V:E\operatorname{in}L,D,V,\_%
]\equiv\operatorname{build-param-list}[E,D,V,\_]\and\operatorname{build-param-%
list}[L,D,V,\_]
  </annotation>
 </semantics>
</math>

</p>

<p><strong>And</strong> - For use in "let".</p>

<p>

<math display="block" id="Lambda_lifting:167">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>build</mi>
     <mo>-</mo>
     <mi>param</mi>
     <mo>-</mo>
     <mi>lists</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mi>E</mi>
      <mi mathvariant="italic">and</mi>
      <mi>F</mi>
     </mrow>
     <mo>,</mo>
     <mi>D</mi>
     <mo>,</mo>
     <mi>V</mi>
     <mo>,</mo>
     <mi mathvariant="normal">_</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>≡</mo>
   <mrow>
    <mrow>
     <mrow>
      <mi>build</mi>
      <mo>-</mo>
      <mi>param</mi>
      <mo>-</mo>
      <mi>lists</mi>
     </mrow>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>E</mi>
      <mo>,</mo>
      <mi>D</mi>
      <mo>,</mo>
      <mi>V</mi>
      <mo>,</mo>
      <mi mathvariant="normal">_</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mi mathvariant="italic">and</mi>
    <mrow>
     <mrow>
      <mi>build</mi>
      <mo>-</mo>
      <mi>param</mi>
      <mo>-</mo>
      <mi>lists</mi>
     </mrow>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>F</mi>
      <mo>,</mo>
      <mi>D</mi>
      <mo>,</mo>
      <mi>V</mi>
      <mo>,</mo>
      <mi mathvariant="normal">_</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <apply>
      <minus></minus>
      <ci>build</ci>
      <ci>param</ci>
      <ci>lists</ci>
     </apply>
     <apply>
      <times></times>
      <ci>E</ci>
      <ci>italic- and</ci>
      <ci>F</ci>
     </apply>
     <ci>D</ci>
     <ci>V</ci>
     <ci>normal-_</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <apply>
       <minus></minus>
       <ci>build</ci>
       <ci>param</ci>
       <ci>lists</ci>
      </apply>
      <ci>E</ci>
      <ci>D</ci>
      <ci>V</ci>
      <ci>normal-_</ci>
     </apply>
     <ci>italic- and</ci>
     <apply>
      <apply>
       <minus></minus>
       <ci>build</ci>
       <ci>param</ci>
       <ci>lists</ci>
      </apply>
      <ci>F</ci>
      <ci>D</ci>
      <ci>V</ci>
      <ci>normal-_</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{build-param-lists}[E\and F,D,V,\_]\equiv\operatorname{build-%
param-lists}[E,D,V,\_]\and\operatorname{build-param-lists}[F,D,V,\_]
  </annotation>
 </semantics>
</math>

</p>
<h5 id="examples-1">Examples</h5>

<p>For example building the parameter lists for,</p>

<p>

<math display="block" id="Lambda_lifting:168">
 <semantics>
  <mrow>
   <mi>λ</mi>
   <mi>m</mi>
   <mo>,</mo>
   <mi>p</mi>
   <mo>,</mo>
   <mi>q</mi>
   <mo>.</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>g</mi>
    <mo>.</mo>
    <mi>λ</mi>
    <mi>n</mi>
    <mo>.</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mpadded width="+5pt">
      <mi>n</mi>
     </mpadded>
     <mrow>
      <mo stretchy="false">(</mo>
      <mpadded width="+5pt">
       <mi>g</mi>
      </mpadded>
      <mpadded width="+5pt">
       <mi>m</mi>
      </mpadded>
      <mpadded width="+5pt">
       <mi>p</mi>
      </mpadded>
      <mi>n</mi>
      <mo rspace="7.5pt" stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mpadded width="+5pt">
       <mi>g</mi>
      </mpadded>
      <mpadded width="+5pt">
       <mi>q</mi>
      </mpadded>
      <mpadded width="+5pt">
       <mi>p</mi>
      </mpadded>
      <mi>n</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo rspace="7.5pt" stretchy="false">)</mo>
   </mrow>
   <mi>λ</mi>
   <mi>x</mi>
   <mo>.</mo>
   <mi>λ</mi>
   <mi>o</mi>
   <mo>.</mo>
   <mi>λ</mi>
   <mi>y</mi>
   <mo>.</mo>
   <mpadded width="+5pt">
    <mi>o</mi>
   </mpadded>
   <mpadded width="+5pt">
    <mi>x</mi>
   </mpadded>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">m</csymbol>
    <ci>normal-,</ci>
    <csymbol cd="unknown">p</csymbol>
    <ci>normal-,</ci>
    <csymbol cd="unknown">q</csymbol>
    <ci>normal-.</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">g</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">n</csymbol>
     <ci>normal-.</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">n</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">g</csymbol>
       <csymbol cd="unknown">m</csymbol>
       <csymbol cd="unknown">p</csymbol>
       <csymbol cd="unknown">n</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">g</csymbol>
       <csymbol cd="unknown">q</csymbol>
       <csymbol cd="unknown">p</csymbol>
       <csymbol cd="unknown">n</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <ci>normal-.</ci>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">o</csymbol>
    <ci>normal-.</ci>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">y</csymbol>
    <ci>normal-.</ci>
    <csymbol cd="unknown">o</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <csymbol cd="unknown">y</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda m,p,q.(\lambda g.\lambda n.(n\ (g\ m\ p\ n)\ (g\ q\ p\ n)))\ \lambda x%
.\lambda o.\lambda y.o\ x\ y
  </annotation>
 </semantics>
</math>

 gives,</p>

<p>

<math display="block" id="Lambda_lifting:169">
 <semantics>
  <mrow>
   <mrow>
    <mi>D</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>g</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mo>false</mo>
     <mo>,</mo>
     <mi mathvariant="normal">_</mi>
     <mo stretchy="false">]</mo>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>o</mi>
     <mo>,</mo>
     <mo>true</mo>
     <mo>,</mo>
     <mi>p</mi>
     <mo stretchy="false">]</mo>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>y</mi>
     <mo>,</mo>
     <mo>true</mo>
     <mo>,</mo>
     <mi>n</mi>
     <mo stretchy="false">]</mo>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>D</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>g</ci>
     </apply>
    </apply>
    <list>
     <list>
      <ci>x</ci>
      <ci>false</ci>
      <ci>normal-_</ci>
     </list>
     <list>
      <ci>o</ci>
      <ci>true</ci>
      <ci>p</ci>
     </list>
     <list>
      <ci>y</ci>
      <ci>true</ci>
      <ci>n</ci>
     </list>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D[g]=[[x,\operatorname{false},\_],[o,\operatorname{true},p],[y,\operatorname{%
true},n]]
  </annotation>
 </semantics>
</math>

 and the parameter o is dropped to give,</p>

<p>

<math display="block" id="Lambda_lifting:170">
 <semantics>
  <mrow>
   <mi>λ</mi>
   <mi>m</mi>
   <mo>,</mo>
   <mi>p</mi>
   <mo>,</mo>
   <mi>q</mi>
   <mo>.</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>g</mi>
    <mo>.</mo>
    <mi>λ</mi>
    <mi>n</mi>
    <mo>.</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mpadded width="+5pt">
      <mi>n</mi>
     </mpadded>
     <mrow>
      <mo stretchy="false">(</mo>
      <mpadded width="+5pt">
       <mi>g</mi>
      </mpadded>
      <mpadded width="+5pt">
       <mi>m</mi>
      </mpadded>
      <mi>n</mi>
      <mo rspace="7.5pt" stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mpadded width="+5pt">
       <mi>g</mi>
      </mpadded>
      <mpadded width="+5pt">
       <mi>q</mi>
      </mpadded>
      <mi>n</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo rspace="7.5pt" stretchy="false">)</mo>
   </mrow>
   <mi>λ</mi>
   <mi>x</mi>
   <mo>.</mo>
   <mi>λ</mi>
   <mi>y</mi>
   <mo>.</mo>
   <mpadded width="+5pt">
    <mi>p</mi>
   </mpadded>
   <mpadded width="+5pt">
    <mi>x</mi>
   </mpadded>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">m</csymbol>
    <ci>normal-,</ci>
    <csymbol cd="unknown">p</csymbol>
    <ci>normal-,</ci>
    <csymbol cd="unknown">q</csymbol>
    <ci>normal-.</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">g</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">n</csymbol>
     <ci>normal-.</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">n</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">g</csymbol>
       <csymbol cd="unknown">m</csymbol>
       <csymbol cd="unknown">n</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">g</csymbol>
       <csymbol cd="unknown">q</csymbol>
       <csymbol cd="unknown">n</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <ci>normal-.</ci>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">y</csymbol>
    <ci>normal-.</ci>
    <csymbol cd="unknown">p</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <csymbol cd="unknown">y</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda m,p,q.(\lambda g.\lambda n.(n\ (g\ m\ n)\ (g\ q\ n)))\ \lambda x.%
\lambda y.p\ x\ y
  </annotation>
 </semantics>
</math>

</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>Build parameter list for 

<math display="inline" id="Lambda_lifting:171">
 <semantics>
  <mrow>
   <mi>λ</mi>
   <mi>m</mi>
   <mo>,</mo>
   <mi>p</mi>
   <mo>,</mo>
   <mi>q</mi>
   <mo>.</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>g</mi>
    <mo>.</mo>
    <mi>λ</mi>
    <mi>n</mi>
    <mo>.</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mpadded width="+5pt">
      <mi>n</mi>
     </mpadded>
     <mrow>
      <mo stretchy="false">(</mo>
      <mpadded width="+5pt">
       <mi>g</mi>
      </mpadded>
      <mpadded width="+5pt">
       <mi>m</mi>
      </mpadded>
      <mpadded width="+5pt">
       <mi>p</mi>
      </mpadded>
      <mi>n</mi>
      <mo rspace="7.5pt" stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mpadded width="+5pt">
       <mi>g</mi>
      </mpadded>
      <mpadded width="+5pt">
       <mi>q</mi>
      </mpadded>
      <mpadded width="+5pt">
       <mi>p</mi>
      </mpadded>
      <mi>n</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo rspace="7.5pt" stretchy="false">)</mo>
   </mrow>
   <mi>λ</mi>
   <mi>x</mi>
   <mo>.</mo>
   <mi>λ</mi>
   <mi>o</mi>
   <mo>.</mo>
   <mi>λ</mi>
   <mi>y</mi>
   <mo>.</mo>
   <mpadded width="+5pt">
    <mi>o</mi>
   </mpadded>
   <mpadded width="+5pt">
    <mi>x</mi>
   </mpadded>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">m</csymbol>
    <ci>normal-,</ci>
    <csymbol cd="unknown">p</csymbol>
    <ci>normal-,</ci>
    <csymbol cd="unknown">q</csymbol>
    <ci>normal-.</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">g</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">n</csymbol>
     <ci>normal-.</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">n</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">g</csymbol>
       <csymbol cd="unknown">m</csymbol>
       <csymbol cd="unknown">p</csymbol>
       <csymbol cd="unknown">n</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">g</csymbol>
       <csymbol cd="unknown">q</csymbol>
       <csymbol cd="unknown">p</csymbol>
       <csymbol cd="unknown">n</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <ci>normal-.</ci>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">o</csymbol>
    <ci>normal-.</ci>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">y</csymbol>
    <ci>normal-.</ci>
    <csymbol cd="unknown">o</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <csymbol cd="unknown">y</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda m,p,q.(\lambda g.\lambda n.(n\ (g\ m\ p\ n)\ (g\ q\ p\ n)))\ \lambda x%
.\lambda o.\lambda y.o\ x\ y
  </annotation>
 </semantics>
</math>

</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>Build parameter list example</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>

<math display="inline" id="Lambda_lifting:172">
 <semantics>
  <mrow>
   <mrow>
    <mi>build</mi>
    <mo>-</mo>
    <mi>param</mi>
    <mo>-</mo>
    <mi>list</mi>
   </mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>λ</mi>
    <mi>m</mi>
    <mo>,</mo>
    <mi>p</mi>
    <mo>,</mo>
    <mi>q</mi>
    <mo>.</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mi>g</mi>
     <mo>.</mo>
     <mi>λ</mi>
     <mi>n</mi>
     <mo>.</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mpadded width="+5pt">
       <mi>n</mi>
      </mpadded>
      <mrow>
       <mo stretchy="false">(</mo>
       <mpadded width="+5pt">
        <mi>g</mi>
       </mpadded>
       <mpadded width="+5pt">
        <mi>m</mi>
       </mpadded>
       <mpadded width="+5pt">
        <mi>p</mi>
       </mpadded>
       <mi>n</mi>
       <mo rspace="7.5pt" stretchy="false">)</mo>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mpadded width="+5pt">
        <mi>g</mi>
       </mpadded>
       <mpadded width="+5pt">
        <mi>q</mi>
       </mpadded>
       <mpadded width="+5pt">
        <mi>p</mi>
       </mpadded>
       <mi>n</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo rspace="7.5pt" stretchy="false">)</mo>
    </mrow>
    <mi>λ</mi>
    <mi>x</mi>
    <mo>.</mo>
    <mi>λ</mi>
    <mi>o</mi>
    <mo>.</mo>
    <mi>λ</mi>
    <mi>y</mi>
    <mo>.</mo>
    <mpadded width="+5pt">
     <mi>o</mi>
    </mpadded>
    <mpadded width="+5pt">
     <mi>x</mi>
    </mpadded>
    <mi>y</mi>
    <mo>,</mo>
    <mi>D</mi>
    <mo>,</mo>
    <mi>V</mi>
    <mo>,</mo>
    <mi mathvariant="normal">_</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <minus></minus>
     <ci>build</ci>
     <ci>param</ci>
     <ci>list</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">m</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">p</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">q</csymbol>
     <ci>normal-.</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">g</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">n</csymbol>
      <ci>normal-.</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">n</csymbol>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <csymbol cd="unknown">g</csymbol>
        <csymbol cd="unknown">m</csymbol>
        <csymbol cd="unknown">p</csymbol>
        <csymbol cd="unknown">n</csymbol>
        <ci>normal-)</ci>
       </cerror>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <csymbol cd="unknown">g</csymbol>
        <csymbol cd="unknown">q</csymbol>
        <csymbol cd="unknown">p</csymbol>
        <csymbol cd="unknown">n</csymbol>
        <ci>normal-)</ci>
       </cerror>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">o</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">o</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">D</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">V</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">_</csymbol>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{build-param-list}[\lambda m,p,q.(\lambda g.\lambda n.(n\ (g\ m\ %
p\ n)\ (g\ q\ p\ n)))\ \lambda x.\lambda o.\lambda y.o\ x\ y,D,V,\_]
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Rule</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>Abstraction</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Abstraction</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>

<math display="inline" id="Lambda_lifting:173">
 <semantics>
  <mrow>
   <mrow>
    <mi>build</mi>
    <mo>-</mo>
    <mi>list</mi>
   </mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>λ</mi>
    <mi>x</mi>
    <mo>.</mo>
    <mi>λ</mi>
    <mi>o</mi>
    <mo>.</mo>
    <mi>λ</mi>
    <mi>y</mi>
    <mo>.</mo>
    <mpadded width="+5pt">
     <mi>o</mi>
    </mpadded>
    <mpadded width="+5pt">
     <mi>x</mi>
    </mpadded>
    <mi>y</mi>
    <mo>,</mo>
    <mi>D</mi>
    <mo>,</mo>
    <mi>V</mi>
    <mo>,</mo>
    <mi>D</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>g</mi>
     <mo stretchy="false">]</mo>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <minus></minus>
     <ci>build</ci>
     <ci>list</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">o</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">o</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">D</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">V</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">D</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-[</ci>
      <csymbol cd="unknown">g</csymbol>
      <ci>normal-]</ci>
     </cerror>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{build-list}[\lambda x.\lambda o.\lambda y.o\ x\ y,D,V,D[g]]
  </annotation>
 </semantics>
</math>


</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Rule</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>Add param</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Add param</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>Add param</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>End list</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>

<math display="inline" id="Lambda_lifting:174">
 <semantics>
  <mrow>
   <mrow>
    <mi>build</mi>
    <mo>-</mo>
    <mi>param</mi>
    <mo>-</mo>
    <mi>lists</mi>
   </mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mrow>
     <mpadded width="+5pt">
      <mi>n</mi>
     </mpadded>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mpadded width="+5pt">
        <mi>g</mi>
       </mpadded>
       <mpadded width="+5pt">
        <mi>m</mi>
       </mpadded>
       <mpadded width="+5pt">
        <mi>p</mi>
       </mpadded>
       <mi>n</mi>
      </mrow>
      <mo rspace="7.5pt" stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mpadded width="+5pt">
        <mi>g</mi>
       </mpadded>
       <mpadded width="+5pt">
        <mi>q</mi>
       </mpadded>
       <mpadded width="+5pt">
        <mi>p</mi>
       </mpadded>
       <mi>n</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>,</mo>
    <mi>D</mi>
    <mo>,</mo>
    <mi>V</mi>
    <mo>,</mo>
    <mi>R</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <minus></minus>
     <ci>build</ci>
     <ci>param</ci>
     <ci>lists</ci>
    </apply>
    <apply>
     <times></times>
     <ci>n</ci>
     <apply>
      <times></times>
      <ci>g</ci>
      <ci>m</ci>
      <ci>p</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <times></times>
      <ci>g</ci>
      <ci>q</ci>
      <ci>p</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <ci>D</ci>
    <ci>V</ci>
    <ci>R</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{build-param-lists}[n\ (g\ m\ p\ n)\ (g\ q\ p\ n),D,V,R]
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Rule</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>Application</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Application</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>Variable</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Variable</p></td>
</tr>
</tbody>
</table>

<p>Gives,</p>

<p>

<math display="block" id="Lambda_lifting:175">
 <semantics>
  <mrow>
   <mi>D</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>n</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi mathvariant="normal">_</mi>
    <mo>,</mo>
    <mi mathvariant="normal">_</mi>
    <mo>,</mo>
    <mpadded width="+5pt">
     <mi>g</mi>
    </mpadded>
    <mpadded width="+5pt">
     <mi>m</mi>
    </mpadded>
    <mpadded width="+5pt">
     <mi>p</mi>
    </mpadded>
    <mi>n</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>:</mo>
   <mo>:</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi mathvariant="normal">_</mi>
    <mo>,</mo>
    <mi mathvariant="normal">_</mi>
    <mo>,</mo>
    <mpadded width="+5pt">
     <mi>g</mi>
    </mpadded>
    <mpadded width="+5pt">
     <mi>q</mi>
    </mpadded>
    <mpadded width="+5pt">
     <mi>p</mi>
    </mpadded>
    <mi>n</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>:</mo>
   <mo>:</mo>
   <mi>R</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">D</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">n</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">_</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">_</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">g</csymbol>
     <csymbol cd="unknown">m</csymbol>
     <csymbol cd="unknown">p</csymbol>
     <csymbol cd="unknown">n</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <ci>normal-:</ci>
    <ci>normal-:</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">_</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">_</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">g</csymbol>
     <csymbol cd="unknown">q</csymbol>
     <csymbol cd="unknown">p</csymbol>
     <csymbol cd="unknown">n</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <ci>normal-:</ci>
    <ci>normal-:</ci>
    <csymbol cd="unknown">R</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D[n]=[\_,\_,g\ m\ p\ n]::[\_,\_,g\ q\ p\ n]::R
  </annotation>
 </semantics>
</math>

</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>

<math display="inline" id="Lambda_lifting:176">
 <semantics>
  <mrow>
   <mrow>
    <mi>build</mi>
    <mo>-</mo>
    <mi>param</mi>
    <mo>-</mo>
    <mi>lists</mi>
   </mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mrow>
     <mpadded width="+5pt">
      <mi>g</mi>
     </mpadded>
     <mpadded width="+5pt">
      <mi>m</mi>
     </mpadded>
     <mpadded width="+5pt">
      <mi>p</mi>
     </mpadded>
     <mi>n</mi>
    </mrow>
    <mo>,</mo>
    <mi>D</mi>
    <mo>,</mo>
    <mi>V</mi>
    <mo>,</mo>
    <msub>
     <mi>K</mi>
     <mn>2</mn>
    </msub>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <minus></minus>
     <ci>build</ci>
     <ci>param</ci>
     <ci>lists</ci>
    </apply>
    <apply>
     <times></times>
     <ci>g</ci>
     <ci>m</ci>
     <ci>p</ci>
     <ci>n</ci>
    </apply>
    <ci>D</ci>
    <ci>V</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>K</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{build-param-lists}[g\ m\ p\ n,D,V,K_{2}]
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Rule</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>application</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>application, Variable</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>application, Variable</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>Variable</p></td>
</tr>
</tbody>
</table>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>

<math display="inline" id="Lambda_lifting:177">
 <semantics>
  <mrow>
   <mrow>
    <mi>build</mi>
    <mo>-</mo>
    <mi>param</mi>
    <mo>-</mo>
    <mi>lists</mi>
   </mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mrow>
     <mpadded width="+5pt">
      <mi>g</mi>
     </mpadded>
     <mpadded width="+5pt">
      <mi>q</mi>
     </mpadded>
     <mpadded width="+5pt">
      <mi>p</mi>
     </mpadded>
     <mi>n</mi>
    </mrow>
    <mo>,</mo>
    <mi>D</mi>
    <mo>,</mo>
    <mi>V</mi>
    <mo>,</mo>
    <msub>
     <mi>K</mi>
     <mn>1</mn>
    </msub>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <minus></minus>
     <ci>build</ci>
     <ci>param</ci>
     <ci>lists</ci>
    </apply>
    <apply>
     <times></times>
     <ci>g</ci>
     <ci>q</ci>
     <ci>p</ci>
     <ci>n</ci>
    </apply>
    <ci>D</ci>
    <ci>V</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>K</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{build-param-lists}[g\ q\ p\ n,D,V,K_{1}]
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Rule</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>application</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>application, Variable</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>application, Variable</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>Variable</p></td>
</tr>
</tbody>
</table>

<p>As there are no definitions for, 

<math display="inline" id="Lambda_lifting:178">
 <semantics>
  <mrow>
   <mrow>
    <mi>V</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>n</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>V</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>p</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>V</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>q</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>V</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>m</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <times></times>
     <ci>V</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>V</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>p</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>V</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>q</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>V</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>m</ci>
     </apply>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V[n],V[p],V[q],V[m]
  </annotation>
 </semantics>
</math>


, then equate can be simplified to,</p>

<p>

<math display="block" id="Lambda_lifting:179">
 <semantics>
  <mrow>
   <mo>equate</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>A</mi>
    <mo>,</mo>
    <mi>N</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>≡</mo>
   <mi>A</mi>
   <mo>=</mo>
   <mi>N</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>def</mo>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>V</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>N</mi>
      <mo stretchy="false">]</mo>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
    <mi mathvariant="italic">and</mi>
    <mi>A</mi>
    <mo>=</mo>
    <mi>V</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>N</mi>
     <mo stretchy="false">]</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>≡</mo>
   <mi>A</mi>
   <mo>=</mo>
   <mi>N</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>equate</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">A</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">N</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <equivalent></equivalent>
    <csymbol cd="unknown">A</csymbol>
    <eq></eq>
    <csymbol cd="unknown">N</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <ci>def</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-[</ci>
      <csymbol cd="unknown">V</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-[</ci>
       <csymbol cd="unknown">N</csymbol>
       <ci>normal-]</ci>
      </cerror>
      <ci>normal-]</ci>
     </cerror>
     <csymbol cd="unknown">and</csymbol>
     <csymbol cd="unknown">A</csymbol>
     <eq></eq>
     <csymbol cd="unknown">V</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-[</ci>
      <csymbol cd="unknown">N</csymbol>
      <ci>normal-]</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <equivalent></equivalent>
    <csymbol cd="unknown">A</csymbol>
    <eq></eq>
    <csymbol cd="unknown">N</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{equate}[A,N]\equiv A=N(\operatorname{def}[V[N]]\and A=V[N])%
\equiv A=N
  </annotation>
 </semantics>
</math>

</p>

<p>By removing expressions not needed, 

<math display="inline" id="Lambda_lifting:180">
 <semantics>
  <mrow>
   <mi>D</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>g</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>x</mi>
    <mo>,</mo>
    <msub>
     <mi>S</mi>
     <mn>5</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>A</mi>
     <mn>5</mn>
    </msub>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>:</mo>
   <mo>:</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>o</mi>
    <mo>,</mo>
    <msub>
     <mi>S</mi>
     <mn>4</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>A</mi>
     <mn>4</mn>
    </msub>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>:</mo>
   <mo>:</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>y</mi>
    <mo>,</mo>
    <msub>
     <mi>S</mi>
     <mn>3</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>A</mi>
     <mn>3</mn>
    </msub>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>:</mo>
   <mo>:</mo>
   <msub>
    <mi>K</mi>
    <mn>2</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">D</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">g</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>S</ci>
      <cn type="integer">5</cn>
     </apply>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <cn type="integer">5</cn>
     </apply>
     <ci>normal-]</ci>
    </cerror>
    <ci>normal-:</ci>
    <ci>normal-:</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">o</csymbol>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>S</ci>
      <cn type="integer">4</cn>
     </apply>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <cn type="integer">4</cn>
     </apply>
     <ci>normal-]</ci>
    </cerror>
    <ci>normal-:</ci>
    <ci>normal-:</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>S</ci>
      <cn type="integer">3</cn>
     </apply>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <cn type="integer">3</cn>
     </apply>
     <ci>normal-]</ci>
    </cerror>
    <ci>normal-:</ci>
    <ci>normal-:</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>K</ci>
     <cn type="integer">2</cn>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D[g]=[x,S_{5},A_{5}]::[o,S_{4},A_{4}]::[y,S_{3},A_{3}]::K_{2}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Lambda_lifting:181">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="italic">and</mi>
    <msub>
     <mi>S</mi>
     <mn>3</mn>
    </msub>
   </mrow>
   <mo>⟹</mo>
   <msub>
    <mi>A</mi>
    <mn>3</mn>
   </msub>
   <mo>=</mo>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <implies></implies>
     <apply>
      <times></times>
      <ci>italic- and</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>S</ci>
       <cn type="integer">3</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <cn type="integer">3</cn>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \and S_{3}\implies A_{3}=n
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Lambda_lifting:182">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="italic">and</mi>
    <msub>
     <mi>S</mi>
     <mn>4</mn>
    </msub>
   </mrow>
   <mo>⟹</mo>
   <msub>
    <mi>A</mi>
    <mn>4</mn>
   </msub>
   <mo>=</mo>
   <mi>p</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <implies></implies>
     <apply>
      <times></times>
      <ci>italic- and</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>S</ci>
       <cn type="integer">4</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <cn type="integer">4</cn>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <ci>p</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \and S_{4}\implies A_{4}=p
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Lambda_lifting:183">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="italic">and</mi>
    <msub>
     <mi>S</mi>
     <mn>5</mn>
    </msub>
   </mrow>
   <mo>⟹</mo>
   <msub>
    <mi>A</mi>
    <mn>5</mn>
   </msub>
   <mo>=</mo>
   <mi>m</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <implies></implies>
     <apply>
      <times></times>
      <ci>italic- and</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>S</ci>
       <cn type="integer">5</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <cn type="integer">5</cn>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <ci>m</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \and S_{5}\implies A_{5}=m
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Lambda_lifting:184">
 <semantics>
  <mrow>
   <mi>D</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>g</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>x</mi>
    <mo>,</mo>
    <msub>
     <mi>S</mi>
     <mn>8</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>A</mi>
     <mn>8</mn>
    </msub>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>:</mo>
   <mo>:</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>o</mi>
    <mo>,</mo>
    <msub>
     <mi>S</mi>
     <mn>6</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>A</mi>
     <mn>7</mn>
    </msub>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>:</mo>
   <mo>:</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>y</mi>
    <mo>,</mo>
    <msub>
     <mi>S</mi>
     <mn>6</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>A</mi>
     <mn>6</mn>
    </msub>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>:</mo>
   <mo>:</mo>
   <msub>
    <mi>K</mi>
    <mn>1</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">D</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">g</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>S</ci>
      <cn type="integer">8</cn>
     </apply>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <cn type="integer">8</cn>
     </apply>
     <ci>normal-]</ci>
    </cerror>
    <ci>normal-:</ci>
    <ci>normal-:</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">o</csymbol>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>S</ci>
      <cn type="integer">6</cn>
     </apply>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <cn type="integer">7</cn>
     </apply>
     <ci>normal-]</ci>
    </cerror>
    <ci>normal-:</ci>
    <ci>normal-:</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>S</ci>
      <cn type="integer">6</cn>
     </apply>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <cn type="integer">6</cn>
     </apply>
     <ci>normal-]</ci>
    </cerror>
    <ci>normal-:</ci>
    <ci>normal-:</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>K</ci>
     <cn type="integer">1</cn>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D[g]=[x,S_{8},A_{8}]::[o,S_{6},A_{7}]::[y,S_{6},A_{6}]::K_{1}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Lambda_lifting:185">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="italic">and</mi>
    <msub>
     <mi>S</mi>
     <mn>6</mn>
    </msub>
   </mrow>
   <mo>⟹</mo>
   <msub>
    <mi>A</mi>
    <mn>6</mn>
   </msub>
   <mo>=</mo>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <implies></implies>
     <apply>
      <times></times>
      <ci>italic- and</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>S</ci>
       <cn type="integer">6</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <cn type="integer">6</cn>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \and S_{6}\implies A_{6}=n
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Lambda_lifting:186">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="italic">and</mi>
    <msub>
     <mi>S</mi>
     <mn>7</mn>
    </msub>
   </mrow>
   <mo>⟹</mo>
   <msub>
    <mi>A</mi>
    <mn>7</mn>
   </msub>
   <mo>=</mo>
   <mi>p</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <implies></implies>
     <apply>
      <times></times>
      <ci>italic- and</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>S</ci>
       <cn type="integer">7</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <cn type="integer">7</cn>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <ci>p</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \and S_{7}\implies A_{7}=p
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Lambda_lifting:187">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="italic">and</mi>
    <msub>
     <mi>S</mi>
     <mn>8</mn>
    </msub>
   </mrow>
   <mo>⟹</mo>
   <msub>
    <mi>A</mi>
    <mn>8</mn>
   </msub>
   <mo>=</mo>
   <mi>q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <implies></implies>
     <apply>
      <times></times>
      <ci>italic- and</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>S</ci>
       <cn type="integer">8</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <cn type="integer">8</cn>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <ci>q</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \and S_{8}\implies A_{8}=q
  </annotation>
 </semantics>
</math>

</p>

<p>By comparing the two expressions for 

<math display="inline" id="Lambda_lifting:188">
 <semantics>
  <mrow>
   <mi>D</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>g</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>D</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>g</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D[g]
  </annotation>
 </semantics>
</math>


, get,</p>

<p>

<math display="block" id="Lambda_lifting:189">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>S</mi>
     <mn>5</mn>
    </msub>
    <mo>=</mo>
    <msub>
     <mi>S</mi>
     <mn>8</mn>
    </msub>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>A</mi>
      <mn>5</mn>
     </msub>
     <mo>=</mo>
     <msub>
      <mi>A</mi>
      <mn>8</mn>
     </msub>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mrow>
      <msub>
       <mi>S</mi>
       <mn>4</mn>
      </msub>
      <mo>=</mo>
      <msub>
       <mi>S</mi>
       <mn>7</mn>
      </msub>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mrow>
       <msub>
        <mi>A</mi>
        <mn>4</mn>
       </msub>
       <mo>=</mo>
       <msub>
        <mi>A</mi>
        <mn>7</mn>
       </msub>
      </mrow>
      <mo>,</mo>
      <mrow>
       <mrow>
        <msub>
         <mi>S</mi>
         <mn>3</mn>
        </msub>
        <mo>=</mo>
        <msub>
         <mi>S</mi>
         <mn>6</mn>
        </msub>
       </mrow>
       <mo>,</mo>
       <mrow>
        <msub>
         <mi>A</mi>
         <mn>3</mn>
        </msub>
        <mo>=</mo>
        <msub>
         <mi>A</mi>
         <mn>6</mn>
        </msub>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>S</ci>
      <cn type="integer">5</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>S</ci>
      <cn type="integer">8</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">formulae-sequence</csymbol>
     <apply>
      <eq></eq>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>A</ci>
       <cn type="integer">5</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>A</ci>
       <cn type="integer">8</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">formulae-sequence</csymbol>
      <apply>
       <eq></eq>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>S</ci>
        <cn type="integer">4</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>S</ci>
        <cn type="integer">7</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">formulae-sequence</csymbol>
       <apply>
        <eq></eq>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>A</ci>
         <cn type="integer">4</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>A</ci>
         <cn type="integer">7</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">formulae-sequence</csymbol>
        <apply>
         <eq></eq>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>S</ci>
          <cn type="integer">3</cn>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>S</ci>
          <cn type="integer">6</cn>
         </apply>
        </apply>
        <apply>
         <eq></eq>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>A</ci>
          <cn type="integer">3</cn>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>A</ci>
          <cn type="integer">6</cn>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{5}=S_{8},A_{5}=A_{8},S_{4}=S_{7},A_{4}=A_{7},S_{3}=S_{6},A_{3}=A_{6}
  </annotation>
 </semantics>
</math>

</p>

<p>If 

<math display="inline" id="Lambda_lifting:190">
 <semantics>
  <msub>
   <mi>S</mi>
   <mn>3</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>S</ci>
    <cn type="integer">3</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{3}
  </annotation>
 </semantics>
</math>

 is true;</p>

<p>

<math display="block" id="Lambda_lifting:191">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>=</mo>
   <msub>
    <mi>A</mi>
    <mn>3</mn>
   </msub>
   <mo>=</mo>
   <msub>
    <mi>A</mi>
    <mn>6</mn>
   </msub>
   <mo>=</mo>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>n</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <cn type="integer">3</cn>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <cn type="integer">6</cn>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n=A_{3}=A_{6}=n
  </annotation>
 </semantics>
</math>

 If 

<math display="inline" id="Lambda_lifting:192">
 <semantics>
  <msub>
   <mi>S</mi>
   <mn>3</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>S</ci>
    <cn type="integer">3</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{3}
  </annotation>
 </semantics>
</math>

 is false there is no implication. So 

<math display="inline" id="Lambda_lifting:193">
 <semantics>
  <mrow>
   <msub>
    <mi>S</mi>
    <mn>3</mn>
   </msub>
   <mo>=</mo>
   <mi mathvariant="normal">_</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>S</ci>
     <cn type="integer">3</cn>
    </apply>
    <ci>normal-_</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{3}=\_
  </annotation>
 </semantics>
</math>


 which means it may be true or false.</p>

<p>If 

<math display="inline" id="Lambda_lifting:194">
 <semantics>
  <msub>
   <mi>S</mi>
   <mn>4</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>S</ci>
    <cn type="integer">4</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{4}
  </annotation>
 </semantics>
</math>

 is true;</p>

<p>

<math display="block" id="Lambda_lifting:195">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mo>=</mo>
   <msub>
    <mi>A</mi>
    <mn>4</mn>
   </msub>
   <mo>=</mo>
   <msub>
    <mi>A</mi>
    <mn>7</mn>
   </msub>
   <mo>=</mo>
   <mi>p</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>p</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <cn type="integer">4</cn>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <cn type="integer">7</cn>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <ci>p</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p=A_{4}=A_{7}=p
  </annotation>
 </semantics>
</math>

</p>

<p>If 

<math display="inline" id="Lambda_lifting:196">
 <semantics>
  <msub>
   <mi>S</mi>
   <mn>5</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>S</ci>
    <cn type="integer">5</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{5}
  </annotation>
 </semantics>
</math>

 is true;</p>

<p>

<math display="block" id="Lambda_lifting:197">
 <semantics>
  <mrow>
   <mi>m</mi>
   <mo>=</mo>
   <msub>
    <mi>A</mi>
    <mn>5</mn>
   </msub>
   <mo>=</mo>
   <msub>
    <mi>A</mi>
    <mn>8</mn>
   </msub>
   <mo>=</mo>
   <mi>q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>m</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <cn type="integer">5</cn>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <cn type="integer">8</cn>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <ci>q</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m=A_{5}=A_{8}=q
  </annotation>
 </semantics>
</math>

 So 

<math display="inline" id="Lambda_lifting:198">
 <semantics>
  <msub>
   <mi>S</mi>
   <mn>5</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>S</ci>
    <cn type="integer">5</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{5}
  </annotation>
 </semantics>
</math>


 is false.</p>

<p>The result is, 

<math display="inline" id="Lambda_lifting:199">
 <semantics>
  <mrow>
   <mi>D</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>g</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mo>false</mo>
    <mo>,</mo>
    <mi mathvariant="normal">_</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>:</mo>
   <mo>:</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>o</mi>
    <mo>,</mo>
    <mi mathvariant="normal">_</mi>
    <mo>,</mo>
    <mi>p</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>:</mo>
   <mo>:</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>y</mi>
    <mo>,</mo>
    <mi mathvariant="normal">_</mi>
    <mo>,</mo>
    <mi>n</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>:</mo>
   <mo>:</mo>
   <mi mathvariant="normal">_</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">D</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">g</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-,</ci>
     <ci>false</ci>
     <ci>normal-,</ci>
     <csymbol cd="unknown">_</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <ci>normal-:</ci>
    <ci>normal-:</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">o</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">_</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">p</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <ci>normal-:</ci>
    <ci>normal-:</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">_</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">n</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <ci>normal-:</ci>
    <ci>normal-:</ci>
    <csymbol cd="unknown">_</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D[g]=[x,\operatorname{false},\_]::[o,\_,p]::[y,\_,n]::\_
  </annotation>
 </semantics>
</math>

</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>

<math display="inline" id="Lambda_lifting:200">
 <semantics>
  <mrow>
   <mrow>
    <mi>build</mi>
    <mo>-</mo>
    <mi>param</mi>
    <mo>-</mo>
    <mi>lists</mi>
   </mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mrow>
     <mpadded width="+5pt">
      <mi>o</mi>
     </mpadded>
     <mpadded width="+5pt">
      <mi>x</mi>
     </mpadded>
     <mi>y</mi>
    </mrow>
    <mo>,</mo>
    <mi>D</mi>
    <mo>,</mo>
    <mi>V</mi>
    <mo>,</mo>
    <mi>L</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <minus></minus>
     <ci>build</ci>
     <ci>param</ci>
     <ci>lists</ci>
    </apply>
    <apply>
     <times></times>
     <ci>o</ci>
     <ci>x</ci>
     <ci>y</ci>
    </apply>
    <ci>D</ci>
    <ci>V</ci>
    <ci>L</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{build-param-lists}[o\ x\ y,D,V,L]
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Rule</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>application</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>application</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>variable</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>

<p>By similar arguments as used above get,</p>

<p>

<math display="block" id="Lambda_lifting:201">
 <semantics>
  <mrow>
   <mi>D</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>o</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi mathvariant="normal">_</mi>
    <mo>,</mo>
    <mi mathvariant="normal">_</mi>
    <mo>,</mo>
    <mi>x</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>:</mo>
   <mo>:</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi mathvariant="normal">_</mi>
    <mo>,</mo>
    <mi mathvariant="normal">_</mi>
    <mo>,</mo>
    <mi>y</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>:</mo>
   <mo>:</mo>
   <mi mathvariant="normal">_</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">D</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">o</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">_</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">_</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <ci>normal-:</ci>
    <ci>normal-:</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">_</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">_</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <ci>normal-:</ci>
    <ci>normal-:</ci>
    <csymbol cd="unknown">_</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D[o]=[\_,\_,x]::[\_,\_,y]::\_
  </annotation>
 </semantics>
</math>

</p>

<p>and from previously,</p>

<p>

<math display="block" id="Lambda_lifting:202">
 <semantics>
  <mrow>
   <mrow>
    <mi>D</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>g</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mo>false</mo>
     <mo>,</mo>
     <mi mathvariant="normal">_</mi>
     <mo stretchy="false">]</mo>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>o</mi>
     <mo>,</mo>
     <mo>true</mo>
     <mo>,</mo>
     <mi>p</mi>
     <mo stretchy="false">]</mo>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>y</mi>
     <mo>,</mo>
     <mo>true</mo>
     <mo>,</mo>
     <mi>n</mi>
     <mo stretchy="false">]</mo>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>D</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>g</ci>
     </apply>
    </apply>
    <list>
     <list>
      <ci>x</ci>
      <ci>false</ci>
      <ci>normal-_</ci>
     </list>
     <list>
      <ci>o</ci>
      <ci>true</ci>
      <ci>p</ci>
     </list>
     <list>
      <ci>y</ci>
      <ci>true</ci>
      <ci>n</ci>
     </list>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D[g]=[[x,\operatorname{false},\_],[o,\operatorname{true},p],[y,\operatorname{%
true},n]]
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Lambda_lifting:203">
 <semantics>
  <mrow>
   <mrow>
    <mi>D</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>n</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi mathvariant="normal">_</mi>
     <mo>,</mo>
     <mi mathvariant="normal">_</mi>
     <mo>,</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mpadded width="+5pt">
        <mi>g</mi>
       </mpadded>
       <mpadded width="+5pt">
        <mi>m</mi>
       </mpadded>
       <mpadded width="+5pt">
        <mi>p</mi>
       </mpadded>
       <mi>n</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi mathvariant="normal">_</mi>
     <mo>,</mo>
     <mi mathvariant="normal">_</mi>
     <mo>,</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mpadded width="+5pt">
        <mi>g</mi>
       </mpadded>
       <mpadded width="+5pt">
        <mi>q</mi>
       </mpadded>
       <mpadded width="+5pt">
        <mi>p</mi>
       </mpadded>
       <mi>n</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>D</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>n</ci>
     </apply>
    </apply>
    <interval closure="closed">
     <list>
      <ci>normal-_</ci>
      <ci>normal-_</ci>
      <apply>
       <times></times>
       <ci>g</ci>
       <ci>m</ci>
       <ci>p</ci>
       <ci>n</ci>
      </apply>
     </list>
     <list>
      <ci>normal-_</ci>
      <ci>normal-_</ci>
      <apply>
       <times></times>
       <ci>g</ci>
       <ci>q</ci>
       <ci>p</ci>
       <ci>n</ci>
      </apply>
     </list>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D[n]=[[\_,\_,(g\ m\ p\ n)],[\_,\_,(g\ q\ p\ n)]]
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Lambda_lifting:204">
 <semantics>
  <mrow>
   <mrow>
    <mi>D</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>m</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi mathvariant="normal">_</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>D</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>m</ci>
     </apply>
    </apply>
    <ci>normal-_</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D[m]=\_
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Lambda_lifting:205">
 <semantics>
  <mrow>
   <mrow>
    <mi>D</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>p</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi mathvariant="normal">_</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>D</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>p</ci>
     </apply>
    </apply>
    <ci>normal-_</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D[p]=\_
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Lambda_lifting:206">
 <semantics>
  <mrow>
   <mrow>
    <mi>D</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>q</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi mathvariant="normal">_</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>D</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>q</ci>
     </apply>
    </apply>
    <ci>normal-_</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D[q]=\_
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
</tbody>
</table>

<p>Another example is,</p>

<p>

<math display="block" id="Lambda_lifting:207">
 <semantics>
  <mrow>
   <mi>λ</mi>
   <mi>f</mi>
   <mo>.</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mi>p</mi>
     <mo>.</mo>
     <mpadded width="+5pt">
      <mi>f</mi>
     </mpadded>
     <mrow>
      <mo stretchy="false">(</mo>
      <mpadded width="+5pt">
       <mi>p</mi>
      </mpadded>
      <mpadded width="+5pt">
       <mi>p</mi>
      </mpadded>
      <mi>f</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo rspace="7.5pt" stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mi>q</mi>
     <mo>.</mo>
     <mi>λ</mi>
     <mi>x</mi>
     <mo>.</mo>
     <mpadded width="+5pt">
      <mi>x</mi>
     </mpadded>
     <mrow>
      <mo stretchy="false">(</mo>
      <mpadded width="+5pt">
       <mi>q</mi>
      </mpadded>
      <mpadded width="+5pt">
       <mi>q</mi>
      </mpadded>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">f</csymbol>
    <ci>normal-.</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">p</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">f</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">p</csymbol>
       <csymbol cd="unknown">p</csymbol>
       <csymbol cd="unknown">f</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">q</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">x</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">q</csymbol>
       <csymbol cd="unknown">q</csymbol>
       <csymbol cd="unknown">x</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda f.((\lambda p.f\ (p\ p\ f))\ (\lambda q.\lambda x.x\ (q\ q\ x))
  </annotation>
 </semantics>
</math>

 Here x is equal to f. The parameter list mapping is,</p>

<p>

<math display="block" id="Lambda_lifting:208">
 <semantics>
  <mrow>
   <mrow>
    <mi>D</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>p</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>q</mi>
     <mo>,</mo>
     <mi mathvariant="normal">_</mi>
     <mo>,</mo>
     <mi>p</mi>
     <mo stretchy="false">]</mo>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi mathvariant="normal">_</mi>
     <mo>,</mo>
     <mi>f</mi>
     <mo stretchy="false">]</mo>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>D</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>p</ci>
     </apply>
    </apply>
    <interval closure="closed">
     <list>
      <ci>q</ci>
      <ci>normal-_</ci>
      <ci>p</ci>
     </list>
     <list>
      <ci>x</ci>
      <ci>normal-_</ci>
      <ci>f</ci>
     </list>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D[p]=[[q,\_,p],[x,\_,f]]
  </annotation>
 </semantics>
</math>

 and the parameter x is dropped to give,</p>

<p>

<math display="block" id="Lambda_lifting:209">
 <semantics>
  <mrow>
   <mi>λ</mi>
   <mi>f</mi>
   <mo>.</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mi>q</mi>
     <mo>.</mo>
     <mpadded width="+5pt">
      <mi>f</mi>
     </mpadded>
     <mrow>
      <mo stretchy="false">(</mo>
      <mpadded width="+5pt">
       <mi>q</mi>
      </mpadded>
      <mi>q</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo rspace="7.5pt" stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mi>q</mi>
     <mo>.</mo>
     <mpadded width="+5pt">
      <mi>f</mi>
     </mpadded>
     <mrow>
      <mo stretchy="false">(</mo>
      <mpadded width="+5pt">
       <mi>q</mi>
      </mpadded>
      <mi>q</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">f</csymbol>
    <ci>normal-.</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">q</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">f</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">q</csymbol>
       <csymbol cd="unknown">q</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">q</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">f</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">q</csymbol>
       <csymbol cd="unknown">q</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda f.((\lambda q.f\ (q\ q))\ (\lambda q.f\ (q\ q))
  </annotation>
 </semantics>
</math>

</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>Build parameter list for 

<math display="inline" id="Lambda_lifting:210">
 <semantics>
  <mrow>
   <mi>λ</mi>
   <mi>f</mi>
   <mo>.</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mi>p</mi>
     <mo>.</mo>
     <mpadded width="+5pt">
      <mi>f</mi>
     </mpadded>
     <mrow>
      <mo stretchy="false">(</mo>
      <mpadded width="+5pt">
       <mi>p</mi>
      </mpadded>
      <mpadded width="+5pt">
       <mi>p</mi>
      </mpadded>
      <mi>f</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo rspace="7.5pt" stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mi>q</mi>
     <mo>.</mo>
     <mi>λ</mi>
     <mi>x</mi>
     <mo>.</mo>
     <mpadded width="+5pt">
      <mi>x</mi>
     </mpadded>
     <mrow>
      <mo stretchy="false">(</mo>
      <mpadded width="+5pt">
       <mi>q</mi>
      </mpadded>
      <mpadded width="+5pt">
       <mi>q</mi>
      </mpadded>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">f</csymbol>
    <ci>normal-.</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">p</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">f</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">p</csymbol>
       <csymbol cd="unknown">p</csymbol>
       <csymbol cd="unknown">f</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">q</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">x</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">q</csymbol>
       <csymbol cd="unknown">q</csymbol>
       <csymbol cd="unknown">x</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda f.((\lambda p.f\ (p\ p\ f))\ (\lambda q.\lambda x.x\ (q\ q\ x))
  </annotation>
 </semantics>
</math>

</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>The logic in <em>equate</em> is used in this more difficult example.</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>

<math display="inline" id="Lambda_lifting:211">
 <semantics>
  <mrow>
   <mrow>
    <mi>build</mi>
    <mo>-</mo>
    <mi>param</mi>
    <mo>-</mo>
    <mi>list</mi>
   </mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>λ</mi>
    <mi>f</mi>
    <mo>.</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>λ</mi>
      <mi>p</mi>
      <mo>.</mo>
      <mpadded width="+5pt">
       <mi>f</mi>
      </mpadded>
      <mrow>
       <mo stretchy="false">(</mo>
       <mpadded width="+5pt">
        <mi>p</mi>
       </mpadded>
       <mpadded width="+5pt">
        <mi>p</mi>
       </mpadded>
       <mi>f</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo rspace="7.5pt" stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>λ</mi>
      <mi>q</mi>
      <mo>.</mo>
      <mi>λ</mi>
      <mi>x</mi>
      <mo>.</mo>
      <mpadded width="+5pt">
       <mi>x</mi>
      </mpadded>
      <mrow>
       <mo stretchy="false">(</mo>
       <mpadded width="+5pt">
        <mi>q</mi>
       </mpadded>
       <mpadded width="+5pt">
        <mi>q</mi>
       </mpadded>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>,</mo>
     <mi>D</mi>
     <mo>,</mo>
     <mi>V</mi>
     <mo>,</mo>
     <mi mathvariant="normal">_</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <minus></minus>
     <ci>build</ci>
     <ci>param</ci>
     <ci>list</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">f</csymbol>
     <ci>normal-.</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">λ</csymbol>
       <csymbol cd="unknown">p</csymbol>
       <ci>normal-.</ci>
       <csymbol cd="unknown">f</csymbol>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <csymbol cd="unknown">p</csymbol>
        <csymbol cd="unknown">p</csymbol>
        <csymbol cd="unknown">f</csymbol>
        <ci>normal-)</ci>
       </cerror>
       <ci>normal-)</ci>
      </cerror>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">λ</csymbol>
       <csymbol cd="unknown">q</csymbol>
       <ci>normal-.</ci>
       <csymbol cd="unknown">λ</csymbol>
       <csymbol cd="unknown">x</csymbol>
       <ci>normal-.</ci>
       <csymbol cd="unknown">x</csymbol>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <csymbol cd="unknown">q</csymbol>
        <csymbol cd="unknown">q</csymbol>
        <csymbol cd="unknown">x</csymbol>
        <ci>normal-)</ci>
       </cerror>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-,</ci>
      <csymbol cd="unknown">D</csymbol>
      <ci>normal-,</ci>
      <csymbol cd="unknown">V</csymbol>
      <ci>normal-,</ci>
      <csymbol cd="unknown">_</csymbol>
      <ci>normal-]</ci>
     </cerror>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{build-param-list}[\lambda f.((\lambda p.f\ (p\ p\ f))\ (\lambda q%
.\lambda x.x\ (q\ q\ x)),D,V,\_]
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Rule</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>Abstraction</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Abstraction</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>

<math display="inline" id="Lambda_lifting:212">
 <semantics>
  <mrow>
   <mrow>
    <mi>build</mi>
    <mo>-</mo>
    <mi>list</mi>
   </mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>λ</mi>
    <mi>q</mi>
    <mo>.</mo>
    <mi>λ</mi>
    <mi>x</mi>
    <mo>.</mo>
    <mpadded width="+5pt">
     <mi>x</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mpadded width="+5pt">
      <mi>q</mi>
     </mpadded>
     <mpadded width="+5pt">
      <mi>q</mi>
     </mpadded>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>,</mo>
    <mi>D</mi>
    <mo>,</mo>
    <mi>D</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>p</mi>
     <mo stretchy="false">]</mo>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <minus></minus>
     <ci>build</ci>
     <ci>list</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">q</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">x</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">q</csymbol>
      <csymbol cd="unknown">q</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-,</ci>
     <csymbol cd="unknown">D</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">D</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-[</ci>
      <csymbol cd="unknown">p</csymbol>
      <ci>normal-]</ci>
     </cerror>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{build-list}[\lambda q.\lambda x.x\ (q\ q\ x),D,D[p]]
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Rule</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>Add param</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Add param</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>End list</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>

<math display="inline" id="Lambda_lifting:213">
 <semantics>
  <mrow>
   <mrow>
    <mi>build</mi>
    <mo>-</mo>
    <mi>param</mi>
    <mo>-</mo>
    <mi>lists</mi>
   </mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>λ</mi>
    <mi>p</mi>
    <mo>.</mo>
    <mpadded width="+5pt">
     <mi>f</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mpadded width="+5pt">
      <mi>p</mi>
     </mpadded>
     <mpadded width="+5pt">
      <mi>p</mi>
     </mpadded>
     <mi>f</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>,</mo>
    <mi>D</mi>
    <mo>,</mo>
    <mi>V</mi>
    <mo>,</mo>
    <msub>
     <mi>T</mi>
     <mn>1</mn>
    </msub>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <minus></minus>
     <ci>build</ci>
     <ci>param</ci>
     <ci>lists</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">p</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">f</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">p</csymbol>
      <csymbol cd="unknown">p</csymbol>
      <csymbol cd="unknown">f</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-,</ci>
     <csymbol cd="unknown">D</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">V</csymbol>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>T</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{build-param-lists}[\lambda p.f\ (p\ p\ f),D,V,T_{1}]
  </annotation>
 </semantics>
</math>


</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Rule</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>Abstraction</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Application</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>Name</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Name</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>Name</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Application</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>Name</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>

<math display="inline" id="Lambda_lifting:214">
 <semantics>
  <mrow>
   <mrow>
    <mi>build</mi>
    <mo>-</mo>
    <mi>param</mi>
    <mo>-</mo>
    <mi>lists</mi>
   </mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mpadded width="+5pt">
     <mi>x</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mpadded width="+5pt">
      <mi>q</mi>
     </mpadded>
     <mpadded width="+5pt">
      <mi>q</mi>
     </mpadded>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>,</mo>
   <mi>D</mi>
   <mo>,</mo>
   <mi>V</mi>
   <mo>,</mo>
   <mi mathvariant="normal">_</mi>
   <mo stretchy="false">]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <minus></minus>
     <ci>build</ci>
     <ci>param</ci>
     <ci>lists</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">x</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">q</csymbol>
      <csymbol cd="unknown">q</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-,</ci>
    <csymbol cd="unknown">D</csymbol>
    <ci>normal-,</ci>
    <csymbol cd="unknown">V</csymbol>
    <ci>normal-,</ci>
    <csymbol cd="unknown">_</csymbol>
    <ci>normal-]</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{build-param-lists}[x\ (q\ q\ x)),D,V,\_]
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Rule</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>Abstraction</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Application</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>Name</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Name</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>Name</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Application</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>Name</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Name</p></td>
</tr>
</tbody>
</table>

<p>After collecting the results together,</p>

<p>

<math display="block" id="Lambda_lifting:215">
 <semantics>
  <mrow>
   <mi>D</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>p</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>q</mi>
    <mo>,</mo>
    <mi mathvariant="normal">_</mi>
    <mo>,</mo>
    <mi mathvariant="normal">_</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>:</mo>
   <mo>:</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi mathvariant="normal">_</mi>
    <mo>,</mo>
    <mi mathvariant="normal">_</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>:</mo>
   <mo>:</mo>
   <msub>
    <mi>L</mi>
    <mn>3</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">D</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">p</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">q</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">_</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">_</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <ci>normal-:</ci>
    <ci>normal-:</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">_</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">_</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <ci>normal-:</ci>
    <ci>normal-:</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>L</ci>
     <cn type="integer">3</cn>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D[p]=[q,\_,\_]::[x,\_,\_]::L_{3}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Lambda_lifting:216">
 <semantics>
  <mrow>
   <mi>D</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>p</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <msub>
     <mi>F</mi>
     <mn>4</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>S</mi>
     <mn>4</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>A</mi>
     <mn>4</mn>
    </msub>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>:</mo>
   <mo>:</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <msub>
     <mi>F</mi>
     <mn>3</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>S</mi>
     <mn>3</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>A</mi>
     <mn>3</mn>
    </msub>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>:</mo>
   <mo>:</mo>
   <msub>
    <mi>K</mi>
    <mn>2</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">D</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">p</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>F</ci>
      <cn type="integer">4</cn>
     </apply>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>S</ci>
      <cn type="integer">4</cn>
     </apply>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <cn type="integer">4</cn>
     </apply>
     <ci>normal-]</ci>
    </cerror>
    <ci>normal-:</ci>
    <ci>normal-:</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>F</ci>
      <cn type="integer">3</cn>
     </apply>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>S</ci>
      <cn type="integer">3</cn>
     </apply>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <cn type="integer">3</cn>
     </apply>
     <ci>normal-]</ci>
    </cerror>
    <ci>normal-:</ci>
    <ci>normal-:</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>K</ci>
     <cn type="integer">2</cn>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D[p]=[F_{4},S_{4},A_{4}]::[F_{3},S_{3},A_{3}]::K_{2}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Lambda_lifting:217">
 <semantics>
  <mrow>
   <mi mathvariant="italic">and</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>S</mi>
     <mn>3</mn>
    </msub>
    <mo>⟹</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mo>equate</mo>
     <mrow>
      <mo stretchy="false">[</mo>
      <msub>
       <mi>A</mi>
       <mn>3</mn>
      </msub>
      <mo>,</mo>
      <mi>f</mi>
      <mo stretchy="false">]</mo>
     </mrow>
     <mi mathvariant="italic">and</mi>
     <mi>V</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <msub>
       <mi>F</mi>
       <mn>3</mn>
      </msub>
      <mo stretchy="false">]</mo>
     </mrow>
     <mo>=</mo>
     <msub>
      <mi>A</mi>
      <mn>3</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi mathvariant="italic">and</mi>
   <mi>D</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <msub>
     <mi>F</mi>
     <mn>3</mn>
    </msub>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>=</mo>
   <mi>D</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>f</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">and</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>S</ci>
      <cn type="integer">3</cn>
     </apply>
     <implies></implies>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <ci>equate</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-[</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>A</ci>
        <cn type="integer">3</cn>
       </apply>
       <ci>normal-,</ci>
       <csymbol cd="unknown">f</csymbol>
       <ci>normal-]</ci>
      </cerror>
      <csymbol cd="unknown">and</csymbol>
      <csymbol cd="unknown">V</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-[</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>F</ci>
        <cn type="integer">3</cn>
       </apply>
       <ci>normal-]</ci>
      </cerror>
      <eq></eq>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>A</ci>
       <cn type="integer">3</cn>
      </apply>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">and</csymbol>
    <csymbol cd="unknown">D</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>F</ci>
      <cn type="integer">3</cn>
     </apply>
     <ci>normal-]</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">D</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">f</csymbol>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \and(S_{3}\implies(\operatorname{equate}[A_{3},f]\and V[F_{3}]=A_{3}))\and D[F%
_{3}]=D[f]
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Lambda_lifting:218">
 <semantics>
  <mrow>
   <mi mathvariant="italic">and</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>S</mi>
     <mn>4</mn>
    </msub>
    <mo>⟹</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mo>equate</mo>
     <mrow>
      <mo stretchy="false">[</mo>
      <msub>
       <mi>A</mi>
       <mn>4</mn>
      </msub>
      <mo>,</mo>
      <mi>p</mi>
      <mo stretchy="false">]</mo>
     </mrow>
     <mi mathvariant="italic">and</mi>
     <mi>V</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <msub>
       <mi>F</mi>
       <mn>4</mn>
      </msub>
      <mo stretchy="false">]</mo>
     </mrow>
     <mo>=</mo>
     <msub>
      <mi>A</mi>
      <mn>4</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi mathvariant="italic">and</mi>
   <mi>D</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <msub>
     <mi>F</mi>
     <mn>4</mn>
    </msub>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>=</mo>
   <mi>D</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>p</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">and</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>S</ci>
      <cn type="integer">4</cn>
     </apply>
     <implies></implies>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <ci>equate</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-[</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>A</ci>
        <cn type="integer">4</cn>
       </apply>
       <ci>normal-,</ci>
       <csymbol cd="unknown">p</csymbol>
       <ci>normal-]</ci>
      </cerror>
      <csymbol cd="unknown">and</csymbol>
      <csymbol cd="unknown">V</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-[</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>F</ci>
        <cn type="integer">4</cn>
       </apply>
       <ci>normal-]</ci>
      </cerror>
      <eq></eq>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>A</ci>
       <cn type="integer">4</cn>
      </apply>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">and</csymbol>
    <csymbol cd="unknown">D</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>F</ci>
      <cn type="integer">4</cn>
     </apply>
     <ci>normal-]</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">D</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">p</csymbol>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \and(S_{4}\implies(\operatorname{equate}[A_{4},p]\and V[F_{4}]=A_{4}))\and D[F%
_{4}]=D[p]
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Lambda_lifting:219">
 <semantics>
  <mrow>
   <mi>D</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>q</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <msub>
     <mi>F</mi>
     <mn>7</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>S</mi>
     <mn>7</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>A</mi>
     <mn>7</mn>
    </msub>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>:</mo>
   <mo>:</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <msub>
     <mi>F</mi>
     <mn>6</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>S</mi>
     <mn>6</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>A</mi>
     <mn>6</mn>
    </msub>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>:</mo>
   <mo>:</mo>
   <msub>
    <mi>K</mi>
    <mn>5</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">D</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">q</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>F</ci>
      <cn type="integer">7</cn>
     </apply>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>S</ci>
      <cn type="integer">7</cn>
     </apply>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <cn type="integer">7</cn>
     </apply>
     <ci>normal-]</ci>
    </cerror>
    <ci>normal-:</ci>
    <ci>normal-:</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>F</ci>
      <cn type="integer">6</cn>
     </apply>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>S</ci>
      <cn type="integer">6</cn>
     </apply>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <cn type="integer">6</cn>
     </apply>
     <ci>normal-]</ci>
    </cerror>
    <ci>normal-:</ci>
    <ci>normal-:</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>K</ci>
     <cn type="integer">5</cn>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D[q]=[F_{7},S_{7},A_{7}]::[F_{6},S_{6},A_{6}]::K_{5}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Lambda_lifting:220">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>S</mi>
     <mn>6</mn>
    </msub>
    <mo>⟹</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mo>equate</mo>
     <mrow>
      <mo stretchy="false">[</mo>
      <msub>
       <mi>A</mi>
       <mn>6</mn>
      </msub>
      <mo>,</mo>
      <mi>x</mi>
      <mo stretchy="false">]</mo>
     </mrow>
     <mi mathvariant="italic">and</mi>
     <mi>V</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <msub>
       <mi>F</mi>
       <mn>6</mn>
      </msub>
      <mo stretchy="false">]</mo>
     </mrow>
     <mo>=</mo>
     <msub>
      <mi>A</mi>
      <mn>6</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi mathvariant="italic">and</mi>
   <mi>D</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <msub>
     <mi>F</mi>
     <mn>6</mn>
    </msub>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>=</mo>
   <mi>D</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>x</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>S</ci>
      <cn type="integer">6</cn>
     </apply>
     <implies></implies>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <ci>equate</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-[</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>A</ci>
        <cn type="integer">6</cn>
       </apply>
       <ci>normal-,</ci>
       <csymbol cd="unknown">x</csymbol>
       <ci>normal-]</ci>
      </cerror>
      <csymbol cd="unknown">and</csymbol>
      <csymbol cd="unknown">V</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-[</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>F</ci>
        <cn type="integer">6</cn>
       </apply>
       <ci>normal-]</ci>
      </cerror>
      <eq></eq>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>A</ci>
       <cn type="integer">6</cn>
      </apply>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">and</csymbol>
    <csymbol cd="unknown">D</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>F</ci>
      <cn type="integer">6</cn>
     </apply>
     <ci>normal-]</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">D</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (S_{6}\implies(\operatorname{equate}[A_{6},x]\and V[F_{6}]=A_{6}))\and D[F_{6}%
]=D[x]
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Lambda_lifting:221">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>S</mi>
     <mn>7</mn>
    </msub>
    <mo>⟹</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mo>equate</mo>
     <mrow>
      <mo stretchy="false">[</mo>
      <msub>
       <mi>A</mi>
       <mn>7</mn>
      </msub>
      <mo>,</mo>
      <mi>q</mi>
      <mo stretchy="false">]</mo>
     </mrow>
     <mi mathvariant="italic">and</mi>
     <mi>V</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <msub>
       <mi>F</mi>
       <mn>7</mn>
      </msub>
      <mo stretchy="false">]</mo>
     </mrow>
     <mo>=</mo>
     <msub>
      <mi>A</mi>
      <mn>7</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi mathvariant="italic">and</mi>
   <mi>D</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <msub>
     <mi>F</mi>
     <mn>7</mn>
    </msub>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>=</mo>
   <mi>D</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>q</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>S</ci>
      <cn type="integer">7</cn>
     </apply>
     <implies></implies>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <ci>equate</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-[</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>A</ci>
        <cn type="integer">7</cn>
       </apply>
       <ci>normal-,</ci>
       <csymbol cd="unknown">q</csymbol>
       <ci>normal-]</ci>
      </cerror>
      <csymbol cd="unknown">and</csymbol>
      <csymbol cd="unknown">V</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-[</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>F</ci>
        <cn type="integer">7</cn>
       </apply>
       <ci>normal-]</ci>
      </cerror>
      <eq></eq>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>A</ci>
       <cn type="integer">7</cn>
      </apply>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">and</csymbol>
    <csymbol cd="unknown">D</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>F</ci>
      <cn type="integer">7</cn>
     </apply>
     <ci>normal-]</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">D</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">q</csymbol>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (S_{7}\implies(\operatorname{equate}[A_{7},q]\and V[F_{7}]=A_{7}))\and D[F_{7}%
]=D[q]
  </annotation>
 </semantics>
</math>

</p>

<p>From the two definitions for 

<math display="inline" id="Lambda_lifting:222">
 <semantics>
  <mrow>
   <mi>D</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>p</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>D</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>p</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D[p]
  </annotation>
 </semantics>
</math>

;</p>

<p>

<math display="block" id="Lambda_lifting:223">
 <semantics>
  <mrow>
   <msub>
    <mi>F</mi>
    <mn>4</mn>
   </msub>
   <mo>=</mo>
   <mi>q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>F</ci>
     <cn type="integer">4</cn>
    </apply>
    <ci>q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F_{4}=q
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Lambda_lifting:224">
 <semantics>
  <mrow>
   <msub>
    <mi>F</mi>
    <mn>3</mn>
   </msub>
   <mo>=</mo>
   <mi>x</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>F</ci>
     <cn type="integer">3</cn>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F_{3}=x
  </annotation>
 </semantics>
</math>

 so</p>

<p>

<math display="block" id="Lambda_lifting:225">
 <semantics>
  <mrow>
   <mi>D</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>p</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>q</mi>
    <mo>,</mo>
    <msub>
     <mi>S</mi>
     <mn>4</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>A</mi>
     <mn>4</mn>
    </msub>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>:</mo>
   <mo>:</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>x</mi>
    <mo>,</mo>
    <msub>
     <mi>S</mi>
     <mn>3</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>A</mi>
     <mn>3</mn>
    </msub>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>:</mo>
   <mo>:</mo>
   <msub>
    <mi>K</mi>
    <mn>2</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">D</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">p</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">q</csymbol>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>S</ci>
      <cn type="integer">4</cn>
     </apply>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <cn type="integer">4</cn>
     </apply>
     <ci>normal-]</ci>
    </cerror>
    <ci>normal-:</ci>
    <ci>normal-:</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>S</ci>
      <cn type="integer">3</cn>
     </apply>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <cn type="integer">3</cn>
     </apply>
     <ci>normal-]</ci>
    </cerror>
    <ci>normal-:</ci>
    <ci>normal-:</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>K</ci>
     <cn type="integer">2</cn>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D[p]=[q,S_{4},A_{4}]::[x,S_{3},A_{3}]::K_{2}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Lambda_lifting:226">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>S</mi>
     <mn>3</mn>
    </msub>
    <mo>⟹</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mo>equate</mo>
     <mrow>
      <mo stretchy="false">[</mo>
      <msub>
       <mi>A</mi>
       <mn>3</mn>
      </msub>
      <mo>,</mo>
      <mi>f</mi>
      <mo stretchy="false">]</mo>
     </mrow>
     <mi mathvariant="italic">and</mi>
     <mi>V</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>x</mi>
      <mo stretchy="false">]</mo>
     </mrow>
     <mo>=</mo>
     <msub>
      <mi>A</mi>
      <mn>3</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi mathvariant="italic">and</mi>
   <mi>D</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>x</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>=</mo>
   <mi>D</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>f</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>S</ci>
      <cn type="integer">3</cn>
     </apply>
     <implies></implies>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <ci>equate</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-[</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>A</ci>
        <cn type="integer">3</cn>
       </apply>
       <ci>normal-,</ci>
       <csymbol cd="unknown">f</csymbol>
       <ci>normal-]</ci>
      </cerror>
      <csymbol cd="unknown">and</csymbol>
      <csymbol cd="unknown">V</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-[</ci>
       <csymbol cd="unknown">x</csymbol>
       <ci>normal-]</ci>
      </cerror>
      <eq></eq>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>A</ci>
       <cn type="integer">3</cn>
      </apply>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">and</csymbol>
    <csymbol cd="unknown">D</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">D</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">f</csymbol>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (S_{3}\implies(\operatorname{equate}[A_{3},f]\and V[x]=A_{3}))\and D[x]=D[f]
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Lambda_lifting:227">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>S</mi>
     <mn>4</mn>
    </msub>
    <mo>⟹</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mo>equate</mo>
     <mrow>
      <mo stretchy="false">[</mo>
      <msub>
       <mi>A</mi>
       <mn>4</mn>
      </msub>
      <mo>,</mo>
      <mi>p</mi>
      <mo stretchy="false">]</mo>
     </mrow>
     <mi mathvariant="italic">and</mi>
     <mi>V</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>q</mi>
      <mo stretchy="false">]</mo>
     </mrow>
     <mo>=</mo>
     <msub>
      <mi>A</mi>
      <mn>4</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi mathvariant="italic">and</mi>
   <mi>D</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>q</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>=</mo>
   <mi>D</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>p</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>S</ci>
      <cn type="integer">4</cn>
     </apply>
     <implies></implies>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <ci>equate</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-[</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>A</ci>
        <cn type="integer">4</cn>
       </apply>
       <ci>normal-,</ci>
       <csymbol cd="unknown">p</csymbol>
       <ci>normal-]</ci>
      </cerror>
      <csymbol cd="unknown">and</csymbol>
      <csymbol cd="unknown">V</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-[</ci>
       <csymbol cd="unknown">q</csymbol>
       <ci>normal-]</ci>
      </cerror>
      <eq></eq>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>A</ci>
       <cn type="integer">4</cn>
      </apply>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">and</csymbol>
    <csymbol cd="unknown">D</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">q</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">D</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">p</csymbol>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (S_{4}\implies(\operatorname{equate}[A_{4},p]\and V[q]=A_{4}))\and D[q]=D[p]
  </annotation>
 </semantics>
</math>

</p>

<p>Using 

<math display="inline" id="Lambda_lifting:228">
 <semantics>
  <mrow>
   <mrow>
    <mi>D</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>q</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>D</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>p</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>D</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>q</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>D</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>p</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D[q]=D[p]
  </annotation>
 </semantics>
</math>


 and</p>

<p>

<math display="block" id="Lambda_lifting:229">
 <semantics>
  <mrow>
   <mi>D</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>p</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <msub>
     <mi>F</mi>
     <mn>7</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>S</mi>
     <mn>7</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>A</mi>
     <mn>7</mn>
    </msub>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>:</mo>
   <mo>:</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <msub>
     <mi>F</mi>
     <mn>6</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>S</mi>
     <mn>6</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>A</mi>
     <mn>6</mn>
    </msub>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>:</mo>
   <mo>:</mo>
   <msub>
    <mi>K</mi>
    <mn>5</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">D</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">p</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>F</ci>
      <cn type="integer">7</cn>
     </apply>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>S</ci>
      <cn type="integer">7</cn>
     </apply>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <cn type="integer">7</cn>
     </apply>
     <ci>normal-]</ci>
    </cerror>
    <ci>normal-:</ci>
    <ci>normal-:</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>F</ci>
      <cn type="integer">6</cn>
     </apply>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>S</ci>
      <cn type="integer">6</cn>
     </apply>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <cn type="integer">6</cn>
     </apply>
     <ci>normal-]</ci>
    </cerror>
    <ci>normal-:</ci>
    <ci>normal-:</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>K</ci>
     <cn type="integer">5</cn>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D[p]=[F_{7},S_{7},A_{7}]::[F_{6},S_{6},A_{6}]::K_{5}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Lambda_lifting:230">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>S</mi>
     <mn>6</mn>
    </msub>
    <mo>⟹</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mo>equate</mo>
     <mrow>
      <mo stretchy="false">[</mo>
      <msub>
       <mi>A</mi>
       <mn>6</mn>
      </msub>
      <mo>,</mo>
      <mi>x</mi>
      <mo stretchy="false">]</mo>
     </mrow>
     <mi mathvariant="italic">and</mi>
     <mi>V</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <msub>
       <mi>F</mi>
       <mn>6</mn>
      </msub>
      <mo stretchy="false">]</mo>
     </mrow>
     <mo>=</mo>
     <msub>
      <mi>A</mi>
      <mn>6</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi mathvariant="italic">and</mi>
   <mi>D</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <msub>
     <mi>F</mi>
     <mn>6</mn>
    </msub>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>=</mo>
   <mi>D</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>x</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>S</ci>
      <cn type="integer">6</cn>
     </apply>
     <implies></implies>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <ci>equate</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-[</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>A</ci>
        <cn type="integer">6</cn>
       </apply>
       <ci>normal-,</ci>
       <csymbol cd="unknown">x</csymbol>
       <ci>normal-]</ci>
      </cerror>
      <csymbol cd="unknown">and</csymbol>
      <csymbol cd="unknown">V</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-[</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>F</ci>
        <cn type="integer">6</cn>
       </apply>
       <ci>normal-]</ci>
      </cerror>
      <eq></eq>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>A</ci>
       <cn type="integer">6</cn>
      </apply>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">and</csymbol>
    <csymbol cd="unknown">D</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>F</ci>
      <cn type="integer">6</cn>
     </apply>
     <ci>normal-]</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">D</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (S_{6}\implies(\operatorname{equate}[A_{6},x]\and V[F_{6}]=A_{6}))\and D[F_{6}%
]=D[x]
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Lambda_lifting:231">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>S</mi>
     <mn>7</mn>
    </msub>
    <mo>⟹</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mo>equate</mo>
     <mrow>
      <mo stretchy="false">[</mo>
      <msub>
       <mi>A</mi>
       <mn>7</mn>
      </msub>
      <mo>,</mo>
      <mi>q</mi>
      <mo stretchy="false">]</mo>
     </mrow>
     <mi mathvariant="italic">and</mi>
     <mi>V</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <msub>
       <mi>F</mi>
       <mn>7</mn>
      </msub>
      <mo stretchy="false">]</mo>
     </mrow>
     <mo>=</mo>
     <msub>
      <mi>A</mi>
      <mn>7</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi mathvariant="italic">and</mi>
   <mi>D</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <msub>
     <mi>F</mi>
     <mn>7</mn>
    </msub>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>=</mo>
   <mi>D</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>q</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>S</ci>
      <cn type="integer">7</cn>
     </apply>
     <implies></implies>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <ci>equate</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-[</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>A</ci>
        <cn type="integer">7</cn>
       </apply>
       <ci>normal-,</ci>
       <csymbol cd="unknown">q</csymbol>
       <ci>normal-]</ci>
      </cerror>
      <csymbol cd="unknown">and</csymbol>
      <csymbol cd="unknown">V</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-[</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>F</ci>
        <cn type="integer">7</cn>
       </apply>
       <ci>normal-]</ci>
      </cerror>
      <eq></eq>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>A</ci>
       <cn type="integer">7</cn>
      </apply>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">and</csymbol>
    <csymbol cd="unknown">D</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>F</ci>
      <cn type="integer">7</cn>
     </apply>
     <ci>normal-]</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">D</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">q</csymbol>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (S_{7}\implies(\operatorname{equate}[A_{7},q]\and V[F_{7}]=A_{7}))\and D[F_{7}%
]=D[q]
  </annotation>
 </semantics>
</math>

</p>

<p>by comparing with the above,</p>

<p>

<math display="block" id="Lambda_lifting:232">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>F</mi>
     <mn>7</mn>
    </msub>
    <mo>=</mo>
    <mi>q</mi>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>F</mi>
      <mn>6</mn>
     </msub>
     <mo>=</mo>
     <mi>x</mi>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mrow>
      <msub>
       <mi>A</mi>
       <mn>3</mn>
      </msub>
      <mo>=</mo>
      <msub>
       <mi>A</mi>
       <mn>6</mn>
      </msub>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mrow>
       <msub>
        <mi>A</mi>
        <mn>4</mn>
       </msub>
       <mo>=</mo>
       <msub>
        <mi>A</mi>
        <mn>7</mn>
       </msub>
      </mrow>
      <mo>,</mo>
      <mrow>
       <mrow>
        <msub>
         <mi>S</mi>
         <mn>3</mn>
        </msub>
        <mo>=</mo>
        <msub>
         <mi>S</mi>
         <mn>6</mn>
        </msub>
       </mrow>
       <mo>,</mo>
       <mrow>
        <msub>
         <mi>S</mi>
         <mn>4</mn>
        </msub>
        <mo>=</mo>
        <msub>
         <mi>S</mi>
         <mn>7</mn>
        </msub>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>F</ci>
      <cn type="integer">7</cn>
     </apply>
     <ci>q</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">formulae-sequence</csymbol>
     <apply>
      <eq></eq>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>F</ci>
       <cn type="integer">6</cn>
      </apply>
      <ci>x</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">formulae-sequence</csymbol>
      <apply>
       <eq></eq>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>A</ci>
        <cn type="integer">3</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>A</ci>
        <cn type="integer">6</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">formulae-sequence</csymbol>
       <apply>
        <eq></eq>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>A</ci>
         <cn type="integer">4</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>A</ci>
         <cn type="integer">7</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">formulae-sequence</csymbol>
        <apply>
         <eq></eq>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>S</ci>
          <cn type="integer">3</cn>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>S</ci>
          <cn type="integer">6</cn>
         </apply>
        </apply>
        <apply>
         <eq></eq>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>S</ci>
          <cn type="integer">4</cn>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>S</ci>
          <cn type="integer">7</cn>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F_{7}=q,F_{6}=x,A_{3}=A_{6},A_{4}=A_{7},S_{3}=S_{6},S_{4}=S_{7}
  </annotation>
 </semantics>
</math>

 so,</p>

<p>

<math display="block" id="Lambda_lifting:233">
 <semantics>
  <mrow>
   <mrow>
    <mi>V</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>x</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msub>
    <mi>A</mi>
    <mn>3</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>V</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>x</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>A</ci>
     <cn type="integer">3</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V[x]=A_{3}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Lambda_lifting:234">
 <semantics>
  <mrow>
   <mrow>
    <mi>V</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>q</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msub>
    <mi>A</mi>
    <mn>4</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>V</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>q</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>A</ci>
     <cn type="integer">4</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V[q]=A_{4}
  </annotation>
 </semantics>
</math>

 in,</p>

<p>

<math display="block" id="Lambda_lifting:235">
 <semantics>
  <mrow>
   <msub>
    <mi>S</mi>
    <mn>3</mn>
   </msub>
   <mo>⟹</mo>
   <msub>
    <mi>A</mi>
    <mn>3</mn>
   </msub>
   <mo>=</mo>
   <mi>f</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <implies></implies>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>S</ci>
      <cn type="integer">3</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <cn type="integer">3</cn>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <ci>f</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{3}\implies A_{3}=f
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Lambda_lifting:236">
 <semantics>
  <mrow>
   <msub>
    <mi>S</mi>
    <mn>3</mn>
   </msub>
   <mo>⟹</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>A</mi>
     <mn>3</mn>
    </msub>
    <mo>=</mo>
    <mi>x</mi>
    <msub>
     <mi>A</mi>
     <mn>3</mn>
    </msub>
    <mo>=</mo>
    <mi>v</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>x</mi>
     <mo stretchy="false">]</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>S</ci>
     <cn type="integer">3</cn>
    </apply>
    <implies></implies>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <cn type="integer">3</cn>
     </apply>
     <eq></eq>
     <csymbol cd="unknown">x</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <cn type="integer">3</cn>
     </apply>
     <eq></eq>
     <csymbol cd="unknown">v</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-[</ci>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-]</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{3}\implies(A_{3}=xA_{3}=v[x])
  </annotation>
 </semantics>
</math>

 reduces to,</p>

<p>

<math display="block" id="Lambda_lifting:237">
 <semantics>
  <mrow>
   <msub>
    <mi>S</mi>
    <mn>3</mn>
   </msub>
   <mo>⟹</mo>
   <msub>
    <mi>A</mi>
    <mn>3</mn>
   </msub>
   <mo>=</mo>
   <mi>f</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <implies></implies>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>S</ci>
      <cn type="integer">3</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <cn type="integer">3</cn>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <ci>f</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{3}\implies A_{3}=f
  </annotation>
 </semantics>
</math>

 also,</p>

<p>

<math display="block" id="Lambda_lifting:238">
 <semantics>
  <mrow>
   <msub>
    <mi>S</mi>
    <mn>4</mn>
   </msub>
   <mo>⟹</mo>
   <msub>
    <mi>A</mi>
    <mn>4</mn>
   </msub>
   <mo>=</mo>
   <mi>p</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <implies></implies>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>S</ci>
      <cn type="integer">4</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <cn type="integer">4</cn>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <ci>p</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{4}\implies A_{4}=p
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Lambda_lifting:239">
 <semantics>
  <mrow>
   <msub>
    <mi>S</mi>
    <mn>4</mn>
   </msub>
   <mo>⟹</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>A</mi>
     <mn>4</mn>
    </msub>
    <mo>=</mo>
    <mi>q</mi>
    <msub>
     <mi>A</mi>
     <mn>4</mn>
    </msub>
    <mo>=</mo>
    <mi>v</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>q</mi>
     <mo stretchy="false">]</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>S</ci>
     <cn type="integer">4</cn>
    </apply>
    <implies></implies>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <cn type="integer">4</cn>
     </apply>
     <eq></eq>
     <csymbol cd="unknown">q</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <cn type="integer">4</cn>
     </apply>
     <eq></eq>
     <csymbol cd="unknown">v</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-[</ci>
      <csymbol cd="unknown">q</csymbol>
      <ci>normal-]</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{4}\implies(A_{4}=qA_{4}=v[q])
  </annotation>
 </semantics>
</math>

 reduces to,</p>

<p>

<math display="block" id="Lambda_lifting:240">
 <semantics>
  <mrow>
   <msub>
    <mi>S</mi>
    <mn>4</mn>
   </msub>
   <mo>⟹</mo>
   <msub>
    <mi>A</mi>
    <mn>4</mn>
   </msub>
   <mo>=</mo>
   <mi>p</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <implies></implies>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>S</ci>
      <cn type="integer">4</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <cn type="integer">4</cn>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <ci>p</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{4}\implies A_{4}=p
  </annotation>
 </semantics>
</math>

</p>

<p>So the parameter list for p is effectively;</p>

<p>

<math display="block" id="Lambda_lifting:241">
 <semantics>
  <mrow>
   <mi>D</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>p</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>q</mi>
    <mo>,</mo>
    <mi mathvariant="normal">_</mi>
    <mo>,</mo>
    <mi>p</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>:</mo>
   <mo>:</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi mathvariant="normal">_</mi>
    <mo>,</mo>
    <mi>f</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>:</mo>
   <mo>:</mo>
   <mi mathvariant="normal">_</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">D</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">p</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">q</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">_</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">p</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <ci>normal-:</ci>
    <ci>normal-:</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">_</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">f</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <ci>normal-:</ci>
    <ci>normal-:</ci>
    <csymbol cd="unknown">_</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D[p]=[q,\_,p]::[x,\_,f]::\_
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
</tbody>
</table>
<h4 id="drop-parameters">Drop parameters</h4>

<p>Use the information obtained by <a href="#Build_parameter_lists" title="wikilink">Build parameter lists</a> to drop actual parameters that are no longer required. <em>drop-params</em> has the parameters,</p>
<ul>
<li>The lambda expression in which the parameters are to be dropped.</li>
<li>The mapping of variable names to parameter lists (built in Build parameter lists).</li>
<li>The set of variables free in the lambda expression.</li>
<li>The returned parameter list. A parameter used internally in the algorithm.</li>
</ul>

<p><strong>Abstraction</strong></p>

<p>

<math display="block" id="Lambda_lifting:242">
 <semantics>
  <mrow>
   <mrow>
    <mi>drop</mi>
    <mo>-</mo>
    <mi>params</mi>
   </mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mi>N</mi>
     <mo>.</mo>
     <mi>S</mi>
     <mo rspace="7.5pt" stretchy="false">)</mo>
    </mrow>
    <mi>L</mi>
    <mo>,</mo>
    <mi>D</mi>
    <mo>,</mo>
    <mi>V</mi>
    <mo>,</mo>
    <mi>R</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>≡</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>N</mi>
    <mo>.</mo>
    <mrow>
     <mi>drop</mi>
     <mo>-</mo>
     <mi>params</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>S</mi>
     <mo>,</mo>
     <mi>D</mi>
     <mo>,</mo>
     <mi>F</mi>
     <mo>,</mo>
     <mi>R</mi>
     <mo stretchy="false">]</mo>
    </mrow>
    <mo rspace="7.5pt" stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mi>drop</mi>
    <mo>-</mo>
    <mi>formal</mi>
   </mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>D</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>N</mi>
     <mo stretchy="false">]</mo>
    </mrow>
    <mo>,</mo>
    <mi>L</mi>
    <mo>,</mo>
    <mi>F</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <minus></minus>
     <ci>drop</ci>
     <ci>params</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">N</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">S</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <csymbol cd="unknown">L</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">D</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">V</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">R</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <equivalent></equivalent>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">N</csymbol>
     <ci>normal-.</ci>
     <apply>
      <minus></minus>
      <ci>drop</ci>
      <ci>params</ci>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-[</ci>
      <csymbol cd="unknown">S</csymbol>
      <ci>normal-,</ci>
      <csymbol cd="unknown">D</csymbol>
      <ci>normal-,</ci>
      <csymbol cd="unknown">F</csymbol>
      <ci>normal-,</ci>
      <csymbol cd="unknown">R</csymbol>
      <ci>normal-]</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <apply>
     <minus></minus>
     <ci>drop</ci>
     <ci>formal</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">D</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-[</ci>
      <csymbol cd="unknown">N</csymbol>
      <ci>normal-]</ci>
     </cerror>
     <ci>normal-,</ci>
     <csymbol cd="unknown">L</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">F</csymbol>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{drop-params}[(\lambda N.S)\ L,D,V,R]\equiv(\lambda N.%
\operatorname{drop-params}[S,D,F,R])\ \operatorname{drop-formal}[D[N],L,F]
  </annotation>
 </semantics>
</math>

 where,</p>

<p>

<math display="block" id="Lambda_lifting:243">
 <semantics>
  <mrow>
   <mi>F</mi>
   <mo>=</mo>
   <mi>F</mi>
   <mi>V</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mi>N</mi>
     <mo>.</mo>
     <mi>S</mi>
     <mo rspace="7.5pt" stretchy="false">)</mo>
    </mrow>
    <mi>L</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">F</csymbol>
    <eq></eq>
    <csymbol cd="unknown">F</csymbol>
    <csymbol cd="unknown">V</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">N</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">S</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <csymbol cd="unknown">L</csymbol>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F=FV[(\lambda N.S)\ L]
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Lambda_lifting:244">
 <semantics>
  <mrow>
   <mrow>
    <mi>drop</mi>
    <mo>-</mo>
    <mi>params</mi>
   </mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>λ</mi>
    <mi>N</mi>
    <mo>.</mo>
    <mi>S</mi>
    <mo>,</mo>
    <mi>D</mi>
    <mo>,</mo>
    <mi>V</mi>
    <mo>,</mo>
    <mi>R</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>≡</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>N</mi>
    <mo>.</mo>
    <mrow>
     <mi>drop</mi>
     <mo>-</mo>
     <mi>params</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>S</mi>
     <mo>,</mo>
     <mi>D</mi>
     <mo>,</mo>
     <mi>F</mi>
     <mo>,</mo>
     <mi>R</mi>
     <mo stretchy="false">]</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <minus></minus>
     <ci>drop</ci>
     <ci>params</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">N</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">S</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">D</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">V</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">R</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <equivalent></equivalent>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">N</csymbol>
     <ci>normal-.</ci>
     <apply>
      <minus></minus>
      <ci>drop</ci>
      <ci>params</ci>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-[</ci>
      <csymbol cd="unknown">S</csymbol>
      <ci>normal-,</ci>
      <csymbol cd="unknown">D</csymbol>
      <ci>normal-,</ci>
      <csymbol cd="unknown">F</csymbol>
      <ci>normal-,</ci>
      <csymbol cd="unknown">R</csymbol>
      <ci>normal-]</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{drop-params}[\lambda N.S,D,V,R]\equiv(\lambda N.\operatorname{%
drop-params}[S,D,F,R])
  </annotation>
 </semantics>
</math>

 where,</p>

<p>

<math display="block" id="Lambda_lifting:245">
 <semantics>
  <mrow>
   <mi>F</mi>
   <mo>=</mo>
   <mi>F</mi>
   <mi>V</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>λ</mi>
    <mi>N</mi>
    <mo>.</mo>
    <mi>S</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">F</csymbol>
    <eq></eq>
    <csymbol cd="unknown">F</csymbol>
    <csymbol cd="unknown">V</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">N</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">S</csymbol>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F=FV[\lambda N.S]
  </annotation>
 </semantics>
</math>

</p>

<p><strong>Variable</strong></p>

<p>

<math display="block" id="Lambda_lifting:246">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>drop</mi>
     <mo>-</mo>
     <mi>params</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>N</mi>
     <mo>,</mo>
     <mi>D</mi>
     <mo>,</mo>
     <mi>V</mi>
     <mo>,</mo>
     <mrow>
      <mi>D</mi>
      <mrow>
       <mo stretchy="false">[</mo>
       <mi>N</mi>
       <mo stretchy="false">]</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>≡</mo>
   <mi>N</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <apply>
      <minus></minus>
      <ci>drop</ci>
      <ci>params</ci>
     </apply>
     <ci>N</ci>
     <ci>D</ci>
     <ci>V</ci>
     <apply>
      <times></times>
      <ci>D</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <ci>N</ci>
      </apply>
     </apply>
    </apply>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{drop-params}[N,D,V,D[N]]\equiv N
  </annotation>
 </semantics>
</math>

</p>

<p>For a function name or parameter start populating actual parameter list by outputting the parameter list for this name.</p>

<p><strong>Application</strong> - An application (function call) is processed to extract</p>

<p>

<math display="block" id="Lambda_lifting:247">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>def</mo>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>F</mi>
     <mo stretchy="false">]</mo>
    </mrow>
    <mi mathvariant="italic">and</mi>
    <mo>ask</mo>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>S</mi>
     <mo stretchy="false">]</mo>
    </mrow>
    <mi mathvariant="italic">and</mi>
    <mi>F</mi>
    <mi>V</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>A</mi>
     <mo stretchy="false">]</mo>
    </mrow>
    <mo>⊂</mo>
    <mi>V</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mi>drop</mi>
    <mo>-</mo>
    <mi>params</mi>
   </mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mpadded width="+5pt">
     <mi>E</mi>
    </mpadded>
    <mi>P</mi>
    <mo>,</mo>
    <mi>D</mi>
    <mo>,</mo>
    <mi>V</mi>
    <mo>,</mo>
    <mi>R</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>≡</mo>
   <mrow>
    <mi>drop</mi>
    <mo>-</mo>
    <mi>params</mi>
   </mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>E</mi>
    <mo>,</mo>
    <mi>D</mi>
    <mo>,</mo>
    <mi>V</mi>
    <mo>,</mo>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>F</mi>
     <mo>,</mo>
     <mi>S</mi>
     <mo>,</mo>
     <mi>A</mi>
     <mo stretchy="false">]</mo>
    </mrow>
    <mo>:</mo>
    <mo>:</mo>
    <mi>R</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <ci>def</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-[</ci>
      <csymbol cd="unknown">F</csymbol>
      <ci>normal-]</ci>
     </cerror>
     <csymbol cd="unknown">and</csymbol>
     <ci>ask</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-[</ci>
      <csymbol cd="unknown">S</csymbol>
      <ci>normal-]</ci>
     </cerror>
     <csymbol cd="unknown">and</csymbol>
     <csymbol cd="unknown">F</csymbol>
     <csymbol cd="unknown">V</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-[</ci>
      <csymbol cd="unknown">A</csymbol>
      <ci>normal-]</ci>
     </cerror>
     <subset></subset>
     <csymbol cd="unknown">V</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <apply>
     <minus></minus>
     <ci>drop</ci>
     <ci>params</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">E</csymbol>
     <csymbol cd="unknown">P</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">D</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">V</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">R</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <equivalent></equivalent>
    <apply>
     <minus></minus>
     <ci>drop</ci>
     <ci>params</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">E</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">D</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">V</csymbol>
     <ci>normal-,</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-[</ci>
      <csymbol cd="unknown">F</csymbol>
      <ci>normal-,</ci>
      <csymbol cd="unknown">S</csymbol>
      <ci>normal-,</ci>
      <csymbol cd="unknown">A</csymbol>
      <ci>normal-]</ci>
     </cerror>
     <ci>normal-:</ci>
     <ci>normal-:</ci>
     <csymbol cd="unknown">R</csymbol>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\operatorname{def}[F]\and\operatorname{ask}[S]\and FV[A]\subset V)\to%
\operatorname{drop-params}[E\ P,D,V,R]\equiv\operatorname{drop-params}[E,D,V,[%
F,S,A]::R]
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Lambda_lifting:248">
 <semantics>
  <mrow>
   <mi mathvariant="normal">¬</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>def</mo>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>F</mi>
     <mo stretchy="false">]</mo>
    </mrow>
    <mi mathvariant="italic">and</mi>
    <mo>ask</mo>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>S</mi>
     <mo stretchy="false">]</mo>
    </mrow>
    <mi mathvariant="italic">and</mi>
    <mi>F</mi>
    <mi>V</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>A</mi>
     <mo stretchy="false">]</mo>
    </mrow>
    <mo>⊂</mo>
    <mi>V</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mi>drop</mi>
    <mo>-</mo>
    <mi>params</mi>
   </mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mpadded width="+5pt">
     <mi>E</mi>
    </mpadded>
    <mi>P</mi>
    <mo>,</mo>
    <mi>D</mi>
    <mo>,</mo>
    <mi>V</mi>
    <mo>,</mo>
    <mi>R</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>≡</mo>
   <mrow>
    <mi>drop</mi>
    <mo>-</mo>
    <mi>params</mi>
   </mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>E</mi>
    <mo>,</mo>
    <mi>D</mi>
    <mo>,</mo>
    <mi>V</mi>
    <mo>,</mo>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>F</mi>
     <mo>,</mo>
     <mi>S</mi>
     <mo>,</mo>
     <mi>A</mi>
     <mo stretchy="false">]</mo>
    </mrow>
    <mo>:</mo>
    <mo>:</mo>
    <mi>R</mi>
    <mo rspace="7.5pt" stretchy="false">]</mo>
   </mrow>
   <mrow>
    <mi>drop</mi>
    <mo>-</mo>
    <mi>params</mi>
   </mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>P</mi>
    <mo>,</mo>
    <mi>D</mi>
    <mo>,</mo>
    <mi>V</mi>
    <mo>,</mo>
    <mi mathvariant="normal">_</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <not></not>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <ci>def</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-[</ci>
      <csymbol cd="unknown">F</csymbol>
      <ci>normal-]</ci>
     </cerror>
     <csymbol cd="unknown">and</csymbol>
     <ci>ask</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-[</ci>
      <csymbol cd="unknown">S</csymbol>
      <ci>normal-]</ci>
     </cerror>
     <csymbol cd="unknown">and</csymbol>
     <csymbol cd="unknown">F</csymbol>
     <csymbol cd="unknown">V</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-[</ci>
      <csymbol cd="unknown">A</csymbol>
      <ci>normal-]</ci>
     </cerror>
     <subset></subset>
     <csymbol cd="unknown">V</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <apply>
     <minus></minus>
     <ci>drop</ci>
     <ci>params</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">E</csymbol>
     <csymbol cd="unknown">P</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">D</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">V</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">R</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <equivalent></equivalent>
    <apply>
     <minus></minus>
     <ci>drop</ci>
     <ci>params</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">E</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">D</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">V</csymbol>
     <ci>normal-,</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-[</ci>
      <csymbol cd="unknown">F</csymbol>
      <ci>normal-,</ci>
      <csymbol cd="unknown">S</csymbol>
      <ci>normal-,</ci>
      <csymbol cd="unknown">A</csymbol>
      <ci>normal-]</ci>
     </cerror>
     <ci>normal-:</ci>
     <ci>normal-:</ci>
     <csymbol cd="unknown">R</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <apply>
     <minus></minus>
     <ci>drop</ci>
     <ci>params</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">P</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">D</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">V</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">_</csymbol>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg(\operatorname{def}[F]\and\operatorname{ask}[S]\and FV[A]\subset V)\to%
\operatorname{drop-params}[E\ P,D,V,R]\equiv\operatorname{drop-params}[E,D,V,[%
F,S,A]::R]\ \operatorname{drop-params}[P,D,V,\_]
  </annotation>
 </semantics>
</math>

</p>

<p><strong>Let</strong> - Let expression.</p>

<p>

<math display="block" id="Lambda_lifting:249">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mi>drop</mi>
      <mo>-</mo>
      <mi>params</mi>
     </mrow>
     <mrow>
      <mo stretchy="false">[</mo>
      <mrow>
       <mrow>
        <mo>let</mo>
        <mi>V</mi>
       </mrow>
       <mo>:</mo>
       <mrow>
        <mi>E</mi>
        <mrow>
         <mo>in</mo>
         <mi>L</mi>
        </mrow>
       </mrow>
      </mrow>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo>≡</mo>
    <mrow>
     <mo>let</mo>
     <mi>V</mi>
    </mrow>
   </mrow>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mrow>
      <mi>drop</mi>
      <mo>-</mo>
      <mi>params</mi>
     </mrow>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>E</mi>
      <mo>,</mo>
      <mi>D</mi>
      <mo>,</mo>
      <mrow>
       <mi>F</mi>
       <mi>V</mi>
       <mrow>
        <mo stretchy="false">[</mo>
        <mi>E</mi>
        <mo stretchy="false">]</mo>
       </mrow>
      </mrow>
      <mo>,</mo>
      <mrow>
       <mo stretchy="false">[</mo>
       <mo stretchy="false">]</mo>
      </mrow>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mrow>
     <mrow>
      <mo>in</mo>
      <mrow>
       <mi>drop</mi>
       <mo>-</mo>
       <mi>params</mi>
      </mrow>
     </mrow>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>L</mi>
      <mo>,</mo>
      <mi>D</mi>
      <mo>,</mo>
      <mrow>
       <mi>F</mi>
       <mi>V</mi>
       <mrow>
        <mo stretchy="false">[</mo>
        <mi>L</mi>
        <mo stretchy="false">]</mo>
       </mrow>
      </mrow>
      <mo>,</mo>
      <mrow>
       <mo stretchy="false">[</mo>
       <mo stretchy="false">]</mo>
      </mrow>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <equivalent></equivalent>
     <apply>
      <apply>
       <minus></minus>
       <ci>drop</ci>
       <ci>params</ci>
      </apply>
      <apply>
       <ci>normal-:</ci>
       <apply>
        <ci>let</ci>
        <ci>V</ci>
       </apply>
       <apply>
        <times></times>
        <ci>E</ci>
        <apply>
         <ci>in</ci>
         <ci>L</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <ci>let</ci>
      <ci>V</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <apply>
       <minus></minus>
       <ci>drop</ci>
       <ci>params</ci>
      </apply>
      <ci>E</ci>
      <ci>D</ci>
      <apply>
       <times></times>
       <ci>F</ci>
       <ci>V</ci>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <ci>E</ci>
       </apply>
      </apply>
      <list></list>
     </apply>
     <apply>
      <apply>
       <ci>in</ci>
       <apply>
        <minus></minus>
        <ci>drop</ci>
        <ci>params</ci>
       </apply>
      </apply>
      <ci>L</ci>
      <ci>D</ci>
      <apply>
       <times></times>
       <ci>F</ci>
       <ci>V</ci>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <ci>L</ci>
       </apply>
      </apply>
      <list></list>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{drop-params}[\operatorname{let}V:E\operatorname{in}L]\equiv%
\operatorname{let}V:\operatorname{drop-params}[E,D,FV[E],[]]\operatorname{in}%
\operatorname{drop-params}[L,D,FV[L],[]]
  </annotation>
 </semantics>
</math>

</p>

<p><strong>And</strong> - For use in "let".</p>

<p>

<math display="block" id="Lambda_lifting:250">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>drop</mi>
     <mo>-</mo>
     <mi>params</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mi>E</mi>
      <mi mathvariant="italic">and</mi>
      <mi>F</mi>
     </mrow>
     <mo>,</mo>
     <mi>D</mi>
     <mo>,</mo>
     <mi>V</mi>
     <mo>,</mo>
     <mi mathvariant="normal">_</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>≡</mo>
   <mrow>
    <mrow>
     <mrow>
      <mi>drop</mi>
      <mo>-</mo>
      <mi>params</mi>
     </mrow>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>E</mi>
      <mo>,</mo>
      <mi>D</mi>
      <mo>,</mo>
      <mi>V</mi>
      <mo>,</mo>
      <mi mathvariant="normal">_</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mi mathvariant="italic">and</mi>
    <mrow>
     <mrow>
      <mi>drop</mi>
      <mo>-</mo>
      <mi>params</mi>
     </mrow>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>F</mi>
      <mo>,</mo>
      <mi>D</mi>
      <mo>,</mo>
      <mi>V</mi>
      <mo>,</mo>
      <mi mathvariant="normal">_</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <apply>
      <minus></minus>
      <ci>drop</ci>
      <ci>params</ci>
     </apply>
     <apply>
      <times></times>
      <ci>E</ci>
      <ci>italic- and</ci>
      <ci>F</ci>
     </apply>
     <ci>D</ci>
     <ci>V</ci>
     <ci>normal-_</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <apply>
       <minus></minus>
       <ci>drop</ci>
       <ci>params</ci>
      </apply>
      <ci>E</ci>
      <ci>D</ci>
      <ci>V</ci>
      <ci>normal-_</ci>
     </apply>
     <ci>italic- and</ci>
     <apply>
      <apply>
       <minus></minus>
       <ci>drop</ci>
       <ci>params</ci>
      </apply>
      <ci>F</ci>
      <ci>D</ci>
      <ci>V</ci>
      <ci>normal-_</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{drop-params}[E\and F,D,V,\_]\equiv\operatorname{drop-params}[E,D%
,V,\_]\and\operatorname{drop-params}[F,D,V,\_]
  </annotation>
 </semantics>
</math>

</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>Drop parameters from applications</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>

<math display="inline" id="Lambda_lifting:251">
 <semantics>
  <mrow>
   <mrow>
    <mi>λ</mi>
    <mi>g</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>λ</mi>
    <mi>n</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mpadded width="+5pt">
     <mi>n</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>g</mi>
      </mpadded>
      <mpadded width="+5pt">
       <mi>m</mi>
      </mpadded>
      <mpadded width="+5pt">
       <mi>p</mi>
      </mpadded>
      <mi>n</mi>
     </mrow>
     <mo rspace="7.5pt" stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>g</mi>
      </mpadded>
      <mpadded width="+5pt">
       <mi>q</mi>
      </mpadded>
      <mpadded width="+5pt">
       <mi>p</mi>
      </mpadded>
      <mi>n</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>g</ci>
    </apply>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <times></times>
     <ci>n</ci>
     <apply>
      <times></times>
      <ci>g</ci>
      <ci>m</ci>
      <ci>p</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <times></times>
      <ci>g</ci>
      <ci>q</ci>
      <ci>p</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda g.\lambda n.n\ (g\ m\ p\ n)\ (g\ q\ p\ n)
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Condition</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>

<math display="inline" id="Lambda_lifting:252">
 <semantics>
  <mrow>
   <mi mathvariant="normal">¬</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mrow>
      <mo>def</mo>
      <mrow>
       <mo stretchy="false">[</mo>
       <msub>
        <mi>F</mi>
        <mn>1</mn>
       </msub>
       <mo stretchy="false">]</mo>
      </mrow>
     </mrow>
     <mrow>
      <mi mathvariant="italic">and</mi>
      <mi mathvariant="normal">…</mi>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <not></not>
    <apply>
     <apply>
      <ci>def</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>F</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>italic- and</ci>
      <ci>normal-…</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg(\operatorname{def}[F_{1}]\and...)
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>

<math display="inline" id="Lambda_lifting:253">
 <semantics>
  <mrow>
   <mi mathvariant="normal">¬</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mrow>
      <mo>def</mo>
      <mrow>
       <mo stretchy="false">[</mo>
       <msub>
        <mi>F</mi>
        <mn>2</mn>
       </msub>
       <mo stretchy="false">]</mo>
      </mrow>
     </mrow>
     <mrow>
      <mi mathvariant="italic">and</mi>
      <mi mathvariant="normal">…</mi>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <not></not>
    <apply>
     <apply>
      <ci>def</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>F</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>italic- and</ci>
      <ci>normal-…</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg(\operatorname{def}[F_{2}]\and...)
  </annotation>
 </semantics>
</math>


</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>

<math display="inline" id="Lambda_lifting:254">
 <semantics>
  <mrow>
   <mi>D</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>n</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <msub>
     <mi>F</mi>
     <mn>2</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>S</mi>
     <mn>2</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>A</mi>
     <mn>2</mn>
    </msub>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>:</mo>
   <mo>:</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <msub>
     <mi>F</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>S</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>A</mi>
     <mn>1</mn>
    </msub>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>:</mo>
   <mo>:</mo>
   <mi mathvariant="normal">_</mi>
   <mo stretchy="false">]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">D</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">n</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>F</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>S</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-]</ci>
    </cerror>
    <ci>normal-:</ci>
    <ci>normal-:</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>F</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>S</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-]</ci>
    </cerror>
    <ci>normal-:</ci>
    <ci>normal-:</ci>
    <csymbol cd="unknown">_</csymbol>
    <ci>normal-]</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D[n]=[F_{2},S_{2},A_{2}]::[F_{1},S_{1},A_{1}]::\_]
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>

<p>From the results of building parameter lists;</p>

<p>

<math display="block" id="Lambda_lifting:255">
 <semantics>
  <mrow>
   <mrow>
    <mi>D</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>n</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi mathvariant="normal">_</mi>
     <mo>,</mo>
     <mi mathvariant="normal">_</mi>
     <mo>,</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mpadded width="+5pt">
        <mi>g</mi>
       </mpadded>
       <mpadded width="+5pt">
        <mi>m</mi>
       </mpadded>
       <mpadded width="+5pt">
        <mi>p</mi>
       </mpadded>
       <mi>n</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi mathvariant="normal">_</mi>
     <mo>,</mo>
     <mi mathvariant="normal">_</mi>
     <mo>,</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mpadded width="+5pt">
        <mi>g</mi>
       </mpadded>
       <mpadded width="+5pt">
        <mi>q</mi>
       </mpadded>
       <mpadded width="+5pt">
        <mi>p</mi>
       </mpadded>
       <mi>n</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>D</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>n</ci>
     </apply>
    </apply>
    <interval closure="closed">
     <list>
      <ci>normal-_</ci>
      <ci>normal-_</ci>
      <apply>
       <times></times>
       <ci>g</ci>
       <ci>m</ci>
       <ci>p</ci>
       <ci>n</ci>
      </apply>
     </list>
     <list>
      <ci>normal-_</ci>
      <ci>normal-_</ci>
      <apply>
       <times></times>
       <ci>g</ci>
       <ci>q</ci>
       <ci>p</ci>
       <ci>n</ci>
      </apply>
     </list>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D[n]=[[\_,\_,(g\ m\ p\ n)],[\_,\_,(g\ q\ p\ n)]]
  </annotation>
 </semantics>
</math>

 so,</p>

<p>

<math display="block" id="Lambda_lifting:256">
 <semantics>
  <mrow>
   <msub>
    <mi>F</mi>
    <mn>1</mn>
   </msub>
   <mo>=</mo>
   <mi mathvariant="normal">_</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>F</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-_</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F_{1}=\_
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Lambda_lifting:257">
 <semantics>
  <mrow>
   <msub>
    <mi>F</mi>
    <mn>2</mn>
   </msub>
   <mo>=</mo>
   <mi mathvariant="normal">_</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>F</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>normal-_</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F_{2}=\_
  </annotation>
 </semantics>
</math>

 so,</p>

<p>

<math display="block" id="Lambda_lifting:258">
 <semantics>
  <mrow>
   <mrow>
    <mo>def</mo>
    <mrow>
     <mo stretchy="false">[</mo>
     <msub>
      <mi>F</mi>
      <mn>1</mn>
     </msub>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mo>false</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>def</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>F</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <ci>false</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{def}[F_{1}]=\operatorname{false}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Lambda_lifting:259">
 <semantics>
  <mrow>
   <mrow>
    <mo>def</mo>
    <mrow>
     <mo stretchy="false">[</mo>
     <msub>
      <mi>F</mi>
      <mn>2</mn>
     </msub>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mo>false</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>def</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>F</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <ci>false</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{def}[F_{2}]=\operatorname{false}
  </annotation>
 </semantics>
</math>

</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>

<math display="inline" id="Lambda_lifting:260">
 <semantics>
  <mrow>
   <mrow>
    <mi>drop</mi>
    <mo>-</mo>
    <mi>param</mi>
   </mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>g</mi>
      </mpadded>
      <mpadded width="+5pt">
       <mi>m</mi>
      </mpadded>
      <mpadded width="+5pt">
       <mi>p</mi>
      </mpadded>
      <mi>n</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>,</mo>
    <mi>D</mi>
    <mo>,</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mi>p</mi>
     <mo>,</mo>
     <mi>q</mi>
     <mo>,</mo>
     <mi>m</mi>
     <mo stretchy="false">}</mo>
    </mrow>
    <mo>,</mo>
    <mi mathvariant="normal">_</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <minus></minus>
     <ci>drop</ci>
     <ci>param</ci>
    </apply>
    <apply>
     <times></times>
     <ci>g</ci>
     <ci>m</ci>
     <ci>p</ci>
     <ci>n</ci>
    </apply>
    <ci>D</ci>
    <set>
     <ci>p</ci>
     <ci>q</ci>
     <ci>m</ci>
    </set>
    <ci>normal-_</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{drop-param}[(g\ m\ p\ n),D,\{p,q,m\},\_]
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Condition</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>

<math display="inline" id="Lambda_lifting:261">
 <semantics>
  <mrow>
   <mi>V</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mi>p</mi>
    <mo>,</mo>
    <mi>q</mi>
    <mo>,</mo>
    <mi>m</mi>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>V</ci>
    <set>
     <ci>p</ci>
     <ci>q</ci>
     <ci>m</ci>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V=\{p,q,m\}
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>

<math display="inline" id="Lambda_lifting:262">
 <semantics>
  <mrow>
   <mrow>
    <mi>F</mi>
    <mi>V</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>A</mi>
      <mn>1</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>⊄</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mi>p</mi>
    <mo>,</mo>
    <mi>q</mi>
    <mo>,</mo>
    <mi>m</mi>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">not-subset-of</csymbol>
    <apply>
     <times></times>
     <ci>F</ci>
     <ci>V</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <set>
     <ci>p</ci>
     <ci>q</ci>
     <ci>m</ci>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   FV(A_{1})\not\subset\{p,q,m\}
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>

<math display="inline" id="Lambda_lifting:263">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mo>def</mo>
      <mrow>
       <mo stretchy="false">[</mo>
       <msub>
        <mi>F</mi>
        <mn>2</mn>
       </msub>
       <mo stretchy="false">]</mo>
      </mrow>
     </mrow>
     <mi mathvariant="italic">and</mi>
    </mrow>
    <mrow>
     <mrow>
      <mo>ask</mo>
      <mrow>
       <mo stretchy="false">[</mo>
       <msub>
        <mi>S</mi>
        <mn>2</mn>
       </msub>
       <mo stretchy="false">]</mo>
      </mrow>
     </mrow>
     <mrow>
      <mi mathvariant="italic">and</mi>
      <mi>F</mi>
      <mi>V</mi>
     </mrow>
    </mrow>
    <mrow>
     <mo stretchy="false">[</mo>
     <msub>
      <mi>A</mi>
      <mn>2</mn>
     </msub>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>⊂</mo>
   <mi>V</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <apply>
     <times></times>
     <apply>
      <apply>
       <ci>def</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>F</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <ci>italic- and</ci>
     </apply>
     <apply>
      <apply>
       <ci>ask</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>S</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>italic- and</ci>
       <ci>F</ci>
       <ci>V</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>A</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
    <ci>V</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{def}[F_{2}]\and\operatorname{ask}[S_{2}]\and FV[A_{2}]\subset V
  </annotation>
 </semantics>
</math>


</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>

<math display="inline" id="Lambda_lifting:264">
 <semantics>
  <mrow>
   <mi mathvariant="normal">¬</mi>
   <mrow>
    <mo>ask</mo>
    <mrow>
     <mo stretchy="false">[</mo>
     <msub>
      <mi>S</mi>
      <mn>3</mn>
     </msub>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <not></not>
    <apply>
     <ci>ask</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>S</ci>
      <cn type="integer">3</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg\operatorname{ask}[S_{3}]
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>

<math display="inline" id="Lambda_lifting:265">
 <semantics>
  <mrow>
   <mrow>
    <mi>D</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>g</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mo>false</mo>
     <mo>,</mo>
     <mi mathvariant="normal">_</mi>
     <mo stretchy="false">]</mo>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>o</mi>
     <mo>,</mo>
     <mi mathvariant="normal">_</mi>
     <mo>,</mo>
     <mi>p</mi>
     <mo stretchy="false">]</mo>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>y</mi>
     <mo>,</mo>
     <mi mathvariant="normal">_</mi>
     <mo>,</mo>
     <mi>n</mi>
     <mo stretchy="false">]</mo>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>D</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>g</ci>
     </apply>
    </apply>
    <list>
     <list>
      <ci>x</ci>
      <ci>false</ci>
      <ci>normal-_</ci>
     </list>
     <list>
      <ci>o</ci>
      <ci>normal-_</ci>
      <ci>p</ci>
     </list>
     <list>
      <ci>y</ci>
      <ci>normal-_</ci>
      <ci>n</ci>
     </list>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D[g]=[[x,\operatorname{false},\_],[o,\_,p],[y,\_,n]]
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Lambda_lifting:266">
 <semantics>
  <mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <msub>
     <mi>F</mi>
     <mn>3</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>S</mi>
     <mn>3</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>A</mi>
     <mn>3</mn>
    </msub>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>:</mo>
   <mo>:</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <msub>
     <mi>F</mi>
     <mn>2</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>S</mi>
     <mn>2</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>A</mi>
     <mn>2</mn>
    </msub>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>:</mo>
   <mo>:</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <msub>
     <mi>F</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>S</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>A</mi>
     <mn>1</mn>
    </msub>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>:</mo>
   <mo>:</mo>
   <mi mathvariant="normal">_</mi>
   <mo stretchy="false">]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>F</ci>
      <cn type="integer">3</cn>
     </apply>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>S</ci>
      <cn type="integer">3</cn>
     </apply>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <cn type="integer">3</cn>
     </apply>
     <ci>normal-]</ci>
    </cerror>
    <ci>normal-:</ci>
    <ci>normal-:</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>F</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>S</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-]</ci>
    </cerror>
    <ci>normal-:</ci>
    <ci>normal-:</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>F</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>S</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-]</ci>
    </cerror>
    <ci>normal-:</ci>
    <ci>normal-:</ci>
    <csymbol cd="unknown">_</csymbol>
    <ci>normal-]</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =[F_{3},S_{3},A_{3}]::[F_{2},S_{2},A_{2}]::[F_{1},S_{1},A_{1}]::\_]
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
</tbody>
</table>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>

<math display="inline" id="Lambda_lifting:267">
 <semantics>
  <mrow>
   <mrow>
    <mi>drop</mi>
    <mo>-</mo>
    <mi>param</mi>
   </mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>g</mi>
      </mpadded>
      <mpadded width="+5pt">
       <mi>q</mi>
      </mpadded>
      <mpadded width="+5pt">
       <mi>p</mi>
      </mpadded>
      <mi>n</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>,</mo>
    <mi>D</mi>
    <mo>,</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mi>p</mi>
     <mo>,</mo>
     <mi>q</mi>
     <mo>,</mo>
     <mi>m</mi>
     <mo stretchy="false">}</mo>
    </mrow>
    <mo>,</mo>
    <mi mathvariant="normal">_</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <minus></minus>
     <ci>drop</ci>
     <ci>param</ci>
    </apply>
    <apply>
     <times></times>
     <ci>g</ci>
     <ci>q</ci>
     <ci>p</ci>
     <ci>n</ci>
    </apply>
    <ci>D</ci>
    <set>
     <ci>p</ci>
     <ci>q</ci>
     <ci>m</ci>
    </set>
    <ci>normal-_</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{drop-param}[(g\ q\ p\ n),D,\{p,q,m\},\_]
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Condition</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>V = \{p, q, m\}</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>

<math display="inline" id="Lambda_lifting:268">
 <semantics>
  <mrow>
   <mrow>
    <mi>F</mi>
    <mi>V</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>A</mi>
      <mn>4</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>⊄</mo>
   <mi>V</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">not-subset-of</csymbol>
    <apply>
     <times></times>
     <ci>F</ci>
     <ci>V</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <cn type="integer">4</cn>
     </apply>
    </apply>
    <ci>V</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   FV(A_{4})\not\subset V
  </annotation>
 </semantics>
</math>


</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>

<math display="inline" id="Lambda_lifting:269">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mo>def</mo>
      <mrow>
       <mo stretchy="false">[</mo>
       <msub>
        <mi>F</mi>
        <mn>5</mn>
       </msub>
       <mo stretchy="false">]</mo>
      </mrow>
     </mrow>
     <mi mathvariant="italic">and</mi>
    </mrow>
    <mrow>
     <mrow>
      <mo>ask</mo>
      <mrow>
       <mo stretchy="false">[</mo>
       <msub>
        <mi>S</mi>
        <mn>5</mn>
       </msub>
       <mo stretchy="false">]</mo>
      </mrow>
     </mrow>
     <mrow>
      <mi mathvariant="italic">and</mi>
      <mi>F</mi>
      <mi>V</mi>
     </mrow>
    </mrow>
    <mrow>
     <mo stretchy="false">[</mo>
     <msub>
      <mi>A</mi>
      <mn>5</mn>
     </msub>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>⊂</mo>
   <mi>V</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <apply>
     <times></times>
     <apply>
      <apply>
       <ci>def</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>F</ci>
        <cn type="integer">5</cn>
       </apply>
      </apply>
      <ci>italic- and</ci>
     </apply>
     <apply>
      <apply>
       <ci>ask</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>S</ci>
        <cn type="integer">5</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>italic- and</ci>
       <ci>F</ci>
       <ci>V</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>A</ci>
       <cn type="integer">5</cn>
      </apply>
     </apply>
    </apply>
    <ci>V</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{def}[F_{5}]\and\operatorname{ask}[S_{5}]\and FV[A_{5}]\subset V
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>

<math display="inline" id="Lambda_lifting:270">
 <semantics>
  <mrow>
   <mi mathvariant="normal">¬</mi>
   <mrow>
    <mo>ask</mo>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mi>S</mi>
      <mo>-</mo>
      <mn>6</mn>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <not></not>
    <apply>
     <ci>ask</ci>
     <apply>
      <minus></minus>
      <ci>S</ci>
      <cn type="integer">6</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg\operatorname{ask}[S-6]
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>

<math display="inline" id="Lambda_lifting:271">
 <semantics>
  <mrow>
   <mrow>
    <mi>D</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>g</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mo>false</mo>
     <mo>,</mo>
     <mi mathvariant="normal">_</mi>
     <mo stretchy="false">]</mo>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>o</mi>
     <mo>,</mo>
     <mi mathvariant="normal">_</mi>
     <mo>,</mo>
     <mi>p</mi>
     <mo stretchy="false">]</mo>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>y</mi>
     <mo>,</mo>
     <mi mathvariant="normal">_</mi>
     <mo>,</mo>
     <mi>n</mi>
     <mo stretchy="false">]</mo>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>D</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>g</ci>
     </apply>
    </apply>
    <list>
     <list>
      <ci>x</ci>
      <ci>false</ci>
      <ci>normal-_</ci>
     </list>
     <list>
      <ci>o</ci>
      <ci>normal-_</ci>
      <ci>p</ci>
     </list>
     <list>
      <ci>y</ci>
      <ci>normal-_</ci>
      <ci>n</ci>
     </list>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D[g]=[[x,\operatorname{false},\_],[o,\_,p],[y,\_,n]]
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Lambda_lifting:272">
 <semantics>
  <mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <msub>
     <mi>F</mi>
     <mn>6</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>S</mi>
     <mn>6</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>A</mi>
     <mn>6</mn>
    </msub>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>:</mo>
   <mo>:</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <msub>
     <mi>F</mi>
     <mn>5</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>S</mi>
     <mn>5</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>A</mi>
     <mn>5</mn>
    </msub>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>:</mo>
   <mo>:</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <msub>
     <mi>F</mi>
     <mn>4</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>S</mi>
     <mn>4</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>A</mi>
     <mn>4</mn>
    </msub>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>:</mo>
   <mo>:</mo>
   <mi mathvariant="normal">_</mi>
   <mo stretchy="false">]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>F</ci>
      <cn type="integer">6</cn>
     </apply>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>S</ci>
      <cn type="integer">6</cn>
     </apply>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <cn type="integer">6</cn>
     </apply>
     <ci>normal-]</ci>
    </cerror>
    <ci>normal-:</ci>
    <ci>normal-:</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>F</ci>
      <cn type="integer">5</cn>
     </apply>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>S</ci>
      <cn type="integer">5</cn>
     </apply>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <cn type="integer">5</cn>
     </apply>
     <ci>normal-]</ci>
    </cerror>
    <ci>normal-:</ci>
    <ci>normal-:</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>F</ci>
      <cn type="integer">4</cn>
     </apply>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>S</ci>
      <cn type="integer">4</cn>
     </apply>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <cn type="integer">4</cn>
     </apply>
     <ci>normal-]</ci>
    </cerror>
    <ci>normal-:</ci>
    <ci>normal-:</ci>
    <csymbol cd="unknown">_</csymbol>
    <ci>normal-]</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =[F_{6},S_{6},A_{6}]::[F_{5},S_{5},A_{5}]::[F_{4},S_{4},A_{4}]::\_]
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
</tbody>
</table></td>
</tr>
</tbody>
</table>
<h5 id="drop-formal-parameters">Drop formal parameters</h5>

<p><em>drop-formal</em> removes formal parameters, based on the contents of the drop lists. Its parameters are,</p>
<ul>
<li>The drop list,</li>
<li>The function definition (lambda abstraction).</li>
<li>The free variables from the function definition.</li>
</ul>

<p><em>drop-formal</em> is defined as,</p>
<ol>
<li>

<math display="inline" id="Lambda_lifting:273">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>ask</mo>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>S</mi>
     <mo stretchy="false">]</mo>
    </mrow>
    <mi mathvariant="italic">and</mi>
    <mi>F</mi>
    <mi>V</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>A</mi>
     <mo stretchy="false">]</mo>
    </mrow>
    <mo>⊂</mo>
    <mi>V</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mi>drop</mi>
    <mo>-</mo>
    <mi>formal</mi>
   </mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>F</mi>
     <mo>,</mo>
     <mi>S</mi>
     <mo>,</mo>
     <mi>A</mi>
     <mo stretchy="false">]</mo>
    </mrow>
    <mo>:</mo>
    <mo>:</mo>
    <mi>Z</mi>
    <mo>,</mo>
    <mi>λ</mi>
    <mi>F</mi>
    <mo>.</mo>
    <mi>Y</mi>
    <mo>,</mo>
    <mi>V</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>≡</mo>
   <mrow>
    <mi>drop</mi>
    <mo>-</mo>
    <mi>formal</mi>
   </mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>F</mi>
     <mo>,</mo>
     <mi>S</mi>
     <mo>,</mo>
     <mi>A</mi>
     <mo stretchy="false">]</mo>
    </mrow>
    <mo>:</mo>
    <mo>:</mo>
    <mi>Z</mi>
    <mo>,</mo>
    <mi>Y</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>F</mi>
     <mo>:=</mo>
     <mi>A</mi>
     <mo stretchy="false">]</mo>
    </mrow>
    <mo>,</mo>
    <mi>L</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <ci>ask</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-[</ci>
      <csymbol cd="unknown">S</csymbol>
      <ci>normal-]</ci>
     </cerror>
     <csymbol cd="unknown">and</csymbol>
     <csymbol cd="unknown">F</csymbol>
     <csymbol cd="unknown">V</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-[</ci>
      <csymbol cd="unknown">A</csymbol>
      <ci>normal-]</ci>
     </cerror>
     <subset></subset>
     <csymbol cd="unknown">V</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <apply>
     <minus></minus>
     <ci>drop</ci>
     <ci>formal</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-[</ci>
      <csymbol cd="unknown">F</csymbol>
      <ci>normal-,</ci>
      <csymbol cd="unknown">S</csymbol>
      <ci>normal-,</ci>
      <csymbol cd="unknown">A</csymbol>
      <ci>normal-]</ci>
     </cerror>
     <ci>normal-:</ci>
     <ci>normal-:</ci>
     <csymbol cd="unknown">Z</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">F</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">Y</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">V</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <equivalent></equivalent>
    <apply>
     <minus></minus>
     <ci>drop</ci>
     <ci>formal</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-[</ci>
      <csymbol cd="unknown">F</csymbol>
      <ci>normal-,</ci>
      <csymbol cd="unknown">S</csymbol>
      <ci>normal-,</ci>
      <csymbol cd="unknown">A</csymbol>
      <ci>normal-]</ci>
     </cerror>
     <ci>normal-:</ci>
     <ci>normal-:</ci>
     <csymbol cd="unknown">Z</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">Y</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-[</ci>
      <csymbol cd="unknown">F</csymbol>
      <csymbol cd="latexml">assign</csymbol>
      <csymbol cd="unknown">A</csymbol>
      <ci>normal-]</ci>
     </cerror>
     <ci>normal-,</ci>
     <csymbol cd="unknown">L</csymbol>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\operatorname{ask}[S]\and FV[A]\subset V)\to\operatorname{drop-formal}[[F,S,A%
]::Z,\lambda F.Y,V]\equiv\operatorname{drop-formal}[[F,S,A]::Z,Y[F:=A],L]
  </annotation>
 </semantics>
</math>


</li>
<li>

<math display="inline" id="Lambda_lifting:274">
 <semantics>
  <mrow>
   <mi mathvariant="normal">¬</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>ask</mo>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>S</mi>
     <mo stretchy="false">]</mo>
    </mrow>
    <mi mathvariant="italic">and</mi>
    <mi>F</mi>
    <mi>V</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>A</mi>
     <mo stretchy="false">]</mo>
    </mrow>
    <mo>⊂</mo>
    <mi>V</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mi>drop</mi>
    <mo>-</mo>
    <mi>formal</mi>
   </mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>F</mi>
     <mo>,</mo>
     <mi>S</mi>
     <mo>,</mo>
     <mi>A</mi>
     <mo stretchy="false">]</mo>
    </mrow>
    <mo>:</mo>
    <mo>:</mo>
    <mi>Z</mi>
    <mo>,</mo>
    <mi>λ</mi>
    <mi>F</mi>
    <mo>.</mo>
    <mi>Y</mi>
    <mo>,</mo>
    <mi>V</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>≡</mo>
   <mi>λ</mi>
   <mi>F</mi>
   <mo>.</mo>
   <mrow>
    <mi>drop</mi>
    <mo>-</mo>
    <mi>formal</mi>
   </mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>F</mi>
     <mo>,</mo>
     <mi>S</mi>
     <mo>,</mo>
     <mi>A</mi>
     <mo stretchy="false">]</mo>
    </mrow>
    <mo>:</mo>
    <mo>:</mo>
    <mi>Z</mi>
    <mo>,</mo>
    <mi>Y</mi>
    <mo>,</mo>
    <mi>V</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <not></not>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <ci>ask</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-[</ci>
      <csymbol cd="unknown">S</csymbol>
      <ci>normal-]</ci>
     </cerror>
     <csymbol cd="unknown">and</csymbol>
     <csymbol cd="unknown">F</csymbol>
     <csymbol cd="unknown">V</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-[</ci>
      <csymbol cd="unknown">A</csymbol>
      <ci>normal-]</ci>
     </cerror>
     <subset></subset>
     <csymbol cd="unknown">V</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <apply>
     <minus></minus>
     <ci>drop</ci>
     <ci>formal</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-[</ci>
      <csymbol cd="unknown">F</csymbol>
      <ci>normal-,</ci>
      <csymbol cd="unknown">S</csymbol>
      <ci>normal-,</ci>
      <csymbol cd="unknown">A</csymbol>
      <ci>normal-]</ci>
     </cerror>
     <ci>normal-:</ci>
     <ci>normal-:</ci>
     <csymbol cd="unknown">Z</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">F</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">Y</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">V</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <equivalent></equivalent>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">F</csymbol>
    <ci>normal-.</ci>
    <apply>
     <minus></minus>
     <ci>drop</ci>
     <ci>formal</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-[</ci>
      <csymbol cd="unknown">F</csymbol>
      <ci>normal-,</ci>
      <csymbol cd="unknown">S</csymbol>
      <ci>normal-,</ci>
      <csymbol cd="unknown">A</csymbol>
      <ci>normal-]</ci>
     </cerror>
     <ci>normal-:</ci>
     <ci>normal-:</ci>
     <csymbol cd="unknown">Z</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">Y</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">V</csymbol>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg(\operatorname{ask}[S]\and FV[A]\subset V)\to\operatorname{drop-formal}[[F%
,S,A]::Z,\lambda F.Y,V]\equiv\lambda F.\operatorname{drop-formal}[[F,S,A]::Z,Y%
,V]
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="Lambda_lifting:275">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>drop</mi>
     <mo>-</mo>
     <mi>formal</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>Z</mi>
     <mo>,</mo>
     <mi>Y</mi>
     <mo>,</mo>
     <mi>V</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>≡</mo>
   <mi>Y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <apply>
      <minus></minus>
      <ci>drop</ci>
      <ci>formal</ci>
     </apply>
     <ci>Z</ci>
     <ci>Y</ci>
     <ci>V</ci>
    </apply>
    <ci>Y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{drop-formal}[Z,Y,V]\equiv Y
  </annotation>
 </semantics>
</math>

</li>
</ol>

<p>Which can be explained as,</p>
<ol>
<li>If all the actual parameters have the same value, and all the free variables of that value are available for definition of the function then drop the parameter, and replace the old parameter with its value.</li>
<li>else do not drop the parameter.</li>
<li>else return the body of the function.</li>
</ol>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>Condition</p></th>
<th style="text-align: left;">
<p>Expression</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>

<math display="inline" id="Lambda_lifting:276">
 <semantics>
  <mo>false</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>false</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{false}
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Lambda_lifting:277">
 <semantics>
  <mrow>
   <mrow>
    <mi>drop</mi>
    <mo>-</mo>
    <mi>formal</mi>
   </mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>D</mi>
    <mo>,</mo>
    <mi>λ</mi>
    <mi>x</mi>
    <mo>.</mo>
    <mi>λ</mi>
    <mi>o</mi>
    <mo>.</mo>
    <mi>λ</mi>
    <mi>y</mi>
    <mo>.</mo>
    <mpadded width="+5pt">
     <mi>o</mi>
    </mpadded>
    <mpadded width="+5pt">
     <mi>x</mi>
    </mpadded>
    <mi>y</mi>
    <mo>,</mo>
    <mi>F</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <minus></minus>
     <ci>drop</ci>
     <ci>formal</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">D</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">o</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">o</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">F</csymbol>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{drop-formal}[D,\lambda x.\lambda o.\lambda y.o\ x\ y,F]
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>

<math display="inline" id="Lambda_lifting:278">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>true</mo>
     <mi mathvariant="italic">and</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">{</mo>
     <mi>p</mi>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
   <mo>⊂</mo>
   <mi>F</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <apply>
     <times></times>
     <apply>
      <ci>true</ci>
      <ci>italic- and</ci>
     </apply>
     <set>
      <ci>p</ci>
     </set>
    </apply>
    <ci>F</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{true}\and\{p\}\subset F
  </annotation>
 </semantics>
</math>


</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Lambda_lifting:279">
 <semantics>
  <mrow>
   <mi>λ</mi>
   <mi>x</mi>
   <mo>.</mo>
   <mrow>
    <mi>drop</mi>
    <mo>-</mo>
    <mi>formal</mi>
   </mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>D</mi>
    <mo>,</mo>
    <mi>λ</mi>
    <mi>o</mi>
    <mo>.</mo>
    <mi>λ</mi>
    <mi>y</mi>
    <mo>.</mo>
    <mpadded width="+5pt">
     <mi>o</mi>
    </mpadded>
    <mpadded width="+5pt">
     <mi>x</mi>
    </mpadded>
    <mi>y</mi>
    <mo>,</mo>
    <mi>F</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <ci>normal-.</ci>
    <apply>
     <minus></minus>
     <ci>drop</ci>
     <ci>formal</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">D</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">o</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">o</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">F</csymbol>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda x.\operatorname{drop-formal}[D,\lambda o.\lambda y.o\ x\ y,F]
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>

<math display="inline" id="Lambda_lifting:280">
 <semantics>
  <mrow>
   <mi mathvariant="normal">¬</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>true</mo>
    <mi mathvariant="italic">and</mi>
    <mrow>
     <mo stretchy="false">{</mo>
     <mi>n</mi>
     <mo stretchy="false">}</mo>
    </mrow>
    <mo>⊂</mo>
    <mi>F</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <not></not>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <ci>true</ci>
     <csymbol cd="unknown">and</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-{</ci>
      <csymbol cd="unknown">n</csymbol>
      <ci>normal-}</ci>
     </cerror>
     <subset></subset>
     <csymbol cd="unknown">F</csymbol>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg(\operatorname{true}\and\{n\}\subset F
  </annotation>
 </semantics>
</math>

)</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Lambda_lifting:281">
 <semantics>
  <mrow>
   <mi>λ</mi>
   <mi>x</mi>
   <mo>.</mo>
   <mrow>
    <mi>drop</mi>
    <mo>-</mo>
    <mi>formal</mi>
   </mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>D</mi>
    <mo>,</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mi>y</mi>
     <mo>.</mo>
     <mpadded width="+5pt">
      <mi>o</mi>
     </mpadded>
     <mpadded width="+5pt">
      <mi>x</mi>
     </mpadded>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>o</mi>
     <mo>:=</mo>
     <mi>p</mi>
     <mo stretchy="false">]</mo>
    </mrow>
    <mo>,</mo>
    <mi>F</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <ci>normal-.</ci>
    <apply>
     <minus></minus>
     <ci>drop</ci>
     <ci>formal</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">D</csymbol>
     <ci>normal-,</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">y</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">o</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <csymbol cd="unknown">y</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-[</ci>
      <csymbol cd="unknown">o</csymbol>
      <csymbol cd="latexml">assign</csymbol>
      <csymbol cd="unknown">p</csymbol>
      <ci>normal-]</ci>
     </cerror>
     <ci>normal-,</ci>
     <csymbol cd="unknown">F</csymbol>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda x.\operatorname{drop-formal}[D,(\lambda y.o\ x\ y)[o:=p],F]
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Lambda_lifting:282">
 <semantics>
  <mrow>
   <mrow>
    <mi>λ</mi>
    <mi>x</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>λ</mi>
    <mi>y</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mrow>
     <mi>drop</mi>
     <mo>-</mo>
     <mi>formal</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>D</mi>
     <mo>,</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>p</mi>
      </mpadded>
      <mpadded width="+5pt">
       <mi>x</mi>
      </mpadded>
      <mi>y</mi>
     </mrow>
     <mo>,</mo>
     <mi>F</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>y</ci>
    </apply>
    <apply>
     <apply>
      <minus></minus>
      <ci>drop</ci>
      <ci>formal</ci>
     </apply>
     <ci>D</ci>
     <apply>
      <times></times>
      <ci>p</ci>
      <ci>x</ci>
      <ci>y</ci>
     </apply>
     <ci>F</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda x.\lambda y.\operatorname{drop-formal}[D,p\ x\ y,F]
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Lambda_lifting:283">
 <semantics>
  <mrow>
   <mrow>
    <mi>λ</mi>
    <mi>x</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>λ</mi>
    <mi>y</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mpadded width="+5pt">
     <mi>p</mi>
    </mpadded>
    <mpadded width="+5pt">
     <mi>x</mi>
    </mpadded>
    <mi>y</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>y</ci>
    </apply>
    <apply>
     <times></times>
     <ci>p</ci>
     <ci>x</ci>
     <ci>y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda x.\lambda y.p\ x\ y
  </annotation>
 </semantics>
</math>


</p></td>
</tr>
</tbody>
</table>
<h3 id="example-2">Example</h3>

<p>Starting with the function definition of the Y-combinator,</p>

<p>

<math display="block" id="Lambda_lifting:284">
 <semantics>
  <mrow>
   <mrow>
    <mo>let</mo>
    <mrow>
     <mpadded width="+5pt">
      <mi>p</mi>
     </mpadded>
     <mpadded width="+5pt">
      <mi>f</mi>
     </mpadded>
     <mi>x</mi>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mpadded width="+5pt">
     <mi>f</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>x</mi>
      </mpadded>
      <mi>x</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi mathvariant="italic">and</mi>
    <mpadded width="+5pt">
     <mi>q</mi>
    </mpadded>
    <mpadded width="+5pt">
     <mi>p</mi>
    </mpadded>
    <mi>f</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>p</mi>
      </mpadded>
      <mi>f</mi>
     </mrow>
     <mo rspace="7.5pt" stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>p</mi>
      </mpadded>
      <mi>f</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo>in</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>q</mi>
      </mpadded>
      <mi>p</mi>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <ci>let</ci>
      <apply>
       <times></times>
       <ci>p</ci>
       <ci>f</ci>
       <ci>x</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <apply>
       <times></times>
       <ci>x</ci>
       <ci>x</ci>
      </apply>
      <ci>italic- and</ci>
      <ci>q</ci>
      <ci>p</ci>
      <ci>f</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <times></times>
       <ci>p</ci>
       <ci>f</ci>
      </apply>
      <apply>
       <times></times>
       <ci>p</ci>
       <ci>f</ci>
      </apply>
      <apply>
       <ci>in</ci>
       <apply>
        <times></times>
        <ci>q</ci>
        <ci>p</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{let}p\ f\ x=f\ (x\ x)\and q\ p\ f=(p\ f)\ (p\ f)\operatorname{in%
}q\ p
  </annotation>
 </semantics>
</math>

</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>Transformation</p></th>
<th style="text-align: left;">
<p>Expression</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Lambda_lifting:285">
 <semantics>
  <mrow>
   <mrow>
    <mo>let</mo>
    <mrow>
     <mpadded width="+5pt">
      <mi>p</mi>
     </mpadded>
     <mpadded width="+5pt">
      <mi>f</mi>
     </mpadded>
     <mi>x</mi>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mpadded width="+5pt">
     <mi>f</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>x</mi>
      </mpadded>
      <mi>x</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi mathvariant="italic">and</mi>
    <mpadded width="+5pt">
     <mi>q</mi>
    </mpadded>
    <mpadded width="+5pt">
     <mi>p</mi>
    </mpadded>
    <mi>f</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>p</mi>
      </mpadded>
      <mi>f</mi>
     </mrow>
     <mo rspace="7.5pt" stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>p</mi>
      </mpadded>
      <mi>f</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo>in</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>q</mi>
      </mpadded>
      <mi>p</mi>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <ci>let</ci>
      <apply>
       <times></times>
       <ci>p</ci>
       <ci>f</ci>
       <ci>x</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <apply>
       <times></times>
       <ci>x</ci>
       <ci>x</ci>
      </apply>
      <ci>italic- and</ci>
      <ci>q</ci>
      <ci>p</ci>
      <ci>f</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <times></times>
       <ci>p</ci>
       <ci>f</ci>
      </apply>
      <apply>
       <times></times>
       <ci>p</ci>
       <ci>f</ci>
      </apply>
      <apply>
       <ci>in</ci>
       <apply>
        <times></times>
        <ci>q</ci>
        <ci>p</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{let}p\ f\ x=f\ (x\ x)\and q\ p\ f=(p\ f)\ (p\ f)\operatorname{in%
}q\ p
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><em>abstract</em> * 4</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Lambda_lifting:286">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>let</mo>
     <mi>p</mi>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>λ</mi>
     <mi>f</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>λ</mi>
    <mi>x</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mrow>
     <mpadded width="+5pt">
      <mi>f</mi>
     </mpadded>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mpadded width="+5pt">
        <mi>x</mi>
       </mpadded>
       <mi>x</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi mathvariant="italic">and</mi>
     <mi>q</mi>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>λ</mi>
     <mi>p</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>λ</mi>
    <mi>f</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>p</mi>
      </mpadded>
      <mi>f</mi>
     </mrow>
     <mo rspace="7.5pt" stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>p</mi>
      </mpadded>
      <mi>f</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo>in</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>q</mi>
      </mpadded>
      <mi>p</mi>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <ci>let</ci>
      <ci>p</ci>
     </apply>
     <apply>
      <times></times>
      <ci>λ</ci>
      <ci>f</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>f</ci>
      <apply>
       <times></times>
       <ci>x</ci>
       <ci>x</ci>
      </apply>
      <ci>italic- and</ci>
      <ci>q</ci>
     </apply>
     <apply>
      <times></times>
      <ci>λ</ci>
      <ci>p</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>f</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <times></times>
      <ci>p</ci>
      <ci>f</ci>
     </apply>
     <apply>
      <times></times>
      <ci>p</ci>
      <ci>f</ci>
     </apply>
     <apply>
      <ci>in</ci>
      <apply>
       <times></times>
       <ci>q</ci>
       <ci>p</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{let}p=\lambda f.\lambda x.f\ (x\ x)\and q=\lambda p.\lambda f.(p%
\ f)\ (p\ f)\operatorname{in}q\ p
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><em>lambda-abstract-tran</em></p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Lambda_lifting:287">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>q</mi>
    <mo>.</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mi>p</mi>
     <mo>.</mo>
     <mpadded width="+5pt">
      <mi>q</mi>
     </mpadded>
     <mi>p</mi>
     <mo rspace="7.5pt" stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mi>f</mi>
     <mo>.</mo>
     <mi>λ</mi>
     <mi>x</mi>
     <mo>.</mo>
     <mpadded width="+5pt">
      <mi>f</mi>
     </mpadded>
     <mrow>
      <mo stretchy="false">(</mo>
      <mpadded width="+5pt">
       <mi>x</mi>
      </mpadded>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo rspace="7.5pt" stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>p</mi>
    <mo>.</mo>
    <mi>λ</mi>
    <mi>f</mi>
    <mo>.</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mpadded width="+5pt">
      <mi>p</mi>
     </mpadded>
     <mi>f</mi>
     <mo rspace="7.5pt" stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mpadded width="+5pt">
      <mi>p</mi>
     </mpadded>
     <mi>f</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">q</csymbol>
     <ci>normal-.</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">p</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">q</csymbol>
      <csymbol cd="unknown">p</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">f</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">f</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">x</csymbol>
       <csymbol cd="unknown">x</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">p</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">f</csymbol>
     <ci>normal-.</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">p</csymbol>
      <csymbol cd="unknown">f</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">p</csymbol>
      <csymbol cd="unknown">f</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\lambda q.(\lambda p.q\ p)\ (\lambda f.\lambda x.f\ (x\ x)))\ (\lambda p.%
\lambda f.(p\ f)\ (p\ f))
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><em>sink-tran</em></p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Lambda_lifting:288">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>p</mi>
    <mo>.</mo>
    <mi>λ</mi>
    <mi>f</mi>
    <mo>.</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mpadded width="+5pt">
      <mi>p</mi>
     </mpadded>
     <mi>f</mi>
     <mo rspace="7.5pt" stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mpadded width="+5pt">
      <mi>p</mi>
     </mpadded>
     <mi>f</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo rspace="7.5pt" stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>f</mi>
    <mo>.</mo>
    <mi>λ</mi>
    <mi>x</mi>
    <mo>.</mo>
    <mpadded width="+5pt">
     <mi>f</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mpadded width="+5pt">
      <mi>x</mi>
     </mpadded>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">p</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">f</csymbol>
     <ci>normal-.</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">p</csymbol>
      <csymbol cd="unknown">f</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">p</csymbol>
      <csymbol cd="unknown">f</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">f</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">f</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\lambda p.\lambda f.(p\ f)\ (p\ f))\ (\lambda f.\lambda x.f\ (x\ x))
  </annotation>
 </semantics>
</math>


</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><em>sink-tran</em></p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Lambda_lifting:289">
 <semantics>
  <mrow>
   <mi>λ</mi>
   <mi>f</mi>
   <mo>.</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>p</mi>
    <mo>.</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mpadded width="+5pt">
      <mi>p</mi>
     </mpadded>
     <mi>f</mi>
     <mo rspace="7.5pt" stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mpadded width="+5pt">
      <mi>p</mi>
     </mpadded>
     <mi>f</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo rspace="7.5pt" stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>f</mi>
    <mo>.</mo>
    <mi>λ</mi>
    <mi>x</mi>
    <mo>.</mo>
    <mpadded width="+5pt">
     <mi>f</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mpadded width="+5pt">
      <mi>x</mi>
     </mpadded>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">f</csymbol>
    <ci>normal-.</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">p</csymbol>
     <ci>normal-.</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">p</csymbol>
      <csymbol cd="unknown">f</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">p</csymbol>
      <csymbol cd="unknown">f</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">f</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">f</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda f.(\lambda p.(p\ f)\ (p\ f))\ (\lambda f.\lambda x.f\ (x\ x))
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><em>drop-param</em></p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Lambda_lifting:290">
 <semantics>
  <mrow>
   <mi>λ</mi>
   <mi>f</mi>
   <mo>.</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>p</mi>
    <mo>.</mo>
    <mpadded width="+5pt">
     <mi>p</mi>
    </mpadded>
    <mi>p</mi>
    <mo rspace="7.5pt" stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>x</mi>
    <mo>.</mo>
    <mpadded width="+5pt">
     <mi>f</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mpadded width="+5pt">
      <mi>x</mi>
     </mpadded>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">f</csymbol>
    <ci>normal-.</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">p</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">p</csymbol>
     <csymbol cd="unknown">p</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">f</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda f.(\lambda p.p\ p)\ (\lambda x.f\ (x\ x))
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><em>beta-redex</em></p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Lambda_lifting:291">
 <semantics>
  <mrow>
   <mi>λ</mi>
   <mi>f</mi>
   <mo>.</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>x</mi>
    <mo>.</mo>
    <mpadded width="+5pt">
     <mi>f</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mpadded width="+5pt">
      <mi>x</mi>
     </mpadded>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo rspace="7.5pt" stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>x</mi>
    <mo>.</mo>
    <mpadded width="+5pt">
     <mi>f</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mpadded width="+5pt">
      <mi>x</mi>
     </mpadded>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">f</csymbol>
    <ci>normal-.</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">f</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">f</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda f.(\lambda x.f\ (x\ x))\ (\lambda x.f\ (x\ x))
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
</tbody>
</table>

<p>Which gives back the <a href="Fixed-point_combinator" title="wikilink">Y combinator</a>,</p>

<p>

<math display="block" id="Lambda_lifting:292">
 <semantics>
  <mrow>
   <mi>λ</mi>
   <mi>f</mi>
   <mo>.</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>x</mi>
    <mo>.</mo>
    <mpadded width="+5pt">
     <mi>f</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mpadded width="+5pt">
      <mi>x</mi>
     </mpadded>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo rspace="7.5pt" stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>x</mi>
    <mo>.</mo>
    <mpadded width="+5pt">
     <mi>f</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mpadded width="+5pt">
      <mi>x</mi>
     </mpadded>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">f</csymbol>
    <ci>normal-.</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">f</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">f</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda f.(\lambda x.f\ (x\ x))\ (\lambda x.f\ (x\ x))
  </annotation>
 </semantics>
</math>

</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Let_expression" title="wikilink">Let expression</a></li>
<li><a href="Fixed-point_combinator" title="wikilink">Fixed-point combinator</a></li>
<li><a href="Lambda_calculus" title="wikilink">Lambda calculus</a></li>
<li><a href="Deductive_lambda_calculus" title="wikilink">Deductive lambda calculus</a></li>
<li><a class="uri" href="Supercombinator" title="wikilink">Supercombinator</a></li>
<li><a href="Curry's_paradox" title="wikilink">Curry's paradox</a></li>
</ul>
<h2 id="references">References</h2>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://stackoverflow.com/questions/592584/what-is-lambda-lifting/592634#592634">Explanation on Stack Overflow, with a JavaScript example</a></li>
<li><a href="http://homepage.cs.uiowa.edu/~slonnegr/plf/Lecture05.pdf">Some discussion of let expressions</a></li>
</ul>

<p>"</p>

<p><a href="Category:Implementation_of_functional_programming_languages" title="wikilink">Category:Implementation of functional programming languages</a> <a href="Category:Lambda_calculus" title="wikilink">Category:Lambda calculus</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
</ol>
</section>
</body>

