<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title offset="823">Word problem (mathematics)</title>
   <script type="text/javascript"
      src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js">
    </script>
</head>
<body>
<h1>Word problem (mathematics)</h1>
<hr/>
<p>In <a class="uri" href="mathematics" title="wikilink">mathematics</a> and <a href="computer_science" title="wikilink">computer science</a>, a <strong>word problem</strong> for a set S with respect to a system of finite encodings of its elements is the <a href="decision_problem" title="wikilink">algorithmic problem of deciding</a> whether two given representatives represent the same element of the set. The problem is commonly encountered in <a href="abstract_algebra" title="wikilink">abstract algebra</a>, where given a presentation of an algebraic structure by <a href="generating_set" title="wikilink">generators</a> and <a href="relator" title="wikilink">relators</a>, the problem is to determine if two expressions represent the same element; a prototypical example is the <a href="word_problem_for_groups" title="wikilink">word problem for groups</a>. Less formally, the word problem in an algebra is: given a set of identities <em>E</em>, and two expressions <em>x</em> and <em>y</em>, is it possible to transform <em>x</em> into <em>y</em> using the identities in <em>E</em> as <a class="uri" href="rewriting" title="wikilink">rewriting</a> rules in both directions? While answering this question may not seem hard, the remarkable (and <a href="deep_result" title="wikilink">deep</a>) result that emerges, in many important cases, is that the <a href="undecidable_problem" title="wikilink">problem is undecidable</a>.</p>
<p>Many, if not most all, undecidable problems in mathematics can be posed as word problems; see the <a href="list_of_undecidable_problems" title="wikilink">list of undecidable problems</a> for many examples.</p>
<h2 id="background-and-motivation">Background and motivation</h2>
<p>Many occasions arise in mathematics where one wishes to use a finite amount of information to describe an element of a (typically infinite) set. This issue is particularly apparent in computational mathematics. Traditional models of computation (such as the <a href="Turing_machine" title="wikilink">Turing machine</a>) have storage capacity which is unbounded, so it is in principle possible to perform computations with the elements of infinite sets. On the other hand, since the amount of storage space in use at any one time is finite, we need each element to have a finite representation.</p>
<p>For various reasons, it is not always possible or desirable to use a system of <em>unique</em> encodings, that is, one in which every element has a single encoding. When using an encoding system without uniqueness, the question naturally arises of whether there is an algorithm which, given as input two encodings, decides whether they represent the same element. Such an algorithm is called a <em>solution to the word problem</em> for the encoding system.</p>
<h2 id="the-word-problem-in-combinatorial-calculus">The word problem in combinatorial calculus</h2>
<p>The simplest example of an undecidable word problem occurs in <a href="combinatory_logic" title="wikilink">combinatory logic</a>: when are two strings of combinators equivalent? Because combinators encode all possible <a href="Turing_machine" title="wikilink">Turing machines</a>, and the equivalence of two Turing machines is undecidable, it follows that the equivalence of two strings of combinators is undecidable.</p>
<p>Likewise, one has essentially the same problem in <a href="lambda_calculus" title="wikilink">lambda calculus</a>: given two distinct lambda expressions, there is no algorithm which can discern whether they are equivalent or not; <a href="Lambda_calculus#Undecidability_of_equivalence" title="wikilink">equivalence is undecidable</a>.</p>
<h2 id="the-word-problem-in-universal-algebra">The word problem in universal algebra</h2>
<p>In <a class="uri" href="algebra" title="wikilink">algebra</a>, one often studies infinite algebras which are generated (under the <a class="uri" href="finitary" title="wikilink">finitary</a> operations of the algebra) by finitely many elements. In this case, the elements of the algebra have a natural system of finite encoding as expressions in terms of the generators and operations. The word problem here is thus to determine, given two such expressions, whether they represent the same element of the algebra.</p>
<p>Roughly speaking, the word problem in an algebra is: given a set <em>E</em> of identities (an <a href="equational_theory" title="wikilink">equational theory</a>), and two <a href="Term_(logic)" title="wikilink">terms</a> <em>s</em> and <em>t</em>, is it possible to transform <em>s</em> into <em>t</em> using the identities in <em>E</em> as <a class="uri" href="rewriting" title="wikilink">rewriting</a> rules in both directions?.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>
<p>A proper extension of the <em>word problem</em> is known as the <em><a href="unification_(computer_science)" title="wikilink">unification problem</a></em> (a.k.a. as <em>equation solving problem</em>). While the former asks whether two terms <em>are</em> equal, the latter asks whether they have <em>instances</em> that are equal. As a common example, "<span class="LaTeX">$2 + 3 \stackrel{?}{=} 8 + (-3)$</span>" is a word problem in the <a href="Integer#Algebraic_properties" title="wikilink">integer group ℤ</a>, while "<span class="LaTeX">$2 + x \stackrel{?}{=} 8 + (-x)$</span>" is a unification problem in the same group; since the former terms happen to be equal in ℤ, the latter problem has the <a href="substitution_(logic)" title="wikilink">substitution</a> <span class="LaTeX">$\{x \mapsto 3\}$</span> as a solution.</p>
<p>Substitutions may be ordered into a <a href="partial_order" title="wikilink">partial order</a>, thus, unification is the act of finding a <a class="uri" href="join" title="wikilink">join</a> on a <a href="lattice_(order)" title="wikilink">lattice</a>.  In this sense, the word problem on a lattice has a solution, namely, the set of all equivalent words is the <a href="free_lattice" title="wikilink">free lattice</a>.</p>
<p>One of the most deeply studied cases of the word problem is in the theory of <a href="semigroup" title="wikilink">semigroups</a> and <a href="group_(mathematics)" title="wikilink">groups</a>. There are <a href="word_problem_for_groups" title="wikilink">many groups for which the word problem</a> is not <a href="Decidability_(logic)" title="wikilink">decidable</a>, in that there is no Turing machine that can determine the equivalence of two <em>arbitrary</em> words in a finite time.</p>
<p>The word problem on <a href="ground_term" title="wikilink">ground terms</a> is not decidable.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> </p>
<p>The word problem on free <a href="Heyting_algebra" title="wikilink">Heyting algebras</a> is difficult.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> The only known results are that the free Heyting algebra on one generator is infinite, and that the free <a href="complete_Heyting_algebra" title="wikilink">complete Heyting algebra</a> on one generator exists (and has one more element than the free Heyting algebra).</p>
<h2 id="example-a-term-rewriting-system-to-decide-the-word-problem-in-the-free-group">Example: A term rewriting system to decide the word problem in the free group</h2>
<p>Bläsius and Bürckert <a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> demonstrate the <a href="Knuth–Bendix_algorithm" title="wikilink">Knuth–Bendix algorithm</a> on an axiom set for groups. The algorithm yields a <a href="Confluence_(abstract_rewriting)" title="wikilink">confluent</a> and <a href="Abstract_rewriting_system#Termination_and_convergence" title="wikilink">noetherian</a> <a href="rewrite_system#Term_rewriting_systems" title="wikilink">term rewrite system</a> that transforms every term into a unique <a href="Normal_form_(abstract_rewriting)" title="wikilink">normal form</a>.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> The rewrite rules are numbered incontiguous since some rules became redundant and were deleted during the algorithm run. The equality of two terms follows from the axioms if and only if both terms are transformed into literally the same normal form term. For example, the terms</p>
<p><span class="LaTeX">$$((a^{-1} \cdot a) \cdot (b \cdot b^{-1}))^{-1} \stackrel{R2}{\rightsquigarrow} (1 \cdot (b \cdot b^{-1}))^{-1} \stackrel{R13}{\rightsquigarrow} (1 \cdot 1)^{-1} \stackrel{R1}{\rightsquigarrow} 1 ^{-1} \stackrel{R8}{\rightsquigarrow} 1$$</span>, and</p>
<p><span class="LaTeX">$$b \cdot ((a \cdot b)^{-1} \cdot a) \stackrel{R17}{\rightsquigarrow} b \cdot ((b^{-1} \cdot a^{-1}) \cdot a) \stackrel{R3}{\rightsquigarrow} b \cdot (b^{-1} \cdot (a^{-1} \cdot a)) \stackrel{R2}{\rightsquigarrow} b \cdot (b^{-1} \cdot 1) \stackrel{R11}{\rightsquigarrow} b \cdot b^{-1} \stackrel{R13}{\rightsquigarrow} 1$$</span> share the same normal form, viz. <span class="LaTeX">$1$</span>; therefor both terms are equal in every group. As another example, the term <span class="LaTeX">$1 \cdot (a \cdot b)$</span> and <span class="LaTeX">$b \cdot (1 \cdot a)$</span> has the normal form <span class="LaTeX">$a \cdot b$</span> and <span class="LaTeX">$b \cdot a$</span>, respectively. Since the normal forms are literally different, the original terms cannot be equal in every group. In fact, they are usually different in <a href="abelian_group" title="wikilink">non-abelian groups</a>.</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p>Group axioms used in Knuth–Bendix completion</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><strong>A1</strong></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><strong>A2</strong></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><strong>A3</strong>    </p></td>
</tr>
</tbody>
</table>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p>Term rewrite system obtained from Knuth–Bendix completion</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><strong>R1</strong></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><strong>R2</strong></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><strong>R3</strong></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><strong>R4</strong></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><strong>R8</strong></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><strong>R11</strong></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><strong>R12</strong></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><strong>R13</strong></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><strong>R14</strong></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><strong>R17</strong>    </p></td>
</tr>
</tbody>
</table>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Munn_tree" title="wikilink">Munn tree</a></li>
<li><a href="Word_problem_for_groups" title="wikilink">Word problem for groups</a></li>
<li><a href="Knuth–Bendix_completion_algorithm" title="wikilink">Knuth–Bendix completion algorithm</a></li>
<li><a href="Unification_(computer_science)" title="wikilink">Unification (computer science)</a></li>
</ul>
<h2 id="references">References</h2>
<p>"</p>
<p><a href="Category:Abstract_algebra" title="wikilink">Category:Abstract algebra</a> <a href="Category:Combinatorics_on_words" title="wikilink">Category:Combinatorics on words</a> <a href="Category:Rewriting_systems" title="wikilink">Category:Rewriting systems</a> <a href="Category:Computational_problems" title="wikilink">Category:Computational problems</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="Franz_Baader" title="wikilink">Franz Baader</a> and <a href="Tobias_Nipkow" title="wikilink">Tobias Nipkow</a>, <em>Term Rewriting and All That</em>, Cambridge University Press, 1998, p. 5<a href="#fnref1">↩</a></li>
<li id="fn2">Yuri Matijasevich, (1967) "Simple examples of undecidable associative calculi", <em>Soviet Mathematics Doklady</em> <strong>8</strong>(2) pp 555–557.<a href="#fnref2">↩</a></li>
<li id="fn3">Peter T. Johnstone, <em>Stone Spaces</em>, (1982) Cambridge University Press, Cambridge, ISBN 0-521-23893-5. <em>(See chapter 1, paragraph 4.11)</em><a href="#fnref3">↩</a></li>
<li id="fn4">; here: p.126, 134<a href="#fnref4">↩</a></li>
<li id="fn5">Apply rules in any order to a term, as long as possible; the result doesn't depend on the order; it is the term's normal form.<a href="#fnref5">↩</a></li>
</ol>
</section>
</body>
</html>
