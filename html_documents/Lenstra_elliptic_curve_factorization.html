<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="453">Lenstra elliptic curve factorization</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Lenstra elliptic curve factorization</h1>
<hr/>

<p>The <strong>Lenstra elliptic curve factorization</strong> or the <strong>elliptic curve factorization method</strong> (<strong>ECM</strong>) is a fast, sub-<a href="exponential_running_time" title="wikilink">exponential running time</a> algorithm for <a href="integer_factorization" title="wikilink">integer factorization</a> which employs <a href="elliptic_curve" title="wikilink">elliptic curves</a>. For <a href="general_purpose_computer" title="wikilink">general purpose</a> factoring, ECM is the third-fastest known factoring method. The second fastest is the <a href="quadratic_sieve" title="wikilink">multiple polynomial quadratic sieve</a> and the fastest is the <a href="general_number_field_sieve" title="wikilink">general number field sieve</a>. The Lenstra elliptic curve factorization is named after <a href="Hendrik_Lenstra" title="wikilink">Hendrik Lenstra</a>.</p>

<p>Practically speaking, ECM is considered a special purpose factoring algorithm as it is most suitable for finding small factors. , it is still the best algorithm for <a href="divisor" title="wikilink">divisors</a> not greatly exceeding 20 to 25 <a href="decimal" title="wikilink">digits</a> (64 to 83 <a href="binary_digit" title="wikilink">bits</a> or so), as its running time is dominated by the size of the smallest factor <em>p</em> rather than by the size of the number <em>n</em> to be factored. Frequently, ECM is used to remove small factors from a very large integer with many factors; if the remaining integer is still composite, then it has only large factors and is factored using general purpose techniques. The largest factor found using ECM so far has 83 digits and was discovered on 7 September 2013 by R. Propper.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> Increasing the number of curves tested improves the chances of finding a factor, but they are not <a class="uri" href="linear" title="wikilink">linear</a> with the increase in the number of digits.</p>
<h2 id="lenstras-elliptic-curve-factorization">Lenstra's elliptic curve factorization</h2>

<p>The Lenstra elliptic curve factorization method to find a factor of the given natural number 

<math display="inline" id="Lenstra_elliptic_curve_factorization:0">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 works as follows:</p>
<ol>
<li>Pick a random <a href="elliptic_curve" title="wikilink">elliptic curve</a> over 

<math display="inline" id="Lenstra_elliptic_curve_factorization:1">
 <semantics>
  <mrow>
   <mrow>
    <mi>ℤ</mi>
    <mo>/</mo>
    <mi>n</mi>
   </mrow>
   <mi>ℤ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <ci>ℤ</ci>
     <ci>n</ci>
    </apply>
    <ci>ℤ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{Z}/n\mathbb{Z}
  </annotation>
 </semantics>
</math>

, with equation of the form 

<math display="inline" id="Lenstra_elliptic_curve_factorization:2">
 <semantics>
  <mrow>
   <msup>
    <mi>y</mi>
    <mn>2</mn>
   </msup>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msup>
      <mi>x</mi>
      <mn>3</mn>
     </msup>
     <mo>+</mo>
     <mrow>
      <mi>a</mi>
      <mi>x</mi>
     </mrow>
     <mo>+</mo>
     <mi>b</mi>
    </mrow>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mrow>
     <mo lspace="8.1pt" stretchy="false">(</mo>
     <mrow>
      <mo>mod</mo>
      <mi>n</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>y</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <cn type="integer">3</cn>
      </apply>
      <apply>
       <times></times>
       <ci>a</ci>
       <ci>x</ci>
      </apply>
      <ci>b</ci>
     </apply>
     <apply>
      <ci>pmod</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y^{2}=x^{3}+ax+b\;\;(\mathop{{\rm mod}}n)
  </annotation>
 </semantics>
</math>

 together with a non-trivial <a href="Point_(geometry)" title="wikilink">point</a> 

<math display="inline" id="Lenstra_elliptic_curve_factorization:3">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mn>0</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>y</mi>
     <mn>0</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <cn type="integer">0</cn>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(x_{0},y_{0})
  </annotation>
 </semantics>
</math>

 on it.
<dl>
<dd>This can be done by first picking random 

<math display="inline" id="Lenstra_elliptic_curve_factorization:4">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>x</mi>
     <mn>0</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>y</mi>
     <mn>0</mn>
    </msub>
    <mo>,</mo>
    <mi>a</mi>
   </mrow>
   <mo>∈</mo>
   <mrow>
    <mrow>
     <mi>ℤ</mi>
     <mo>/</mo>
     <mi>n</mi>
    </mrow>
    <mi>ℤ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <list>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <cn type="integer">0</cn>
     </apply>
     <ci>a</ci>
    </list>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <ci>ℤ</ci>
      <ci>n</ci>
     </apply>
     <ci>ℤ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{0},y_{0},a\in\mathbb{Z}/n\mathbb{Z}
  </annotation>
 </semantics>
</math>

, and then calculating 

<math display="inline" id="Lenstra_elliptic_curve_factorization:5">
 <semantics>
  <mrow>
   <mi>b</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msubsup>
      <mi>y</mi>
      <mn>0</mn>
      <mn>2</mn>
     </msubsup>
     <mo>-</mo>
     <msubsup>
      <mi>x</mi>
      <mn>0</mn>
      <mn>3</mn>
     </msubsup>
     <mo>-</mo>
     <mrow>
      <mi>a</mi>
      <msub>
       <mi>x</mi>
       <mn>0</mn>
      </msub>
     </mrow>
    </mrow>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mrow>
     <mo lspace="8.1pt" stretchy="false">(</mo>
     <mrow>
      <mo>mod</mo>
      <mi>n</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>b</ci>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <cn type="integer">0</cn>
       </apply>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <cn type="integer">0</cn>
       </apply>
       <cn type="integer">3</cn>
      </apply>
      <apply>
       <times></times>
       <ci>a</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <ci>pmod</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b=y_{0}^{2}-x_{0}^{3}-ax_{0}\;\;(\mathop{{\rm mod}}n)
  </annotation>
 </semantics>
</math>

.
</dd>
<dd>
</dd>
</dl></li>
<li>'Addition' of <em>P</em> and <em>Q</em> as points in general defines a group operation <em>P</em> ⊕ <em>Q</em> on the curve whose product can be computed from formulas given in the <a href="elliptic_curve#The_group_law" title="wikilink">article on elliptic curves</a>.
<dl>
<dd>Using this assumption, we can form repeated multiples of a point <em>P</em>: <em>kP</em> = <em>P</em> ⊕ ... ⊕ <em>P</em> (<em>k</em> times). The addition formulas involve the taking the modular slope of a chord joining <em>P</em> and <em>Q</em>, and thus division between residue classes modulo <em>n</em>, performed using the <a href="extended_Euclidean_algorithm" title="wikilink">extended Euclidean algorithm</a>. In particular, division by some <em>v</em> (mod <em>n</em>) includes calculation of the <a href="greatest_common_divisor" title="wikilink">greatest common divisor</a> gcd(<em>v</em>, <em>n</em>).
</dd>
<dd>If the slope is of the form <em>u</em>/<em>v</em> with gcd(<em>u</em>, <em>n</em>) = 1, then <em>v</em> = 0 (mod <em>n</em>) means that the result of the ⊕-addition will be 

<math display="inline" id="Lenstra_elliptic_curve_factorization:6">
 <semantics>
  <mi mathvariant="normal">∞</mi>
  <annotation-xml encoding="MathML-Content">
   <infinity></infinity>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \infty
  </annotation>
 </semantics>
</math>

, the point 'at infinity' corresponding to the intersection of the 'vertical' line joining <em>P</em> (<em>x</em>, <em>y</em>), <em>P</em>' (<em>x</em>, −<em>y</em>) and the curve. However, if gcd(<em>v</em>, <em>n</em>) is neither 1 nor <em>n</em>, then the ⊕-addition will not produce a meaningful point on the curve, which shows that our elliptic curve is not a group (mod <em>n</em>), but, more importantly for now, gcd(<em>v</em>, <em>n</em>) is a non-trivial factor of <em>n</em>.
</dd>
<dd>
</dd>
</dl></li>
<li>Compute <em>eP</em> on the elliptic curve (mod <em>n</em>), where <em>e</em> is product of many small numbers: say, a product of small primes raised to small powers, as in the <a href="Pollard's_p_−_1_algorithm" title="wikilink"><em>p</em> − 1 algorithm</a>, or the <a class="uri" href="factorial" title="wikilink">factorial</a> <em>B</em>! for some not too large <em>B</em>. This can be done efficiently, one small factor at a time. Say, to get <em>B</em>!<em>P</em>, first compute 2<em>P</em>, then 3(2<em>P</em>), then 4(3!<em>P</em>), and so on. Of course, <em>B</em> should be small enough so that <em>B</em>-wise ⊕-addition can be performed in reasonable time.
<dl>
<dd>
</dd>
</dl></li>
<li><ul>
<li>If we were able to finish all the calculations above without encountering non-invertible elements (mod <em>n</em>), then we need to try again with some other curve and starting point.</li>
<li>If at some stage we found <em>kP</em> = ∞ (<em>infinity</em> on the elliptic curve), we should start over with a new curve and starting point, since this point 

<math display="inline" id="Lenstra_elliptic_curve_factorization:7">
 <semantics>
  <mi mathvariant="normal">∞</mi>
  <annotation-xml encoding="MathML-Content">
   <infinity></infinity>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \infty
  </annotation>
 </semantics>
</math>

 is the group identity element, so is unchanged under any further addition operations.</li>
<li>If we encountered a gcd(<em>v</em>, <em>n</em>) at some stage that was neither 1 nor <em>n</em>, then we are done: it is a non-trivial factor of <em>n</em>.</li>
</ul></li>
</ol>

<p>The time complexity depends on the size of the factor and can be represented by exp((√2 + <a href="Big_O_notation#Little-o_notation" title="wikilink">o</a>(1)) √(ln <em>p</em> ln ln <em>p</em>)), where <em>p</em> is the smallest factor of <em>n</em>, or 

<math display="inline" id="Lenstra_elliptic_curve_factorization:8">
 <semantics>
  <mrow>
   <msub>
    <mi>L</mi>
    <mi>p</mi>
   </msub>
   <mrow>
    <mo>[</mo>
    <mfrac>
     <mn>1</mn>
     <mn>2</mn>
    </mfrac>
    <mo>,</mo>
    <msqrt>
     <mn>2</mn>
    </msqrt>
    <mo>]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>L</ci>
     <ci>p</ci>
    </apply>
    <interval closure="closed">
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <root></root>
      <cn type="integer">2</cn>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L_{p}\left[\frac{1}{2},\sqrt{2}\right]
  </annotation>
 </semantics>
</math>

, in <a class="uri" href="L-notation" title="wikilink">L-notation</a>.</p>
<h2 id="why-does-the-algorithm-work">Why does the algorithm work?</h2>

<p>If <em>p</em> and <em>q</em> are two prime divisors of <em>n</em>, then <em>y</em><sup>2</sup> = <em>x</em><sup>3</sup> + <em>ax</em> + <em>b</em> (mod <em>n</em>) implies the same equation also modulo <em>p</em> and modulo <em>q</em>. These two smaller elliptic curves with the 

<math display="inline" id="Lenstra_elliptic_curve_factorization:9">
 <semantics>
  <mo>⊞</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-⊞</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \boxplus
  </annotation>
 </semantics>
</math>

-addition are now genuine <a href="group_(mathematics)" title="wikilink">groups</a>. If these groups have <em>N</em><sub><em>p</em></sub> and <em>N<sub>q</sub></em> elements, respectively, then for any point <em>P</em> on the original curve, by <a href="Lagrange's_theorem_(group_theory)" title="wikilink">Lagrange's theorem</a>, <em>k</em> &gt; 0 is minimal such that 

<math display="inline" id="Lenstra_elliptic_curve_factorization:10">
 <semantics>
  <mrow>
   <mrow>
    <mi>k</mi>
    <mi>P</mi>
   </mrow>
   <mo>=</mo>
   <mi mathvariant="normal">∞</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>k</ci>
     <ci>P</ci>
    </apply>
    <infinity></infinity>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   kP=\infty
  </annotation>
 </semantics>
</math>

 on the curve modulo <em>p</em> implies that <em>k</em> divides <em>N</em><sub><em>p</em></sub>; moreover, 

<math display="inline" id="Lenstra_elliptic_curve_factorization:11">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>N</mi>
     <mi>p</mi>
    </msub>
    <mi>P</mi>
   </mrow>
   <mo>=</mo>
   <mi mathvariant="normal">∞</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>N</ci>
      <ci>p</ci>
     </apply>
     <ci>P</ci>
    </apply>
    <infinity></infinity>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N_{p}P=\infty
  </annotation>
 </semantics>
</math>

. The analogous statement holds for the curve modulo <em>q</em>. When the elliptic curve is chosen randomly, then <em>N</em><sub><em>p</em></sub> and <em>N</em><sub><em>q</em></sub> are random numbers close to <em>p</em> + 1 and <em>q</em> + 1, respectively (see below). Hence it is unlikely that most of the prime factors of <em>N</em><sub><em>p</em></sub> and <em>N</em><sub><em>q</em></sub> are the same, and it is quite likely that while computing <em>eP</em>, we will encounter some <em>kP</em> that is ∞ modulo <em>p</em> but not modulo <em>q</em>, or vice versa. When this is the case, <em>kP</em> does not exist on the original curve, and in the computations we found some <em>v</em> with either gcd(<em>v</em>,<em>p</em>) = <em>p</em> or gcd(<em>v</em>, <em>q</em>) = <em>q</em>, but not both. That is, gcd(<em>v</em>, <em>n</em>) gave a non-trivial factor of <em>n</em>.</p>

<p>ECM is at its core an improvement of the older <a href="Pollard's_p_−_1_algorithm" title="wikilink"><em>p</em> − 1 algorithm</a>. The <em>p</em> − 1 algorithm finds prime factors <em>p</em> such that <em>p</em> − 1 is <a href="smooth_number" title="wikilink">b-powersmooth</a> for small values of <em>b</em>. For any <em>e</em>, a multiple of <em>p</em> − 1, and any <em>a</em> <a href="relatively_prime" title="wikilink">relatively prime</a> to <em>p</em>, by <a href="Fermat's_little_theorem" title="wikilink">Fermat's little theorem</a> we have <em>a</em><sup><em>e</em></sup> ≡ <em>1</em> (<a href="modular_arithmetic" title="wikilink">mod</a> <em>p</em>). Then <a href="greatest_common_divisor" title="wikilink">gcd</a>(<em>a</em><sup><em>e</em></sup> − 1, <em>n</em>) is likely to produce a factor of <em>n</em>. However, the algorithm fails when <em>p</em> - 1 has large prime factors, as is the case for numbers containing <a href="strong_prime" title="wikilink">strong primes</a>, for example.</p>

<p>ECM gets around this obstacle by considering the <a href="group_(mathematics)" title="wikilink">group</a> of a random <a href="elliptic_curve" title="wikilink">elliptic curve</a> over the <a href="finite_field" title="wikilink">finite field</a> <strong>Z</strong><sub><em>p</em></sub>, rather than considering the <a href="multiplicative_group" title="wikilink">multiplicative group</a> of <strong>Z</strong><sub><em>p</em></sub> which always has order <em>p</em> − 1.</p>

<p>The order of the group of an elliptic curve over <strong>Z</strong><sub><em>p</em></sub> varies (quite randomly) between <em>p</em> + 1 − 2√<em>p</em> and <em>p</em> + 1 + 2√<em>p</em> by <a href="Hasse's_theorem_on_elliptic_curves" title="wikilink">Hasse's theorem</a>, and is likely to be smooth for some elliptic curves. Although there is no proof that a smooth group order will be found in the Hasse-interval, by using <a class="uri" href="heuristic" title="wikilink">heuristic</a> probabilistic methods, the <a href="Canfield–Erdős–Pomerance_theorem" title="wikilink">Canfield–Erdős–Pomerance theorem</a> with suitably optimized parameter choices, and the <a class="uri" href="L-notation" title="wikilink">L-notation</a>, we can expect to try <strong><a href="L-notation" title="wikilink">L</a></strong>[√2/2, √2] curves before getting a smooth group order. This heuristic estimate is very reliable in practice.</p>
<h2 id="an-example">An example</h2>

<p>The following example is from , with some details added.</p>

<p>We want to factor <em>n</em> = 455839. Let's choose the elliptic curve <em>y</em><sup>2</sup> = <em>x</em><sup>3</sup> + 5<em>x</em> – 5, with the point <em>P</em> = (1, 1) on it, and let's try to compute (10!)<em>P</em>.</p>

<p>The slope of the tangent line at some point <em>A</em>=(<em>x</em>, <em>y</em>) is <em>s</em> = (3<em>x</em><sup>2</sup> + 5)/(2<em>y</em>) (mod n). Using <em>s</em> we can compute 2<em>A</em>. If the value of <em>s</em> is of the form <em>a/b</em> where <em>b</em> &gt; 1 and gcd(<em>a</em>,<em>b</em>) = 1, we have to find the <a href="modular_inverse" title="wikilink">modular inverse</a> of <em>b</em>. If it does not exist, gcd(<em>n</em>,<em>b</em>) is a non-trivial factor of <em>n</em>.</p>

<p>First we compute 2<em>P</em>. We have <em>s</em>(<em>P</em>) = <em>s</em>(1,1) = 4, so the coordinates of 2<em>P</em> = (<em>x′</em>, <em>y′</em>) are <mtpl></mtpl> and  = 4(1 – 14) – 1 = –53, all numbers understood (mod <em>n</em>). Just to check that this 2<em>P</em> is indeed on the curve: (–53)<sup>2</sup> = 2809 = 14<sup>3</sup> + 5·14 – 5.</p>

<p>Then we compute 3(2<em>P</em>). We have <em>s</em>(2<em>P</em>) = <em>s</em>(14,-53) = –593/106 (mod <em>n</em>). Using the <a href="Euclidean_algorithm" title="wikilink">Euclidean algorithm</a>: 455839 = 4300·106 + 39, then 106 = 2·39 + 28, then 39 = 28 + 11, then 28 = 2·11 + 6, then 11 = 6 + 5, then 6 = 5 + 1. Hence gcd(455839, 106) = 1, and working backwards (a version of the <a href="extended_Euclidean_algorithm" title="wikilink">extended Euclidean algorithm</a>): 1 = 6 – 5 = 2·6 – 11 = 2·28 – 5·11 = 7·28 – 5·39 = 7·106 – 19·39 = 81707·106 – 19·455839. Hence 106<sup>−1</sup> = 81707 (mod 455839), and –593/106 = –133317 (mod 455839). Given this <em>s</em>, we can compute the coordinates of 2(2<em>P</em>), just as we did above: 4<em>P</em> = (259851, 116255). Just to check that this is indeed a point on the curve: <em>y</em><sup>2</sup> = 54514 = <em>x</em><sup>3</sup> + 5<em>x</em> – 5 (mod 455839). After this, we can compute 

<math display="inline" id="Lenstra_elliptic_curve_factorization:12">
 <semantics>
  <mrow>
   <mrow>
    <mn>3</mn>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mn>2</mn>
      <mi>P</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mn>4</mn>
     <mi>P</mi>
    </mrow>
    <mo>⊞</mo>
    <mrow>
     <mn>2</mn>
     <mi>P</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <cn type="integer">3</cn>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <ci>P</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-⊞</ci>
     <apply>
      <times></times>
      <cn type="integer">4</cn>
      <ci>P</ci>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <ci>P</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   3(2P)=4P\boxplus 2P
  </annotation>
 </semantics>
</math>

.</p>

<p>We can similarly compute 4!<em>P</em>, and so on, but 8!<em>P</em> requires inverting 599 (mod 455839). The Euclidean algorithm gives that 455839 is divisible by 599, and we have found a factorization 455839 = 599·761.</p>

<p>The reason that this worked is that the curve (mod 599) has 640 = 2<sup>7</sup>·5 points, while (mod 761) it has 777 = 3·7·37 points. Moreover, 640 and 777 are the smallest positive integers <em>k</em> such that <em>kP</em> = ∞ on the curve (mod 599) and (mod 761), respectively. Since 8! is a multiple of 640 but not a multiple of 777, we have 8!<em>P</em> = ∞ on the curve (mod 599), but not on the curve (mod 761), hence the repeated addition broke down here, yielding the factorization.</p>
<h2 id="the-algorithm-with-projective-coordinates">The algorithm with projective coordinates</h2>

<p>Before considering the projective plane over 

<math display="inline" id="Lenstra_elliptic_curve_factorization:13">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mrow>
     <mi>ℤ</mi>
     <mo>/</mo>
     <mi>n</mi>
    </mrow>
    <mi>ℤ</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <ci>ℤ</ci>
     <ci>n</ci>
    </apply>
    <ci>ℤ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\mathbb{Z}/n\mathbb{Z})
  </annotation>
 </semantics>
</math>

/~, first consider a 'normal' <a href="projective_space" title="wikilink">projective space</a> over ℝ: Instead of points, lines through the origin are studied. A line may be represented as a non-zero point 

<math display="inline" id="Lenstra_elliptic_curve_factorization:14">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>x</mi>
   <mo>,</mo>
   <mi>y</mi>
   <mo>,</mo>
   <mi>z</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <ci>x</ci>
    <ci>y</ci>
    <ci>z</ci>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x,y,z)
  </annotation>
 </semantics>
</math>

, under an equivalence relation ~ given by

<math display="block" id="Lenstra_elliptic_curve_factorization:15">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>x</mi>
   <mo>,</mo>
   <mi>y</mi>
   <mo>,</mo>
   <mi>z</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <ci>x</ci>
    <ci>y</ci>
    <ci>z</ci>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x,y,z)
  </annotation>
 </semantics>
</math>

~

<math display="inline" id="Lenstra_elliptic_curve_factorization:16">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msup>
    <mi>x</mi>
    <mo>′</mo>
   </msup>
   <mo>,</mo>
   <msup>
    <mi>y</mi>
    <mo>′</mo>
   </msup>
   <mo>,</mo>
   <msup>
    <mi>z</mi>
    <mo>′</mo>
   </msup>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <ci>normal-′</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>y</ci>
     <ci>normal-′</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>z</ci>
     <ci>normal-′</ci>
    </apply>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x^{\prime},y^{\prime},z^{\prime})
  </annotation>
 </semantics>
</math>

 ⇔ ∃ <strong><em>c</em></strong> ≠ 0 such that <em>x' = <strong>c</strong>x</em>, <em>y' = <strong>c</strong>y</em> and <em>z' = <strong>c</strong>z</em>. Under this equivalence relation, the space is called <strong>the projective plane</strong> 

<math display="inline" id="Lenstra_elliptic_curve_factorization:17">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msup>
    <mi>P</mi>
    <mn>2</mn>
   </msup>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>P</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (P^{2})
  </annotation>
 </semantics>
</math>

; points, denoted by 

<math display="inline" id="Lenstra_elliptic_curve_factorization:18">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi>x</mi>
    <mo>:</mo>
    <mi>y</mi>
    <mo>:</mo>
    <mi>z</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-:</ci>
     <ci>x</ci>
     <ci>y</ci>
    </apply>
    <apply>
     <ci>normal-:</ci>
     <share href="#.cmml">
     </share>
     <ci>z</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x:y:z)
  </annotation>
 </semantics>
</math>

, correspond to lines in a three-dimensional space that pass through the origin. Note that the point 

<math display="inline" id="Lenstra_elliptic_curve_factorization:19">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mn>0</mn>
    <mo>:</mo>
    <mn>0</mn>
    <mo>:</mo>
    <mn>0</mn>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-:</ci>
     <cn type="integer">0</cn>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <ci>normal-:</ci>
     <share href="#.cmml">
     </share>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (0:0:0)
  </annotation>
 </semantics>
</math>

 does not exist in this space since to draw a line in any possible direction requires at least one of x',y' or z' ≠ 0. Now observe that almost all lines go through any given reference plane - such as the (<em>X,Y</em>,1)-plane, whilst the lines precisely parallel to this plane, having coordinates (<em>X,Y</em>,0), specify directions uniquely, as 'points at infinity' that are used in the affine (<em>X,Y</em>)-plane it lies above.</p>

<p>In the algorithm, only the group structure of an elliptic curve over the field ℝ is used. Since we do not necessarily need the field ℝ, a finite field will also provide a group structure on an elliptic curve. However, considering the same curve and operation over 

<math display="inline" id="Lenstra_elliptic_curve_factorization:20">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mrow>
     <mi>ℤ</mi>
     <mo>/</mo>
     <mi>n</mi>
    </mrow>
    <mi>ℤ</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <ci>ℤ</ci>
     <ci>n</ci>
    </apply>
    <ci>ℤ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\mathbb{Z}/n\mathbb{Z})
  </annotation>
 </semantics>
</math>

/~ with 

<math display="inline" id="Lenstra_elliptic_curve_factorization:21">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 not a prime does not give a group. The Elliptic Curve Method makes use of the failure cases of the addition law.</p>

<p>We now state the algorithm in projective coordinates. The neutral element is then given by the point at infinity 

<math display="inline" id="Lenstra_elliptic_curve_factorization:22">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mn>0</mn>
    <mo>:</mo>
    <mn>1</mn>
    <mo>:</mo>
    <mn>0</mn>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-:</ci>
     <cn type="integer">0</cn>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <ci>normal-:</ci>
     <share href="#.cmml">
     </share>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (0:1:0)
  </annotation>
 </semantics>
</math>

. Let 

<math display="inline" id="Lenstra_elliptic_curve_factorization:23">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 be a (positive) integer and consider the elliptic curve (a set of points with some structure on it) 

<math display="inline" id="Lenstra_elliptic_curve_factorization:24">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>Z</mi>
    <mo>/</mo>
    <mi>n</mi>
    <mi>Z</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>:</mo>
     <mi>y</mi>
     <mo>:</mo>
     <mi>z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∈</mo>
    <mpadded width="+5pt">
     <msup>
      <mi>P</mi>
      <mn>2</mn>
     </msup>
    </mpadded>
    <mo rspace="7.5pt" stretchy="false">|</mo>
    <msup>
     <mi>y</mi>
     <mn>2</mn>
    </msup>
    <mi>z</mi>
    <mo>=</mo>
    <msup>
     <mi>x</mi>
     <mn>3</mn>
    </msup>
    <mo>+</mo>
    <mi>a</mi>
    <mi>x</mi>
    <msup>
     <mi>z</mi>
     <mn>2</mn>
    </msup>
    <mo>+</mo>
    <mi>b</mi>
    <msup>
     <mi>z</mi>
     <mn>3</mn>
    </msup>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">E</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">Z</csymbol>
     <divide></divide>
     <csymbol cd="unknown">n</csymbol>
     <csymbol cd="unknown">Z</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-{</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-:</ci>
      <csymbol cd="unknown">y</csymbol>
      <ci>normal-:</ci>
      <csymbol cd="unknown">z</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <in></in>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>P</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-|</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>y</ci>
      <cn type="integer">2</cn>
     </apply>
     <csymbol cd="unknown">z</csymbol>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <cn type="integer">3</cn>
     </apply>
     <plus></plus>
     <csymbol cd="unknown">a</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>z</ci>
      <cn type="integer">2</cn>
     </apply>
     <plus></plus>
     <csymbol cd="unknown">b</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>z</ci>
      <cn type="integer">3</cn>
     </apply>
     <ci>normal-}</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E(Z/nZ)=\{(x:y:z)\in P^{2}\ |\ y^{2}z=x^{3}+axz^{2}+bz^{3}\}
  </annotation>
 </semantics>
</math>

.</p>
<ol>
<li>Pick 

<math display="inline" id="Lenstra_elliptic_curve_factorization:25">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mi>P</mi>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>y</mi>
    <mi>P</mi>
   </msub>
   <mo>,</mo>
   <mi>a</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>P</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <ci>P</ci>
    </apply>
    <ci>a</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{P},y_{P},a
  </annotation>
 </semantics>
</math>

 in 

<math display="inline" id="Lenstra_elliptic_curve_factorization:26">
 <semantics>
  <mrow>
   <mrow>
    <mi>ℤ</mi>
    <mo>/</mo>
    <mi>n</mi>
   </mrow>
   <mi>ℤ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <ci>ℤ</ci>
     <ci>n</ci>
    </apply>
    <ci>ℤ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{Z}/n\mathbb{Z}
  </annotation>
 </semantics>
</math>

 (

<math display="inline" id="Lenstra_elliptic_curve_factorization:27">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 ≠ 0).</li>
<li>Calculate 

<math display="inline" id="Lenstra_elliptic_curve_factorization:28">
 <semantics>
  <mrow>
   <mi>b</mi>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mi>y</mi>
     <mi>P</mi>
     <mn>2</mn>
    </msubsup>
    <mo>-</mo>
    <msubsup>
     <mi>x</mi>
     <mi>P</mi>
     <mn>3</mn>
    </msubsup>
    <mo>-</mo>
    <mrow>
     <mi>a</mi>
     <msub>
      <mi>x</mi>
      <mi>P</mi>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>b</ci>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <ci>P</ci>
      </apply>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>P</ci>
      </apply>
      <cn type="integer">3</cn>
     </apply>
     <apply>
      <times></times>
      <ci>a</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>P</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b=y_{P}^{2}-x_{P}^{3}-ax_{P}
  </annotation>
 </semantics>
</math>

. The elliptic curve 

<math display="inline" id="Lenstra_elliptic_curve_factorization:29">
 <semantics>
  <mi>E</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>E</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E
  </annotation>
 </semantics>
</math>

 is then in Weierstrass form given by 

<math display="inline" id="Lenstra_elliptic_curve_factorization:30">
 <semantics>
  <mrow>
   <msup>
    <mi>y</mi>
    <mn>2</mn>
   </msup>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>x</mi>
     <mn>3</mn>
    </msup>
    <mo>+</mo>
    <mrow>
     <mi>a</mi>
     <mi>x</mi>
    </mrow>
    <mo>+</mo>
    <mi>b</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>y</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <cn type="integer">3</cn>
     </apply>
     <apply>
      <times></times>
      <ci>a</ci>
      <ci>x</ci>
     </apply>
     <ci>b</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y^{2}=x^{3}+ax+b
  </annotation>
 </semantics>
</math>

 and by using projective coordinates the elliptic curve is given by the homogeneous equation 

<math display="inline" id="Lenstra_elliptic_curve_factorization:31">
 <semantics>
  <mrow>
   <mrow>
    <mi>Z</mi>
    <msup>
     <mi>Y</mi>
     <mn>2</mn>
    </msup>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>X</mi>
     <mn>3</mn>
    </msup>
    <mo>+</mo>
    <mrow>
     <mi>a</mi>
     <msup>
      <mi>Z</mi>
      <mn>2</mn>
     </msup>
     <mi>X</mi>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>b</mi>
     <msup>
      <mi>Z</mi>
      <mn>3</mn>
     </msup>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>Z</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>Y</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>X</ci>
      <cn type="integer">3</cn>
     </apply>
     <apply>
      <times></times>
      <ci>a</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>Z</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>X</ci>
     </apply>
     <apply>
      <times></times>
      <ci>b</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>Z</ci>
       <cn type="integer">3</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ZY^{2}=X^{3}+aZ^{2}X+bZ^{3}
  </annotation>
 </semantics>
</math>

. It has the point 

<math display="inline" id="Lenstra_elliptic_curve_factorization:32">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mi>P</mi>
    </msub>
    <mo>:</mo>
    <msub>
     <mi>y</mi>
     <mi>P</mi>
    </msub>
    <mo>:</mo>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>P</ci>
     </apply>
     <ci>normal-:</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <ci>P</ci>
     </apply>
     <ci>normal-:</ci>
     <cn type="integer">1</cn>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P=(x_{P}:y_{P}:1)
  </annotation>
 </semantics>
</math>

.</li>
<li>Choose an upperbound 

<math display="inline" id="Lenstra_elliptic_curve_factorization:33">
 <semantics>
  <mrow>
   <mi>B</mi>
   <mo>∈</mo>
   <mi>ℤ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>B</ci>
    <ci>ℤ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B\in\mathbb{Z}
  </annotation>
 </semantics>
</math>

 for this elliptic curve. Remark: You will only find factors 

<math display="inline" id="Lenstra_elliptic_curve_factorization:34">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 if the group order of the elliptic curve 

<math display="inline" id="Lenstra_elliptic_curve_factorization:35">
 <semantics>
  <mi>E</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>E</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E
  </annotation>
 </semantics>
</math>

 over 

<math display="inline" id="Lenstra_elliptic_curve_factorization:36">
 <semantics>
  <mrow>
   <mrow>
    <mi>ℤ</mi>
    <mo>/</mo>
    <mi>p</mi>
   </mrow>
   <mi>ℤ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <ci>ℤ</ci>
     <ci>p</ci>
    </apply>
    <ci>ℤ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{Z}/p\mathbb{Z}
  </annotation>
 </semantics>
</math>

 (denoted by #

<math display="inline" id="Lenstra_elliptic_curve_factorization:37">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mrow>
      <mi>ℤ</mi>
      <mo>/</mo>
      <mi>p</mi>
     </mrow>
     <mi>ℤ</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>E</ci>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <ci>ℤ</ci>
      <ci>p</ci>
     </apply>
     <ci>ℤ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E(\mathbb{Z}/p\mathbb{Z})
  </annotation>
 </semantics>
</math>

) is <a href="Smooth_number" title="wikilink">B-smooth</a>, which means that all prime factors of #

<math display="inline" id="Lenstra_elliptic_curve_factorization:38">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mrow>
      <mi>ℤ</mi>
      <mo>/</mo>
      <mi>p</mi>
     </mrow>
     <mi>ℤ</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>E</ci>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <ci>ℤ</ci>
      <ci>p</ci>
     </apply>
     <ci>ℤ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E(\mathbb{Z}/p\mathbb{Z})
  </annotation>
 </semantics>
</math>

 have to be less or equal to 

<math display="inline" id="Lenstra_elliptic_curve_factorization:39">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

.</li>
<li>Calculate 

<math display="inline" id="Lenstra_elliptic_curve_factorization:40">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>=</mo>
   <mrow>
    <mi>lcm</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>1</mn>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <mi>B</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>k</ci>
    <apply>
     <times></times>
     <ci>lcm</ci>
     <vector>
      <cn type="integer">1</cn>
      <ci>normal-…</ci>
      <ci>B</ci>
     </vector>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k={\rm lcm}(1,\dots,B)
  </annotation>
 </semantics>
</math>

.</li>
<li>Calculate 

<math display="inline" id="Lenstra_elliptic_curve_factorization:41">
 <semantics>
  <mrow>
   <mrow>
    <mi>k</mi>
    <mi>P</mi>
   </mrow>
   <mo>:=</mo>
   <mrow>
    <mi>P</mi>
    <mo>+</mo>
    <mi>P</mi>
    <mo>+</mo>
    <mi mathvariant="normal">⋯</mi>
    <mo>+</mo>
    <mi>P</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <apply>
     <times></times>
     <ci>k</ci>
     <ci>P</ci>
    </apply>
    <apply>
     <plus></plus>
     <ci>P</ci>
     <ci>P</ci>
     <ci>normal-⋯</ci>
     <ci>P</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   kP:=P+P+\cdots+P
  </annotation>
 </semantics>
</math>

 (k times) in the ring 

<math display="inline" id="Lenstra_elliptic_curve_factorization:42">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mrow>
      <mi>ℤ</mi>
      <mo>/</mo>
      <mi>n</mi>
     </mrow>
     <mi>ℤ</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>E</ci>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <ci>ℤ</ci>
      <ci>n</ci>
     </apply>
     <ci>ℤ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E(\mathbb{Z}/n\mathbb{Z})
  </annotation>
 </semantics>
</math>

. Note that if #

<math display="inline" id="Lenstra_elliptic_curve_factorization:43">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mrow>
      <mi>ℤ</mi>
      <mo>/</mo>
      <mi>n</mi>
     </mrow>
     <mi>ℤ</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>E</ci>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <ci>ℤ</ci>
      <ci>n</ci>
     </apply>
     <ci>ℤ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E(\mathbb{Z}/n\mathbb{Z})
  </annotation>
 </semantics>
</math>

 is 

<math display="inline" id="Lenstra_elliptic_curve_factorization:44">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

-smooth and 

<math display="inline" id="Lenstra_elliptic_curve_factorization:45">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 is prime (and therefore 

<math display="inline" id="Lenstra_elliptic_curve_factorization:46">
 <semantics>
  <mrow>
   <mrow>
    <mi>ℤ</mi>
    <mo>/</mo>
    <mi>n</mi>
   </mrow>
   <mi>ℤ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <ci>ℤ</ci>
     <ci>n</ci>
    </apply>
    <ci>ℤ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{Z}/n\mathbb{Z}
  </annotation>
 </semantics>
</math>

 is a field) that 

<math display="inline" id="Lenstra_elliptic_curve_factorization:47">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mi>P</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>0</mn>
    <mo>:</mo>
    <mn>1</mn>
    <mo>:</mo>
    <mn>0</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">k</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cn type="integer">0</cn>
     <ci>normal-:</ci>
     <cn type="integer">1</cn>
     <ci>normal-:</ci>
     <cn type="integer">0</cn>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   kP=(0:1:0)
  </annotation>
 </semantics>
</math>

. However, if only #

<math display="inline" id="Lenstra_elliptic_curve_factorization:48">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mrow>
      <mi>ℤ</mi>
      <mo>/</mo>
      <mi>p</mi>
     </mrow>
     <mi>ℤ</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>E</ci>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <ci>ℤ</ci>
      <ci>p</ci>
     </apply>
     <ci>ℤ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E(\mathbb{Z}/p\mathbb{Z})
  </annotation>
 </semantics>
</math>

 is B-smooth for some divisor 

<math display="inline" id="Lenstra_elliptic_curve_factorization:49">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 of 

<math display="inline" id="Lenstra_elliptic_curve_factorization:50">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

, the product might not be (0:1:0) because addition and multiplication are not well-defined if 

<math display="inline" id="Lenstra_elliptic_curve_factorization:51">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 is not prime. In this case, a non-trivial divisor can be found.</li>
<li>If not, then go back to step 2. If this does occur, then you will notice this when simplifying the product 

<math display="inline" id="Lenstra_elliptic_curve_factorization:52">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mi>P</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>k</ci>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   kP
  </annotation>
 </semantics>
</math>

.</li>
</ol>

<p>In point 5 it is said that under the right circumstances a non-trivial divisor can be found. As pointed out in Lenstra's article (Factoring Integers with Elliptic Curves) the addition needs the assumption 

<math display="inline" id="Lenstra_elliptic_curve_factorization:53">
 <semantics>
  <mrow>
   <mrow>
    <mi>gcd</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>x</mi>
       <mn>1</mn>
      </msub>
      <mo>-</mo>
      <msub>
       <mi>x</mi>
       <mn>2</mn>
      </msub>
     </mrow>
     <mo>,</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <gcd></gcd>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <ci>n</ci>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gcd(x_{1}-x_{2},n)=1
  </annotation>
 </semantics>
</math>

. If 

<math display="inline" id="Lenstra_elliptic_curve_factorization:54">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mo>,</mo>
   <mi>Q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>P</ci>
    <ci>Q</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P,Q
  </annotation>
 </semantics>
</math>

 are not 

<math display="inline" id="Lenstra_elliptic_curve_factorization:55">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mn>0</mn>
    <mo>:</mo>
    <mn>1</mn>
    <mo>:</mo>
    <mn>0</mn>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-:</ci>
     <cn type="integer">0</cn>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <ci>normal-:</ci>
     <share href="#.cmml">
     </share>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (0:1:0)
  </annotation>
 </semantics>
</math>

 and distinct (otherwise addition works similarly, but is a little different), then addition works as follows:</p>
<ul>
<li>To calculate

<math display="block" id="Lenstra_elliptic_curve_factorization:56">
 <semantics>
  <mrow>
   <mrow>
    <mi>R</mi>
    <mo>=</mo>
    <mrow>
     <mi>P</mi>
     <mo>+</mo>
     <mi>Q</mi>
    </mrow>
   </mrow>
   <mo>;</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>R</ci>
    <apply>
     <plus></plus>
     <ci>P</ci>
     <ci>Q</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R=P+Q;
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Lenstra_elliptic_curve_factorization:57">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
    <mo>:</mo>
    <msub>
     <mi>y</mi>
     <mn>1</mn>
    </msub>
    <mo>:</mo>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-:</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-:</ci>
     <cn type="integer">1</cn>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P=(x_{1}:y_{1}:1)
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Lenstra_elliptic_curve_factorization:58">
 <semantics>
  <mrow>
   <mi>Q</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mn>2</mn>
    </msub>
    <mo>:</mo>
    <msub>
     <mi>y</mi>
     <mn>2</mn>
    </msub>
    <mo>:</mo>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">Q</csymbol>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-:</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-:</ci>
     <cn type="integer">1</cn>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q=(x_{2}:y_{2}:1)
  </annotation>
 </semantics>
</math>

,</li>
<li>

<math display="inline" id="Lenstra_elliptic_curve_factorization:59">
 <semantics>
  <mrow>
   <mi>λ</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>y</mi>
       <mn>1</mn>
      </msub>
      <mo>-</mo>
      <msub>
       <mi>y</mi>
       <mn>2</mn>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>x</mi>
        <mn>1</mn>
       </msub>
       <mo>-</mo>
       <msub>
        <mi>x</mi>
        <mn>2</mn>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>λ</ci>
    <apply>
     <times></times>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda=(y_{1}-y_{2})(x_{1}-x_{2})^{-1}
  </annotation>
 </semantics>
</math>

,</li>
<li>

<math display="inline" id="Lenstra_elliptic_curve_factorization:60">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mn>3</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>λ</mi>
     <mn>2</mn>
    </msup>
    <mo>-</mo>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
    <mo>-</mo>
    <msub>
     <mi>x</mi>
     <mn>2</mn>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">3</cn>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>λ</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{3}=\lambda^{2}-x_{1}-x_{2}
  </annotation>
 </semantics>
</math>

,</li>
<li>

<math display="inline" id="Lenstra_elliptic_curve_factorization:61">
 <semantics>
  <mrow>
   <msub>
    <mi>y</mi>
    <mn>3</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>λ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>x</mi>
        <mn>1</mn>
       </msub>
       <mo>-</mo>
       <msub>
        <mi>x</mi>
        <mn>3</mn>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>-</mo>
    <msub>
     <mi>y</mi>
     <mn>1</mn>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <cn type="integer">3</cn>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>λ</ci>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <cn type="integer">3</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{3}=\lambda(x_{1}-x_{3})-y_{1}
  </annotation>
 </semantics>
</math>

,</li>
<li>

<math display="inline" id="Lenstra_elliptic_curve_factorization:62">
 <semantics>
  <mrow>
   <mi>R</mi>
   <mo>=</mo>
   <mi>P</mi>
   <mo>+</mo>
   <mi>Q</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mn>3</mn>
    </msub>
    <mo>:</mo>
    <msub>
     <mi>y</mi>
     <mn>3</mn>
    </msub>
    <mo>:</mo>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">R</csymbol>
    <eq></eq>
    <csymbol cd="unknown">P</csymbol>
    <plus></plus>
    <csymbol cd="unknown">Q</csymbol>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">3</cn>
     </apply>
     <ci>normal-:</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <cn type="integer">3</cn>
     </apply>
     <ci>normal-:</ci>
     <cn type="integer">1</cn>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R=P+Q=(x_{3}:y_{3}:1)
  </annotation>
 </semantics>
</math>

.</li>
</ul>

<p>If addition fails, this will be due to a failure calculating 

<math display="inline" id="Lenstra_elliptic_curve_factorization:63">
 <semantics>
  <mi>λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda
  </annotation>
 </semantics>
</math>

. In particular, because 

<math display="inline" id="Lenstra_elliptic_curve_factorization:64">
 <semantics>
  <msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo>-</mo>
     <msub>
      <mi>x</mi>
      <mn>2</mn>
     </msub>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x_{1}-x_{2})^{-1}
  </annotation>
 </semantics>
</math>

 can not always be calculated if 

<math display="inline" id="Lenstra_elliptic_curve_factorization:65">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 is not prime (and therefore 

<math display="inline" id="Lenstra_elliptic_curve_factorization:66">
 <semantics>
  <mrow>
   <mrow>
    <mi>ℤ</mi>
    <mo>/</mo>
    <mi>n</mi>
   </mrow>
   <mi>ℤ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <ci>ℤ</ci>
     <ci>n</ci>
    </apply>
    <ci>ℤ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{Z}/n\mathbb{Z}
  </annotation>
 </semantics>
</math>

 is not a field). Without making use of 

<math display="inline" id="Lenstra_elliptic_curve_factorization:67">
 <semantics>
  <mrow>
   <mrow>
    <mi>ℤ</mi>
    <mo>/</mo>
    <mi>n</mi>
   </mrow>
   <mi>ℤ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <ci>ℤ</ci>
     <ci>n</ci>
    </apply>
    <ci>ℤ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{Z}/n\mathbb{Z}
  </annotation>
 </semantics>
</math>

 being a field, one could calculate:</p>
<ul>
<li>

<math display="inline" id="Lenstra_elliptic_curve_factorization:68">
 <semantics>
  <mrow>
   <msup>
    <mi>λ</mi>
    <mo>′</mo>
   </msup>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>y</mi>
     <mn>1</mn>
    </msub>
    <mo>-</mo>
    <msub>
     <mi>y</mi>
     <mn>2</mn>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>λ</ci>
     <ci>normal-′</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda^{\prime}=y_{1}-y_{2}
  </annotation>
 </semantics>
</math>

,</li>
<li>

<math display="inline" id="Lenstra_elliptic_curve_factorization:69">
 <semantics>
  <mrow>
   <msubsup>
    <mi>x</mi>
    <mn>3</mn>
    <mo>′</mo>
   </msubsup>
   <mo>=</mo>
   <mrow>
    <mmultiscripts>
     <mi>λ</mi>
     <none></none>
     <mo>′</mo>
     <none></none>
     <mn>2</mn>
    </mmultiscripts>
    <mo>-</mo>
    <mrow>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <msub>
         <mi>x</mi>
         <mn>1</mn>
        </msub>
        <mo>-</mo>
        <msub>
         <mi>x</mi>
         <mn>2</mn>
        </msub>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mn>2</mn>
     </msup>
    </mrow>
    <mo>-</mo>
    <mrow>
     <msub>
      <mi>x</mi>
      <mn>2</mn>
     </msub>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <msub>
         <mi>x</mi>
         <mn>1</mn>
        </msub>
        <mo>-</mo>
        <msub>
         <mi>x</mi>
         <mn>2</mn>
        </msub>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mn>2</mn>
     </msup>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">3</cn>
     </apply>
     <ci>normal-′</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>λ</ci>
       <ci>normal-′</ci>
      </apply>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <cn type="integer">1</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <cn type="integer">1</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{3}^{\prime}={\lambda^{\prime}}^{2}-x_{1}(x_{1}-x_{2})^{2}-x_{2}(x_{1}-x_{2}%
)^{2}
  </annotation>
 </semantics>
</math>

,</li>
<li>

<math display="inline" id="Lenstra_elliptic_curve_factorization:70">
 <semantics>
  <mrow>
   <msubsup>
    <mi>y</mi>
    <mn>3</mn>
    <mo>′</mo>
   </msubsup>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msup>
      <mi>λ</mi>
      <mo>′</mo>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <msub>
         <mi>x</mi>
         <mn>1</mn>
        </msub>
        <msup>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <msub>
            <mi>x</mi>
            <mn>1</mn>
           </msub>
           <mo>-</mo>
           <msub>
            <mi>x</mi>
            <mn>2</mn>
           </msub>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
         <mn>2</mn>
        </msup>
       </mrow>
       <mo>-</mo>
       <msubsup>
        <mi>x</mi>
        <mn>3</mn>
        <mo>′</mo>
       </msubsup>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <msub>
      <mi>y</mi>
      <mn>1</mn>
     </msub>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <msub>
         <mi>x</mi>
         <mn>1</mn>
        </msub>
        <mo>-</mo>
        <msub>
         <mi>x</mi>
         <mn>2</mn>
        </msub>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mn>3</mn>
     </msup>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <cn type="integer">3</cn>
     </apply>
     <ci>normal-′</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>λ</ci>
       <ci>normal-′</ci>
      </apply>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <cn type="integer">1</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <minus></minus>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>x</ci>
           <cn type="integer">1</cn>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>x</ci>
           <cn type="integer">2</cn>
          </apply>
         </apply>
         <cn type="integer">2</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <cn type="integer">3</cn>
        </apply>
        <ci>normal-′</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <cn type="integer">1</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
       <cn type="integer">3</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{3}^{\prime}=\lambda^{\prime}(x_{1}(x_{1}-x_{2})^{2}-x_{3}^{\prime})-y_{1}(x%
_{1}-x_{2})^{3}
  </annotation>
 </semantics>
</math>

,</li>
<li>

<math display="inline" id="Lenstra_elliptic_curve_factorization:71">
 <semantics>
  <mrow>
   <mi>R</mi>
   <mo>=</mo>
   <mi>P</mi>
   <mo>+</mo>
   <mi>Q</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msubsup>
     <mi>x</mi>
     <mn>3</mn>
     <mo>′</mo>
    </msubsup>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo>-</mo>
     <msub>
      <mi>x</mi>
      <mn>2</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>:</mo>
    <msubsup>
     <mi>y</mi>
     <mn>3</mn>
     <mo>′</mo>
    </msubsup>
    <mo>:</mo>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mn>1</mn>
      </msub>
      <mo>-</mo>
      <msub>
       <mi>x</mi>
       <mn>2</mn>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
     <mn>3</mn>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">R</csymbol>
    <eq></eq>
    <csymbol cd="unknown">P</csymbol>
    <plus></plus>
    <csymbol cd="unknown">Q</csymbol>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">3</cn>
      </apply>
      <ci>normal-′</ci>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-:</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">3</cn>
      </apply>
      <ci>normal-′</ci>
     </apply>
     <ci>normal-:</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <cn type="integer">1</cn>
       </apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <cn type="integer">2</cn>
       </apply>
       <ci>normal-)</ci>
      </cerror>
      <cn type="integer">3</cn>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R=P+Q=(x_{3}^{\prime}(x_{1}-x_{2}):y_{3}^{\prime}:(x_{1}-x_{2})^{3})
  </annotation>
 </semantics>
</math>

, and simplify if possible.</li>
</ul>

<p>This calculation is always legal and if the gcd of the 

<math display="inline" id="Lenstra_elliptic_curve_factorization:72">
 <semantics>
  <mi>Z</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Z</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z
  </annotation>
 </semantics>
</math>

-coordinate with 

<math display="inline" id="Lenstra_elliptic_curve_factorization:73">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 ≠ (1 or 

<math display="inline" id="Lenstra_elliptic_curve_factorization:74">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

), so when simplifying fails, a non-trivial divisor of 

<math display="inline" id="Lenstra_elliptic_curve_factorization:75">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 is found.</p>
<h2 id="twisted-edwards-curves">Twisted Edwards curves</h2>

<p>The use of <a href="Edwards_curve" title="wikilink">Edwards curves</a> needs fewer modular multiplications and less time than the use of <a href="Montgomery_curve" title="wikilink">Montgomery curves</a> or Weierstrass curves (other used methods). Using Edwards curves you can also find more primes.</p>

<p>Definition: Let 

<math display="inline" id="Lenstra_elliptic_curve_factorization:76">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 be a field in which 

<math display="inline" id="Lenstra_elliptic_curve_factorization:77">
 <semantics>
  <mrow>
   <mn>2</mn>
   <mo>≠</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <neq></neq>
    <cn type="integer">2</cn>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2\neq 0
  </annotation>
 </semantics>
</math>

, and let 

<math display="inline" id="Lenstra_elliptic_curve_factorization:78">
 <semantics>
  <mrow>
   <mrow>
    <mi>a</mi>
    <mo>,</mo>
    <mi>d</mi>
   </mrow>
   <mo>∈</mo>
   <mrow>
    <mi>k</mi>
    <mo>∖</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mn>0</mn>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <list>
     <ci>a</ci>
     <ci>d</ci>
    </list>
    <apply>
     <setdiff></setdiff>
     <ci>k</ci>
     <set>
      <cn type="integer">0</cn>
     </set>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a,d\in k\setminus\{0\}
  </annotation>
 </semantics>
</math>

 with 

<math display="inline" id="Lenstra_elliptic_curve_factorization:79">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo>≠</mo>
   <mi>d</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <neq></neq>
    <ci>a</ci>
    <ci>d</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a\neq d
  </annotation>
 </semantics>
</math>

. Then the twisted Edwards curve 

<math display="inline" id="Lenstra_elliptic_curve_factorization:80">
 <semantics>
  <msub>
   <mi>E</mi>
   <mrow>
    <mi>E</mi>
    <mo>,</mo>
    <mi>a</mi>
    <mo>,</mo>
    <mi>d</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>E</ci>
    <list>
     <ci>E</ci>
     <ci>a</ci>
     <ci>d</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E_{E,a,d}
  </annotation>
 </semantics>
</math>

 is given by 

<math display="inline" id="Lenstra_elliptic_curve_factorization:81">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mi>a</mi>
      <msup>
       <mi>x</mi>
       <mn>2</mn>
      </msup>
     </mrow>
     <mo>+</mo>
     <msup>
      <mi>y</mi>
      <mn>2</mn>
     </msup>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mn>1</mn>
     <mo>+</mo>
     <mrow>
      <mi>d</mi>
      <msup>
       <mi>x</mi>
       <mn>2</mn>
      </msup>
      <msup>
       <mi>y</mi>
       <mn>2</mn>
      </msup>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>a</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>y</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <cn type="integer">1</cn>
     <apply>
      <times></times>
      <ci>d</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>y</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ax^{2}+y^{2}=1+dx^{2}y^{2}.
  </annotation>
 </semantics>
</math>

 An Edwards curve is a twisted Edwards curve in which 

<math display="inline" id="Lenstra_elliptic_curve_factorization:82">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>a</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a=1
  </annotation>
 </semantics>
</math>

.</p>

<p>There are five known ways to build a set of point on an Edwards curve: the set of affine points, the set of projective points, the set of inverted points, the set of extended points and the set of completed points.</p>

<p>The set of affine points is given by

<math display="block" id="Lenstra_elliptic_curve_factorization:83">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∈</mo>
    <msup>
     <mi>A</mi>
     <mn>2</mn>
    </msup>
   </mrow>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mrow>
      <mi>a</mi>
      <msup>
       <mi>x</mi>
       <mn>2</mn>
      </msup>
     </mrow>
     <mo>+</mo>
     <msup>
      <mi>y</mi>
      <mn>2</mn>
     </msup>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mn>1</mn>
     <mo>+</mo>
     <mrow>
      <mi>d</mi>
      <msup>
       <mi>x</mi>
       <mn>2</mn>
      </msup>
      <msup>
       <mi>y</mi>
       <mn>2</mn>
      </msup>
     </mrow>
    </mrow>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">conditional-set</csymbol>
    <apply>
     <in></in>
     <interval closure="open">
      <ci>x</ci>
      <ci>y</ci>
     </interval>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>A</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>a</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>x</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>y</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <plus></plus>
      <cn type="integer">1</cn>
      <apply>
       <times></times>
       <ci>d</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>x</ci>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>y</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{(x,y)\in A^{2}:ax^{2}+y^{2}=1+dx^{2}y^{2}\}
  </annotation>
 </semantics>
</math>

.</p>

<p>The addition law is given by 

<math display="inline" id="Lenstra_elliptic_curve_factorization:84">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>e</mi>
     <mo>,</mo>
     <mi>f</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>g</mi>
     <mo>,</mo>
     <mi>h</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>↦</mo>
   <mrow>
    <mo>(</mo>
    <mfrac>
     <mrow>
      <mrow>
       <mi>e</mi>
       <mi>h</mi>
      </mrow>
      <mo>+</mo>
      <mrow>
       <mi>f</mi>
       <mi>g</mi>
      </mrow>
     </mrow>
     <mrow>
      <mn>1</mn>
      <mo>+</mo>
      <mrow>
       <mi>d</mi>
       <mi>e</mi>
       <mi>g</mi>
       <mi>f</mi>
       <mi>h</mi>
      </mrow>
     </mrow>
    </mfrac>
    <mo>,</mo>
    <mfrac>
     <mrow>
      <mrow>
       <mi>f</mi>
       <mi>h</mi>
      </mrow>
      <mo>-</mo>
      <mrow>
       <mi>a</mi>
       <mi>e</mi>
       <mi>g</mi>
      </mrow>
     </mrow>
     <mrow>
      <mn>1</mn>
      <mo>-</mo>
      <mrow>
       <mi>d</mi>
       <mi>e</mi>
       <mi>g</mi>
       <mi>f</mi>
       <mi>h</mi>
      </mrow>
     </mrow>
    </mfrac>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">maps-to</csymbol>
    <list>
     <interval closure="open">
      <ci>e</ci>
      <ci>f</ci>
     </interval>
     <interval closure="open">
      <ci>g</ci>
      <ci>h</ci>
     </interval>
    </list>
    <interval closure="open">
     <apply>
      <divide></divide>
      <apply>
       <plus></plus>
       <apply>
        <times></times>
        <ci>e</ci>
        <ci>h</ci>
       </apply>
       <apply>
        <times></times>
        <ci>f</ci>
        <ci>g</ci>
       </apply>
      </apply>
      <apply>
       <plus></plus>
       <cn type="integer">1</cn>
       <apply>
        <times></times>
        <ci>d</ci>
        <ci>e</ci>
        <ci>g</ci>
        <ci>f</ci>
        <ci>h</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <ci>f</ci>
        <ci>h</ci>
       </apply>
       <apply>
        <times></times>
        <ci>a</ci>
        <ci>e</ci>
        <ci>g</ci>
       </apply>
      </apply>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
       <apply>
        <times></times>
        <ci>d</ci>
        <ci>e</ci>
        <ci>g</ci>
        <ci>f</ci>
        <ci>h</ci>
       </apply>
      </apply>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (e,f),(g,h)\mapsto\left(\frac{eh+fg}{1+degfh},\frac{fh-aeg}{1-degfh}\right)
  </annotation>
 </semantics>
</math>

. The point (0,1) is its neutral element and the negative of 

<math display="inline" id="Lenstra_elliptic_curve_factorization:85">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>e</mi>
   <mo>,</mo>
   <mi>f</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>e</ci>
    <ci>f</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (e,f)
  </annotation>
 </semantics>
</math>

 is 

<math display="inline" id="Lenstra_elliptic_curve_factorization:86">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mo>-</mo>
    <mi>e</mi>
   </mrow>
   <mo>,</mo>
   <mi>f</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <apply>
     <minus></minus>
     <ci>e</ci>
    </apply>
    <ci>f</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (-e,f)
  </annotation>
 </semantics>
</math>

. The other representations are defined similar to how the projective Weierstrass curve follows from the affine.</p>

<p>Any <a href="elliptic_curve" title="wikilink">elliptic curve</a> in Edwards form has a point of order 4. So the <a href="torsion_group" title="wikilink">torsion group</a> of an Edwards curve over 

<math display="inline" id="Lenstra_elliptic_curve_factorization:87">
 <semantics>
  <mi>ℚ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℚ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{Q}
  </annotation>
 </semantics>
</math>

 is isomorphic to either 

<math display="inline" id="Lenstra_elliptic_curve_factorization:88">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>ℤ</mi>
     <mo>/</mo>
     <mn>4</mn>
    </mrow>
    <mi>ℤ</mi>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mrow>
     <mi>ℤ</mi>
     <mo>/</mo>
     <mn>8</mn>
    </mrow>
    <mi>ℤ</mi>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mrow>
     <mi>ℤ</mi>
     <mo>/</mo>
     <mn>12</mn>
    </mrow>
    <mi>ℤ</mi>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mrow>
     <mrow>
      <mrow>
       <mrow>
        <mi>ℤ</mi>
        <mo>/</mo>
        <mn>2</mn>
       </mrow>
       <mi>ℤ</mi>
      </mrow>
      <mo>×</mo>
      <mi>ℤ</mi>
     </mrow>
     <mo>/</mo>
     <mn>4</mn>
    </mrow>
    <mi>ℤ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <ci>ℤ</ci>
      <cn type="integer">4</cn>
     </apply>
     <ci>ℤ</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <ci>ℤ</ci>
      <cn type="integer">8</cn>
     </apply>
     <ci>ℤ</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <ci>ℤ</ci>
      <cn type="integer">12</cn>
     </apply>
     <ci>ℤ</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <apply>
        <times></times>
        <apply>
         <divide></divide>
         <ci>ℤ</ci>
         <cn type="integer">2</cn>
        </apply>
        <ci>ℤ</ci>
       </apply>
       <ci>ℤ</ci>
      </apply>
      <cn type="integer">4</cn>
     </apply>
     <ci>ℤ</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{Z}/4\mathbb{Z},\mathbb{Z}/8\mathbb{Z},\mathbb{Z}/12\mathbb{Z},\mathbb{%
Z}/2\mathbb{Z}\times\mathbb{Z}/4\mathbb{Z}
  </annotation>
 </semantics>
</math>

 or 

<math display="inline" id="Lenstra_elliptic_curve_factorization:89">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mrow>
       <mi>ℤ</mi>
       <mo>/</mo>
       <mn>2</mn>
      </mrow>
      <mi>ℤ</mi>
     </mrow>
     <mo>×</mo>
     <mi>ℤ</mi>
    </mrow>
    <mo>/</mo>
    <mn>8</mn>
   </mrow>
   <mi>ℤ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <ci>ℤ</ci>
        <cn type="integer">2</cn>
       </apply>
       <ci>ℤ</ci>
      </apply>
      <ci>ℤ</ci>
     </apply>
     <cn type="integer">8</cn>
    </apply>
    <ci>ℤ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{Z}/2\mathbb{Z}\times\mathbb{Z}/8\mathbb{Z}
  </annotation>
 </semantics>
</math>

.</p>

<p>The most interesting cases for ECM are 

<math display="inline" id="Lenstra_elliptic_curve_factorization:90">
 <semantics>
  <mrow>
   <mrow>
    <mi>ℤ</mi>
    <mo>/</mo>
    <mn>12</mn>
   </mrow>
   <mi>ℤ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <ci>ℤ</ci>
     <cn type="integer">12</cn>
    </apply>
    <ci>ℤ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{Z}/12\mathbb{Z}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Lenstra_elliptic_curve_factorization:91">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mrow>
       <mi>ℤ</mi>
       <mo>/</mo>
       <mn>2</mn>
      </mrow>
      <mi>ℤ</mi>
     </mrow>
     <mo>×</mo>
     <mi>ℤ</mi>
    </mrow>
    <mo>/</mo>
    <mn>8</mn>
   </mrow>
   <mi>ℤ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <ci>ℤ</ci>
        <cn type="integer">2</cn>
       </apply>
       <ci>ℤ</ci>
      </apply>
      <ci>ℤ</ci>
     </apply>
     <cn type="integer">8</cn>
    </apply>
    <ci>ℤ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{Z}/2\mathbb{Z}\times\mathbb{Z}/8\mathbb{Z}
  </annotation>
 </semantics>
</math>

, since they force the group orders of the curve modulo primes to be divisible by 12 and 16 respectively. The following curves have a torsion group isomorphic to 

<math display="inline" id="Lenstra_elliptic_curve_factorization:92">
 <semantics>
  <mrow>
   <mrow>
    <mi>ℤ</mi>
    <mo>/</mo>
    <mn>12</mn>
   </mrow>
   <mi>ℤ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <ci>ℤ</ci>
     <cn type="integer">12</cn>
    </apply>
    <ci>ℤ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{Z}/12\mathbb{Z}
  </annotation>
 </semantics>
</math>

:</p>
<ul>
<li>

<math display="inline" id="Lenstra_elliptic_curve_factorization:93">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>x</mi>
     <mn>2</mn>
    </msup>
    <mo>+</mo>
    <msup>
     <mi>y</mi>
     <mn>2</mn>
    </msup>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mo>+</mo>
    <mrow>
     <mi>d</mi>
     <msup>
      <mi>x</mi>
      <mn>2</mn>
     </msup>
     <msup>
      <mi>y</mi>
      <mn>2</mn>
     </msup>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>y</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <cn type="integer">1</cn>
     <apply>
      <times></times>
      <ci>d</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>y</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{2}+y^{2}=1+dx^{2}y^{2}
  </annotation>
 </semantics>
</math>

 with point 

<math display="inline" id="Lenstra_elliptic_curve_factorization:94">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>a</mi>
   <mo>,</mo>
   <mi>b</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>a</ci>
    <ci>b</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (a,b)
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Lenstra_elliptic_curve_factorization:95">
 <semantics>
  <mrow>
   <mrow>
    <mi>b</mi>
    <mo>∉</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mrow>
      <mo>-</mo>
      <mn>2</mn>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mo>-</mo>
      <mrow>
       <mn>1</mn>
       <mo>/</mo>
       <mn>2</mn>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mn>0</mn>
     <mo>,</mo>
     <mrow>
      <mo>±</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mrow>
    <msup>
     <mi>a</mi>
     <mn>2</mn>
    </msup>
    <mo>=</mo>
    <mrow>
     <mo>-</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msup>
        <mi>b</mi>
        <mn>2</mn>
       </msup>
       <mo>+</mo>
       <mrow>
        <mn>2</mn>
        <mi>b</mi>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <notin></notin>
     <ci>b</ci>
     <set>
      <apply>
       <minus></minus>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <minus></minus>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <cn type="integer">0</cn>
      <apply>
       <csymbol cd="latexml">plus-or-minus</csymbol>
       <cn type="integer">1</cn>
      </apply>
     </set>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>a</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <plus></plus>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>b</ci>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <ci>b</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b\notin\{-2,-1/2,0,\pm 1\},a^{2}=-(b^{2}+2b)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Lenstra_elliptic_curve_factorization:96">
 <semantics>
  <mrow>
   <mi>d</mi>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <mn>2</mn>
        <mi>b</mi>
       </mrow>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>/</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msup>
        <mi>a</mi>
        <mn>2</mn>
       </msup>
       <msup>
        <mi>b</mi>
        <mn>2</mn>
       </msup>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>d</ci>
    <apply>
     <minus></minus>
     <apply>
      <divide></divide>
      <apply>
       <plus></plus>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <ci>b</ci>
       </apply>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>a</ci>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>b</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d=-(2b+1)/(a^{2}b^{2})
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="Lenstra_elliptic_curve_factorization:97">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>x</mi>
     <mn>2</mn>
    </msup>
    <mo>+</mo>
    <msup>
     <mi>y</mi>
     <mn>2</mn>
    </msup>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mo>+</mo>
    <mrow>
     <mi>d</mi>
     <msup>
      <mi>x</mi>
      <mn>2</mn>
     </msup>
     <msup>
      <mi>y</mi>
      <mn>2</mn>
     </msup>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>y</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <cn type="integer">1</cn>
     <apply>
      <times></times>
      <ci>d</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>y</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{2}+y^{2}=1+dx^{2}y^{2}
  </annotation>
 </semantics>
</math>

 with point 

<math display="inline" id="Lenstra_elliptic_curve_factorization:98">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>a</mi>
   <mo>,</mo>
   <mi>b</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>a</ci>
    <ci>b</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (a,b)
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Lenstra_elliptic_curve_factorization:99">
 <semantics>
  <mrow>
   <mrow>
    <mi>a</mi>
    <mo>=</mo>
    <mfrac>
     <mrow>
      <msup>
       <mi>u</mi>
       <mn>2</mn>
      </msup>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
     <mrow>
      <msup>
       <mi>u</mi>
       <mn>2</mn>
      </msup>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </mfrac>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>b</mi>
    <mo>=</mo>
    <mrow>
     <mo>-</mo>
     <mfrac>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>u</mi>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mn>2</mn>
      </msup>
      <mrow>
       <msup>
        <mi>u</mi>
        <mn>2</mn>
       </msup>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </mfrac>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <ci>a</ci>
     <apply>
      <divide></divide>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>u</ci>
        <cn type="integer">2</cn>
       </apply>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <plus></plus>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>u</ci>
        <cn type="integer">2</cn>
       </apply>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <ci>b</ci>
     <apply>
      <minus></minus>
      <apply>
       <divide></divide>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <minus></minus>
         <ci>u</ci>
         <cn type="integer">1</cn>
        </apply>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <plus></plus>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>u</ci>
         <cn type="integer">2</cn>
        </apply>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a=\frac{u^{2}-1}{u^{2}+1},b=-\frac{(u-1)^{2}}{u^{2}+1}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Lenstra_elliptic_curve_factorization:100">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>d</mi>
     <mo>=</mo>
     <mfrac>
      <mrow>
       <msup>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <msup>
           <mi>u</mi>
           <mn>2</mn>
          </msup>
          <mo>+</mo>
          <mn>1</mn>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
        <mn>3</mn>
       </msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mrow>
          <msup>
           <mi>u</mi>
           <mn>2</mn>
          </msup>
          <mo>-</mo>
          <mrow>
           <mn>4</mn>
           <mi>u</mi>
          </mrow>
         </mrow>
         <mo>+</mo>
         <mn>1</mn>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mrow>
       <msup>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mi>u</mi>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
        <mn>6</mn>
       </msup>
       <msup>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mi>u</mi>
          <mo>+</mo>
          <mn>1</mn>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
        <mn>2</mn>
       </msup>
      </mrow>
     </mfrac>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mi>u</mi>
     <mo>∉</mo>
     <mrow>
      <mo stretchy="false">{</mo>
      <mn>0</mn>
      <mo>,</mo>
      <mrow>
       <mo>±</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">}</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <ci>d</ci>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <plus></plus>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>u</ci>
          <cn type="integer">2</cn>
         </apply>
         <cn type="integer">1</cn>
        </apply>
        <cn type="integer">3</cn>
       </apply>
       <apply>
        <plus></plus>
        <apply>
         <minus></minus>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>u</ci>
          <cn type="integer">2</cn>
         </apply>
         <apply>
          <times></times>
          <cn type="integer">4</cn>
          <ci>u</ci>
         </apply>
        </apply>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <minus></minus>
         <ci>u</ci>
         <cn type="integer">1</cn>
        </apply>
        <cn type="integer">6</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <plus></plus>
         <ci>u</ci>
         <cn type="integer">1</cn>
        </apply>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <notin></notin>
     <ci>u</ci>
     <set>
      <cn type="integer">0</cn>
      <apply>
       <csymbol cd="latexml">plus-or-minus</csymbol>
       <cn type="integer">1</cn>
      </apply>
     </set>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d=\frac{(u^{2}+1)^{3}(u^{2}-4u+1)}{(u-1)^{6}(u+1)^{2}},u\notin\{0,\pm 1\}.
  </annotation>
 </semantics>
</math>

</li>
</ul>

<p>Every Edwards curve with a point of order 3 can be written in the ways shown above. Curves with torsion group isomorphic to 

<math display="inline" id="Lenstra_elliptic_curve_factorization:101">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mrow>
       <mi>ℤ</mi>
       <mo>/</mo>
       <mn>2</mn>
      </mrow>
      <mi>ℤ</mi>
     </mrow>
     <mo>×</mo>
     <mi>ℤ</mi>
    </mrow>
    <mo>/</mo>
    <mn>8</mn>
   </mrow>
   <mi>ℤ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <ci>ℤ</ci>
        <cn type="integer">2</cn>
       </apply>
       <ci>ℤ</ci>
      </apply>
      <ci>ℤ</ci>
     </apply>
     <cn type="integer">8</cn>
    </apply>
    <ci>ℤ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{Z}/2\mathbb{Z}\times\mathbb{Z}/8\mathbb{Z}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Lenstra_elliptic_curve_factorization:102">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mrow>
       <mi>ℤ</mi>
       <mo>/</mo>
       <mn>2</mn>
      </mrow>
      <mi>ℤ</mi>
     </mrow>
     <mo>×</mo>
     <mi>ℤ</mi>
    </mrow>
    <mo>/</mo>
    <mn>4</mn>
   </mrow>
   <mi>ℤ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <ci>ℤ</ci>
        <cn type="integer">2</cn>
       </apply>
       <ci>ℤ</ci>
      </apply>
      <ci>ℤ</ci>
     </apply>
     <cn type="integer">4</cn>
    </apply>
    <ci>ℤ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{Z}/2\mathbb{Z}\times\mathbb{Z}/4\mathbb{Z}
  </annotation>
 </semantics>
</math>

 can be found on <a class="uri" href="http://eprint.iacr.org/2008/016">http://eprint.iacr.org/2008/016</a>, top of page 30.</p>
<h2 id="stage-2">Stage 2</h2>

<p>The above text is about the first stage of elliptic curve factorisation. There one hopes to find a prime divisor 

<math display="inline" id="Lenstra_elliptic_curve_factorization:103">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Lenstra_elliptic_curve_factorization:104">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mi>P</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>s</ci>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   sP
  </annotation>
 </semantics>
</math>

 is the neutral element of 

<math display="inline" id="Lenstra_elliptic_curve_factorization:105">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mrow>
      <mi>ℤ</mi>
      <mo>/</mo>
      <mi>p</mi>
     </mrow>
     <mi>ℤ</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>E</ci>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <ci>ℤ</ci>
      <ci>p</ci>
     </apply>
     <ci>ℤ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E(\mathbb{Z}/p\mathbb{Z})
  </annotation>
 </semantics>
</math>

. In the second stage one hopes to have found a prime divisor 

<math display="inline" id="Lenstra_elliptic_curve_factorization:106">
 <semantics>
  <mi>q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Lenstra_elliptic_curve_factorization:107">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mi>P</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>s</ci>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   sP
  </annotation>
 </semantics>
</math>

 has small prime order in 

<math display="inline" id="Lenstra_elliptic_curve_factorization:108">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mrow>
      <mi>ℤ</mi>
      <mo>/</mo>
      <mi>q</mi>
     </mrow>
     <mi>ℤ</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>E</ci>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <ci>ℤ</ci>
      <ci>q</ci>
     </apply>
     <ci>ℤ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E(\mathbb{Z}/q\mathbb{Z})
  </annotation>
 </semantics>
</math>

.</p>

<p>We hope the order to be between 

<math display="inline" id="Lenstra_elliptic_curve_factorization:109">
 <semantics>
  <msub>
   <mi>B</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>B</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B_{1}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Lenstra_elliptic_curve_factorization:110">
 <semantics>
  <msub>
   <mi>B</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>B</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B_{2}
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Lenstra_elliptic_curve_factorization:111">
 <semantics>
  <msub>
   <mi>B</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>B</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B_{1}
  </annotation>
 </semantics>
</math>

 is determined in stage 1 and 

<math display="inline" id="Lenstra_elliptic_curve_factorization:112">
 <semantics>
  <msub>
   <mi>B</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>B</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B_{2}
  </annotation>
 </semantics>
</math>

 is new stage 2 parameter. Checking for a small order of 

<math display="inline" id="Lenstra_elliptic_curve_factorization:113">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mi>P</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>s</ci>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   sP
  </annotation>
 </semantics>
</math>

, can be done by computing 

<math display="inline" id="Lenstra_elliptic_curve_factorization:114">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>l</mi>
     <mi>s</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi>P</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <times></times>
     <ci>l</ci>
     <ci>s</ci>
    </apply>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (ls)P
  </annotation>
 </semantics>
</math>

 modulo 

<math display="inline" id="Lenstra_elliptic_curve_factorization:115">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 for each prime 

<math display="inline" id="Lenstra_elliptic_curve_factorization:116">
 <semantics>
  <mi>l</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>l</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   l
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="success-probability-using-eecm-mpfq">Success probability using EECM-MPFQ</h2>

<p>For speedup techniques using Edward curves and implementation results, see: <a class="uri" href="http://eprint.iacr.org/2008/016">http://eprint.iacr.org/2008/016</a> pages 30–32.</p>
<h2 id="hyperelliptic-curve-method-hecm">Hyperelliptic curve method (HECM)</h2>

<p>There are recent developments in using <a href="hyperelliptic_curve" title="wikilink">hyperelliptic curves</a> to factor integers. Cosset shows in his article (of 2010) that one can build a hyperelliptic curve with genus two (so a curve 

<math display="inline" id="Lenstra_elliptic_curve_factorization:117">
 <semantics>
  <mrow>
   <msup>
    <mi>y</mi>
    <mn>2</mn>
   </msup>
   <mo>=</mo>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>y</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y^{2}=f(x)
  </annotation>
 </semantics>
</math>

 with 

<math display="inline" id="Lenstra_elliptic_curve_factorization:118">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 of degree 5) which gives the same result as using two 'normal' elliptic curves at the same time. By making use of the Kummer Surface calculation is more efficient. The disadvantages of the hyperelliptic curve (versus an elliptic curve) are compensated by this alternative way of calculating. Therefore Cosset roughly claims that using hyperelliptic curves for factorization is no worse than using elliptic curves.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a class="uri" href="UBASIC" title="wikilink">UBASIC</a> for practical program (ECMX).</li>
</ul>
<h2 id="references">References</h2>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://alpertron.com.ar/ECM.HTM">Factorization using the Elliptic Curve Method</a>, a Java applet which uses ECM and switches to the <a href="Quadratic_sieve" title="wikilink">Self-Initializing Quadratic Sieve</a> when it is faster.</li>
<li><a href="http://ecm.gforge.inria.fr/">GMP-ECM</a>, an efficient implementation of ECM.</li>
<li><a href="http://www.loria.fr/~zimmerma/records/ecmnet.html">ECMNet</a>, an easy client-server implementation that works with several factorization projects.</li>
<li><a href="http://www.sourceforge.net/projects/pyecm">pyecm</a>, a python implementation of ECM. Much faster with psyco and/or gmpy.</li>
<li><a href="http://www.rechenkraft.net/yoyo/">Distributed computing project yoyo@Home</a> Subproject ECM is a program for Elliptic Curve Factorization which is used by a couple of projects to find factors for different kind of numbers.</li>
<li><a href="http://ardoino.com/2008/03/large-integers-factorization/">Lenstra Elliptic Curve Factorization algorithm source code</a> Simple C and GMP Elliptic Curve Factorization Algorithm source code</li>
</ul>

<p>"</p>

<p><a href="Category:Integer_factorization_algorithms" title="wikilink">Category:Integer factorization algorithms</a> <a href="Category:Finite_fields" title="wikilink">Category:Finite fields</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="http://www.loria.fr/~zimmerma/records/top50.html">50 largest factors found by ECM</a><a href="#fnref1">↩</a></li>
</ol>
</section>
</body>
</html>
