<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="805">Distributed source coding</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Distributed source coding</h1>
<hr>'''Distributed source coding''' ('''DSC''') is an important problem in [[information theory]] and [[comm
<p>unication]]. DSC problems regard the compression of multiple correlated information sources that do not communicate with each other.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> By modeling the correlation between multiple sources at the decoder side together with <a href="channel_code" title="wikilink">channel codes</a>, DSC is able to shift the computational complexity from encoder side to decoder side, therefore provide appropriate frameworks for applications with complexity-constrained sender, such as <a href="sensor_networks" title="wikilink">sensor networks</a> and video/multimedia compression (see <a href="distributed_video_coding" title="wikilink">distributed video coding</a><a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a>). One of the main properties of distributed source coding is that the computational burden in encoders is shifted to the joint decoder.</p>
<h2 id="history">History</h2>

<p>In 1973, <a href="David_Slepian" title="wikilink">David Slepian</a> and <a href="Jack_Keil_Wolf" title="wikilink">Jack Keil Wolf</a> proposed the information theoretical lossless compression bound on distributed compression of two correlated <a href="IID" title="wikilink">i.i.d.</a> sources X and Y.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> After that, this bound was extended to cases with more than two sources by <a href="Thomas_M._Cover" title="wikilink">Thomas M. Cover</a> in 1975,<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> while the theoretical results in the lossy compression case are presented by <a href="Aaron_D._Wyner" title="wikilink">Aaron D. Wyner</a> and <a href="Jacob_Ziv" title="wikilink">Jacob Ziv</a> in 1976.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>

<p>Although the theorems on DSC were proposed on 1970s, it was after about 30 years that attempts were started for practical techniques, based on the idea that DSC is closely related to channel coding proposed in 1974 by <a href="Aaron_D._Wyner" title="wikilink">Aaron D. Wyner</a>.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> The asymmetric DSC problem was addressed by S. S. Pradhan and K. Ramchandran in 1999, which focused on statistically dependent binary and Gaussian sources and used scalar and trellis <a class="uri" href="coset" title="wikilink">coset</a> constructions to solve the problem.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> They further extended the work into the symmetric DSC case.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></p>

<p><a href="Syndrome_decoding" title="wikilink">Syndrome decoding</a> technology was first used in distributed source coding by the <a class="uri" href="DISCUS" title="wikilink">DISCUS</a> system of SS Pradhan and K Ramachandran (Distributed Source Coding Using Syndromes).<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> They compress binary block data from one source into syndromes and transmit data from the other source uncompressed as <a href="side_information" title="wikilink">side information</a>. This kind of DSC scheme achieves asymmetric compression rates per source and results in <em>asymmetric</em> DSC. This asymmetric DSC scheme can be easily extended to the case of more than two correlated information sources. There are also some DSC schemes that use <a href="parity_bit" title="wikilink">parity bits</a> rather than syndrome bits.</p>

<p>The correlation between two sources in DSC has been modeled as a <a href="virtual_channel" title="wikilink">virtual channel</a> which is usually referred as a <a href="binary_symmetric_channel" title="wikilink">binary symmetric channel</a>.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a><a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a></p>

<p>Starting from <a class="uri" href="DISCUS" title="wikilink">DISCUS</a>, DSC has attracted significant research activity and more sophisticated channel coding techniques have been adopted into DSC frameworks, such as <a href="Turbo_Code" title="wikilink">Turbo Code</a>, <a class="uri" href="LDPC" title="wikilink">LDPC</a> Code, and so on.</p>

<p>Similar to the previous lossless coding framework based on Slepian–Wolf theorem, efforts have been taken on lossy cases based on the Wyner–Ziv theorem. Theoretical results on quantizer designs was provided by R. Zamir and S. Shamai,<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> while different frameworks have been proposed based on this result, including a nested lattice quantizer and a trellis-coded quantizer.</p>

<p>Moreover, DSC has been used in video compression for applications which require low complexity video encoding, such as sensor networks, multiview video camcorders, and so on.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a></p>

<p>With deterministic and probabilistic discussions of correlation model of two correlated information sources, DSC schemes with more general compressed rates have been developed.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a><a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a><a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a> In these <em>non-asymmetric</em> schemes, both of two correlated sources are compressed.</p>

<p>Under a certain deterministic assumption of correlation between information sources, a DSC framework in which any number of information sources can be compressed in a distributed way has been demonstrated by X. Cao and M. Kuijper.<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a> This method performs non-asymmetric compression with flexible rates for each source, achieving the same overall compression rate as repeatedly applying asymmetric DSC for more than two sources. Then, by investigating the unique connection between syndromes and complementary codewords of linear codes, they have translated the major steps of DSC joint decoding into syndrome decoding followed by channel encoding via a linear block code and also via its complement code,<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a> which theoretically illustrated a method of assembling a DSC joint decoder from linear code encoders and decoders.</p>
<h2 id="theoretical-bounds">Theoretical bounds</h2>

<p>The information theoretical lossless compression bound on DSC (the <a href="Slepian–Wolf_bound" title="wikilink">Slepian–Wolf bound</a>) was first purposed by <a href="David_Slepian" title="wikilink">David Slepian</a> and <a href="Jack_Keil_Wolf" title="wikilink">Jack Keil Wolf</a> in terms of entropies of correlated information sources in 1973.<a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a> They also showed that two isolated sources can compress data as efficiently as if they were communicating with each other. This bound has been extended to the case of more than two correlated sources by <a href="Thomas_M._Cover" title="wikilink">Thomas M. Cover</a> in 1975.<a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a></p>

<p>Similar results were obtained in 1976 by <a href="Aaron_D._Wyner" title="wikilink">Aaron D. Wyner</a> and <a href="Jacob_Ziv" title="wikilink">Jacob Ziv</a> with regard to lossy coding of joint Gaussian sources.<a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a></p>
<h3 id="slepianwolf-bound">Slepian–Wolf bound</h3>

<p>Distributed Coding is the coding of two or more dependent sources with separate encoders and joint decoder. Given two statistically dependent i.i.d. finite-alphabet random sequences X and Y, Slepian–Wolf theorem includes theoretical bound for the lossless coding rate for distributed coding of the two sources as below:<a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a></p>

<p>

<math display="block" id="Distributed_source_coding:0">
 <semantics>
  <mrow>
   <msub>
    <mi>R</mi>
    <mi>X</mi>
   </msub>
   <mo>≥</mo>
   <mi>H</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">|</mo>
    <mi>Y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo rspace="4.2pt">,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>R</ci>
     <ci>X</ci>
    </apply>
    <geq></geq>
    <csymbol cd="unknown">H</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">X</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">Y</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-,</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{X}\geq H(X|Y),\,
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Distributed_source_coding:1">
 <semantics>
  <mrow>
   <msub>
    <mi>R</mi>
    <mi>Y</mi>
   </msub>
   <mo>≥</mo>
   <mi>H</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>Y</mi>
    <mo stretchy="false">|</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo rspace="4.2pt">,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>R</ci>
     <ci>Y</ci>
    </apply>
    <geq></geq>
    <csymbol cd="unknown">H</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">Y</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">X</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-,</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{Y}\geq H(Y|X),\,
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Distributed_source_coding:2">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>R</mi>
      <mi>X</mi>
     </msub>
     <mo>+</mo>
     <msub>
      <mi>R</mi>
      <mi>Y</mi>
     </msub>
    </mrow>
    <mo>≥</mo>
    <mrow>
     <mi>H</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>X</mi>
      <mo>,</mo>
      <mi>Y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>R</ci>
      <ci>X</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>R</ci>
      <ci>Y</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>H</ci>
     <interval closure="open">
      <ci>X</ci>
      <ci>Y</ci>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{X}+R_{Y}\geq H(X,Y).\,
  </annotation>
 </semantics>
</math>

</p>

<p>If both the encoder and decoder of the two sources are independent, the lowest rate we can achieve for lossless compression is 

<math display="inline" id="Distributed_source_coding:3">
 <semantics>
  <mrow>
   <mi>H</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>H</ci>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H(X)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Distributed_source_coding:4">
 <semantics>
  <mrow>
   <mi>H</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>Y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>H</ci>
    <ci>Y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H(Y)
  </annotation>
 </semantics>
</math>

 for 

<math display="inline" id="Distributed_source_coding:5">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Distributed_source_coding:6">
 <semantics>
  <mi>Y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y
  </annotation>
 </semantics>
</math>

 respectively, where 

<math display="inline" id="Distributed_source_coding:7">
 <semantics>
  <mrow>
   <mi>H</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>H</ci>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H(X)
  </annotation>
 </semantics>
</math>


 and 

<math display="inline" id="Distributed_source_coding:8">
 <semantics>
  <mrow>
   <mi>H</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>Y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>H</ci>
    <ci>Y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H(Y)
  </annotation>
 </semantics>
</math>

 are the entropies of 

<math display="inline" id="Distributed_source_coding:9">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Distributed_source_coding:10">
 <semantics>
  <mi>Y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y
  </annotation>
 </semantics>
</math>

. However, with joint decoding, if vanishing error probability for long sequences is accepted, the Slepian–Wolf theorem shows that much better compression rate can be achieved. As long as the total rate of 

<math display="inline" id="Distributed_source_coding:11">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Distributed_source_coding:12">
 <semantics>
  <mi>Y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y
  </annotation>
 </semantics>
</math>


 is larger than their joint entropy 

<math display="inline" id="Distributed_source_coding:13">
 <semantics>
  <mrow>
   <mi>H</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo>,</mo>
    <mi>Y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>H</ci>
    <interval closure="open">
     <ci>X</ci>
     <ci>Y</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H(X,Y)
  </annotation>
 </semantics>
</math>

 and none of the sources is encoded with a rate larger than its entropy, distributed coding can achieve arbitrarily small error probability for long sequences.</p>

<p>A special case of distributed coding is compression with decoder side information, where source 

<math display="inline" id="Distributed_source_coding:14">
 <semantics>
  <mi>Y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y
  </annotation>
 </semantics>
</math>

 is available at the decoder side but not accessible at the encoder side. This can be treated as the condition that 

<math display="inline" id="Distributed_source_coding:15">
 <semantics>
  <mrow>
   <msub>
    <mi>R</mi>
    <mi>Y</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mi>H</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>Y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>R</ci>
     <ci>Y</ci>
    </apply>
    <apply>
     <times></times>
     <ci>H</ci>
     <ci>Y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{Y}=H(Y)
  </annotation>
 </semantics>
</math>

 has already been used to encode 

<math display="inline" id="Distributed_source_coding:16">
 <semantics>
  <mi>Y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y
  </annotation>
 </semantics>
</math>

, while we intend to use 

<math display="inline" id="Distributed_source_coding:17">
 <semantics>
  <mrow>
   <mi>H</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">|</mo>
    <mi>Y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">H</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">X</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">Y</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H(X|Y)
  </annotation>
 </semantics>
</math>


 to encode 

<math display="inline" id="Distributed_source_coding:18">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

. The whole system is operating in an asymmetric way (compression rate for the two sources are asymmetric).</p>
<h3 id="wynerziv-bound">Wyner–Ziv bound</h3>

<p>Shortly after Slepian–Wolf theorem on lossless distributed compression was published, the extension to lossy compression with decoder side information was proposed as Wyner–Ziv theorem.<a class="footnoteRef" href="#fn23" id="fnref23"><sup>23</sup></a> Similarly to lossless case, two statistically dependent i.i.d. sources 

<math display="inline" id="Distributed_source_coding:19">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Distributed_source_coding:20">
 <semantics>
  <mi>Y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y
  </annotation>
 </semantics>
</math>

 are given, where 

<math display="inline" id="Distributed_source_coding:21">
 <semantics>
  <mi>Y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y
  </annotation>
 </semantics>
</math>

 is available at the decoder side but not accessible at the encoder side. Instead of lossless compression in Slepian–Wolf theorem, Wyner–Ziv theorem looked into the lossy compression case.</p>

<p>Wyner–Ziv theorem presents the achievable lower bound for the bit rate of 

<math display="inline" id="Distributed_source_coding:22">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>


 at given distortion 

<math display="inline" id="Distributed_source_coding:23">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>

. It was found that for Gaussian memoryless sources and mean-squared error distortion, the lower bound for the bit rate of 

<math display="inline" id="Distributed_source_coding:24">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

 remain the same no matter whether side information is available at the encoder or not.</p>
<h2 id="virtual-channel">Virtual channel</h2>

<p><strong>Deterministic</strong> model</p>

<p><strong>Probabilistic</strong> model</p>
<h2 id="asymmetric-dsc-vs.-symmetric-dsc">Asymmetric DSC vs. symmetric DSC</h2>

<p>Asymmetric DSC means that, different bitrates are used in coding the input sources, while same bitrate is used in symmetric DSC. Taking a DSC design with two sources for example, in this example 

<math display="inline" id="Distributed_source_coding:25">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Distributed_source_coding:26">
 <semantics>
  <mi>Y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y
  </annotation>
 </semantics>
</math>

 are two discrete, memoryless, uniformly distributed sources which generate set of variables 

<math display="inline" id="Distributed_source_coding:27">
 <semantics>
  <mi>𝐱</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐱</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{x}
  </annotation>
 </semantics>
</math>


 and 

<math display="inline" id="Distributed_source_coding:28">
 <semantics>
  <mi>𝐲</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐲</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{y}
  </annotation>
 </semantics>
</math>

 of length 7 bits and the Hamming distance between 

<math display="inline" id="Distributed_source_coding:29">
 <semantics>
  <mi>𝐱</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐱</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{x}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Distributed_source_coding:30">
 <semantics>
  <mi>𝐲</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐲</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{y}
  </annotation>
 </semantics>
</math>

 is at most one. The Slepian–Wolf bound for them is:</p>

<p>

<math display="block" id="Distributed_source_coding:31">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>R</mi>
     <mi>X</mi>
    </msub>
    <mo>+</mo>
    <msub>
     <mi>R</mi>
     <mi>Y</mi>
    </msub>
   </mrow>
   <mo>≥</mo>
   <mn>10</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>R</ci>
      <ci>X</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>R</ci>
      <ci>Y</ci>
     </apply>
    </apply>
    <cn type="integer">10</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{X}+R_{Y}\geq 10
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Distributed_source_coding:32">
 <semantics>
  <mrow>
   <msub>
    <mi>R</mi>
    <mi>X</mi>
   </msub>
   <mo>≥</mo>
   <mn>5</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>R</ci>
     <ci>X</ci>
    </apply>
    <cn type="integer">5</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{X}\geq 5
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Distributed_source_coding:33">
 <semantics>
  <mrow>
   <msub>
    <mi>R</mi>
    <mi>Y</mi>
   </msub>
   <mo>≥</mo>
   <mn>5</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>R</ci>
     <ci>Y</ci>
    </apply>
    <cn type="integer">5</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{Y}\geq 5
  </annotation>
 </semantics>
</math>

</p>

<p>This means, the theoretical bound is 

<math display="inline" id="Distributed_source_coding:34">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>R</mi>
     <mi>X</mi>
    </msub>
    <mo>+</mo>
    <msub>
     <mi>R</mi>
     <mi>Y</mi>
    </msub>
   </mrow>
   <mo>=</mo>
   <mn>10</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>R</ci>
      <ci>X</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>R</ci>
      <ci>Y</ci>
     </apply>
    </apply>
    <cn type="integer">10</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{X}+R_{Y}=10
  </annotation>
 </semantics>
</math>

 and symmetric DSC means 5 bits for each source. Other pairs with 

<math display="inline" id="Distributed_source_coding:35">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>R</mi>
     <mi>X</mi>
    </msub>
    <mo>+</mo>
    <msub>
     <mi>R</mi>
     <mi>Y</mi>
    </msub>
   </mrow>
   <mo>=</mo>
   <mn>10</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>R</ci>
      <ci>X</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>R</ci>
      <ci>Y</ci>
     </apply>
    </apply>
    <cn type="integer">10</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{X}+R_{Y}=10
  </annotation>
 </semantics>
</math>

 are asymmetric cases with different bit rate distributions between 

<math display="inline" id="Distributed_source_coding:36">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Distributed_source_coding:37">
 <semantics>
  <mi>Y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y
  </annotation>
 </semantics>
</math>


, where 

<math display="inline" id="Distributed_source_coding:38">
 <semantics>
  <mrow>
   <msub>
    <mi>R</mi>
    <mi>X</mi>
   </msub>
   <mo>=</mo>
   <mn>3</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>R</ci>
     <ci>X</ci>
    </apply>
    <cn type="integer">3</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{X}=3
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Distributed_source_coding:39">
 <semantics>
  <mrow>
   <msub>
    <mi>R</mi>
    <mi>Y</mi>
   </msub>
   <mo>=</mo>
   <mn>7</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>R</ci>
     <ci>Y</ci>
    </apply>
    <cn type="integer">7</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{Y}=7
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Distributed_source_coding:40">
 <semantics>
  <mrow>
   <msub>
    <mi>R</mi>
    <mi>Y</mi>
   </msub>
   <mo>=</mo>
   <mn>3</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>R</ci>
     <ci>Y</ci>
    </apply>
    <cn type="integer">3</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{Y}=3
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Distributed_source_coding:41">
 <semantics>
  <mrow>
   <msub>
    <mi>R</mi>
    <mi>X</mi>
   </msub>
   <mo>=</mo>
   <mn>7</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>R</ci>
     <ci>X</ci>
    </apply>
    <cn type="integer">7</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{X}=7
  </annotation>
 </semantics>
</math>

 represent two extreme cases called decoding with side information.</p>
<h2 id="practical-distributed-source-coding">Practical distributed source coding</h2>
<h3 id="slepianwolf-coding-lossless-distributed-coding">Slepian–Wolf coding – lossless distributed coding</h3>

<p>It was understood that <a href="Slepian–Wolf_coding" title="wikilink">Slepian–Wolf coding</a> is closely related to channel coding in 1974,<a class="footnoteRef" href="#fn24" id="fnref24"><sup>24</sup></a> and after about 30 years, practical DSC started to be implemented by different channel codes. The motivation behind the use of channel codes is from two sources case, the correlation between input sources can be modeled as a virtual channel which has input as source 

<math display="inline" id="Distributed_source_coding:42">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>


 and output as source 

<math display="inline" id="Distributed_source_coding:43">
 <semantics>
  <mi>Y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y
  </annotation>
 </semantics>
</math>

. The <a class="uri" href="DISCUS" title="wikilink">DISCUS</a> system proposed by S. S. Pradhan and K. Ramchandran in 1999 implemented DSC with <a href="syndrome_decoding" title="wikilink">syndrome decoding</a>, which worked for asymmetric case and was further extended to symmetric case.<a class="footnoteRef" href="#fn25" id="fnref25"><sup>25</sup></a><a class="footnoteRef" href="#fn26" id="fnref26"><sup>26</sup></a></p>

<p>The basic framework of syndrome based DSC is that, for each source, its input space is partitioned into several cosets according to the particular channel coding method used. Every input of each source gets an output indicating which coset the input belongs to, and the joint decoder can decode all inputs by received coset indices and dependence between sources. The design of channel codes should consider the correlation between input sources.</p>

<p>A group of codes can be used to generate coset partitions,<a class="footnoteRef" href="#fn27" id="fnref27"><sup>27</sup></a> such as trellis codes and lattice codes. Pradhan and Ramchandran designed rules for construction of sub-codes for each source, and presented result of trellis-based coset constructions in DSC, which is based on <a href="convolution_code" title="wikilink">convolution code</a> and set-partitioning rules as in <a href="Trellis_modulation" title="wikilink">Trellis modulation</a>, as well as lattice code based DSC.<a class="footnoteRef" href="#fn28" id="fnref28"><sup>28</sup></a><a class="footnoteRef" href="#fn29" id="fnref29"><sup>29</sup></a> After this, embedded trellis code was proposed for asymmetric coding as an improvement over their results.<a class="footnoteRef" href="#fn30" id="fnref30"><sup>30</sup></a></p>

<p>After DISCUS system was proposed, more sophisticated channel codes have been adapted to the DSC system, such as <a href="Turbo_Code" title="wikilink">Turbo Code</a>, <a class="uri" href="LDPC" title="wikilink">LDPC</a> Code and Iterative Channel Code. The encoders of these codes are usually simple and easy to implement, while the decoders have much higher computational complexity and are able to get good performance by utilizing source statistics. With sophisticated channel codes which have performance approaching the capacity of the correlation channel, corresponding DSC system can approach the Slepian–Wolf bound.</p>

<p>Although most research focused on DSC with two dependent sources, Slepian–Wolf coding has been extended to more than two input sources case, and sub-codes generation methods from one channel code was proposed by V. Stankovic, A. D. Liveris, etc. given particular correlation models.<a class="footnoteRef" href="#fn31" id="fnref31"><sup>31</sup></a></p>
<h4 id="general-theorem-of-slepianwolf-coding-with-syndromes-for-two-sources">General theorem of Slepian–Wolf coding with syndromes for two sources</h4>

<p><strong>Theorem</strong>: Any pair of correlated uniformly distributed sources, 

<math display="inline" id="Distributed_source_coding:44">
 <semantics>
  <mrow>
   <mrow>
    <mi>X</mi>
    <mo>,</mo>
    <mi>Y</mi>
   </mrow>
   <mo>∈</mo>
   <msup>
    <mrow>
     <mo>{</mo>
     <mn>0</mn>
     <mo>,</mo>
     <mn>1</mn>
     <mo>}</mo>
    </mrow>
    <mi>n</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <list>
     <ci>X</ci>
     <ci>Y</ci>
    </list>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <set>
      <cn type="integer">0</cn>
      <cn type="integer">1</cn>
     </set>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X,Y\in\left\{0,1\right\}^{n}
  </annotation>
 </semantics>
</math>

, with 

<math display="inline" id="Distributed_source_coding:45">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>𝐝</mi>
     <mi>𝐇</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mo>,</mo>
     <mi>Y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mi>t</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐝</ci>
      <ci>𝐇</ci>
     </apply>
     <interval closure="open">
      <ci>X</ci>
      <ci>Y</ci>
     </interval>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{d_{H}}(X,Y)\leq t
  </annotation>
 </semantics>
</math>

, can be compressed separately at a rate pair 

<math display="inline" id="Distributed_source_coding:46">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msub>
    <mi>R</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>R</mi>
    <mn>2</mn>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>R</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>R</ci>
     <cn type="integer">2</cn>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (R_{1},R_{2})
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Distributed_source_coding:47">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>R</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>R</mi>
      <mn>2</mn>
     </msub>
    </mrow>
    <mo>≥</mo>
    <mrow>
     <mi>n</mi>
     <mo>-</mo>
     <mi>k</mi>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>R</mi>
      <mn>1</mn>
     </msub>
     <mo>+</mo>
     <msub>
      <mi>R</mi>
      <mn>2</mn>
     </msub>
    </mrow>
    <mo>≥</mo>
    <mrow>
     <mrow>
      <mn>2</mn>
      <mi>n</mi>
     </mrow>
     <mo>-</mo>
     <mi>k</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <geq></geq>
     <list>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>R</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>R</ci>
       <cn type="integer">2</cn>
      </apply>
     </list>
     <apply>
      <minus></minus>
      <ci>n</ci>
      <ci>k</ci>
     </apply>
    </apply>
    <apply>
     <geq></geq>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>R</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>R</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>n</ci>
      </apply>
      <ci>k</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{1},R_{2}\geq n-k,R_{1}+R_{2}\geq 2n-k
  </annotation>
 </semantics>
</math>


, where 

<math display="inline" id="Distributed_source_coding:48">
 <semantics>
  <msub>
   <mi>R</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>R</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{1}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Distributed_source_coding:49">
 <semantics>
  <msub>
   <mi>R</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>R</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{2}
  </annotation>
 </semantics>
</math>

 are integers, and 

<math display="inline" id="Distributed_source_coding:50">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>≤</mo>
   <mrow>
    <mi>n</mi>
    <mo>-</mo>
    <mrow>
     <mi>log</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msubsup>
        <mo largeop="true" symmetric="true">∑</mo>
        <mrow>
         <mi>i</mi>
         <mo>=</mo>
         <mn>0</mn>
        </mrow>
        <mi>t</mi>
       </msubsup>
       <mrow>
        <mo>(</mo>
        <mstyle scriptlevel="+1">
         <mtable columnspacing="0.4em" rowspacing="0.2ex">
          <mtr>
           <mtd>
            <mi>n</mi>
           </mtd>
          </mtr>
          <mtr>
           <mtd>
            <mi>i</mi>
           </mtd>
          </mtr>
         </mtable>
        </mstyle>
        <mo>)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <ci>k</ci>
    <apply>
     <minus></minus>
     <ci>n</ci>
     <apply>
      <log></log>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <ci>i</ci>
          <cn type="integer">0</cn>
         </apply>
        </apply>
        <ci>t</ci>
       </apply>
       <apply>
        <csymbol cd="latexml">binomial</csymbol>
        <ci>n</ci>
        <ci>i</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k\leq n-\log(\sum_{i=0}^{t}{n\choose i})
  </annotation>
 </semantics>
</math>

. This can be achieved using an 

<math display="inline" id="Distributed_source_coding:51">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>n</mi>
   <mo>,</mo>
   <mi>k</mi>
   <mo>,</mo>
   <mrow>
    <mrow>
     <mn>2</mn>
     <mi>t</mi>
    </mrow>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <ci>n</ci>
    <ci>k</ci>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <ci>t</ci>
     </apply>
     <cn type="integer">1</cn>
    </apply>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (n,k,2t+1)
  </annotation>
 </semantics>
</math>

 binary linear code.</p>

<p><em>Proof</em>: The Hamming bound for an 

<math display="inline" id="Distributed_source_coding:52">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>n</mi>
   <mo>,</mo>
   <mi>k</mi>
   <mo>,</mo>
   <mrow>
    <mrow>
     <mn>2</mn>
     <mi>t</mi>
    </mrow>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <ci>n</ci>
    <ci>k</ci>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <ci>t</ci>
     </apply>
     <cn type="integer">1</cn>
    </apply>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (n,k,2t+1)
  </annotation>
 </semantics>
</math>


 binary linear code is 

<math display="inline" id="Distributed_source_coding:53">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>≤</mo>
   <mrow>
    <mi>n</mi>
    <mo>-</mo>
    <mrow>
     <mi>log</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msubsup>
        <mo largeop="true" symmetric="true">∑</mo>
        <mrow>
         <mi>i</mi>
         <mo>=</mo>
         <mn>0</mn>
        </mrow>
        <mi>t</mi>
       </msubsup>
       <mrow>
        <mo>(</mo>
        <mstyle scriptlevel="+1">
         <mtable columnspacing="0.4em" rowspacing="0.2ex">
          <mtr>
           <mtd>
            <mi>n</mi>
           </mtd>
          </mtr>
          <mtr>
           <mtd>
            <mi>i</mi>
           </mtd>
          </mtr>
         </mtable>
        </mstyle>
        <mo>)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <ci>k</ci>
    <apply>
     <minus></minus>
     <ci>n</ci>
     <apply>
      <log></log>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <ci>i</ci>
          <cn type="integer">0</cn>
         </apply>
        </apply>
        <ci>t</ci>
       </apply>
       <apply>
        <csymbol cd="latexml">binomial</csymbol>
        <ci>n</ci>
        <ci>i</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k\leq n-\log(\sum_{i=0}^{t}{n\choose i})
  </annotation>
 </semantics>
</math>

, and we have Hamming code achieving this bound, therefore we have such a binary linear code 

<math display="inline" id="Distributed_source_coding:54">
 <semantics>
  <mi>𝐂</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐂</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{C}
  </annotation>
 </semantics>
</math>

 with 

<math display="inline" id="Distributed_source_coding:55">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>×</mo>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>k</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k\times n
  </annotation>
 </semantics>
</math>

 generator matrix 

<math display="inline" id="Distributed_source_coding:56">
 <semantics>
  <mi>𝐆</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐆</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{G}
  </annotation>
 </semantics>
</math>

. Next we will show how to construct syndrome encoding based on this linear code.</p>

<p>Let 

<math display="inline" id="Distributed_source_coding:57">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>R</mi>
     <mn>1</mn>
    </msub>
    <mo>+</mo>
    <msub>
     <mi>R</mi>
     <mn>2</mn>
    </msub>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mn>2</mn>
     <mi>n</mi>
    </mrow>
    <mo>-</mo>
    <mi>k</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>R</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>R</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <ci>n</ci>
     </apply>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{1}+R_{2}=2n-k
  </annotation>
 </semantics>
</math>


 and 

<math display="inline" id="Distributed_source_coding:58">
 <semantics>
  <msub>
   <mi>𝐆</mi>
   <mn>𝟏</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝐆</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{G_{1}}
  </annotation>
 </semantics>
</math>

 be formed by taking first 

<math display="inline" id="Distributed_source_coding:59">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi>n</mi>
    <mo>-</mo>
    <msub>
     <mi>R</mi>
     <mn>1</mn>
    </msub>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>n</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>R</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (n-R_{1})
  </annotation>
 </semantics>
</math>

 rows from 

<math display="inline" id="Distributed_source_coding:60">
 <semantics>
  <mi>𝐆</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐆</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{G}
  </annotation>
 </semantics>
</math>

, while 

<math display="inline" id="Distributed_source_coding:61">
 <semantics>
  <msub>
   <mi>𝐆</mi>
   <mn>𝟐</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝐆</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{G_{2}}
  </annotation>
 </semantics>
</math>

 is formed using the remaining 

<math display="inline" id="Distributed_source_coding:62">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi>n</mi>
    <mo>-</mo>
    <msub>
     <mi>R</mi>
     <mn>2</mn>
    </msub>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>n</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>R</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (n-R_{2})
  </annotation>
 </semantics>
</math>


 rows of 

<math display="inline" id="Distributed_source_coding:63">
 <semantics>
  <mi>𝐆</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐆</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{G}
  </annotation>
 </semantics>
</math>

. 

<math display="inline" id="Distributed_source_coding:64">
 <semantics>
  <msub>
   <mi>𝐂</mi>
   <mn>𝟏</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝐂</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{C_{1}}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Distributed_source_coding:65">
 <semantics>
  <msub>
   <mi>𝐂</mi>
   <mn>𝟐</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝐂</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{C_{2}}
  </annotation>
 </semantics>
</math>

 are the subcodes of the Hamming code generated by 

<math display="inline" id="Distributed_source_coding:66">
 <semantics>
  <msub>
   <mi>𝐆</mi>
   <mn>𝟏</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝐆</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{G_{1}}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Distributed_source_coding:67">
 <semantics>
  <msub>
   <mi>𝐆</mi>
   <mn>𝟐</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝐆</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{G_{2}}
  </annotation>
 </semantics>
</math>


 respectively, with 

<math display="inline" id="Distributed_source_coding:68">
 <semantics>
  <msub>
   <mi>𝐇</mi>
   <mn>𝟏</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝐇</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{H_{1}}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Distributed_source_coding:69">
 <semantics>
  <msub>
   <mi>𝐇</mi>
   <mn>𝟐</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝐇</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{H_{2}}
  </annotation>
 </semantics>
</math>

 as their parity check matrices.</p>

<p>For a pair of input 

<math display="inline" id="Distributed_source_coding:70">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>𝐱</mi>
   <mo>,</mo>
   <mi>𝐲</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>𝐱</ci>
    <ci>𝐲</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{(x,y)}
  </annotation>
 </semantics>
</math>

, the encoder is given by 

<math display="inline" id="Distributed_source_coding:71">
 <semantics>
  <mrow>
   <msub>
    <mi>𝐬</mi>
    <mn>𝟏</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>𝐇</mi>
     <mn>𝟏</mn>
    </msub>
    <mi>𝐱</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝐬</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐇</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>𝐱</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{s_{1}}=\mathbf{H_{1}}\mathbf{x}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Distributed_source_coding:72">
 <semantics>
  <mrow>
   <msub>
    <mi>𝐬</mi>
    <mn>𝟐</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>𝐇</mi>
     <mn>𝟐</mn>
    </msub>
    <mi>𝐲</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝐬</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐇</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>𝐲</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{s_{2}}=\mathbf{H_{2}}\mathbf{y}
  </annotation>
 </semantics>
</math>


. That means, we can represent 

<math display="inline" id="Distributed_source_coding:73">
 <semantics>
  <mi>𝐱</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐱</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{x}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Distributed_source_coding:74">
 <semantics>
  <mi>𝐲</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐲</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{y}
  </annotation>
 </semantics>
</math>

 as 

<math display="inline" id="Distributed_source_coding:75">
 <semantics>
  <mrow>
   <mi>𝐱</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>𝐮</mi>
      <mn>𝟏</mn>
     </msub>
     <msub>
      <mi>𝐆</mi>
      <mn>𝟏</mn>
     </msub>
    </mrow>
    <mo>+</mo>
    <msub>
     <mi>𝐜</mi>
     <mi>𝐬𝟏</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>𝐱</ci>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐮</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐆</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐜</ci>
      <ci>𝐬𝟏</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{x=u_{1}G_{1}+c_{s1}}
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Distributed_source_coding:76">
 <semantics>
  <mrow>
   <mi>𝐲</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>𝐮</mi>
      <mn>𝟐</mn>
     </msub>
     <msub>
      <mi>𝐆</mi>
      <mn>𝟐</mn>
     </msub>
    </mrow>
    <mo>+</mo>
    <msub>
     <mi>𝐜</mi>
     <mi>𝐬𝟐</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>𝐲</ci>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐮</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐆</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐜</ci>
      <ci>𝐬𝟐</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{y=u_{2}G_{2}+c_{s2}}
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Distributed_source_coding:77">
 <semantics>
  <mrow>
   <msub>
    <mi>𝐜</mi>
    <mi>𝐬𝟏</mi>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>𝐜</mi>
    <mi>𝐬𝟐</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝐜</ci>
     <ci>𝐬𝟏</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝐜</ci>
     <ci>𝐬𝟐</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{c_{s1},c_{s2}}
  </annotation>
 </semantics>
</math>


 are the representatives of the cosets of 

<math display="inline" id="Distributed_source_coding:78">
 <semantics>
  <mrow>
   <mi>𝐬𝟏</mi>
   <mo>,</mo>
   <mi>𝐬𝟐</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>𝐬𝟏</ci>
    <ci>𝐬𝟐</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{s1,s2}
  </annotation>
 </semantics>
</math>

 with regard to 

<math display="inline" id="Distributed_source_coding:79">
 <semantics>
  <mrow>
   <msub>
    <mi>𝐂</mi>
    <mn>𝟏</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>𝐂</mi>
    <mn>𝟐</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝐂</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝐂</ci>
     <cn type="integer">2</cn>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{C_{1},C_{2}}
  </annotation>
 </semantics>
</math>

 respectively. Since we have 

<math display="inline" id="Distributed_source_coding:80">
 <semantics>
  <mrow>
   <mi>𝐲</mi>
   <mo>=</mo>
   <mrow>
    <mi>𝐱</mi>
    <mo>+</mo>
    <mi>𝐞</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>𝐲</ci>
    <apply>
     <plus></plus>
     <ci>𝐱</ci>
     <ci>𝐞</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{y=x+e}
  </annotation>
 </semantics>
</math>

 with 

<math display="inline" id="Distributed_source_coding:81">
 <semantics>
  <mrow>
   <mrow>
    <mi>w</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>𝐞</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mi>t</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <times></times>
     <ci>w</ci>
     <ci>𝐞</ci>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w(\mathbf{e})\leq t
  </annotation>
 </semantics>
</math>

. We can get 

<math display="inline" id="Distributed_source_coding:82">
 <semantics>
  <mrow>
   <mrow>
    <mi>𝐱</mi>
    <mo>+</mo>
    <mi>𝐲</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>𝐮𝐆</mi>
    <mo>+</mo>
    <msub>
     <mi>𝐜</mi>
     <mi>𝐬</mi>
    </msub>
   </mrow>
   <mo>=</mo>
   <mi>𝐞</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <plus></plus>
      <ci>𝐱</ci>
      <ci>𝐲</ci>
     </apply>
     <apply>
      <plus></plus>
      <ci>𝐮𝐆</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐜</ci>
       <ci>𝐬</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <ci>𝐞</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{x+y=uG+c_{s}=e}
  </annotation>
 </semantics>
</math>


, where 

<math display="inline" id="Distributed_source_coding:83">
 <semantics>
  <mrow>
   <mi>𝐮</mi>
   <mo>=</mo>
   <mrow>
    <mo>[</mo>
    <msub>
     <mi>𝐮</mi>
     <mn>𝟏</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>𝐮</mi>
     <mn>𝟐</mn>
    </msub>
    <mo>]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>𝐮</ci>
    <interval closure="closed">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐮</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐮</ci>
      <cn type="integer">2</cn>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{u=\left[u_{1},u_{2}\right]}
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Distributed_source_coding:84">
 <semantics>
  <mrow>
   <msub>
    <mi>𝐜</mi>
    <mi>𝐬</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>𝐜</mi>
     <mi>𝐬𝟏</mi>
    </msub>
    <mo>+</mo>
    <msub>
     <mi>𝐜</mi>
     <mi>𝐬𝟐</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝐜</ci>
     <ci>𝐬</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐜</ci>
      <ci>𝐬𝟏</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐜</ci>
      <ci>𝐬𝟐</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{c_{s}=c_{s1}+c_{s2}}
  </annotation>
 </semantics>
</math>

.</p>

<p>Suppose there are two different input pairs with the same syndromes, that means there are two different strings 

<math display="inline" id="Distributed_source_coding:85">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>𝐮</mi>
     <mn>𝟏</mn>
    </msup>
    <mo>,</mo>
    <msup>
     <mi>𝐮</mi>
     <mn>𝟐</mn>
    </msup>
   </mrow>
   <mo>∈</mo>
   <msup>
    <mrow>
     <mo>{</mo>
     <mn>0</mn>
     <mo>,</mo>
     <mn>1</mn>
     <mo>}</mo>
    </mrow>
    <mi>k</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <list>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>𝐮</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>𝐮</ci>
      <cn type="integer">2</cn>
     </apply>
    </list>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <set>
      <cn type="integer">0</cn>
      <cn type="integer">1</cn>
     </set>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{u^{1},u^{2}}\in\left\{0,1\right\}^{k}
  </annotation>
 </semantics>
</math>

, such that 

<math display="inline" id="Distributed_source_coding:86">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msup>
      <mi>𝐮</mi>
      <mn>𝟏</mn>
     </msup>
     <mi>𝐆</mi>
    </mrow>
    <mo>+</mo>
    <msub>
     <mi>𝐜</mi>
     <mi>𝐬</mi>
    </msub>
   </mrow>
   <mo>=</mo>
   <mi>𝐞</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>𝐮</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>𝐆</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐜</ci>
      <ci>𝐬</ci>
     </apply>
    </apply>
    <ci>𝐞</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{u^{1}G+c_{s}=e}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Distributed_source_coding:87">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msup>
      <mi>𝐮</mi>
      <mn>𝟐</mn>
     </msup>
     <mi>𝐆</mi>
    </mrow>
    <mo>+</mo>
    <msub>
     <mi>𝐜</mi>
     <mi>𝐬</mi>
    </msub>
   </mrow>
   <mo>=</mo>
   <mi>𝐞</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>𝐮</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>𝐆</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐜</ci>
      <ci>𝐬</ci>
     </apply>
    </apply>
    <ci>𝐞</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{u^{2}G+c_{s}=e}
  </annotation>
 </semantics>
</math>


. Thus we will have 

<math display="inline" id="Distributed_source_coding:88">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msup>
       <mi>𝐮</mi>
       <mn>𝟏</mn>
      </msup>
      <mo>-</mo>
      <msup>
       <mi>𝐮</mi>
       <mn>𝟐</mn>
      </msup>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>𝐆</mi>
   </mrow>
   <mo>=</mo>
   <mn>𝟎</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>𝐮</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>𝐮</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <ci>𝐆</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{(u^{1}-u^{2})G=0}
  </annotation>
 </semantics>
</math>

. Because minimum Hamming weight of the code 

<math display="inline" id="Distributed_source_coding:89">
 <semantics>
  <mi>𝐂</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐂</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{C}
  </annotation>
 </semantics>
</math>

 is 

<math display="inline" id="Distributed_source_coding:90">
 <semantics>
  <mrow>
   <mrow>
    <mn>2</mn>
    <mi>t</mi>
   </mrow>
   <mo>+</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <times></times>
     <cn type="integer">2</cn>
     <ci>t</ci>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2t+1
  </annotation>
 </semantics>
</math>

, the distance between 

<math display="inline" id="Distributed_source_coding:91">
 <semantics>
  <mrow>
   <msub>
    <mi>𝐮</mi>
    <mn>𝟏</mn>
   </msub>
   <mi>𝐆</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝐮</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>𝐆</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{u_{1}G}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Distributed_source_coding:92">
 <semantics>
  <mrow>
   <msub>
    <mi>𝐮</mi>
    <mn>𝟐</mn>
   </msub>
   <mi>𝐆</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝐮</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>𝐆</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{u_{2}G}
  </annotation>
 </semantics>
</math>


 is 

<math display="inline" id="Distributed_source_coding:93">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>≥</mo>
   <mrow>
    <mrow>
     <mn>2</mn>
     <mi>t</mi>
    </mrow>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <csymbol cd="latexml">absent</csymbol>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <ci>t</ci>
     </apply>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \geq 2t+1
  </annotation>
 </semantics>
</math>

. On the other hand, according to 

<math display="inline" id="Distributed_source_coding:94">
 <semantics>
  <mrow>
   <mrow>
    <mi>w</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>𝐞</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mi>t</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <times></times>
     <ci>w</ci>
     <ci>𝐞</ci>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w(\mathbf{e})\leq t
  </annotation>
 </semantics>
</math>

 together with 

<math display="inline" id="Distributed_source_coding:95">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msup>
      <mi>𝐮</mi>
      <mn>𝟏</mn>
     </msup>
     <mi>𝐆</mi>
    </mrow>
    <mo>+</mo>
    <msub>
     <mi>𝐜</mi>
     <mi>𝐬</mi>
    </msub>
   </mrow>
   <mo>=</mo>
   <mi>𝐞</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>𝐮</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>𝐆</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐜</ci>
      <ci>𝐬</ci>
     </apply>
    </apply>
    <ci>𝐞</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{u^{1}G+c_{s}=e}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Distributed_source_coding:96">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msup>
      <mi>𝐮</mi>
      <mn>𝟐</mn>
     </msup>
     <mi>𝐆</mi>
    </mrow>
    <mo>+</mo>
    <msub>
     <mi>𝐜</mi>
     <mi>𝐬</mi>
    </msub>
   </mrow>
   <mo>=</mo>
   <mi>𝐞</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>𝐮</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>𝐆</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐜</ci>
      <ci>𝐬</ci>
     </apply>
    </apply>
    <ci>𝐞</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{u^{2}G+c_{s}=e}
  </annotation>
 </semantics>
</math>

, we will have 

<math display="inline" id="Distributed_source_coding:97">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>d</mi>
     <mi>H</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msup>
       <mi>𝐮</mi>
       <mn>𝟏</mn>
      </msup>
      <mi>𝐆</mi>
     </mrow>
     <mo>,</mo>
     <msub>
      <mi>𝐜</mi>
      <mi>𝐬</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mi>t</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>d</ci>
      <ci>H</ci>
     </apply>
     <interval closure="open">
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>𝐮</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>𝐆</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐜</ci>
       <ci>𝐬</ci>
      </apply>
     </interval>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d_{H}(\mathbf{u^{1}G,c_{s}})\leq t
  </annotation>
 </semantics>
</math>


 and 

<math display="inline" id="Distributed_source_coding:98">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>d</mi>
     <mi>H</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msup>
       <mi>𝐮</mi>
       <mn>𝟐</mn>
      </msup>
      <mi>𝐆</mi>
     </mrow>
     <mo>,</mo>
     <msub>
      <mi>𝐜</mi>
      <mi>𝐬</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mi>t</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>d</ci>
      <ci>H</ci>
     </apply>
     <interval closure="open">
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>𝐮</ci>
        <cn type="integer">2</cn>
       </apply>
       <ci>𝐆</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐜</ci>
       <ci>𝐬</ci>
      </apply>
     </interval>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d_{H}(\mathbf{u^{2}G,c_{s}})\leq t
  </annotation>
 </semantics>
</math>

, which contradict with 

<math display="inline" id="Distributed_source_coding:99">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>d</mi>
     <mi>H</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msup>
       <mi>𝐮</mi>
       <mn>𝟏</mn>
      </msup>
      <mi>𝐆</mi>
     </mrow>
     <mo>,</mo>
     <mrow>
      <msup>
       <mi>𝐮</mi>
       <mn>𝟐</mn>
      </msup>
      <mi>𝐆</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≥</mo>
   <mrow>
    <mrow>
     <mn>2</mn>
     <mi>t</mi>
    </mrow>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>d</ci>
      <ci>H</ci>
     </apply>
     <interval closure="open">
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>𝐮</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>𝐆</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>𝐮</ci>
        <cn type="integer">2</cn>
       </apply>
       <ci>𝐆</ci>
      </apply>
     </interval>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <ci>t</ci>
     </apply>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d_{H}(\mathbf{u^{1}G,u^{2}G})\geq 2t+1
  </annotation>
 </semantics>
</math>

. Therefore, we cannot have more than one input pairs with the same syndromes.</p>

<p>Therefore, we can successfully compress the two dependent sources with constructed subcodes from an 

<math display="inline" id="Distributed_source_coding:100">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>n</mi>
   <mo>,</mo>
   <mi>k</mi>
   <mo>,</mo>
   <mrow>
    <mrow>
     <mn>2</mn>
     <mi>t</mi>
    </mrow>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <ci>n</ci>
    <ci>k</ci>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <ci>t</ci>
     </apply>
     <cn type="integer">1</cn>
    </apply>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (n,k,2t+1)
  </annotation>
 </semantics>
</math>

 binary linear code, with rate pair 

<math display="inline" id="Distributed_source_coding:101">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msub>
    <mi>R</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>R</mi>
    <mn>2</mn>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>R</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>R</ci>
     <cn type="integer">2</cn>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (R_{1},R_{2})
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Distributed_source_coding:102">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>R</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>R</mi>
      <mn>2</mn>
     </msub>
    </mrow>
    <mo>≥</mo>
    <mrow>
     <mi>n</mi>
     <mo>-</mo>
     <mi>k</mi>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>R</mi>
      <mn>1</mn>
     </msub>
     <mo>+</mo>
     <msub>
      <mi>R</mi>
      <mn>2</mn>
     </msub>
    </mrow>
    <mo>≥</mo>
    <mrow>
     <mrow>
      <mn>2</mn>
      <mi>n</mi>
     </mrow>
     <mo>-</mo>
     <mi>k</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <geq></geq>
     <list>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>R</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>R</ci>
       <cn type="integer">2</cn>
      </apply>
     </list>
     <apply>
      <minus></minus>
      <ci>n</ci>
      <ci>k</ci>
     </apply>
    </apply>
    <apply>
     <geq></geq>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>R</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>R</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>n</ci>
      </apply>
      <ci>k</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{1},R_{2}\geq n-k,R_{1}+R_{2}\geq 2n-k
  </annotation>
 </semantics>
</math>


, where 

<math display="inline" id="Distributed_source_coding:103">
 <semantics>
  <msub>
   <mi>R</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>R</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{1}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Distributed_source_coding:104">
 <semantics>
  <msub>
   <mi>R</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>R</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{2}
  </annotation>
 </semantics>
</math>

 are integers, and 

<math display="inline" id="Distributed_source_coding:105">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>≤</mo>
   <mrow>
    <mi>n</mi>
    <mo>-</mo>
    <mrow>
     <mi>log</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msubsup>
        <mo largeop="true" symmetric="true">∑</mo>
        <mrow>
         <mi>i</mi>
         <mo>=</mo>
         <mn>0</mn>
        </mrow>
        <mi>t</mi>
       </msubsup>
       <mrow>
        <mo>(</mo>
        <mstyle scriptlevel="+1">
         <mtable columnspacing="0.4em" rowspacing="0.2ex">
          <mtr>
           <mtd>
            <mi>n</mi>
           </mtd>
          </mtr>
          <mtr>
           <mtd>
            <mi>i</mi>
           </mtd>
          </mtr>
         </mtable>
        </mstyle>
        <mo>)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <ci>k</ci>
    <apply>
     <minus></minus>
     <ci>n</ci>
     <apply>
      <log></log>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <ci>i</ci>
          <cn type="integer">0</cn>
         </apply>
        </apply>
        <ci>t</ci>
       </apply>
       <apply>
        <csymbol cd="latexml">binomial</csymbol>
        <ci>n</ci>
        <ci>i</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k\leq n-\log(\sum_{i=0}^{t}{n\choose i})
  </annotation>
 </semantics>
</math>

. <em>Log</em> indicates <em>Log<sub>2</sub></em>.</p>
<h4 id="slepianwolf-coding-example">Slepian–Wolf coding example</h4>

<p>Take the same example as in the previous <strong>Asymmetric DSC vs. Symmetric DSC</strong> part, this part presents the corresponding DSC schemes with coset codes and syndromes including asymmetric case and symmetric case. The Slepian–Wolf bound for DSC design is shown in the previous part.</p>
<h5 id="asymmetric-case-r_x3-r_y7">Asymmetric case (

<math display="inline" id="Distributed_source_coding:106">
 <semantics>
  <mrow>
   <msub>
    <mi>R</mi>
    <mi>X</mi>
   </msub>
   <mo>=</mo>
   <mn>3</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>R</ci>
     <ci>X</ci>
    </apply>
    <cn type="integer">3</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{X}=3
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Distributed_source_coding:107">
 <semantics>
  <mrow>
   <msub>
    <mi>R</mi>
    <mi>Y</mi>
   </msub>
   <mo>=</mo>
   <mn>7</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>R</ci>
     <ci>Y</ci>
    </apply>
    <cn type="integer">7</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{Y}=7
  </annotation>
 </semantics>
</math>


)</h5>

<p>In this case, the length of an input variable 

<math display="inline" id="Distributed_source_coding:108">
 <semantics>
  <mi>𝐲</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐲</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{y}
  </annotation>
 </semantics>
</math>

 from source 

<math display="inline" id="Distributed_source_coding:109">
 <semantics>
  <mi>Y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y
  </annotation>
 </semantics>
</math>

 is 7 bits, therefore it can be sent lossless with 7 bits independent of any other bits. Based on the knowledge that 

<math display="inline" id="Distributed_source_coding:110">
 <semantics>
  <mi>𝐱</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐱</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{x}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Distributed_source_coding:111">
 <semantics>
  <mi>𝐲</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐲</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{y}
  </annotation>
 </semantics>
</math>

 have Hamming distance at most one, for input 

<math display="inline" id="Distributed_source_coding:112">
 <semantics>
  <mi>𝐱</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐱</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{x}
  </annotation>
 </semantics>
</math>


 from source 

<math display="inline" id="Distributed_source_coding:113">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

, since the receiver already has 

<math display="inline" id="Distributed_source_coding:114">
 <semantics>
  <mi>𝐲</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐲</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{y}
  </annotation>
 </semantics>
</math>

, the only possible 

<math display="inline" id="Distributed_source_coding:115">
 <semantics>
  <mi>𝐱</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐱</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{x}
  </annotation>
 </semantics>
</math>

 are those with at most 1 distance from 

<math display="inline" id="Distributed_source_coding:116">
 <semantics>
  <mi>𝐲</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐲</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{y}
  </annotation>
 </semantics>
</math>

. If we model the correlation between two sources as a virtual channel, which has input 

<math display="inline" id="Distributed_source_coding:117">
 <semantics>
  <mi>𝐱</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐱</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{x}
  </annotation>
 </semantics>
</math>


 and output 

<math display="inline" id="Distributed_source_coding:118">
 <semantics>
  <mi>𝐲</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐲</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{y}
  </annotation>
 </semantics>
</math>

, as long as we get 

<math display="inline" id="Distributed_source_coding:119">
 <semantics>
  <mi>𝐲</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐲</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{y}
  </annotation>
 </semantics>
</math>

, all we need to successfully "decode" 

<math display="inline" id="Distributed_source_coding:120">
 <semantics>
  <mi>𝐱</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐱</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{x}
  </annotation>
 </semantics>
</math>

 is "parity bits" with particular error correction ability, taking the difference between 

<math display="inline" id="Distributed_source_coding:121">
 <semantics>
  <mi>𝐱</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐱</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{x}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Distributed_source_coding:122">
 <semantics>
  <mi>𝐲</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐲</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{y}
  </annotation>
 </semantics>
</math>


 as channel error. We can also model the problem with cosets partition. That is, we want to find a channel code, which is able to partition the space of input 

<math display="inline" id="Distributed_source_coding:123">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

 into several cosets, where each coset has a unique syndrome associated with it. With a given coset and 

<math display="inline" id="Distributed_source_coding:124">
 <semantics>
  <mi>𝐲</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐲</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{y}
  </annotation>
 </semantics>
</math>

, there is only one 

<math display="inline" id="Distributed_source_coding:125">
 <semantics>
  <mi>𝐱</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐱</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{x}
  </annotation>
 </semantics>
</math>

 that is possible to be the input given the correlation between two sources.</p>

<p>In this example, we can use the 

<math display="inline" id="Distributed_source_coding:126">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mn>7</mn>
   <mo>,</mo>
   <mn>4</mn>
   <mo>,</mo>
   <mn>3</mn>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <cn type="integer">7</cn>
    <cn type="integer">4</cn>
    <cn type="integer">3</cn>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (7,4,3)
  </annotation>
 </semantics>
</math>

 binary <a href="Hamming_Code" title="wikilink">Hamming Code</a> 

<math display="inline" id="Distributed_source_coding:127">
 <semantics>
  <mi>𝐂</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐂</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{C}
  </annotation>
 </semantics>
</math>


, with parity check matrix 

<math display="inline" id="Distributed_source_coding:128">
 <semantics>
  <mi>𝐇</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐇</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{H}
  </annotation>
 </semantics>
</math>

. For an input 

<math display="inline" id="Distributed_source_coding:129">
 <semantics>
  <mi>𝐱</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐱</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{x}
  </annotation>
 </semantics>
</math>

 from source 

<math display="inline" id="Distributed_source_coding:130">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

, only the syndrome given by 

<math display="inline" id="Distributed_source_coding:131">
 <semantics>
  <mrow>
   <mi>𝐬</mi>
   <mo>=</mo>
   <mi>𝐇𝐱</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>𝐬</ci>
    <ci>𝐇𝐱</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{s}=\mathbf{H}\mathbf{x}
  </annotation>
 </semantics>
</math>

 is transmitted, which is 3 bits. With received 

<math display="inline" id="Distributed_source_coding:132">
 <semantics>
  <mi>𝐲</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐲</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{y}
  </annotation>
 </semantics>
</math>


 and 

<math display="inline" id="Distributed_source_coding:133">
 <semantics>
  <mi>𝐬</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐬</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{s}
  </annotation>
 </semantics>
</math>

, suppose there are two inputs 

<math display="inline" id="Distributed_source_coding:134">
 <semantics>
  <msub>
   <mi>𝐱</mi>
   <mn>𝟏</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝐱</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{x_{1}}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Distributed_source_coding:135">
 <semantics>
  <msub>
   <mi>𝐱</mi>
   <mn>𝟐</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝐱</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{x_{2}}
  </annotation>
 </semantics>
</math>

 with same syndrome 

<math display="inline" id="Distributed_source_coding:136">
 <semantics>
  <mi>𝐬</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐬</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{s}
  </annotation>
 </semantics>
</math>

. That means 

<math display="inline" id="Distributed_source_coding:137">
 <semantics>
  <mrow>
   <msub>
    <mi>𝐇𝐱</mi>
    <mn>𝟏</mn>
   </msub>
   <mo>=</mo>
   <msub>
    <mi>𝐇𝐱</mi>
    <mn>𝟐</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝐇𝐱</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝐇𝐱</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{H}\mathbf{x_{1}}=\mathbf{H}\mathbf{x_{2}}
  </annotation>
 </semantics>
</math>


, which is 

<math display="inline" id="Distributed_source_coding:138">
 <semantics>
  <mrow>
   <mrow>
    <mi>𝐇</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>𝐱</mi>
       <mn>𝟏</mn>
      </msub>
      <mo>-</mo>
      <msub>
       <mi>𝐱</mi>
       <mn>𝟐</mn>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>𝐇</ci>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐱</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐱</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{H}(\mathbf{x_{1}}-\mathbf{x_{2}})=0
  </annotation>
 </semantics>
</math>

. Since the minimum Hamming weight of 

<math display="inline" id="Distributed_source_coding:139">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mn>7</mn>
   <mo>,</mo>
   <mn>4</mn>
   <mo>,</mo>
   <mn>3</mn>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <cn type="integer">7</cn>
    <cn type="integer">4</cn>
    <cn type="integer">3</cn>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (7,4,3)
  </annotation>
 </semantics>
</math>

 Hamming Code is 3, 

<math display="inline" id="Distributed_source_coding:140">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>d</mi>
     <mi>H</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>𝐱</mi>
      <mn>𝟏</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>𝐱</mi>
      <mn>𝟐</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≥</mo>
   <mn>3</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>d</ci>
      <ci>H</ci>
     </apply>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐱</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐱</ci>
       <cn type="integer">2</cn>
      </apply>
     </interval>
    </apply>
    <cn type="integer">3</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d_{H}(\mathbf{x_{1}},\mathbf{x_{2}})\geq 3
  </annotation>
 </semantics>
</math>

. Therefore the input 

<math display="inline" id="Distributed_source_coding:141">
 <semantics>
  <mi>𝐱</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐱</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{x}
  </annotation>
 </semantics>
</math>

 can be recovered since 

<math display="inline" id="Distributed_source_coding:142">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>d</mi>
     <mi>H</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>𝐱</mi>
     <mo>,</mo>
     <mi>𝐲</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>d</ci>
      <ci>H</ci>
     </apply>
     <interval closure="open">
      <ci>𝐱</ci>
      <ci>𝐲</ci>
     </interval>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d_{H}(\mathbf{x},\mathbf{y})\leq 1
  </annotation>
 </semantics>
</math>


.</p>

<p>Similarly, the bits distribution with 

<math display="inline" id="Distributed_source_coding:143">
 <semantics>
  <mrow>
   <msub>
    <mi>R</mi>
    <mi>X</mi>
   </msub>
   <mo>=</mo>
   <mn>7</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>R</ci>
     <ci>X</ci>
    </apply>
    <cn type="integer">7</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{X}=7
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Distributed_source_coding:144">
 <semantics>
  <mrow>
   <msub>
    <mi>R</mi>
    <mi>Y</mi>
   </msub>
   <mo>=</mo>
   <mn>3</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>R</ci>
     <ci>Y</ci>
    </apply>
    <cn type="integer">3</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{Y}=3
  </annotation>
 </semantics>
</math>

 can be achieved by reversing the roles of 

<math display="inline" id="Distributed_source_coding:145">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Distributed_source_coding:146">
 <semantics>
  <mi>Y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y
  </annotation>
 </semantics>
</math>

.</p>
<h5 id="symmetric-case">Symmetric case</h5>

<p>In symmetric case, what we want is equal bitrate for the two sources: 5 bits each with separate encoder and joint decoder. We still use linear codes for this system, as we used for asymmetric case. The basic idea is similar, but in this case, we need to do coset partition for both sources, while for a pair of received syndromes (corresponds to one coset), only one pair of input variables are possible given the correlation between two sources.</p>

<p>Suppose we have a pair of <a href="linear_code" title="wikilink">linear code</a> 

<math display="inline" id="Distributed_source_coding:147">
 <semantics>
  <msub>
   <mi>𝐂</mi>
   <mn>𝟏</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝐂</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{C_{1}}
  </annotation>
 </semantics>
</math>


 and 

<math display="inline" id="Distributed_source_coding:148">
 <semantics>
  <msub>
   <mi>𝐂</mi>
   <mn>𝟐</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝐂</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{C_{2}}
  </annotation>
 </semantics>
</math>

 and an encoder-decoder pair based on linear codes which can achieve symmetric coding. The encoder output is given by

<math display="block" id="Distributed_source_coding:149">
 <semantics>
  <mrow>
   <msub>
    <mi>𝐬</mi>
    <mn>𝟏</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>𝐇</mi>
     <mn>𝟏</mn>
    </msub>
    <mi>𝐱</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝐬</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐇</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>𝐱</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{s_{1}}=\mathbf{H_{1}}\mathbf{x}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Distributed_source_coding:150">
 <semantics>
  <mrow>
   <msub>
    <mi>𝐬</mi>
    <mn>𝟐</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>𝐇</mi>
     <mn>𝟐</mn>
    </msub>
    <mi>𝐲</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝐬</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐇</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>𝐲</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{s_{2}}=\mathbf{H_{2}}\mathbf{y}
  </annotation>
 </semantics>
</math>

. If there exists two pair of valid inputs 

<math display="inline" id="Distributed_source_coding:151">
 <semantics>
  <mrow>
   <msub>
    <mi>𝐱</mi>
    <mn>𝟏</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>𝐲</mi>
    <mn>𝟏</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝐱</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝐲</ci>
     <cn type="integer">1</cn>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{x_{1}},\mathbf{y_{1}}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Distributed_source_coding:152">
 <semantics>
  <mrow>
   <msub>
    <mi>𝐱</mi>
    <mn>𝟐</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>𝐲</mi>
    <mn>𝟐</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝐱</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝐲</ci>
     <cn type="integer">2</cn>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{x_{2}},\mathbf{y_{2}}
  </annotation>
 </semantics>
</math>


 generating the same syndromes, i.e. 

<math display="inline" id="Distributed_source_coding:153">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>𝐇</mi>
     <mn>𝟏</mn>
    </msub>
    <msub>
     <mi>𝐱</mi>
     <mn>𝟏</mn>
    </msub>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>𝐇</mi>
     <mn>𝟏</mn>
    </msub>
    <msub>
     <mi>𝐱</mi>
     <mn>𝟐</mn>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐇</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐱</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐇</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐱</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{H_{1}}\mathbf{x_{1}}=\mathbf{H_{1}}\mathbf{x_{2}}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Distributed_source_coding:154">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>𝐇</mi>
     <mn>𝟏</mn>
    </msub>
    <msub>
     <mi>𝐲</mi>
     <mn>𝟏</mn>
    </msub>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>𝐇</mi>
     <mn>𝟏</mn>
    </msub>
    <msub>
     <mi>𝐲</mi>
     <mn>𝟐</mn>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐇</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐲</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐇</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐲</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{H_{1}}\mathbf{y_{1}}=\mathbf{H_{1}}\mathbf{y_{2}}
  </annotation>
 </semantics>
</math>

, we can get following(

<math display="inline" id="Distributed_source_coding:155">
 <semantics>
  <mrow>
   <mi>w</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>w</ci>
    <list></list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w()
  </annotation>
 </semantics>
</math>

 represents Hamming weight):</p>

<p>

<math display="inline" id="Distributed_source_coding:156">
 <semantics>
  <mrow>
   <msub>
    <mi>𝐲</mi>
    <mn>𝟏</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>𝐱</mi>
     <mn>𝟏</mn>
    </msub>
    <mo>+</mo>
    <msub>
     <mi>𝐞</mi>
     <mn>𝟏</mn>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝐲</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐱</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐞</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{y_{1}}=\mathbf{x_{1}}+\mathbf{e_{1}}
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Distributed_source_coding:157">
 <semantics>
  <mrow>
   <mrow>
    <mi>w</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>𝐞</mi>
      <mn>𝟏</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <times></times>
     <ci>w</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐞</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w(\mathbf{e_{1}})\leq 1
  </annotation>
 </semantics>
</math>


 

<math display="inline" id="Distributed_source_coding:158">
 <semantics>
  <mrow>
   <msub>
    <mi>𝐲</mi>
    <mn>𝟐</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>𝐱</mi>
     <mn>𝟐</mn>
    </msub>
    <mo>+</mo>
    <msub>
     <mi>𝐞</mi>
     <mn>𝟐</mn>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝐲</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐱</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐞</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{y_{2}}=\mathbf{x_{2}}+\mathbf{e_{2}}
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Distributed_source_coding:159">
 <semantics>
  <mrow>
   <mrow>
    <mi>w</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>𝐞</mi>
      <mn>𝟐</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <times></times>
     <ci>w</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐞</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w(\mathbf{e_{2}})\leq 1
  </annotation>
 </semantics>
</math>

</p>

<p>Thus

<math display="block" id="Distributed_source_coding:160">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>𝐱</mi>
     <mn>𝟏</mn>
    </msub>
    <mo>+</mo>
    <msub>
     <mi>𝐱</mi>
     <mn>𝟐</mn>
    </msub>
   </mrow>
   <mo>∈</mo>
   <msub>
    <mi>𝐂</mi>
    <mn>𝟏</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐱</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐱</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝐂</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{x_{1}}+\mathbf{x_{2}}\in\mathbf{C_{1}}
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Distributed_source_coding:161">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>𝐲</mi>
     <mn>𝟏</mn>
    </msub>
    <mo>+</mo>
    <msub>
     <mi>𝐲</mi>
     <mn>𝟐</mn>
    </msub>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>𝐱</mi>
     <mn>𝟏</mn>
    </msub>
    <mo>+</mo>
    <msub>
     <mi>𝐱</mi>
     <mn>𝟐</mn>
    </msub>
    <mo>+</mo>
    <msub>
     <mi>𝐞</mi>
     <mn>𝟑</mn>
    </msub>
   </mrow>
   <mo>∈</mo>
   <msub>
    <mi>𝐂</mi>
    <mn>𝟐</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐲</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐲</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐱</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐱</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐞</ci>
       <cn type="integer">3</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <in></in>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐂</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{y_{1}}+\mathbf{y_{2}}=\mathbf{x_{1}}+\mathbf{x_{2}}+\mathbf{e_{3}}\in%
\mathbf{C_{2}}
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Distributed_source_coding:162">
 <semantics>
  <mrow>
   <msub>
    <mi>𝐞</mi>
    <mn>𝟑</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>𝐞</mi>
     <mn>𝟐</mn>
    </msub>
    <mo>+</mo>
    <msub>
     <mi>𝐞</mi>
     <mn>𝟏</mn>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝐞</ci>
     <cn type="integer">3</cn>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐞</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐞</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{e_{3}}=\mathbf{e_{2}}+\mathbf{e_{1}}
  </annotation>
 </semantics>
</math>


 and 

<math display="inline" id="Distributed_source_coding:163">
 <semantics>
  <mrow>
   <mrow>
    <mi>w</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>𝐞</mi>
      <mn>𝟑</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <times></times>
     <ci>w</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐞</ci>
      <cn type="integer">3</cn>
     </apply>
    </apply>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w(\mathbf{e_{3}})\leq 2
  </annotation>
 </semantics>
</math>

. That means, as long as we have the minimum distance between the two codes larger than 

<math display="inline" id="Distributed_source_coding:164">
 <semantics>
  <mn>3</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">3</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   3
  </annotation>
 </semantics>
</math>

, we can achieve error-free decoding.</p>

<p>The two codes 

<math display="inline" id="Distributed_source_coding:165">
 <semantics>
  <msub>
   <mi>𝐂</mi>
   <mn>𝟏</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝐂</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{C_{1}}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Distributed_source_coding:166">
 <semantics>
  <msub>
   <mi>𝐂</mi>
   <mn>𝟐</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝐂</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{C_{2}}
  </annotation>
 </semantics>
</math>

 can be constructed as subcodes of the 

<math display="inline" id="Distributed_source_coding:167">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mn>7</mn>
   <mo>,</mo>
   <mn>4</mn>
   <mo>,</mo>
   <mn>3</mn>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <cn type="integer">7</cn>
    <cn type="integer">4</cn>
    <cn type="integer">3</cn>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (7,4,3)
  </annotation>
 </semantics>
</math>


 Hamming code and thus has minimum distance of 

<math display="inline" id="Distributed_source_coding:168">
 <semantics>
  <mn>3</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">3</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   3
  </annotation>
 </semantics>
</math>

. Given the <a href="generator_matrix" title="wikilink">generator matrix</a> 

<math display="inline" id="Distributed_source_coding:169">
 <semantics>
  <mi>𝐆</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐆</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{G}
  </annotation>
 </semantics>
</math>

 of the original Hamming code, the generator matrix 

<math display="inline" id="Distributed_source_coding:170">
 <semantics>
  <msub>
   <mi>𝐆</mi>
   <mn>𝟏</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝐆</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{G_{1}}
  </annotation>
 </semantics>
</math>

 for 

<math display="inline" id="Distributed_source_coding:171">
 <semantics>
  <msub>
   <mi>𝐂</mi>
   <mn>𝟏</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝐂</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{C_{1}}
  </annotation>
 </semantics>
</math>

 is constructed by taking any two rows from 

<math display="inline" id="Distributed_source_coding:172">
 <semantics>
  <mi>𝐆</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐆</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{G}
  </annotation>
 </semantics>
</math>


, and 

<math display="inline" id="Distributed_source_coding:173">
 <semantics>
  <msub>
   <mi>𝐆</mi>
   <mn>𝟐</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝐆</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{G_{2}}
  </annotation>
 </semantics>
</math>

 is constructed by the remaining two rows of 

<math display="inline" id="Distributed_source_coding:174">
 <semantics>
  <mi>𝐆</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐆</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{G}
  </annotation>
 </semantics>
</math>

. The corresponding 

<math display="inline" id="Distributed_source_coding:175">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mn>5</mn>
    <mo>×</mo>
    <mn>7</mn>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <cn type="integer">5</cn>
    <cn type="integer">7</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (5\times 7)
  </annotation>
 </semantics>
</math>

 <a href="Parity_check_matrix" title="wikilink">parity-check matrix</a> for each sub-code can be generated according to the generator matrix and used to generate syndrome bits.</p>
<h3 id="wynerziv-coding-lossy-distributed-coding">Wyner–Ziv coding – lossy distributed coding</h3>

<p>In general, a Wyner–Ziv coding scheme is obtained by adding a quantizer and a de-quantizer to the Slepian–Wolf coding scheme. Therefore, a Wyner–Ziv coder design could focus on the quantizer and corresponding reconstruction method design. Several quantizer designs have been proposed, such as a nested lattice quantizer,<a class="footnoteRef" href="#fn32" id="fnref32"><sup>32</sup></a> trellis code quantizer<a class="footnoteRef" href="#fn33" id="fnref33"><sup>33</sup></a> and Lloyd quantization method.<a class="footnoteRef" href="#fn34" id="fnref34"><sup>34</sup></a></p>
<h3 id="large-scale-distributed-quantization">Large scale distributed quantization</h3>

<p>Unfortunately, the above approaches do not scale (in design or operational complexity requirements) to sensor networks of large sizes, a scenario where distributed compression is most helpful. If there are N sources transmitting at R bits each (with some distributed coding scheme), the number of possible reconstructions scales 

<math display="inline" id="Distributed_source_coding:176">
 <semantics>
  <msup>
   <mn>2</mn>
   <mrow>
    <mi>N</mi>
    <mi>R</mi>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <apply>
     <times></times>
     <ci>N</ci>
     <ci>R</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{NR}
  </annotation>
 </semantics>
</math>

. Even for moderate values of N and R (say N=10, R = 2), prior design schemes become impractical. Recently, an approach,<a class="footnoteRef" href="#fn35" id="fnref35"><sup>35</sup></a> using ideas borrowed from Fusion Coding of Correlated Sources, has been proposed where design and operational complexity are traded against decoder performance. This has allowed distributed quantizer design for network sizes reaching 60 sources, with substantial gains over traditional approaches.</p>

<p>The central idea is the presence of a bit-subset selector which maintains a certain subset of the received (NR bits, in the above example) bits for each source. Let 

<math display="inline" id="Distributed_source_coding:177">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ℬ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℬ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{B}
  </annotation>
 </semantics>
</math>


 be the set of all subsets of the NR bits i.e.</p>

<p>

<math display="block" id="Distributed_source_coding:178">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">ℬ</mi>
   <mo>=</mo>
   <msup>
    <mn>2</mn>
    <mrow>
     <mo stretchy="false">{</mo>
     <mn>1</mn>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <mrow>
      <mi>N</mi>
      <mi>R</mi>
     </mrow>
     <mo stretchy="false">}</mo>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>ℬ</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <set>
      <cn type="integer">1</cn>
      <ci>normal-…</ci>
      <apply>
       <times></times>
       <ci>N</ci>
       <ci>R</ci>
      </apply>
     </set>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{B}=2^{\{1,...,NR\}}
  </annotation>
 </semantics>
</math>

</p>

<p>Then, we define the bit-subset selector mapping to be<br/>


<math display="block" id="Distributed_source_coding:179">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">𝒮</mi>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">{</mo>
     <mn>1</mn>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <mi>N</mi>
     <mo stretchy="false">}</mo>
    </mrow>
    <mo>→</mo>
    <mi class="ltx_font_mathcaligraphic">ℬ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>𝒮</ci>
    <apply>
     <ci>normal-→</ci>
     <set>
      <cn type="integer">1</cn>
      <ci>normal-…</ci>
      <ci>N</ci>
     </set>
     <ci>ℬ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{S}:\{1,...,N\}\rightarrow\mathcal{B}
  </annotation>
 </semantics>
</math>

</p>

<p>Note that each choice of the bit-subset selector imposes a storage requirement (C) that is exponential in the cardinality of the set of chosen bits.<br/>


<math display="block" id="Distributed_source_coding:180">
 <semantics>
  <mrow>
   <mi>C</mi>
   <mo>=</mo>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>n</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>N</mi>
    </munderover>
    <msup>
     <mn>2</mn>
     <mrow>
      <mo stretchy="false">|</mo>
      <mrow>
       <mi class="ltx_font_mathcaligraphic">𝒮</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>n</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">|</mo>
     </mrow>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>C</ci>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>N</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <apply>
       <abs></abs>
       <apply>
        <times></times>
        <ci>𝒮</ci>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C=\sum_{n=1}^{N}2^{|\mathcal{S}(n)|}
  </annotation>
 </semantics>
</math>

</p>

<p>This allows a judicious choice of bits that minimize the distortion, given the constraints on decoder storage. Additional limitations on the set of allowable subsets are still needed. The effective cost function that needs to be minimized is a weighted sum of distortion and decoder storage<br/>


<math display="block" id="Distributed_source_coding:181">
 <semantics>
  <mrow>
   <mi>J</mi>
   <mo>=</mo>
   <mrow>
    <mi>D</mi>
    <mo>+</mo>
    <mrow>
     <mi>λ</mi>
     <mi>C</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>J</ci>
    <apply>
     <plus></plus>
     <ci>D</ci>
     <apply>
      <times></times>
      <ci>λ</ci>
      <ci>C</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   J=D+\lambda C
  </annotation>
 </semantics>
</math>

</p>

<p>The system design is performed by iteratively (and incrementally) optimizing the encoders, decoder and bit-subset selector till convergence.</p>
<h2 id="non-asymmetric-dsc">Non-asymmetric DSC</h2>
<h2 id="non-asymmetric-dsc-for-more-than-two-sources">Non-asymmetric DSC for more than two sources</h2>

<p>The syndrome approach can still be used for more than two sources. Let us consider 

<math display="inline" id="Distributed_source_coding:182">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>


 binary sources of length-

<math display="inline" id="Distributed_source_coding:183">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Distributed_source_coding:184">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>𝐱</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>𝐱</mi>
     <mn>2</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">⋯</mi>
    <mo>,</mo>
    <msub>
     <mi>𝐱</mi>
     <mi>a</mi>
    </msub>
   </mrow>
   <mo>∈</mo>
   <msup>
    <mrow>
     <mo stretchy="false">{</mo>
     <mn>0</mn>
     <mo>,</mo>
     <mn>1</mn>
     <mo stretchy="false">}</mo>
    </mrow>
    <mi>n</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <list>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐱</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐱</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-⋯</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐱</ci>
      <ci>a</ci>
     </apply>
    </list>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <set>
      <cn type="integer">0</cn>
      <cn type="integer">1</cn>
     </set>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{x}_{1},\mathbf{x}_{2},\cdots,\mathbf{x}_{a}\in\{0,1\}^{n}
  </annotation>
 </semantics>
</math>

. Let 

<math display="inline" id="Distributed_source_coding:185">
 <semantics>
  <mrow>
   <msub>
    <mi>𝐇</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>𝐇</mi>
    <mn>2</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">⋯</mi>
   <mo>,</mo>
   <msub>
    <mi>𝐇</mi>
    <mi>s</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝐇</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝐇</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>normal-⋯</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝐇</ci>
     <ci>s</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{H}_{1},\mathbf{H}_{2},\cdots,\mathbf{H}_{s}
  </annotation>
 </semantics>
</math>

 be the corresponding coding matrices of sizes 

<math display="inline" id="Distributed_source_coding:186">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>m</mi>
     <mn>1</mn>
    </msub>
    <mo>×</mo>
    <mi>n</mi>
   </mrow>
   <mo>,</mo>
   <mrow>
    <msub>
     <mi>m</mi>
     <mn>2</mn>
    </msub>
    <mo>×</mo>
    <mi>n</mi>
   </mrow>
   <mo>,</mo>
   <mi mathvariant="normal">⋯</mi>
   <mo>,</mo>
   <mrow>
    <msub>
     <mi>m</mi>
     <mi>a</mi>
    </msub>
    <mo>×</mo>
    <mi>n</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>m</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>n</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>m</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>n</ci>
    </apply>
    <ci>normal-⋯</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>m</ci>
      <ci>a</ci>
     </apply>
     <ci>n</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m_{1}\times n,m_{2}\times n,\cdots,m_{a}\times n
  </annotation>
 </semantics>
</math>

. Then the input binary sources are compressed into 

<math display="inline" id="Distributed_source_coding:187">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>𝐬</mi>
     <mn>1</mn>
    </msub>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>𝐇</mi>
      <mn>1</mn>
     </msub>
     <msub>
      <mi>𝐱</mi>
      <mn>1</mn>
     </msub>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>𝐬</mi>
      <mn>2</mn>
     </msub>
     <mo>=</mo>
     <mrow>
      <mrow>
       <msub>
        <mi>𝐇</mi>
        <mn>2</mn>
       </msub>
       <msub>
        <mi>𝐱</mi>
        <mn>2</mn>
       </msub>
      </mrow>
      <mo>,</mo>
      <mi mathvariant="normal">⋯</mi>
     </mrow>
    </mrow>
    <mo>,</mo>
    <mrow>
     <msub>
      <mi>𝐬</mi>
      <mi>a</mi>
     </msub>
     <mo>=</mo>
     <mrow>
      <msub>
       <mi>𝐇</mi>
       <mi>a</mi>
      </msub>
      <msub>
       <mi>𝐱</mi>
       <mi>a</mi>
      </msub>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐬</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐇</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐱</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">formulae-sequence</csymbol>
     <apply>
      <eq></eq>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐬</ci>
       <cn type="integer">2</cn>
      </apply>
      <list>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>𝐇</ci>
         <cn type="integer">2</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>𝐱</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
       <ci>normal-⋯</ci>
      </list>
     </apply>
     <apply>
      <eq></eq>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐬</ci>
       <ci>a</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>𝐇</ci>
        <ci>a</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>𝐱</ci>
        <ci>a</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{s}_{1}=\mathbf{H}_{1}\mathbf{x}_{1},\mathbf{s}_{2}=\mathbf{H}_{2}%
\mathbf{x}_{2},\cdots,\mathbf{s}_{a}=\mathbf{H}_{a}\mathbf{x}_{a}
  </annotation>
 </semantics>
</math>


 of total 

<math display="inline" id="Distributed_source_coding:188">
 <semantics>
  <mrow>
   <mi>m</mi>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>m</mi>
     <mn>1</mn>
    </msub>
    <mo>+</mo>
    <msub>
     <mi>m</mi>
     <mn>2</mn>
    </msub>
    <mo>+</mo>
    <mrow>
     <mi mathvariant="normal">⋯</mi>
     <msub>
      <mi>m</mi>
      <mi>a</mi>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>m</ci>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>m</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>m</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <times></times>
      <ci>normal-⋯</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>m</ci>
       <ci>a</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m=m_{1}+m_{2}+\cdots m_{a}
  </annotation>
 </semantics>
</math>

 bits. Apparently, two source tuples cannot be recovered at the same time if they share the same syndrome. In other words, if all source tuples of interest have different syndromes, then one can recover them losslessly.</p>

<p>General theoretical result does not seem to exist. However, for a restricted kind of source so-called Hamming source <a class="footnoteRef" href="#fn36" id="fnref36"><sup>36</sup></a> that only has at most one source different from the rest and at most one bit location not all identical, practical lossless DSC is shown to exist in some cases. For the case when there are more than two sources, the number of source tuple in a Hamming source is 

<math display="inline" id="Distributed_source_coding:189">
 <semantics>
  <mrow>
   <msup>
    <mn>2</mn>
    <mi>n</mi>
   </msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mrow>
      <mi>a</mi>
      <mi>n</mi>
     </mrow>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <ci>n</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>a</ci>
      <ci>n</ci>
     </apply>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{n}(an+1)
  </annotation>
 </semantics>
</math>

. Therefore, a packing bound that 

<math display="inline" id="Distributed_source_coding:190">
 <semantics>
  <mrow>
   <msup>
    <mn>2</mn>
    <mi>m</mi>
   </msup>
   <mo>≥</mo>
   <mrow>
    <msup>
     <mn>2</mn>
     <mi>n</mi>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mi>a</mi>
       <mi>n</mi>
      </mrow>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <ci>m</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <ci>n</ci>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>a</ci>
       <ci>n</ci>
      </apply>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{m}\geq 2^{n}(an+1)
  </annotation>
 </semantics>
</math>

 obviously has to satisfy. When the packing bound is satisfied with equality, we may call such code to be perfect (an analogous of perfect code in error correcting code).<a class="footnoteRef" href="#fn37" id="fnref37"><sup>37</sup></a></p>

<p>A simplest set of 

<math display="inline" id="Distributed_source_coding:191">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo>,</mo>
   <mi>n</mi>
   <mo>,</mo>
   <mi>m</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>a</ci>
    <ci>n</ci>
    <ci>m</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a,n,m
  </annotation>
 </semantics>
</math>

 to satisfy the packing bound with equality is 

<math display="inline" id="Distributed_source_coding:192">
 <semantics>
  <mrow>
   <mrow>
    <mi>a</mi>
    <mo>=</mo>
    <mn>3</mn>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mrow>
     <mi>n</mi>
     <mo>=</mo>
     <mn>5</mn>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mi>m</mi>
     <mo>=</mo>
     <mn>9</mn>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <ci>a</ci>
     <cn type="integer">3</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">formulae-sequence</csymbol>
     <apply>
      <eq></eq>
      <ci>n</ci>
      <cn type="integer">5</cn>
     </apply>
     <apply>
      <eq></eq>
      <ci>m</ci>
      <cn type="integer">9</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a=3,n=5,m=9
  </annotation>
 </semantics>
</math>


. However, it turns out that such syndrome code does not exist.<a class="footnoteRef" href="#fn38" id="fnref38"><sup>38</sup></a> The simplest (perfect) syndrome code with more than two sources have 

<math display="inline" id="Distributed_source_coding:193">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>=</mo>
   <mn>21</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>n</ci>
    <cn type="integer">21</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n=21
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Distributed_source_coding:194">
 <semantics>
  <mrow>
   <mi>m</mi>
   <mo>=</mo>
   <mn>27</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>m</ci>
    <cn type="integer">27</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m=27
  </annotation>
 </semantics>
</math>

. Let</p>

<p>

<math display="inline" id="Distributed_source_coding:195">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>𝐐</mi>
     <mn>1</mn>
    </msub>
    <mo>=</mo>
    <mrow>
     <mo>(</mo>
     <mtable>
      <mtr>
       <mtd columnalign="center">
        <mn>1 0 0 0 0 0 1 0 0 0 0 1 1 1 0 1 1 0 0 0 0</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>0 1 0 0 0 0 1 1 0 0 0 0 1 0 0 0 0 0 1 1 1</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>0 0 1 0 0 0 0 1 1 0 0 0 0 1 1 1 0 1 0 1 1</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>0 0 0 1 0 0 0 0 1 1 0 0 0 1 0 0 1 1 1 1 0</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>0 0 0 0 1 0 0 0 0 1 1 0 1 0 1 1 0 1 1 1 1</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>0 0 0 0 0 1 0 0 0 0 1 1 0 0 1 0 0 1 1 0 1</mn>
       </mtd>
      </mtr>
     </mtable>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝐐</ci>
     <cn type="integer">1</cn>
    </apply>
    <matrix>
     <matrixrow>
      <cn type="float">1 0 0 0 0 0 1 0 0 0 0 1 1 1 0 1 1 0 0 0 0</cn>
     </matrixrow>
     <matrixrow>
      <cn type="float">0 1 0 0 0 0 1 1 0 0 0 0 1 0 0 0 0 0 1 1 1</cn>
     </matrixrow>
     <matrixrow>
      <cn type="float">0 0 1 0 0 0 0 1 1 0 0 0 0 1 1 1 0 1 0 1 1</cn>
     </matrixrow>
     <matrixrow>
      <cn type="float">0 0 0 1 0 0 0 0 1 1 0 0 0 1 0 0 1 1 1 1 0</cn>
     </matrixrow>
     <matrixrow>
      <cn type="float">0 0 0 0 1 0 0 0 0 1 1 0 1 0 1 1 0 1 1 1 1</cn>
     </matrixrow>
     <matrixrow>
      <cn type="float">0 0 0 0 0 1 0 0 0 0 1 1 0 0 1 0 0 1 1 0 1</cn>
     </matrixrow>
    </matrix>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{Q}_{1}=\begin{pmatrix}1\;0\;0\;0\;0\;0\;1\;0\;0\;0\;0\;1\;1\;1\;0\;1\;%
1\;0\;0\;0\;0\\
0\;1\;0\;0\;0\;0\;1\;1\;0\;0\;0\;0\;1\;0\;0\;0\;0\;0\;1\;1\;1\\
0\;0\;1\;0\;0\;0\;0\;1\;1\;0\;0\;0\;0\;1\;1\;1\;0\;1\;0\;1\;1\\
0\;0\;0\;1\;0\;0\;0\;0\;1\;1\;0\;0\;0\;1\;0\;0\;1\;1\;1\;1\;0\\
0\;0\;0\;0\;1\;0\;0\;0\;0\;1\;1\;0\;1\;0\;1\;1\;0\;1\;1\;1\;1\\
0\;0\;0\;0\;0\;1\;0\;0\;0\;0\;1\;1\;0\;0\;1\;0\;0\;1\;1\;0\;1\end{pmatrix},
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Distributed_source_coding:196">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>𝐐</mi>
     <mn>2</mn>
    </msub>
    <mo>=</mo>
    <mrow>
     <mo>(</mo>
     <mtable>
      <mtr>
       <mtd columnalign="center">
        <mn>0 0 0 1 0 1 1 0 1 1 1 1 0 1 0 0 0 1 1 1 1</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>1 0 0 0 1 0 1 1 0 1 1 1 1 0 1 1 1 1 0 0 0</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>0 1 0 0 0 1 1 1 1 0 1 1 1 0 0 0 0 0 1 0 1</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>1 0 1 0 0 0 1 1 1 1 0 1 0 1 1 1 0 0 1 1 1</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>0 1 0 1 0 0 1 1 1 1 1 0 0 0 1 0 1 1 0 1 1</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>0 0 1 0 1 0 0 1 1 1 1 1 1 1 0 1 0 1 1 1 0</mn>
       </mtd>
      </mtr>
     </mtable>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝐐</ci>
     <cn type="integer">2</cn>
    </apply>
    <matrix>
     <matrixrow>
      <cn type="float">0 0 0 1 0 1 1 0 1 1 1 1 0 1 0 0 0 1 1 1 1</cn>
     </matrixrow>
     <matrixrow>
      <cn type="float">1 0 0 0 1 0 1 1 0 1 1 1 1 0 1 1 1 1 0 0 0</cn>
     </matrixrow>
     <matrixrow>
      <cn type="float">0 1 0 0 0 1 1 1 1 0 1 1 1 0 0 0 0 0 1 0 1</cn>
     </matrixrow>
     <matrixrow>
      <cn type="float">1 0 1 0 0 0 1 1 1 1 0 1 0 1 1 1 0 0 1 1 1</cn>
     </matrixrow>
     <matrixrow>
      <cn type="float">0 1 0 1 0 0 1 1 1 1 1 0 0 0 1 0 1 1 0 1 1</cn>
     </matrixrow>
     <matrixrow>
      <cn type="float">0 0 1 0 1 0 0 1 1 1 1 1 1 1 0 1 0 1 1 1 0</cn>
     </matrixrow>
    </matrix>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{Q}_{2}=\begin{pmatrix}0\;0\;0\;1\;0\;1\;1\;0\;1\;1\;1\;1\;0\;1\;0\;0\;%
0\;1\;1\;1\;1\\
1\;0\;0\;0\;1\;0\;1\;1\;0\;1\;1\;1\;1\;0\;1\;1\;1\;1\;0\;0\;0\\
0\;1\;0\;0\;0\;1\;1\;1\;1\;0\;1\;1\;1\;0\;0\;0\;0\;0\;1\;0\;1\\
1\;0\;1\;0\;0\;0\;1\;1\;1\;1\;0\;1\;0\;1\;1\;1\;0\;0\;1\;1\;1\\
0\;1\;0\;1\;0\;0\;1\;1\;1\;1\;1\;0\;0\;0\;1\;0\;1\;1\;0\;1\;1\\
0\;0\;1\;0\;1\;0\;0\;1\;1\;1\;1\;1\;1\;1\;0\;1\;0\;1\;1\;1\;0\end{pmatrix},
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Distributed_source_coding:197">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>𝐐</mi>
     <mn>3</mn>
    </msub>
    <mo>=</mo>
    <mrow>
     <mo>(</mo>
     <mtable>
      <mtr>
       <mtd columnalign="center">
        <mn>1 0 0 1 0 1 0 0 1 1 1 0 1 0 0 1 1 1 1 1 1</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>1 1 0 0 1 0 0 0 0 1 1 1 0 0 1 1 1 1 1 1 1</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>0 1 1 0 0 1 1 0 0 0 1 1 1 1 1 1 0 1 1 1 0</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>1 0 1 1 0 0 1 1 0 0 0 1 0 0 1 1 1 1 0 0 1</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>0 1 0 1 1 0 1 1 1 0 0 0 1 0 0 1 1 0 1 0 0</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>0 0 1 0 1 1 0 1 1 1 0 0 1 1 1 1 0 0 0 1 1</mn>
       </mtd>
      </mtr>
     </mtable>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝐐</ci>
     <cn type="integer">3</cn>
    </apply>
    <matrix>
     <matrixrow>
      <cn type="float">1 0 0 1 0 1 0 0 1 1 1 0 1 0 0 1 1 1 1 1 1</cn>
     </matrixrow>
     <matrixrow>
      <cn type="float">1 1 0 0 1 0 0 0 0 1 1 1 0 0 1 1 1 1 1 1 1</cn>
     </matrixrow>
     <matrixrow>
      <cn type="float">0 1 1 0 0 1 1 0 0 0 1 1 1 1 1 1 0 1 1 1 0</cn>
     </matrixrow>
     <matrixrow>
      <cn type="float">1 0 1 1 0 0 1 1 0 0 0 1 0 0 1 1 1 1 0 0 1</cn>
     </matrixrow>
     <matrixrow>
      <cn type="float">0 1 0 1 1 0 1 1 1 0 0 0 1 0 0 1 1 0 1 0 0</cn>
     </matrixrow>
     <matrixrow>
      <cn type="float">0 0 1 0 1 1 0 1 1 1 0 0 1 1 1 1 0 0 0 1 1</cn>
     </matrixrow>
    </matrix>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{Q}_{3}=\begin{pmatrix}1\;0\;0\;1\;0\;1\;0\;0\;1\;1\;1\;0\;1\;0\;0\;1\;%
1\;1\;1\;1\;1\\
1\;1\;0\;0\;1\;0\;0\;0\;0\;1\;1\;1\;0\;0\;1\;1\;1\;1\;1\;1\;1\\
0\;1\;1\;0\;0\;1\;1\;0\;0\;0\;1\;1\;1\;1\;1\;1\;0\;1\;1\;1\;0\\
1\;0\;1\;1\;0\;0\;1\;1\;0\;0\;0\;1\;0\;0\;1\;1\;1\;1\;0\;0\;1\\
0\;1\;0\;1\;1\;0\;1\;1\;1\;0\;0\;0\;1\;0\;0\;1\;1\;0\;1\;0\;0\\
0\;0\;1\;0\;1\;1\;0\;1\;1\;1\;0\;0\;1\;1\;1\;1\;0\;0\;0\;1\;1\end{pmatrix},
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Distributed_source_coding:198">
 <semantics>
  <mrow>
   <mi>𝐆</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mn>𝟎</mn>
    <mo stretchy="false">|</mo>
    <msub>
     <mi>𝐈</mi>
     <mn>9</mn>
    </msub>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">G</csymbol>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <cn type="integer">0</cn>
     <ci>normal-|</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐈</ci>
      <cn type="integer">9</cn>
     </apply>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{G}=[\mathbf{0}|\mathbf{I}_{9}]
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="Distributed_source_coding:199">
 <semantics>
  <mrow>
   <mi>𝐆</mi>
   <mo>=</mo>
   <mrow>
    <mo>(</mo>
    <mtable>
     <mtr>
      <mtd columnalign="center">
       <msub>
        <mi>𝐆</mi>
        <mn>1</mn>
       </msub>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <msub>
        <mi>𝐆</mi>
        <mn>2</mn>
       </msub>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <msub>
        <mi>𝐆</mi>
        <mn>3</mn>
       </msub>
      </mtd>
     </mtr>
    </mtable>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>𝐆</ci>
    <matrix>
     <matrixrow>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐆</ci>
       <cn type="integer">1</cn>
      </apply>
     </matrixrow>
     <matrixrow>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐆</ci>
       <cn type="integer">2</cn>
      </apply>
     </matrixrow>
     <matrixrow>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐆</ci>
       <cn type="integer">3</cn>
      </apply>
     </matrixrow>
    </matrix>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{G}=\begin{pmatrix}\mathbf{G}_{1}\\
\mathbf{G}_{2}\\
\mathbf{G}_{3}\end{pmatrix}
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Distributed_source_coding:200">
 <semantics>
  <mrow>
   <msub>
    <mi>𝐆</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>𝐆</mi>
    <mn>2</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>𝐆</mi>
    <mn>3</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝐆</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝐆</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝐆</ci>
     <cn type="integer">3</cn>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{G}_{1},\mathbf{G}_{2},\mathbf{G}_{3}
  </annotation>
 </semantics>
</math>

 are any partition of 

<math display="inline" id="Distributed_source_coding:201">
 <semantics>
  <mi>𝐆</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐆</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{G}
  </annotation>
 </semantics>
</math>

.</p>

<p>

<math display="inline" id="Distributed_source_coding:202">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>𝐇</mi>
     <mn>1</mn>
    </msub>
    <mo>=</mo>
    <mrow>
     <mo>(</mo>
     <mtable>
      <mtr>
       <mtd columnalign="center">
        <msub>
         <mi>𝐆</mi>
         <mn>1</mn>
        </msub>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <msub>
         <mi>𝐐</mi>
         <mn>1</mn>
        </msub>
       </mtd>
      </mtr>
     </mtable>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>𝐇</mi>
      <mn>2</mn>
     </msub>
     <mo>=</mo>
     <mrow>
      <mo>(</mo>
      <mtable>
       <mtr>
        <mtd columnalign="center">
         <msub>
          <mi>𝐆</mi>
          <mn>2</mn>
         </msub>
        </mtd>
       </mtr>
       <mtr>
        <mtd columnalign="center">
         <msub>
          <mi>𝐐</mi>
          <mn>2</mn>
         </msub>
        </mtd>
       </mtr>
      </mtable>
      <mo>)</mo>
     </mrow>
    </mrow>
    <mo>,</mo>
    <mrow>
     <msub>
      <mi>𝐇</mi>
      <mn>3</mn>
     </msub>
     <mo>=</mo>
     <mrow>
      <mo>(</mo>
      <mtable>
       <mtr>
        <mtd columnalign="center">
         <msub>
          <mi>𝐆</mi>
          <mn>3</mn>
         </msub>
        </mtd>
       </mtr>
       <mtr>
        <mtd columnalign="center">
         <msub>
          <mi>𝐐</mi>
          <mn>3</mn>
         </msub>
        </mtd>
       </mtr>
      </mtable>
      <mo>)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐇</ci>
      <cn type="integer">1</cn>
     </apply>
     <matrix>
      <matrixrow>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>𝐆</ci>
        <cn type="integer">1</cn>
       </apply>
      </matrixrow>
      <matrixrow>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>𝐐</ci>
        <cn type="integer">1</cn>
       </apply>
      </matrixrow>
     </matrix>
    </apply>
    <apply>
     <csymbol cd="ambiguous">formulae-sequence</csymbol>
     <apply>
      <eq></eq>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐇</ci>
       <cn type="integer">2</cn>
      </apply>
      <matrix>
       <matrixrow>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>𝐆</ci>
         <cn type="integer">2</cn>
        </apply>
       </matrixrow>
       <matrixrow>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>𝐐</ci>
         <cn type="integer">2</cn>
        </apply>
       </matrixrow>
      </matrix>
     </apply>
     <apply>
      <eq></eq>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐇</ci>
       <cn type="integer">3</cn>
      </apply>
      <matrix>
       <matrixrow>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>𝐆</ci>
         <cn type="integer">3</cn>
        </apply>
       </matrixrow>
       <matrixrow>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>𝐐</ci>
         <cn type="integer">3</cn>
        </apply>
       </matrixrow>
      </matrix>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{H}_{1}=\begin{pmatrix}\mathbf{G}_{1}\\
\mathbf{Q}_{1}\end{pmatrix},\mathbf{H}_{2}=\begin{pmatrix}\mathbf{G}_{2}\\
\mathbf{Q}_{2}\end{pmatrix},\mathbf{H}_{3}=\begin{pmatrix}\mathbf{G}_{3}\\
\mathbf{Q}_{3}\end{pmatrix}
  </annotation>
 </semantics>
</math>

 can compress a Hamming source (i.e., sources that have no more than one bit different will all have different syndromes).<a class="footnoteRef" href="#fn39" id="fnref39"><sup>39</sup></a> For example, for the symmetric case, a possible set of coding matrices are 

<math display="inline" id="Distributed_source_coding:203">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>𝐇</mi>
     <mn>1</mn>
    </msub>
    <mo>=</mo>
    <mrow>
     <mo>(</mo>
     <mtable>
      <mtr>
       <mtd columnalign="center">
        <mn>0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>1 0 0 0 0 0 1 0 0 0 0 1 1 1 0 1 1 0 0 0 0</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>0 1 0 0 0 0 1 1 0 0 0 0 1 0 0 0 0 0 1 1 1</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>0 0 1 0 0 0 0 1 1 0 0 0 0 1 1 1 0 1 0 1 1</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>0 0 0 1 0 0 0 0 1 1 0 0 0 1 0 0 1 1 1 1 0</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>0 0 0 0 1 0 0 0 0 1 1 0 1 0 1 1 0 1 1 1 1</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>0 0 0 0 0 1 0 0 0 0 1 1 0 0 1 0 0 1 1 0 1</mn>
       </mtd>
      </mtr>
     </mtable>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝐇</ci>
     <cn type="integer">1</cn>
    </apply>
    <matrix>
     <matrixrow>
      <cn type="float">0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0</cn>
     </matrixrow>
     <matrixrow>
      <cn type="float">0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0</cn>
     </matrixrow>
     <matrixrow>
      <cn type="float">0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1</cn>
     </matrixrow>
     <matrixrow>
      <cn type="float">1 0 0 0 0 0 1 0 0 0 0 1 1 1 0 1 1 0 0 0 0</cn>
     </matrixrow>
     <matrixrow>
      <cn type="float">0 1 0 0 0 0 1 1 0 0 0 0 1 0 0 0 0 0 1 1 1</cn>
     </matrixrow>
     <matrixrow>
      <cn type="float">0 0 1 0 0 0 0 1 1 0 0 0 0 1 1 1 0 1 0 1 1</cn>
     </matrixrow>
     <matrixrow>
      <cn type="float">0 0 0 1 0 0 0 0 1 1 0 0 0 1 0 0 1 1 1 1 0</cn>
     </matrixrow>
     <matrixrow>
      <cn type="float">0 0 0 0 1 0 0 0 0 1 1 0 1 0 1 1 0 1 1 1 1</cn>
     </matrixrow>
     <matrixrow>
      <cn type="float">0 0 0 0 0 1 0 0 0 0 1 1 0 0 1 0 0 1 1 0 1</cn>
     </matrixrow>
    </matrix>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{H}_{1}=\begin{pmatrix}0\;0\;0\;0\;0\;0\;0\;0\;0\;0\;0\;0\;0\;0\;0\;0\;%
0\;0\;1\;0\;0\\
0\;0\;0\;0\;0\;0\;0\;0\;0\;0\;0\;0\;0\;0\;0\;0\;0\;0\;0\;1\;0\\
0\;0\;0\;0\;0\;0\;0\;0\;0\;0\;0\;0\;0\;0\;0\;0\;0\;0\;0\;0\;1\\
1\;0\;0\;0\;0\;0\;1\;0\;0\;0\;0\;1\;1\;1\;0\;1\;1\;0\;0\;0\;0\\
0\;1\;0\;0\;0\;0\;1\;1\;0\;0\;0\;0\;1\;0\;0\;0\;0\;0\;1\;1\;1\\
0\;0\;1\;0\;0\;0\;0\;1\;1\;0\;0\;0\;0\;1\;1\;1\;0\;1\;0\;1\;1\\
0\;0\;0\;1\;0\;0\;0\;0\;1\;1\;0\;0\;0\;1\;0\;0\;1\;1\;1\;1\;0\\
0\;0\;0\;0\;1\;0\;0\;0\;0\;1\;1\;0\;1\;0\;1\;1\;0\;1\;1\;1\;1\\
0\;0\;0\;0\;0\;1\;0\;0\;0\;0\;1\;1\;0\;0\;1\;0\;0\;1\;1\;0\;1\end{pmatrix},
  </annotation>
 </semantics>
</math>


 

<math display="inline" id="Distributed_source_coding:204">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>𝐇</mi>
     <mn>2</mn>
    </msub>
    <mo>=</mo>
    <mrow>
     <mo>(</mo>
     <mtable>
      <mtr>
       <mtd columnalign="center">
        <mn>0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>0 0 0 1 0 1 1 0 1 1 1 1 0 1 0 0 0 1 1 1 1</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>1 0 0 0 1 0 1 1 0 1 1 1 1 0 1 1 1 1 0 0 0</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>0 1 0 0 0 1 1 1 1 0 1 1 1 0 0 0 0 0 1 0 1</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>1 0 1 0 0 0 1 1 1 1 0 1 0 1 1 1 0 0 1 1 1</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>0 1 0 1 0 0 1 1 1 1 1 0 0 0 1 0 1 1 0 1 1</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>0 0 1 0 1 0 0 1 1 1 1 1 1 1 0 1 0 1 1 1 0</mn>
       </mtd>
      </mtr>
     </mtable>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝐇</ci>
     <cn type="integer">2</cn>
    </apply>
    <matrix>
     <matrixrow>
      <cn type="float">0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0</cn>
     </matrixrow>
     <matrixrow>
      <cn type="float">0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0</cn>
     </matrixrow>
     <matrixrow>
      <cn type="float">0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0</cn>
     </matrixrow>
     <matrixrow>
      <cn type="float">0 0 0 1 0 1 1 0 1 1 1 1 0 1 0 0 0 1 1 1 1</cn>
     </matrixrow>
     <matrixrow>
      <cn type="float">1 0 0 0 1 0 1 1 0 1 1 1 1 0 1 1 1 1 0 0 0</cn>
     </matrixrow>
     <matrixrow>
      <cn type="float">0 1 0 0 0 1 1 1 1 0 1 1 1 0 0 0 0 0 1 0 1</cn>
     </matrixrow>
     <matrixrow>
      <cn type="float">1 0 1 0 0 0 1 1 1 1 0 1 0 1 1 1 0 0 1 1 1</cn>
     </matrixrow>
     <matrixrow>
      <cn type="float">0 1 0 1 0 0 1 1 1 1 1 0 0 0 1 0 1 1 0 1 1</cn>
     </matrixrow>
     <matrixrow>
      <cn type="float">0 0 1 0 1 0 0 1 1 1 1 1 1 1 0 1 0 1 1 1 0</cn>
     </matrixrow>
    </matrix>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{H}_{2}=\begin{pmatrix}0\;0\;0\;0\;0\;0\;0\;0\;0\;0\;0\;0\;0\;0\;0\;1\;%
0\;0\;0\;0\;0\\
0\;0\;0\;0\;0\;0\;0\;0\;0\;0\;0\;0\;0\;0\;0\;0\;1\;0\;0\;0\;0\\
0\;0\;0\;0\;0\;0\;0\;0\;0\;0\;0\;0\;0\;0\;0\;0\;0\;1\;0\;0\;0\\
0\;0\;0\;1\;0\;1\;1\;0\;1\;1\;1\;1\;0\;1\;0\;0\;0\;1\;1\;1\;1\\
1\;0\;0\;0\;1\;0\;1\;1\;0\;1\;1\;1\;1\;0\;1\;1\;1\;1\;0\;0\;0\\
0\;1\;0\;0\;0\;1\;1\;1\;1\;0\;1\;1\;1\;0\;0\;0\;0\;0\;1\;0\;1\\
1\;0\;1\;0\;0\;0\;1\;1\;1\;1\;0\;1\;0\;1\;1\;1\;0\;0\;1\;1\;1\\
0\;1\;0\;1\;0\;0\;1\;1\;1\;1\;1\;0\;0\;0\;1\;0\;1\;1\;0\;1\;1\\
0\;0\;1\;0\;1\;0\;0\;1\;1\;1\;1\;1\;1\;1\;0\;1\;0\;1\;1\;1\;0\end{pmatrix},
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Distributed_source_coding:205">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>𝐇</mi>
     <mn>3</mn>
    </msub>
    <mo>=</mo>
    <mrow>
     <mo>(</mo>
     <mtable>
      <mtr>
       <mtd columnalign="center">
        <mn>0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>1 0 0 1 0 1 0 0 1 1 1 0 1 0 0 1 1 1 1 1 1</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>1 1 0 0 1 0 0 0 0 1 1 1 0 0 1 1 1 1 1 1 1</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>0 1 1 0 0 1 1 0 0 0 1 1 1 1 1 1 0 1 1 1 0</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>1 0 1 1 0 0 1 1 0 0 0 1 0 0 1 1 1 1 0 0 1</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>0 1 0 1 1 0 1 1 1 0 0 0 1 0 0 1 1 0 1 0 0</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>0 0 1 0 1 1 0 1 1 1 0 0 1 1 1 1 0 0 0 1 1</mn>
       </mtd>
      </mtr>
     </mtable>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝐇</ci>
     <cn type="integer">3</cn>
    </apply>
    <matrix>
     <matrixrow>
      <cn type="float">0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0</cn>
     </matrixrow>
     <matrixrow>
      <cn type="float">0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0</cn>
     </matrixrow>
     <matrixrow>
      <cn type="float">0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0</cn>
     </matrixrow>
     <matrixrow>
      <cn type="float">1 0 0 1 0 1 0 0 1 1 1 0 1 0 0 1 1 1 1 1 1</cn>
     </matrixrow>
     <matrixrow>
      <cn type="float">1 1 0 0 1 0 0 0 0 1 1 1 0 0 1 1 1 1 1 1 1</cn>
     </matrixrow>
     <matrixrow>
      <cn type="float">0 1 1 0 0 1 1 0 0 0 1 1 1 1 1 1 0 1 1 1 0</cn>
     </matrixrow>
     <matrixrow>
      <cn type="float">1 0 1 1 0 0 1 1 0 0 0 1 0 0 1 1 1 1 0 0 1</cn>
     </matrixrow>
     <matrixrow>
      <cn type="float">0 1 0 1 1 0 1 1 1 0 0 0 1 0 0 1 1 0 1 0 0</cn>
     </matrixrow>
     <matrixrow>
      <cn type="float">0 0 1 0 1 1 0 1 1 1 0 0 1 1 1 1 0 0 0 1 1</cn>
     </matrixrow>
    </matrix>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{H}_{3}=\begin{pmatrix}0\;0\;0\;0\;0\;0\;0\;0\;0\;0\;0\;0\;1\;0\;0\;0\;%
0\;0\;0\;0\;0\\
0\;0\;0\;0\;0\;0\;0\;0\;0\;0\;0\;0\;0\;1\;0\;0\;0\;0\;0\;0\;0\\
0\;0\;0\;0\;0\;0\;0\;0\;0\;0\;0\;0\;0\;0\;1\;0\;0\;0\;0\;0\;0\\
1\;0\;0\;1\;0\;1\;0\;0\;1\;1\;1\;0\;1\;0\;0\;1\;1\;1\;1\;1\;1\\
1\;1\;0\;0\;1\;0\;0\;0\;0\;1\;1\;1\;0\;0\;1\;1\;1\;1\;1\;1\;1\\
0\;1\;1\;0\;0\;1\;1\;0\;0\;0\;1\;1\;1\;1\;1\;1\;0\;1\;1\;1\;0\\
1\;0\;1\;1\;0\;0\;1\;1\;0\;0\;0\;1\;0\;0\;1\;1\;1\;1\;0\;0\;1\\
0\;1\;0\;1\;1\;0\;1\;1\;1\;0\;0\;0\;1\;0\;0\;1\;1\;0\;1\;0\;0\\
0\;0\;1\;0\;1\;1\;0\;1\;1\;1\;0\;0\;1\;1\;1\;1\;0\;0\;0\;1\;1\end{pmatrix}.
  </annotation>
 </semantics>
</math>

</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Linear_code" title="wikilink">Linear code</a></li>
<li><a href="Syndrome_decoding" title="wikilink">Syndrome decoding</a></li>
<li><a href="Low-density_parity-check_code" title="wikilink">Low-density parity-check code</a></li>
<li><a href="Turbo_Code" title="wikilink">Turbo Code</a></li>
</ul>
<h2 id="references">References</h2>

<p>"</p>

<p><a href="Category:Information_theory" title="wikilink">Category:Information theory</a> <a href="Category:Coding_theory" title="wikilink">Category:Coding theory</a> <a href="Category:Wireless_sensor_network" title="wikilink">Category:Wireless sensor network</a> <a href="Category:Data_transmission" title="wikilink">Category:Data transmission</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="http://ieeexplore.ieee.org/xpl/freeabs_all.jsp?arnumber=1328091">"Distributed source coding for sensor networks" by Z. Xiong, A.D. Liveris, and S. Cheng</a><a href="#fnref1">↩</a></li>
<li id="fn2">[<a class="uri" href="http://ieeexplore.ieee.org/xpl/freeabs_all.jsp?tp">http://ieeexplore.ieee.org/xpl/freeabs_all.jsp?tp</a>=&amp;arnumber;=1657820&amp;isnumber;=34703 "Distributed video coding in wireless sensor networks" by Puri, R. Majumdar, A. Ishwar, P. Ramchandran, K. ]<a href="#fnref2">↩</a></li>
<li id="fn3"><a href="http://ieeexplore.ieee.org/xpl/freeabs_all.jsp?arnumber=1055037">"Noiseless coding of correlated information sources" by D. Slepian and J. Wolf</a><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="http://ieeexplore.ieee.org/xpl/freeabs_all.jsp?arnumber=1055356">"A proof of the data compression theorem of Slepian and Wolf for ergodic sources" by T. Cover</a><a href="#fnref4">↩</a></li>
<li id="fn5">[<a class="uri" href="http://ieeexplore.ieee.org/xpl/freeabs_all.jsp?tp">http://ieeexplore.ieee.org/xpl/freeabs_all.jsp?tp</a>=&amp;arnumber;=1055508 "The rate-distortion function for source coding with side information at the decoder" by A. Wyner and J. Ziv]<a href="#fnref5">↩</a></li>
<li id="fn6"><a href="http://ieeexplore.ieee.org/xpls/freeabs_all.jsp?arnumber=1055171">"Recent results in Shannon theory" by A. D. Wyner</a><a href="#fnref6">↩</a></li>
<li id="fn7">[<a class="uri" href="http://ieeexplore.ieee.org/xpl/freeabs_all.jsp?tp">http://ieeexplore.ieee.org/xpl/freeabs_all.jsp?tp</a>=&amp;arnumber;=1055508 "Distributed source coding using syndromes (DISCUS): design and construction" by S. S. Pradhan and K. Ramchandran]<a href="#fnref7">↩</a></li>
<li id="fn8"><a href="http://ieeexplore.ieee.org/xpls/freeabs_all.jsp?arnumber=838176">"Distributed source coding: symmetric rates and applications to sensor networks" by S. S. Pradhan and K. Ramchandran</a><a href="#fnref8">↩</a></li>
<li id="fn9"></li>
<li id="fn10"><a href="http://ieeexplore.ieee.org/xpl/freeabs_all.jsp?arnumber=1281474">"Distributed code constructions for the entire Slepian–Wolf rate region for arbitrarily correlated sources" by Schonberg, D. Ramchandran, K. Pradhan, S.S.</a><a href="#fnref10">↩</a></li>
<li id="fn11"><a href="http://ieeexplore.ieee.org/xpl/freeabs_all.jsp?arnumber=1512420">"Generalized coset codes for distributed binning" by Pradhan, S.S. Ramchandran, K.</a><a href="#fnref11">↩</a></li>
<li id="fn12"><a href="http://ieeexplore.ieee.org/xpls/freeabs_all.jsp?arnumber=706450">"Nested linear/lattice codes for Wyner–Ziv encoding" by R. Zamir and S. Shamai</a><a href="#fnref12">↩</a></li>
<li id="fn13"><a href="http://ieeexplore.ieee.org/xpls/freeabs_all.jsp?arnumber=1369699">"Distributed Video Coding" by B. Girod, etc.</a><a href="#fnref13">↩</a></li>
<li id="fn14"><a href="http://ieeexplore.ieee.org/xpl/freeabs_all.jsp?arnumber=1614079">"On code design for the Slepian–Wolf problem and lossless multiterminal networks" by Stankovic, V. Liveris, A.D. Zixiang Xiong Georghiades, C.N.</a><a href="#fnref14">↩</a></li>
<li id="fn15"><a href="http://portal.acm.org/citation.cfm?id=1226544">"A general and optimal framework to achieve the entire rate region for Slepian–Wolf coding" by P. Tan and J. Li</a><a href="#fnref15">↩</a></li>
<li id="fn16"><a href="http://ieeexplore.ieee.org/xpl/freeabs_all.jsp?arnumber=4471935">"Distributed source coding using short to moderate length rate-compatible LDPC codes: the entire Slepian–Wolf rate region" by Sartipi, M. Fekri, F.</a><a href="#fnref16">↩</a></li>
<li id="fn17">[<a class="uri" href="http://ieeexplore.ieee.org/xpl/freeabs_all.jsp?isnumber=4895364&amp;arnumber">http://ieeexplore.ieee.org/xpl/freeabs_all.jsp?isnumber=4895364&amp;arnumber;</a>;=4895396&amp;count;=299&amp;index;=31 "A distributed source coding framework for multiple sources" by Xiaomin Cao and Kuijper, M.]<a href="#fnref17">↩</a></li>
<li id="fn18"><a href="http://ieeexplore.ieee.org/xpl/articleDetails.jsp?arnumber=6291702&amp;refinements;%3D4281469143%26sortType%3Dasc_p_Sequence%26filter%3DAND%28p_IS_Number%3A6362326%29">1</a>"Distributed Source Coding via Linear Block Codes: A General Framework for Multiple Sources" by Xiaomin Cao and Kuijper, M.<a href="#fnref18">↩</a></li>
<li id="fn19"></li>
<li id="fn20"></li>
<li id="fn21"></li>
<li id="fn22"></li>
<li id="fn23"></li>
<li id="fn24"></li>
<li id="fn25"></li>
<li id="fn26"></li>
<li id="fn27"><a href="http://ieeexplore.ieee.org/xpls/freeabs_all.jsp?arnumber=21245">"Coset codes. I. Introduction and geometrical classification" by G. D. Forney</a><a href="#fnref27">↩</a></li>
<li id="fn28"></li>
<li id="fn29"></li>
<li id="fn30"><a href="http://ieeexplore.ieee.org/xpls/freeabs_all.jsp?arnumber=917167">"Design of trellis codes for source coding with side information at the decoder" by X. Wang and M. Orchard</a><a href="#fnref30">↩</a></li>
<li id="fn31"><a href="http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=1281475">"Design of Slepian–Wolf codes by channel code partitioning" by V. Stankovic, A. D. Liveris, Z. Xiong and C. N. Georghiades</a><a href="#fnref31">↩</a></li>
<li id="fn32"><a href="http://ieeexplore.ieee.org/xpl/freeabs_all.jsp?arnumber=1289429">"Nested quantization and Slepian–Wolf coding: a Wyner–Ziv coding paradigm for i.i.d. sources" by Z. Xiong, A. D. Liveris, S. Cheng and Z. Liu</a><a href="#fnref32">↩</a></li>
<li id="fn33"><a href="http://ieeexplore.ieee.org/xpl/freeabs_all.jsp?arnumber=4784347">"Wyner–Ziv coding based on TCQ and LDPC codes" by Y. Yang, S. Cheng, Z. Xiong and W. Zhao</a><a href="#fnref33">↩</a></li>
<li id="fn34"><a href="http://ieeexplore.ieee.org/xpl/freeabs_all.jsp?arnumber=1193992">"Design of optimal quantizers for distributed source coding" by D. Rebollo-Monedero, R. Zhang and B. Girod</a><a href="#fnref34">↩</a></li>
<li id="fn35"><a href="http://www.scl.ece.ucsb.edu/pubs/pubs_D/d10_4.pdf">"Towards large scale distributed source coding" by S. Ramaswamy, K. Viswanatha, A. Saxena and K. Rose</a><a href="#fnref35">↩</a></li>
<li id="fn36"><a href="http://arxiv.org/pdf/1001.4072">"Hamming Codes for Multiple Sources" by R. Ma and S. Cheng</a><a href="#fnref36">↩</a></li>
<li id="fn37"></li>
<li id="fn38"><a href="http://tulsagrad.ou.edu/samuel_cheng/papers/dcc10.pdf">"The Non-existence of Length-5 Slepian–Wolf Codes of Three Sources" by S. Cheng and R. Ma</a><a href="#fnref38">↩</a></li>
<li id="fn39"></li>
</ol>
</section>
</hr></body>
</html>
