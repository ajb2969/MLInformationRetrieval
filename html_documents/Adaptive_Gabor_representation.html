<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="659">Adaptive Gabor representation</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Adaptive Gabor representation</h1>
<hr/>

<p><strong>Adaptive Gabor representation</strong> (<strong>AGR</strong>) is a <a href="Gabor_representation" title="wikilink">Gabor representation</a> of a signal where its variance is adjustable. There's always a trade-off between time resolution and frequency resolution in traditional <a href="short-time_Fourier_transform" title="wikilink">short-time Fourier transform</a> (STFT). A long window leads to high frequency resolution and low time resolution. On the other hand, high time resolution requires shorter window, with the expense of low frequency resolution. By choosing the proper elementary function for signal with different spectrum structure, adaptive Gabor representation is able to accommodate both narrowband and wideband signal.</p>
<h2 id="gabor-expansion">Gabor expansion</h2>

<p>In 1946, <a href="Dennis_Gabor" title="wikilink">Dennis Gabor</a> suggested that a signal can be represented in two dimensions, with time and frequency coordinates. And the signal can be expanded into a discrete set of Gaussian elementary signals.</p>
<h3 id="definition">Definition</h3>

<p>The Gabor expansion of signal s(t) is defined by this formula:</p>

<p>

<math display="block" id="Adaptive_Gabor_representation:0">
 <semantics>
  <mrow>
   <mrow>
    <mi>s</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>m</mi>
      <mo>=</mo>
      <mrow>
       <mo>-</mo>
       <mi mathvariant="normal">∞</mi>
      </mrow>
     </mrow>
     <mi mathvariant="normal">∞</mi>
    </munderover>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>n</mi>
       <mo>=</mo>
       <mrow>
        <mo>-</mo>
        <mi mathvariant="normal">∞</mi>
       </mrow>
      </mrow>
      <mi mathvariant="normal">∞</mi>
     </munderover>
     <mrow>
      <msub>
       <mi>C</mi>
       <mrow>
        <mi>m</mi>
        <mo>,</mo>
        <mi>n</mi>
       </mrow>
      </msub>
      <mi>h</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>t</mi>
        <mo>-</mo>
        <mrow>
         <mi>m</mi>
         <mi>T</mi>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <msup>
       <mi>e</mi>
       <mrow>
        <mi>j</mi>
        <mi>n</mi>
        <mi>t</mi>
        <mi mathvariant="normal">Ω</mi>
       </mrow>
      </msup>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>s</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>m</ci>
        <apply>
         <minus></minus>
         <infinity></infinity>
        </apply>
       </apply>
      </apply>
      <infinity></infinity>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>n</ci>
         <apply>
          <minus></minus>
          <infinity></infinity>
         </apply>
        </apply>
       </apply>
       <infinity></infinity>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>C</ci>
        <list>
         <ci>m</ci>
         <ci>n</ci>
        </list>
       </apply>
       <ci>h</ci>
       <apply>
        <minus></minus>
        <ci>t</ci>
        <apply>
         <times></times>
         <ci>m</ci>
         <ci>T</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>e</ci>
        <apply>
         <times></times>
         <ci>j</ci>
         <ci>n</ci>
         <ci>t</ci>
         <ci>normal-Ω</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s(t)=\sum_{m=-\infty}^{\infty}\sum_{n=-\infty}^{\infty}C_{m,n}h(t-mT)e^{jnt\Omega}
  </annotation>
 </semantics>
</math>

</p>

<p>where <em>h</em>(<em>t</em>) is the Gaussian elementary function:</p>

<p>

<math display="block" id="Adaptive_Gabor_representation:1">
 <semantics>
  <mrow>
   <mrow>
    <mi>h</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msup>
     <mrow>
      <mo>(</mo>
      <mfrac>
       <mi>α</mi>
       <mi>π</mi>
      </mfrac>
      <mo>)</mo>
     </mrow>
     <mfrac>
      <mn>1</mn>
      <mn>4</mn>
     </mfrac>
    </msup>
    <msup>
     <mi>e</mi>
     <mrow>
      <mo>(</mo>
      <mrow>
       <mo>-</mo>
       <mrow>
        <mfrac>
         <mi>α</mi>
         <mn>2</mn>
        </mfrac>
        <msup>
         <mi>t</mi>
         <mn>2</mn>
        </msup>
       </mrow>
      </mrow>
      <mo>)</mo>
     </mrow>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>h</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <divide></divide>
       <ci>α</ci>
       <ci>π</ci>
      </apply>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <cn type="integer">4</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>e</ci>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <apply>
         <divide></divide>
         <ci>α</ci>
         <cn type="integer">2</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>t</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h(t)=\left(\frac{\alpha}{\pi}\right)^{\frac{1}{4}}e^{\left(-\frac{\alpha}{2}t^%
{2}\right)}
  </annotation>
 </semantics>
</math>

</p>

<p>Once the Gabor elementary function is determined, the Gabor coefficients 

<math display="inline" id="Adaptive_Gabor_representation:2">
 <semantics>
  <msub>
   <mi>C</mi>
   <mrow>
    <mi>m</mi>
    <mo>,</mo>
    <mi>n</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>C</ci>
    <list>
     <ci>m</ci>
     <ci>n</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{m,n}
  </annotation>
 </semantics>
</math>

can be obtained by the inner product of s(t) and a dual function 

<math display="inline" id="Adaptive_Gabor_representation:3">
 <semantics>
  <mrow>
   <mi>γ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>γ</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gamma(t)
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Adaptive_Gabor_representation:4">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>C</mi>
     <mrow>
      <mi>m</mi>
      <mo>,</mo>
      <mi>n</mi>
     </mrow>
    </msub>
    <mo>=</mo>
    <mrow>
     <mo largeop="true" symmetric="true">∫</mo>
     <mrow>
      <mi>s</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <msup>
       <mi>γ</mi>
       <mo>*</mo>
      </msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>t</mi>
        <mo>-</mo>
        <mrow>
         <mi>m</mi>
         <mi>T</mi>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mpadded width="+1.7pt">
       <msup>
        <mi>e</mi>
        <mrow>
         <mo>-</mo>
         <mrow>
          <mi>j</mi>
          <mi>n</mi>
          <mi>t</mi>
          <mi mathvariant="normal">Ω</mi>
         </mrow>
        </mrow>
       </msup>
      </mpadded>
      <mi>d</mi>
      <mi>t</mi>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <list>
      <ci>m</ci>
      <ci>n</ci>
     </list>
    </apply>
    <apply>
     <int></int>
     <apply>
      <times></times>
      <ci>s</ci>
      <ci>t</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>γ</ci>
       <times></times>
      </apply>
      <apply>
       <minus></minus>
       <ci>t</ci>
       <apply>
        <times></times>
        <ci>m</ci>
        <ci>T</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>e</ci>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <ci>j</ci>
         <ci>n</ci>
         <ci>t</ci>
         <ci>normal-Ω</ci>
        </apply>
       </apply>
      </apply>
      <ci>d</ci>
      <ci>t</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{m,n}=\int s(t)\gamma^{*}(t-mT)e^{-jnt\Omega}\,dt.
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Adaptive_Gabor_representation:5">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Adaptive_Gabor_representation:6">
 <semantics>
  <mi mathvariant="normal">Ω</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Ω</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Omega
  </annotation>
 </semantics>
</math>

 denote the sampling steps of time and frequency and satisfy the criteria</p>

<p>

<math display="block" id="Adaptive_Gabor_representation:7">
 <semantics>
  <mrow>
   <mrow>
    <mi>T</mi>
    <mi mathvariant="normal">Ω</mi>
   </mrow>
   <mo>≦</mo>
   <mrow>
    <mn>2</mn>
    <mpadded width="+1.7pt">
     <mi>π</mi>
    </mpadded>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <times></times>
     <ci>T</ci>
     <ci>normal-Ω</ci>
    </apply>
    <apply>
     <times></times>
     <cn type="integer">2</cn>
     <ci>π</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T\Omega\leqq 2\pi\,
  </annotation>
 </semantics>
</math>

</p>
<h4 id="relationship-between-gabor-representation-and-gabor-transform">Relationship between Gabor representation and Gabor transform</h4>

<p>Gabor transform simply computes the Gabor coefficients 

<math display="inline" id="Adaptive_Gabor_representation:8">
 <semantics>
  <msub>
   <mi>C</mi>
   <mrow>
    <mi>m</mi>
    <mo>,</mo>
    <mi>n</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>C</ci>
    <list>
     <ci>m</ci>
     <ci>n</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{m,n}
  </annotation>
 </semantics>
</math>

 for the signal s(t).</p>
<h2 id="adaptive-expansion">Adaptive expansion</h2>

<p>Adaptive signal expansion is defined as</p>

<p>

<math display="block" id="Adaptive_Gabor_representation:9">
 <semantics>
  <mrow>
   <mrow>
    <mi>s</mi>
    <mrow>
     <mo>(</mo>
     <mi>t</mi>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mi>p</mi>
    </munder>
    <mrow>
     <msub>
      <mi>B</mi>
      <mi>p</mi>
     </msub>
     <msub>
      <mi>h</mi>
      <mi>p</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>s</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <ci>p</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>B</ci>
       <ci>p</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>h</ci>
       <ci>p</ci>
      </apply>
      <ci>t</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s\left(t\right)=\sum_{p}B_{p}h_{p}(t)
  </annotation>
 </semantics>
</math>

</p>

<p>where the coefficients 

<math display="inline" id="Adaptive_Gabor_representation:10">
 <semantics>
  <msub>
   <mi>B</mi>
   <mi>p</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>B</ci>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B_{p}
  </annotation>
 </semantics>
</math>

 are obtained by the inner product of the signal s(t) and the elementary function 

<math display="inline" id="Adaptive_Gabor_representation:11">
 <semantics>
  <msub>
   <mi>h</mi>
   <mi>p</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>h</ci>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h_{p}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Adaptive_Gabor_representation:12">
 <semantics>
  <mrow>
   <msub>
    <mi>B</mi>
    <mi>p</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo>⟨</mo>
    <mi>s</mi>
    <mo>,</mo>
    <msub>
     <mi>h</mi>
     <mi>p</mi>
    </msub>
    <mo rspace="4.2pt">⟩</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>B</ci>
     <ci>p</ci>
    </apply>
    <list>
     <ci>s</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>h</ci>
      <ci>p</ci>
     </apply>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B_{p}=\left\langle s,h_{p}\right\rangle\,
  </annotation>
 </semantics>
</math>

</p>

<p>Coeffients 

<math display="inline" id="Adaptive_Gabor_representation:13">
 <semantics>
  <msub>
   <mi>B</mi>
   <mi>p</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>B</ci>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B_{p}
  </annotation>
 </semantics>
</math>

 represent the similarity between the signal and elementary function.<br/>
Adaptive signal decomposition is an iterative operation, aim to find a set of elementary function 

<math display="inline" id="Adaptive_Gabor_representation:14">
 <semantics>
  <mrow>
   <mo>{</mo>
   <mrow>
    <msub>
     <mi>h</mi>
     <mi>p</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>h</ci>
      <ci>p</ci>
     </apply>
     <ci>t</ci>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left\{h_{p}(t)\right\}
  </annotation>
 </semantics>
</math>

, which is most similar to the signal's time-frequency structure.<br/>
First, start with w=0 and 

<math display="inline" id="Adaptive_Gabor_representation:15">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>s</mi>
     <mn>0</mn>
    </msub>
    <mrow>
     <mo>(</mo>
     <mi>t</mi>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>s</mi>
    <mrow>
     <mo>(</mo>
     <mi>t</mi>
     <mo>)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>s</ci>
      <cn type="integer">0</cn>
     </apply>
     <ci>t</ci>
    </apply>
    <apply>
     <times></times>
     <ci>s</ci>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s_{0}\left(t\right)=s\left(t\right)
  </annotation>
 </semantics>
</math>

. Then find 

<math display="inline" id="Adaptive_Gabor_representation:16">
 <semantics>
  <mrow>
   <msub>
    <mi>h</mi>
    <mn>0</mn>
   </msub>
   <mrow>
    <mo>(</mo>
    <mi>t</mi>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>h</ci>
     <cn type="integer">0</cn>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h_{0}\left(t\right)
  </annotation>
 </semantics>
</math>

 which has the maximum inner product with signal 

<math display="inline" id="Adaptive_Gabor_representation:17">
 <semantics>
  <mrow>
   <msub>
    <mi>s</mi>
    <mn>0</mn>
   </msub>
   <mrow>
    <mo>(</mo>
    <mi>t</mi>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>s</ci>
     <cn type="integer">0</cn>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s_{0}\left(t\right)
  </annotation>
 </semantics>
</math>

 and</p>

<p>

<math display="block" id="Adaptive_Gabor_representation:18">
 <semantics>
  <mrow>
   <msup>
    <mrow>
     <mo>|</mo>
     <msub>
      <mi>B</mi>
      <mi>p</mi>
     </msub>
     <mo>|</mo>
    </mrow>
    <mn>2</mn>
   </msup>
   <mo>=</mo>
   <mrow>
    <munder>
     <mi>max</mi>
     <mi>h</mi>
    </munder>
    <msup>
     <mrow>
      <mo>|</mo>
      <mrow>
       <mo>⟨</mo>
       <mrow>
        <msub>
         <mi>s</mi>
         <mi>p</mi>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>t</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>,</mo>
       <mrow>
        <msub>
         <mi>h</mi>
         <mi>p</mi>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>t</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>⟩</mo>
      </mrow>
      <mo>|</mo>
     </mrow>
     <mn>2</mn>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <abs></abs>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>B</ci>
       <ci>p</ci>
      </apply>
     </apply>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <max></max>
      <ci>h</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <abs></abs>
       <list>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>s</ci>
          <ci>p</ci>
         </apply>
         <ci>t</ci>
        </apply>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>h</ci>
          <ci>p</ci>
         </apply>
         <ci>t</ci>
        </apply>
       </list>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left|B_{p}\right|^{2}=\max_{h}\left|\left\langle s_{p}(t),h_{p}(t)\right%
\rangle\right|^{2}
  </annotation>
 </semantics>
</math>

</p>

<p>Second, compute the residual:</p>

<p>

<math display="block" id="Adaptive_Gabor_representation:19">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>s</mi>
      <mn>1</mn>
     </msub>
     <mrow>
      <mo>(</mo>
      <mi>t</mi>
      <mo>)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <msub>
       <mi>s</mi>
       <mn>0</mn>
      </msub>
      <mrow>
       <mo>(</mo>
       <mi>t</mi>
       <mo>)</mo>
      </mrow>
     </mrow>
     <mo>-</mo>
     <mrow>
      <msub>
       <mi>B</mi>
       <mn>0</mn>
      </msub>
      <msub>
       <mi>h</mi>
       <mn>0</mn>
      </msub>
      <mrow>
       <mo>(</mo>
       <mi>t</mi>
       <mo>)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>s</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>t</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>s</ci>
       <cn type="integer">0</cn>
      </apply>
      <ci>t</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>B</ci>
       <cn type="integer">0</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>h</ci>
       <cn type="integer">0</cn>
      </apply>
      <ci>t</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s_{1}\left(t\right)=s_{0}\left(t\right)-B_{0}h_{0}\left(t\right),
  </annotation>
 </semantics>
</math>

</p>

<p>and so on. It will comes out a set of <strong>residual</strong> (

<math display="inline" id="Adaptive_Gabor_representation:20">
 <semantics>
  <mrow>
   <msub>
    <mi>s</mi>
    <mi>p</mi>
   </msub>
   <mrow>
    <mo>(</mo>
    <mi>t</mi>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>s</ci>
     <ci>p</ci>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s_{p}\left(t\right)
  </annotation>
 </semantics>
</math>

), <strong>projection</strong> (

<math display="inline" id="Adaptive_Gabor_representation:21">
 <semantics>
  <mrow>
   <msub>
    <mi>B</mi>
    <mi>p</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo>⟨</mo>
    <mrow>
     <msub>
      <mi>s</mi>
      <mi>p</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>,</mo>
    <mrow>
     <msub>
      <mi>h</mi>
      <mi>p</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>⟩</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>B</ci>
     <ci>p</ci>
    </apply>
    <list>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>s</ci>
       <ci>p</ci>
      </apply>
      <ci>t</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>h</ci>
       <ci>p</ci>
      </apply>
      <ci>t</ci>
     </apply>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B_{p}=\left\langle s_{p}(t),h_{p}(t)\right\rangle
  </annotation>
 </semantics>
</math>

), and <strong>elementary function</strong> (

<math display="inline" id="Adaptive_Gabor_representation:22">
 <semantics>
  <mrow>
   <msub>
    <mi>h</mi>
    <mi>p</mi>
   </msub>
   <mrow>
    <mo>(</mo>
    <mi>t</mi>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>h</ci>
     <ci>p</ci>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h_{p}\left(t\right)
  </annotation>
 </semantics>
</math>

) for each different p. The energy of the residual will vanish if we keep doing the decomposition.</p>
<h3 id="energy-conservation-equation">Energy conservation equation</h3>

<p>If the elementary equation (

<math display="inline" id="Adaptive_Gabor_representation:23">
 <semantics>
  <mrow>
   <msub>
    <mi>h</mi>
    <mi>p</mi>
   </msub>
   <mrow>
    <mo>(</mo>
    <mi>t</mi>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>h</ci>
     <ci>p</ci>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h_{p}\left(t\right)
  </annotation>
 </semantics>
</math>

) is designed to have a unit energy. Then the energy contain in the residual at the pth stage can be determined by the residual at p+1th stage plus (

<math display="inline" id="Adaptive_Gabor_representation:24">
 <semantics>
  <msub>
   <mi>B</mi>
   <mi>p</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>B</ci>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B_{p}
  </annotation>
 </semantics>
</math>

). That is,</p>

<p>

<math display="block" id="Adaptive_Gabor_representation:25">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mrow>
      <mo>∥</mo>
      <mrow>
       <msub>
        <mi>s</mi>
        <mi>p</mi>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>t</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>∥</mo>
     </mrow>
     <mn>2</mn>
    </msup>
    <mo>=</mo>
    <mrow>
     <msup>
      <mrow>
       <mo>∥</mo>
       <mrow>
        <msub>
         <mi>s</mi>
         <mrow>
          <mi>p</mi>
          <mo>+</mo>
          <mn>1</mn>
         </mrow>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>t</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>∥</mo>
      </mrow>
      <mn>2</mn>
     </msup>
     <mo>+</mo>
     <msup>
      <mrow>
       <mo>|</mo>
       <msub>
        <mi>B</mi>
        <mi>p</mi>
       </msub>
       <mo>|</mo>
      </mrow>
      <mn>2</mn>
     </msup>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="latexml">norm</csymbol>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>s</ci>
        <ci>p</ci>
       </apply>
       <ci>t</ci>
      </apply>
     </apply>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="latexml">norm</csymbol>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>s</ci>
         <apply>
          <plus></plus>
          <ci>p</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>t</ci>
       </apply>
      </apply>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <abs></abs>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>B</ci>
        <ci>p</ci>
       </apply>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left\|s_{p}(t)\right\|^{2}=\left\|s_{p+1}(t)\right\|^{2}+\left|B_{p}\right|^{%
2},
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Adaptive_Gabor_representation:26">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mrow>
      <mo>∥</mo>
      <mrow>
       <mi>s</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>t</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>∥</mo>
     </mrow>
     <mn>2</mn>
    </msup>
    <mo>=</mo>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>p</mi>
       <mo>=</mo>
       <mi>o</mi>
      </mrow>
      <mi mathvariant="normal">∞</mi>
     </munderover>
     <msup>
      <mrow>
       <mo>|</mo>
       <msub>
        <mi>B</mi>
        <mi>p</mi>
       </msub>
       <mo>|</mo>
      </mrow>
      <mn>2</mn>
     </msup>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="latexml">norm</csymbol>
      <apply>
       <times></times>
       <ci>s</ci>
       <ci>t</ci>
      </apply>
     </apply>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>p</ci>
        <ci>o</ci>
       </apply>
      </apply>
      <infinity></infinity>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <abs></abs>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>B</ci>
        <ci>p</ci>
       </apply>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left\|s(t)\right\|^{2}=\sum_{p=o}^{\infty}\left|B_{p}\right|^{2},
  </annotation>
 </semantics>
</math>

</p>

<p>similar to the <a href="Parseval's_theorem" title="wikilink">Parseval's theorem</a> in Fourier analysis.</p>

<p>The selection of elementary function is the main task in adaptive signal decomposition. It is natural to choose a Gaussian-type function to achieve the lower bound for the inequality:</p>

<p>

<math display="block" id="Adaptive_Gabor_representation:27">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>h</mi>
      <mi>p</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msup>
      <mrow>
       <mo>(</mo>
       <mfrac>
        <mi>α</mi>
        <mi>π</mi>
       </mfrac>
       <mo>)</mo>
      </mrow>
      <mfrac>
       <mn>1</mn>
       <mn>4</mn>
      </mfrac>
     </msup>
     <msup>
      <mi>e</mi>
      <mrow>
       <mo>-</mo>
       <mrow>
        <mfrac>
         <mi>α</mi>
         <mn>2</mn>
        </mfrac>
        <msup>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <mi>t</mi>
           <mo>-</mo>
           <msub>
            <mi>T</mi>
            <mi>p</mi>
           </msub>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
         <mn>2</mn>
        </msup>
       </mrow>
      </mrow>
     </msup>
     <msup>
      <mi>e</mi>
      <mrow>
       <mi>j</mi>
       <mi>t</mi>
       <msub>
        <mi mathvariant="normal">Ω</mi>
        <mi>p</mi>
       </msub>
      </mrow>
     </msup>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>h</ci>
      <ci>p</ci>
     </apply>
     <ci>t</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <divide></divide>
       <ci>α</ci>
       <ci>π</ci>
      </apply>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <cn type="integer">4</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>e</ci>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <apply>
         <divide></divide>
         <ci>α</ci>
         <cn type="integer">2</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <minus></minus>
          <ci>t</ci>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>T</ci>
           <ci>p</ci>
          </apply>
         </apply>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>e</ci>
      <apply>
       <times></times>
       <ci>j</ci>
       <ci>t</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>normal-Ω</ci>
        <ci>p</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h_{p}(t)=\left(\frac{\alpha}{\pi}\right)^{\frac{1}{4}}e^{-\frac{\alpha}{2}(t-T%
_{p})^{2}}e^{jt\Omega_{p}},
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Adaptive_Gabor_representation:28">
 <semantics>
  <mrow>
   <mo>(</mo>
   <msub>
    <mi>T</mi>
    <mi>p</mi>
   </msub>
   <mo>,</mo>
   <msub>
    <mi mathvariant="normal">Ω</mi>
    <mi>p</mi>
   </msub>
   <mo>)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>T</ci>
     <ci>p</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-Ω</ci>
     <ci>p</ci>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left(T_{p},\Omega_{p}\right)
  </annotation>
 </semantics>
</math>

 is th mean and 

<math display="inline" id="Adaptive_Gabor_representation:29">
 <semantics>
  <msubsup>
   <mi>α</mi>
   <mi>p</mi>
   <mrow>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>α</ci>
     <ci>p</ci>
    </apply>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha_{p}^{-1}
  </annotation>
 </semantics>
</math>

 is the variance of Gaussian at 

<math display="inline" id="Adaptive_Gabor_representation:30">
 <semantics>
  <mrow>
   <mo>(</mo>
   <msub>
    <mi>T</mi>
    <mi>p</mi>
   </msub>
   <mo>,</mo>
   <msub>
    <mi mathvariant="normal">Ω</mi>
    <mi>p</mi>
   </msub>
   <mo>)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>T</ci>
     <ci>p</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-Ω</ci>
     <ci>p</ci>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left(T_{p},\Omega_{p}\right)
  </annotation>
 </semantics>
</math>

. And</p>

<p>

<math display="block" id="Adaptive_Gabor_representation:31">
 <semantics>
  <mrow>
   <mrow>
    <mi>s</mi>
    <mrow>
     <mo>(</mo>
     <mi>t</mi>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mi>p</mi>
    </munder>
    <mrow>
     <msub>
      <mi>B</mi>
      <mi>p</mi>
     </msub>
     <msub>
      <mi>h</mi>
      <mi>p</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mi>p</mi>
    </munder>
    <mrow>
     <msub>
      <mi>B</mi>
      <mi>p</mi>
     </msub>
     <msup>
      <mrow>
       <mo>(</mo>
       <mfrac>
        <mi>α</mi>
        <mi>π</mi>
       </mfrac>
       <mo>)</mo>
      </mrow>
      <mfrac>
       <mn>1</mn>
       <mn>4</mn>
      </mfrac>
     </msup>
     <msup>
      <mi>e</mi>
      <mrow>
       <mo>-</mo>
       <mrow>
        <mfrac>
         <mi>α</mi>
         <mn>2</mn>
        </mfrac>
        <msup>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <mi>t</mi>
           <mo>-</mo>
           <msub>
            <mi>T</mi>
            <mi>p</mi>
           </msub>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
         <mn>2</mn>
        </msup>
       </mrow>
      </mrow>
     </msup>
     <msup>
      <mi>e</mi>
      <mrow>
       <mi>j</mi>
       <mi>t</mi>
       <msub>
        <mi mathvariant="normal">Ω</mi>
        <mi>p</mi>
       </msub>
      </mrow>
     </msup>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>s</ci>
      <ci>t</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <ci>p</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>B</ci>
        <ci>p</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>h</ci>
        <ci>p</ci>
       </apply>
       <ci>t</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <ci>p</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>B</ci>
        <ci>p</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <divide></divide>
         <ci>α</ci>
         <ci>π</ci>
        </apply>
        <apply>
         <divide></divide>
         <cn type="integer">1</cn>
         <cn type="integer">4</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>e</ci>
        <apply>
         <minus></minus>
         <apply>
          <times></times>
          <apply>
           <divide></divide>
           <ci>α</ci>
           <cn type="integer">2</cn>
          </apply>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <apply>
            <minus></minus>
            <ci>t</ci>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <ci>T</ci>
             <ci>p</ci>
            </apply>
           </apply>
           <cn type="integer">2</cn>
          </apply>
         </apply>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>e</ci>
        <apply>
         <times></times>
         <ci>j</ci>
         <ci>t</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>normal-Ω</ci>
          <ci>p</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s\left(t\right)=\sum_{p}B_{p}h_{p}(t)=\sum_{p}B_{p}\left(\frac{\alpha}{\pi}%
\right)^{\frac{1}{4}}e^{-\frac{\alpha}{2}(t-T_{p})^{2}}e^{jt\Omega_{p}}
  </annotation>
 </semantics>
</math>

</p>

<p>is called the adaptive Gabor representation.</p>

<p>Changing the variance value will change the duration of the elementary function (window size), and the center of the elementary function is no longer fixed. By adjusting the center point and variance of the elementary function, we are able to match the signal's local time-frequency feature. The better performance of the adaptation is achieved at the cost of matching process. The trade-off between different window length now become the trade-off between computation time and performance.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Gabor_transform" title="wikilink">Gabor transform</a></li>
<li><a href="Short-time_Fourier_transform" title="wikilink">Short-time Fourier transform</a></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li>M.J. Bastiaans, "Gabor's expansion of a signal into Gaussian elementary signals", Proceedings of the IEEE, vol. 68, Issue:4, pp. 538–539, April 1980</li>
<li>Shie Qian and Dapang Chen, "Signal Representation using adaptive normalized Gaussian functions," <em>Signal Processing</em>, vol. 42, no.3, pp. 687–694, March 1994</li>
<li>Qinye Yin, Shie Qian, and Aigang Feng, "A Fast Refinement for Adaptive Gaussian Chirplet Decomposition," IEEE Transactions on Signal Processing, vol. 50, no.6, pp. 1298–1306, June 2002</li>
<li>Shie Qian, <em>Introduction to Time-Frequency and Wavelet Transforms</em>, Prentice Hall, 2002</li>
</ul>

<p>"</p>

<p><a href="Category:Time–frequency_analysis" title="wikilink">Category:Time–frequency analysis</a></p>
</body>
</html>
