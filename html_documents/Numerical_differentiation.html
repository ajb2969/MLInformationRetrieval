<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="166">Numerical differentiation</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Numerical differentiation</h1>
<hr/>

<p>In <a href="numerical_analysis" title="wikilink">numerical analysis</a>, <strong>numerical differentiation</strong> describes <a href="algorithm" title="wikilink">algorithms</a> for estimating the <a class="uri" href="derivative" title="wikilink">derivative</a> of a <a href="mathematical_function" title="wikilink">mathematical function</a> or function <a class="uri" href="subroutine" title="wikilink">subroutine</a> using values of the function and perhaps other knowledge about the function.</p>
<figure><b>(Figure)</b>
<figcaption>Derivative.svg</figcaption>
</figure>
<h2 id="finite-difference-formulas">Finite difference formulas</h2>

<p>The simplest method is to use finite difference approximations.</p>

<p>A simple two-point estimation is to compute the slope of a nearby <a href="secant_line" title="wikilink">secant line</a> through the points (<em>x</em>,<em>f(x)</em>) and (<em>x+h</em>,<em>f(x+h)</em>).<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> Choosing a small number <em>h</em>, <em>h</em> represents a small change in <em>x</em>, and it can be either positive or negative. The slope of this line is</p>

<p>

<math display="block" id="Numerical_differentiation:0">
 <semantics>
  <mrow>
   <mfrac>
    <mrow>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>x</mi>
        <mo>+</mo>
        <mi>h</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>-</mo>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mi>h</mi>
   </mfrac>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>f</ci>
      <apply>
       <plus></plus>
       <ci>x</ci>
       <ci>h</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>x</ci>
     </apply>
    </apply>
    <ci>h</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {f(x+h)-f(x)\over h}.
  </annotation>
 </semantics>
</math>

 This expression is <a href="Isaac_Newton" title="wikilink">Newton</a>'s <a href="difference_quotient" title="wikilink">difference quotient</a> (also know as a first-order <a href="divided_difference" title="wikilink">divided difference</a>.)</p>

<p>The slope of this secant line differs from the slope of the tangent line by an amount that is approximately proportional to <em>h</em>. As <em>h</em> approaches zero, the slope of the secant line approaches the slope of the tangent line. Therefore, the true <strong>derivative of</strong> <strong><em>f</em></strong> <strong>at</strong> <strong><em>x</em></strong> is the limit of the value of the difference quotient as the secant lines get closer and closer to being a tangent line:</p>

<p>

<math display="block" id="Numerical_differentiation:1">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msup>
      <mi>f</mi>
      <mo>′</mo>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <munder>
      <mo movablelimits="false">lim</mo>
      <mrow>
       <mi>h</mi>
       <mo>→</mo>
       <mn>0</mn>
      </mrow>
     </munder>
     <mfrac>
      <mrow>
       <mrow>
        <mi>f</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mi>x</mi>
          <mo>+</mo>
          <mi>h</mi>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>-</mo>
       <mrow>
        <mi>f</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>x</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
      <mi>h</mi>
     </mfrac>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>f</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>x</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <limit></limit>
      <apply>
       <ci>normal-→</ci>
       <ci>h</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <ci>f</ci>
        <apply>
         <plus></plus>
         <ci>x</ci>
         <ci>h</ci>
        </apply>
       </apply>
       <apply>
        <times></times>
        <ci>f</ci>
        <ci>x</ci>
       </apply>
      </apply>
      <ci>h</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f^{\prime}(x)=\lim_{h\to 0}{f(x+h)-f(x)\over h}.
  </annotation>
 </semantics>
</math>

</p>

<p>Since immediately <a href="substitution_(logic)" title="wikilink">substituting</a> 0 for <em>h</em> results in <a href="division_by_zero" title="wikilink">division by zero</a>, calculating the derivative directly can be unintuitive.</p>

<p>Equivalently, the slope could be estimated by employing positions (x - h) and x.</p>

<p>Another two-point formula is to compute the slope of a nearby secant line through the points (<em>x-h</em>,<em>f(x-h)</em>) and (<em>x+h</em>,<em>f(x+h)</em>). The slope of this line is</p>

<p>

<math display="block" id="Numerical_differentiation:2">
 <semantics>
  <mrow>
   <mfrac>
    <mrow>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>x</mi>
        <mo>+</mo>
        <mi>h</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>-</mo>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>x</mi>
        <mo>-</mo>
        <mi>h</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mrow>
     <mn>2</mn>
     <mi>h</mi>
    </mrow>
   </mfrac>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>f</ci>
      <apply>
       <plus></plus>
       <ci>x</ci>
       <ci>h</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <apply>
       <minus></minus>
       <ci>x</ci>
       <ci>h</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <cn type="integer">2</cn>
     <ci>h</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {f(x+h)-f(x-h)\over 2h}.
  </annotation>
 </semantics>
</math>

</p>

<p>This formula is known as the <a href="symmetric_difference_quotient" title="wikilink">symmetric difference quotient</a>. In this case the first-order errors cancel, so the slope of these secant lines differ from the slope of the tangent line by an amount that is approximately proportional to 

<math display="inline" id="Numerical_differentiation:3">
 <semantics>
  <msup>
   <mi>h</mi>
   <mn>2</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>h</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h^{2}
  </annotation>
 </semantics>
</math>

. Hence for small values of <em>h</em> this is a more accurate approximation to the tangent line than the one-sided estimation. Note however that although the slope is being computed at x, the value of the function at x is not involved.</p>

<p>The estimation error is given by:</p>

<p>

<math display="block" id="Numerical_differentiation:4">
 <semantics>
  <mrow>
   <mi>R</mi>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mrow>
      <mo>-</mo>
      <mrow>
       <msup>
        <mi>f</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mn>3</mn>
         <mo stretchy="false">)</mo>
        </mrow>
       </msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>c</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mn>6</mn>
    </mfrac>
    <msup>
     <mi>h</mi>
     <mn>2</mn>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>R</ci>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>f</ci>
         <cn type="integer">3</cn>
        </apply>
        <ci>c</ci>
       </apply>
      </apply>
      <cn type="integer">6</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>h</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R={{-f^{(3)}(c)}\over{6}}h^{2}
  </annotation>
 </semantics>
</math>

,</p>

<p>where 

<math display="inline" id="Numerical_differentiation:5">
 <semantics>
  <mi>c</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>c</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c
  </annotation>
 </semantics>
</math>

 is some point between 

<math display="inline" id="Numerical_differentiation:6">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>-</mo>
   <mi>h</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>x</ci>
    <ci>h</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x-h
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Numerical_differentiation:7">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>+</mo>
   <mi>h</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>x</ci>
    <ci>h</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x+h
  </annotation>
 </semantics>
</math>

. This error does not include the <a href="rounding_error" title="wikilink">rounding error</a> due to numbers being represented and calculations being performed in limited precision.</p>

<p>The symmetric difference quotient is employed as the method of approximating the derivative in a number of calculators, including <a class="uri" href="TI-82" title="wikilink">TI-82</a>, <a class="uri" href="TI-83" title="wikilink">TI-83</a>, <a class="uri" href="TI-84" title="wikilink">TI-84</a>, <a class="uri" href="TI-85" title="wikilink">TI-85</a> all of which use this method with <em>h</em>=0.001.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a><a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>

<p>Despite their practical popularity, finite difference formulas like the above two have been harshly criticized by some researchers, in particular by proponents of <a href="automatic_differentiation" title="wikilink">automatic differentiation</a>.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> because their simplicity must be set against the fact that their accuracy is low - in rough terms, calculations in six digit precision will produce a slope of only three-digit precision whereas evaluating a function that calculates the slope may still deliver nearly six-digit precision. For example, given f(x) = x<sup>2</sup>, calculating the slope from 2x will give near full precision, whereas the finite difference approximation will have difficulties as described below.</p>
<h3 id="practical-considerations-using-floating-point-arithmetic">Practical considerations using floating point arithmetic</h3>
<figure><b>(Figure)</b>
<figcaption>Example showing the difficulty of choosing 

<math display="inline" id="Numerical_differentiation:8">
 <semantics>
  <mi>h</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>h</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h
  </annotation>
 </semantics>
</math>

 due to both rounding error and formula error</figcaption>
</figure>

<p>An important consideration in practice when the function is approximated using <a href="floating_point" title="wikilink">floating point</a> arithmetic is how small a value of <em>h</em> to choose. If chosen too small, the subtraction will yield a large <a href="rounding_error" title="wikilink">rounding error</a>. In fact all the finite difference formulae are <a class="uri" href="ill-conditioned" title="wikilink">ill-conditioned</a><a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> and due to cancellation will produce a value of zero if <em>h</em> is small enough.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> If too large, the calculation of the slope of the secant line will be more accurately calculated, but the estimate of the slope of the tangent by using the secant could be worse.</p>

<p>A choice for <em>h</em> which is small without producing a large rounding error is 

<math display="inline" id="Numerical_differentiation:9">
 <semantics>
  <mrow>
   <msqrt>
    <mi>ε</mi>
   </msqrt>
   <mi>x</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <root></root>
     <ci>ε</ci>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sqrt{\varepsilon}x
  </annotation>
 </semantics>
</math>

 where the <a href="machine_epsilon" title="wikilink">machine epsilon</a> <em>ε</em> is typically of the order 2.2×10<sup>−16</sup>. <a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> This epsilon is for double precision (64-bit) variables: such calculations in single precision are rarely useful. The resulting value is unlikely to be a "round" number in binary, so it is important to realise that although <em>x</em> is a machine-<a href="Floating_point#Representable_numbers,_conversion_and_rounding" title="wikilink">representable</a> number, <em>x</em> + <em>h</em> almost certainly will not be. This means that <em>x</em> + <em>h</em> will be changed (via rounding or truncation) to a nearby machine-representable number, with the consequence that (<em>x</em> + <em>h</em>) - <em>x</em> will <em>not</em> equal <em>h</em>; the two function evaluations will not be exactly <em>h</em> apart. In this regard, since most decimal fractions are recurring sequences in binary (just as 1/3 is in decimal) a seemingly round step such as <em>h</em> = 0.1 will not be a round number in binary; it is 0.000110011001100... A possible approach is as follows:</p>

<p><code> h:=sqrt(eps)*max(abs(x), 1);</code><br/>
<code> xph:=x + h;</code><br/>
<code> dx:=xph - x;</code><br/>
<code> slope:=(F(xph) - F(x))/dx;</code></p>

<p>However, with computers, <a href="compiler_optimization" title="wikilink">compiler optimization</a> facilities may fail to attend to the details of actual computer arithmetic, and instead apply the axioms of mathematics to deduce that <em>dx</em> and <em>h</em> are the same. With C and similar languages, a directive that <em>xph</em> is a <a href="volatile_variable" title="wikilink">volatile variable</a> will prevent this.</p>
<h3 id="higher-order-methods">Higher-order methods</h3>

<p>Higher-order methods for approximating the derivative, as well as methods for higher derivatives exist.</p>

<p>Given below is the five point method for the first derivative (<a href="five-point_stencil" title="wikilink">five-point stencil</a> in one dimension).<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></p>

<p>

<math display="block" id="Numerical_differentiation:10">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>f</mi>
     <mo>′</mo>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mrow>
      <mrow>
       <mrow>
        <mrow>
         <mo>-</mo>
         <mrow>
          <mi>f</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mrow>
            <mi>x</mi>
            <mo>+</mo>
            <mrow>
             <mn>2</mn>
             <mi>h</mi>
            </mrow>
           </mrow>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
        </mrow>
        <mo>+</mo>
        <mrow>
         <mn>8</mn>
         <mi>f</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <mi>x</mi>
           <mo>+</mo>
           <mi>h</mi>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
       <mo>-</mo>
       <mrow>
        <mn>8</mn>
        <mi>f</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mi>x</mi>
          <mo>-</mo>
          <mi>h</mi>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
      <mo>+</mo>
      <mrow>
       <mi>f</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>x</mi>
         <mo>-</mo>
         <mrow>
          <mn>2</mn>
          <mi>h</mi>
         </mrow>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mrow>
      <mn>12</mn>
      <mi>h</mi>
     </mrow>
    </mfrac>
    <mo>+</mo>
    <mrow>
     <mfrac>
      <msup>
       <mi>h</mi>
       <mn>4</mn>
      </msup>
      <mn>30</mn>
     </mfrac>
     <msup>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mn>5</mn>
       <mo stretchy="false">)</mo>
      </mrow>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>c</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>f</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>x</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <divide></divide>
      <apply>
       <plus></plus>
       <apply>
        <minus></minus>
        <apply>
         <plus></plus>
         <apply>
          <minus></minus>
          <apply>
           <times></times>
           <ci>f</ci>
           <apply>
            <plus></plus>
            <ci>x</ci>
            <apply>
             <times></times>
             <cn type="integer">2</cn>
             <ci>h</ci>
            </apply>
           </apply>
          </apply>
         </apply>
         <apply>
          <times></times>
          <cn type="integer">8</cn>
          <ci>f</ci>
          <apply>
           <plus></plus>
           <ci>x</ci>
           <ci>h</ci>
          </apply>
         </apply>
        </apply>
        <apply>
         <times></times>
         <cn type="integer">8</cn>
         <ci>f</ci>
         <apply>
          <minus></minus>
          <ci>x</ci>
          <ci>h</ci>
         </apply>
        </apply>
       </apply>
       <apply>
        <times></times>
        <ci>f</ci>
        <apply>
         <minus></minus>
         <ci>x</ci>
         <apply>
          <times></times>
          <cn type="integer">2</cn>
          <ci>h</ci>
         </apply>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <cn type="integer">12</cn>
       <ci>h</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>h</ci>
        <cn type="integer">4</cn>
       </apply>
       <cn type="integer">30</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>f</ci>
       <cn type="integer">5</cn>
      </apply>
      <ci>c</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f^{\prime}(x)=\frac{-f(x+2h)+8f(x+h)-8f(x-h)+f(x-2h)}{12h}+\frac{h^{4}}{30}f^{%
(5)}(c)
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Numerical_differentiation:11">
 <semantics>
  <mrow>
   <mi>c</mi>
   <mo>∈</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mrow>
     <mi>x</mi>
     <mo>-</mo>
     <mrow>
      <mn>2</mn>
      <mi>h</mi>
     </mrow>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mi>x</mi>
     <mo>+</mo>
     <mrow>
      <mn>2</mn>
      <mi>h</mi>
     </mrow>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>c</ci>
    <interval closure="closed">
     <apply>
      <minus></minus>
      <ci>x</ci>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>h</ci>
      </apply>
     </apply>
     <apply>
      <plus></plus>
      <ci>x</ci>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>h</ci>
      </apply>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c\in[x-2h,x+2h]
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="differential-quadrature">Differential quadrature</h2>

<p><a href="Differential_quadrature" title="wikilink">Differential quadrature</a> is the approximation of derivatives by using weighted sums of function values.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a><a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> The name is in analogy with <em>quadrature</em> meaning <a href="Numerical_integration" title="wikilink">Numerical integration</a> where weighted sums are used in methods such as <a href="Simpson's_method" title="wikilink">Simpson's method</a> or the <a href="Trapezium_rule" title="wikilink">Trapezium rule</a>. There are various methods for determining the weight coefficients. Differential quadrature is used to solve <a href="partial_differential_equations" title="wikilink">partial differential equations</a>.</p>
<h2 id="complex-variable-methods">Complex variable methods</h2>

<p>The classical finite difference approximations for numerical differentiation are ill-conditioned. However, if 

<math display="inline" id="Numerical_differentiation:12">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 is a <a href="holomorphic_function" title="wikilink">holomorphic function</a>, real-valued on the real line, which can be evaluated at points in the complex plane near 

<math display="inline" id="Numerical_differentiation:13">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 then there are <a href="Numerical_stability" title="wikilink">stable</a> methods. For example,<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> the first derivative can be calculated by the complex-step derivative formula:<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a></p>

<p>

<math display="block" id="Numerical_differentiation:14">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>f</mi>
     <mo>′</mo>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≈</mo>
   <mrow>
    <mrow>
     <mi mathvariant="normal">ℑ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>f</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>x</mi>
         <mo>+</mo>
         <mrow>
          <mi>i</mi>
          <mi>h</mi>
         </mrow>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>/</mo>
    <mi>h</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>f</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>x</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <imaginary></imaginary>
      <apply>
       <times></times>
       <ci>f</ci>
       <apply>
        <plus></plus>
        <ci>x</ci>
        <apply>
         <times></times>
         <ci>i</ci>
         <ci>h</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <ci>h</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f^{\prime}(x)\approx\Im(f(x+ih))/h
  </annotation>
 </semantics>
</math>

.</p>

<p>The above formula is only valid for calculating a first-order derivative. A generalization of the above for calculating derivatives of any order derivatives employ <a href="multicomplex_numbers" title="wikilink">multicomplex numbers</a>, resulting in multicomplex derivatives.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a></p>

<p>In general, derivatives of any order can be calculated using <a href="Cauchy's_integral_formula" title="wikilink">Cauchy's integral formula</a>:</p>

<p>

<math display="block" id="Numerical_differentiation:15">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>a</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mrow>
      <mi>n</mi>
      <mo lspace="0pt" rspace="3.5pt">!</mo>
     </mrow>
     <mrow>
      <mn>2</mn>
      <mi>π</mi>
      <mi>i</mi>
     </mrow>
    </mfrac>
    <mrow>
     <msub>
      <mo largeop="true" symmetric="true">∮</mo>
      <mi>γ</mi>
     </msub>
     <mrow>
      <mpadded width="+1.7pt">
       <mfrac>
        <mrow>
         <mi>f</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>z</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <msup>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <mi>z</mi>
           <mo>-</mo>
           <mi>a</mi>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
         <mrow>
          <mi>n</mi>
          <mo>+</mo>
          <mn>1</mn>
         </mrow>
        </msup>
       </mfrac>
      </mpadded>
      <mi mathvariant="normal">d</mi>
      <mi>z</mi>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>f</ci>
      <ci>n</ci>
     </apply>
     <ci>a</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <apply>
       <factorial></factorial>
       <ci>n</ci>
      </apply>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>π</ci>
       <ci>i</ci>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <csymbol cd="latexml">contour-integral</csymbol>
       <ci>γ</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <apply>
         <times></times>
         <ci>f</ci>
         <ci>z</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <minus></minus>
          <ci>z</ci>
          <ci>a</ci>
         </apply>
         <apply>
          <plus></plus>
          <ci>n</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
       </apply>
       <ci>normal-d</ci>
       <ci>z</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f^{(n)}(a)={n!\over 2\pi i}\oint_{\gamma}{f(z)\over(z-a)^{n+1}}\,\mathrm{d}z
  </annotation>
 </semantics>
</math>

, where the integration is done <a href="Numerical_integration" title="wikilink">numerically</a>.</p>

<p>Using complex variables for numerical differentiation was started by Lyness and Moler in 1967.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a> A method based on numerical inversion of a complex <a href="Laplace_transform" title="wikilink">Laplace transform</a> was developed by Abate and Dubner.<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a> An algorithm which can be used without requiring knowledge about the method or the character of the function was developed by Fornberg.<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Automatic_differentiation" title="wikilink">Automatic differentiation</a></li>
<li><a href="Finite_difference" title="wikilink">Finite difference</a></li>
<li><a href="Five-point_stencil" title="wikilink">Five-point stencil</a></li>
<li><a href="Numerical_integration" title="wikilink">Numerical integration</a></li>
<li><a href="Numerical_ordinary_differential_equations" title="wikilink">Numerical ordinary differential equations</a></li>
<li><a href="Numerical_smoothing_and_differentiation" title="wikilink">Numerical smoothing and differentiation</a></li>
<li><a href="List_of_numerical_analysis_software" title="wikilink">List of numerical analysis software</a></li>
</ul>
<h2 id="references">References</h2>
<h2 id="external-links">External links</h2>
<ul>
<li><a class="uri" href="http://mathworld.wolfram.com/NumericalDifferentiation.html">http://mathworld.wolfram.com/NumericalDifferentiation.html</a></li>
<li><a class="uri" href="http://math.fullerton.edu/mathews/n2003/NumericalDiffMod.html">http://math.fullerton.edu/mathews/n2003/NumericalDiffMod.html</a></li>
<li><a href="http://numericalmethods.eng.usf.edu/topics/continuous_02dif.html">Numerical Differentiation Resources: Textbook notes, PPT, Worksheets, Audiovisual YouTube Lectures</a> at <a href="http://numericalmethods.eng.usf.edu/">Numerical Methods for STEM Undergraduate</a></li>
<li><a class="uri" href="ftp://math.nist.gov/pub/repository/diff/src/DIFF">ftp://math.nist.gov/pub/repository/diff/src/DIFF</a> Fortran code for the numerical differentiation of a function using Neville's process to extrapolate from a sequence of simple polynomial approximations.</li>
<li><a href="http://www.nag.co.uk/numeric/fl/nagdoc_fl24/html/D04/d04conts.html">NAG Library numerical differentiation routines</a></li>
<li><a class="uri" href="http://graphulator.com">http://graphulator.com</a> <a href="http://graphulator.com">Online numerical graphing calculator with calculus function.</a></li>
</ul>

<p>"</p>

<p><a href="Category:Numerical_analysis" title="wikilink">Category:Numerical analysis</a> <a href="Category:Differential_calculus" title="wikilink">Category:Differential calculus</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Richard L. Burden, J. Douglas Faires (2000), <em>Numerical Analysis</em>, (7th Ed), Brooks/Cole. ISBN 0-534-38216-9<a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5">Numerical Differentiation of Analytic Functions, B Fornberg - ACM Transactions on Mathematical Software (TOMS), 1981<a href="#fnref5">↩</a></li>
<li id="fn6">Using Complex Variables to Estimate Derivatives of Real Functions, W Squire, G Trapp - SIAM REVIEW, 1998<a href="#fnref6">↩</a></li>
<li id="fn7">Following <em><a href="Numerical_Recipes" title="wikilink">Numerical Recipes</a> in C</em>, <a href="http://www.nrbook.com/a/bookcpdf/c5-7.pdf">Chapter 5.7</a><a href="#fnref7">↩</a></li>
<li id="fn8">Abramowitz &amp; Stegun, Table 25.2<a href="#fnref8">↩</a></li>
<li id="fn9">Differential Quadrature and Its Application in Engineering: Engineering Applications, Chang Shu, Springer, 2000, ISBN 978-1-85233-209-9<a href="#fnref9">↩</a></li>
<li id="fn10">Advanced Differential Quadrature Methods, Yingyan Zhang, CRC Press, 2009, ISBN 978-1-4200-8248-7<a href="#fnref10">↩</a></li>
<li id="fn11"></li>
<li id="fn12"><a href="#fnref12">↩</a></li>
<li id="fn13"><a class="uri" href="http://russell.ae.utexas.edu/FinalPublications/ConferencePapers/2010Feb_SanDiego_AAS-10-218_mulicomplex.pdf">http://russell.ae.utexas.edu/FinalPublications/ConferencePapers/2010Feb_SanDiego_AAS-10-218_mulicomplex.pdf</a><a href="#fnref13">↩</a></li>
<li id="fn14"><a href="#fnref14">↩</a></li>
<li id="fn15"><a href="#fnref15">↩</a></li>
<li id="fn16"></li>
</ol>
</section>
</body>
</html>
