<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1589">Computation history</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Computation history</h1>
<hr/>

<p>In <a href="computer_science" title="wikilink">computer science</a>, a <strong>computation history</strong> is a sequence of steps taken by an <a href="abstract_machine" title="wikilink">abstract machine</a> in the process of computing its result. Computation histories are frequently used in <a href="Mathematical_proof" title="wikilink">proofs</a> about the capabilities of certain machines, and particularly about the <a href="undecidable_problem" title="wikilink">undecidability</a> of various <a href="formal_languages" title="wikilink">formal languages</a>.</p>

<p>Formally, a computation history is a (normally <a href="Finite_set" title="wikilink">finite</a>) sequence of <strong>configurations</strong> of a formal <a class="uri" href="automaton" title="wikilink">automaton</a>. Each configuration fully describes the status of the machine at a particular point. To be valid, certain conditions must hold:</p>
<ul>
<li>the first configuration must be a valid initial configuration of the automaton and</li>
<li>each transition between adjacent configurations must be valid according to the transition rules of the automaton.</li>
</ul>

<p>In addition, to be <strong>complete</strong>, a computation history must be finite and</p>
<ul>
<li>the final configuration must be a valid terminal configuration of the automaton.</li>
</ul>

<p>The definitions of "valid initial configuration", "valid transition", and "valid terminal configuration" vary for different kinds of formal machines.</p>

<p>A <a class="uri" href="deterministic" title="wikilink">deterministic</a> automaton has exactly one computation history for a given initial configuration, though the history may be infinite and therefore incomplete.</p>
<h2 id="finite-state-machines">Finite State Machines</h2>

<p>For a <a href="finite_state_machine" title="wikilink">finite state machine</a> 

<math display="inline" id="Computation_history:0">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

, a configuration is simply the current state of the machine, together with the remaining input. The first configuration must be the initial state of 

<math display="inline" id="Computation_history:1">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 and the complete input. A transition from a configuration 

<math display="inline" id="Computation_history:2">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>S</mi>
   <mo>,</mo>
   <mi>I</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>S</ci>
    <ci>I</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (S,I)
  </annotation>
 </semantics>
</math>

 to a configuration 

<math display="inline" id="Computation_history:3">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>T</mi>
   <mo>,</mo>
   <mi>J</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>T</ci>
    <ci>J</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (T,J)
  </annotation>
 </semantics>
</math>


 is allowed if 

<math display="inline" id="Computation_history:4">
 <semantics>
  <mrow>
   <mi>I</mi>
   <mo>=</mo>
   <mrow>
    <mi>a</mi>
    <mi>J</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>I</ci>
    <apply>
     <times></times>
     <ci>a</ci>
     <ci>J</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I=aJ
  </annotation>
 </semantics>
</math>

 for some input symbol 

<math display="inline" id="Computation_history:5">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 and if 

<math display="inline" id="Computation_history:6">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 has a transition from 

<math display="inline" id="Computation_history:7">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Computation_history:8">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>


 on input 

<math display="inline" id="Computation_history:9">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

. The final configuration must have the empty string 

<math display="inline" id="Computation_history:10">
 <semantics>
  <mi>ϵ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϵ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon
  </annotation>
 </semantics>
</math>

 as its remaining input; whether 

<math display="inline" id="Computation_history:11">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 has accepted or rejected the input depends on whether the final state is an accepting state. <a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>
<h2 id="turing-machines">Turing Machines</h2>

<p>Computation histories are more commonly used in reference to <a href="Turing_machines" title="wikilink">Turing machines</a>. The configuration of a single-tape Turing machine consists of the contents of the tape, the position of the read/write head on the tape, and the current state of the associated state machine; this is usually written</p>

<p>

<math display="inline" id="Computation_history:12">
 <semantics>
  <mrow>
   <mi mathvariant="normal">…</mi>
   <mn>0011010101</mn>
   <mi>q</mi>
   <mn>00110101010...</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-…</ci>
    <cn type="integer">0011010101</cn>
    <ci>q</ci>
    <cn type="float">00110101010...</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ...0011010101q00110101010...
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Computation_history:13">
 <semantics>
  <mi>q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q
  </annotation>
 </semantics>
</math>


 is the current state of the machine, represented in some way that's distinguishable from the tape language, and where 

<math display="inline" id="Computation_history:14">
 <semantics>
  <mi>q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q
  </annotation>
 </semantics>
</math>

 is positioned immediately before the position of the read/write head.</p>

<p>Consider a Turing machine 

<math display="inline" id="Computation_history:15">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 on input 

<math display="inline" id="Computation_history:16">
 <semantics>
  <mi>w</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>w</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w
  </annotation>
 </semantics>
</math>

. The first configuration must be 

<math display="inline" id="Computation_history:17">
 <semantics>
  <mrow>
   <msub>
    <mi>q</mi>
    <mn>0</mn>
   </msub>
   <msub>
    <mi>w</mi>
    <mn>0</mn>
   </msub>
   <msub>
    <mi>w</mi>
    <mn>1</mn>
   </msub>
   <mi mathvariant="normal">…</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>q</ci>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>w</ci>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>w</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q_{0}w_{0}w_{1}...
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Computation_history:18">
 <semantics>
  <msub>
   <mi>q</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>q</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q_{0}
  </annotation>
 </semantics>
</math>


 is the initial state of the Turing machine. The machine's state in the final configuration must be either 

<math display="inline" id="Computation_history:19">
 <semantics>
  <msub>
   <mi>q</mi>
   <mi>a</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>q</ci>
    <ci>a</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q_{a}
  </annotation>
 </semantics>
</math>

 (the accept state) or 

<math display="inline" id="Computation_history:20">
 <semantics>
  <msub>
   <mi>q</mi>
   <mi>r</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>q</ci>
    <ci>r</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q_{r}
  </annotation>
 </semantics>
</math>

 (the reject state). A configuration 

<math display="inline" id="Computation_history:21">
 <semantics>
  <msub>
   <mi>c</mi>
   <mrow>
    <mi>i</mi>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>c</ci>
    <apply>
     <plus></plus>
     <ci>i</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{i+1}
  </annotation>
 </semantics>
</math>

 is a valid successor to configuration 

<math display="inline" id="Computation_history:22">
 <semantics>
  <msub>
   <mi>c</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>c</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{i}
  </annotation>
 </semantics>
</math>

 if there's a transition from the state in 

<math display="inline" id="Computation_history:23">
 <semantics>
  <msub>
   <mi>c</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>c</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{i}
  </annotation>
 </semantics>
</math>


 to the state in 

<math display="inline" id="Computation_history:24">
 <semantics>
  <msub>
   <mi>c</mi>
   <mrow>
    <mi>i</mi>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>c</ci>
    <apply>
     <plus></plus>
     <ci>i</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{i+1}
  </annotation>
 </semantics>
</math>

 which manipulates the tape and moves the read/write head in a way that produces the result in 

<math display="inline" id="Computation_history:25">
 <semantics>
  <msub>
   <mi>c</mi>
   <mrow>
    <mi>i</mi>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>c</ci>
    <apply>
     <plus></plus>
     <ci>i</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{i+1}
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>
<h3 id="decidability-results">Decidability results</h3>

<p>Computation histories can be used to show that certain problems for <a href="pushdown_automata" title="wikilink">pushdown automata</a> are <a href="undecidable_problem" title="wikilink">undecidable</a>. This is because the language of non-accepting computation histories of a Turing machine 

<math display="inline" id="Computation_history:26">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 on input 

<math display="inline" id="Computation_history:27">
 <semantics>
  <mi>w</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>w</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w
  </annotation>
 </semantics>
</math>

 is a <a href="context-free_language" title="wikilink">context-free language</a> recognizable by a non-deterministic pushdown automaton.</p>

<p>We encode a Turing computation history 

<math display="inline" id="Computation_history:28">
 <semantics>
  <mrow>
   <msub>
    <mi>c</mi>
    <mn>0</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>c</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>c</mi>
    <mi>n</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>c</ci>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>c</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>c</ci>
     <ci>n</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{0},c_{1},...,c_{n}
  </annotation>
 </semantics>
</math>


 as the string 

<math display="inline" id="Computation_history:29">
 <semantics>
  <mrow>
   <msub>
    <mi>C</mi>
    <mn>0</mn>
   </msub>
   <mi mathvariant="normal">#</mi>
   <msubsup>
    <mi>C</mi>
    <mn>1</mn>
    <mi>r</mi>
   </msubsup>
   <mi mathvariant="normal">#</mi>
   <msub>
    <mi>C</mi>
    <mn>2</mn>
   </msub>
   <mi mathvariant="normal">#</mi>
   <msubsup>
    <mi>C</mi>
    <mn>3</mn>
    <mi>r</mi>
   </msubsup>
   <mi mathvariant="normal">#</mi>
   <mi mathvariant="normal">…</mi>
   <mi mathvariant="normal">#</mi>
   <msub>
    <mi>C</mi>
    <mi>n</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <cn type="integer">0</cn>
    </apply>
    <ci>normal-#</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>C</ci>
      <ci>r</ci>
     </apply>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-#</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>normal-#</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>C</ci>
      <ci>r</ci>
     </apply>
     <cn type="integer">3</cn>
    </apply>
    <ci>normal-#</ci>
    <ci>normal-…</ci>
    <ci>normal-#</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{0}\#C^{r}_{1}\#C_{2}\#C^{r}_{3}\#...\#C_{n}
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Computation_history:30">
 <semantics>
  <msub>
   <mi>C</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>C</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{i}
  </annotation>
 </semantics>
</math>

 is the encoding of configuration 

<math display="inline" id="Computation_history:31">
 <semantics>
  <msub>
   <mi>c</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>c</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{i}
  </annotation>
 </semantics>
</math>

, as discussed above, and where every other configuration is written in reverse. Before reading a particular configuration, the pushdown automaton makes a non-deterministic choice to either ignore the configuration or read it completely onto the stack.</p>
<ul>
<li>If the pushdown automaton decides to ignore the configuration, it simply reads and discards it completely and makes the same choice for the next one.</li>
<li>If it decides to process the configuration, it pushes it completely onto the stack, then verifies that the next configuration is a valid successor according to the rules of 

<math display="inline" id="Computation_history:32">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

. Since successive configurations are always written in opposite orders, this can be done by, for each tape symbol in the new configuration, popping off a symbol from the stack and checking if they're the same. Where they disagree, it must be accountable for by a valid transition of 

<math display="inline" id="Computation_history:33">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>


. If, at any point, the automaton decides that the transition is invalid, it immediately enters a special accept state which ignores the rest of the input and accepts at the end.</li>
</ul>

<p>In addition, the automaton verifies that the first configuration is the correct initial configuration (if not, it accepts) and that the state of the final configuration of the history is the accept state (if not, it accepts). Since a non-deterministic automaton accepts if there's any valid way for it to accept, the automaton described here will discover if the history is not a valid accepting history and will accept if so, and reject if not. <a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>

<p>This same trick cannot be used to recognize <em>accepting</em> computation histories with an NPDA, since non-determinism could be used to skip past a test that would otherwise fail. A linear-bounded Turing machine is sufficient to recognize accepting computation histories.</p>

<p>This result allows us to prove that 

<math display="inline" id="Computation_history:34">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mi>L</mi>
   <msub>
    <mi>L</mi>
    <mrow>
     <mi>P</mi>
     <mi>D</mi>
     <mi>A</mi>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>A</ci>
    <ci>L</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>L</ci>
     <apply>
      <times></times>
      <ci>P</ci>
      <ci>D</ci>
      <ci>A</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ALL_{PDA}
  </annotation>
 </semantics>
</math>

, the language of pushdown automata which accept all input, is undecidable. Suppose we have a decider for it, 

<math display="inline" id="Computation_history:35">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>

. For any Turing machine 

<math display="inline" id="Computation_history:36">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 and input 

<math display="inline" id="Computation_history:37">
 <semantics>
  <mi>w</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>w</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w
  </annotation>
 </semantics>
</math>

, we can form the pushdown automaton 

<math display="inline" id="Computation_history:38">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>


 which accepts non-accepting computation histories for that machine. 

<math display="inline" id="Computation_history:39">
 <semantics>
  <mrow>
   <mi>D</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>P</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>D</ci>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D(P)
  </annotation>
 </semantics>
</math>

 will accept if and only if there are no accepting computation histories for 

<math display="inline" id="Computation_history:40">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 on 

<math display="inline" id="Computation_history:41">
 <semantics>
  <mi>w</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>w</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w
  </annotation>
 </semantics>
</math>

; this would allow us to decide 

<math display="inline" id="Computation_history:42">
 <semantics>
  <msub>
   <mi>A</mi>
   <mrow>
    <mi>T</mi>
    <mi>M</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>A</ci>
    <apply>
     <times></times>
     <ci>T</ci>
     <ci>M</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{TM}
  </annotation>
 </semantics>
</math>

, which we know to be undecidable.</p>
<h2 id="references">References</h2>

<p>"</p>

<p><a href="Category:Theory_of_computation" title="wikilink">Category:Theory of computation</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
</ol>
</section>
</body>
</html>
