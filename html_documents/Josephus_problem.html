<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1497">Josephus problem</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Josephus problem</h1>
<hr/>

<p>In <a href="computer_science" title="wikilink">computer science</a> and <a class="uri" href="mathematics" title="wikilink">mathematics</a>, the <strong>Josephus Problem</strong> (or <strong>Josephus permutation</strong>) is a theoretical problem related to a certain <a href="counting-out_game" title="wikilink">counting-out game</a>.</p>

<p>There are people standing in a <a class="uri" href="circle" title="wikilink">circle</a> waiting to be executed. The counting out begins at some point in the circle and proceeds around the circle in a fixed direction. In each step, a certain number of people are skipped and the next person is executed. The elimination proceeds around the circle (which is becoming smaller and smaller as the executed people are removed), until only the last person remains, who is given freedom.</p>

<p>The task is to choose the place in the initial circle so that you are the last one remaining and so survive.</p>
<h2 id="history">History</h2>

<p>The problem is named after <a href="Flavius_Josephus" title="wikilink">Flavius Josephus</a>, a Jewish historian living in the 1st century. According to Josephus' account of the <a href="siege_of_Yodfat" title="wikilink">siege of Yodfat</a>, he and his 40 soldiers were trapped in a cave, the exit of which was blocked by <a href="Roman_soldiers" title="wikilink">Romans</a>. They chose suicide over capture and decided that they would form a circle and start killing themselves using a step of three. Josephus states that by luck or possibly by the hand of God, he and another man remained the last and gave up to the Romans.</p>

<p>The reference comes from Book 3, Chapter 8, par 7 of Josephus' <em><a href="The_Jewish_War" title="wikilink">The Jewish War</a></em> (writing of himself in the third person):</p>

<p><mtpl></mtpl></p>
<h2 id="solution">Solution</h2>

<p>In the following, 

<math display="inline" id="Josephus_problem:0">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 denotes the number of people in the initial circle, and 

<math display="inline" id="Josephus_problem:1">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 denotes the count for each step, that is, 

<math display="inline" id="Josephus_problem:2">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>-</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>k</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k-1
  </annotation>
 </semantics>
</math>

 people are skipped and the 

<math display="inline" id="Josephus_problem:3">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

-th is executed. The people in the circle are numbered from 

<math display="inline" id="Josephus_problem:4">
 <semantics>
  <mn>1</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">1</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Josephus_problem:5">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

.</p>

<p>===k=2=== We explicitly solve the problem when every 2nd person will be killed, i.e. 

<math display="inline" id="Josephus_problem:6">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>=</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>k</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k=2
  </annotation>
 </semantics>
</math>

. (For the more general case 

<math display="inline" id="Josephus_problem:7">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>≠</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <neq></neq>
    <ci>k</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k\neq 2
  </annotation>
 </semantics>
</math>

, we outline a solution below.) We express the solution recursively. Let 

<math display="inline" id="Josephus_problem:8">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(n)
  </annotation>
 </semantics>
</math>

 denote the position of the survivor when there are initially 

<math display="inline" id="Josephus_problem:9">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 people (and 

<math display="inline" id="Josephus_problem:10">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>=</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>k</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k=2
  </annotation>
 </semantics>
</math>

). The first time around the circle, all of the even-numbered people die. The second time around the circle, the new 2nd person dies, then the new 4th person, etc.; it's as though there were no first time around the circle.</p>

<p>If the initial number of people was even, then the person in position 

<math display="inline" id="Josephus_problem:11">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 during the second time around the circle was originally in position 

<math display="inline" id="Josephus_problem:12">
 <semantics>
  <mrow>
   <mrow>
    <mn>2</mn>
    <mi>x</mi>
   </mrow>
   <mo>-</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <apply>
     <times></times>
     <cn type="integer">2</cn>
     <ci>x</ci>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2x-1
  </annotation>
 </semantics>
</math>

 (for every choice of 

<math display="inline" id="Josephus_problem:13">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

). Let 

<math display="inline" id="Josephus_problem:14">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>=</mo>
   <mrow>
    <mn>2</mn>
    <mi>j</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>n</ci>
    <apply>
     <times></times>
     <cn type="integer">2</cn>
     <ci>j</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n=2j
  </annotation>
 </semantics>
</math>

. The person at 

<math display="inline" id="Josephus_problem:15">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>j</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(j)
  </annotation>
 </semantics>
</math>

 who will now survive was originally in position 

<math display="inline" id="Josephus_problem:16">
 <semantics>
  <mrow>
   <mrow>
    <mn>2</mn>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>j</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>-</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <apply>
     <times></times>
     <cn type="integer">2</cn>
     <ci>f</ci>
     <ci>j</ci>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2f(j)-1
  </annotation>
 </semantics>
</math>

. This gives us the recurrence</p>

<p>

<math display="block" id="Josephus_problem:17">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mn>2</mn>
      <mi>j</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mn>2</mn>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>j</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mn>1 .</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <ci>j</ci>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <ci>f</ci>
      <ci>j</ci>
     </apply>
     <cn type="float">1 .</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(2j)=2f(j)-1\;.
  </annotation>
 </semantics>
</math>

</p>

<p>If the initial number of people was odd, then we think of person 1 as dying at the end of the first time around the circle. Again, during the second time around the circle, the new 2nd person dies, then the new 4th person, etc. In this case, the person in position 

<math display="inline" id="Josephus_problem:18">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 was originally in position 

<math display="inline" id="Josephus_problem:19">
 <semantics>
  <mrow>
   <mrow>
    <mn>2</mn>
    <mi>x</mi>
   </mrow>
   <mo>+</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <times></times>
     <cn type="integer">2</cn>
     <ci>x</ci>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2x+1
  </annotation>
 </semantics>
</math>

. This gives us the recurrence</p>

<p>

<math display="block" id="Josephus_problem:20">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mn>2</mn>
       <mi>j</mi>
      </mrow>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mn>2</mn>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>j</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mn>1 .</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>j</ci>
      </apply>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <ci>f</ci>
      <ci>j</ci>
     </apply>
     <cn type="float">1 .</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(2j+1)=2f(j)+1\;.
  </annotation>
 </semantics>
</math>

</p>

<p>When we tabulate the values of 

<math display="inline" id="Josephus_problem:21">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Josephus_problem:22">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(n)
  </annotation>
 </semantics>
</math>

 we see a pattern:</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>

<math display="inline" id="Josephus_problem:23">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>2</p></td>
<td style="text-align: left;">
<p>3</p></td>
<td style="text-align: left;">
<p>4</p></td>
<td style="text-align: left;">
<p>5</p></td>
<td style="text-align: left;">
<p>6</p></td>
<td style="text-align: left;">
<p>7</p></td>
<td style="text-align: left;">
<p>8</p></td>
<td style="text-align: left;">
<p>9</p></td>
<td style="text-align: left;">
<p>10</p></td>
<td style="text-align: left;">
<p>11</p></td>
<td style="text-align: left;">
<p>12</p></td>
<td style="text-align: left;">
<p>13</p></td>
<td style="text-align: left;">
<p>14</p></td>
<td style="text-align: left;">
<p>15</p></td>
<td style="text-align: left;">
<p>16</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>

<math display="inline" id="Josephus_problem:24">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(n)
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>3</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>3</p></td>
<td style="text-align: left;">
<p>5</p></td>
<td style="text-align: left;">
<p>7</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>3</p></td>
<td style="text-align: left;">
<p>5</p></td>
<td style="text-align: left;">
<p>7</p></td>
<td style="text-align: left;">
<p>9</p></td>
<td style="text-align: left;">
<p>11</p></td>
<td style="text-align: left;">
<p>13</p></td>
<td style="text-align: left;">
<p>15</p></td>
<td style="text-align: left;">
<p>1</p></td>
</tr>
</tbody>
</table>

<p>This suggests that 

<math display="inline" id="Josephus_problem:25">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(n)
  </annotation>
 </semantics>
</math>

 is an increasing odd sequence that restarts with 

<math display="inline" id="Josephus_problem:26">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>n</ci>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(n)=1
  </annotation>
 </semantics>
</math>

 whenever the index <em>n</em> is a power of 2. Therefore, if we choose <em>m</em> and <em>l</em> so that 

<math display="inline" id="Josephus_problem:27">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>=</mo>
   <mrow>
    <msup>
     <mn>2</mn>
     <mi>m</mi>
    </msup>
    <mo>+</mo>
    <mi>l</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>n</ci>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <ci>m</ci>
     </apply>
     <ci>l</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n=2^{m}+l
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Josephus_problem:28">
 <semantics>
  <mrow>
   <mn>0</mn>
   <mo>≤</mo>
   <mi>l</mi>
   <mo><</mo>
   <msup>
    <mn>2</mn>
    <mi>m</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <cn type="integer">0</cn>
     <ci>l</ci>
    </apply>
    <apply>
     <lt></lt>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <ci>m</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0\leq l<2^{m}
  </annotation>
 </semantics>
</math>

, then 

<math display="inline" id="Josephus_problem:29">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mn>2</mn>
     <mo>⋅</mo>
     <mi>l</mi>
    </mrow>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <ci>normal-⋅</ci>
      <cn type="integer">2</cn>
      <ci>l</ci>
     </apply>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(n)=2\cdot l+1
  </annotation>
 </semantics>
</math>

. It is clear that values in the table satisfy this equation. Or we can think that after 

<math display="inline" id="Josephus_problem:30">
 <semantics>
  <mi>l</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>l</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   l
  </annotation>
 </semantics>
</math>

 people are dead there are only 

<math display="inline" id="Josephus_problem:31">
 <semantics>
  <msup>
   <mn>2</mn>
   <mi>m</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{m}
  </annotation>
 </semantics>
</math>

 people and we go to the 

<math display="inline" id="Josephus_problem:32">
 <semantics>
  <mrow>
   <mrow>
    <mn>2</mn>
    <mi>l</mi>
   </mrow>
   <mo>+</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <times></times>
     <cn type="integer">2</cn>
     <ci>l</ci>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2l+1
  </annotation>
 </semantics>
</math>

th person. He must be the survivor. So 

<math display="inline" id="Josephus_problem:33">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mn>2</mn>
     <mi>l</mi>
    </mrow>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <ci>l</ci>
     </apply>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(n)=2l+1
  </annotation>
 </semantics>
</math>

. Below, we give a proof by induction.</p>

<p><strong>Theorem:</strong> If 

<math display="inline" id="Josephus_problem:34">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>=</mo>
   <mrow>
    <msup>
     <mn>2</mn>
     <mi>m</mi>
    </msup>
    <mo>+</mo>
    <mi>l</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>n</ci>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <ci>m</ci>
     </apply>
     <ci>l</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n=2^{m}+l
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Josephus_problem:35">
 <semantics>
  <mrow>
   <mn>0</mn>
   <mo>≤</mo>
   <mi>l</mi>
   <mo><</mo>
   <msup>
    <mn>2</mn>
    <mi>m</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <cn type="integer">0</cn>
     <ci>l</ci>
    </apply>
    <apply>
     <lt></lt>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <ci>m</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0\leq l<2^{m}
  </annotation>
 </semantics>
</math>

, then 

<math display="inline" id="Josephus_problem:36">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mn>2</mn>
     <mi>l</mi>
    </mrow>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <ci>l</ci>
     </apply>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(n)=2l+1
  </annotation>
 </semantics>
</math>

.</p>

<p><strong>Proof:</strong> We use <a href="strong_induction" title="wikilink">strong induction</a> on 

<math display="inline" id="Josephus_problem:37">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

. The base case 

<math display="inline" id="Josephus_problem:38">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>n</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n=1
  </annotation>
 </semantics>
</math>

 is true. We consider separately the cases when 

<math display="inline" id="Josephus_problem:39">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 is even and when 

<math display="inline" id="Josephus_problem:40">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 is odd.</p>

<p>If 

<math display="inline" id="Josephus_problem:41">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 is even, then choose 

<math display="inline" id="Josephus_problem:42">
 <semantics>
  <msub>
   <mi>l</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>l</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   l_{1}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Josephus_problem:43">
 <semantics>
  <msub>
   <mi>m</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>m</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m_{1}
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Josephus_problem:44">
 <semantics>
  <mrow>
   <mrow>
    <mi>n</mi>
    <mo>/</mo>
    <mn>2</mn>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msup>
     <mn>2</mn>
     <msub>
      <mi>m</mi>
      <mn>1</mn>
     </msub>
    </msup>
    <mo>+</mo>
    <msub>
     <mi>l</mi>
     <mn>1</mn>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <divide></divide>
     <ci>n</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>m</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>l</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n/2=2^{m_{1}}+l_{1}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Josephus_problem:45">
 <semantics>
  <mrow>
   <mn>0</mn>
   <mo>≤</mo>
   <msub>
    <mi>l</mi>
    <mn>1</mn>
   </msub>
   <mo><</mo>
   <msup>
    <mn>2</mn>
    <msub>
     <mi>m</mi>
     <mn>1</mn>
    </msub>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <cn type="integer">0</cn>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>l</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <lt></lt>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>m</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0\leq l_{1}<2^{m_{1}}
  </annotation>
 </semantics>
</math>

. Note that 

<math display="inline" id="Josephus_problem:46">
 <semantics>
  <mrow>
   <msub>
    <mi>l</mi>
    <mn>1</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <mi>l</mi>
    <mo>/</mo>
    <mn>2</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>l</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <divide></divide>
     <ci>l</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   l_{1}=l/2
  </annotation>
 </semantics>
</math>

. We have 

<math display="inline" id="Josephus_problem:47">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mn>2</mn>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>n</mi>
       <mo>/</mo>
       <mn>2</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mn>2</mn>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mn>2</mn>
         <msub>
          <mi>l</mi>
          <mn>1</mn>
         </msub>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mn>2</mn>
     <mi>l</mi>
    </mrow>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>f</ci>
       <apply>
        <divide></divide>
        <ci>n</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <apply>
        <plus></plus>
        <apply>
         <times></times>
         <cn type="integer">2</cn>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>l</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>l</ci>
      </apply>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(n)=2f(n/2)-1=2((2l_{1})+1)-1=2l+1
  </annotation>
 </semantics>
</math>

, where the second equality follows from the induction hypothesis.</p>

<p>If 

<math display="inline" id="Josephus_problem:48">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 is odd, then choose 

<math display="inline" id="Josephus_problem:49">
 <semantics>
  <msub>
   <mi>l</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>l</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   l_{1}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Josephus_problem:50">
 <semantics>
  <msub>
   <mi>m</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>m</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m_{1}
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Josephus_problem:51">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>n</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>/</mo>
    <mn>2</mn>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msup>
     <mn>2</mn>
     <msub>
      <mi>m</mi>
      <mn>1</mn>
     </msub>
    </msup>
    <mo>+</mo>
    <msub>
     <mi>l</mi>
     <mn>1</mn>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <divide></divide>
     <apply>
      <minus></minus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>m</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>l</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (n-1)/2=2^{m_{1}}+l_{1}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Josephus_problem:52">
 <semantics>
  <mrow>
   <mn>0</mn>
   <mo>≤</mo>
   <msub>
    <mi>l</mi>
    <mn>1</mn>
   </msub>
   <mo><</mo>
   <msup>
    <mn>2</mn>
    <msub>
     <mi>m</mi>
     <mn>1</mn>
    </msub>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <cn type="integer">0</cn>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>l</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <lt></lt>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>m</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0\leq l_{1}<2^{m_{1}}
  </annotation>
 </semantics>
</math>

. Note that 

<math display="inline" id="Josephus_problem:53">
 <semantics>
  <mrow>
   <msub>
    <mi>l</mi>
    <mn>1</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>l</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>/</mo>
    <mn>2</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>l</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <minus></minus>
      <ci>l</ci>
      <cn type="integer">1</cn>
     </apply>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   l_{1}=(l-1)/2
  </annotation>
 </semantics>
</math>

. We have 

<math display="inline" id="Josephus_problem:54">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mn>2</mn>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>n</mi>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mo>/</mo>
       <mn>2</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mn>2</mn>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mn>2</mn>
         <msub>
          <mi>l</mi>
          <mn>1</mn>
         </msub>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mn>2</mn>
     <mi>l</mi>
    </mrow>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>f</ci>
       <apply>
        <divide></divide>
        <apply>
         <minus></minus>
         <ci>n</ci>
         <cn type="integer">1</cn>
        </apply>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <apply>
        <plus></plus>
        <apply>
         <times></times>
         <cn type="integer">2</cn>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>l</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>l</ci>
      </apply>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(n)=2f((n-1)/2)+1=2((2l_{1})+1)+1=2l+1
  </annotation>
 </semantics>
</math>

, where the second equality follows from the induction hypothesis. This completes the proof.</p>

<p>We can solve for 

<math display="inline" id="Josephus_problem:55">
 <semantics>
  <mi>l</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>l</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   l
  </annotation>
 </semantics>
</math>

 to get an explicit expression for 

<math display="inline" id="Josephus_problem:56">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(n)
  </annotation>
 </semantics>
</math>

:</p>

<p>

<math display="block" id="Josephus_problem:57">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mn>2</mn>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <msup>
        <mn>2</mn>
        <mrow>
         <mo stretchy="false">⌊</mo>
         <mrow>
          <msub>
           <mi>log</mi>
           <mn>2</mn>
          </msub>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>n</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo stretchy="false">⌋</mo>
        </mrow>
       </msup>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <apply>
       <minus></minus>
       <ci>n</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <cn type="integer">2</cn>
        <apply>
         <floor></floor>
         <apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <log></log>
           <cn type="integer">2</cn>
          </apply>
          <ci>n</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(n)=2(n-2^{\lfloor\log_{2}(n)\rfloor})+1
  </annotation>
 </semantics>
</math>

</p>

<p>The most elegant form of the answer involves the binary representation of size 

<math display="inline" id="Josephus_problem:58">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>



<math display="block" id="Josephus_problem:59">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(n)
  </annotation>
 </semantics>
</math>

 can be obtained by a one-bit left cyclic shift of 

<math display="inline" id="Josephus_problem:60">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 itself. If we represent 

<math display="inline" id="Josephus_problem:61">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 in binary as 

<math display="inline" id="Josephus_problem:62">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <msub>
     <mi>b</mi>
     <mn>1</mn>
    </msub>
    <msub>
     <mi>b</mi>
     <mn>2</mn>
    </msub>
    <msub>
     <mi>b</mi>
     <mn>3</mn>
    </msub>
    <mi mathvariant="normal">…</mi>
    <msub>
     <mi>b</mi>
     <mi>m</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>n</ci>
    <apply>
     <times></times>
     <cn type="integer">1</cn>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>b</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>b</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>b</ci>
      <cn type="integer">3</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>b</ci>
      <ci>m</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n=1b_{1}b_{2}b_{3}\dots b_{m}
  </annotation>
 </semantics>
</math>

, then the solution is given by 

<math display="inline" id="Josephus_problem:63">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>b</mi>
     <mn>1</mn>
    </msub>
    <msub>
     <mi>b</mi>
     <mn>2</mn>
    </msub>
    <msub>
     <mi>b</mi>
     <mn>3</mn>
    </msub>
    <mi mathvariant="normal">…</mi>
    <msub>
     <mi>b</mi>
     <mi>m</mi>
    </msub>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>b</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>b</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>b</ci>
      <cn type="integer">3</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>b</ci>
      <ci>m</ci>
     </apply>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(n)=b_{1}b_{2}b_{3}\dots b_{m}1
  </annotation>
 </semantics>
</math>

. The proof of this follows from the representation of 

<math display="inline" id="Josephus_problem:64">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 as 

<math display="inline" id="Josephus_problem:65">
 <semantics>
  <mrow>
   <msup>
    <mn>2</mn>
    <mi>m</mi>
   </msup>
   <mo>+</mo>
   <mi>l</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <ci>m</ci>
    </apply>
    <ci>l</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{m}+l
  </annotation>
 </semantics>
</math>

 or from the above expression for 

<math display="inline" id="Josephus_problem:66">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(n)
  </annotation>
 </semantics>
</math>

.</p>
<h3 id="the-general-case">The general case</h3>

<p>The easiest way to solve this problem in the general case is to use <a href="dynamic_programming" title="wikilink">dynamic programming</a> by performing the first step and then using the solution of the remaining problem. When the index starts from one, then the person at 

<math display="inline" id="Josephus_problem:67">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

 shifts from the first person is in position 

<math display="inline" id="Josephus_problem:68">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>s</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo lspace="2.5pt" rspace="2.5pt">mod</mo>
     <mi>n</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>+</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <csymbol cd="latexml">modulo</csymbol>
     <apply>
      <minus></minus>
      <ci>s</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>n</ci>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ((s-1)\bmod n)+1
  </annotation>
 </semantics>
</math>

, where n is the total number of persons. Let 

<math display="inline" id="Josephus_problem:69">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo>,</mo>
    <mi>k</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <interval closure="open">
     <ci>n</ci>
     <ci>k</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(n,k)
  </annotation>
 </semantics>
</math>

 denote the position of the survivor. After the 

<math display="inline" id="Josephus_problem:70">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

-th person is killed, we're left with a circle of 

<math display="inline" id="Josephus_problem:71">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>-</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>n</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n-1
  </annotation>
 </semantics>
</math>

, and we start the next count with the person whose number in the original problem was 

<math display="inline" id="Josephus_problem:72">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>k</mi>
     <mo lspace="2.5pt" rspace="2.5pt">mod</mo>
     <mi>n</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>+</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <csymbol cd="latexml">modulo</csymbol>
     <ci>k</ci>
     <ci>n</ci>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (k\bmod n)+1
  </annotation>
 </semantics>
</math>

. The position of the survivor in the remaining circle would be 

<math display="inline" id="Josephus_problem:73">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>n</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
    <mo>,</mo>
    <mi>k</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <interval closure="open">
     <apply>
      <minus></minus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>k</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(n-1,k)
  </annotation>
 </semantics>
</math>

 if we start counting at 

<math display="inline" id="Josephus_problem:74">
 <semantics>
  <mn>1</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">1</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1
  </annotation>
 </semantics>
</math>

; shifting this to account for the fact that we're starting at 

<math display="inline" id="Josephus_problem:75">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>k</mi>
     <mo lspace="2.5pt" rspace="2.5pt">mod</mo>
     <mi>n</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>+</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <csymbol cd="latexml">modulo</csymbol>
     <ci>k</ci>
     <ci>n</ci>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (k\bmod n)+1
  </annotation>
 </semantics>
</math>

 yields the recurrence</p>

<p>

<math display="block" id="Josephus_problem:76">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>n</mi>
       <mo>,</mo>
       <mi>k</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>=</mo>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mrow>
           <mrow>
            <mi>f</mi>
            <mrow>
             <mo stretchy="false">(</mo>
             <mrow>
              <mi>n</mi>
              <mo>-</mo>
              <mn>1</mn>
             </mrow>
             <mo>,</mo>
             <mi>k</mi>
             <mo stretchy="false">)</mo>
            </mrow>
           </mrow>
           <mo>+</mo>
           <mi>k</mi>
          </mrow>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
        <mo lspace="2.5pt" rspace="2.5pt">mod</mo>
        <mi>n</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mrow>
      <mtext>with</mtext>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mn>1</mn>
       <mo>,</mo>
       <mi>k</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>=</mo>
     <mpadded width="+1.7pt">
      <mn>1</mn>
     </mpadded>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>f</ci>
      <interval closure="open">
       <ci>n</ci>
       <ci>k</ci>
      </interval>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="latexml">modulo</csymbol>
       <apply>
        <minus></minus>
        <apply>
         <plus></plus>
         <apply>
          <times></times>
          <ci>f</ci>
          <interval closure="open">
           <apply>
            <minus></minus>
            <ci>n</ci>
            <cn type="integer">1</cn>
           </apply>
           <ci>k</ci>
          </interval>
         </apply>
         <ci>k</ci>
        </apply>
        <cn type="integer">1</cn>
       </apply>
       <ci>n</ci>
      </apply>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <mtext>with</mtext>
      <ci>f</ci>
      <interval closure="open">
       <cn type="integer">1</cn>
       <ci>k</ci>
      </interval>
     </apply>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(n,k)=((f(n-1,k)+k-1)\bmod n)+1,\text{ with }f(1,k)=1\,,
  </annotation>
 </semantics>
</math>

</p>

<p>which takes the simpler form</p>

<p>

<math display="block" id="Josephus_problem:77">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>g</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo>,</mo>
      <mi>k</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <mi>g</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mi>n</mi>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
         <mo>,</mo>
         <mi>k</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>+</mo>
       <mi>k</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo lspace="2.5pt" rspace="2.5pt">mod</mo>
     <mi>n</mi>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mrow>
     <mtext>with</mtext>
     <mi>g</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>1</mn>
      <mo>,</mo>
      <mi>k</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mn>0</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>g</ci>
      <interval closure="open">
       <ci>n</ci>
       <ci>k</ci>
      </interval>
     </apply>
     <apply>
      <csymbol cd="latexml">modulo</csymbol>
      <apply>
       <plus></plus>
       <apply>
        <times></times>
        <ci>g</ci>
        <interval closure="open">
         <apply>
          <minus></minus>
          <ci>n</ci>
          <cn type="integer">1</cn>
         </apply>
         <ci>k</ci>
        </interval>
       </apply>
       <ci>k</ci>
      </apply>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <mtext>with</mtext>
      <ci>g</ci>
      <interval closure="open">
       <cn type="integer">1</cn>
       <ci>k</ci>
      </interval>
     </apply>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g(n,k)=(g(n-1,k)+k)\bmod n,\text{ with }g(1,k)=0
  </annotation>
 </semantics>
</math>

</p>

<p>if we number the positions from 

<math display="inline" id="Josephus_problem:78">
 <semantics>
  <mn>0</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">0</cn>
  </annotation-xml>
 </semantics>
</math>

 to 

<math display="inline" id="Josephus_problem:79">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>-</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>n</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n-1
  </annotation>
 </semantics>
</math>

 instead.</p>

<p>This approach has <a href="Big-O_notation" title="wikilink">running time</a> 

<math display="inline" id="Josephus_problem:80">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n)
  </annotation>
 </semantics>
</math>

, but for small 

<math display="inline" id="Josephus_problem:81">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 and large 

<math display="inline" id="Josephus_problem:82">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 there is another approach. The second approach also uses dynamic programming but has running time 

<math display="inline" id="Josephus_problem:83">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>k</mi>
     <mrow>
      <mi>log</mi>
      <mi>n</mi>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>k</ci>
     <apply>
      <log></log>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(k\log n)
  </annotation>
 </semantics>
</math>

. It is based on considering killing <em>k</em>-th, 2<em>k</em>-th, ..., 

<math display="inline" id="Josephus_problem:84">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">⌊</mo>
     <mrow>
      <mi>n</mi>
      <mo>/</mo>
      <mi>k</mi>
     </mrow>
     <mo stretchy="false">⌋</mo>
    </mrow>
    <mi>k</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <floor></floor>
     <apply>
      <divide></divide>
      <ci>n</ci>
      <ci>k</ci>
     </apply>
    </apply>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\lfloor n/k\rfloor k)
  </annotation>
 </semantics>
</math>

-th people as one step, then changing the numbering.</p>
<h2 id="variants-and-generalizations">Variants and generalizations</h2>

<p>Josephus had an accomplice; the problem was then to find the places of the two last remaining survivors (whose conspiracy would ensure their survival). It is alleged that he placed himself and the other man in the 31st and 16th place respectively.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> A generalization of this process is as follows. We suppose that every 

<math display="inline" id="Josephus_problem:85">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

th person will be executed from a group of size 

<math display="inline" id="Josephus_problem:86">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

, in which the 

<math display="inline" id="Josephus_problem:87">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

th person is the survivor. If there is an addition of 

<math display="inline" id="Josephus_problem:88">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 people to the circle, then the survivor is in the 

<math display="inline" id="Josephus_problem:89">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mo>+</mo>
   <mrow>
    <mi>m</mi>
    <mi>x</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>p</ci>
    <apply>
     <times></times>
     <ci>m</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p+mx
  </annotation>
 </semantics>
</math>

th position if there is less than or equal to 

<math display="inline" id="Josephus_problem:90">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>+</mo>
   <mi>x</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>n</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n+x
  </annotation>
 </semantics>
</math>

. If 

<math display="inline" id="Josephus_problem:91">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 is the lowest value in which 

<math display="inline" id="Josephus_problem:92">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>p</mi>
     <mo>+</mo>
     <mrow>
      <mi>m</mi>
      <mi>x</mi>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>></mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>n</mi>
     <mo>+</mo>
     <mi>x</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <apply>
     <plus></plus>
     <ci>p</ci>
     <apply>
      <times></times>
      <ci>m</ci>
      <ci>x</ci>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <ci>n</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (p+mx)>(n+x)
  </annotation>
 </semantics>
</math>

, then the survivor is in position 

<math display="inline" id="Josephus_problem:93">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>p</mi>
     <mo>+</mo>
     <mrow>
      <mi>m</mi>
      <mi>x</mi>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>-</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>n</mi>
     <mo>+</mo>
     <mi>x</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <apply>
     <plus></plus>
     <ci>p</ci>
     <apply>
      <times></times>
      <ci>m</ci>
      <ci>x</ci>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <ci>n</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (p+mx)-(n+x)
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>
<h3 id="extended-josephus-problem">Extended Josephus problem</h3>

<p>Problem definition: There are <em>n</em> persons, numbered 1 to <em>n</em>, around a circle. We eliminate second of every two remaining persons until one person remains. Given the <em>n</em>, determine the number of <em>x</em>th person who is eliminated.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<ul>
<li></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.cut-the-knot.org/recurrence/flavius.shtml">Josephus Flavius game</a> (Java Applet) at <a class="uri" href="cut-the-knot" title="wikilink">cut-the-knot</a> allowing selection of every n<sup>th</sup> out of 50 (maximum).</li>
<li><a href="http://mathworld.wolfram.com/JosephusProblem.html">Josephus Problem at the MathWorld encyclopedia</a></li>
</ul>

<p>"</p>

<p><a class="uri" href="Category:Combinatorics" title="wikilink">Category:Combinatorics</a> <a class="uri" href="Category:Permutations" title="wikilink">Category:Permutations</a> <a href="Category:Mathematical_problems" title="wikilink">Category:Mathematical problems</a> <a href="Category:Computational_problems" title="wikilink">Category:Computational problems</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3">Armin Shams-Baragh <a href="http://www.cs.man.ac.uk/~shamsbaa/Josephus.pdf">Formulating The Extended Josephus Problem</a>.<a href="#fnref3">↩</a></li>
</ol>
</section>
</body>
</html>
