<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="455">Weak key</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Weak key</h1>
<hr/>

<p>In <a class="uri" href="cryptography" title="wikilink">cryptography</a>, a <strong>weak key</strong> is a <a href="key_(cryptography)" title="wikilink">key</a>, which, used with a specific <a class="uri" href="cipher" title="wikilink">cipher</a>, makes the cipher behave in some undesirable way. Weak keys usually represent a very small fraction of the overall keyspace, which usually means that, if one generates a random key to encrypt a message, weak keys are very unlikely to give rise to a security problem. Nevertheless, it is considered desirable for a cipher to have no weak keys. A cipher with no weak keys is said to have a <em>flat</em>, or <em>linear</em>, <a href="key_space_(cryptography)" title="wikilink">key space</a>.</p>
<h2 id="historical-origins">Historical origins</h2>

<p>Virtually all rotor based cipher machines (from 1925 onwards) have implementation flaws that lead to a substantial number of weak keys being created. Some machines have more problems with weak keys than others, as modern block and stream ciphers do.</p>

<p>The German Enigma machine is a family of about a dozen different cipher machine designs, each with its own problems. The military Enigma cipher machine, in its 3 and 4 rotor implementations had the equivalent of weak keys. Certain combinations of rotor order, stepping and initial key were fundamentally weaker than others. The Enigma's reflector (when used) guaranteed that no letter could be enciphered as itself, so an A could never turn back into an A. This helped Polish and, later, British efforts to break the cipher. (See <a href="Cryptanalysis_of_the_Enigma" title="wikilink">Cryptanalysis of the Enigma</a> and the <a href="Enigma_rotor_details" title="wikilink">Enigma rotor details</a>.)</p>

<p>The first stream cipher machines, that were also rotor machines had some of the same problems of weak keys as the more traditional rotor machines. The T52 was one such stream cipher machine that had weak key problems.</p>

<p>The British first detected T52 traffic in Summer and Autumn of 1942. One link was between <a class="uri" href="Sicily" title="wikilink">Sicily</a> and <a class="uri" href="Libya" title="wikilink">Libya</a>, codenamed "<a class="uri" href="Sturgeon" title="wikilink">Sturgeon</a>", and another from <a href="Aegean_Sea" title="wikilink">the Aegean</a> to <a class="uri" href="Sicily" title="wikilink">Sicily</a>, codenamed "<a class="uri" href="Mackerel" title="wikilink">Mackerel</a>". Operators of both links were in the habit of enciphering several messages with the same machine settings, producing large numbers of <a href="depth_(cryptanalysis)" title="wikilink">depths</a>.</p>

<p>There were several (mostly incompatible) versions of the T52: the T52a and T52b (which differed only in their electrical noise suppression), T52c, T52d and T52e. While the T52a/b and T52c were cryptologically weak, the last two were more advanced devices; the movement of the wheels was intermittent, the decision on whether or not to advance them being controlled by logic circuits which took as input data from the wheels themselves.</p>

<p>In addition, a number of conceptual flaws (including very subtle ones) had been eliminated. One such flaw was the ability to reset the <a class="uri" href="keystream" title="wikilink">keystream</a> to a fixed point, which led to key reuse by undisciplined machine operators.</p>
<h2 id="weak-keys-in-des">Weak keys in DES</h2>

<p>The <a href="block_cipher" title="wikilink">block cipher</a> <a href="Data_Encryption_Standard" title="wikilink">DES</a> has a few specific keys termed "weak keys" and "semi-weak keys". These are keys that cause the encryption mode of DES to act identically to the decryption mode of DES (albeit potentially that of a different key).</p>

<p>In operation, the secret 56-bit key is broken up into 16 subkeys according to the DES <a href="key_schedule" title="wikilink">key schedule</a>; one subkey is used in each of the sixteen DES rounds. DES <em>weak keys</em> produce sixteen identical subkeys. This occurs when the key (expressed in <a class="uri" href="hexadecimal" title="wikilink">hexadecimal</a>) is:<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>
<ul>
<li>Alternating ones + zeros (0x0101010101010101)</li>
<li>Alternating 'F' + 'E' (0xFEFEFEFEFEFEFEFE)</li>
<li>'0xE0E0E0E0F1F1F1F1'</li>
<li>'0x1F1F1F1F0E0E0E0E'</li>
</ul>

<p>If an implementation does not consider the parity bits, the corresponding keys with the inverted parity bits may also work as weak keys:</p>
<ul>
<li>all zeros (0x0000000000000000)</li>
<li>all ones (0xFFFFFFFFFFFFFFFF)</li>
<li>'0xE1E1E1E1F0F0F0F0'</li>
<li>'0x1E1E1E1E0F0F0F0F'</li>
</ul>

<p>Using weak keys, the outcome of the Permuted Choice 1 (PC1) in the DES <a href="key_schedule" title="wikilink">key schedule</a> leads to round keys being either all zeros, all ones or alternating zero-one patterns.</p>

<p>Since all the subkeys are identical, and DES is a <a href="Feistel_network" title="wikilink">Feistel network</a>, the encryption function is self-inverting; that is, despite encrypting once giving a secure-looking cipher text, encrypting twice produces the original plaintext.</p>

<p>DES also has <em>semi-weak keys</em>, which only produce two different subkeys, each used eight times in the algorithm: This means they come in pairs <em>K</em><sub>1</sub> and <em>K</em><sub>2</sub>, and they have the property that:</p>

<p>

<math display="block" id="Weak_key:0">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>E</mi>
     <msub>
      <mi>K</mi>
      <mn>1</mn>
     </msub>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>E</mi>
       <msub>
        <mi>K</mi>
        <mn>2</mn>
       </msub>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>M</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>M</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>E</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>K</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>E</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>K</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <ci>M</ci>
     </apply>
    </apply>
    <ci>M</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E_{K_{1}}(E_{K_{2}}(M))=M
  </annotation>
 </semantics>
</math>

</p>

<p>where E<sub><em>K</em></sub>(M) is the encryption algorithm encrypting <a href="plaintext" title="wikilink">message</a> ''M ''with key <em>K</em>. There are six semiweak key pairs:</p>
<ul>
<li>0x011F011F010E010E and 0x1F011F010E010E01</li>
<li>0x01E001E001F101F1 and 0xE001E001F101F101</li>
<li>0x01FE01FE01FE01FE and 0xFE01FE01FE01FE01</li>
<li>0x1FE01FE00EF10EF1 and 0xE01FE01FF10EF10E</li>
<li>0x1FFE1FFE0EFE0EFE and 0xFE1FFE1FFE0EFE0E</li>
<li>0xE0FEE0FEF1FEF1FE and 0xFEE0FEE0FEF1FEF1</li>
</ul>

<p>There are also 48 possibly weak keys that produce only four distinct subkeys (instead of 16). They can be found in <a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>

<p>These weak and semiweak keys are not considered "fatal flaws" of DES. There are 2<sup>56</sup> (7.21 × 10<sup>16</sup>, about 72 quadrillion) possible keys for DES, of which four are weak and twelve are semiweak. This is such a tiny fraction of the possible keyspace that users do not need to worry. If they so desire, they can check for weak or semiweak keys when the keys are generated. They are very few, and easy to recognize. Note, however, that currently DES is no longer recommended for general use since <em>all</em> keys can be brute-forced in about a day for a one-time hardware cost in the order of some new PC addon cards.</p>
<h2 id="list-of-algorithms-with-weak-keys">List of algorithms with weak keys</h2>
<ul>
<li><a class="uri" href="RC4" title="wikilink">RC4</a>. RC4's weak initialization vectors allow an attacker to mount a known-plaintext attack and have been widely used to compromise the security of <a href="Wired_Equivalent_Privacy" title="wikilink">WEP</a>.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></li>
<li><a href="IDEA_(cipher)" title="wikilink">IDEA</a>. IDEA's weak keys are identifiable in a chosen-plaintext attack. They make the relationship between the XOR sum of plaintext bits and ciphertext bits predictable. There is no list of these keys, but they can be identified by their "structure".</li>
<li><a href="Data_Encryption_Standard" title="wikilink">Data Encryption Standard</a></li>
<li><a href="Blowfish_(cipher)" title="wikilink">Blowfish</a>. Blowfish's weak keys produce <em>bad</em> <a href="S-box" title="wikilink">S-boxes</a>, since Blowfish's S-boxes are key-dependent. There is a chosen plaintext attack against a reduced-round variant of Blowfish that is made easier by the use of weak keys. This is not a concern for full 16-round Blowfish.</li>
</ul>
<h2 id="no-weak-keys-as-a-design-goal">No weak keys as a design goal</h2>

<p>The goal of having a 'flat' keyspace (i.e., all keys equally strong) is always a cipher design goal. As in the case of DES, sometimes a small number of weak keys is acceptable, provided that they are all identified or identifiable. An algorithm that has unknown weak keys does not inspire much trust .</p>

<p>The two main countermeasures against inadvertently using a weak key:</p>
<ul>
<li>Checking generated keys against a list of known weak keys, or building rejection of weak keys into the key scheduling.</li>
<li>When the number of weak keys is known to be very small (in comparison to the size of the keyspace), generating a key uniformly at random ensures that the probability of it being weak is a (known) very small number.</li>
</ul>

<p>A large number of weak keys is a serious flaw in any cipher design, since there will then be a (perhaps too) large chance that a randomly generated one will be a weak one, compromising the security of messages encrypted under it. It will also take longer to check randomly generated keys for weakness in such cases, which will tempt shortcuts in interest of 'efficiency'.</p>

<p>However, weak keys are much more often a problem where the adversary has some control over what keys are used, such as when a block cipher is used in a <a href="block_cipher_modes_of_operation" title="wikilink">mode of operation</a> intended to construct a secure <a href="cryptographic_hash_function" title="wikilink">cryptographic hash function</a> (e.g. <a class="uri" href="Davies-Meyer" title="wikilink">Davies-Meyer</a>).</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Authentication_factor" title="wikilink">Authentication factors</a></li>
<li><a href="Strong_authentication" title="wikilink">Strong authentication</a></li>
<li><a href="Authentication#Two-factor_authentication" title="wikilink">Multifactor authentication</a></li>
</ul>
<h2 id="references">References</h2>
<references>
</references>

<p>"</p>

<p><a href="Category:Cryptographic_attacks" title="wikilink">Category:Cryptographic attacks</a> <a href="Category:Key_management" title="wikilink">Category:Key management</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">FIPS, <em>GUIDELINES FOR IMPLEMENTING AND USING THE NBS DATA ENCRYPTION STANDARD</em>, FIPS-PUB 74, <a class="uri" href="http://www.itl.nist.gov/fipspubs/fip74.htm">http://www.itl.nist.gov/fipspubs/fip74.htm</a><a href="#fnref1">↩</a></li>
<li id="fn2">NIST, <em>Recommendation for the Triple Data Encryption Algorithm (TDEA) Block Cipher,</em> <a href="http://csrc.nist.gov/publications/nistpubs/800-67/SP800-67.pdf">Special Publication 800-67</a>, page 14<a href="#fnref2">↩</a></li>
<li id="fn3">FLUHRER, S., MANTIN, I., AND SHAMIR, A. Weaknesses in the key scheduling algorithm of RC4. Eighth Annual Workshop on Selected Areas in Cryptography (August 2001), <a class="uri" href="http://citeseer.ist.psu.edu/fluhrer01weaknesses.html">http://citeseer.ist.psu.edu/fluhrer01weaknesses.html</a><a href="#fnref3">↩</a></li>
</ol>
</section>
</body>
</html>
