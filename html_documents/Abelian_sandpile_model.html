<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1993">Abelian sandpile model</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Abelian sandpile model</h1>
<hr/>

<p>The <strong>Abelian sandpile model</strong>, also known as the <strong>Bakâ€“Tangâ€“Wiesenfeld model</strong>, was the first discovered example of a <a href="dynamical_system" title="wikilink">dynamical system</a> displaying <a href="self-organized_criticality" title="wikilink">self-organized criticality</a>. It was introduced by <a href="Per_Bak" title="wikilink">Per Bak</a>, <a href="Chao_Tang" title="wikilink">Chao Tang</a> and <a href="Kurt_Wiesenfeld" title="wikilink">Kurt Wiesenfeld</a> in a 1987 paper.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>
<figure><b>(Figure)</b>
<figcaption> 28 million grains dropped.</figcaption>
</figure>

<p>The model is a <a href="cellular_automaton" title="wikilink">cellular automaton</a>. In its original formulation, each site on a finite grid has an associated value that corresponds to the slope of the pile. This slope builds up as grains of sand are randomly placed onto the pile, until the slope exceeds a specific threshold value at which time that site collapses transferring sand into the adjacent sites, increasing their slope. Bak, Tang, and Wiesenfeld considered process of successive random placement of sand grains on the grid; each such placement of sand at a particular site may have no effect, or it may cause a cascading reaction that will affect many sites. These "avalanches" are an example of the <a href="Eden_growth_model" title="wikilink">Eden growth model</a>. The grains of sand are often more conveniently referred to as "chips".</p>

<p>The model has since been studied on the infinite lattice, on other (non-square) lattices, and on arbitrary graphs (including directed multigraphs).<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>
<h2 id="definition">Definition</h2>

<p>The iteration rules for the model on the square lattice can be defined as follows:</p>

<p>Begin with some nonnegative configuration 

<math display="inline" id="Abelian_sandpile_model:0">
 <semantics>
  <mrow>
   <mrow>
    <mi>z</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>âˆˆ</mo>
   <mi>ğ™</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <times></times>
     <ci>z</ci>
     <interval closure="open">
      <ci>x</ci>
      <ci>y</ci>
     </interval>
    </apply>
    <ci>ğ™</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z(x,y)\in\mathbf{Z}
  </annotation>
 </semantics>
</math>

 which is finite, in the sense that</p>

<p>

<math display="block" id="Abelian_sandpile_model:1">
 <semantics>
  <mrow>
   <mrow>
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">âˆ‘</mo>
     <mrow>
      <mi>x</mi>
      <mo>,</mo>
      <mi>y</mi>
     </mrow>
    </munder>
    <mrow>
     <mi>z</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mi>y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo><</mo>
   <mi mathvariant="normal">âˆ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <list>
       <ci>x</ci>
       <ci>y</ci>
      </list>
     </apply>
     <apply>
      <times></times>
      <ci>z</ci>
      <interval closure="open">
       <ci>x</ci>
       <ci>y</ci>
      </interval>
     </apply>
    </apply>
    <infinity></infinity>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{x,y}z(x,y)<\infty
  </annotation>
 </semantics>
</math>

.</p>

<p>Any site 

<math display="inline" id="Abelian_sandpile_model:2">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>x</mi>
   <mo>,</mo>
   <mi>y</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>x</ci>
    <ci>y</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x,y)
  </annotation>
 </semantics>
</math>

 with</p>

<p>

<math display="block" id="Abelian_sandpile_model:3">
 <semantics>
  <mrow>
   <mrow>
    <mi>z</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>â‰¥</mo>
   <mn>4</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <times></times>
     <ci>z</ci>
     <interval closure="open">
      <ci>x</ci>
      <ci>y</ci>
     </interval>
    </apply>
    <cn type="integer">4</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z(x,y)\geq 4
  </annotation>
 </semantics>
</math>

 is <em>unstable</em> and can <em>topple</em>, sending one of its chips to each of its 4 neighbors:</p>

<p>

<math display="block" id="Abelian_sandpile_model:4">
 <semantics>
  <mrow>
   <mrow>
    <mi>z</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>â†’</mo>
   <mrow>
    <mrow>
     <mi>z</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mi>y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mn>4</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-â†’</ci>
    <apply>
     <times></times>
     <ci>z</ci>
     <interval closure="open">
      <ci>x</ci>
      <ci>y</ci>
     </interval>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>z</ci>
      <interval closure="open">
       <ci>x</ci>
       <ci>y</ci>
      </interval>
     </apply>
     <cn type="integer">4</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z(x,y)\rightarrow z(x,y)-4
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Abelian_sandpile_model:5">
 <semantics>
  <mrow>
   <mrow>
    <mi>z</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>x</mi>
      <mo>Â±</mo>
      <mn>1</mn>
     </mrow>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>â†’</mo>
   <mrow>
    <mrow>
     <mi>z</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>x</mi>
       <mo>Â±</mo>
       <mn>1</mn>
      </mrow>
      <mo>,</mo>
      <mi>y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-â†’</ci>
    <apply>
     <times></times>
     <ci>z</ci>
     <interval closure="open">
      <apply>
       <csymbol cd="latexml">plus-or-minus</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>y</ci>
     </interval>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>z</ci>
      <interval closure="open">
       <apply>
        <csymbol cd="latexml">plus-or-minus</csymbol>
        <ci>x</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>y</ci>
      </interval>
     </apply>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z(x\pm 1,y)\rightarrow z(x\pm 1,y)+1
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Abelian_sandpile_model:6">
 <semantics>
  <mrow>
   <mrow>
    <mi>z</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mrow>
      <mi>y</mi>
      <mo>Â±</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>â†’</mo>
   <mrow>
    <mrow>
     <mi>z</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mrow>
       <mi>y</mi>
       <mo>Â±</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mn>1.</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-â†’</ci>
    <apply>
     <times></times>
     <ci>z</ci>
     <interval closure="open">
      <ci>x</ci>
      <apply>
       <csymbol cd="latexml">plus-or-minus</csymbol>
       <ci>y</ci>
       <cn type="integer">1</cn>
      </apply>
     </interval>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>z</ci>
      <interval closure="open">
       <ci>x</ci>
       <apply>
        <csymbol cd="latexml">plus-or-minus</csymbol>
        <ci>y</ci>
        <cn type="integer">1</cn>
       </apply>
      </interval>
     </apply>
     <cn type="float">1.</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z(x,y\pm 1)\rightarrow z(x,y\pm 1)+1.
  </annotation>
 </semantics>
</math>

</p>

<p>The process is guaranteed to terminate given that the initial configuration was finite. Moreover, although there will often be many possible choices for the order in which to topple vertices, the final configuration does not depend on the chosen order; this is one sense in which the sandpile is <a href="Abelian_group" title="wikilink"><em>Abelian</em></a>. The number of times each vertex topples in this process is also independent of the choice of toppling order.</p>

<p>On an arbitrary undirected graph, a special vertex called a <em>sink</em> is specified that is not allowed to topple. In the presence of a sink, the term <em>chip configuration</em> refers to a chip-counting vector (nonnegative and integral) indexed by the non-sink vertices. The rules are that any non-sink vertex 

<math display="inline" id="Abelian_sandpile_model:7">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>

 with</p>

<p>

<math display="block" id="Abelian_sandpile_model:8">
 <semantics>
  <mrow>
   <mrow>
    <mi>z</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>v</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>â‰¥</mo>
   <mrow>
    <mi>deg</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>v</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <times></times>
     <ci>z</ci>
     <ci>v</ci>
    </apply>
    <apply>
     <times></times>
     <ci>deg</ci>
     <ci>v</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z(v)\geq\mathrm{deg}(v)
  </annotation>
 </semantics>
</math>

 is unstable; toppling again sends one of its chips to each of its neighbors:</p>

<p>

<math display="block" id="Abelian_sandpile_model:9">
 <semantics>
  <mrow>
   <mrow>
    <mi>z</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>v</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>â†’</mo>
   <mrow>
    <mrow>
     <mi>z</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>v</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mi>deg</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>v</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-â†’</ci>
    <apply>
     <times></times>
     <ci>z</ci>
     <ci>v</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>z</ci>
      <ci>v</ci>
     </apply>
     <apply>
      <times></times>
      <ci>deg</ci>
      <ci>v</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z(v)\rightarrow z(v)-\mathrm{deg}(v)
  </annotation>
 </semantics>
</math>

 and, for each 

<math display="inline" id="Abelian_sandpile_model:10">
 <semantics>
  <mrow>
   <mi>u</mi>
   <mo>âˆ¼</mo>
   <mi>v</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">similar-to</csymbol>
    <ci>u</ci>
    <ci>v</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u\sim v
  </annotation>
 </semantics>
</math>

:</p>

<p>

<math display="block" id="Abelian_sandpile_model:11">
 <semantics>
  <mrow>
   <mrow>
    <mi>z</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>u</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>â†’</mo>
   <mrow>
    <mrow>
     <mi>z</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>u</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mn>1.</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-â†’</ci>
    <apply>
     <times></times>
     <ci>z</ci>
     <ci>u</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>z</ci>
      <ci>u</ci>
     </apply>
     <cn type="float">1.</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z(u)\rightarrow z(u)+1.
  </annotation>
 </semantics>
</math>

</p>

<p>Multiple toppling operations can be efficiently encoded by using the <a href="Laplacian_matrix" title="wikilink">Laplacian matrix</a> 

<math display="inline" id="Abelian_sandpile_model:12">
 <semantics>
  <mi mathvariant="normal">Î”</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Î”</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta
  </annotation>
 </semantics>
</math>

. Deleting the row and column of 

<math display="inline" id="Abelian_sandpile_model:13">
 <semantics>
  <mi mathvariant="normal">Î”</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Î”</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta
  </annotation>
 </semantics>
</math>

 corresponding with the sink yields the <em>reduced Laplacian</em> 

<math display="inline" id="Abelian_sandpile_model:14">
 <semantics>
  <msup>
   <mi mathvariant="normal">Î”</mi>
   <mo>â€²</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>normal-Î”</ci>
    <ci>normal-â€²</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta^{\prime}
  </annotation>
 </semantics>
</math>

. If 

<math display="inline" id="Abelian_sandpile_model:15">
 <semantics>
  <mi>ğ±</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ğ±</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{x}
  </annotation>
 </semantics>
</math>

 is a nonnegative integral vector indexed by the non-sink vertices, then starting with a configuration 

<math display="inline" id="Abelian_sandpile_model:16">
 <semantics>
  <mi>z</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>z</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z
  </annotation>
 </semantics>
</math>

 and toppling each vertex 

<math display="inline" id="Abelian_sandpile_model:17">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>

 a total of 

<math display="inline" id="Abelian_sandpile_model:18">
 <semantics>
  <mrow>
   <mi>ğ±</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>v</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>ğ±</ci>
    <ci>v</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{x}(v)
  </annotation>
 </semantics>
</math>

 times yields the configuration 

<math display="inline" id="Abelian_sandpile_model:19">
 <semantics>
  <mrow>
   <mi>z</mi>
   <mo>-</mo>
   <mrow>
    <mi>ğ±</mi>
    <msup>
     <mi mathvariant="normal">Î”</mi>
     <mo>â€²</mo>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>z</ci>
    <apply>
     <times></times>
     <ci>ğ±</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>normal-Î”</ci>
      <ci>normal-â€²</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z-\mathbf{x}\Delta^{\prime}
  </annotation>
 </semantics>
</math>

.</p>

<p>This and other models that involve a toppling operation are sometimes referred to as <em>chip-firing models</em> or <em>chip-firing games</em>.</p>
<h2 id="sandpile-group">Sandpile group</h2>

<p>Given a configuration 

<math display="inline" id="Abelian_sandpile_model:20">
 <semantics>
  <mi>z</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>z</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z
  </annotation>
 </semantics>
</math>

, toppling unstable non-sink vertices on a finite connected graph until no unstable non-sink vertex remains leads to a unique <em>stable</em> configuration 

<math display="inline" id="Abelian_sandpile_model:21">
 <semantics>
  <msup>
   <mi>z</mi>
   <mo>âˆ˜</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>z</ci>
    <compose></compose>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z^{\circ}
  </annotation>
 </semantics>
</math>

, which is called the <em>stabilization</em> of 

<math display="inline" id="Abelian_sandpile_model:22">
 <semantics>
  <mi>z</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>z</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z
  </annotation>
 </semantics>
</math>

.</p>

<p>The set of stable configurations forms a <a href="commutative_monoid" title="wikilink">commutative monoid</a> under the operation 

<math display="inline" id="Abelian_sandpile_model:23">
 <semantics>
  <mrow>
   <mrow>
    <mi>z</mi>
    <mo>*</mo>
    <mi>w</mi>
   </mrow>
   <mo>â†’</mo>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>z</mi>
      <mo>+</mo>
      <mi>w</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>âˆ˜</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-â†’</ci>
    <apply>
     <times></times>
     <ci>z</ci>
     <ci>w</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <plus></plus>
      <ci>z</ci>
      <ci>w</ci>
     </apply>
     <compose></compose>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z*w\to(z+w)^{\circ}
  </annotation>
 </semantics>
</math>

. The minimal <a class="uri" href="ideal" title="wikilink">ideal</a> of this monoid is a group of <em>recurrent</em> configurations called the <em>sandpile group</em>. A stable configuration is recurrent if it can be gotten from any other configuration by adding chips and stabilizing.</p>

<p>The sandpile group is isomorphic to the group of equivalence classes of configurations gotten by reducing modulo the toppling operation, which can be written</p>

<p>

<math display="block" id="Abelian_sandpile_model:24">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>ğ™</mi>
     <mrow>
      <mi>n</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <mo>/</mo>
    <msup>
     <mi>ğ™</mi>
     <mrow>
      <mi>n</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
   </mrow>
   <msup>
    <mi mathvariant="normal">Î”</mi>
    <mo>â€²</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ğ™</ci>
      <apply>
       <minus></minus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ğ™</ci>
      <apply>
       <minus></minus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-Î”</ci>
     <ci>normal-â€²</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{Z}^{n-1}/\mathbf{Z}^{n-1}\Delta^{\prime}
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Abelian_sandpile_model:25">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 is the number of vertices and 

<math display="inline" id="Abelian_sandpile_model:26">
 <semantics>
  <mrow>
   <msup>
    <mi>ğ™</mi>
    <mrow>
     <mi>n</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msup>
   <msup>
    <mi mathvariant="normal">Î”</mi>
    <mo>â€²</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ğ™</ci>
     <apply>
      <minus></minus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-Î”</ci>
     <ci>normal-â€²</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{Z}^{n-1}\Delta^{\prime}
  </annotation>
 </semantics>
</math>

 is the integer row-span of 

<math display="inline" id="Abelian_sandpile_model:27">
 <semantics>
  <msup>
   <mi mathvariant="normal">Î”</mi>
   <mo>â€²</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>normal-Î”</ci>
    <ci>normal-â€²</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta^{\prime}
  </annotation>
 </semantics>
</math>

.</p>

<p>The order of the sandpile group is the determinant of 

<math display="inline" id="Abelian_sandpile_model:28">
 <semantics>
  <msup>
   <mi mathvariant="normal">Î”</mi>
   <mo>â€²</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>normal-Î”</ci>
    <ci>normal-â€²</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta^{\prime}
  </annotation>
 </semantics>
</math>

, which by the <a href="Kirchhoff's_theorem" title="wikilink">matrix tree theorem</a> is the number of spanning trees of the graph.</p>
<h2 id="self-organized-criticality">Self-organized criticality</h2>

<p>The original interest behind the model stemmed from the fact that it is attracted to its <a href="critical_state" title="wikilink">critical state</a>, at which point the correlation length of the system and the correlation time of the system go to infinity, without any fine tuning of a system parameter. This contrasts with earlier examples of critical phenomena, such as the <a href="phase_transition" title="wikilink">phase transitions</a> between solid and liquid, or liquid and gas, where the critical point can only be reached by precise tuning (e.g., of temperature). Hence, in the sandpile model we can say that the criticality is <a href="self-organization" title="wikilink">self-organized</a>.</p>

<p>Once the sandpile model reaches its critical state there is no correlation between the system's response to a <a href="wiktionary:perturbation" title="wikilink">perturbation</a> and the details of a perturbation. Generally this means that dropping another grain of sand onto the pile may cause nothing to happen, or it may cause the entire pile to collapse in a massive slide. The model also displays <a href="1/f_noise" title="wikilink">1/<em>Æ’</em> noise</a>, a feature common to many complex systems in nature.</p>

<p>This model only displays critical behaviour in two or more dimensions. The sandpile model can be expressed in 1D; however, instead of evolving to its critical state, the 1D sandpile model instead reaches a minimally stable state where every lattice site goes toward the critical slope.</p>

<p>For 2 dimensions, the associated conformal field theory is suggested to be symplectic fermions with central charge c=-2.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>
<h2 id="generalization-to-directed-graphs">Generalization to directed graphs</h2>

<p>The sandpile model can be generalized to arbitrary directed multigraphs. The rules are that any vertex 

<math display="inline" id="Abelian_sandpile_model:29">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>

 with</p>

<p>

<math display="block" id="Abelian_sandpile_model:30">
 <semantics>
  <mrow>
   <mrow>
    <mi>z</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>v</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>â‰¥</mo>
   <mrow>
    <msup>
     <mi>deg</mi>
     <mo>+</mo>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>v</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <times></times>
     <ci>z</ci>
     <ci>v</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>deg</ci>
      <plus></plus>
     </apply>
     <ci>v</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z(v)\geq\mathrm{deg}^{+}(v)
  </annotation>
 </semantics>
</math>

 is unstable; toppling again sends chips to each of its neighbors, one along each outgoing edge:</p>

<p>

<math display="block" id="Abelian_sandpile_model:31">
 <semantics>
  <mrow>
   <mrow>
    <mi>z</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>v</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>â†’</mo>
   <mrow>
    <mrow>
     <mrow>
      <mi>z</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>v</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>-</mo>
     <mrow>
      <msup>
       <mi>deg</mi>
       <mo>+</mo>
      </msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>v</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>deg</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>v</mi>
      <mo>,</mo>
      <mi>v</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-â†’</ci>
    <apply>
     <times></times>
     <ci>z</ci>
     <ci>v</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>z</ci>
       <ci>v</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>deg</ci>
        <plus></plus>
       </apply>
       <ci>v</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>deg</ci>
      <interval closure="open">
       <ci>v</ci>
       <ci>v</ci>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z(v)\rightarrow z(v)-\mathrm{deg}^{+}(v)+\mathrm{deg}(v,v)
  </annotation>
 </semantics>
</math>

 and, for each 

<math display="inline" id="Abelian_sandpile_model:32">
 <semantics>
  <mrow>
   <mi>u</mi>
   <mo>â‰ </mo>
   <mi>v</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <neq></neq>
    <ci>u</ci>
    <ci>v</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u\neq v
  </annotation>
 </semantics>
</math>

:</p>

<p>

<math display="block" id="Abelian_sandpile_model:33">
 <semantics>
  <mrow>
   <mrow>
    <mi>z</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>u</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>â†’</mo>
   <mrow>
    <mrow>
     <mi>z</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>u</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>deg</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>v</mi>
      <mo>,</mo>
      <mi>u</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-â†’</ci>
    <apply>
     <times></times>
     <ci>z</ci>
     <ci>u</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>z</ci>
      <ci>u</ci>
     </apply>
     <apply>
      <times></times>
      <ci>deg</ci>
      <interval closure="open">
       <ci>v</ci>
       <ci>u</ci>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z(u)\rightarrow z(u)+\mathrm{deg}(v,u)
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Abelian_sandpile_model:34">
 <semantics>
  <mrow>
   <mi>deg</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>v</mi>
    <mo>,</mo>
    <mi>u</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>deg</ci>
    <interval closure="open">
     <ci>v</ci>
     <ci>u</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{deg}(v,u)
  </annotation>
 </semantics>
</math>

 is the number of edges from 

<math display="inline" id="Abelian_sandpile_model:35">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Abelian_sandpile_model:36">
 <semantics>
  <mi>u</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>u</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u
  </annotation>
 </semantics>
</math>

.</p>

<p>In this case the Laplacian matrix is not symmetric. If we specify a sink 

<math display="inline" id="Abelian_sandpile_model:37">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

 such that there is a path from every other vertex to 

<math display="inline" id="Abelian_sandpile_model:38">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

, then the stabilization operation on finite graphs is well-defined and the sandpile group can be written</p>

<p>

<math display="block" id="Abelian_sandpile_model:39">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>ğ™</mi>
     <mrow>
      <mi>n</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <mo>/</mo>
    <msup>
     <mi>ğ™</mi>
     <mrow>
      <mi>n</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
   </mrow>
   <msup>
    <mi mathvariant="normal">Î”</mi>
    <mo>â€²</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ğ™</ci>
      <apply>
       <minus></minus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ğ™</ci>
      <apply>
       <minus></minus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-Î”</ci>
     <ci>normal-â€²</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{Z}^{n-1}/\mathbf{Z}^{n-1}\Delta^{\prime}
  </annotation>
 </semantics>
</math>

 as before.</p>

<p>The order of the sandpile group is again the determinant of 

<math display="inline" id="Abelian_sandpile_model:40">
 <semantics>
  <msup>
   <mi mathvariant="normal">Î”</mi>
   <mo>â€²</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>normal-Î”</ci>
    <ci>normal-â€²</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta^{\prime}
  </annotation>
 </semantics>
</math>

, which by the general version of the <a href="Kirchhoff's_theorem" title="wikilink">matrix tree theorem</a> is the number of oriented <a href="spanning_tree" title="wikilink">spanning trees</a> rooted at the sink.</p>
<h2 id="least-action-principle">Least action principle</h2>

<p>The stabilization of chip configurations obeys a form of <em><a href="principle_of_least_action" title="wikilink">least action principle</a></em>: each vertex topples no more than necessary in the course of the stabilization.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> Even if toppling stable vertices is allowed, stabilization via the toppling of exclusively unstable vertices is always at least as efficient. More precisely, if 

<math display="inline" id="Abelian_sandpile_model:41">
 <semantics>
  <mi>ğ®</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ğ®</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{u}
  </annotation>
 </semantics>
</math>

 is a vector such that 

<math display="inline" id="Abelian_sandpile_model:42">
 <semantics>
  <mrow>
   <mi>ğ®</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>v</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>ğ®</ci>
    <ci>v</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{u}(v)
  </annotation>
 </semantics>
</math>

 is the number of times the vertex 

<math display="inline" id="Abelian_sandpile_model:43">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>

 topples during the stabilization (via the toppling of unstable vertices) of a chip configuration 

<math display="inline" id="Abelian_sandpile_model:44">
 <semantics>
  <mi>z</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>z</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="Abelian_sandpile_model:45">
 <semantics>
  <mi>ğ§</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ğ§</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{n}
  </annotation>
 </semantics>
</math>

 is an integral vector (not necessarily non-negative) such that 

<math display="inline" id="Abelian_sandpile_model:46">
 <semantics>
  <mrow>
   <mi>z</mi>
   <mo>-</mo>
   <mrow>
    <mi>ğ§</mi>
    <msup>
     <mi mathvariant="normal">Î”</mi>
     <mo>â€²</mo>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>z</ci>
    <apply>
     <times></times>
     <ci>ğ§</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>normal-Î”</ci>
      <ci>normal-â€²</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z-\mathbf{n}\Delta^{\prime}
  </annotation>
 </semantics>
</math>

 is stable, then 

<math display="inline" id="Abelian_sandpile_model:47">
 <semantics>
  <mrow>
   <mrow>
    <mi>ğ®</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>v</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>â‰¤</mo>
   <mrow>
    <mi>ğ§</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>v</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <times></times>
     <ci>ğ®</ci>
     <ci>v</ci>
    </apply>
    <apply>
     <times></times>
     <ci>ğ§</ci>
     <ci>v</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{u}(v)\leq\mathbf{n}(v)
  </annotation>
 </semantics>
</math>

 for all vertices 

<math display="inline" id="Abelian_sandpile_model:48">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="cultural-references">Cultural references</h2>

<p>The Bakâ€“Tangâ€“Wiesenfeld sandpile was mentioned on the <a class="uri" href="Numb3rs" title="wikilink">Numb3rs</a> episode "Rampage," as mathematician Charlie Eppes explains to his colleagues a solution to a criminal investigation.</p>

<p>The <a href="computer_game" title="wikilink">computer game</a> <a class="uri" href="Hexplode" title="wikilink">Hexplode</a> is based around the Abelian sandpile model on a finite hexagonal grid where instead of random grain placement, grains are placed by players.</p>
<h2 id="references">References</h2>
<ul>
<li>[<a class="uri" href="http://xstructure.inr.ac.ru/x-bin/theme3.py?level=1&amp;index1">http://xstructure.inr.ac.ru/x-bin/theme3.py?level=1&amp;index1;</a>;=-15547 Sandpile model on arxiv.org]</li>
</ul>
<h2 id="further-reading">Further reading</h2>
<ul>
<li></li>
</ul>
<ul>
<li></li>
</ul>
<ul>
<li></li>
</ul>
<ul>
<li></li>
</ul>
<ul>
<li></li>
</ul>

<p>"</p>

<p><a class="uri" href="Category:Self-organization" title="wikilink">Category:Self-organization</a> <a href="Category:Phase_transitions" title="wikilink">Category:Phase transitions</a> <a href="Category:Dynamical_systems" title="wikilink">Category:Dynamical systems</a> <a href="Category:Critical_phenomena" title="wikilink">Category:Critical phenomena</a> <a href="Category:Nonlinear_systems" title="wikilink">Category:Nonlinear systems</a> <a href="Category:Cellular_automaton_rules" title="wikilink">Category:Cellular automaton rules</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">â†©</a></li>
<li id="fn2"><a href="#fnref2">â†©</a></li>
<li id="fn3"><a href="#fnref3">â†©</a></li>
<li id="fn4"><a href="#fnref4">â†©</a></li>
</ol>
</section>
</body>
</html>
