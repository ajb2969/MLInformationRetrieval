<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="429">Cone (formal languages)</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Cone (formal languages)</h1>
<hr/>

<p>In <a href="formal_language_theory" title="wikilink">formal language theory</a>, a <strong>cone</strong> is a set of <a href="formal_language" title="wikilink">formal languages</a> that has some desirable <a href="closure_(mathematics)" title="wikilink">closure</a> properties enjoyed by some well-known sets of languages, in particular by the families of <a href="regular_language" title="wikilink">regular languages</a>, <a href="context-free_language" title="wikilink">context-free languages</a> and the <a href="recursively_enumerable_language" title="wikilink">recursively enumerable languages</a>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> The concept of a cone is a more abstract notion that subsumes all of these families. A similar notion is the <strong>faithful cone</strong>, having somewhat relaxed conditions. For example, the <a href="context-sensitive_language" title="wikilink">context-sensitive languages</a> do not form a cone, but still have the required properties to form a faithful cone.</p>

<p>The terminology <em>cone</em> has a French origin. In the American oriented literature one usually speaks of a <em>full trio</em>. The <em>trio</em> corresponds to the faithful cone.</p>
<h2 id="definition">Definition</h2>

<p>A cone is a non-empty family 

<math display="inline" id="Cone_(formal_languages):0">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒮</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒮</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{S}
  </annotation>
 </semantics>
</math>

 of languages such that, for any 

<math display="inline" id="Cone_(formal_languages):1">
 <semantics>
  <mrow>
   <mi>L</mi>
   <mo>∈</mo>
   <mi class="ltx_font_mathcaligraphic">𝒮</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>L</ci>
    <ci>𝒮</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L\in\mathcal{S}
  </annotation>
 </semantics>
</math>

 over some alphabet 

<math display="inline" id="Cone_(formal_languages):2">
 <semantics>
  <mi mathvariant="normal">Σ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma
  </annotation>
 </semantics>
</math>

,</p>
<ul>
<li>if 

<math display="inline" id="Cone_(formal_languages):3">
 <semantics>
  <mi>h</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>h</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h
  </annotation>
 </semantics>
</math>

 is a <a class="uri" href="homomorphism" title="wikilink">homomorphism</a> from 

<math display="inline" id="Cone_(formal_languages):4">
 <semantics>
  <msup>
   <mi mathvariant="normal">Σ</mi>
   <mo>∗</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>normal-Σ</ci>
    <ci>normal-∗</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma^{\ast}
  </annotation>
 </semantics>
</math>

 to some 

<math display="inline" id="Cone_(formal_languages):5">
 <semantics>
  <msup>
   <mi mathvariant="normal">Δ</mi>
   <mo>∗</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>normal-Δ</ci>
    <ci>normal-∗</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta^{\ast}
  </annotation>
 </semantics>
</math>

, the language 

<math display="inline" id="Cone_(formal_languages):6">
 <semantics>
  <mrow>
   <mi>h</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>L</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>h</ci>
    <ci>L</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h(L)
  </annotation>
 </semantics>
</math>

 is in 

<math display="inline" id="Cone_(formal_languages):7">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒮</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒮</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{S}
  </annotation>
 </semantics>
</math>

;</li>
<li>if 

<math display="inline" id="Cone_(formal_languages):8">
 <semantics>
  <mi>h</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>h</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h
  </annotation>
 </semantics>
</math>

 is a homomorphism from some 

<math display="inline" id="Cone_(formal_languages):9">
 <semantics>
  <msup>
   <mi mathvariant="normal">Δ</mi>
   <mo>∗</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>normal-Δ</ci>
    <ci>normal-∗</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta^{\ast}
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Cone_(formal_languages):10">
 <semantics>
  <msup>
   <mi mathvariant="normal">Σ</mi>
   <mo>∗</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>normal-Σ</ci>
    <ci>normal-∗</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma^{\ast}
  </annotation>
 </semantics>
</math>

, the language 

<math display="inline" id="Cone_(formal_languages):11">
 <semantics>
  <mrow>
   <msup>
    <mi>h</mi>
    <mrow>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>L</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>h</ci>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <ci>L</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h^{-1}(L)
  </annotation>
 </semantics>
</math>

 is in 

<math display="inline" id="Cone_(formal_languages):12">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒮</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒮</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{S}
  </annotation>
 </semantics>
</math>

;</li>
<li>if 

<math display="inline" id="Cone_(formal_languages):13">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

 is any regular language over 

<math display="inline" id="Cone_(formal_languages):14">
 <semantics>
  <mi mathvariant="normal">Σ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma
  </annotation>
 </semantics>
</math>

, then 

<math display="inline" id="Cone_(formal_languages):15">
 <semantics>
  <mrow>
   <mi>L</mi>
   <mo>∩</mo>
   <mi>R</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <intersect></intersect>
    <ci>L</ci>
    <ci>R</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L\cap R
  </annotation>
 </semantics>
</math>

 is in 

<math display="inline" id="Cone_(formal_languages):16">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒮</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒮</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{S}
  </annotation>
 </semantics>
</math>

.</li>
</ul>

<p>The family of all regular languages is contained in any cone.</p>

<p>If one restricts the definition to homomorphisms that do not introduce the empty word 

<math display="inline" id="Cone_(formal_languages):17">
 <semantics>
  <mi>λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda
  </annotation>
 </semantics>
</math>

 then one speaks of a <em>faithful cone</em>; the inverse homomorphisms are not restricted. Within the <a href="Chomsky_hierarchy" title="wikilink">Chomsky hierarchy</a>, the regular languages, the context-free languages, and the <a href="recursively_enumerable_language" title="wikilink">recursively enumerable languages</a> are all cones, whereas the context-sensitive languages and the recursive languages are only faithful cones.</p>
<h2 id="relation-to-transducers">Relation to Transducers</h2>

<p>A <a href="finite_state_transducer" title="wikilink">finite state transducer</a> is a finite state automaton that has both input and output. It defines a transduction 

<math display="inline" id="Cone_(formal_languages):18">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

, mapping a language 

<math display="inline" id="Cone_(formal_languages):19">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

 over the input alphabet into another language 

<math display="inline" id="Cone_(formal_languages):20">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>L</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>T</ci>
    <ci>L</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T(L)
  </annotation>
 </semantics>
</math>

 over the output alphabet. Each of the cone operations (homomorphism, inverse homomorphism, intersection with a regular language) can be implemented using a finite state transducer. And, since finite state transducers are closed under composition, every sequence of cone operations can be performed by a finite state transducer.</p>

<p>Conversely, every finite state transduction 

<math display="inline" id="Cone_(formal_languages):21">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

 can be decomposed into cone operations. In fact, there exists a normal form for this decomposition,<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> which is commonly known as <em>Nivat's Theorem</em>:<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> Namely, each such 

<math display="inline" id="Cone_(formal_languages):22">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

 can be effectively decomposed as 

<math display="inline" id="Cone_(formal_languages):23">
 <semantics>
  <mrow>
   <mrow>
    <mi>T</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>L</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>g</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <msup>
        <mi>h</mi>
        <mrow>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
       </msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>L</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>∩</mo>
      <mi>R</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>T</ci>
     <ci>L</ci>
    </apply>
    <apply>
     <times></times>
     <ci>g</ci>
     <apply>
      <intersect></intersect>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>h</ci>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>L</ci>
      </apply>
      <ci>R</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T(L)=g(h^{-1}(L)\cap R)
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Cone_(formal_languages):24">
 <semantics>
  <mrow>
   <mi>g</mi>
   <mo>,</mo>
   <mi>h</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>g</ci>
    <ci>h</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g,h
  </annotation>
 </semantics>
</math>

 are homomorphisms, and 

<math display="inline" id="Cone_(formal_languages):25">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

 is a regular language depending only on 

<math display="inline" id="Cone_(formal_languages):26">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

.</p>

<p>Altogether, this means that a family of languages is a cone if it is closed under finite state transductions. This is a very powerful set of operations. For instance one easily writes a (nondeterministic) finite state transducer with alphabet 

<math display="inline" id="Cone_(formal_languages):27">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mi>a</mi>
   <mo>,</mo>
   <mi>b</mi>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <ci>a</ci>
    <ci>b</ci>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{a,b\}
  </annotation>
 </semantics>
</math>

 that removes every second 

<math display="inline" id="Cone_(formal_languages):28">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>

 in words of even length (and does not change words otherwise). Since the context-free languages form a cone, they are closed under this exotic operation.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Abstract_family_of_languages" title="wikilink">Abstract family of languages</a></li>
</ul>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<ul>
<li></li>
</ul>
<ul>
<li></li>
</ul>
<ul>
<li><a href="Seymour_Ginsburg" title="wikilink">Seymour Ginsburg</a>, <em>Algebraic and automata theoretic properties of formal languages</em>, North-Holland, 1975, ISBN 0-7204-2506-9.</li>
</ul>
<ul>
<li>John E. Hopcroft and Jeffrey D. Ullman, <em><a href="Introduction_to_Automata_Theory,_Languages,_and_Computation" title="wikilink">Introduction to Automata Theory, Languages, and Computation</a></em>, Addison-Wesley Publishing, Reading Massachusetts, 1979. ISBN 0-201-02988-X. Chapter 11: Closure properties of families of languages.</li>
</ul>
<ul>
<li></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://eom.springer.de/T/t110060.htm">Encyclopedia of mathematics: Trio</a>, Springer.</li>
</ul>

<p>"</p>

<p><a href="Category:Formal_languages" title="wikilink">Category:Formal languages</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3">cf. <a href="#fnref3">↩</a></li>
</ol>
</section>
</body>
</html>
