<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="133">P (complexity)</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>P (complexity)</h1>
<hr/>

<p>In <a href="computational_complexity_theory" title="wikilink">computational complexity theory</a>, <strong>P</strong>, also known as <strong>PTIME</strong> or <strong><a class="uri" href="DTIME" title="wikilink">DTIME</a></strong>(<em>n</em><sup>O(1)</sup>), is one of the most fundamental <a href="complexity_class" title="wikilink">complexity classes</a>. It contains all <a href="decision_problem" title="wikilink">decision problems</a> that can be solved by a <a href="deterministic_Turing_machine" title="wikilink">deterministic Turing machine</a> using a <a class="uri" href="polynomial" title="wikilink">polynomial</a> amount of <a href="computation_time" title="wikilink">computation time</a>, or <a href="polynomial_time" title="wikilink">polynomial time</a>.</p>

<p><a href="Cobham's_thesis" title="wikilink">Cobham's thesis</a> holds that <strong>P</strong> is the class of computational problems that are "efficiently solvable" or "tractable"; in practice, some problems not known to be in <strong>P</strong> have practical solutions, and some that are in <strong>P</strong> do not, but this is a useful rule of thumb.</p>
<h2 id="definition">Definition</h2>

<p>A language <em>L</em> is in <strong>P</strong> if and only if there exists a deterministic Turing machine <em>M</em>, such that</p>
<ul>
<li><em>M</em> runs for polynomial time on all inputs</li>
<li>For all <em>x</em> in <em>L</em>, <em>M</em> outputs 1</li>
<li>For all <em>x</em> not in <em>L</em>, <em>M</em> outputs 0</li>
</ul>

<p><strong>P</strong> can also be viewed as a uniform family of <a href="boolean_circuit" title="wikilink">boolean circuits</a>. A language <em>L</em> is in <strong>P</strong> if and only if there exists a <a href="Circuit_complexity#Polynomial-time_uniform" title="wikilink">polynomial-time uniform</a> family of boolean circuits 

<math display="inline" id="P_(complexity):0">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <msub>
    <mi>C</mi>
    <mi>n</mi>
   </msub>
   <mo>:</mo>
   <mrow>
    <mi>n</mi>
    <mo>∈</mo>
    <mi>ℕ</mi>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">conditional-set</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <in></in>
     <ci>n</ci>
     <ci>ℕ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{C_{n}:n\in\mathbb{N}\}
  </annotation>
 </semantics>
</math>

, such that</p>
<ul>
<li>For all 

<math display="inline" id="P_(complexity):1">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>∈</mo>
   <mi>ℕ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>n</ci>
    <ci>ℕ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n\in\mathbb{N}
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="P_(complexity):2">
 <semantics>
  <msub>
   <mi>C</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>C</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{n}
  </annotation>
 </semantics>
</math>

 takes <em>n</em> bits as input and outputs 1 bit</li>
<li>For all <em>x</em> in <em>L</em>, 

<math display="inline" id="P_(complexity):3">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>C</mi>
     <mrow>
      <mo stretchy="false">|</mo>
      <mi>x</mi>
      <mo stretchy="false">|</mo>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>C</ci>
      <apply>
       <abs></abs>
       <ci>x</ci>
      </apply>
     </apply>
     <ci>x</ci>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{|x|}(x)=1
  </annotation>
 </semantics>
</math>

</li>
<li>For all <em>x</em> not in <em>L</em>, 

<math display="inline" id="P_(complexity):4">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>C</mi>
     <mrow>
      <mo stretchy="false">|</mo>
      <mi>x</mi>
      <mo stretchy="false">|</mo>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>C</ci>
      <apply>
       <abs></abs>
       <ci>x</ci>
      </apply>
     </apply>
     <ci>x</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{|x|}(x)=0
  </annotation>
 </semantics>
</math>

</li>
</ul>

<p>The circuit definition can be weakened to use only a <a href="Circuit_complexity#Logspace_uniform" title="wikilink">logspace uniform</a> family without changing the complexity class.</p>
<h2 id="notable-problems-in-p">Notable problems in P</h2>

<p><strong>P</strong> is known to contain many natural problems, including the decision versions of <a href="linear_programming" title="wikilink">linear programming</a>, calculating the <a href="greatest_common_divisor" title="wikilink">greatest common divisor</a>, and finding a <a href="maximum_matching" title="wikilink">maximum matching</a>. In 2002, it was shown that the problem of determining if a number is <a href="prime_number" title="wikilink">prime</a> is in <strong>P</strong>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> The related class of <a href="function_problem" title="wikilink">function problems</a> is <strong><a href="FP_(complexity)" title="wikilink">FP</a></strong>.</p>

<p>Several natural problems are complete for <strong>P</strong>, including <a href="st-connectivity" title="wikilink"><em>st</em>-connectivity</a> (or <a class="uri" href="reachability" title="wikilink">reachability</a>) on alternating graphs.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> The article on <a href="P-complete" title="wikilink"><strong>P</strong>-complete problems</a> lists further relevant problems in <strong>P</strong>.</p>
<h2 id="relationships-to-other-classes">Relationships to other classes</h2>

<p>A generalization of <strong>P</strong> is <strong><a href="NP_(complexity)" title="wikilink">NP</a></strong>, which is the class of <a href="decision_problem" title="wikilink">decision problems</a> decidable by a <a href="non-deterministic_Turing_machine" title="wikilink">non-deterministic Turing machine</a> that runs in <a href="polynomial_time" title="wikilink">polynomial time</a>. Equivalently, it is the class of decision problems where each "yes" instance has a polynomial size certificate, and certificates can be checked by a polynomial time deterministic Turing machine. The class of problems for which this is true for the "no" instances is called <strong><a class="uri" href="co-NP" title="wikilink">co-NP</a></strong>. <strong>P</strong> is trivially a subset of <strong>NP</strong> and of <strong>co-NP</strong>; most experts believe it is a proper subset,<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> although this (the <a href="P_=_NP_problem" title="wikilink"><strong>P</strong> ≠ <strong>NP</strong> hypothesis</a>) remains unproven. Another open problem is whether <strong>NP</strong> = <strong>co-NP</strong> (a negative answer would imply <strong>P</strong> ≠ <strong>NP</strong>).</p>

<p><strong>P</strong> is also known to be at least as large as <strong><a href="L_(complexity)" title="wikilink">L</a></strong>, the class of problems decidable in a <a href="logarithm" title="wikilink">logarithmic</a> amount of <a href="Memory_space_(computational_resource)" title="wikilink">memory space</a>. A decider using 

<math display="inline" id="P_(complexity):5">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>log</mi>
     <mi>n</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <log></log>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(\log n)
  </annotation>
 </semantics>
</math>

 space cannot use more than 

<math display="inline" id="P_(complexity):6">
 <semantics>
  <mrow>
   <msup>
    <mn>2</mn>
    <mrow>
     <mi>O</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>log</mi>
       <mi>n</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </msup>
   <mo>=</mo>
   <msup>
    <mi>n</mi>
    <mrow>
     <mi>O</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>1</mn>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <apply>
      <times></times>
      <ci>O</ci>
      <apply>
       <log></log>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>n</ci>
     <apply>
      <times></times>
      <ci>O</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{O(\log n)}=n^{O(1)}
  </annotation>
 </semantics>
</math>

 time, because this is the total number of possible configurations; thus, <strong>L</strong> is a subset of <strong>P</strong>. Another important problem is whether <strong>L</strong> = <strong>P</strong>. We do know that <strong>P</strong> = <strong>AL</strong>, the set of problems solvable in logarithmic memory by <a href="alternating_Turing_machine" title="wikilink">alternating Turing machines</a>. <strong>P</strong> is also known to be no larger than <strong><a class="uri" href="PSPACE" title="wikilink">PSPACE</a></strong>, the class of problems decidable in polynomial space. Again, whether <strong>P</strong> = <strong>PSPACE</strong> is an open problem. To summarize:</p>

<p>

<math display="block" id="P_(complexity):7">
 <semantics>
  <mrow>
   <mrow>
    <mtext>L</mtext>
    <mo>⊆</mo>
    <mtext>AL</mtext>
    <mo>=</mo>
    <mtext>P</mtext>
    <mo>⊆</mo>
    <mtext>NP</mtext>
    <mo>⊆</mo>
    <mtext>PSPACE</mtext>
    <mo>⊆</mo>
    <mtext>EXPTIME</mtext>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <subset></subset>
     <mtext>L</mtext>
     <mtext>AL</mtext>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <mtext>P</mtext>
    </apply>
    <apply>
     <subset></subset>
     <share href="#.cmml">
     </share>
     <mtext>NP</mtext>
    </apply>
    <apply>
     <subset></subset>
     <share href="#.cmml">
     </share>
     <mtext>PSPACE</mtext>
    </apply>
    <apply>
     <subset></subset>
     <share href="#.cmml">
     </share>
     <mtext>EXPTIME</mtext>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mbox{L}\subseteq\mbox{AL}=\mbox{P}\subseteq\mbox{NP}\subseteq\mbox{PSPACE}%
\subseteq\mbox{EXPTIME}.
  </annotation>
 </semantics>
</math>

</p>

<p>Here, <strong><a class="uri" href="EXPTIME" title="wikilink">EXPTIME</a></strong> is the class of problems solvable in exponential time. Of all the classes shown above, only two strict containments are known:</p>
<ul>
<li><strong>P</strong> is strictly contained in <strong>EXPTIME</strong>. Consequently, all <strong>EXPTIME</strong>-hard problems lie outside <strong>P</strong>, and at least one of the containments to the right of <strong>P</strong> above is strict (in fact, it is widely believed that all three are strict).</li>
<li><strong>L</strong> is strictly contained in <strong>PSPACE</strong>.</li>
</ul>

<p>The most difficult problems in P are <a class="uri" href="P-complete" title="wikilink">P-complete</a> problems.</p>

<p>Another generalization of <strong>P</strong> is <strong><a class="uri" href="P/poly" title="wikilink">P/poly</a></strong>, or <strong>Nonuniform Polynomial-Time</strong>. If a problem is in <strong>P/poly</strong>, then it can be solved in deterministic polynomial time provided that an <a href="advice_(complexity)" title="wikilink">advice string</a> is given that depends only on the length of the input. Unlike for <strong>NP</strong>, however, the polynomial-time machine doesn't need to detect fraudulent advice strings; it is not a verifier. <strong>P/poly</strong> is a large class containing nearly all practical problems, including all of <strong><a href="Bounded-error_probabilistic_polynomial" title="wikilink">BPP</a></strong>. If it contains <strong>NP</strong>, then the <a href="polynomial_hierarchy" title="wikilink">polynomial hierarchy</a> collapses to the second level. On the other hand, it also contains some impractical problems, including some <a href="undecidable_problem" title="wikilink">undecidable problems</a> such as the unary version of any undecidable problem.</p>

<p>In 1999, Jin-Yi Cai and D. Sivakumar, building on work by <a href="Mitsunori_Ogihara" title="wikilink">Mitsunori Ogihara</a>, showed that if there exists a <a href="sparse_language" title="wikilink">sparse language</a> that is <strong>P-complete</strong>, then <strong>L</strong> = <strong>P</strong>.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>
<h2 id="properties">Properties</h2>

<p>Polynomial-time algorithms are closed under composition. Intuitively, this says that if one writes a function that is polynomial-time assuming that function calls are constant-time, and if those called functions themselves require polynomial time, then the entire algorithm takes polynomial time. One consequence of this is that <strong>P</strong> is <a href="low_(complexity)" title="wikilink">low</a> for itself. This is also one of the main reasons that <strong>P</strong> is considered to be a machine-independent class; any machine "feature", such as <a href="random_access" title="wikilink">random access</a>, that can be simulated in polynomial time can simply be composed with the main polynomial-time algorithm to reduce it to a polynomial-time algorithm on a more basic machine.</p>

<p>Languages in <strong>P</strong> are also closed under reversal, <a href="Intersection_(set_theory)" title="wikilink">intersection</a>, <a href="Union_(set_theory)" title="wikilink">union</a>, <a class="uri" href="concatenation" title="wikilink">concatenation</a>, <a href="Kleene_closure" title="wikilink">Kleene closure</a>, inverse <a class="uri" href="homomorphism" title="wikilink">homomorphism</a>, and <a href="Complement_(complexity)" title="wikilink">complementation</a>.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>
<h2 id="pure-existence-proofs-of-polynomial-time-algorithms">Pure existence proofs of polynomial-time algorithms</h2>

<p>Some problems are known to be solvable in polynomial-time, but no concrete algorithm is known for solving them. For example, the <a href="Robertson–Seymour_theorem" title="wikilink">Robertson–Seymour theorem</a> guarantees that there is a finite list of <a href="forbidden_minor" title="wikilink">forbidden minors</a> that characterizes (for example) the set of graphs that can be embedded on a torus; moreover, Robertson and Seymour showed that there is an O(<em>n</em><sup>3</sup>) algorithm for determining whether a graph has a given graph as a minor. This yields a <a href="nonconstructive_proof" title="wikilink">nonconstructive proof</a> that there is a polynomial-time algorithm for determining if a given graph can be embedded on a torus, despite the fact that no concrete algorithm is known for this problem.</p>
<h2 id="alternative-characterizations">Alternative characterizations</h2>

<p>In <a href="descriptive_complexity" title="wikilink">descriptive complexity</a>, <strong>P</strong> can be described as the problems expressible in <a class="uri" href="FO(LFP)" title="wikilink">FO(LFP)</a>, the <a href="first-order_logic" title="wikilink">first-order logic</a> with a <a href="least_fixed_point" title="wikilink">least fixed point</a> operator added to it, on ordered structures. In Immerman's 1999 textbook on descriptive complexity,<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> Immerman ascribes this result to Vardi<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> and to Immerman.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></p>

<p>It was published in 2001 that PTIME corresponds to (positive) <a href="range_concatenation_grammars" title="wikilink">range concatenation grammars</a>.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></p>
<h2 id="history">History</h2>

<p><a href="Dexter_Kozen" title="wikilink">Kozen</a><a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> states that <a href="Alan_Cobham_(mathematician)" title="wikilink">Cobham</a> and <a href="Jack_Edmonds" title="wikilink">Edmonds</a> are "generally credited with the invention of the notion of polynomial time." Cobham invented the class as a robust way of characterizing efficient algorithms, leading to <a href="Cobham's_thesis" title="wikilink">Cobham's thesis</a>. However, <a href="Henry_Cabourn_Pocklington" title="wikilink">H. C. Pocklington</a>, in a 1910 paper,<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a><a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> analyzed two algorithms for solving quadratic congruences, and observed that one took time "proportional to a power of the logarithm of the modulus" and contrasted this with one that took time proportional "to the modulus itself or its square root", thus explicitly drawing a distinction between an algorithm that ran in polynomial time versus one that did not.</p>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<ul>
<li></li>
<li><a href="Thomas_H._Cormen" title="wikilink">Thomas H. Cormen</a>, <a href="Charles_E._Leiserson" title="wikilink">Charles E. Leiserson</a>, <a href="Ronald_L._Rivest" title="wikilink">Ronald L. Rivest</a>, and <a href="Clifford_Stein" title="wikilink">Clifford Stein</a>. <em><a href="Introduction_to_Algorithms" title="wikilink">Introduction to Algorithms</a></em>, Second Edition. MIT Press and McGraw–Hill, 2001. ISBN 0-262-03293-7. Section 34.1: Polynomial time, pp. 971–979.</li>
<li></li>
<li>

<p>Section 7.2: The Class P, pp. 256–263;.</p></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li></li>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Complexity_classes" title="wikilink">Category:Complexity classes</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Manindra Agrawal, Neeraj Kayal, Nitin Saxena, "<a href="http://www.cse.iitk.ac.in/users/manindra/algebra/primality_v6.pdf">PRIMES is in P</a>", <em>Annals of Mathematics</em> 160 (2004), no. 2, pp. 781–793.<a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3">Johnsonbaugh, Richard; Schaefer, Marcus, <em>Algorithms</em>, 2004 Pearson Education, page 458, ISBN 0-02-360692-4<a href="#fnref3">↩</a></li>
<li id="fn4">Jin-Yi Cai and D. Sivakumar. Sparse hard sets for P: resolution of a conjecture of Hartmanis. <em>Journal of Computer and System Sciences</em>, volume 58, issue 2, pp.280–296. 1999. ISSN:0022-0000. <a href="http://citeseer.ist.psu.edu/501645.html">At Citeseer</a><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
<li id="fn8"> Revised version in <em>Information and Control</em>, 68 (1986), 86–104.<a href="#fnref8">↩</a></li>
<li id="fn9"> citing <a class="uri" href="http://mjn.host.cs.st-andrews.ac.uk/publications/2001d.pdf">http://mjn.host.cs.st-andrews.ac.uk/publications/2001d.pdf</a> for the proof<a href="#fnref9">↩</a></li>
<li id="fn10"><a href="#fnref10">↩</a></li>
<li id="fn11"><a href="#fnref11">↩</a></li>
<li id="fn12"><a href="#fnref12">↩</a></li>
</ol>
</section>
</body>
</html>
