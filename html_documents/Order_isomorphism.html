<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="869">Order isomorphism</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Order isomorphism</h1>
<hr/>

<p>In the <a href="mathematics" title="wikilink">mathematical</a> field of <a href="order_theory" title="wikilink">order theory</a> an <strong>order isomorphism</strong> is a special kind of <a href="monotone_function" title="wikilink">monotone function</a> that constitutes a suitable notion of <a class="uri" href="isomorphism" title="wikilink">isomorphism</a> for <a href="partially_ordered_set" title="wikilink">partially ordered sets</a> (posets). Whenever two posets are order isomorphic, they can be considered to be "essentially the same" in the sense that one of the orders can be obtained from the other just by renaming of elements. Two strictly weaker notions that relate to order isomorphisms are <a href="order_embedding" title="wikilink">order embeddings</a> and <a href="Galois_connection" title="wikilink">Galois connections</a>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>
<h2 id="definition">Definition</h2>

<p>Formally, given two posets 

<math display="inline" id="Order_isomorphism:0">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>S</mi>
   <mo>,</mo>
   <msub>
    <mo>≤</mo>
    <mi>S</mi>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>S</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <leq></leq>
     <ci>S</ci>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (S,\leq_{S})
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Order_isomorphism:1">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>T</mi>
   <mo>,</mo>
   <msub>
    <mo>≤</mo>
    <mi>T</mi>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>T</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <leq></leq>
     <ci>T</ci>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (T,\leq_{T})
  </annotation>
 </semantics>
</math>

, an <strong>order isomorphism</strong> from 

<math display="inline" id="Order_isomorphism:2">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>S</mi>
   <mo>,</mo>
   <msub>
    <mo>≤</mo>
    <mi>S</mi>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>S</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <leq></leq>
     <ci>S</ci>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (S,\leq_{S})
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Order_isomorphism:3">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>T</mi>
   <mo>,</mo>
   <msub>
    <mo>≤</mo>
    <mi>T</mi>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>T</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <leq></leq>
     <ci>T</ci>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (T,\leq_{T})
  </annotation>
 </semantics>
</math>

 is a <a href="bijection" title="wikilink">bijective function</a> 

<math display="inline" id="Order_isomorphism:4">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 from 

<math display="inline" id="Order_isomorphism:5">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Order_isomorphism:6">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

 with the property that, for every 

<math display="inline" id="Order_isomorphism:7">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Order_isomorphism:8">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

 in 

<math display="inline" id="Order_isomorphism:9">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Order_isomorphism:10">
 <semantics>
  <mrow>
   <mi>x</mi>
   <msub>
    <mo>≤</mo>
    <mi>S</mi>
   </msub>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <leq></leq>
     <ci>S</ci>
    </apply>
    <ci>x</ci>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\leq_{S}y
  </annotation>
 </semantics>
</math>

 if and only if 

<math display="inline" id="Order_isomorphism:11">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <msub>
    <mo>≤</mo>
    <mi>T</mi>
   </msub>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <leq></leq>
     <ci>T</ci>
    </apply>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x)\leq_{T}f(y)
  </annotation>
 </semantics>
</math>

. That is, it is a bijective <a class="uri" href="order-embedding" title="wikilink">order-embedding</a>.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>

<p>It is also possible to define an order isomorphism to be a <a class="uri" href="surjective" title="wikilink">surjective</a> order-embedding. The two assumptions that 

<math display="inline" id="Order_isomorphism:12">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 cover all the elements of 

<math display="inline" id="Order_isomorphism:13">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

 and that it preserve orderings, are enough to ensure that 

<math display="inline" id="Order_isomorphism:14">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 is also one-to-one, for if 

<math display="inline" id="Order_isomorphism:15">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x)=f(y)
  </annotation>
 </semantics>
</math>

 then (by the assumption that 

<math display="inline" id="Order_isomorphism:16">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 preserves the order) it would follow that 

<math display="inline" id="Order_isomorphism:17">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>≤</mo>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <ci>x</ci>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\leq y
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Order_isomorphism:18">
 <semantics>
  <mrow>
   <mi>y</mi>
   <mo>≤</mo>
   <mi>x</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <ci>y</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y\leq x
  </annotation>
 </semantics>
</math>

, implying by the definition of a partial order that 

<math display="inline" id="Order_isomorphism:19">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>=</mo>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>x</ci>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x=y
  </annotation>
 </semantics>
</math>

.</p>

<p>Yet another characterization of order isomorphisms is that they are exactly the <a href="monotone_function" title="wikilink">monotone</a> <a href="bijection" title="wikilink">bijections</a> that have a monotone inverse.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>

<p>An order isomorphism from a partially ordered set to itself is called an <strong>order <a class="uri" href="automorphism" title="wikilink">automorphism</a></strong>.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>
<h2 id="examples">Examples</h2>
<ul>
<li>The <a href="identity_function" title="wikilink">identity function</a> on any partially ordered set is always an order automorphism.</li>
<li><a href="Additive_inverse" title="wikilink">Negation</a> is an order isomorphism from 

<math display="inline" id="Order_isomorphism:20">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>ℝ</mi>
   <mo>,</mo>
   <mo>≤</mo>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>ℝ</ci>
    <leq></leq>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\mathbb{R},\leq)
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Order_isomorphism:21">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>ℝ</mi>
   <mo>,</mo>
   <mo>≥</mo>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>ℝ</ci>
    <geq></geq>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\mathbb{R},\geq)
  </annotation>
 </semantics>
</math>

 (where 

<math display="inline" id="Order_isomorphism:22">
 <semantics>
  <mi>ℝ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℝ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{R}
  </annotation>
 </semantics>
</math>

 is the set of <a href="real_number" title="wikilink">real numbers</a> and 

<math display="inline" id="Order_isomorphism:23">
 <semantics>
  <mo>≤</mo>
  <annotation-xml encoding="MathML-Content">
   <leq></leq>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \leq
  </annotation>
 </semantics>
</math>

 denotes the usual numerical comparison), since −<em>x</em> ≥ −<em>y</em> if and only if <em>x</em> ≤ <em>y</em>.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></li>
<li>The <a href="open_interval" title="wikilink">open interval</a> 

<math display="inline" id="Order_isomorphism:24">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mn>0</mn>
   <mo>,</mo>
   <mn>1</mn>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <cn type="integer">0</cn>
    <cn type="integer">1</cn>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (0,1)
  </annotation>
 </semantics>
</math>

 (again, ordered numerically) does not have an order isomorphism to or from the <a href="closed_interval" title="wikilink">closed interval</a> 

<math display="inline" id="Order_isomorphism:25">
 <semantics>
  <mrow>
   <mo stretchy="false">[</mo>
   <mn>0</mn>
   <mo>,</mo>
   <mn>1</mn>
   <mo stretchy="false">]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="closed">
    <cn type="integer">0</cn>
    <cn type="integer">1</cn>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [0,1]
  </annotation>
 </semantics>
</math>

: the closed interval has a least element, but the open interval does not, and order isomorphisms must preserve the existence of least elements.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></li>
</ul>
<h2 id="order-types">Order types</h2>

<p>If 

<math display="inline" id="Order_isomorphism:26">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 is an order isomorphism, then so is its <a href="inverse_function" title="wikilink">inverse function</a>. Also, if 

<math display="inline" id="Order_isomorphism:27">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 is an order isomorphism from 

<math display="inline" id="Order_isomorphism:28">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>S</mi>
   <mo>,</mo>
   <msub>
    <mo>≤</mo>
    <mi>S</mi>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>S</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <leq></leq>
     <ci>S</ci>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (S,\leq_{S})
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Order_isomorphism:29">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>T</mi>
   <mo>,</mo>
   <msub>
    <mo>≤</mo>
    <mi>T</mi>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>T</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <leq></leq>
     <ci>T</ci>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (T,\leq_{T})
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Order_isomorphism:30">
 <semantics>
  <mi>g</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>g</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g
  </annotation>
 </semantics>
</math>

 is an order isomorphism from 

<math display="inline" id="Order_isomorphism:31">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>T</mi>
   <mo>,</mo>
   <msub>
    <mo>≤</mo>
    <mi>T</mi>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>T</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <leq></leq>
     <ci>T</ci>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (T,\leq_{T})
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Order_isomorphism:32">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>U</mi>
   <mo>,</mo>
   <msub>
    <mo>≤</mo>
    <mi>U</mi>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>U</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <leq></leq>
     <ci>U</ci>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (U,\leq_{U})
  </annotation>
 </semantics>
</math>

, then the <a href="function_composition" title="wikilink">function composition</a> of 

<math display="inline" id="Order_isomorphism:33">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Order_isomorphism:34">
 <semantics>
  <mi>g</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>g</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g
  </annotation>
 </semantics>
</math>

 is itself an order isomorphism, from 

<math display="inline" id="Order_isomorphism:35">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>S</mi>
   <mo>,</mo>
   <msub>
    <mo>≤</mo>
    <mi>S</mi>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>S</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <leq></leq>
     <ci>S</ci>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (S,\leq_{S})
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Order_isomorphism:36">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>U</mi>
   <mo>,</mo>
   <msub>
    <mo>≤</mo>
    <mi>U</mi>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>U</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <leq></leq>
     <ci>U</ci>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (U,\leq_{U})
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>

<p>Two partially ordered sets are said to be <strong>order isomorphic</strong> when there exists an order isomorphism from one to the other.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> Identity functions, function inverses, and compositions of functions correspond, respectively, to the three defining characteristics of an <a href="equivalence_relation" title="wikilink">equivalence relation</a>: <a href="reflexive_relation" title="wikilink">reflexivity</a>, <a href="symmetric_relation" title="wikilink">symmetry</a>, and <a href="transitive_relation" title="wikilink">transitivity</a>. Therefore, order isomorphism is an equivalence relation. The class of partially ordered sets can be partitioned by it into <a href="equivalence_class" title="wikilink">equivalence classes</a>, families of partially ordered sets that are all isomorphic to each other. These equivalence classes are called <a href="order_type" title="wikilink">order types</a>.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Permutation_pattern" title="wikilink">Permutation pattern</a>, a permutation that is order-isomorphic to a subsequence of another permutation</li>
</ul>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<ul>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
</ul>

<p>"</p>

<p><a href="Category:Order_theory" title="wikilink">Category:Order theory</a> <a class="uri" href="Category:Morphisms" title="wikilink">Category:Morphisms</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">; .<a href="#fnref1">↩</a></li>
<li id="fn2">This is the definition used by . For  and  it is a consequence of a different definition.<a href="#fnref2">↩</a></li>
<li id="fn3">This is the definition used by  and .<a href="#fnref3">↩</a></li>
<li id="fn4">, p. 13.<a href="#fnref4">↩</a></li>
<li id="fn5">See example 4 of , p. 39., for a similar example with integers in place of real numbers.<a href="#fnref5">↩</a></li>
<li id="fn6">, example 1, p. 39.<a href="#fnref6">↩</a></li>
<li id="fn7">; .<a href="#fnref7">↩</a></li>
<li id="fn8">.<a href="#fnref8">↩</a></li>
</ol>
</section>
</body>
</html>
