<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="658">LPBoost</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>LPBoost</h1>
<hr/>

<p><strong>Linear Programming Boosting</strong> (<strong>LPBoost</strong>) is a <a href="supervised_classification" title="wikilink">supervised classifier</a> from the <a href="Boosting_(machine_learning)" title="wikilink">boosting</a> family of classifiers. LPBoost maximizes a <em>margin</em> between training samples of different classes and hence also belongs to the class of margin-maximizing supervised classification algorithms. Consider a classification function</p>

<p>

<math display="block" id="LPBoost:0">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mo>:</mo>
    <mrow>
     <mi class="ltx_font_mathcaligraphic">𝒳</mi>
     <mo>→</mo>
     <mrow>
      <mo stretchy="false">{</mo>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
      <mo>,</mo>
      <mn>1</mn>
      <mo stretchy="false">}</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>f</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>𝒳</ci>
     <set>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
      <cn type="integer">1</cn>
     </set>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f:\mathcal{X}\to\{-1,1\},
  </annotation>
 </semantics>
</math>

 which classifies samples from a space 

<math display="inline" id="LPBoost:1">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒳</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒳</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{X}
  </annotation>
 </semantics>
</math>

 into one of two classes, labelled 1 and -1, respectively. LPBoost is an algorithm to <em>learn</em> such a classification function given a set of training examples with known class labels. LPBoost is a <a href="machine_learning" title="wikilink">machine learning</a> technique and especially suited for applications of joint classification and feature selection in structured domains.</p>
<h2 id="lpboost-overview">LPBoost overview</h2>

<p>As in all boosting classifiers, the final classification function is of the form</p>

<p>

<math display="block" id="LPBoost:2">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>𝒙</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>j</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>J</mi>
     </munderover>
     <mrow>
      <msub>
       <mi>α</mi>
       <mi>j</mi>
      </msub>
      <msub>
       <mi>h</mi>
       <mi>j</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>𝒙</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>𝒙</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>j</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>J</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>α</ci>
       <ci>j</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>h</ci>
       <ci>j</ci>
      </apply>
      <ci>𝒙</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(\boldsymbol{x})=\sum_{j=1}^{J}\alpha_{j}h_{j}(\boldsymbol{x}),
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="LPBoost:3">
 <semantics>
  <msub>
   <mi>α</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>α</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha_{j}
  </annotation>
 </semantics>
</math>

 are non-negative weightings for <em>weak</em> classifiers 

<math display="inline" id="LPBoost:4">
 <semantics>
  <mrow>
   <msub>
    <mi>h</mi>
    <mi>j</mi>
   </msub>
   <mo>:</mo>
   <mrow>
    <mi class="ltx_font_mathcaligraphic">𝒳</mi>
    <mo>→</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
     <mo>,</mo>
     <mn>1</mn>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>h</ci>
     <ci>j</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <ci>𝒳</ci>
     <set>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
      <cn type="integer">1</cn>
     </set>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h_{j}:\mathcal{X}\to\{-1,1\}
  </annotation>
 </semantics>
</math>

. Each individual weak classifier 

<math display="inline" id="LPBoost:5">
 <semantics>
  <msub>
   <mi>h</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>h</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h_{j}
  </annotation>
 </semantics>
</math>

 may be just a little bit better than random, but the resulting linear combination of many weak classifiers can perform very well.</p>

<p>LPBoost constructs 

<math display="inline" id="LPBoost:6">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 by starting with an empty set of weak classifiers. Iteratively, a single weak classifier to add to the set of considered weak classifiers is selected, added and all the weights 

<math display="inline" id="LPBoost:7">
 <semantics>
  <mi>𝜶</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝜶</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \boldsymbol{\alpha}
  </annotation>
 </semantics>
</math>

 for the current set of weak classifiers are adjusted. This is repeated until no weak classifiers to add remain.</p>

<p>The property that all classifier weights are adjusted in each iteration is known as <em>totally-corrective</em> property. Early boosting methods, such as <a class="uri" href="AdaBoost" title="wikilink">AdaBoost</a> do not have this property and converge slower.</p>
<h2 id="linear-program">Linear program</h2>

<p>More generally, let 

<math display="inline" id="LPBoost:8">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">ℋ</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mi>h</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mo>⋅</mo>
      <mo>;</mo>
      <mi>ω</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">|</mo>
    <mrow>
     <mi>ω</mi>
     <mo>∈</mo>
     <mi mathvariant="normal">Ω</mi>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>ℋ</ci>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <apply>
      <times></times>
      <ci>h</ci>
      <list>
       <ci>normal-⋅</ci>
       <ci>ω</ci>
      </list>
     </apply>
     <apply>
      <in></in>
      <ci>ω</ci>
      <ci>normal-Ω</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{H}=\{h(\cdot;\omega)|\omega\in\Omega\}
  </annotation>
 </semantics>
</math>

 be the possibly infinite set of weak classifiers, also termed <em>hypotheses</em>. One way to write down the problem LPBoost solves is as a <a href="linear_program" title="wikilink">linear program</a> with infinitely many variables.</p>

<p>The primal linear program of LPBoost, optimizing over the non-negative weight vector 

<math display="inline" id="LPBoost:9">
 <semantics>
  <mi>𝜶</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝜶</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \boldsymbol{\alpha}
  </annotation>
 </semantics>
</math>

, the non-negative vector 

<math display="inline" id="LPBoost:10">
 <semantics>
  <mi>𝝃</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝝃</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \boldsymbol{\xi}
  </annotation>
 </semantics>
</math>

 of slack variables and the <em>margin</em> 

<math display="inline" id="LPBoost:11">
 <semantics>
  <mi>ρ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ρ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho
  </annotation>
 </semantics>
</math>

 is the following.</p>

<p>

<math display="block" id="LPBoost:12">
 <semantics>
  <mtable displaystyle="true">
   <mtr>
    <mtd columnalign="center">
     <munder accentunder="true">
      <mi>min</mi>
      <mrow>
       <mi>𝜶</mi>
       <mo>,</mo>
       <mi>𝝃</mi>
       <mo>,</mo>
       <mi>ρ</mi>
      </mrow>
     </munder>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mrow>
       <mo>-</mo>
       <mi>ρ</mi>
      </mrow>
      <mo>+</mo>
      <mrow>
       <mi>D</mi>
       <mrow>
        <munderover>
         <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
         <mrow>
          <mi>n</mi>
          <mo>=</mo>
          <mn>1</mn>
         </mrow>
         <mi mathvariant="normal">ℓ</mi>
        </munderover>
        <msub>
         <mi>ξ</mi>
         <mi>n</mi>
        </msub>
       </mrow>
      </mrow>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="center">
     <mtext>sb.t.</mtext>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mrow>
       <mrow>
        <mrow>
         <mrow>
          <munder>
           <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
           <mrow>
            <mi>ω</mi>
            <mo>∈</mo>
            <mi mathvariant="normal">Ω</mi>
           </mrow>
          </munder>
          <mrow>
           <msub>
            <mi>y</mi>
            <mi>n</mi>
           </msub>
           <msub>
            <mi>α</mi>
            <mi>ω</mi>
           </msub>
           <mi>h</mi>
           <mrow>
            <mo stretchy="false">(</mo>
            <msub>
             <mi>𝒙</mi>
             <mi>n</mi>
            </msub>
            <mo>;</mo>
            <mi>ω</mi>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
         </mrow>
         <mo>+</mo>
         <msub>
          <mi>ξ</mi>
          <mi>n</mi>
         </msub>
        </mrow>
        <mo>≥</mo>
        <mi>ρ</mi>
       </mrow>
       <mo rspace="22.5pt">,</mo>
       <mrow>
        <mi>n</mi>
        <mo>=</mo>
        <mrow>
         <mn>1</mn>
         <mo>,</mo>
         <mi mathvariant="normal">…</mi>
         <mo>,</mo>
         <mi mathvariant="normal">ℓ</mi>
        </mrow>
       </mrow>
      </mrow>
      <mo>,</mo>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd></mtd>
    <mtd columnalign="left">
     <mrow>
      <mrow>
       <mrow>
        <munder>
         <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
         <mrow>
          <mi>ω</mi>
          <mo>∈</mo>
          <mi mathvariant="normal">Ω</mi>
         </mrow>
        </munder>
        <msub>
         <mi>α</mi>
         <mi>ω</mi>
        </msub>
       </mrow>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mo>,</mo>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd></mtd>
    <mtd columnalign="left">
     <mrow>
      <mrow>
       <mrow>
        <msub>
         <mi>ξ</mi>
         <mi>n</mi>
        </msub>
        <mo>≥</mo>
        <mn>0</mn>
       </mrow>
       <mo rspace="22.5pt">,</mo>
       <mrow>
        <mi>n</mi>
        <mo>=</mo>
        <mrow>
         <mn>1</mn>
         <mo>,</mo>
         <mi mathvariant="normal">…</mi>
         <mo>,</mo>
         <mi mathvariant="normal">ℓ</mi>
        </mrow>
       </mrow>
      </mrow>
      <mo>,</mo>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd></mtd>
    <mtd columnalign="left">
     <mrow>
      <mrow>
       <mrow>
        <msub>
         <mi>α</mi>
         <mi>ω</mi>
        </msub>
        <mo>≥</mo>
        <mn>0</mn>
       </mrow>
       <mo rspace="22.5pt">,</mo>
       <mrow>
        <mi>ω</mi>
        <mo>∈</mo>
        <mi mathvariant="normal">Ω</mi>
       </mrow>
      </mrow>
      <mo>,</mo>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd></mtd>
    <mtd columnalign="left">
     <mrow>
      <mrow>
       <mi>ρ</mi>
       <mo>∈</mo>
       <mi>ℝ</mi>
      </mrow>
      <mo>.</mo>
     </mrow>
    </mtd>
   </mtr>
  </mtable>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <apply>
      <list>
       <ci>𝜶</ci>
       <ci>𝝃</ci>
       <ci>ρ</ci>
      </list>
      <min></min>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <minus></minus>
       <ci>ρ</ci>
      </apply>
      <apply>
       <times></times>
       <ci>D</ci>
       <apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <sum></sum>
          <apply>
           <eq></eq>
           <ci>n</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
         <ci>normal-ℓ</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>ξ</ci>
         <ci>n</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </matrixrow>
    <matrixrow>
     <mtext>sb.t.</mtext>
     <apply>
      <csymbol cd="ambiguous">formulae-sequence</csymbol>
      <apply>
       <geq></geq>
       <apply>
        <plus></plus>
        <apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <sum></sum>
          <apply>
           <in></in>
           <ci>ω</ci>
           <ci>normal-Ω</ci>
          </apply>
         </apply>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>y</ci>
           <ci>n</ci>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>α</ci>
           <ci>ω</ci>
          </apply>
          <ci>h</ci>
          <list>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>𝒙</ci>
            <ci>n</ci>
           </apply>
           <ci>ω</ci>
          </list>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>ξ</ci>
         <ci>n</ci>
        </apply>
       </apply>
       <ci>ρ</ci>
      </apply>
      <apply>
       <eq></eq>
       <ci>n</ci>
       <list>
        <cn type="integer">1</cn>
        <ci>normal-…</ci>
        <ci>normal-ℓ</ci>
       </list>
      </apply>
     </apply>
    </matrixrow>
    <matrixrow>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <apply>
      <eq></eq>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <in></in>
         <ci>ω</ci>
         <ci>normal-Ω</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>α</ci>
        <ci>ω</ci>
       </apply>
      </apply>
      <cn type="integer">1</cn>
     </apply>
    </matrixrow>
    <matrixrow>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <apply>
      <csymbol cd="ambiguous">formulae-sequence</csymbol>
      <apply>
       <geq></geq>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ξ</ci>
        <ci>n</ci>
       </apply>
       <cn type="integer">0</cn>
      </apply>
      <apply>
       <eq></eq>
       <ci>n</ci>
       <list>
        <cn type="integer">1</cn>
        <ci>normal-…</ci>
        <ci>normal-ℓ</ci>
       </list>
      </apply>
     </apply>
    </matrixrow>
    <matrixrow>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <apply>
      <csymbol cd="ambiguous">formulae-sequence</csymbol>
      <apply>
       <geq></geq>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>α</ci>
        <ci>ω</ci>
       </apply>
       <cn type="integer">0</cn>
      </apply>
      <apply>
       <in></in>
       <ci>ω</ci>
       <ci>normal-Ω</ci>
      </apply>
     </apply>
    </matrixrow>
    <matrixrow>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <apply>
      <in></in>
      <ci>ρ</ci>
      <ci>ℝ</ci>
     </apply>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{array}[]{cl}\underset{\boldsymbol{\alpha},\boldsymbol{\xi},\rho}{\min}&%
-\rho+D\sum_{n=1}^{\ell}\xi_{n}\\
\textrm{sb.t.}&\sum_{\omega\in\Omega}y_{n}\alpha_{\omega}h(\boldsymbol{x}_{n};%
\omega)+\xi_{n}\geq\rho,\qquad n=1,\dots,\ell,\\
&\sum_{\omega\in\Omega}\alpha_{\omega}=1,\\
&\xi_{n}\geq 0,\qquad n=1,\dots,\ell,\\
&\alpha_{\omega}\geq 0,\qquad\omega\in\Omega,\\
&\rho\in{\mathbb{R}}.\end{array}
  </annotation>
 </semantics>
</math>

</p>

<p>Note the effects of slack variables 

<math display="inline" id="LPBoost:13">
 <semantics>
  <mrow>
   <mi>𝝃</mi>
   <mo>≥</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <ci>𝝃</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \boldsymbol{\xi}\geq 0
  </annotation>
 </semantics>
</math>

: their one-norm is penalized in the objective function by a constant factor 

<math display="inline" id="LPBoost:14">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>

, which—if small enough—always leads to a primal feasible linear program.</p>

<p>Here we adopted the notation of a parameter space 

<math display="inline" id="LPBoost:15">
 <semantics>
  <mi mathvariant="normal">Ω</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Ω</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Omega
  </annotation>
 </semantics>
</math>

, such that for a choice 

<math display="inline" id="LPBoost:16">
 <semantics>
  <mrow>
   <mi>ω</mi>
   <mo>∈</mo>
   <mi mathvariant="normal">Ω</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>ω</ci>
    <ci>normal-Ω</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \omega\in\Omega
  </annotation>
 </semantics>
</math>

 the weak classifier 

<math display="inline" id="LPBoost:17">
 <semantics>
  <mrow>
   <mrow>
    <mi>h</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mo>⋅</mo>
     <mo>;</mo>
     <mi>ω</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>:</mo>
   <mrow>
    <mi class="ltx_font_mathcaligraphic">𝒳</mi>
    <mo>→</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
     <mo>,</mo>
     <mn>1</mn>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <times></times>
     <ci>h</ci>
     <list>
      <ci>normal-⋅</ci>
      <ci>ω</ci>
     </list>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <ci>𝒳</ci>
     <set>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
      <cn type="integer">1</cn>
     </set>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h(\cdot;\omega):\mathcal{X}\to\{-1,1\}
  </annotation>
 </semantics>
</math>


 is uniquely defined.</p>

<p>When the above linear program was first written down in early publications about boosting methods it was disregarded as intractable due to the large number of variables 

<math display="inline" id="LPBoost:18">
 <semantics>
  <mi>𝜶</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝜶</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \boldsymbol{\alpha}
  </annotation>
 </semantics>
</math>

. Only later it was discovered that such linear programs can indeed be solved efficiently using the classic technique of <a href="Delayed_Column_Generation" title="wikilink">column generation</a>.</p>
<h3 id="column-generation-for-lpboost">Column Generation for LPBoost</h3>

<p>In a <a href="linear_program" title="wikilink">linear program</a> a <em>column</em> corresponds to a primal variable. <a href="Delayed_Column_Generation" title="wikilink">Column generation</a> is a technique to solve large linear programs. It typically works in a restricted problem, dealing only with a subset of variables. By generating primal variables iteratively and on-demand, eventually the original unrestricted problem with all variables is recovered. By cleverly choosing the columns to generate the problem can be solved such that while still guaranteeing the obtained solution to be optimal for the original full problem, only a small fraction of columns has to be created.</p>
<h4 id="lpboost-dual-problem">LPBoost dual problem</h4>

<p>Columns in the primal linear program corresponds to rows in the <a href="dual_problem" title="wikilink">dual linear program</a>. The equivalent dual linear program of LPBoost is the following linear program.</p>

<p>

<math display="block" id="LPBoost:19">
 <semantics>
  <mtable displaystyle="true">
   <mtr>
    <mtd columnalign="center">
     <munder accentunder="true">
      <mi>max</mi>
      <mrow>
       <mi>𝝀</mi>
       <mo>,</mo>
       <mi>γ</mi>
      </mrow>
     </munder>
    </mtd>
    <mtd columnalign="left">
     <mi>γ</mi>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="center">
     <mtext>sb.t.</mtext>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mrow>
       <mrow>
        <mrow>
         <mrow>
          <munderover>
           <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
           <mrow>
            <mi>n</mi>
            <mo>=</mo>
            <mn>1</mn>
           </mrow>
           <mi mathvariant="normal">ℓ</mi>
          </munderover>
          <mrow>
           <msub>
            <mi>y</mi>
            <mi>n</mi>
           </msub>
           <mi>h</mi>
           <mrow>
            <mo stretchy="false">(</mo>
            <msub>
             <mi>𝒙</mi>
             <mi>n</mi>
            </msub>
            <mo>;</mo>
            <mi>ω</mi>
            <mo stretchy="false">)</mo>
           </mrow>
           <msub>
            <mi>λ</mi>
            <mi>n</mi>
           </msub>
          </mrow>
         </mrow>
         <mo>+</mo>
         <mi>γ</mi>
        </mrow>
        <mo>≤</mo>
        <mn>0</mn>
       </mrow>
       <mo rspace="22.5pt">,</mo>
       <mrow>
        <mi>ω</mi>
        <mo>∈</mo>
        <mi mathvariant="normal">Ω</mi>
       </mrow>
      </mrow>
      <mo>,</mo>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd></mtd>
    <mtd columnalign="left">
     <mrow>
      <mrow>
       <mrow>
        <mn>0</mn>
        <mo>≤</mo>
        <msub>
         <mi>λ</mi>
         <mi>n</mi>
        </msub>
        <mo>≤</mo>
        <mi>D</mi>
       </mrow>
       <mo rspace="22.5pt">,</mo>
       <mrow>
        <mi>n</mi>
        <mo>=</mo>
        <mrow>
         <mn>1</mn>
         <mo>,</mo>
         <mi mathvariant="normal">…</mi>
         <mo>,</mo>
         <mi mathvariant="normal">ℓ</mi>
        </mrow>
       </mrow>
      </mrow>
      <mo>,</mo>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd></mtd>
    <mtd columnalign="left">
     <mrow>
      <mrow>
       <mrow>
        <munderover>
         <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
         <mrow>
          <mi>n</mi>
          <mo>=</mo>
          <mn>1</mn>
         </mrow>
         <mi mathvariant="normal">ℓ</mi>
        </munderover>
        <msub>
         <mi>λ</mi>
         <mi>n</mi>
        </msub>
       </mrow>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mo>,</mo>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd></mtd>
    <mtd columnalign="left">
     <mrow>
      <mrow>
       <mi>γ</mi>
       <mo>∈</mo>
       <mi>ℝ</mi>
      </mrow>
      <mo>.</mo>
     </mrow>
    </mtd>
   </mtr>
  </mtable>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <apply>
      <list>
       <ci>𝝀</ci>
       <ci>γ</ci>
      </list>
      <max></max>
     </apply>
     <ci>γ</ci>
    </matrixrow>
    <matrixrow>
     <mtext>sb.t.</mtext>
     <apply>
      <csymbol cd="ambiguous">formulae-sequence</csymbol>
      <apply>
       <leq></leq>
       <apply>
        <plus></plus>
        <apply>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <sum></sum>
           <apply>
            <eq></eq>
            <ci>n</ci>
            <cn type="integer">1</cn>
           </apply>
          </apply>
          <ci>normal-ℓ</ci>
         </apply>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>y</ci>
           <ci>n</ci>
          </apply>
          <ci>h</ci>
          <list>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>𝒙</ci>
            <ci>n</ci>
           </apply>
           <ci>ω</ci>
          </list>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>λ</ci>
           <ci>n</ci>
          </apply>
         </apply>
        </apply>
        <ci>γ</ci>
       </apply>
       <cn type="integer">0</cn>
      </apply>
      <apply>
       <in></in>
       <ci>ω</ci>
       <ci>normal-Ω</ci>
      </apply>
     </apply>
    </matrixrow>
    <matrixrow>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <apply>
      <csymbol cd="ambiguous">formulae-sequence</csymbol>
      <apply>
       <and></and>
       <apply>
        <leq></leq>
        <cn type="integer">0</cn>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>λ</ci>
         <ci>n</ci>
        </apply>
       </apply>
       <apply>
        <leq></leq>
        <share href="#.cmml">
        </share>
        <ci>D</ci>
       </apply>
      </apply>
      <apply>
       <eq></eq>
       <ci>n</ci>
       <list>
        <cn type="integer">1</cn>
        <ci>normal-…</ci>
        <ci>normal-ℓ</ci>
       </list>
      </apply>
     </apply>
    </matrixrow>
    <matrixrow>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <apply>
      <eq></eq>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <ci>n</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>normal-ℓ</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>λ</ci>
        <ci>n</ci>
       </apply>
      </apply>
      <cn type="integer">1</cn>
     </apply>
    </matrixrow>
    <matrixrow>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <apply>
      <in></in>
      <ci>γ</ci>
      <ci>ℝ</ci>
     </apply>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{array}[]{cl}\underset{\boldsymbol{\lambda},\gamma}{\max}&\gamma\\
\textrm{sb.t.}&\sum_{n=1}^{\ell}y_{n}h(\boldsymbol{x}_{n};\omega)\lambda_{n}+%
\gamma\leq 0,\qquad\omega\in\Omega,\\
&0\leq\lambda_{n}\leq D,\qquad n=1,\dots,\ell,\\
&\sum_{n=1}^{\ell}\lambda_{n}=1,\\
&\gamma\in\mathbb{R}.\end{array}
  </annotation>
 </semantics>
</math>

</p>

<p>For <a href="linear_program" title="wikilink">linear programs</a> the optimal value of the primal and <a href="dual_problem" title="wikilink">dual problem</a> are equal. For the above primal and dual problems, the optimal value is equal to the negative 'soft margin'. The soft margin is the size of the margin separating positive from negative training instances minus positive slack variables that carry penalties for margin-violating samples. Thus, the soft margin may be positive although not all samples are linearly separated by the classification function. The latter is called the 'hard margin' or 'realized margin'.</p>
<h4 id="convergence-criterion">Convergence criterion</h4>

<p>Consider a subset of the satisfied constraints in the dual problem. For any finite subset we can solve the linear program and thus satisfy all constraints. If we could prove that of all the constraints which we did not add to the dual problem no single constraint is violated, we would have proven that solving our restricted problem is equivalent to solving the original problem. More formally, let 

<math display="inline" id="LPBoost:20">
 <semantics>
  <msup>
   <mi>γ</mi>
   <mo>*</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>γ</ci>
    <times></times>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gamma^{*}
  </annotation>
 </semantics>
</math>

 be the optimal objective function value for any restricted instance. Then, we can formulate a search problem for the 'most violated constraint' in the original problem space, namely finding 

<math display="inline" id="LPBoost:21">
 <semantics>
  <mrow>
   <msup>
    <mi>ω</mi>
    <mo>*</mo>
   </msup>
   <mo>∈</mo>
   <mi mathvariant="normal">Ω</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ω</ci>
     <times></times>
    </apply>
    <ci>normal-Ω</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \omega^{*}\in\Omega
  </annotation>
 </semantics>
</math>

 as</p>

<p>

<math display="block" id="LPBoost:22">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>ω</mi>
     <mo>*</mo>
    </msup>
    <mo>=</mo>
    <mrow>
     <munder accentunder="true">
      <mtext>argmax</mtext>
      <mrow>
       <mi>ω</mi>
       <mo>∈</mo>
       <mi mathvariant="normal">Ω</mi>
      </mrow>
     </munder>
     <mrow>
      <munderover>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mrow>
        <mi>n</mi>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <mi mathvariant="normal">ℓ</mi>
      </munderover>
      <mrow>
       <msub>
        <mi>y</mi>
        <mi>n</mi>
       </msub>
       <mi>h</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>𝒙</mi>
         <mi>n</mi>
        </msub>
        <mo>;</mo>
        <mi>ω</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <msub>
        <mi>λ</mi>
        <mi>n</mi>
       </msub>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ω</ci>
     <times></times>
    </apply>
    <apply>
     <times></times>
     <apply>
      <apply>
       <in></in>
       <ci>ω</ci>
       <ci>normal-Ω</ci>
      </apply>
      <mtext>argmax</mtext>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>n</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>normal-ℓ</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <ci>n</ci>
       </apply>
       <ci>h</ci>
       <list>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>𝒙</ci>
         <ci>n</ci>
        </apply>
        <ci>ω</ci>
       </list>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>λ</ci>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \omega^{*}=\underset{\omega\in\Omega}{\textrm{argmax}}\sum_{n=1}^{\ell}y_{n}h(%
\boldsymbol{x}_{n};\omega)\lambda_{n}.
  </annotation>
 </semantics>
</math>

</p>

<p>That is, we search the space 

<math display="inline" id="LPBoost:23">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ℋ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℋ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{H}
  </annotation>
 </semantics>
</math>

 for a single <a href="decision_stump" title="wikilink">decision stump</a> 

<math display="inline" id="LPBoost:24">
 <semantics>
  <mrow>
   <mi>h</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>⋅</mo>
    <mo>;</mo>
    <msup>
     <mi>ω</mi>
     <mo>*</mo>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>h</ci>
    <list>
     <ci>normal-⋅</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ω</ci>
      <times></times>
     </apply>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h(\cdot;\omega^{*})
  </annotation>
 </semantics>
</math>

 maximizing the left hand side of the dual constraint. If the constraint cannot be violated by any choice of decision stump, none of the corresponding constraint can be active in the original problem and the restricted problem is equivalent.</p>
<h4 id="penalization-constant-d">Penalization constant 

<math display="inline" id="LPBoost:25">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>

</h4>

<p>The positive value of penalization constant 

<math display="inline" id="LPBoost:26">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>

 has to be found using <a href="model_selection" title="wikilink">model selection</a> techniques. However, if we choose 

<math display="inline" id="LPBoost:27">
 <semantics>
  <mrow>
   <mi>D</mi>
   <mo>=</mo>
   <mfrac>
    <mn>1</mn>
    <mrow>
     <mi mathvariant="normal">ℓ</mi>
     <mi>ν</mi>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>D</ci>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <apply>
      <times></times>
      <ci>normal-ℓ</ci>
      <ci>ν</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D=\frac{1}{\ell\nu}
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="LPBoost:28">
 <semantics>
  <mi mathvariant="normal">ℓ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-ℓ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ell
  </annotation>
 </semantics>
</math>

 is the number of training samples and 

<math display="inline" id="LPBoost:29">
 <semantics>
  <mrow>
   <mn>0</mn>
   <mo><</mo>
   <mi>ν</mi>
   <mo><</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <lt></lt>
     <cn type="integer">0</cn>
     <ci>ν</ci>
    </apply>
    <apply>
     <lt></lt>
     <share href="#.cmml">
     </share>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0<\nu<1
  </annotation>
 </semantics>
</math>

, then the new parameter 

<math display="inline" id="LPBoost:30">
 <semantics>
  <mi>ν</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ν</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \nu
  </annotation>
 </semantics>
</math>

 has the following properties.</p>
<ul>
<li>

<math display="inline" id="LPBoost:31">
 <semantics>
  <mi>ν</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ν</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \nu
  </annotation>
 </semantics>
</math>

 is an upper bound on the fraction of training errors; that is, if 

<math display="inline" id="LPBoost:32">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 denotes the number of misclassified training samples, then 

<math display="inline" id="LPBoost:33">
 <semantics>
  <mrow>
   <mfrac>
    <mi>k</mi>
    <mi mathvariant="normal">ℓ</mi>
   </mfrac>
   <mo>≤</mo>
   <mi>ν</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <divide></divide>
     <ci>k</ci>
     <ci>normal-ℓ</ci>
    </apply>
    <ci>ν</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{k}{\ell}\leq\nu
  </annotation>
 </semantics>
</math>

.</li>
<li>

<math display="inline" id="LPBoost:34">
 <semantics>
  <mi>ν</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ν</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \nu
  </annotation>
 </semantics>
</math>

 is a lower bound on the fraction of training samples outside or on the margin.</li>
</ul>
<h2 id="algorithm">Algorithm</h2>
<ul>
<li>Input:
<ul>
<li>Training set 

<math display="inline" id="LPBoost:35">
 <semantics>
  <mrow>
   <mi>X</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <msub>
     <mi>𝒙</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>𝒙</mi>
     <mi mathvariant="normal">ℓ</mi>
    </msub>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>X</ci>
    <set>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝒙</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝒙</ci>
      <ci>normal-ℓ</ci>
     </apply>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X=\{\boldsymbol{x}_{1},\dots,\boldsymbol{x}_{\ell}\}
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="LPBoost:36">
 <semantics>
  <mrow>
   <msub>
    <mi>𝒙</mi>
    <mi>i</mi>
   </msub>
   <mo>∈</mo>
   <mi class="ltx_font_mathcaligraphic">𝒳</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝒙</ci>
     <ci>i</ci>
    </apply>
    <ci>𝒳</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \boldsymbol{x}_{i}\in\mathcal{X}
  </annotation>
 </semantics>
</math>

</li>
<li>Training labels 

<math display="inline" id="LPBoost:37">
 <semantics>
  <mrow>
   <mi>Y</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <msub>
     <mi>y</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>y</mi>
     <mi mathvariant="normal">ℓ</mi>
    </msub>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>Y</ci>
    <set>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <ci>normal-ℓ</ci>
     </apply>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y=\{y_{1},\dots,y_{\ell}\}
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="LPBoost:38">
 <semantics>
  <mrow>
   <msub>
    <mi>y</mi>
    <mi>i</mi>
   </msub>
   <mo>∈</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
    <mo>,</mo>
    <mn>1</mn>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <ci>i</ci>
    </apply>
    <set>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
     <cn type="integer">1</cn>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{i}\in\{-1,1\}
  </annotation>
 </semantics>
</math>

</li>
<li>Convergence threshold 

<math display="inline" id="LPBoost:39">
 <semantics>
  <mrow>
   <mi>θ</mi>
   <mo>≥</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <ci>θ</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta\geq 0
  </annotation>
 </semantics>
</math>

</li>
</ul></li>
<li>Output:
<ul>
<li>Classification function 

<math display="inline" id="LPBoost:40">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mo>:</mo>
   <mrow>
    <mi class="ltx_font_mathcaligraphic">𝒳</mi>
    <mo>→</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
     <mo>,</mo>
     <mn>1</mn>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>f</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>𝒳</ci>
     <set>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
      <cn type="integer">1</cn>
     </set>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f:\mathcal{X}\to\{-1,1\}
  </annotation>
 </semantics>
</math>

</li>
</ul></li>
</ul>
<ol>
<li>Initialization
<ol>
<li>Weights, uniform 

<math display="inline" id="LPBoost:41">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>λ</mi>
     <mi>n</mi>
    </msub>
    <mo>←</mo>
    <mfrac>
     <mn>1</mn>
     <mi mathvariant="normal">ℓ</mi>
    </mfrac>
   </mrow>
   <mo rspace="12.5pt">,</mo>
   <mrow>
    <mi>n</mi>
    <mo>=</mo>
    <mrow>
     <mn>1</mn>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <mi mathvariant="normal">ℓ</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <ci>normal-←</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>λ</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <ci>normal-ℓ</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <ci>n</ci>
     <list>
      <cn type="integer">1</cn>
      <ci>normal-…</ci>
      <ci>normal-ℓ</ci>
     </list>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda_{n}\leftarrow\frac{1}{\ell},\quad n=1,\dots,\ell
  </annotation>
 </semantics>
</math>

</li>
<li>Edge 

<math display="inline" id="LPBoost:42">
 <semantics>
  <mrow>
   <mi>γ</mi>
   <mo>←</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-←</ci>
    <ci>γ</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gamma\leftarrow 0
  </annotation>
 </semantics>
</math>

</li>
<li>Hypothesis count 

<math display="inline" id="LPBoost:43">
 <semantics>
  <mrow>
   <mi>J</mi>
   <mo>←</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-←</ci>
    <ci>J</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   J\leftarrow 1
  </annotation>
 </semantics>
</math>

</li>
</ol></li>
<li>Iterate
<ol>
<li>

<math display="inline" id="LPBoost:44">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>h</mi>
    <mo stretchy="false">^</mo>
   </mover>
   <mo>←</mo>
   <mrow>
    <munder accentunder="true">
     <mtext>argmax</mtext>
     <mrow>
      <mi>ω</mi>
      <mo>∈</mo>
      <mi mathvariant="normal">Ω</mi>
     </mrow>
    </munder>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <mi>n</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi mathvariant="normal">ℓ</mi>
     </msubsup>
     <mrow>
      <msub>
       <mi>y</mi>
       <mi>n</mi>
      </msub>
      <mi>h</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>𝒙</mi>
        <mi>n</mi>
       </msub>
       <mo>;</mo>
       <mi>ω</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <msub>
       <mi>λ</mi>
       <mi>n</mi>
      </msub>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-←</ci>
    <apply>
     <ci>normal-^</ci>
     <ci>h</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <apply>
       <in></in>
       <ci>ω</ci>
       <ci>normal-Ω</ci>
      </apply>
      <mtext>argmax</mtext>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>n</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>normal-ℓ</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <ci>n</ci>
       </apply>
       <ci>h</ci>
       <list>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>𝒙</ci>
         <ci>n</ci>
        </apply>
        <ci>ω</ci>
       </list>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>λ</ci>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{h}\leftarrow\underset{\omega\in\Omega}{\textrm{argmax}}\sum_{n=1}^{\ell}y%
_{n}h(\boldsymbol{x}_{n};\omega)\lambda_{n}
  </annotation>
 </semantics>
</math>

</li>
<li>if 

<math display="inline" id="LPBoost:45">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <mi>n</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi mathvariant="normal">ℓ</mi>
     </msubsup>
     <mrow>
      <msub>
       <mi>y</mi>
       <mi>n</mi>
      </msub>
      <mover accent="true">
       <mi>h</mi>
       <mo stretchy="false">^</mo>
      </mover>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>𝒙</mi>
        <mi>n</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
      <msub>
       <mi>λ</mi>
       <mi>n</mi>
      </msub>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mi>γ</mi>
   </mrow>
   <mo>≤</mo>
   <mi>θ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <plus></plus>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>n</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>normal-ℓ</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <ci>n</ci>
       </apply>
       <apply>
        <ci>normal-^</ci>
        <ci>h</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>𝒙</ci>
        <ci>n</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>λ</ci>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
     <ci>γ</ci>
    </apply>
    <ci>θ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{n=1}^{\ell}y_{n}\hat{h}(\boldsymbol{x}_{n})\lambda_{n}+\gamma\leq\theta
  </annotation>
 </semantics>
</math>

 then
<ol>
<li>break</li>
</ol></li>
<li>

<math display="inline" id="LPBoost:46">
 <semantics>
  <mrow>
   <msub>
    <mi>h</mi>
    <mi>J</mi>
   </msub>
   <mo>←</mo>
   <mover accent="true">
    <mi>h</mi>
    <mo stretchy="false">^</mo>
   </mover>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-←</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>h</ci>
     <ci>J</ci>
    </apply>
    <apply>
     <ci>normal-^</ci>
     <ci>h</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h_{J}\leftarrow\hat{h}
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="LPBoost:47">
 <semantics>
  <mrow>
   <mi>J</mi>
   <mo>←</mo>
   <mrow>
    <mi>J</mi>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-←</ci>
    <ci>J</ci>
    <apply>
     <plus></plus>
     <ci>J</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   J\leftarrow J+1
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="LPBoost:48">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>𝝀</mi>
    <mo>,</mo>
    <mi>γ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>←</mo>
   <mi></mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-←</ci>
    <interval closure="open">
     <ci>𝝀</ci>
     <ci>γ</ci>
    </interval>
    <csymbol cd="latexml">absent</csymbol>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\boldsymbol{\lambda},\gamma)\leftarrow
  </annotation>
 </semantics>
</math>

 solution of the LPBoost dual</li>
<li>

<math display="inline" id="LPBoost:49">
 <semantics>
  <mrow>
   <mi>𝜶</mi>
   <mo>←</mo>
   <mi></mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-←</ci>
    <ci>𝜶</ci>
    <csymbol cd="latexml">absent</csymbol>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \boldsymbol{\alpha}\leftarrow
  </annotation>
 </semantics>
</math>

 Lagrangian multipliers of solution to LPBoost dual problem</li>
</ol></li>
<li>

<math display="inline" id="LPBoost:50">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>𝒙</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>:=</mo>
   <mrow>
    <mtext>sign</mtext>
    <mrow>
     <mo>(</mo>
     <mrow>
      <msubsup>
       <mo largeop="true" symmetric="true">∑</mo>
       <mrow>
        <mi>j</mi>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <mi>J</mi>
      </msubsup>
      <mrow>
       <msub>
        <mi>α</mi>
        <mi>j</mi>
       </msub>
       <msub>
        <mi>h</mi>
        <mi>j</mi>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>𝒙</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo>)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>𝒙</ci>
    </apply>
    <apply>
     <times></times>
     <mtext>sign</mtext>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>j</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>J</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>α</ci>
        <ci>j</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>h</ci>
        <ci>j</ci>
       </apply>
       <ci>𝒙</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(\boldsymbol{x}):=\textrm{sign}\left(\sum_{j=1}^{J}\alpha_{j}h_{j}(%
\boldsymbol{x})\right)
  </annotation>
 </semantics>
</math>

</li>
</ol>

<p>Note that if the convergence threshold is set to 

<math display="inline" id="LPBoost:51">
 <semantics>
  <mrow>
   <mi>θ</mi>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>θ</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta=0
  </annotation>
 </semantics>
</math>

 the solution obtained is the global optimal solution of the above linear program. In practice, 

<math display="inline" id="LPBoost:52">
 <semantics>
  <mi>θ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>θ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta
  </annotation>
 </semantics>
</math>

 is set to a small positive value in order obtain a good solution quickly.</p>
<h3 id="realized-margin">Realized margin</h3>

<p>The actual margin separating the training samples is termed the <em>realized margin</em> and is defined as</p>

<p>

<math display="block" id="LPBoost:53">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>ρ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>𝜶</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>:=</mo>
    <mrow>
     <mrow>
      <munder>
       <mi>min</mi>
       <mrow>
        <mi>n</mi>
        <mo>=</mo>
        <mrow>
         <mn>1</mn>
         <mo>,</mo>
         <mi mathvariant="normal">…</mi>
         <mo>,</mo>
         <mi mathvariant="normal">ℓ</mi>
        </mrow>
       </mrow>
      </munder>
      <msub>
       <mi>y</mi>
       <mi>n</mi>
      </msub>
     </mrow>
     <mrow>
      <munder>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mrow>
        <msub>
         <mi>α</mi>
         <mi>ω</mi>
        </msub>
        <mo>∈</mo>
        <mi mathvariant="normal">Ω</mi>
       </mrow>
      </munder>
      <mrow>
       <msub>
        <mi>α</mi>
        <mi>ω</mi>
       </msub>
       <mi>h</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>𝒙</mi>
         <mi>n</mi>
        </msub>
        <mo>;</mo>
        <mi>ω</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <apply>
     <times></times>
     <ci>ρ</ci>
     <ci>𝜶</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <min></min>
       <apply>
        <eq></eq>
        <ci>n</ci>
        <list>
         <cn type="integer">1</cn>
         <ci>normal-…</ci>
         <ci>normal-ℓ</ci>
        </list>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <ci>n</ci>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <in></in>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>α</ci>
         <ci>ω</ci>
        </apply>
        <ci>normal-Ω</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>α</ci>
        <ci>ω</ci>
       </apply>
       <ci>h</ci>
       <list>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>𝒙</ci>
         <ci>n</ci>
        </apply>
        <ci>ω</ci>
       </list>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho(\boldsymbol{\alpha}):=\min_{n=1,\dots,\ell}y_{n}\sum_{\alpha_{\omega}\in%
\Omega}\alpha_{\omega}h(\boldsymbol{x}_{n};\omega).
  </annotation>
 </semantics>
</math>

</p>

<p>The realized margin can and will usually be negative in the first iterations. For a hypothesis space that permits singling out of any single sample, as is commonly the case, the realized margin will eventually converge to some positive value.</p>
<h3 id="convergence-guarantee">Convergence guarantee</h3>

<p>While the above algorithm is proven to converge, in contrast to other boosting formulations, such as <a class="uri" href="AdaBoost" title="wikilink">AdaBoost</a> and <a class="uri" href="TotalBoost" title="wikilink">TotalBoost</a>, there are no known convergence bounds for LPBoost. In practise however, LPBoost is known to converge quickly, often faster than other formulations.</p>
<h2 id="base-learners">Base learners</h2>

<p>LPBoost is an <a href="ensemble_learning" title="wikilink">ensemble learning</a> method and thus does not dictate the choice of base learners, the space of hypotheses 

<math display="inline" id="LPBoost:54">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ℋ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℋ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{H}
  </annotation>
 </semantics>
</math>

. Demiriz et al. showed that under mild assumptions, any base learner can be used. If the base learners are particularly simple, they are often referred to as <em><a href="decision_stump" title="wikilink">decision stumps</a></em>.</p>

<p>The number of base learners commonly used with Boosting in the literature is large. For example, if 

<math display="inline" id="LPBoost:55">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">𝒳</mi>
   <mo>⊆</mo>
   <msup>
    <mi>ℝ</mi>
    <mi>n</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <ci>𝒳</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ℝ</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{X}\subseteq{\mathbb{R}}^{n}
  </annotation>
 </semantics>
</math>

, a base learner could be a linear soft margin <a href="support_vector_machine" title="wikilink">support vector machine</a>. Or even more simple, a simple stump of the form</p>

<p>

<math display="block" id="LPBoost:56">
 <semantics>
  <mrow>
   <mi>h</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>𝒙</mi>
    <mo>;</mo>
    <mi>ω</mi>
    <mo>∈</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mn>1</mn>
     <mo>,</mo>
     <mo>-</mo>
     <mn>1</mn>
     <mo stretchy="false">}</mo>
    </mrow>
    <mo>,</mo>
    <mi>p</mi>
    <mo>∈</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mn>1</mn>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <mi>n</mi>
     <mo stretchy="false">}</mo>
    </mrow>
    <mo>,</mo>
    <mi>t</mi>
    <mo>∈</mo>
    <mi>ℝ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>:=</mo>
   <mrow>
    <mo>{</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="center">
       <mi>ω</mi>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mtext>if</mtext>
         <msub>
          <mi>𝒙</mi>
          <mi>p</mi>
         </msub>
        </mrow>
        <mo>≤</mo>
        <mi>t</mi>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <mo>-</mo>
        <mi>ω</mi>
       </mrow>
      </mtd>
      <mtd columnalign="left">
       <mtext>otherwise</mtext>
      </mtd>
     </mtr>
    </mtable>
    <mo>.</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">h</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-;</ci>
     <csymbol cd="unknown">ω</csymbol>
     <in></in>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-{</ci>
      <cn type="integer">1</cn>
      <ci>normal-,</ci>
      <minus></minus>
      <cn type="integer">1</cn>
      <ci>normal-}</ci>
     </cerror>
     <ci>normal-,</ci>
     <csymbol cd="unknown">p</csymbol>
     <in></in>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-{</ci>
      <cn type="integer">1</cn>
      <ci>normal-,</ci>
      <ci>normal-…</ci>
      <ci>normal-,</ci>
      <csymbol cd="unknown">n</csymbol>
      <ci>normal-}</ci>
     </cerror>
     <ci>normal-,</ci>
     <csymbol cd="unknown">t</csymbol>
     <in></in>
     <csymbol cd="unknown">R</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="latexml">assign</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-{</ci>
     <matrix>
      <matrixrow>
       <ci>ω</ci>
       <apply>
        <leq></leq>
        <apply>
         <times></times>
         <mtext>if</mtext>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>𝒙</ci>
          <ci>p</ci>
         </apply>
        </apply>
        <ci>t</ci>
       </apply>
      </matrixrow>
      <matrixrow>
       <apply>
        <minus></minus>
        <ci>ω</ci>
       </apply>
       <mtext>otherwise</mtext>
      </matrixrow>
     </matrix>
     <ci>normal-.</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h(\boldsymbol{x};\omega\in\{1,-1\},p\in\{1,\dots,n\},t\in{\mathbb{R}}):=\left%
\{\begin{array}[]{cl}\omega&\textrm{if~{}}\boldsymbol{x}_{p}\leq t\\
-\omega&\textrm{otherwise}\end{array}\right..
  </annotation>
 </semantics>
</math>

</p>

<p>The above decision stumps looks only along a single dimension 

<math display="inline" id="LPBoost:57">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 of the input space and simply thresholds the respective column of the sample using a constant threshold 

<math display="inline" id="LPBoost:58">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

. Then, it can decide in either direction, depending on 

<math display="inline" id="LPBoost:59">
 <semantics>
  <mi>ω</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ω</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \omega
  </annotation>
 </semantics>
</math>

 for a positive or negative class.</p>

<p>Given weights for the training samples, constructing the optimal decision stump of the above form simply involves searching along all sample columns and determining 

<math display="inline" id="LPBoost:60">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="LPBoost:61">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="LPBoost:62">
 <semantics>
  <mi>ω</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ω</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \omega
  </annotation>
 </semantics>
</math>

 in order to optimize the gain function.</p>
<h2 id="references">References</h2>
<ul>
<li><a href="http://www.boosting.org/papers/upload_27160_mlj.ps.gz">Linear Programming Boosting via Column Generation</a>, A. Demiriz and K.P. Bennett and J. Shawe-Taylor. Published 2002 in Kluwer Machine Learning 46, pages 225–254.</li>
</ul>

<p>"</p>

<p><a href="Category:Ensemble_learning" title="wikilink">Category:Ensemble learning</a></p>
</body>
</html>
