<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1899">Two's complement</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Two's complement</h1>
<style>
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
<style>
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
</body></html>
<body>
<hr/>

<p><strong>Two's complement</strong> is a <a href="mathematical_operation" title="wikilink">mathematical operation</a> on <a href="binary_number" title="wikilink">binary numbers</a>, as well as a binary <a href="signed_number_representation" title="wikilink">signed number representation</a> based on this operation. Its wide use in computing makes it the most important example of a <a href="Method_of_complements" title="wikilink">radix complement</a>.</p>

<p>The two's complement of an 

<math display="inline" id="Two's_complement:0">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

-bit number is defined as the <a href="method_of_complements" title="wikilink">complement</a> with respect to <mtpl></mtpl>; in other words, it is the result of subtracting the number from <mtpl></mtpl>, which in binary is one followed by 

<math display="inline" id="Two's_complement:1">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

 zeroes. This is also equivalent to taking the <a href="ones'_complement" title="wikilink">ones' complement</a> and then adding one, since the sum of a number and its ones' complement is all 1 bits. The two's complement of a number behaves like the <a href="additive_inverse" title="wikilink">negative</a> of the original number in most arithmetic, and positive and negative numbers can coexist in a natural way.</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>Three-bit two's-complement integers</p></td>
<td style="text-align: left;">
<p>Bits</p></td>
<td style="text-align: left;">
<p>Unsigned<br/>
value</p></td>
<td style="text-align: left;">
<p>Two's<br/>
complement<br/>
value</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>011</p></td>
<td style="text-align: left;">
<p>3 </p></td>
<td style="text-align: left;">
<p>3 </p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>010</p></td>
<td style="text-align: left;">
<p>2 </p></td>
<td style="text-align: left;">
<p>2 </p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>001</p></td>
<td style="text-align: left;">
<p>1 </p></td>
<td style="text-align: left;">
<p>1 </p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>000</p></td>
<td style="text-align: left;">
<p>0 </p></td>
<td style="text-align: left;">
<p>0 </p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>111</p></td>
<td style="text-align: left;">
<p>7 </p></td>
<td style="text-align: left;">
<p>-1 </p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>110</p></td>
<td style="text-align: left;">
<p>6 </p></td>
<td style="text-align: left;">
<p>-2 </p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>101</p></td>
<td style="text-align: left;">
<p>5 </p></td>
<td style="text-align: left;">
<p>-3 </p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>100</p></td>
<td style="text-align: left;">
<p>4 </p></td>
<td style="text-align: left;">
<p>-4 </p></td>
</tr>
<tr class="even">
</tr>
</tbody>
</table>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>Eight-bit two's-complement integers</p></td>
<td style="text-align: left;">
<p>Bits</p></td>
<td style="text-align: left;">
<p>Unsigned<br/>
value</p></td>
<td style="text-align: left;">
<p>Two's<br/>
complement<br/>
value</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>0111 1111</p></td>
<td style="text-align: left;">
<p>127 </p></td>
<td style="text-align: left;">
<p>127 </p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>0111 1110</p></td>
<td style="text-align: left;">
<p>126 </p></td>
<td style="text-align: left;">
<p>126 </p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>0000 0010</p></td>
<td style="text-align: left;">
<p>2 </p></td>
<td style="text-align: left;">
<p>2 </p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>0000 0001</p></td>
<td style="text-align: left;">
<p>1 </p></td>
<td style="text-align: left;">
<p>1 </p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>0000 0000</p></td>
<td style="text-align: left;">
<p>0 </p></td>
<td style="text-align: left;">
<p>0 </p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>1111 1111</p></td>
<td style="text-align: left;">
<p>255 </p></td>
<td style="text-align: left;">
<p>−1 </p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>1111 1110</p></td>
<td style="text-align: left;">
<p>254 </p></td>
<td style="text-align: left;">
<p>−2 </p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>1000 0010</p></td>
<td style="text-align: left;">
<p>130 </p></td>
<td style="text-align: left;">
<p>−126 </p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>1000 0001</p></td>
<td style="text-align: left;">
<p>129 </p></td>
<td style="text-align: left;">
<p>−127 </p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>1000 0000</p></td>
<td style="text-align: left;">
<p>128 </p></td>
<td style="text-align: left;">
<p>−128 </p></td>
</tr>
<tr class="even">
</tr>
</tbody>
</table>

<p>In two's-complement representation, positive numbers are simply represented as themselves, and negative numbers are represented by the two's complement of their absolute value;<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> two tables on the right provide examples for 

<math display="inline" id="Two's_complement:2">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

 = 3 and 

<math display="inline" id="Two's_complement:3">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

 = 8. In general, negation (reversing the sign) is performed by taking the two's complement. This system is the most common method of representing signed integers on <a href="computer" title="wikilink">computers</a>.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> An 

<math display="inline" id="Two's_complement:4">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

-bit two's-complement numeral system can represent every integer in the range <mtpl></mtpl> to <mtpl></mtpl> while <a href="ones'_complement" title="wikilink">ones' complement</a> can only represent integers in the range <mtpl></mtpl> to <mtpl></mtpl>.</p>

<p>The two's-complement system has the advantage that the fundamental arithmetic operations of <a class="uri" href="addition" title="wikilink">addition</a>, <a class="uri" href="subtraction" title="wikilink">subtraction</a>, and <a class="uri" href="multiplication" title="wikilink">multiplication</a> are identical to those for unsigned binary numbers (as long as the inputs are represented in the same number of bits and any <a href="arithmetic_overflow" title="wikilink">overflow</a> beyond those bits is discarded from the result). This property makes the system both simpler to implement and capable of easily handling higher precision arithmetic. Also, <a class="uri" href="zero" title="wikilink">zero</a> has only a single representation, obviating the subtleties associated with <a href="negative_zero" title="wikilink">negative zero</a>, which exists in <a href="ones'_complement" title="wikilink">ones'-complement systems</a>.</p>
<h2 id="history">History</h2>

<p>The <a href="method_of_complements" title="wikilink">method of complements</a> had long been used to perform subtraction in decimal <a href="adding_machine" title="wikilink">adding machines</a> and <a href="mechanical_calculator" title="wikilink">mechanical calculators</a>. <a href="John_von_Neumann" title="wikilink">John von Neumann</a> suggested use of two's complement binary representation in his 1945 <em><a href="First_Draft_of_a_Report_on_the_EDVAC" title="wikilink">First Draft of a Report on the EDVAC</a></em> proposal for an electronic stored-program digital computer.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> The 1949 <a class="uri" href="EDSAC" title="wikilink">EDSAC</a>, which was inspired by the <em>First Draft</em>, used two's complement representation of binary numbers.</p>

<p>Many early computers, including the <a href="CDC_6600" title="wikilink">CDC 6600</a>, use <a href="ones'_complement" title="wikilink">ones' complement</a> notation. The <a href="IBM_700/7000_series" title="wikilink">IBM 700/7000 series</a> scientific machines use sign/magnitude notation, except for the index registers which are two's complement. Early commercial two's complement computers include the <a href="Digital_Equipment_Corporation" title="wikilink">Digital Equipment Corporation</a> PDP-5 and the 1963 <a class="uri" href="PDP-6" title="wikilink">PDP-6</a>. The <a href="IBM_System/360" title="wikilink">System/360</a>, introduced in 1964 by <a class="uri" href="IBM" title="wikilink">IBM</a>, then the dominant player in the computer industry, made two's complement the most widely used binary representation in the computer industry. The first minicomputer, the <a class="uri" href="PDP-8" title="wikilink">PDP-8</a> introduced in 1965, uses two's complement arithmetic as do the 1969 <a href="Data_General_Nova" title="wikilink">Data General Nova</a>, the 1970 <a class="uri" href="PDP-11" title="wikilink">PDP-11</a>, and almost all subsequent minicomputers and microcomputers.</p>
<h2 id="potential-ambiguities-of-terminology">Potential ambiguities of terminology</h2>

<p>The term <em>two's complement</em> can mean either a number format or a mathematical operator. For example, 0111 represents decimal 7 in two's-complement <em>notation</em>, but the two's complement of 7 in a <a href="nibble" title="wikilink">4-bit register</a> is actually the "1001" <a href="bit_string" title="wikilink">bit string</a> (the same as represents <mtpl></mtpl> in unsigned arithmetics) which is the two's complement <em>representation</em> of −7. The statement "convert 

<math display="inline" id="Two's_complement:5">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 to two's complement" may be ambiguous, since it could describe either the process of representing 

<math display="inline" id="Two's_complement:6">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 in two's-complement notation without changing its value, or the calculation of the two's complement, which is the <a href="additive_inverse" title="wikilink">arithmetic negative</a> of 

<math display="inline" id="Two's_complement:7">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 if two's complement representation is used.</p>
<h2 id="converting-from-twos-complement-representation">Converting from two's complement representation</h2>

<p>A two's-complement number system encodes positive and negative numbers in a binary number representation. The weight of each bit is a power of two, except for the <a href="most_significant_bit" title="wikilink">most significant bit</a>, whose weight is the negative of the corresponding power of two.</p>

<p>The value 

<math display="inline" id="Two's_complement:8">
 <semantics>
  <mi>w</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>w</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w
  </annotation>
 </semantics>
</math>

 of an 

<math display="inline" id="Two's_complement:9">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

-bit integer 

<math display="inline" id="Two's_complement:10">
 <semantics>
  <mrow>
   <msub>
    <mi>a</mi>
    <mrow>
     <mi>N</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <msub>
    <mi>a</mi>
    <mrow>
     <mi>N</mi>
     <mo>-</mo>
     <mn>2</mn>
    </mrow>
   </msub>
   <mi mathvariant="normal">…</mi>
   <msub>
    <mi>a</mi>
    <mn>0</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <apply>
      <minus></minus>
      <ci>N</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <apply>
      <minus></minus>
      <ci>N</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{N-1}a_{N-2}\dots a_{0}
  </annotation>
 </semantics>
</math>

 is given by the following formula:</p>

<p>

<math display="block" id="Two's_complement:11">
 <semantics>
  <mrow>
   <mi>w</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo>-</mo>
     <mrow>
      <msub>
       <mi>a</mi>
       <mrow>
        <mi>N</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msub>
      <msup>
       <mn>2</mn>
       <mrow>
        <mi>N</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msup>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>0</mn>
      </mrow>
      <mrow>
       <mi>N</mi>
       <mo>-</mo>
       <mn>2</mn>
      </mrow>
     </munderover>
     <mrow>
      <msub>
       <mi>a</mi>
       <mi>i</mi>
      </msub>
      <msup>
       <mn>2</mn>
       <mi>i</mi>
      </msup>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>w</ci>
    <apply>
     <plus></plus>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <apply>
         <minus></minus>
         <ci>N</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <cn type="integer">2</cn>
        <apply>
         <minus></minus>
         <ci>N</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">0</cn>
        </apply>
       </apply>
       <apply>
        <minus></minus>
        <ci>N</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <cn type="integer">2</cn>
        <ci>i</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w=-a_{N-1}2^{N-1}+\sum_{i=0}^{N-2}a_{i}2^{i}
  </annotation>
 </semantics>
</math>

 The most significant bit determines the sign of the number and is sometimes called the <a href="sign_bit" title="wikilink">sign bit</a>. Unlike in <a class="uri" href="sign-and-magnitude" title="wikilink">sign-and-magnitude</a> representation, the sign bit also has the weight <mtpl></mtpl> shown above. Using 

<math display="inline" id="Two's_complement:12">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

 bits, all integers from <mtpl></mtpl> to <mtpl></mtpl> can be represented.</p>
<h2 id="converting-to-twos-complement-representation">Converting to two's complement representation</h2>

<p>In two's complement notation, a <em>non-negative</em> number is represented by its ordinary <a href="Binary_numeral_system" title="wikilink">binary representation</a>; in this case, the most significant bit is 0. Though, the range of numbers represented is not the same as with unsigned binary numbers. For example, an 8-bit unsigned number can represent the values 0 to 255 (11111111). However a two's complement 8-bit number can only represent positive integers from 0 to 127 (01111111), because the rest of the bit combinations with the most significant bit as '1' represent the negative integers −1 to −128.</p>

<p>The two's complement operation is the <a href="additive_inverse" title="wikilink">additive inverse</a> operation, so negative numbers are represented by the two's complement of the <a href="absolute_value" title="wikilink">absolute value</a>.</p>
<h3 id="from-the-ones-complement">From the ones' complement</h3>

<p>To get the two's complement of a binary number, the <a href="bit" title="wikilink">bits</a> are inverted, or "flipped", by using the <a href="bitwise_NOT" title="wikilink">bitwise NOT</a> operation; the value of 1 is then added to the resulting value, ignoring the overflow which occurs when taking the two's complement of 0.</p>

<p>For example, using 1 byte (= 2 <a href="nibble" title="wikilink">nibbles</a> = 8 bits), the decimal number 5 is represented by</p>
<dl>
<dd>0000 0101<sub>2</sub>
</dd>
</dl>

<p>The most significant bit is 0, so the pattern represents a non-negative value. To convert to −5 in two's-complement notation, the bits are inverted; 0 becomes 1, and 1 becomes 0:</p>
<dl>
<dd>1111 1010
</dd>
</dl>

<p>At this point, the numeral is the <a href="ones'_complement" title="wikilink">ones' complement</a> of the decimal value −5. To obtain the two's complement, 1 is added to the result, giving:</p>
<dl>
<dd>1111 1011
</dd>
</dl>

<p>The result is a signed binary number representing the decimal value −5 in two's-complement form. The most significant bit is 1, so the value represented is negative.</p>

<p>The two's complement of a negative number is the corresponding positive value. For example, inverting the bits of −5 (above) gives:</p>
<dl>
<dd>0000 0100
</dd>
</dl>

<p>And adding one gives the final value:</p>
<dl>
<dd>0000 0101
</dd>
</dl>

<p>The two's complement of zero is zero: inverting gives all ones, and adding one changes the ones back to zeros (since the overflow is ignored). Furthermore, the two's complement of the most negative number representable (e.g. a one as the most-significant bit and all other bits zero) is itself. Hence, there appears to be an 'extra' negative number.</p>
<h3 id="subtraction-from-2n">Subtraction from 2<sup><em>N</em></sup></h3>

<p>The sum of a number and its ones' complement is an 

<math display="inline" id="Two's_complement:13">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

-bit word with all 1 bits, which is <mtpl></mtpl>. Then adding a number to its two's complement results in the 

<math display="inline" id="Two's_complement:14">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

 lowest bits set to 0 and the carry bit 1, where the latter has the weight <mtpl></mtpl>. Hence, in the unsigned binary arithmetic the value of two's-complement negative number 

<math display="inline" id="Two's_complement:15">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>*</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <times></times>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x*
  </annotation>
 </semantics>
</math>

 of a positive 

<math display="inline" id="Two's_complement:16">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 satisfies the equality <mtpl></mtpl>.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>

<p>For example, to find the 4-bit representation of −5 (subscripts denote the <a href="radix" title="wikilink">base of the representation</a>):</p>
<dl>
<dd><mtpl></mtpl> therefore <mtpl></mtpl>
</dd>
</dl>

<p>Hence, with 

<math display="inline" id="Two's_complement:17">
 <semantics>
  <mrow>
   <mi>N</mi>
   <mo>=</mo>
   <mn>4</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>N</ci>
    <cn type="integer">4</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N=4
  </annotation>
 </semantics>
</math>

:</p>
<dl>
<dd><mtpl></mtpl>
</dd>
</dl>

<p>The calculation can be done entirely in base 10, converting to base 2 at the end:</p>
<dl>
<dd><mtpl></mtpl>
</dd>
</dl>
<h3 id="working-from-lsb-towards-msb">Working from LSB towards MSB</h3>

<p>A shortcut to manually convert a <a href="binary_number" title="wikilink">binary number</a> into its two's complement is to start at the <a href="least_significant_bit" title="wikilink">least significant bit</a> (LSB), and copy all the zeros (working from LSB toward the most significant bit) until the first 1 is reached; then copy that 1, and flip all the remaining bits (Leave the MSB as a 1 if the initial number was in sign-and-magnitude representation). This shortcut allows a person to convert a number to its two's complement without first forming its ones' complement. For example: the two's complement of "0011 1100" is "1100 0<u>100</u>", where the underlined digits were unchanged by the copying operation (while the rest of the digits were flipped).</p>

<p>In computer circuitry, this method is no faster than the "complement and add one" method; both methods require working sequentially from right to left, propagating logic changes. The method of complementing and adding one can be sped up by a standard <a href="carry_look-ahead_adder" title="wikilink">carry look-ahead adder</a> circuit; the LSB towards MSB method can be sped up by a similar logic transformation.</p>
<h2 id="sign-extension">Sign extension</h2>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>Sign-bit repetition in 7- and 8-bit integers using two's complement</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Decimal</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>−42 </p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>42 </p></td>
</tr>
</tbody>
</table>

<p>When turning a two's-complement number with a certain number of bits into one with more bits (e.g., when copying from a 1 byte variable to a two byte variable), the most-significant bit must be repeated in all the extra bits. Some processors do this in a single instruction; on other processors, a conditional must be used followed by code to set the relevant bits or bytes.</p>

<p>Similarly, when a two's-complement number is shifted to the right, the most-significant bit, which contains magnitude and the sign information, must be maintained. However when shifted to the left, a 0 is shifted in. These rules preserve the common semantics that left shifts multiply the number by two and right shifts divide the number by two.</p>

<p>Both shifting and doubling the precision are important for some multiplication algorithms. Note that unlike addition and subtraction, precision extension and right shifting are done differently for signed vs unsigned numbers.</p>
<h2 id="most-negative-number">Most negative number</h2>

<p>With only one exception, starting with any number in two's-complement representation, if all the bits are flipped and 1 added, the two's-complement representation of the negative of that number is obtained. Positive 12 becomes negative 12, positive 5 becomes negative 5, zero becomes zero(+overflow), etc.</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>The two's complement of −128 results in the same 8-bit binary number.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>−128</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>invert bits</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>add one</p></td>
</tr>
<tr class="odd">
</tr>
</tbody>
</table>

<p>The two's complement of the minimum number in the range will not have the desired effect of negating the number. For example, the two's complement of −128 in an 8-bit system results in the same binary number. This is because a positive value of 128 cannot be represented with an 8-bit signed binary numeral.</p>

<p>This phenomenon is fundamentally about the mathematics of binary numbers, not the details of the representation as two's complement. Mathematically, this is complementary to the fact that the negative of 0 is again 0. For a given number of bits <em>k</em> there is an even number of binary numbers 2<sup><em>k</em></sup>, taking negatives is a <a href="group_action" title="wikilink">group action</a> (of the group of order 2) on binary numbers, and since the <a href="Orbit_(group_theory)" title="wikilink">orbit</a> of zero has order 1, at least one other number must have an orbit of order 1 for the orders of the orbits to add up to the order of the set. Thus some other number must be invariant under taking negatives (formally, by the <a href="orbit-stabilizer_theorem" title="wikilink">orbit-stabilizer theorem</a>). Geometrically, one can view the <em>k</em>-bit binary numbers as the <a href="cyclic_group" title="wikilink">cyclic group</a> 

<math display="inline" id="Two's_complement:18">
 <semantics>
  <mrow>
   <mi>𝐙</mi>
   <mo>/</mo>
   <msup>
    <mn>2</mn>
    <mi>k</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <ci>𝐙</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{Z}/2^{k}
  </annotation>
 </semantics>
</math>

, which can be visualized as a circle (or properly a regular 2<sup><em>k</em></sup>-gon), and taking negatives is a reflection, which fixes the elements of order dividing 2: 0 and the opposite point, or visually the zenith and nadir.</p>

<p>Note that this negative being the same number is detected as an overflow condition since there was a carry into but not out of the most-significant bit. This can lead to unexpected bugs in that an unchecked implementation of <a href="absolute_value" title="wikilink">absolute value</a> could return a negative number in the case of the minimum negative. The <em>abs</em> family of integer functions in <a href="C_(programming_language)" title="wikilink">C</a> typically has this behaviour. This is also true for Java.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> In this case it is for the developer to decide if there will be a check for the minimum negative value before the call of the function.</p>

<p>The most negative number in two's complement is sometimes called "the weird number," because it is the only exception.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a><a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>

<p>Although the number is an exception, it is a valid number in regular two's complement systems. All arithmetic operations work with it both as an operand and (unless there was an overflow) a result.</p>
<h2 id="why-it-works">Why it works</h2>

<p>Given a set of all possible 

<math display="inline" id="Two's_complement:19">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

-bit values, we can assign the lower (by the binary value) half to be the integers from 0 to <mtpl></mtpl> inclusive and the upper half to be <mtpl></mtpl> to −1 inclusive. The upper half (again, by the binary value) can be used to represent negative integers from <mtpl></mtpl> to −1 because, under addition modulo <mtpl></mtpl> they behave the same way as those negative integers. That is to say that because <mtpl></mtpl> any value in the set  can be used in place of 

<math display="inline" id="Two's_complement:20">
 <semantics>
  <mi>j</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>j</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   j
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></p>

<p>For example, with eight bits, the unsigned bytes are 0 to 255. Subtracting 256 from the top half (128 to 255) yields the signed bytes −128 to −1.</p>

<p>The relationship to two's complement is realised by noting that 

<math display="inline" id="Two's_complement:21">
 <semantics>
  <mrow>
   <mn>256</mn>
   <mo>=</mo>
   <mrow>
    <mn>255</mn>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <cn type="integer">256</cn>
    <apply>
     <plus></plus>
     <cn type="integer">255</cn>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   256=255+1
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="Two's_complement:22">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mn>255</mn>
    <mi mathvariant="normal">−</mi>
    <mi>x</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <cn type="integer">255</cn>
    <ci>normal-−</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (255−x)
  </annotation>
 </semantics>
</math>

 is the <a href="Signed_number_representations" title="wikilink">ones' complement</a> of 

<math display="inline" id="Two's_complement:23">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

.</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>Some special numbers to note</p></td>
<td style="text-align: left;">
<p>Decimal</p></td>
<td style="text-align: left;">
<p>Two's complement</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>127 </p></td>
<td style="text-align: left;">
<p>0111 1111</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>64 </p></td>
<td style="text-align: left;">
<p>0100 0000</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>1 </p></td>
<td style="text-align: left;">
<p>0000 0001</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>0 </p></td>
<td style="text-align: left;">
<p>0000 0000</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>−1 </p></td>
<td style="text-align: left;">
<p>1111 1111</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>−64 </p></td>
<td style="text-align: left;">
<p>1100 0000</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>−127 </p></td>
<td style="text-align: left;">
<p>1000 0001</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>−128 </p></td>
<td style="text-align: left;">
<p>1000 0000</p></td>
</tr>
</tbody>
</table>
<h3 id="example">Example</h3>

<p> −95 modulo 256 is equivalent to 161 since</p>
<dl>
<dd>−95 + 256
</dd>
<dd>= −95 + 255 + 1
</dd>
<dd>= 255 − 95 + 1
</dd>
<dd>= 160 + 1
</dd>
<dd>= 161
</dd>
</dl>
<pre><code>   1111 1111                       255
 − 0101 1111                     −  95
 ===========                     =====
   1010 0000  (ones' complement)   160
 +         1                     +   1
 ===========                     =====
   1010 0001  (two's complement)   161</code></pre>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>Two's complement using a 4-bit integer</p></td>
<td style="text-align: left;">
<p>Two's complement</p></td>
<td style="text-align: left;">
<p>Decimal</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>0111</p></td>
<td style="text-align: left;">
<p>7 </p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>0110</p></td>
<td style="text-align: left;">
<p>6 </p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>0101</p></td>
<td style="text-align: left;">
<p>5 </p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>0100</p></td>
<td style="text-align: left;">
<p>4 </p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>0011</p></td>
<td style="text-align: left;">
<p>3 </p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>0010</p></td>
<td style="text-align: left;">
<p>2 </p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>0001</p></td>
<td style="text-align: left;">
<p>1 </p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>0000</p></td>
<td style="text-align: left;">
<p>0 </p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>1111</p></td>
<td style="text-align: left;">
<p>−1 </p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>1110</p></td>
<td style="text-align: left;">
<p>−2 </p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>1101</p></td>
<td style="text-align: left;">
<p>−3 </p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>1100</p></td>
<td style="text-align: left;">
<p>−4 </p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>1011</p></td>
<td style="text-align: left;">
<p>−5 </p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>1010</p></td>
<td style="text-align: left;">
<p>−6 </p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>1001</p></td>
<td style="text-align: left;">
<p>−7 </p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>1000</p></td>
<td style="text-align: left;">
<p>−8 </p></td>
</tr>
</tbody>
</table>

<p>Fundamentally, the system represents negative integers by counting backward and <a href="modulo_arithmetic" title="wikilink">wrapping around</a>. The boundary between positive and negative numbers is arbitrary, but the de facto rule is that all negative numbers have a left-most bit (<a href="most_significant_bit" title="wikilink">most significant bit</a>) of one. Therefore, the most positive 4-bit number is 0111 (7) and the most negative is 1000 (−8). Because of the use of the left-most bit as the sign bit, the absolute value of the most negative number (|−8| = 8) is too large to represent. For example, an 8-bit number can only represent every integer from −128 to 127 (<mtpl></mtpl>) inclusive. Negating a two's complement number is simple: Invert all the bits and add one to the result. For example, negating 1111, we get 0000 + 1 = 1. Therefore, 1111 must represent −1.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></p>

<p>The system is useful in simplifying the implementation of arithmetic on computer hardware. Adding 0011 (3) to 1111 (−1) at first seems to give the incorrect answer of 10010. However, the hardware can simply ignore the left-most bit to give the correct answer of 0010 (2). Overflow checks still must exist to catch operations such as summing 0100 and 0100.</p>

<p>The system therefore allows addition of negative operands without a subtraction circuit and a circuit that detects the sign of a number. Moreover, that addition circuit can also perform subtraction by taking the two's complement of a number (see below), which only requires an additional cycle or its own adder circuit. To perform this, the circuit merely pretends an extra left-most bit of 1 exists.</p>
<h2 id="arithmetic-operations">Arithmetic operations</h2>
<h3 id="addition">Addition</h3>

<p>Adding two's-complement numbers requires no special processing if the operands have opposite signs: the sign of the result is determined automatically. For example, adding 15 and −5:</p>
<pre><code>  11111 111   (carry)
   0000 1111  (15)
 + 1111 1011  (−5)
 ==================
   0000 1010  (10)</code></pre>

<p>This process depends upon restricting to 8 bits of precision; a carry to the (nonexistent) 9th most significant bit is ignored, resulting in the arithmetically correct result of 10<sub>10</sub>.</p>

<p>The last two bits of the <a href="Carry_flag" title="wikilink">carry</a> row (reading right-to-left) contain vital information: whether the calculation resulted in an <a href="arithmetic_overflow" title="wikilink">arithmetic overflow</a>, a number too large for the binary system to represent (in this case greater than 8 bits). An overflow condition exists when these last two bits are different from one another. As mentioned above, the sign of the number is encoded in the MSB of the result.</p>

<p>In other terms, if the left two carry bits (the ones on the far left of the top row in these examples) are both 1s or both 0s, the result is valid; if the left two carry bits are "1 0" or "0 1", a sign overflow has occurred. <strong>Conveniently, an <a class="uri" href="XOR" title="wikilink">XOR</a> operation on these two bits can quickly determine if an overflow condition exists.</strong> As an example, consider the signed 4-bit addition of 7 and 3:</p>
<pre><code>  0111   (carry)
   0111  (7)
 + 0011  (3)
 =============
   1010  (−6)  invalid!</code></pre>

<p>In this case, the far left two (MSB) carry bits are "01", which means there was a two's-complement addition overflow. That is, 1010<sub>2</sub> = 10<sub>10</sub> is outside the permitted range of −8 to 7.</p>

<p>In general, any two 

<math display="inline" id="Two's_complement:24">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

-bit numbers may be added <em>without</em> overflow, by first sign-extending both of them to 

<math display="inline" id="Two's_complement:25">
 <semantics>
  <mrow>
   <mi>N</mi>
   <mo>+</mo>
   <mrow>
    <mi mathvariant="normal"></mi>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>N</ci>
    <apply>
     <times></times>
     <ci>normal-</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N+ 1
  </annotation>
 </semantics>
</math>

 bits, and then adding as above. The 

<math display="inline" id="Two's_complement:26">
 <semantics>
  <mrow>
   <mi>N</mi>
   <mo>+</mo>
   <mrow>
    <mi mathvariant="normal"></mi>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>N</ci>
    <apply>
     <times></times>
     <ci>normal-</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N+ 1
  </annotation>
 </semantics>
</math>

 bits result is large enough to represent any possible sum (

<math display="inline" id="Two's_complement:27">
 <semantics>
  <mrow>
   <mi>N</mi>
   <mo>=</mo>
   <mn>5</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>N</ci>
    <cn type="integer">5</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N=5
  </annotation>
 </semantics>
</math>

 two's complement can represent values in the range −16 to 15) so overflow will never occur. It is then possible, if desired, to 'truncate' the result back to 

<math display="inline" id="Two's_complement:28">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

 bits while preserving the value if and only if the discarded bit is a proper sign extension of the retained result bits. This provides another method of detecting overflow—which is equivalent to the method of comparing the carry bits—but which may be easier to implement in some situations, because it does not require access to the internals of the addition.</p>
<h3 id="subtraction">Subtraction</h3>

<p>Computers usually use the <a href="method_of_complements" title="wikilink">method of complements</a> to implement subtraction. Using complements for subtraction is closely related to using complements for representing negative numbers, since the combination allows all signs of operands and results; direct subtraction works with two's-complement numbers as well. Like addition, the advantage of using two's complement is the elimination of examining the signs of the operands to determine if addition or subtraction is needed. For example, subtracting −5 from 15 is really adding 5 to 15, but this is hidden by the two's-complement representation:</p>
<pre><code>  11110 000   (borrow)
   0000 1111  (15)
 − 1111 1011  (−5)
 ===========
   0001 0100  (20)</code></pre>

<p>Overflow is detected the same way as for addition, by examining the two leftmost (most significant) bits of the borrows; overflow has occurred if they are different.</p>

<p>Another example is a subtraction operation where the result is negative: 15 − 35 = −20:</p>
<pre><code>  11100 000   (borrow)
   0000 1111  (15)
 − 0010 0011  (35)
 ===========
   1110 1100  (−20)</code></pre>

<p>As for addition, overflow in subtraction may be avoided (or detected after the operation) by first sign-extending both inputs by an extra bit.</p>
<h3 id="multiplication">Multiplication</h3>

<p>The product of two 

<math display="inline" id="Two's_complement:29">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

-bit numbers requires 

<math display="inline" id="Two's_complement:30">
 <semantics>
  <mrow>
   <mn>2</mn>
   <mi>N</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <cn type="integer">2</cn>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2N
  </annotation>
 </semantics>
</math>

 bits to contain all possible values.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a></p>

<p>If the precision of the two operands using two's complement is doubled before the multiplication, direct multiplication (discarding any excess bits beyond that precision) will provide the correct result.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> For example, take 

<math display="inline" id="Two's_complement:31">
 <semantics>
  <mrow>
   <mrow>
    <mn>6</mn>
    <mi mathvariant="normal">×</mi>
    <mi mathvariant="normal">−</mi>
    <mn>5</mn>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi mathvariant="normal">−</mi>
    <mn>30</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <cn type="integer">6</cn>
     <ci>normal-×</ci>
     <ci>normal-−</ci>
     <cn type="integer">5</cn>
    </apply>
    <apply>
     <times></times>
     <ci>normal-−</ci>
     <cn type="integer">30</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   6×−5=−30
  </annotation>
 </semantics>
</math>

. First, the precision is extended from four bits to eight. Then the numbers are multiplied, discarding the bits beyond the eighth bit (as shown by ""):</p>
<pre><code>     00000110  (6)
 *   11111011  (−5)
 ============
          110
         1100
        00000
       110000
      1100000
     11000000
    x10000000
   xx00000000
 ============
   xx11100010</code></pre>

<p>This is very inefficient; by doubling the precision ahead of time, all additions must be double-precision and at least twice as many partial products are needed than for the more efficient algorithms actually implemented in computers. Some multiplication algorithms are designed for two's complement, notably <a href="Booth's_multiplication_algorithm" title="wikilink">Booth's multiplication algorithm</a>. Methods for multiplying sign-magnitude numbers don't work with two's-complement numbers without adaptation. There isn't usually a problem when the multiplicand (the one being repeatedly added to form the product) is negative; the issue is setting the initial bits of the product correctly when the multiplier is negative. Two methods for adapting algorithms to handle two's-complement numbers are common:</p>
<ul>
<li>First check to see if the multiplier is negative. If so, negate (<em>i.e.</em>, take the two's complement of) both operands before multiplying. The multiplier will then be positive so the algorithm will work. Because both operands are negated, the result will still have the correct sign.</li>
<li>Subtract the partial product resulting from the MSB (pseudo sign bit) instead of adding it like the other partial products. This method requires the multiplicand's sign bit to be extended by one position, being preserved during the shift right actions.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a></li>
</ul>

<p>As an example of the second method, take the common add-and-shift algorithm for multiplication. Instead of shifting partial products to the left as is done with pencil and paper, the accumulated product is shifted right, into a second register that will eventually hold the least significant half of the product. Since the <a href="least_significant_bit" title="wikilink">least significant bits</a> are not changed once they are calculated, the additions can be single precision, accumulating in the register that will eventually hold the most significant half of the product. In the following example, again multiplying 6 by −5, the two registers and the extended sign bit are separated by "|":</p>
<pre><code>  0 0110  (6)  (multiplicand with extended sign bit)
  × 1011 (−5)  (multiplier)
  =|====|====
  0|0110|0000  (first partial product (rightmost bit is 1))
  0|0011|0000  (shift right, preserving extended sign bit)
  0|1001|0000  (add second partial product (next bit is 1))
  0|0100|1000  (shift right, preserving extended sign bit)
  0|0100|1000  (add third partial product: 0 so no change)
  0|0010|0100  (shift right, preserving extended sign bit)
  1|1100|0100  (''subtract'' last partial product since it's from sign bit)
  1|1110|0010  (shift right, preserving extended sign bit)
   |1110|0010  (discard extended sign bit, giving the final answer, −30)</code></pre>
<h3 id="comparison-ordering">Comparison (ordering)</h3>

<p><a href="Comparison_(computer_programming)" title="wikilink">Comparison</a> is often implemented with a dummy subtraction, where the flags in the computer's <a href="status_register" title="wikilink">status register</a> are checked, but the main result is ignored. The <a href="zero_flag" title="wikilink">zero flag</a> indicates if two values compared equal. If the exclusive-or of the <a href="Sign_flag" title="wikilink">sign</a> and <a href="Overflow_flag" title="wikilink">overflow</a> flags is 1, the subtraction result was less than zero, otherwise the result was zero or greater. These checks are often implemented in computers in <a href="conditional_branch" title="wikilink">conditional branch</a> instructions.</p>

<p>Unsigned binary numbers can be ordered by a simple <a href="lexicographic_ordering" title="wikilink">lexicographic ordering</a>, where the bit value 0 is defined as less than the bit value 1. For two's complement values, the meaning of the most significant bit is reversed (i.e. 1 is less than 0).</p>

<p>The following algorithm (for an 

<math display="inline" id="Two's_complement:32">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

-bit two's complement architecture) sets the result register R to −1 if A  B, and to 0 if A and B are equal:</p>
<div class="sourceCode"><pre class="sourceCode pascal"><code class="sourceCode pascal"> <span class="co">// reversed comparison of the sign bit</span>

 <span class="kw">if</span> A(n<span class="dv">-1</span>) == <span class="dv">0</span> <span class="kw">and</span> B(n<span class="dv">-1</span>) == <span class="dv">1</span> <span class="kw">then</span>
    R := +<span class="dv">1</span>
    <span class="kw">break</span>
 <span class="kw">else</span> <span class="kw">if</span> A(n<span class="dv">-1</span>) == <span class="dv">1</span> <span class="kw">and</span> B(n<span class="dv">-1</span>) == <span class="dv">0</span> <span class="kw">then</span>
    R := -<span class="dv">1</span>
    <span class="kw">break</span>
 <span class="kw">end</span>
 
 <span class="co">// comparison of remaining bits</span>

 <span class="kw">for</span> i = n<span class="dv">-2</span>...<span class="dv">0</span> <span class="kw">do</span>
   <span class="kw">if</span> A(i) == <span class="dv">0</span> <span class="kw">and</span> B(i) == <span class="dv">1</span> <span class="kw">then</span>
      R := -<span class="dv">1</span>
      <span class="kw">break</span>
   <span class="kw">else</span> <span class="kw">if</span> A(i) == <span class="dv">1</span> <span class="kw">and</span> B(i) == <span class="dv">0</span> <span class="kw">then</span>
      R := +<span class="dv">1</span>
      <span class="kw">break</span>
   <span class="kw">end</span>
 <span class="kw">end</span>
 
 R := <span class="dv">0</span></code></pre></div>
<h2 id="twos-complement-and-2-adic-numbers">Two's complement and 2-adic numbers</h2>

<p>In a classic <em><a class="uri" href="HAKMEM" title="wikilink">HAKMEM</a></em> published by the <a href="MIT_AI_Lab" title="wikilink">MIT AI Lab</a> in 1972, <a href="Bill_Gosper" title="wikilink">Bill Gosper</a> noted that whether or not a machine's internal representation was two's-complement could be determined by summing the successive powers of two. In a flight of fancy, he noted that the result of doing this algebraically indicated that "algebra is run on a machine (the universe) which is two's-complement."<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a></p>

<p>Gosper's end conclusion is not necessarily meant to be taken seriously, and it is akin to a <a href="mathematical_joke" title="wikilink">mathematical joke</a>. The critical step is "...110 = ...111 − 1", i.e., "2<em>X</em> = <em>X</em> − 1", and thus <em>X</em> = ...111 = −1. This presupposes a method by which an infinite string of 1s is considered a number, which requires an extension of the finite place-value concepts in elementary arithmetic. It is meaningful either as part of a two's-complement notation for all integers, as a typical <a href="p-adic_number" title="wikilink">2-adic number</a>, or even as one of the generalized sums defined for the <a href="divergent_series" title="wikilink">divergent series</a> of real numbers <a href="1_+_2_+_4_+_8_+_…" title="wikilink">1 + 2 + 4 + 8 + ···</a>.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a> Digital arithmetic circuits, idealized to operate with infinite (extending to positive powers of 2) bit strings, produce 2-adic addition and multiplication compatible with two's complement representation.<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a> <a href="continuous_function" title="wikilink">Continuity</a> of binary arithmetical and <a href="bitwise_operation" title="wikilink">bitwise operations</a> in 2-adic <a href="metric_space" title="wikilink">metric</a> also has some use in cryptography.<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Division_algorithm" title="wikilink">Division algorithm</a>, including restoring and non-restoring division in two's-complement representations</li>
<li><a href="Offset_binary" title="wikilink">Offset binary</a></li>
<li><a href="p-adic_number" title="wikilink">p-adic number</a></li>
</ul>
<h2 id="references">References</h2>
<h2 id="further-reading">Further reading</h2>
<ul>
<li></li>
<li></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.vb-helper.com/tutorial_twos_complement.html">Tutorial: Two's Complement Numbers</a></li>
<li><a href="http://www.ecs.umass.edu/ece/koren/arith/simulator/ArrMlt/">Two's complement array multiplier JavaScript simulator</a></li>
<li>[<a class="uri" href="http://prozessorsimulation.klickagent.ch/?lang=en&amp;convertor">http://prozessorsimulation.klickagent.ch/?lang=en&amp;convertor;</a>;=true Javascript converter for 2's complement to decimal and vice versa]</li>
</ul>

<p>"</p>

<p><a href="Category:Binary_arithmetic" title="wikilink">Category:Binary arithmetic</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">David J. Lilja and Sachin S. Sapatnekar, <em>Designing Digital Computer Systems with Verilog</em>, Cambridge University Press, 2005 [<a class="uri" href="http://books.google.com/books?vid=ISBN052182866X&amp;id">http://books.google.com/books?vid=ISBN052182866X&amp;id;</a>;=5BvW0hYhxkQC&amp;pg;=PA37&amp;lpg;=PA37&amp;ots;=l-E0VjyPt8&amp;dq;=%22two%27s+complement+arithmetic%22&amp;sig;=sS5_swrfrzcQI2nHWest75sIjgg online]<a href="#fnref1">↩</a></li>
<li id="fn2">E.g. "Signed integers are two's complement binary values that can be used to represent both positive and negative integer values.", Section 4.2.1 in Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 1: Basic Architecture, November 2006<a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4">For 

<math display="inline" id="Two's_complement:33">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>x</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x=0
  </annotation>
 </semantics>
</math>

 we have <mtpl></mtpl>, which is equivalent to 

<math display="inline" id="Two's_complement:34">
 <semantics>
  <mrow>
   <mn>0</mn>
   <mo>*</mo>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cn type="integer">0</cn>
    <times></times>
    <eq></eq>
    <cn type="integer">0</cn>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0*=0
  </annotation>
 </semantics>
</math>

 modulo <mtpl></mtpl> (i.e. after restricting to 

<math display="inline" id="Two's_complement:35">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

 least significant bits).<a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7">[<a class="uri" href="http://books.google.com/books?id=5X7JV5-n0FIC&amp;pg">http://books.google.com/books?id=5X7JV5-n0FIC&amp;pg;</a>;=PA19&amp;dq;=%22weird+number%22+binary google.com]; "Digital Design and Computer Architecture", by David Harris, David Money Harris, Sarah L. Harris. 2007. Page 18.<a href="#fnref7">↩</a></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
<li id="fn10">Bruno Paillard. <em>An Introduction To Digital Signal Processors</em>, Sec. 6.4.2. Génie électrique et informatique Report, Université de Sherbrooke, April 2004.<a href="#fnref10">↩</a></li>
<li id="fn11"><a href="#fnref11">↩</a></li>
<li id="fn12"><a href="#fnref12">↩</a></li>
<li id="fn13"><a href="http://www.inwap.com/pdp10/hbaker/hakmem/hacks.html#item154">Hakmem - Programming Hacks - Draft, Not Yet Proofed</a><a href="#fnref13">↩</a></li>
<li id="fn14">For the summation of 1 + 2 + 4 + 8 + ··· without recourse to the 2-adic metric, see  (pp. 7–10)<a href="#fnref14">↩</a></li>
<li id="fn15">, Chapter 7, especially 7.3 for multiplication.<a href="#fnref15">↩</a></li>
<li id="fn16"><a href="#fnref16">↩</a></li>
</ol>
</section>
</body>

