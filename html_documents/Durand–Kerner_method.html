<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="630">Durand–Kerner method</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Durand–Kerner method</h1>
<hr/>

<p>In <a href="numerical_analysis" title="wikilink">numerical analysis</a>, the <strong>Durand–Kerner method</strong>, established 1960–66 and named after E. Durand and Immo Kerner, also called the <strong>method of <a href="Karl_Weierstrass" title="wikilink">Weierstrass</a></strong>, established 1859–91 and named after <a href="Karl_Weierstrass" title="wikilink">Karl Weierstrass</a>, is a <a href="root-finding_algorithm" title="wikilink">root-finding algorithm</a> for solving <a class="uri" href="polynomial" title="wikilink">polynomial</a> <a href="equation_(mathematics)" title="wikilink">equations</a>. In other words, the method can be used to solve numerically the equation</p>
<dl>
<dd>ƒ(<em>x</em>) = 0
</dd>
</dl>

<p>where ƒ is a given polynomial, which can be taken to be scaled so that the leading coefficient is 1.</p>
<h2 id="explanation">Explanation</h2>

<p>The explanation is for equations of <a href="Degree_of_a_polynomial" title="wikilink">degree</a> four. It is easily generalized to other degrees.</p>

<p>Let the polynomial ƒ be defined by</p>
<dl>
<dd>ƒ(<em>x</em>) = <em>x</em><sup>4</sup> + <em>ax</em><sup>3</sup> + <em>bx</em><sup>2</sup> + <em>cx</em> + <em>d</em>
</dd>
</dl>

<p>for all <em>x</em>.</p>

<p>The known numbers <em>a, b, c, d</em> are the <a href="coefficient" title="wikilink">coefficients</a>.</p>

<p>Let the (complex) numbers <em>P,Q,R,S</em> be the roots of this polynomial ƒ.</p>

<p>Then</p>
<dl>
<dd>ƒ(<em>x</em>) = (<em>x</em> − <em>P</em>)(<em>x</em> − <em>Q</em>)(<em>x</em> − <em>R</em>)(<em>x</em> − <em>S</em>)
</dd>
</dl>

<p>for all <em>x</em>. One can isolate the value <em>P</em> from this equation,</p>

<p>

<math display="block" id="Durand–Kerner_method:0">
 <semantics>
  <mrow>
   <mrow>
    <mi>P</mi>
    <mo>=</mo>
    <mrow>
     <mi>x</mi>
     <mo>-</mo>
     <mfrac>
      <mrow>
       <mi>f</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>x</mi>
         <mo>-</mo>
         <mi>Q</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>x</mi>
         <mo>-</mo>
         <mi>R</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>x</mi>
         <mo>-</mo>
         <mi>S</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mfrac>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>P</ci>
    <apply>
     <minus></minus>
     <ci>x</ci>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <ci>f</ci>
       <ci>x</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <minus></minus>
        <ci>x</ci>
        <ci>Q</ci>
       </apply>
       <apply>
        <minus></minus>
        <ci>x</ci>
        <ci>R</ci>
       </apply>
       <apply>
        <minus></minus>
        <ci>x</ci>
        <ci>S</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P=x-\frac{f(x)}{(x-Q)(x-R)(x-S)}.
  </annotation>
 </semantics>
</math>

</p>

<p>So if used as a <a href="fixed_point_(mathematics)" title="wikilink">fixed point</a> <a class="uri" href="iteration" title="wikilink">iteration</a></p>

<p>

<math display="block" id="Durand–Kerner_method:1">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
    <mo>:=</mo>
    <mrow>
     <msub>
      <mi>x</mi>
      <mn>0</mn>
     </msub>
     <mo>-</mo>
     <mfrac>
      <mrow>
       <mi>f</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>x</mi>
         <mn>0</mn>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <msub>
          <mi>x</mi>
          <mn>0</mn>
         </msub>
         <mo>-</mo>
         <mi>Q</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <msub>
          <mi>x</mi>
          <mn>0</mn>
         </msub>
         <mo>-</mo>
         <mi>R</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <msub>
          <mi>x</mi>
          <mn>0</mn>
         </msub>
         <mo>-</mo>
         <mi>S</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mfrac>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <ci>f</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <cn type="integer">0</cn>
        </apply>
        <ci>Q</ci>
       </apply>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <cn type="integer">0</cn>
        </apply>
        <ci>R</ci>
       </apply>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <cn type="integer">0</cn>
        </apply>
        <ci>S</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1}:=x_{0}-\frac{f(x_{0})}{(x_{0}-Q)(x_{0}-R)(x_{0}-S)},
  </annotation>
 </semantics>
</math>

 it is strongly stable in that every initial point <em>x<sub>0</sub></em> ≠ <em>Q,R,S</em> delivers after one iteration the root <em>P=x<sub>1</sub></em>.</p>

<p>Furthermore, if one replaces the zeros <em>Q</em>, <em>R</em> and <em>S</em> by approximations <em>q</em> ≈ <em>Q</em>, <em>r</em> ≈ <em>R</em>, <em>s</em> ≈ <em>S</em>, such that <em>q,r,s</em> are not equal to <em>P</em>, then <em>P</em> is still a fixed point of the perturbed fixed point iteration</p>

<p>

<math display="block" id="Durand–Kerner_method:2">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>x</mi>
     <mrow>
      <mi>k</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo>:=</mo>
    <mrow>
     <msub>
      <mi>x</mi>
      <mi>k</mi>
     </msub>
     <mo>-</mo>
     <mfrac>
      <mrow>
       <mi>f</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>x</mi>
         <mi>k</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <msub>
          <mi>x</mi>
          <mi>k</mi>
         </msub>
         <mo>-</mo>
         <mi>q</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <msub>
          <mi>x</mi>
          <mi>k</mi>
         </msub>
         <mo>-</mo>
         <mi>r</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <msub>
          <mi>x</mi>
          <mi>k</mi>
         </msub>
         <mo>-</mo>
         <mi>s</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mfrac>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <apply>
      <plus></plus>
      <ci>k</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>k</ci>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <ci>f</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>k</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>k</ci>
        </apply>
        <ci>q</ci>
       </apply>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>k</ci>
        </apply>
        <ci>r</ci>
       </apply>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>k</ci>
        </apply>
        <ci>s</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{k+1}:=x_{k}-\frac{f(x_{k})}{(x_{k}-q)(x_{k}-r)(x_{k}-s)},
  </annotation>
 </semantics>
</math>

 since</p>

<p>

<math display="block" id="Durand–Kerner_method:3">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>P</mi>
     <mo>-</mo>
     <mfrac>
      <mrow>
       <mi>f</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>P</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>P</mi>
         <mo>-</mo>
         <mi>q</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>P</mi>
         <mo>-</mo>
         <mi>r</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>P</mi>
         <mo>-</mo>
         <mi>s</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mfrac>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>P</mi>
     <mo>-</mo>
     <mn>0</mn>
    </mrow>
    <mo>=</mo>
    <mi>P</mi>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <minus></minus>
      <ci>P</ci>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <ci>f</ci>
        <ci>P</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <minus></minus>
         <ci>P</ci>
         <ci>q</ci>
        </apply>
        <apply>
         <minus></minus>
         <ci>P</ci>
         <ci>r</ci>
        </apply>
        <apply>
         <minus></minus>
         <ci>P</ci>
         <ci>s</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <ci>P</ci>
      <cn type="integer">0</cn>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <ci>P</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P-\frac{f(P)}{(P-q)(P-r)(P-s)}=P-0=P.
  </annotation>
 </semantics>
</math>

</p>

<p>Note that the denominator is still different from zero. This fixed point iteration is a <a href="contraction_mapping" title="wikilink">contraction mapping</a> for <em>x</em> around <em>P</em>.</p>

<p>The clue to the method now is to combine the fixed point iteration for <em>P</em> with similar iterations for <em>Q,R,S</em> into a simultaneous iteration for all roots.</p>

<p>Initialize <em>p, q, r, s</em>:</p>
<dl>
<dd><em>p</em><sub>0</sub> := (0.4 + 0.9 i)<sup>0</sup> ;
</dd>
<dd><em>q</em><sub>0</sub> := (0.4 + 0.9 i)<sup>1</sup> ;
</dd>
<dd><em>r</em><sub>0</sub> := (0.4 + 0.9 i)<sup>2</sup> ;
</dd>
<dd><em>s</em><sub>0</sub> := (0.4 + 0.9 i)<sup>3</sup> ;
</dd>
</dl>

<p>There is nothing special about choosing 0.4 + 0.9 i except that it is neither a <a href="real_number" title="wikilink">real number</a> nor a <a href="root_of_unity" title="wikilink">root of unity</a>.</p>

<p>Make the substitutions for <em>n</em> = 1,2,3,···</p>
<dl>
<dd>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>

<math display="inline" id="Durand–Kerner_method:4">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>p</mi>
     <mi>n</mi>
    </msub>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>p</mi>
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msub>
     <mo>-</mo>
     <mfrac>
      <mrow>
       <mi>f</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>p</mi>
         <mrow>
          <mi>n</mi>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <msub>
          <mi>p</mi>
          <mrow>
           <mi>n</mi>
           <mo>-</mo>
           <mn>1</mn>
          </mrow>
         </msub>
         <mo>-</mo>
         <msub>
          <mi>q</mi>
          <mrow>
           <mi>n</mi>
           <mo>-</mo>
           <mn>1</mn>
          </mrow>
         </msub>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <msub>
          <mi>p</mi>
          <mrow>
           <mi>n</mi>
           <mo>-</mo>
           <mn>1</mn>
          </mrow>
         </msub>
         <mo>-</mo>
         <msub>
          <mi>r</mi>
          <mrow>
           <mi>n</mi>
           <mo>-</mo>
           <mn>1</mn>
          </mrow>
         </msub>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <msub>
          <mi>p</mi>
          <mrow>
           <mi>n</mi>
           <mo>-</mo>
           <mn>1</mn>
          </mrow>
         </msub>
         <mo>-</mo>
         <msub>
          <mi>s</mi>
          <mrow>
           <mi>n</mi>
           <mo>-</mo>
           <mn>1</mn>
          </mrow>
         </msub>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mfrac>
    </mrow>
   </mrow>
   <mo>;</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>p</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>p</ci>
      <apply>
       <minus></minus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <ci>f</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>p</ci>
        <apply>
         <minus></minus>
         <ci>n</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>p</ci>
         <apply>
          <minus></minus>
          <ci>n</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>q</ci>
         <apply>
          <minus></minus>
          <ci>n</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
       </apply>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>p</ci>
         <apply>
          <minus></minus>
          <ci>n</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>r</ci>
         <apply>
          <minus></minus>
          <ci>n</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
       </apply>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>p</ci>
         <apply>
          <minus></minus>
          <ci>n</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>s</ci>
         <apply>
          <minus></minus>
          <ci>n</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{n}=p_{n-1}-\frac{f(p_{n-1})}{(p_{n-1}-q_{n-1})(p_{n-1}-r_{n-1})(p_{n-1}-s_{%
n-1})};
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>

<math display="inline" id="Durand–Kerner_method:5">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>q</mi>
     <mi>n</mi>
    </msub>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>q</mi>
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msub>
     <mo>-</mo>
     <mfrac>
      <mrow>
       <mi>f</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>q</mi>
         <mrow>
          <mi>n</mi>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <msub>
          <mi>q</mi>
          <mrow>
           <mi>n</mi>
           <mo>-</mo>
           <mn>1</mn>
          </mrow>
         </msub>
         <mo>-</mo>
         <msub>
          <mi>p</mi>
          <mi>n</mi>
         </msub>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <msub>
          <mi>q</mi>
          <mrow>
           <mi>n</mi>
           <mo>-</mo>
           <mn>1</mn>
          </mrow>
         </msub>
         <mo>-</mo>
         <msub>
          <mi>r</mi>
          <mrow>
           <mi>n</mi>
           <mo>-</mo>
           <mn>1</mn>
          </mrow>
         </msub>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <msub>
          <mi>q</mi>
          <mrow>
           <mi>n</mi>
           <mo>-</mo>
           <mn>1</mn>
          </mrow>
         </msub>
         <mo>-</mo>
         <msub>
          <mi>s</mi>
          <mrow>
           <mi>n</mi>
           <mo>-</mo>
           <mn>1</mn>
          </mrow>
         </msub>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mfrac>
    </mrow>
   </mrow>
   <mo>;</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>q</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>q</ci>
      <apply>
       <minus></minus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <ci>f</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>q</ci>
        <apply>
         <minus></minus>
         <ci>n</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>q</ci>
         <apply>
          <minus></minus>
          <ci>n</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>p</ci>
         <ci>n</ci>
        </apply>
       </apply>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>q</ci>
         <apply>
          <minus></minus>
          <ci>n</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>r</ci>
         <apply>
          <minus></minus>
          <ci>n</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
       </apply>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>q</ci>
         <apply>
          <minus></minus>
          <ci>n</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>s</ci>
         <apply>
          <minus></minus>
          <ci>n</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q_{n}=q_{n-1}-\frac{f(q_{n-1})}{(q_{n-1}-p_{n})(q_{n-1}-r_{n-1})(q_{n-1}-s_{n-%
1})};
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>

<math display="inline" id="Durand–Kerner_method:6">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>r</mi>
     <mi>n</mi>
    </msub>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>r</mi>
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msub>
     <mo>-</mo>
     <mfrac>
      <mrow>
       <mi>f</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>r</mi>
         <mrow>
          <mi>n</mi>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <msub>
          <mi>r</mi>
          <mrow>
           <mi>n</mi>
           <mo>-</mo>
           <mn>1</mn>
          </mrow>
         </msub>
         <mo>-</mo>
         <msub>
          <mi>p</mi>
          <mi>n</mi>
         </msub>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <msub>
          <mi>r</mi>
          <mrow>
           <mi>n</mi>
           <mo>-</mo>
           <mn>1</mn>
          </mrow>
         </msub>
         <mo>-</mo>
         <msub>
          <mi>q</mi>
          <mi>n</mi>
         </msub>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <msub>
          <mi>r</mi>
          <mrow>
           <mi>n</mi>
           <mo>-</mo>
           <mn>1</mn>
          </mrow>
         </msub>
         <mo>-</mo>
         <msub>
          <mi>s</mi>
          <mrow>
           <mi>n</mi>
           <mo>-</mo>
           <mn>1</mn>
          </mrow>
         </msub>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mfrac>
    </mrow>
   </mrow>
   <mo>;</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>r</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>r</ci>
      <apply>
       <minus></minus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <ci>f</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>r</ci>
        <apply>
         <minus></minus>
         <ci>n</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>r</ci>
         <apply>
          <minus></minus>
          <ci>n</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>p</ci>
         <ci>n</ci>
        </apply>
       </apply>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>r</ci>
         <apply>
          <minus></minus>
          <ci>n</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>q</ci>
         <ci>n</ci>
        </apply>
       </apply>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>r</ci>
         <apply>
          <minus></minus>
          <ci>n</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>s</ci>
         <apply>
          <minus></minus>
          <ci>n</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r_{n}=r_{n-1}-\frac{f(r_{n-1})}{(r_{n-1}-p_{n})(r_{n-1}-q_{n})(r_{n-1}-s_{n-1}%
)};
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>

<math display="inline" id="Durand–Kerner_method:7">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>s</mi>
     <mi>n</mi>
    </msub>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>s</mi>
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msub>
     <mo>-</mo>
     <mfrac>
      <mrow>
       <mi>f</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>s</mi>
         <mrow>
          <mi>n</mi>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <msub>
          <mi>s</mi>
          <mrow>
           <mi>n</mi>
           <mo>-</mo>
           <mn>1</mn>
          </mrow>
         </msub>
         <mo>-</mo>
         <msub>
          <mi>p</mi>
          <mi>n</mi>
         </msub>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <msub>
          <mi>s</mi>
          <mrow>
           <mi>n</mi>
           <mo>-</mo>
           <mn>1</mn>
          </mrow>
         </msub>
         <mo>-</mo>
         <msub>
          <mi>q</mi>
          <mi>n</mi>
         </msub>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <msub>
          <mi>s</mi>
          <mrow>
           <mi>n</mi>
           <mo>-</mo>
           <mn>1</mn>
          </mrow>
         </msub>
         <mo>-</mo>
         <msub>
          <mi>r</mi>
          <mi>n</mi>
         </msub>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mfrac>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>s</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>s</ci>
      <apply>
       <minus></minus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <ci>f</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>s</ci>
        <apply>
         <minus></minus>
         <ci>n</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>s</ci>
         <apply>
          <minus></minus>
          <ci>n</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>p</ci>
         <ci>n</ci>
        </apply>
       </apply>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>s</ci>
         <apply>
          <minus></minus>
          <ci>n</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>q</ci>
         <ci>n</ci>
        </apply>
       </apply>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>s</ci>
         <apply>
          <minus></minus>
          <ci>n</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>r</ci>
         <ci>n</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s_{n}=s_{n-1}-\frac{f(s_{n-1})}{(s_{n-1}-p_{n})(s_{n-1}-q_{n})(s_{n-1}-r_{n})}.
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
</tbody>
</table>
</dd>
</dl>

<p>Re-iterate until the numbers <em>p, q, r, s</em> stop essentially changing in relative to the desired precision. Then they have the values <em>P, Q, R, S</em> in some order and in the chosen precision. So the problem is solved.</p>

<p>Note that you must use <a href="complex_number" title="wikilink">complex number</a> arithmetic, and that the roots are found simultaneously rather than one at a time.</p>
<h2 id="variations">Variations</h2>

<p>This iteration procedure, like the <a href="Gauss–Seidel_method" title="wikilink">Gauss–Seidel method</a> for linear equations, computes one number at a time based on the already computed numbers. A variant of this procedure, like the <a href="Jacobi_method" title="wikilink">Jacobi method</a>, computes a vector of root approximations at a time. Both variant are effective root-finding algorithms.</p>

<p>One could also choose the initial values for <em>p,q,r,s</em> by some other procedure, even randomly, but in a way that</p>
<ul>
<li>they are inside some not-too-large circle containing also the roots of ƒ(<em>x</em>), e.g. the circle around the origin with radius 

<math display="inline" id="Durand–Kerner_method:8">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>+</mo>
   <mrow>
    <mi>max</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo stretchy="false">|</mo>
      <mi>a</mi>
      <mo stretchy="false">|</mo>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mo stretchy="false">|</mo>
      <mi>b</mi>
      <mo stretchy="false">|</mo>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mo stretchy="false">|</mo>
      <mi>c</mi>
      <mo stretchy="false">|</mo>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mo stretchy="false">|</mo>
      <mi>d</mi>
      <mo stretchy="false">|</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <cn type="integer">1</cn>
    <apply>
     <max></max>
     <apply>
      <abs></abs>
      <ci>a</ci>
     </apply>
     <apply>
      <abs></abs>
      <ci>b</ci>
     </apply>
     <apply>
      <abs></abs>
      <ci>c</ci>
     </apply>
     <apply>
      <abs></abs>
      <ci>d</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1+\max(|a|,|b|,|c|,|d|)
  </annotation>
 </semantics>
</math>

, (where 1,<em>a,b,c,d</em> are the coefficients of ƒ(<em>x</em>))</li>
</ul>

<p>and that</p>
<ul>
<li>they are not too close to each other,</li>
</ul>

<p>which may increasingly become a concern as the degree of the polynomial increases.</p>
<h2 id="example">Example</h2>

<p>This example is from the reference 1992. The equation solved is <mtpl></mtpl>. The first 4 iterations move <em>p</em>, <em>q</em>, <em>r</em> seemingly chaotically, but then the roots are located to 1 decimal. After iteration number 5 we have 4 correct decimals, and the subsequent iteration number 6 confirms that the computed roots are fixed. This general behaviour is characteristic for the method.</p>

<p>::{|class="wikitable" |---- !it.-no. !p !q !r |---- !0 | +1.0000+0.0000i | +0.4000+0.9000i | −0.6500+0.7200i |---- !1 | +1.3608+2.0222i | −0.3658+2.4838i | −2.3858−0.0284i |---- !2 | +2.6597+2.7137i | +0.5977+0.8225i | −0.6320−1.6716i |---- ! 3 | +2.2704+0.3880i | +0.1312+1.3128i | +0.2821−1.5015i |---- ! 4 | +2.5428−0.0153i | +0.2044+1.3716i | +0.2056−1.3721i |---- ! 5 | +2.5874+0.0000i | +0.2063+1.3747i | +0.2063−1.3747i |---- ! 6 | +2.5874+0.0000i | +0.2063+1.3747i | +0.2063−1.3747i |---- |} Note that the equation has one real root and one pair of complex conjugate roots, and that the sum of the roots is 3.</p>
<h2 id="derivation-of-the-method-via-newtons-method">Derivation of the method via Newton's method</h2>

<p>For every <em>n</em>-tuple of complex numbers, there is exactly one monic polynomial of degree <em>n</em> that has them as its zeros (keeping multiplicities). This polynomial is given by multiplying all the corresponding linear factors, that is</p>

<p>

<math display="block" id="Durand–Kerner_method:9">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>g</mi>
      <mover accent="true">
       <mi>z</mi>
       <mo stretchy="false">→</mo>
      </mover>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>X</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>X</mi>
       <mo>-</mo>
       <msub>
        <mi>z</mi>
        <mn>1</mn>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi mathvariant="normal">⋯</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>X</mi>
       <mo>-</mo>
       <msub>
        <mi>z</mi>
        <mi>n</mi>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>g</ci>
      <apply>
       <ci>normal-→</ci>
       <ci>z</ci>
      </apply>
     </apply>
     <ci>X</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <minus></minus>
      <ci>X</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>z</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>normal-⋯</ci>
     <apply>
      <minus></minus>
      <ci>X</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>z</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g_{\vec{z}}(X)=(X-z_{1})\cdots(X-z_{n}).
  </annotation>
 </semantics>
</math>

</p>

<p>This polynomial has coefficients that depend on the prescribed zeros,</p>

<p>

<math display="block" id="Durand–Kerner_method:10">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>g</mi>
      <mover accent="true">
       <mi>z</mi>
       <mo stretchy="false">→</mo>
      </mover>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>X</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msup>
      <mi>X</mi>
      <mi>n</mi>
     </msup>
     <mo>+</mo>
     <mrow>
      <msub>
       <mi>g</mi>
       <mrow>
        <mi>n</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mover accent="true">
        <mi>z</mi>
        <mo stretchy="false">→</mo>
       </mover>
       <mo stretchy="false">)</mo>
      </mrow>
      <msup>
       <mi>X</mi>
       <mrow>
        <mi>n</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msup>
     </mrow>
     <mo>+</mo>
     <mi mathvariant="normal">⋯</mi>
     <mo>+</mo>
     <mrow>
      <msub>
       <mi>g</mi>
       <mn>0</mn>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mover accent="true">
        <mi>z</mi>
        <mo stretchy="false">→</mo>
       </mover>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>g</ci>
      <apply>
       <ci>normal-→</ci>
       <ci>z</ci>
      </apply>
     </apply>
     <ci>X</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>X</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>g</ci>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <ci>normal-→</ci>
       <ci>z</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>X</ci>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
     <ci>normal-⋯</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>g</ci>
       <cn type="integer">0</cn>
      </apply>
      <apply>
       <ci>normal-→</ci>
       <ci>z</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g_{\vec{z}}(X)=X^{n}+g_{n-1}(\vec{z})X^{n-1}+\cdots+g_{0}(\vec{z}).
  </annotation>
 </semantics>
</math>

</p>

<p>Those coefficients are, up to a sign, the <a href="elementary_symmetric_polynomial" title="wikilink">elementary symmetric polynomials</a> 

<math display="inline" id="Durand–Kerner_method:11">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>α</mi>
     <mn>1</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mover accent="true">
      <mi>z</mi>
      <mo stretchy="false">→</mo>
     </mover>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <mrow>
    <msub>
     <mi>α</mi>
     <mi>n</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mover accent="true">
      <mi>z</mi>
      <mo stretchy="false">→</mo>
     </mover>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>α</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <ci>normal-→</ci>
      <ci>z</ci>
     </apply>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>α</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <ci>normal-→</ci>
      <ci>z</ci>
     </apply>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha_{1}(\vec{z}),\dots,\alpha_{n}(\vec{z})
  </annotation>
 </semantics>
</math>

 of degrees <em>1,...,n</em>.</p>

<p>To find all the roots of a given polynomial 

<math display="inline" id="Durand–Kerner_method:12">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>X</mi>
     <mi>n</mi>
    </msup>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>c</mi>
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msub>
     <msup>
      <mi>X</mi>
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msup>
    </mrow>
    <mo>+</mo>
    <mi mathvariant="normal">⋯</mi>
    <mo>+</mo>
    <msub>
     <mi>c</mi>
     <mn>0</mn>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>X</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>X</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>c</ci>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>X</ci>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
     <ci>normal-⋯</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>c</ci>
      <cn type="integer">0</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(X)=X^{n}+c_{n-1}X^{n-1}+\cdots+c_{0}
  </annotation>
 </semantics>
</math>

 with coefficient vector 

<math display="inline" id="Durand–Kerner_method:13">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msub>
    <mi>c</mi>
    <mrow>
     <mi>n</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>c</mi>
    <mn>0</mn>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>c</ci>
     <apply>
      <minus></minus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>c</ci>
     <cn type="integer">0</cn>
    </apply>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (c_{n-1},\dots,c_{0})
  </annotation>
 </semantics>
</math>

 simultaneously is now the same as to find a solution vector to the system</p>

<p>

<math display="block" id="Durand–Kerner_method:14">
 <semantics>
  <mtable displaystyle="true">
   <mtr>
    <mtd columnalign="center">
     <msub>
      <mi>c</mi>
      <mn>0</mn>
     </msub>
    </mtd>
    <mtd columnalign="center">
     <mo>=</mo>
    </mtd>
    <mtd columnalign="center">
     <mrow>
      <mi>g</mi>
      <msub>
       <mo>;</mo>
       <mn>0</mn>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mover accent="true">
        <mi>z</mi>
        <mo stretchy="false">→</mo>
       </mover>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mtd>
    <mtd columnalign="center">
     <mo>=</mo>
    </mtd>
    <mtd columnalign="center">
     <mrow>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mi>n</mi>
      </msup>
      <msub>
       <mi>α</mi>
       <mi>n</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mover accent="true">
        <mi>z</mi>
        <mo stretchy="false">→</mo>
       </mover>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mtd>
    <mtd columnalign="center">
     <mo>=</mo>
    </mtd>
    <mtd columnalign="center">
     <mrow>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mi>n</mi>
      </msup>
      <msub>
       <mi>z</mi>
       <mn>1</mn>
      </msub>
      <mi mathvariant="normal">⋯</mi>
      <msub>
       <mi>z</mi>
       <mi>n</mi>
      </msub>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="center">
     <msub>
      <mi>c</mi>
      <mn>1</mn>
     </msub>
    </mtd>
    <mtd columnalign="center">
     <mo>=</mo>
    </mtd>
    <mtd columnalign="center">
     <mrow>
      <mi>g</mi>
      <msub>
       <mo>;</mo>
       <mn>1</mn>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mover accent="true">
        <mi>z</mi>
        <mo stretchy="false">→</mo>
       </mover>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mtd>
    <mtd columnalign="center">
     <mo>=</mo>
    </mtd>
    <mtd columnalign="center">
     <mrow>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mrow>
        <mi>n</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msup>
      <msub>
       <mi>α</mi>
       <mrow>
        <mi>n</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mover accent="true">
        <mi>z</mi>
        <mo stretchy="false">→</mo>
       </mover>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="center">
     <mi></mi>
    </mtd>
    <mtd columnalign="center">
     <mi mathvariant="normal">⋮</mi>
    </mtd>
    <mtd columnalign="center">
     <mi></mi>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="center">
     <msub>
      <mi>c</mi>
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msub>
    </mtd>
    <mtd columnalign="center">
     <mo>=</mo>
    </mtd>
    <mtd columnalign="center">
     <mrow>
      <mi>g</mi>
      <msub>
       <mo>;</mo>
       <mrow>
        <mi>n</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mover accent="true">
        <mi>z</mi>
        <mo stretchy="false">→</mo>
       </mover>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mtd>
    <mtd columnalign="center">
     <mo>=</mo>
    </mtd>
    <mtd columnalign="center">
     <mrow>
      <mo>-</mo>
      <mrow>
       <msub>
        <mi>α</mi>
        <mn>1</mn>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mover accent="true">
         <mi>z</mi>
         <mo stretchy="false">→</mo>
        </mover>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </mtd>
    <mtd columnalign="center">
     <mo>=</mo>
    </mtd>
    <mtd columnalign="center">
     <mrow>
      <mrow>
       <mo>-</mo>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <msub>
          <mi>z</mi>
          <mn>1</mn>
         </msub>
         <mo>+</mo>
         <msub>
          <mi>z</mi>
          <mn>2</mn>
         </msub>
         <mo>+</mo>
         <mi mathvariant="normal">⋯</mi>
         <mo>+</mo>
         <msub>
          <mi>z</mi>
          <mi>n</mi>
         </msub>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>.</mo>
     </mrow>
    </mtd>
   </mtr>
  </mtable>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>c</ci>
      <cn type="integer">0</cn>
     </apply>
     <eq></eq>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="unknown">g</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>normal-;</ci>
       <cn type="integer">0</cn>
      </apply>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <apply>
        <ci>normal-→</ci>
        <ci>z</ci>
       </apply>
       <ci>normal-)</ci>
      </cerror>
     </cerror>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
       <ci>n</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>α</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <ci>normal-→</ci>
       <ci>z</ci>
      </apply>
     </apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
       <ci>n</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>z</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-⋯</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>z</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </matrixrow>
    <matrixrow>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>c</ci>
      <cn type="integer">1</cn>
     </apply>
     <eq></eq>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="unknown">g</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>normal-;</ci>
       <cn type="integer">1</cn>
      </apply>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <apply>
        <ci>normal-→</ci>
        <ci>z</ci>
       </apply>
       <ci>normal-)</ci>
      </cerror>
     </cerror>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>α</ci>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <ci>normal-→</ci>
       <ci>z</ci>
      </apply>
     </apply>
    </matrixrow>
    <matrixrow>
     <csymbol cd="latexml">absent</csymbol>
     <ci>normal-⋮</ci>
     <csymbol cd="latexml">absent</csymbol>
    </matrixrow>
    <matrixrow>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>c</ci>
      <apply>
       <minus></minus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <eq></eq>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="unknown">g</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>normal-;</ci>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <apply>
        <ci>normal-→</ci>
        <ci>z</ci>
       </apply>
       <ci>normal-)</ci>
      </cerror>
     </cerror>
     <eq></eq>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>α</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <ci>normal-→</ci>
        <ci>z</ci>
       </apply>
      </apply>
     </apply>
     <eq></eq>
     <apply>
      <minus></minus>
      <apply>
       <plus></plus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>z</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>z</ci>
        <cn type="integer">2</cn>
       </apply>
       <ci>normal-⋯</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>z</ci>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{matrix}c_{0}&=&g;_{0}(\vec{z})&=&(-1)^{n}\alpha_{n}(\vec{z})&=&(-1)^{n}%
z_{1}\cdots z_{n}\\
c_{1}&=&g;_{1}(\vec{z})&=&(-1)^{n-1}\alpha_{n-1}(\vec{z})\\
&\vdots&\\
c_{n-1}&=&g;_{n-1}(\vec{z})&=&-\alpha_{1}(\vec{z})&=&-(z_{1}+z_{2}+\cdots+z_{n%
}).\end{matrix}
  </annotation>
 </semantics>
</math>

</p>

<p>The Durand–Kerner method is obtained as the multidimensional <a href="Newton's_method" title="wikilink">Newton's method</a> applied to this system. It is algebraically more comfortable to treat those identities of coefficients as the identity of the corresponding polynomials, 

<math display="inline" id="Durand–Kerner_method:15">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>g</mi>
     <mover accent="true">
      <mi>z</mi>
      <mo stretchy="false">→</mo>
     </mover>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>g</ci>
      <apply>
       <ci>normal-→</ci>
       <ci>z</ci>
      </apply>
     </apply>
     <ci>X</ci>
    </apply>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>X</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g_{\vec{z}}(X)=f(X)
  </annotation>
 </semantics>
</math>

. In the Newton's method one looks, given some initial vector 

<math display="inline" id="Durand–Kerner_method:16">
 <semantics>
  <mover accent="true">
   <mi>z</mi>
   <mo stretchy="false">→</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>z</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vec{z}
  </annotation>
 </semantics>
</math>

, for an increment vector 

<math display="inline" id="Durand–Kerner_method:17">
 <semantics>
  <mover accent="true">
   <mi>w</mi>
   <mo stretchy="false">→</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>w</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vec{w}
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Durand–Kerner_method:18">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>g</mi>
     <mrow>
      <mover accent="true">
       <mi>z</mi>
       <mo stretchy="false">→</mo>
      </mover>
      <mo>+</mo>
      <mover accent="true">
       <mi>w</mi>
       <mo stretchy="false">→</mo>
      </mover>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>g</ci>
      <apply>
       <plus></plus>
       <apply>
        <ci>normal-→</ci>
        <ci>z</ci>
       </apply>
       <apply>
        <ci>normal-→</ci>
        <ci>w</ci>
       </apply>
      </apply>
     </apply>
     <ci>X</ci>
    </apply>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>X</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g_{\vec{z}+\vec{w}}(X)=f(X)
  </annotation>
 </semantics>
</math>

 is satisfied up to second and higher order terms in the increment. For this one solves the identity</p>

<p>

<math display="block" id="Durand–Kerner_method:19">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>X</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>-</mo>
     <mrow>
      <msub>
       <mi>g</mi>
       <mover accent="true">
        <mi>z</mi>
        <mo stretchy="false">→</mo>
       </mover>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>X</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>k</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>n</mi>
     </munderover>
     <mrow>
      <mfrac>
       <mrow>
        <mrow>
         <mo>∂</mo>
         <msub>
          <mi>g</mi>
          <mover accent="true">
           <mi>z</mi>
           <mo stretchy="false">→</mo>
          </mover>
         </msub>
        </mrow>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>X</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mrow>
        <mo>∂</mo>
        <msub>
         <mi>z</mi>
         <mi>k</mi>
        </msub>
       </mrow>
      </mfrac>
      <msub>
       <mi>w</mi>
       <mi>k</mi>
      </msub>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo>-</mo>
     <mrow>
      <munderover>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mrow>
        <mi>k</mi>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <mi>n</mi>
      </munderover>
      <mrow>
       <msub>
        <mi>w</mi>
        <mi>k</mi>
       </msub>
       <mrow>
        <munder>
         <mo largeop="true" movablelimits="false" symmetric="true">∏</mo>
         <mrow>
          <mi>j</mi>
          <mo>≠</mo>
          <mi>k</mi>
         </mrow>
        </munder>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mi>X</mi>
          <mo>-</mo>
          <msub>
           <mi>z</mi>
           <mi>j</mi>
          </msub>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>f</ci>
       <ci>X</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>g</ci>
        <apply>
         <ci>normal-→</ci>
         <ci>z</ci>
        </apply>
       </apply>
       <ci>X</ci>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>k</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>n</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <apply>
         <times></times>
         <apply>
          <partialdiff></partialdiff>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>g</ci>
           <apply>
            <ci>normal-→</ci>
            <ci>z</ci>
           </apply>
          </apply>
         </apply>
         <ci>X</ci>
        </apply>
        <apply>
         <partialdiff></partialdiff>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>z</ci>
          <ci>k</ci>
         </apply>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>w</ci>
        <ci>k</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <minus></minus>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <ci>k</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>n</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>w</ci>
         <ci>k</ci>
        </apply>
        <apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <csymbol cd="latexml">product</csymbol>
          <apply>
           <neq></neq>
           <ci>j</ci>
           <ci>k</ci>
          </apply>
         </apply>
         <apply>
          <minus></minus>
          <ci>X</ci>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>z</ci>
           <ci>j</ci>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(X)-g_{\vec{z}}(X)=\sum_{k=1}^{n}\frac{\partial g_{\vec{z}}(X)}{\partial z_{k%
}}w_{k}=-\sum_{k=1}^{n}w_{k}\prod_{j\neq k}(X-z_{j}).
  </annotation>
 </semantics>
</math>

</p>

<p>If the numbers 

<math display="inline" id="Durand–Kerner_method:20">
 <semantics>
  <mrow>
   <msub>
    <mi>z</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>z</mi>
    <mi>n</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>z</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>z</ci>
     <ci>n</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z_{1},\dots,z_{n}
  </annotation>
 </semantics>
</math>

 are pairwise different, then the polynomials in the terms of the right hand side form a basis of the <em>n</em>-dimensional space 

<math display="inline" id="Durand–Kerner_method:21">
 <semantics>
  <mrow>
   <mi>ℂ</mi>
   <msub>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>X</mi>
     <mo stretchy="false">]</mo>
    </mrow>
    <mrow>
     <mi>n</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>ℂ</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>X</ci>
     </apply>
     <apply>
      <minus></minus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{C}[X]_{n-1}
  </annotation>
 </semantics>
</math>

 of polynomials with maximal degree <em>n</em> − 1. Thus a solution 

<math display="inline" id="Durand–Kerner_method:22">
 <semantics>
  <mover accent="true">
   <mi>w</mi>
   <mo stretchy="false">→</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>w</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vec{w}
  </annotation>
 </semantics>
</math>

 to the increment equation exists in this case. The coordinates of the increment 

<math display="inline" id="Durand–Kerner_method:23">
 <semantics>
  <mover accent="true">
   <mi>w</mi>
   <mo stretchy="false">→</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>w</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vec{w}
  </annotation>
 </semantics>
</math>

 are simply obtained by evaluating the increment equation</p>

<p>

<math display="block" id="Durand–Kerner_method:24">
 <semantics>
  <mrow>
   <mrow>
    <mo>-</mo>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>k</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>n</mi>
     </munderover>
     <mrow>
      <msub>
       <mi>w</mi>
       <mi>k</mi>
      </msub>
      <mrow>
       <munder>
        <mo largeop="true" movablelimits="false" symmetric="true">∏</mo>
        <mrow>
         <mi>j</mi>
         <mo>≠</mo>
         <mi>k</mi>
        </mrow>
       </munder>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>X</mi>
         <mo>-</mo>
         <msub>
          <mi>z</mi>
          <mi>j</mi>
         </msub>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>X</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∏</mo>
      <mrow>
       <mi>j</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>n</mi>
     </munderover>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>X</mi>
       <mo>-</mo>
       <msub>
        <mi>z</mi>
        <mi>j</mi>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <minus></minus>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>k</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>n</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>w</ci>
        <ci>k</ci>
       </apply>
       <apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <csymbol cd="latexml">product</csymbol>
         <apply>
          <neq></neq>
          <ci>j</ci>
          <ci>k</ci>
         </apply>
        </apply>
        <apply>
         <minus></minus>
         <ci>X</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>z</ci>
          <ci>j</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>X</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <csymbol cd="latexml">product</csymbol>
        <apply>
         <eq></eq>
         <ci>j</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>n</ci>
      </apply>
      <apply>
       <minus></minus>
       <ci>X</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>z</ci>
        <ci>j</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   -\sum_{k=1}^{n}w_{k}\prod_{j\neq k}(X-z_{j})=f(X)-\prod_{j=1}^{n}(X-z_{j})
  </annotation>
 </semantics>
</math>

</p>

<p>at the points 

<math display="inline" id="Durand–Kerner_method:25">
 <semantics>
  <mrow>
   <mi>X</mi>
   <mo>=</mo>
   <msub>
    <mi>z</mi>
    <mi>k</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>X</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>z</ci>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X=z_{k}
  </annotation>
 </semantics>
</math>

, which results in</p>

<p>

<math display="block" id="Durand–Kerner_method:26">
 <semantics>
  <mrow>
   <mrow>
    <mo>-</mo>
    <mrow>
     <msub>
      <mi>w</mi>
      <mi>k</mi>
     </msub>
     <mrow>
      <munder>
       <mo largeop="true" movablelimits="false" symmetric="true">∏</mo>
       <mrow>
        <mi>j</mi>
        <mo>≠</mo>
        <mi>k</mi>
       </mrow>
      </munder>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <msub>
         <mi>z</mi>
         <mi>k</mi>
        </msub>
        <mo>-</mo>
        <msub>
         <mi>z</mi>
         <mi>j</mi>
        </msub>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <mrow>
     <msub>
      <mi>w</mi>
      <mi>k</mi>
     </msub>
     <msubsup>
      <mi>g</mi>
      <mover accent="true">
       <mi>z</mi>
       <mo stretchy="false">→</mo>
      </mover>
      <mo>′</mo>
     </msubsup>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>z</mi>
       <mi>k</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>z</mi>
      <mi>k</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>w</ci>
        <ci>k</ci>
       </apply>
       <apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <csymbol cd="latexml">product</csymbol>
         <apply>
          <neq></neq>
          <ci>j</ci>
          <ci>k</ci>
         </apply>
        </apply>
        <apply>
         <minus></minus>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>z</ci>
          <ci>k</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>z</ci>
          <ci>j</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>w</ci>
        <ci>k</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>g</ci>
         <apply>
          <ci>normal-→</ci>
          <ci>z</ci>
         </apply>
        </apply>
        <ci>normal-′</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>z</ci>
        <ci>k</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>f</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>z</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   -w_{k}\prod_{j\neq k}(z_{k}-z_{j})=-w_{k}g_{\vec{z}}^{\prime}(z_{k})=f(z_{k})
  </annotation>
 </semantics>
</math>

, that is 

<math display="inline" id="Durand–Kerner_method:27">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>w</mi>
     <mi>k</mi>
    </msub>
    <mo>=</mo>
    <mrow>
     <mo>-</mo>
     <mfrac>
      <mrow>
       <mi>f</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>z</mi>
         <mi>k</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mrow>
       <mstyle displaystyle="false">
        <msub>
         <mo largeop="true" symmetric="true">∏</mo>
         <mrow>
          <mi>j</mi>
          <mo>≠</mo>
          <mi>k</mi>
         </mrow>
        </msub>
       </mstyle>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <msub>
          <mi>z</mi>
          <mi>k</mi>
         </msub>
         <mo>-</mo>
         <msub>
          <mi>z</mi>
          <mi>j</mi>
         </msub>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mfrac>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>w</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <ci>f</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>z</ci>
        <ci>k</ci>
       </apply>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <csymbol cd="latexml">product</csymbol>
        <apply>
         <neq></neq>
         <ci>j</ci>
         <ci>k</ci>
        </apply>
       </apply>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>z</ci>
         <ci>k</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>z</ci>
         <ci>j</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w_{k}=-\frac{f(z_{k})}{\prod_{j\neq k}(z_{k}-z_{j})}.
  </annotation>
 </semantics>
</math>

</p>
<h2 id="root-inclusion-via-gerschgorins-circles">Root inclusion via Gerschgorin's circles</h2>

<p>In the <a href="quotient_ring" title="wikilink">quotient ring</a> (algebra) of <a href="residue_class" title="wikilink">residue classes</a> modulo ƒ(<em>X</em>), the multiplication by <em>X</em> defines an <a class="uri" href="endomorphism" title="wikilink">endomorphism</a> that has the zeros of ƒ(<em>X</em>) as <a href="eigenvalue" title="wikilink">eigenvalues</a> with the corresponding multiplicities. Choosing a basis, the multiplication operator is represented by its coefficient matrix <em>A</em>, the <a href="companion_matrix" title="wikilink">companion matrix</a> of ƒ(<em>X</em>) for this basis.</p>

<p>Since every polynomial can be reduced modulo ƒ(<em>X</em>) to a polynomial of degree <em>n</em> − 1 or lower, the space of residue classes can be identified with the space of polynomials of degree bounded by <em>n</em> − 1. A problem specific basis can be taken from <a href="Lagrange_interpolation" title="wikilink">Lagrange interpolation</a> as the set of <em>n</em> polynomials</p>

<p>

<math display="block" id="Durand–Kerner_method:28">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <msub>
       <mi>b</mi>
       <mi>k</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>X</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>=</mo>
     <mrow>
      <munder>
       <mo largeop="true" movablelimits="false" symmetric="true">∏</mo>
       <mrow>
        <mrow>
         <mn>1</mn>
         <mo>≤</mo>
         <mi>j</mi>
         <mo>≤</mo>
         <mi>n</mi>
        </mrow>
        <mo rspace="5.3pt">,</mo>
        <mrow>
         <mi>j</mi>
         <mo>≠</mo>
         <mi>k</mi>
        </mrow>
       </mrow>
      </munder>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>X</mi>
        <mo>-</mo>
        <msub>
         <mi>z</mi>
         <mi>j</mi>
        </msub>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo rspace="12.5pt">,</mo>
    <mrow>
     <mi>k</mi>
     <mo>=</mo>
     <mrow>
      <mn>1</mn>
      <mo>,</mo>
      <mi mathvariant="normal">…</mi>
      <mo>,</mo>
      <mi>n</mi>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <ci>k</ci>
      </apply>
      <ci>X</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <csymbol cd="latexml">product</csymbol>
       <apply>
        <csymbol cd="ambiguous">formulae-sequence</csymbol>
        <apply>
         <and></and>
         <apply>
          <leq></leq>
          <cn type="integer">1</cn>
          <ci>j</ci>
         </apply>
         <apply>
          <leq></leq>
          <share href="#.cmml">
          </share>
          <ci>n</ci>
         </apply>
        </apply>
        <apply>
         <neq></neq>
         <ci>j</ci>
         <ci>k</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <minus></minus>
       <ci>X</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>z</ci>
        <ci>j</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <ci>k</ci>
     <list>
      <cn type="integer">1</cn>
      <ci>normal-…</ci>
      <ci>n</ci>
     </list>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b_{k}(X)=\prod_{1\leq j\leq n,\;j\neq k}(X-z_{j}),\quad k=1,\dots,n,
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Durand–Kerner_method:29">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>z</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>z</mi>
     <mi>n</mi>
    </msub>
   </mrow>
   <mo>∈</mo>
   <mi>ℂ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <list>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>z</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>z</ci>
      <ci>n</ci>
     </apply>
    </list>
    <ci>ℂ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z_{1},\dots,z_{n}\in\mathbb{C}
  </annotation>
 </semantics>
</math>

 are pairwise different complex numbers. Note that the kernel functions for the Lagrange interpolation are 

<math display="inline" id="Durand–Kerner_method:30">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>L</mi>
     <mi>k</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <msub>
      <mi>b</mi>
      <mi>k</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>X</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mrow>
     <msub>
      <mi>b</mi>
      <mi>k</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>z</mi>
       <mi>k</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>L</ci>
      <ci>k</ci>
     </apply>
     <ci>X</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <ci>k</ci>
      </apply>
      <ci>X</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <ci>k</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>z</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L_{k}(X)=\frac{b_{k}(X)}{b_{k}(z_{k})}
  </annotation>
 </semantics>
</math>

.</p>

<p>For the multiplication operator applied to the basis polynomials one obtains from the Lagrange interpolation</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>

<math display="inline" id="Durand–Kerner_method:31">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mi>X</mi>
      <mo>⋅</mo>
      <msub>
       <mi>b</mi>
       <mi>k</mi>
      </msub>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>X</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo lspace="2.5pt" rspace="2.5pt">mod</mo>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>X</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <mi>X</mi>
      <mo>⋅</mo>
      <msub>
       <mi>b</mi>
       <mi>k</mi>
      </msub>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>X</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>X</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="latexml">modulo</csymbol>
     <apply>
      <times></times>
      <apply>
       <ci>normal-⋅</ci>
       <ci>X</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>b</ci>
        <ci>k</ci>
       </apply>
      </apply>
      <ci>X</ci>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>X</ci>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <apply>
       <ci>normal-⋅</ci>
       <ci>X</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>b</ci>
        <ci>k</ci>
       </apply>
      </apply>
      <ci>X</ci>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>X</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X\cdot b_{k}(X)\mod f(X)=X\cdot b_{k}(X)-f(X)
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Durand–Kerner_method:32">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∑</mo>
     <mrow>
      <mi>j</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>n</mi>
    </msubsup>
    <mrow>
     <mrow>
      <mo maxsize="160%" minsize="160%">(</mo>
      <mrow>
       <mrow>
        <mrow>
         <msub>
          <mi>z</mi>
          <mi>j</mi>
         </msub>
         <mo>⋅</mo>
         <msub>
          <mi>b</mi>
          <mi>k</mi>
         </msub>
        </mrow>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>z</mi>
          <mi>j</mi>
         </msub>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>-</mo>
       <mrow>
        <mi>f</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>z</mi>
          <mi>j</mi>
         </msub>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
      <mo maxsize="160%" minsize="160%">)</mo>
     </mrow>
     <mo>⋅</mo>
     <mfrac>
      <mrow>
       <msub>
        <mi>b</mi>
        <mi>j</mi>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>X</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mrow>
       <msub>
        <mi>b</mi>
        <mi>j</mi>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>z</mi>
         <mi>j</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mfrac>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <csymbol cd="latexml">absent</csymbol>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>j</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>n</ci>
     </apply>
     <apply>
      <ci>normal-⋅</ci>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <apply>
         <ci>normal-⋅</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>z</ci>
          <ci>j</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>b</ci>
          <ci>k</ci>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>z</ci>
         <ci>j</ci>
        </apply>
       </apply>
       <apply>
        <times></times>
        <ci>f</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>z</ci>
         <ci>j</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>b</ci>
         <ci>j</ci>
        </apply>
        <ci>X</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>b</ci>
         <ci>j</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>z</ci>
         <ci>j</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =\sum_{j=1}^{n}\Big(z_{j}\cdot b_{k}(z_{j})-f(z_{j})\Big)\cdot\frac{b_{j}(X)}{%
b_{j}(z_{j})}
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Durand–Kerner_method:33">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <msub>
       <mi>z</mi>
       <mi>k</mi>
      </msub>
      <mo>⋅</mo>
      <msub>
       <mi>b</mi>
       <mi>k</mi>
      </msub>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>X</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <mi>j</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>n</mi>
     </msubsup>
     <mrow>
      <mrow>
       <msub>
        <mi>w</mi>
        <mi>j</mi>
       </msub>
       <mo>⋅</mo>
       <msub>
        <mi>b</mi>
        <mi>j</mi>
       </msub>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>X</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <csymbol cd="latexml">absent</csymbol>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <ci>normal-⋅</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>z</ci>
        <ci>k</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>b</ci>
        <ci>k</ci>
       </apply>
      </apply>
      <ci>X</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>j</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>n</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <ci>normal-⋅</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>w</ci>
         <ci>j</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>b</ci>
         <ci>j</ci>
        </apply>
       </apply>
       <ci>X</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =z_{k}\cdot b_{k}(X)+\sum_{j=1}^{n}w_{j}\cdot b_{j}(X)
  </annotation>
 </semantics>
</math>

,</p></td>
</tr>
</tbody>
</table>

<p>where 

<math display="inline" id="Durand–Kerner_method:34">
 <semantics>
  <mrow>
   <msub>
    <mi>w</mi>
    <mi>j</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <mfrac>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>z</mi>
        <mi>j</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mrow>
      <msub>
       <mi>b</mi>
       <mi>j</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>z</mi>
        <mi>j</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mfrac>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>w</ci>
     <ci>j</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <ci>f</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>z</ci>
        <ci>j</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>b</ci>
        <ci>j</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>z</ci>
        <ci>j</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w_{j}=-\frac{f(z_{j})}{b_{j}(z_{j})}
  </annotation>
 </semantics>
</math>

 are again the Weierstrass updates.</p>

<p>The companion matrix of ƒ(<em>X</em>) is therefore</p>

<p>

<math display="block" id="Durand–Kerner_method:35">
 <semantics>
  <mrow>
   <mrow>
    <mi>A</mi>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mi>diag</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>z</mi>
        <mn>1</mn>
       </msub>
       <mo>,</mo>
       <mi mathvariant="normal">…</mi>
       <mo>,</mo>
       <msub>
        <mi>z</mi>
        <mi>n</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mrow>
       <mo>(</mo>
       <mtable displaystyle="true">
        <mtr>
         <mtd columnalign="center">
          <mn>1</mn>
         </mtd>
        </mtr>
        <mtr>
         <mtd columnalign="center">
          <mi mathvariant="normal">⋮</mi>
         </mtd>
        </mtr>
        <mtr>
         <mtd columnalign="center">
          <mn>1</mn>
         </mtd>
        </mtr>
       </mtable>
       <mo>)</mo>
      </mrow>
      <mo>⋅</mo>
      <mrow>
       <mo>(</mo>
       <msub>
        <mi>w</mi>
        <mn>1</mn>
       </msub>
       <mo>,</mo>
       <mi mathvariant="normal">…</mi>
       <mo>,</mo>
       <msub>
        <mi>w</mi>
        <mi>n</mi>
       </msub>
       <mo>)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>A</ci>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>diag</ci>
      <vector>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>z</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>normal-…</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>z</ci>
        <ci>n</ci>
       </apply>
      </vector>
     </apply>
     <apply>
      <ci>normal-⋅</ci>
      <matrix>
       <matrixrow>
        <cn type="integer">1</cn>
       </matrixrow>
       <matrixrow>
        <ci>normal-⋮</ci>
       </matrixrow>
       <matrixrow>
        <cn type="integer">1</cn>
       </matrixrow>
      </matrix>
      <vector>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>w</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>normal-…</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>w</ci>
        <ci>n</ci>
       </apply>
      </vector>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A=\mathrm{diag}(z_{1},\dots,z_{n})+\begin{pmatrix}1\\
\vdots\\
1\end{pmatrix}\cdot\left(w_{1},\dots,w_{n}\right).
  </annotation>
 </semantics>
</math>

</p>

<p>From the transposed matrix case of the <a href="Gershgorin_circle_theorem" title="wikilink">Gershgorin circle theorem</a> it follows that all eigenvalues of <em>A</em>, that is, all roots of ƒ(<em>X</em>), are contained in the union of the disks 

<math display="inline" id="Durand–Kerner_method:36">
 <semantics>
  <mrow>
   <mi>D</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>a</mi>
     <mrow>
      <mi>k</mi>
      <mo>,</mo>
      <mi>k</mi>
     </mrow>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>r</mi>
     <mi>k</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>D</ci>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <list>
       <ci>k</ci>
       <ci>k</ci>
      </list>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>r</ci>
      <ci>k</ci>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D(a_{k,k},r_{k})
  </annotation>
 </semantics>
</math>

 with a radius 

<math display="inline" id="Durand–Kerner_method:37">
 <semantics>
  <mrow>
   <msub>
    <mi>r</mi>
    <mi>k</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mo largeop="true" symmetric="true">∑</mo>
     <mrow>
      <mi>j</mi>
      <mo>≠</mo>
      <mi>k</mi>
     </mrow>
    </msub>
    <mrow>
     <mo mathsize="120%" stretchy="false">|</mo>
     <msub>
      <mi>a</mi>
      <mrow>
       <mi>j</mi>
       <mo>,</mo>
       <mi>k</mi>
      </mrow>
     </msub>
     <mo mathsize="120%" stretchy="false">|</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>r</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <neq></neq>
       <ci>j</ci>
       <ci>k</ci>
      </apply>
     </apply>
     <apply>
      <abs></abs>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <list>
        <ci>j</ci>
        <ci>k</ci>
       </list>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r_{k}=\sum_{j\neq k}\big|a_{j,k}\big|
  </annotation>
 </semantics>
</math>

.</p>

<p>Here one has 

<math display="inline" id="Durand–Kerner_method:38">
 <semantics>
  <mrow>
   <msub>
    <mi>a</mi>
    <mrow>
     <mi>k</mi>
     <mo>,</mo>
     <mi>k</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>z</mi>
     <mi>k</mi>
    </msub>
    <mo>+</mo>
    <msub>
     <mi>w</mi>
     <mi>k</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <list>
      <ci>k</ci>
      <ci>k</ci>
     </list>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>z</ci>
      <ci>k</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>w</ci>
      <ci>k</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{k,k}=z_{k}+w_{k}
  </annotation>
 </semantics>
</math>

, so the centers are the next iterates of the Weierstrass iteration, and radii 

<math display="inline" id="Durand–Kerner_method:39">
 <semantics>
  <mrow>
   <msub>
    <mi>r</mi>
    <mi>k</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>n</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo>|</mo>
     <msub>
      <mi>w</mi>
      <mi>k</mi>
     </msub>
     <mo>|</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>r</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <minus></minus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <abs></abs>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>w</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r_{k}=(n-1)\left|w_{k}\right|
  </annotation>
 </semantics>
</math>

 that are multiples of the Weierstrass updates. If the roots of ƒ(<em>X</em>) are all well isolated (relative to the computational precision) and the points 

<math display="inline" id="Durand–Kerner_method:40">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>z</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>z</mi>
     <mi>n</mi>
    </msub>
   </mrow>
   <mo>∈</mo>
   <mi>ℂ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <list>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>z</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>z</ci>
      <ci>n</ci>
     </apply>
    </list>
    <ci>ℂ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z_{1},\dots,z_{n}\in\mathbb{C}
  </annotation>
 </semantics>
</math>

 are sufficidently close approximations to these roots, then all the disks will become disjoint, so each one contains exactly one zero. The midpoints of the circles will be better approximations of the zeros.</p>

<p>Every conjugate matrix 

<math display="inline" id="Durand–Kerner_method:41">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mi>A</mi>
   <msup>
    <mi>T</mi>
    <mrow>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>T</ci>
    <ci>A</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>T</ci>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   TAT^{-1}
  </annotation>
 </semantics>
</math>

 of <em>A</em> is as well a companion matrix of ƒ(<em>X</em>). Choosing <em>T</em> as diagonal matrix leaves the structure of <em>A</em> invariant. The root close to 

<math display="inline" id="Durand–Kerner_method:42">
 <semantics>
  <msub>
   <mi>z</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>z</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z_{k}
  </annotation>
 </semantics>
</math>

 is contained in any isolated circle with center 

<math display="inline" id="Durand–Kerner_method:43">
 <semantics>
  <msub>
   <mi>z</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>z</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z_{k}
  </annotation>
 </semantics>
</math>

 regardless of <em>T</em>. Choosing the optimal diagonal matrix <em>T</em> for every index results in better estimates (see ref. Petkovic et al. 1995).</p>
<h2 id="convergence-results">Convergence results</h2>

<p>The connection between the Taylor series expansion and Newton's method suggests that the distance from 

<math display="inline" id="Durand–Kerner_method:44">
 <semantics>
  <mrow>
   <msub>
    <mi>z</mi>
    <mi>k</mi>
   </msub>
   <mo>+</mo>
   <msub>
    <mi>w</mi>
    <mi>k</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>z</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>w</ci>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z_{k}+w_{k}
  </annotation>
 </semantics>
</math>

 to the corresponding root is of the order 

<math display="inline" id="Durand–Kerner_method:45">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mrow>
      <mo stretchy="false">|</mo>
      <msub>
       <mi>w</mi>
       <mi>k</mi>
      </msub>
      <mo stretchy="false">|</mo>
     </mrow>
     <mn>2</mn>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <abs></abs>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>w</ci>
       <ci>k</ci>
      </apply>
     </apply>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(|w_{k}|^{2})
  </annotation>
 </semantics>
</math>

, if the root is well isolated from nearby roots and the approximation is sufficiently close to the root. So after the approximation is close, Newton's method converges <em>quadratically</em>; that is: the error is squared with every step (which will greatly reduce the error once it is less than 1). In the case of the Durand–Kerner method, convergence is quadratic if the vector 

<math display="inline" id="Durand–Kerner_method:46">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>z</mi>
    <mo stretchy="false">→</mo>
   </mover>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>z</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>z</mi>
     <mi>n</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>normal-→</ci>
     <ci>z</ci>
    </apply>
    <vector>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>z</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>z</ci>
      <ci>n</ci>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vec{z}=(z_{1},\dots,z_{n})
  </annotation>
 </semantics>
</math>

 is close to some permutation of the vector of the roots of ƒ.</p>

<p>For the conclusion of linear convergence there is a more specific result (see ref. Petkovic et al. 1995). If the initial vector 

<math display="inline" id="Durand–Kerner_method:47">
 <semantics>
  <mover accent="true">
   <mi>z</mi>
   <mo stretchy="false">→</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>z</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vec{z}
  </annotation>
 </semantics>
</math>

 and its vector of Weierstrass updates 

<math display="inline" id="Durand–Kerner_method:48">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>w</mi>
    <mo stretchy="false">→</mo>
   </mover>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>w</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>w</mi>
     <mi>n</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>normal-→</ci>
     <ci>w</ci>
    </apply>
    <vector>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>w</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>w</ci>
      <ci>n</ci>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vec{w}=(w_{1},\dots,w_{n})
  </annotation>
 </semantics>
</math>

 satisfies the inequality</p>

<p>

<math display="block" id="Durand–Kerner_method:49">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mrow>
       <mi>D</mi>
       <mrow>
        <mo>(</mo>
        <mrow>
         <msub>
          <mi>z</mi>
          <mi>k</mi>
         </msub>
         <mo>+</mo>
         <msub>
          <mi>w</mi>
          <mi>k</mi>
         </msub>
        </mrow>
        <mo>,</mo>
        <mrow>
         <mstyle displaystyle="false">
          <mfrac>
           <mn>1</mn>
           <mn>4</mn>
          </mfrac>
         </mstyle>
         <mrow>
          <mo stretchy="false">|</mo>
          <msub>
           <mi>w</mi>
           <mi>k</mi>
          </msub>
          <mo stretchy="false">|</mo>
         </mrow>
        </mrow>
        <mo>)</mo>
       </mrow>
      </mrow>
      <mi>k</mi>
     </mrow>
     <mo>=</mo>
     <mn>1</mn>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <mi>n</mi>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <list>
      <apply>
       <times></times>
       <ci>D</ci>
       <interval closure="open">
        <apply>
         <plus></plus>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>z</ci>
          <ci>k</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>w</ci>
          <ci>k</ci>
         </apply>
        </apply>
        <apply>
         <times></times>
         <apply>
          <divide></divide>
          <cn type="integer">1</cn>
          <cn type="integer">4</cn>
         </apply>
         <apply>
          <abs></abs>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>w</ci>
           <ci>k</ci>
          </apply>
         </apply>
        </apply>
       </interval>
      </apply>
      <ci>k</ci>
     </list>
     <cn type="integer">1</cn>
    </apply>
    <list>
     <ci>normal-…</ci>
     <ci>n</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle D\left(z_{k}+w_{k},\frac{1}{4}|w_{k}|\right)\qquad k=1,\dots,n,
  </annotation>
 </semantics>
</math>

 are disjoint and linear convergence with a contraction factor of <em>1/2</em> holds. Further, the inclusion disks can in this case be chosen as</p>

<p><span class="LaTeX">$$\textstyle D\left(z_k+w_k,\frac14 |w_k|\right)\qquad k = 1,\dots, n,$$</span></p>

<p>each containing exactly one zero of ƒ.</p>
<h2 id="references">References</h2>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li>Bo Jacoby, <em>Nulpunkter for polynomier</em>, CAE-nyt (a periodical for Dansk CAE Gruppe [Danish CAE Group]), 1988.</li>
<li>Agnethe Knudsen, <em>Numeriske Metoder</em> (lecture notes), Københavns Teknikum.</li>
<li>Bo Jacoby, <em>Numerisk løsning af ligninger</em>, Bygningsstatiske meddelelser (Published by Danish Society for Structural Science and Engineering) volume 63 no. 3-4, 1992, pp. 83–105.</li>
<li></li>
<li><a href="Victor_Pan" title="wikilink">Victor Pan</a> (May 2002): <a href="http://www.cs.gc.cuny.edu/tr/techreport.php?id=26"><em>Univariate Polynomial Root-Finding with Lower Computational Precision and Higher Convergence Rates</em></a>. Tech-Report, City University of New York</li>
<li></li>
<li>Jan Verschelde, <em><a href="http://www2.math.uic.edu/~jan/mcs471f03/Project_Two/proj2/node2.html">The method of Weierstrass (also known as the Durand-Kerner method)</a></em>, 2003.</li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><em><a href="http://home.roadrunner.com/~jbmatthews/misc/groots.html">Ada Generic_Roots using the Durand-Kerner Method</a></em> — an <a href="Open-Source" title="wikilink">open-source</a> implementation in <a href="Ada_programming_language" title="wikilink">Ada</a></li>
</ul>
<ul>
<li><em><a href="http://sites.google.com/site/drjohnbmatthews/polyroots">Polynomial Roots</a></em> — an <a href="Open-Source" title="wikilink">open-source</a> implementation in <a href="Java_programming_language" title="wikilink">Java</a></li>
</ul>
<ul>
<li><em><a href="http://www.cpc.wmin.ac.uk/~spiesf/Solve/solve.html">Roots Extraction from Polynomials : The Durand-Kerner Method</a></em> — contains a <a href="Java_applet" title="wikilink">Java applet</a> demonstration</li>
</ul>

<p>"</p>

<p><a href="Category:Root-finding_algorithms" title="wikilink">Category:Root-finding algorithms</a></p>
</body>
</html>
