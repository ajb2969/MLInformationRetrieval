<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="988">Backjumping</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Backjumping</h1>
<hr/>

<p>In <a class="uri" href="backtracking" title="wikilink">backtracking</a> <a href="algorithm" title="wikilink">algorithms</a>, <strong>backjumping</strong> is a technique that reduces <a href="Candidate_solution" title="wikilink">search space</a>, therefore increasing efficiency. While backtracking always goes up one level in the <a href="search_tree" title="wikilink">search tree</a> when all values for a variable have been tested, backjumping may go up more levels. In this article, a fixed order of evaluation of variables 

<math display="inline" id="Backjumping:0">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>x</mi>
    <mi>n</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>n</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1},\ldots,x_{n}
  </annotation>
 </semantics>
</math>

 is used, but the same considerations apply to a dynamic order of evaluation.</p>

<p>Image:Backtracking-no-backjumping.svg|A search tree visited by regular backtracking Image:Backtracking-with-backjumping.svg|A backjump: the grey node is not visited</p>
<h2 id="definition">Definition</h2>

<p>Whenever backtracking has tried all values for a variable without finding any solution, it reconsiders the last of the previously assigned variables, changing its value or further backtracking if no other values are to be tried. If 

<math display="inline" id="Backjumping:1">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>a</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mrow>
    <msub>
     <mi>x</mi>
     <mi>k</mi>
    </msub>
    <mo>=</mo>
    <msub>
     <mi>a</mi>
     <mi>k</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <list>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
     </list>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>k</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <ci>k</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1}=a_{1},\ldots,x_{k}=a_{k}
  </annotation>
 </semantics>
</math>

 is the current partial assignment and all values for 

<math display="inline" id="Backjumping:2">
 <semantics>
  <msub>
   <mi>x</mi>
   <mrow>
    <mi>k</mi>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <apply>
     <plus></plus>
     <ci>k</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{k+1}
  </annotation>
 </semantics>
</math>

 have been tried without finding a solution, backtracking concludes that no solution extending 

<math display="inline" id="Backjumping:3">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>a</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mrow>
    <msub>
     <mi>x</mi>
     <mi>k</mi>
    </msub>
    <mo>=</mo>
    <msub>
     <mi>a</mi>
     <mi>k</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <list>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
     </list>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>k</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <ci>k</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1}=a_{1},\ldots,x_{k}=a_{k}
  </annotation>
 </semantics>
</math>

 exists. It then "goes up" to 

<math display="inline" id="Backjumping:4">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{k}
  </annotation>
 </semantics>
</math>

, changing its value if possible, backtracking again otherwise.</p>

<p>The partial assignment is not always necessary in full to prove that no value of 

<math display="inline" id="Backjumping:5">
 <semantics>
  <msub>
   <mi>x</mi>
   <mrow>
    <mi>k</mi>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <apply>
     <plus></plus>
     <ci>k</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{k+1}
  </annotation>
 </semantics>
</math>

 lead to a solution. In particular, a prefix of the partial assignment may have the same property, that is, there exists an index 

<math display="inline" id="Backjumping:6">
 <semantics>
  <msub>
   <mi>x</mi>
   <mrow>
    <mi>k</mi>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <apply>
     <plus></plus>
     <ci>k</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{k+1}
  </annotation>
 </semantics>
</math>

 cannot be extended to form a solution with whatever value for 

<math display="inline" id="Backjumping:7">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{j}
  </annotation>
 </semantics>
</math>

. If the algorithm can prove this fact, it can directly consider a different value for 

<math display="inline" id="Backjumping:8">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{k}
  </annotation>
 </semantics>
</math>

 instead of reconsidering 

<math display="inline" id="Backjumping:9">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mn>1</mn>
   </msub>
   <msub>
    <mi>x</mi>
    <mn>2</mn>
   </msub>
   <msub>
    <mi>x</mi>
    <mn>3</mn>
   </msub>
   <msub>
    <mi>x</mi>
    <mn>4</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">3</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">4</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1}x_{2}x_{3}x_{4}
  </annotation>
 </semantics>
</math>

 as it would normally do.</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;"><figure><b>(Figure)</b>
<figcaption>Backjump-variables-1.svg</figcaption>
</figure></td>
<td style="text-align: left;"><figure><b>(Figure)</b>
<figcaption>Backjump-variables-2.svg</figcaption>
</figure></td>
<td style="text-align: left;"><figure><b>(Figure)</b>
<figcaption>Backjump-variables-3.svg</figcaption>
</figure></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>An example in which the current assignment to 

<math display="inline" id="Backjumping:10">
 <semantics>
  <msub>
   <mi>x</mi>
   <mn>5</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <cn type="integer">5</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{5}
  </annotation>
 </semantics>
</math>

 has been unsuccessfully tried with every possible value of 

<math display="inline" id="Backjumping:11">
 <semantics>
  <msub>
   <mi>x</mi>
   <mn>4</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <cn type="integer">4</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{4}
  </annotation>
 </semantics>
</math>

. Backtracking goes back to 

<math display="inline" id="Backjumping:12">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
    <msub>
     <mi>x</mi>
     <mn>2</mn>
    </msub>
    <msub>
     <mi>x</mi>
     <mn>5</mn>
    </msub>
   </mrow>
   <mo>=</mo>
   <mn>211</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">5</cn>
     </apply>
    </apply>
    <cn type="integer">211</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1}x_{2}x_{5}=211
  </annotation>
 </semantics>
</math>

, trying to assign it a new value.</p></td>
<td style="text-align: left;">
<p>Instead of backtracking, the algorithm makes some further elaboration, proving that the evaluations 

<math display="inline" id="Backjumping:13">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
    <msub>
     <mi>x</mi>
     <mn>5</mn>
    </msub>
   </mrow>
   <mo>=</mo>
   <mn>22</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">5</cn>
     </apply>
    </apply>
    <cn type="integer">22</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1}x_{5}=22
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Backjumping:14">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
    <msub>
     <mi>x</mi>
     <mn>2</mn>
    </msub>
    <msub>
     <mi>x</mi>
     <mn>5</mn>
    </msub>
   </mrow>
   <mo>=</mo>
   <mn>213</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">5</cn>
     </apply>
    </apply>
    <cn type="integer">213</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1}x_{2}x_{5}=213
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="Backjumping:15">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mn>1</mn>
   </msub>
   <msub>
    <mi>x</mi>
    <mn>2</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1}x_{2}
  </annotation>
 </semantics>
</math>

 are not part of any solution.</p></td>
<td style="text-align: left;">
<p>As a result, the current evaluation of 

<math display="inline" id="Backjumping:16">
 <semantics>
  <msub>
   <mi>x</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{2}
  </annotation>
 </semantics>
</math>

 is not part of any solution, and the algorithm can directly backjump to 

<math display="inline" id="Backjumping:17">
 <semantics>
  <msub>
   <mi>x</mi>
   <mrow>
    <mi>k</mi>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <apply>
     <plus></plus>
     <ci>k</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{k+1}
  </annotation>
 </semantics>
</math>

, trying a new value for it.</p></td>
</tr>
</tbody>
</table>

<p>The efficiency of a backjumping algorithm depends on how high it is able to backjump. Ideally, the algorithm could jump from 

<math display="inline" id="Backjumping:18">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{j}
  </annotation>
 </semantics>
</math>

 to whichever variable 

<math display="inline" id="Backjumping:19">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>x</mi>
    <mi>j</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>j</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1},\ldots,x_{j}
  </annotation>
 </semantics>
</math>

 is such that the current assignment to 

<math display="inline" id="Backjumping:20">
 <semantics>
  <msub>
   <mi>x</mi>
   <mrow>
    <mi>k</mi>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <apply>
     <plus></plus>
     <ci>k</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{k+1}
  </annotation>
 </semantics>
</math>

 cannot be extended to form a solution with any value of 

<math display="inline" id="Backjumping:21">
 <semantics>
  <mi>j</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>j</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   j
  </annotation>
 </semantics>
</math>

. If this is the case, 

<math display="inline" id="Backjumping:22">
 <semantics>
  <msub>
   <mi>x</mi>
   <mrow>
    <mi>k</mi>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <apply>
     <plus></plus>
     <ci>k</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{k+1}
  </annotation>
 </semantics>
</math>

 is called a <em>safe jump</em>.</p>

<p>Establishing whether a jump is safe is not always feasible, as safe jumps are defined in terms of the set of solutions, which is what the algorithm is trying to find. In practice, backjumping algorithms use the lowest index they can efficiently prove to be a safe jump. Different algorithms use different methods for determining whether a jump is safe. These methods have different cost, but a higher cost of finding a higher safe jump may be traded off a reduced amount of search due to skipping parts of the search tree.</p>
<h2 id="backjumping-at-leaf-nodes">Backjumping at leaf nodes</h2>

<p>The simplest condition in which backjumping is possible is when all values of a variable have been proved inconsistent without further branching. In <a href="constraint_satisfaction" title="wikilink">constraint satisfaction</a>, a partial evaluation is <em>consistent</em> if and only if it satisfies all constraints involving the assigned variables, and <em>inconsistent</em> otherwise. It might be the case that a consistent partial solution cannot be extended to a consistent complete solution because some of the unassigned variables may not be assigned without violating other constraints.</p>

<p>The condition in which all values of a given variable 

<math display="inline" id="Backjumping:23">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <msub>
      <mi>x</mi>
      <mi>k</mi>
     </msub>
    </mrow>
    <mo>=</mo>
    <msub>
     <mi>a</mi>
     <mn>1</mn>
    </msub>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>a</mi>
     <mi>k</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <list>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>k</ci>
      </apply>
     </list>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <list>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <ci>k</ci>
     </apply>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1},\ldots,x_{k}=a_{1},\ldots,a_{k}
  </annotation>
 </semantics>
</math>

 are inconsistent with the current partial solution 

<math display="inline" id="Backjumping:24">
 <semantics>
  <msub>
   <mi>x</mi>
   <mrow>
    <mi>k</mi>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <apply>
     <plus></plus>
     <ci>k</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{k+1}
  </annotation>
 </semantics>
</math>

 is called a <em>leaf dead end</em>. This happens exactly when the variable 

<math display="inline" id="Backjumping:25">
 <semantics>
  <msub>
   <mi>x</mi>
   <mrow>
    <mi>k</mi>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <apply>
     <plus></plus>
     <ci>k</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{k+1}
  </annotation>
 </semantics>
</math>

 is a leaf of the search tree (which correspond to nodes having only leaves as children in the figures of this article.)</p>

<p>The backjumping algorithm by Gaschnig does a backjump only in leaf dead ends. In other words, it works differently from backtracking only when every possible value of 

<math display="inline" id="Backjumping:26">
 <semantics>
  <msub>
   <mi>a</mi>
   <mrow>
    <mi>k</mi>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>a</ci>
    <apply>
     <plus></plus>
     <ci>k</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{k+1}
  </annotation>
 </semantics>
</math>

 has been tested and resulted inconsistent without the need of branching over another variable.</p>

<p>A safe jump can be found by simply evaluating, for every value 

<math display="inline" id="Backjumping:27">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <msub>
      <mi>x</mi>
      <mi>k</mi>
     </msub>
    </mrow>
    <mo>=</mo>
    <msub>
     <mi>a</mi>
     <mn>1</mn>
    </msub>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>a</mi>
     <mi>k</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <list>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>k</ci>
      </apply>
     </list>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <list>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <ci>k</ci>
     </apply>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1},\ldots,x_{k}=a_{1},\ldots,a_{k}
  </annotation>
 </semantics>
</math>

, the shortest prefix of 

<math display="inline" id="Backjumping:28">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mrow>
     <mi>k</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo>=</mo>
   <msub>
    <mi>a</mi>
    <mrow>
     <mi>k</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <apply>
      <plus></plus>
      <ci>k</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <apply>
      <plus></plus>
      <ci>k</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{k+1}=a_{k+1}
  </annotation>
 </semantics>
</math>

 inconsistent with 

<math display="inline" id="Backjumping:29">
 <semantics>
  <msub>
   <mi>a</mi>
   <mrow>
    <mi>k</mi>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>a</ci>
    <apply>
     <plus></plus>
     <ci>k</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{k+1}
  </annotation>
 </semantics>
</math>

. In other words, if 

<math display="inline" id="Backjumping:30">
 <semantics>
  <msub>
   <mi>x</mi>
   <mrow>
    <mi>k</mi>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <apply>
     <plus></plus>
     <ci>k</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{k+1}
  </annotation>
 </semantics>
</math>

 is a possible value for 

<math display="inline" id="Backjumping:31">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mn>1</mn>
   </msub>
   <mo>=</mo>
   <msub>
    <mi>a</mi>
    <mn>1</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1}=a_{1}
  </annotation>
 </semantics>
</math>

, the algorithm checks the consistency of the following evaluations:</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>

<math display="inline" id="Backjumping:32">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mrow>
     <mi>k</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo>=</mo>
   <msub>
    <mi>a</mi>
    <mrow>
     <mi>k</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <apply>
      <minus></minus>
      <ci>k</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <apply>
      <minus></minus>
      <ci>k</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{k-1}=a_{k-1}
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>...</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Backjumping:33">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mi>k</mi>
   </msub>
   <mo>=</mo>
   <msub>
    <mi>a</mi>
    <mi>k</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{k}=a_{k}
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Backjumping:34">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mrow>
     <mi>k</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo>=</mo>
   <msub>
    <mi>a</mi>
    <mrow>
     <mi>k</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <apply>
      <plus></plus>
      <ci>k</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <apply>
      <plus></plus>
      <ci>k</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{k+1}=a_{k+1}
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Backjumping:35">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mn>1</mn>
   </msub>
   <mo>=</mo>
   <msub>
    <mi>a</mi>
    <mn>1</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1}=a_{1}
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>

<math display="inline" id="Backjumping:36">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mrow>
     <mi>k</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo>=</mo>
   <msub>
    <mi>a</mi>
    <mrow>
     <mi>k</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <apply>
      <minus></minus>
      <ci>k</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <apply>
      <minus></minus>
      <ci>k</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{k-1}=a_{k-1}
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>...</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Backjumping:37">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mrow>
     <mi>k</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo>=</mo>
   <msub>
    <mi>a</mi>
    <mrow>
     <mi>k</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <apply>
      <plus></plus>
      <ci>k</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <apply>
      <plus></plus>
      <ci>k</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{k+1}=a_{k+1}
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Backjumping:38">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mn>1</mn>
   </msub>
   <mo>=</mo>
   <msub>
    <mi>a</mi>
    <mn>1</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1}=a_{1}
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>...</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>

<math display="inline" id="Backjumping:39">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mrow>
     <mi>k</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo>=</mo>
   <msub>
    <mi>a</mi>
    <mrow>
     <mi>k</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <apply>
      <plus></plus>
      <ci>k</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <apply>
      <plus></plus>
      <ci>k</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{k+1}=a_{k+1}
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Backjumping:40">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mrow>
     <mi>k</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo>=</mo>
   <msub>
    <mi>a</mi>
    <mrow>
     <mi>k</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <apply>
      <plus></plus>
      <ci>k</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <apply>
      <plus></plus>
      <ci>k</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{k+1}=a_{k+1}
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
</tbody>
</table>

<p>The smallest index (lowest the listing) for which evaluations are inconsistent would be a safe jump if 

<math display="inline" id="Backjumping:41">
 <semantics>
  <msub>
   <mi>x</mi>
   <mrow>
    <mi>k</mi>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <apply>
     <plus></plus>
     <ci>k</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{k+1}
  </annotation>
 </semantics>
</math>

 were the only possible value for 

<math display="inline" id="Backjumping:42">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mrow>
     <mi>k</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo>=</mo>
   <msub>
    <mi>a</mi>
    <mrow>
     <mi>k</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <apply>
      <plus></plus>
      <ci>k</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <apply>
      <plus></plus>
      <ci>k</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{k+1}=a_{k+1}
  </annotation>
 </semantics>
</math>

. Since every variable can usually take more than one value, the maximal index that comes out from the check for each value is a safe jump, and is the point where Gaschnig's algorithm jumps.</p>

<p>In practice, the algorithm can check the evaluations above at the same time it is checking the consistency of 

<math display="inline" id="Backjumping:43">
 <semantics>
  <msub>
   <mi>x</mi>
   <mrow>
    <mi>k</mi>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <apply>
     <plus></plus>
     <ci>k</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{k+1}
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="backjumping-at-internal-nodes">Backjumping at internal nodes</h2>

<p>The previous algorithm only backjumps when the values of a variable can be shown inconsistent with the current partial solution without further branching. In other words, it allows for a backjump only at leaf nodes in the search tree.</p>

<p>An internal node of the search tree represents an assignment of a variable that is consistent with the previous ones. If no solution extends this assignment, the previous algorithm always backtracks: no backjump is done in this case.</p>

<p>Backjumping at internal nodes cannot be done as for leaf nodes. Indeed, if some evaluations of 

<math display="inline" id="Backjumping:44">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mrow>
     <mi>k</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo>=</mo>
   <msub>
    <mi>a</mi>
    <mrow>
     <mi>k</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <apply>
      <plus></plus>
      <ci>k</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <apply>
      <plus></plus>
      <ci>k</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{k+1}=a_{k+1}
  </annotation>
 </semantics>
</math>

 required branching, it is because they are consistent with the current assignment. As a result, searching for a prefix that is inconsistent with these values of the last variable does not succeed.</p>

<p>In such cases, what proved an evaluation 

<math display="inline" id="Backjumping:45">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>x</mi>
    <mi>k</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>k</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1},\ldots,x_{k}
  </annotation>
 </semantics>
</math>

 not to be part of a solution with the current partial evaluation 

<math display="inline" id="Backjumping:46">
 <semantics>
  <msub>
   <mi>x</mi>
   <mrow>
    <mi>k</mi>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <apply>
     <plus></plus>
     <ci>k</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{k+1}
  </annotation>
 </semantics>
</math>

 is the <a href="Recursion" title="wikilink">recursive</a> search. In particular, the algorithm "knows" that no solution exists from this point on because it comes back to this node instead of stopping after having found a solution.</p>

<p>This return is due to a number of <em>dead ends</em>, points where the algorithm has proved a partial solution inconsistent. In order to further backjump, the algorithm has to take into account that the impossibility of finding solutions is due to these dead ends. In particular, the safe jumps are indexes of prefixes that still make these dead ends to be inconsistent partial solutions.</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;"><figure><b>(Figure)</b>
<figcaption>Dead-ends-1.svg</figcaption>
</figure></td>
<td style="text-align: left;"><figure><b>(Figure)</b>
<figcaption>Dead-ends-1a.svg</figcaption>
</figure></td>
<td style="text-align: left;"><figure><b>(Figure)</b>
<figcaption>Dead-ends-2.svg</figcaption>
</figure></td>
<td style="text-align: left;"><figure><b>(Figure)</b>
<figcaption>Dead-ends-3.svg</figcaption>
</figure></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>In this example, the algorithm come back to 

<math display="inline" id="Backjumping:47">
 <semantics>
  <msub>
   <mi>x</mi>
   <mrow>
    <mi>k</mi>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <apply>
     <plus></plus>
     <ci>k</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{k+1}
  </annotation>
 </semantics>
</math>

, after trying all its possible values, because of the three crossed points of inconsistency.</p></td>
<td style="text-align: left;">
<p>The second point remains inconsistent even if the values of 

<math display="inline" id="Backjumping:48">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{k}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Backjumping:49">
 <semantics>
  <msub>
   <mi>x</mi>
   <mrow>
    <mi>k</mi>
    <mo>-</mo>
    <mn>2</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <apply>
     <minus></minus>
     <ci>k</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{k-2}
  </annotation>
 </semantics>
</math>

 are removed from its partial evaluation (note that the values of a variable are in its children)</p></td>
<td style="text-align: left;">
<p>The other inconsistent evaluations remains so even without 

<math display="inline" id="Backjumping:50">
 <semantics>
  <msub>
   <mi>x</mi>
   <mrow>
    <mi>k</mi>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <apply>
     <minus></minus>
     <ci>k</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{k-1}
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Backjumping:51">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{k}
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="Backjumping:52">
 <semantics>
  <msub>
   <mi>x</mi>
   <mrow>
    <mi>k</mi>
    <mo>-</mo>
    <mn>2</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <apply>
     <minus></minus>
     <ci>k</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{k-2}
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>The algorithm can backjump to 

<math display="inline" id="Backjumping:53">
 <semantics>
  <msub>
   <mi>x</mi>
   <mrow>
    <mi>k</mi>
    <mo>-</mo>
    <mn>2</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <apply>
     <minus></minus>
     <ci>k</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{k-2}
  </annotation>
 </semantics>
</math>

 since this is the lowest variables that maintains all inconsistencies. A new value for 

<math display="inline" id="Backjumping:54">
 <semantics>
  <msub>
   <mi>x</mi>
   <mrow>
    <mi>k</mi>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <apply>
     <plus></plus>
     <ci>k</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{k+1}
  </annotation>
 </semantics>
</math>

 will be tried.</p></td>
</tr>
</tbody>
</table>

<p>In other words, when all values of 

<math display="inline" id="Backjumping:55">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i}
  </annotation>
 </semantics>
</math>

 have been tried, the algorithm can backjump to a variable 

<math display="inline" id="Backjumping:56">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>x</mi>
    <mi>i</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>i</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1},\ldots,x_{i}
  </annotation>
 </semantics>
</math>

 provided that the current truth evaluation of 

<math display="inline" id="Backjumping:57">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mrow>
     <mi>k</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>x</mi>
    <mrow>
     <mi>k</mi>
     <mo>+</mo>
     <mn>2</mn>
    </mrow>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <apply>
      <plus></plus>
      <ci>k</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <apply>
      <plus></plus>
      <ci>k</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <ci>normal-…</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{k+1},x_{k+2},...
  </annotation>
 </semantics>
</math>

 is inconsistent with all the truth evaluations of 

<math display="inline" id="Backjumping:58">
 <semantics>
  <msub>
   <mi>x</mi>
   <mrow>
    <mi>k</mi>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <apply>
     <plus></plus>
     <ci>k</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{k+1}
  </annotation>
 </semantics>
</math>

 in the leaf nodes that are descendants of the node 

<math display="inline" id="Backjumping:59">
 <semantics>
  <msub>
   <mi>x</mi>
   <mrow>
    <mi>k</mi>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <apply>
     <plus></plus>
     <ci>k</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{k+1}
  </annotation>
 </semantics>
</math>

.</p>
<h3 id="simplifications">Simplifications</h3>

<p> Due to the potentially high number of nodes that are in the subtree of 

<math display="inline" id="Backjumping:60">
 <semantics>
  <msub>
   <mi>x</mi>
   <mrow>
    <mi>k</mi>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <apply>
     <plus></plus>
     <ci>k</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{k+1}
  </annotation>
 </semantics>
</math>

, the information that is necessary to safely backjump from 

<math display="inline" id="Backjumping:61">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>l</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>l</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{l}
  </annotation>
 </semantics>
</math>

 is collected during the visit of its subtree. Finding a safe jump can be simplified by two considerations. The first is that the algorithm needs a safe jump, but still works with a jump that is not the highest possible safe jump.</p>

<p>The second simplification is that nodes in the subtree of 

<math display="inline" id="Backjumping:62">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>l</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>l</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{l}
  </annotation>
 </semantics>
</math>

 that have been skipped by a backjump can be ignored while looking for a backjump for 

<math display="inline" id="Backjumping:63">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>m</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{m}
  </annotation>
 </semantics>
</math>

. More precisely, all nodes skipped by a backjump from node 

<math display="inline" id="Backjumping:64">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>l</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>l</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{l}
  </annotation>
 </semantics>
</math>

 up to node 

<math display="inline" id="Backjumping:65">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>m</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{m}
  </annotation>
 </semantics>
</math>

 are irrelevant to the subtree rooted at 

<math display="inline" id="Backjumping:66">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>l</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>l</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{l}
  </annotation>
 </semantics>
</math>

, and also irrelevant are their other subtrees.</p>

<p>Indeed, if an algorithm went down from node 

<math display="inline" id="Backjumping:67">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>m</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{m}
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Backjumping:68">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>l</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>l</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{l}
  </annotation>
 </semantics>
</math>

 via a path but backjumps in its way back, then it could have gone directly from 

<math display="inline" id="Backjumping:69">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>m</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{m}
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Backjumping:70">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>l</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>l</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{l}
  </annotation>
 </semantics>
</math>

 instead. Indeed, the backjump indicates that the nodes between 

<math display="inline" id="Backjumping:71">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>m</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{m}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Backjumping:72">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>m</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{m}
  </annotation>
 </semantics>
</math>

 are irrelevant to the subtree rooted at 

<math display="inline" id="Backjumping:73">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>l</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>l</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{l}
  </annotation>
 </semantics>
</math>

. In other words, a backjump indicates that the visit of a region of the search tree had been a mistake. This part of the search tree can therefore be ignored when considering a possible backjump from 

<math display="inline" id="Backjumping:74">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>x</mi>
    <mi>k</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>k</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1},\ldots,x_{k}
  </annotation>
 </semantics>
</math>

 or from one of its ancestors.</p>

<p> This fact can be exploited by collecting, in each node, a set of previously assigned variables whose evaluation suffices to prove that no solution exists in the subtree rooted at the node. This set is built during the execution of the algorithm. When retracting from a node, this set is removed the variable of the node and collected in the set of the destination of backtracking or backjumping. Since nodes that are skipped from backjumping are never retracted from, their sets are automatically ignored.</p>
<h3 id="graph-based-backjumping">Graph-based backjumping</h3>

<p>The rationale of graph-based backjumping is that a safe jump can be found by checking which of the variables 

<math display="inline" id="Backjumping:75">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mrow>
     <mi>k</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>x</mi>
    <mrow>
     <mi>k</mi>
     <mo>+</mo>
     <mn>2</mn>
    </mrow>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <apply>
      <plus></plus>
      <ci>k</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <apply>
      <plus></plus>
      <ci>k</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <ci>normal-…</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{k+1},x_{k+2},...
  </annotation>
 </semantics>
</math>

 are in a constraint with the variables 

<math display="inline" id="Backjumping:76">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i}
  </annotation>
 </semantics>
</math>

 that are instantiated in leaf nodes. For every leaf node and every variable 

<math display="inline" id="Backjumping:77">
 <semantics>
  <mrow>
   <mi>i</mi>
   <mo>></mo>
   <mi>k</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <ci>i</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i>k
  </annotation>
 </semantics>
</math>

 of index 

<math display="inline" id="Backjumping:78">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 that is instantiated there, the indexes less than or equal to 

<math display="inline" id="Backjumping:79">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i}
  </annotation>
 </semantics>
</math>

 whose variable is in a constraint with 

<math display="inline" id="Backjumping:80">
 <semantics>
  <msub>
   <mi>x</mi>
   <mrow>
    <mi>k</mi>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <apply>
     <plus></plus>
     <ci>k</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{k+1}
  </annotation>
 </semantics>
</math>

 can be used to find safe jumps. In particular, when all values for 

<math display="inline" id="Backjumping:81">
 <semantics>
  <msub>
   <mi>x</mi>
   <mrow>
    <mi>k</mi>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <apply>
     <plus></plus>
     <ci>k</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{k+1}
  </annotation>
 </semantics>
</math>

 have been tried, this set contains the indexes of the variables whose evaluations allow proving that no solution can be found by visiting the subtree rooted at 

<math display="inline" id="Backjumping:82">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

. As a result, the algorithm can backjump to the highest index in this set.</p>

<p>The fact that nodes skipped by backjumping can be ignored when considering a further backjump can be exploited by the following algorithm. When retracting from a leaf node, the set of variables that are in constraint with it is created and "sent back" to its parent, or ancestor in case of backjumping. At every internal node, a set of variables is maintained. Every time a set of variables is received from one of its children or descendant, their variables are added to the maintained set. When further backtracking or backjumping from the node, the variable of the node is removed from this set, and the set is sent to the node that is the destination of backtracking or backjumping. This algorithm works because the set maintained in a node collects all variables that are relevant to prove unsatisfiability in the leaves that are descendant of this node. Since sets of variables are only sent when retracing from nodes, the sets collected at nodes skipped by backjumping are automatically ignored.</p>
<h3 id="conflict-based-backjumping-aka-conflict-directed-backjumping-cbj">Conflict-based backjumping (aka conflict-directed backjumping (cbj))</h3>

<p>A still more refined backjumping algorithm, sometimes able to achieve larger backjumps, is based on checking not only the common presence of two variables in the same constraint but also on whether the constraint actually caused inconsistency. In particular, this algorithm collects one of the violated constraints in every leaf. At every node, the highest index of a variable that is in one of the constraints collected at the leaves is a safe jump.</p>

<p>While the violated constraint chosen in each leaf does not affect the safeness of the resulting jump, choosing constraints of highest possible indices increases the highness of the jump. For this reason, conflict-based backjumping orders constraints in such a way constraints over lower indices variables are preferred over constraints on higher index variables.</p>

<p>Formally, a constraint 

<math display="inline" id="Backjumping:83">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>

 is preferred over another one 

<math display="inline" id="Backjumping:84">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

 if the highest index of a variable in 

<math display="inline" id="Backjumping:85">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>

 but not in 

<math display="inline" id="Backjumping:86">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>

 is lower than the highest index of a variable in 

<math display="inline" id="Backjumping:87">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

 but not in 

<math display="inline" id="Backjumping:88">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

. In other words, excluding common variables, the constraint that has the all lower indices is preferred.</p>

<p>In a leaf node, the algorithm chooses the lowest index 

<math display="inline" id="Backjumping:89">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>x</mi>
    <mi>i</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>i</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1},\ldots,x_{i}
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Backjumping:90">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>+</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>k</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k+1
  </annotation>
 </semantics>
</math>

 is inconsistent with the last variable evaluated in the leaf. Among the constraints that are violated in this evaluation, it chooses the most preferred one, and collects all its indices less than 

<math display="inline" id="Backjumping:91">
 <semantics>
  <msub>
   <mi>x</mi>
   <mrow>
    <mi>k</mi>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <apply>
     <plus></plus>
     <ci>k</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{k+1}
  </annotation>
 </semantics>
</math>

. This way, when the algorithm comes back to the variable 

<math display="inline" id="Backjumping:92">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

, the lowest collected index identifies a safe jump.</p>

<p>In practice, this algorithm is simplified by collecting all indices in a single set, instead of creating a set for every value of <span class="LaTeX">$k$</span>. In particular, the algorithm collects, in each node, all sets coming from its descendants that have not been skipped by backjumping. When retracting from this node, this set is removed the variable of the node and collected into the destination of backtracking or backjumping.</p>

<p>Conflict-directed backjumping was proposed for <a href="Constraint_Satisfaction_Problems" title="wikilink">Constraint Satisfaction Problems</a> by <a href="Patrick_Prosser" title="wikilink">Patrick Prosser</a> in his seminal 1993 paper.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Constraint_learning" title="wikilink">Constraint learning</a></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li></li>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Constraint_programming" title="wikilink">Category:Constraint programming</a> <a href="Category:Search_algorithms" title="wikilink">Category:Search algorithms</a></p>
</body>
</html>
