<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1464">Baker's technique</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Baker's technique</h1>
<hr/>

<p><strong>Baker's technique</strong>, created in 1983 (conference presentation) and published in a journal in 1994 by Brenda Baker, is a method for designing <a href="polynomial-time_approximation_scheme" title="wikilink">polynomial-time approximation schemes</a>, PTASs, for problems on <a href="planar_graph" title="wikilink">planar graphs</a>. This technique has given PTASs for the following problems: <a href="subgraph_isomorphism" title="wikilink">subgraph isomorphism</a>, <a href="maximum_independent_set" title="wikilink">maximum independent set</a>, <a href="minimum_vertex_cover" title="wikilink">minimum vertex cover</a>, <a href="minimum_dominating_set" title="wikilink">minimum dominating set</a>, minimum <a href="edge_dominating_set" title="wikilink">edge dominating set</a>, maximum triangle matching, and many others. Its generalizations have also led to many PTASs on graphs excluding a fixed minor, such as bounded genus graphs, as well as to other classes of graphs not closed under taking minors such as the <a href="1-planar_graph" title="wikilink">1-planar graphs</a>. The idea for Baker's technique is to break the graph into layers, such that the problem can be solved optimally on each layer, then combine the solutions from each layer in a reasonable way that will result in a feasible solution.</p>
<h2 id="example-of-technique">Example of technique</h2>

<p>The example that we will use to demonstrate Baker's technique is the maximum weight <a href="independent_set" title="wikilink">independent set</a> problem.</p>
<h3 id="algorithm">Algorithm</h3>

<p><code>INDEPENDENT-SET(</code>

<math display="inline" id="Baker's_technique:0">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

<code>,</code>

<math display="inline" id="Baker's_technique:1">
 <semantics>
  <mi>w</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>w</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w
  </annotation>
 </semantics>
</math>

<code>,</code>

<math display="inline" id="Baker's_technique:2">
 <semantics>
  <mi>ϵ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϵ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon
  </annotation>
 </semantics>
</math>

<code>)</code><br/>
<code>Choose an arbitrary vertex </code>

<math display="inline" id="Baker's_technique:3">
 <semantics>
  <mi>r</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>r</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="inline" id="Baker's_technique:4">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mo>/</mo>
    <mi>ϵ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>k</ci>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <ci>ϵ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k=1/\epsilon
  </annotation>
 </semantics>
</math>

</p>

<p><code>find the breadth-first search levels for </code>

<math display="inline" id="Baker's_technique:5">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

<code> rooted at </code>

<math display="inline" id="Baker's_technique:6">
 <semantics>
  <mi>r</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>r</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r
  </annotation>
 </semantics>
</math>

<code> </code>

<math display="inline" id="Baker's_technique:7">
 <semantics>
  <mrow>
   <mo lspace="8.1pt" stretchy="false">(</mo>
   <mrow>
    <mo>mod</mo>
    <mi>k</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>pmod</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \;\;(\mathop{{\rm mod}}k)
  </annotation>
 </semantics>
</math>



<math display="block" id="Baker's_technique:8">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <msub>
    <mi>V</mi>
    <mn>0</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>V</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>V</mi>
    <mrow>
     <mi>k</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>V</ci>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>V</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>V</ci>
     <apply>
      <minus></minus>
      <ci>k</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{V_{0},V_{1},\ldots,V_{k-1}\}
  </annotation>
 </semantics>
</math>

<br/>
<code>for </code>

<math display="inline" id="Baker's_technique:9">
 <semantics>
  <mrow>
   <mi mathvariant="normal">ℓ</mi>
   <mo>=</mo>
   <mrow>
    <mn>0</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mrow>
     <mi>k</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>normal-ℓ</ci>
    <list>
     <cn type="integer">0</cn>
     <ci>normal-…</ci>
     <apply>
      <minus></minus>
      <ci>k</ci>
      <cn type="integer">1</cn>
     </apply>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ell=0,\ldots,k-1
  </annotation>
 </semantics>
</math>

<br/>
<code>find the components </code>

<math display="inline" id="Baker's_technique:10">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mi>G</mi>
     <mn>1</mn>
     <mi mathvariant="normal">ℓ</mi>
    </msubsup>
    <mo>,</mo>
    <msubsup>
     <mi>G</mi>
     <mn>2</mn>
     <mi mathvariant="normal">ℓ</mi>
    </msubsup>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>G</ci>
      <ci>normal-ℓ</ci>
     </apply>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>G</ci>
      <ci>normal-ℓ</ci>
     </apply>
     <cn type="integer">2</cn>
    </apply>
    <ci>normal-…</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G^{\ell}_{1},G^{\ell}_{2},\ldots,
  </annotation>
 </semantics>
</math>

<code> of </code>

<math display="inline" id="Baker's_technique:11">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

<code> after deleting </code>

<math display="inline" id="Baker's_technique:12">
 <semantics>
  <msub>
   <mi>V</mi>
   <mi mathvariant="normal">ℓ</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>V</ci>
    <ci>normal-ℓ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V_{\ell}
  </annotation>
 </semantics>
</math>

<br/>
<code>for </code>

<math display="inline" id="Baker's_technique:13">
 <semantics>
  <mrow>
   <mi>i</mi>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mo>,</mo>
    <mn>2</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>i</ci>
    <list>
     <cn type="integer">1</cn>
     <cn type="integer">2</cn>
     <ci>normal-…</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i=1,2,\ldots
  </annotation>
 </semantics>
</math>

<br/>
<code>compute </code>

<math display="inline" id="Baker's_technique:14">
 <semantics>
  <msubsup>
   <mi>S</mi>
   <mi>i</mi>
   <mi mathvariant="normal">ℓ</mi>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>S</ci>
     <ci>i</ci>
    </apply>
    <ci>normal-ℓ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{i}^{\ell}
  </annotation>
 </semantics>
</math>

<code>, the maximum-weight independent set of </code>

<math display="inline" id="Baker's_technique:15">
 <semantics>
  <msubsup>
   <mi>G</mi>
   <mi>i</mi>
   <mi mathvariant="normal">ℓ</mi>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>G</ci>
     <ci>i</ci>
    </apply>
    <ci>normal-ℓ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G_{i}^{\ell}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="inline" id="Baker's_technique:16">
 <semantics>
  <mrow>
   <msup>
    <mi>S</mi>
    <mi mathvariant="normal">ℓ</mi>
   </msup>
   <mo>=</mo>
   <mrow>
    <msub>
     <mo>∪</mo>
     <mi>i</mi>
    </msub>
    <msubsup>
     <mi>S</mi>
     <mi>i</mi>
     <mi mathvariant="normal">ℓ</mi>
    </msubsup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>S</ci>
     <ci>normal-ℓ</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <union></union>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>S</ci>
       <ci>i</ci>
      </apply>
      <ci>normal-ℓ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S^{\ell}=\cup_{i}S_{i}^{\ell}
  </annotation>
 </semantics>
</math>

</p>

<p><code>let </code>

<math display="inline" id="Baker's_technique:17">
 <semantics>
  <msup>
   <mi>S</mi>
   <msup>
    <mi mathvariant="normal">ℓ</mi>
    <mo>*</mo>
   </msup>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>S</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-ℓ</ci>
     <times></times>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S^{\ell^{*}}
  </annotation>
 </semantics>
</math>

<code> be the solution of maximum weight among </code>

<math display="inline" id="Baker's_technique:18">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <msup>
    <mi>S</mi>
    <mn>0</mn>
   </msup>
   <mo>,</mo>
   <msup>
    <mi>S</mi>
    <mn>1</mn>
   </msup>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msup>
    <mi>S</mi>
    <mrow>
     <mi>k</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msup>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>S</ci>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>S</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>S</ci>
     <apply>
      <minus></minus>
      <ci>k</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{S^{0},S^{1},\ldots,S^{k-1}\}
  </annotation>
 </semantics>
</math>

<br/>
<code>return </code>

<math display="inline" id="Baker's_technique:19">
 <semantics>
  <msup>
   <mi>S</mi>
   <msup>
    <mi mathvariant="normal">ℓ</mi>
    <mo>*</mo>
   </msup>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>S</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-ℓ</ci>
     <times></times>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S^{\ell^{*}}
  </annotation>
 </semantics>
</math>

</p>

<p>Notice that the above algorithm is feasible because each 

<math display="inline" id="Baker's_technique:20">
 <semantics>
  <msup>
   <mi>S</mi>
   <mi mathvariant="normal">ℓ</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>S</ci>
    <ci>normal-ℓ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S^{\ell}
  </annotation>
 </semantics>
</math>

 is the union of disjoint independent sets.</p>
<h3 id="dynamic-programming">Dynamic programming</h3>

<p><a href="Dynamic_programming" title="wikilink">Dynamic programming</a> is used when we compute the maximum-weight independent set for each 

<math display="inline" id="Baker's_technique:21">
 <semantics>
  <msubsup>
   <mi>G</mi>
   <mi>i</mi>
   <mi mathvariant="normal">ℓ</mi>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>G</ci>
     <ci>i</ci>
    </apply>
    <ci>normal-ℓ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G_{i}^{\ell}
  </annotation>
 </semantics>
</math>

. This dynamic program works because each 

<math display="inline" id="Baker's_technique:22">
 <semantics>
  <msubsup>
   <mi>G</mi>
   <mi>i</mi>
   <mi mathvariant="normal">ℓ</mi>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>G</ci>
     <ci>i</ci>
    </apply>
    <ci>normal-ℓ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G_{i}^{\ell}
  </annotation>
 </semantics>
</math>

 is a 

<math display="inline" id="Baker's_technique:23">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

-<a href="outerplanar_graph" title="wikilink">outerplanar graph</a>. Many NP-complete problems can be solved with dynamic programming on 

<math display="inline" id="Baker's_technique:24">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

-outerplanar graphs.</p>
<h2 id="references">References</h2>
<ul>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
</ul>

<p>"</p>

<p><a href="Category:Articles_created_via_the_Article_Wizard" title="wikilink">Category:Articles created via the Article Wizard</a> <a href="Category:Graph_theory" title="wikilink">Category:Graph theory</a> <a href="Category:Planar_graphs" title="wikilink">Category:Planar graphs</a> <a href="Category:Approximation_algorithms" title="wikilink">Category:Approximation algorithms</a></p>
</body>
</html>
