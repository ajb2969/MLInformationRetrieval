<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="280">Bridge (graph theory)</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Bridge (graph theory)</h1>
<hr/>

<p> </p>

<p>In <a href="graph_theory" title="wikilink">graph theory</a>, a <strong>bridge</strong>, <strong>isthmus</strong>, <strong>cut-edge</strong>, or <strong>cut arc</strong> is an <a href="Glossary_of_graph_theory#Basics" title="wikilink">edge</a> of a <a href="Graph_(mathematics)" title="wikilink">graph</a> whose deletion increases its number of <a href="Connected_component_(graph_theory)" title="wikilink">connected components</a>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> Equivalently, an edge is a bridge if and only if it is not contained in any <a href="Cycle_(graph_theory)" title="wikilink">cycle</a>. A graph is said to be <strong>bridgeless</strong> or <strong>isthmus-free</strong> if it contains no bridges.</p>

<p>Another meaning of "bridge" appears in the term <strong>bridge of a subgraph</strong>. If <em>H</em> is a subgraph of <em>G</em>, a <strong>bridge of</strong> <em>H</em> <strong>in</strong> <em>G</em> is a maximal subgraph of <em>G</em> that is not contained in <em>H</em> and is not separated by <em>H</em>.</p>
<h2 id="trees-and-forests">Trees and forests</h2>

<p>A graph with 

<math display="inline" id="Bridge_(graph_theory):0">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 nodes can contain at most 

<math display="inline" id="Bridge_(graph_theory):1">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>-</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>n</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n-1
  </annotation>
 </semantics>
</math>


 bridges, since adding additional edges must create a cycle. The graphs with exactly 

<math display="inline" id="Bridge_(graph_theory):2">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>-</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>n</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n-1
  </annotation>
 </semantics>
</math>

 bridges are exactly the <a href="tree_(graph_theory)" title="wikilink">trees</a>, and the graphs in which every edge is a bridge are exactly the <a href="forest_(graph_theory)" title="wikilink">forests</a>.</p>

<p>In every undirected graph, there is an <a href="equivalence_relation" title="wikilink">equivalence relation</a> on the vertices according to which two vertices are related to each other whenever there are two edge-disjoint paths connecting them. (Every vertex is related to itself via two length-zero paths, which are identical but nevertheless edge-disjoint.) The equivalence classes of this relation are called <strong>2-edge-connected components</strong>, and the bridges of the graph are exactly the edges whose endpoints belong to different components. The <strong>bridge-block tree</strong> of the graph has a vertex for every nontrivial component and an edge for every bridge.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>
<h2 id="relation-to-vertex-connectivity">Relation to vertex connectivity</h2>

<p>Bridges are closely related to the concept of <a href="Articulation_vertex" title="wikilink">articulation vertices</a>, vertices that belong to every path between some pair of other vertices. The two endpoints of a bridge are articulation vertices unless they have a degree of 1, although it may also be possible for a non-bridge edge to have two articulation vertices as endpoints. Analogously to bridgeless graphs being 2-edge-connected, graphs without articulation vertices are <a href="k-vertex-connected_graph" title="wikilink">2-vertex-connected</a>.</p>

<p>In a <a href="cubic_graph" title="wikilink">cubic graph</a>, every cut vertex is an endpoint of at least one bridge.</p>
<h2 id="bridgeless-graphs">Bridgeless graphs</h2>

<p>A <strong>bridgeless graph</strong> is a graph that does not have any bridges. Equivalent conditions are that each <a href="Connected_component_(graph_theory)" title="wikilink">connected component</a> of the graph has an <a href="ear_decomposition" title="wikilink">open ear decomposition</a>,<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> that each connected component is <a href="K-edge-connected_graph" title="wikilink">2-edge-connected</a>, or (by <a href="Robbins'_theorem" title="wikilink">Robbins' theorem</a>) that every connected component has a <a href="strong_orientation" title="wikilink">strong orientation</a>.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>

<p>An important open problem involving bridges is the <a href="cycle_double_cover_conjecture" title="wikilink">cycle double cover conjecture</a>, due to <a href="Paul_Seymour_(mathematician)" title="wikilink">Seymour</a> and <a href="George_Szekeres" title="wikilink">Szekeres</a> (1978 and 1979, independently), which states that every bridgeless graph admits a set of simple cycles which contains each edge exactly twice.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>
<h2 id="tarjans-bridge-finding-algorithm">Tarjan's Bridge-finding algorithm</h2>

<p>The first <a href="linear_time" title="wikilink">linear time</a> algorithm for finding the bridges in a graph was described by <a href="Robert_Tarjan" title="wikilink">Robert Tarjan</a> in 1974.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> It performs the following steps:</p>
<ul>
<li>Find a <a href="spanning_forest" title="wikilink">spanning forest</a> of 

<math display="inline" id="Bridge_(graph_theory):3">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

</li>
<li>Create a rooted forest 

<math display="inline" id="Bridge_(graph_theory):4">
 <semantics>
  <mi>F</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>F</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F
  </annotation>
 </semantics>
</math>

 from the spanning tree</li>
<li>Traverse the forest 

<math display="inline" id="Bridge_(graph_theory):5">
 <semantics>
  <mi>F</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>F</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F
  </annotation>
 </semantics>
</math>

 in <a href="Tree_traversal" title="wikilink">preorder</a> and number the nodes. Parent nodes in the forest now have lower numbers than child nodes.</li>
<li>For each node 

<math display="inline" id="Bridge_(graph_theory):6">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>


 in preorder, do:
<ul>
<li>Compute the number of forest descendants 

<math display="inline" id="Bridge_(graph_theory):7">
 <semantics>
  <mrow>
   <mi>N</mi>
   <mi>D</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>v</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>N</ci>
    <ci>D</ci>
    <ci>v</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ND(v)
  </annotation>
 </semantics>
</math>

 for this node, by adding one to the sum of its children's descendants.</li>
<li>Compute 

<math display="inline" id="Bridge_(graph_theory):8">
 <semantics>
  <mrow>
   <mi>L</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>v</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>L</ci>
    <ci>v</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L(v)
  </annotation>
 </semantics>
</math>

, the lowest preorder label reachable from 

<math display="inline" id="Bridge_(graph_theory):9">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>

 by a path for which all but the last edge stays within the subtree rooted at 

<math display="inline" id="Bridge_(graph_theory):10">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>

. This is the minimum of the set consisting of the values of 

<math display="inline" id="Bridge_(graph_theory):11">
 <semantics>
  <mrow>
   <mi>L</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>w</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>L</ci>
    <ci>w</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L(w)
  </annotation>
 </semantics>
</math>


 at child nodes of 

<math display="inline" id="Bridge_(graph_theory):12">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>

 and of the preorder labels of nodes reachable from 

<math display="inline" id="Bridge_(graph_theory):13">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>

 by edges that do not belong to 

<math display="inline" id="Bridge_(graph_theory):14">
 <semantics>
  <mi>F</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>F</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F
  </annotation>
 </semantics>
</math>

.</li>
<li>Similarly, compute 

<math display="inline" id="Bridge_(graph_theory):15">
 <semantics>
  <mrow>
   <mi>H</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>v</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>H</ci>
    <ci>v</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H(v)
  </annotation>
 </semantics>
</math>

, the highest preorder label reachable by a path for which all but the last edge stays within the subtree rooted at 

<math display="inline" id="Bridge_(graph_theory):16">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>


. This is the maximum of the set consisting of the values of 

<math display="inline" id="Bridge_(graph_theory):17">
 <semantics>
  <mrow>
   <mi>H</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>w</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>H</ci>
    <ci>w</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H(w)
  </annotation>
 </semantics>
</math>

 at child nodes of 

<math display="inline" id="Bridge_(graph_theory):18">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>

 and of the preorder labels of nodes reachable from 

<math display="inline" id="Bridge_(graph_theory):19">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>

 by edges that do not belong to 

<math display="inline" id="Bridge_(graph_theory):20">
 <semantics>
  <mi>F</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>F</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F
  </annotation>
 </semantics>
</math>

.</li>
<li>For each node 

<math display="inline" id="Bridge_(graph_theory):21">
 <semantics>
  <mi>w</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>w</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w
  </annotation>
 </semantics>
</math>


 with parent node 

<math display="inline" id="Bridge_(graph_theory):22">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>

, if 

<math display="inline" id="Bridge_(graph_theory):23">
 <semantics>
  <mrow>
   <mrow>
    <mi>L</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>w</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>w</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>L</ci>
     <ci>w</ci>
    </apply>
    <ci>w</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L(w)=w
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Bridge_(graph_theory):24">
 <semantics>
  <mrow>
   <mrow>
    <mi>H</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>w</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo><</mo>
   <mrow>
    <mi>w</mi>
    <mo>+</mo>
    <mrow>
     <mi>N</mi>
     <mi>D</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>w</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <times></times>
     <ci>H</ci>
     <ci>w</ci>
    </apply>
    <apply>
     <plus></plus>
     <ci>w</ci>
     <apply>
      <times></times>
      <ci>N</ci>
      <ci>D</ci>
      <ci>w</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H(w)<w+ND(w)
  </annotation>
 </semantics>
</math>

 then the edge from 

<math display="inline" id="Bridge_(graph_theory):25">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Bridge_(graph_theory):26">
 <semantics>
  <mi>w</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>w</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w
  </annotation>
 </semantics>
</math>


 is a bridge.</li>
</ul></li>
</ul>
<h2 id="bridge-finding-with-chain-decompositions">Bridge-Finding with Chain Decompositions</h2>

<p>A very simple bridge-finding algorithm<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> uses <a href="chain_decompositions" title="wikilink">chain decompositions</a>. Chain decompositions do not only allow to compute all bridges of a graph, they also allow to <em>read off</em> every <a href="cut_vertex" title="wikilink">cut vertex</a> of <em>G</em> (and the <a href="Biconnected_component" title="wikilink">block-cut tree</a> of <em>G</em>), giving a general framework for testing 2-edge- and 2-vertex-connectivity (which extends to linear-time 3-edge- and 3-vertex-connectivity tests).</p>

<p>Chain decompositions are special ear decompositions depending on a DFS-tree <em>T</em> of <em>G</em> and can be computed very simply: Let every vertex be marked as unvisited. For each vertex <em>v</em> in ascending <a href="Depth-first_search" title="wikilink">DFS</a>-numbers 1...<em>n</em>, traverse every backedge (i.e. every edge not in the DFS tree) that is incident to <em>v</em> and follow the path of tree-edges back to the root of <em>T</em>, stopping at the first vertex that is marked as visited. During such a traversal, every traversed vertex is marked as visited. Thus, a traversal stops at the latest at <em>v</em> and forms either a directed path or cycle, beginning with v; we call this path or cycle a <em>chain</em>. The <em>i</em>th chain found by this procedure is referred to as <em>C<sub>i</sub></em>. <em>C=C<sub>1</sub>,C<sub>2</sub>,...</em> is then a <em><a href="chain_decomposition" title="wikilink">chain decomposition</a></em> of <em>G</em>.</p>

<p>The following characterizations then allow to <em>read off</em> several properties of <em>G</em> from <em>C</em> efficiently, including all bridges of <em>G</em>.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> Let <em>C</em> be a chain decomposition of a simple connected graph <em>G=(V,E)</em>.</p>
<ol>
<li><em>G</em> is 2-edge-connected if and only if the chains in <em>C</em> partition <em>E</em>.</li>
<li>An edge <em>e</em> in <em>G</em> is a bridge if and only if <em>e</em> is not contained in any chain in <em>C</em>.</li>
<li>If <em>G</em> is 2-edge-connected, <em>C</em> is an <a href="ear_decomposition" title="wikilink">ear decomposition</a>.</li>
<li><em>G</em> is 2-vertex-connected if and only if <em>G</em> has minimum degree 2 and <em>C<sub>1</sub></em> is the only cycle in <em>C</em>.</li>
<li>A vertex <em>v</em> in a 2-edge-connected graph <em>G</em> is a cut vertex if and only if <em>v</em> is the first vertex of a cycle in <em>C - C<sub>1</sub></em>.</li>
<li>If <em>G</em> is 2-vertex-connected, <em>C</em> is an <a href="Ear_decomposition" title="wikilink">open ear decomposition</a>.</li>
</ol>
<h2 id="notes">Notes</h2>

<p>"</p>

<p><a href="Category:Graph_connectivity" title="wikilink">Category:Graph connectivity</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">.<a href="#fnref1">↩</a></li>
<li id="fn2">.<a href="#fnref2">↩</a></li>
<li id="fn3">.<a href="#fnref3">↩</a></li>
<li id="fn4"></li>
<li id="fn5">.<a href="#fnref5">↩</a></li>
<li id="fn6">.<a href="#fnref6">↩</a></li>
<li id="fn7">.<a href="#fnref7">↩</a></li>
<li id="fn8"></li>
</ol>
</section>
</body>
</html>
