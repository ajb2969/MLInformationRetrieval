<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1518">Software reliability testing</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Software reliability testing</h1>
<hr/>

<p><strong>Software reliability testing</strong> is a field of software testing that relates to testing a software's ability to function, given environmental conditions, for a particular amount of time. Software reliability testing helps discover many problems in the <a href="software_design" title="wikilink">software design</a> and functionality.</p>
<h2 id="overview">Overview</h2>

<p>Software reliability is the probability that software will work properly in a specified environment and for a given amount of time. Using the following formula, the probability of failure is calculated by testing a sample of all available input states.</p>
<dl>
<dd>Probability = Number of failing cases / Total number of cases under consideration
</dd>
</dl>

<p>The set of all possible input states is called the input space. To find reliability of software, we need to find output space from given input space and software.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>

<p>For reliability testing, data is gathered from various stages of development, such as the design and operating stages. The tests are limited due to restrictions such as cost and time restrictions. Statistical samples are obtained from the software products to test for the reliability of the software. Once sufficient data or information is gathered, statistical studies are done. Time constraints are handled by applying fixed dates or deadlines for the tests to be performed. After this phase, design of the software is stopped and the actual implementation phase starts. As there are restrictions on costs and time, the data is gathered carefully so that each data has some purpose and gets its expected precision.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> To achieve the satisfactory results from reliability testing one must take care of some reliability characteristics. For example Mean Time to Failure (MTTF)<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> is measured in terms of three factors:</p>
<ol>
<li>operating time,</li>
<li>number of on off cycles,</li>
<li>and calendar time.</li>
</ol>

<p>If the restrictions are on operation time or if the focus is on first point for improvement, then one can apply compressed time accelerations to reduce the testing time. If the focus is on calendar time (i.e. if there are predefined deadlines), then <a href="stress_testing" title="wikilink">intensified stress testing</a> is used.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>
<h2 id="measurement">Measurement</h2>

<p>Software reliability is measured in terms of <a href="mean_time_between_failures" title="wikilink">mean time between failures</a>(MTBF).<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>

<p>MTBF consists of <a href="mean_time_to_failure" title="wikilink">mean time to failure</a> (MTTF) and <a href="mean_time_to_repair" title="wikilink">mean time to repair</a>(MTTR). MTTF is the difference of time between two consecutive failures and MTTR is the time required to fix the failure.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> Reliability for good software is a number between 0 and 1. Reliability increases when errors or bugs from the program are removed.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>

<p>For example, if MTBF = 1000 hours for average software, then the software should work for 1000 hours for continuous operations.</p>
<h2 id="objectives-of-reliability-testing">Objectives of reliability testing</h2>

<p>The main objective of the reliability testing is to test software performance under given conditions without any type of corrective measure using known fixed procedures considering its specifications.</p>
<h3 id="secondary-objectives">Secondary objectives</h3>

<p>The secondary objectives of reliability testing is:</p>
<ol>
<li>To find perceptual structure of repeating failures.</li>
<li>To find the number of failures occurring in a specified amount of time.</li>
<li>To find the mean life of the software.</li>
<li>To discover the main cause of failure.</li>
<li>Checking the performance of different units of software after taking preventive actions.</li>
</ol>
<h3 id="points-for-defining-objectives">Points for defining objectives</h3>

<p>Some restrictions on creating objectives include:</p>
<ol>
<li>Behaviour of the software should be defined in given conditions.</li>
<li>The objective should be feasible.</li>
<li>Time constraints should be provided.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></li>
</ol>
<h2 id="importance-of-reliability-testing">Importance of reliability testing</h2>

<p>The application of computer software has crossed into many different fields, with software being an essential part of industrial, commercial and military systems. Because of its many applications in safety critical systems, software reliability is now an important research area. Although <a href="software_engineering" title="wikilink">software engineering</a> is becoming the fastest developing technology of the last century, there is no complete, scientific, quantitative measure to assess them. Software reliability testing is being used as a tool to help assess these software engineering technologies.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></p>

<p>To improve the performance of software product and software development process, a thorough assessment of reliability is required. Testing software reliability is important because it is of great use for software managers and practitioners.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a></p>

<p>To verify the reliability of the software via testing:</p>
<ol>
<li>A sufficient number of test cases should be executed for a sufficient amount of time to get a reasonable estimate of how long the software will execute without failure. Long duration tests are needed to identify defects (such as memory leakage and buffer overflows) that take time to cause a fault or failure to occur.</li>
<li>The distribution of test cases should match the actual or planned operational profile of the software. The more often a function or subset of the software is executed, the greater the percentage of test cases that should be allocated to that function or subset.</li>
</ol>
<h2 id="types-of-reliability-testing">Types of reliability testing</h2>

<p>Software reliability testing includes feature testing, load testing, and <a href="regression_testing" title="wikilink">regression testing</a>.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a></p>
<h3 id="feature-test">Feature test</h3>

<p>Feature testing checks the features provided by the software and is conducted in the following steps:</p>
<ul>
<li>Each operation in the software is executed once.</li>
<li>Interaction between the two operations is reduced and</li>
<li>Each operation is checked for its proper execution.</li>
</ul>

<p>The feature test is followed by the load test.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a></p>
<h3 id="load-test">Load test</h3>

<p>This test is conducted to check the performance of the software under maximum work load. Any software performs better up to some amount of workload, after which the response time of the software starts degrading. For example, a web site can be tested to see how many simultaneous users it can support without performance degradation. This testing mainly helps for <a class="uri" href="Databases" title="wikilink">Databases</a> and <a href="Application_servers" title="wikilink">Application servers</a>. Load testing also requires <a href="software_performance_testing" title="wikilink">software performance testing</a>, which checks how well some software performs under workload.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a></p>
<h3 id="regression-test">Regression test</h3>

<p>Regression testing is used to check if any new bugs have been introduced through previous bug fixes. Regression testing is conducted after every change or update in the software features. This testing is periodic, depending on the length and features of the software.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a></p>
<h2 id="test-planning">Test planning</h2>

<p>Reliability testing is more costly compared to other types of testing. Thus while doing reliability testing, proper management and planning is required. This plan includes testing process to be implemented, data about its environment, test schedule, test points etc.</p>
<h3 id="problems-in-designing-test-cases">Problems in designing test cases</h3>

<p>Some common problems that occur when designing test cases include:</p>
<ul>
<li>Test cases can be designed simply by selecting only valid input values for each field in the software. When changes are made in a particular module, the previous values may not actually test the new features introduced after the older version of software.</li>
<li>There may be some critical runs in the software which are not handled by any existing test case. Therefore, it is necessary to ensure that all possible types of test cases are considered through careful test case selection.<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a></li>
</ul>
<h2 id="reliability-enhancement-through-testing">Reliability enhancement through testing</h2>

<p>Studies during development and design of software help for improving the reliability of a product. Reliability testing is essentially performed to eliminate the failure mode of the software. Life testing of the product should always be done after the design part is finished or at least the complete design is finalized.<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a> Failure analysis and design improvement is achieved through testings.</p>
<h3 id="reliability-growth-testing">Reliability growth testing</h3>

<p><a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a> This testing is used to check new prototypes of the software which are initially supposed to fail frequently. The causes of failure are detected and actions are taken to reduce defects. Suppose T is total accumulated time for prototype. n(T) is number of failure from start to time T. The graph drawn for n(T)/T is a straight line. This graph is called Duane Plot. One can get how much reliability can be gained after all other cycles of test and fix it.</p>

<p>

<math display="inline" id="Software_reliability_testing:0">
 <semantics>
  <mtable>
   <mtr>
    <mtd columnalign="right">
     <mrow>
      <mi>l</mi>
      <mi>n</mi>
      <mrow>
       <mo>[</mo>
       <mstyle displaystyle="true">
        <mfrac>
         <mrow>
          <mi>n</mi>
          <mrow>
           <mo>(</mo>
           <mi>T</mi>
           <mo>)</mo>
          </mrow>
         </mrow>
         <mi>T</mi>
        </mfrac>
       </mstyle>
       <mo>]</mo>
      </mrow>
      <mo>=</mo>
      <mo>-</mo>
      <mi>α</mi>
      <mi>l</mi>
      <mi>n</mi>
      <mrow>
       <mo>(</mo>
       <mi>T</mi>
       <mo>)</mo>
      </mrow>
      <mo>+</mo>
      <mi>b</mi>
      <mo rspace="77.5pt">;</mo>
      <mi mathvariant="normal">…</mi>
      <mo>.</mo>
      <mo>.</mo>
      <mi>E</mi>
      <mi>q</mi>
      <mo>:</mo>
      <mn>1</mn>
     </mrow>
    </mtd>
   </mtr>
  </mtable>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="unknown">l</csymbol>
      <csymbol cd="unknown">n</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-[</ci>
       <apply>
        <divide></divide>
        <apply>
         <times></times>
         <ci>n</ci>
         <ci>T</ci>
        </apply>
        <ci>T</ci>
       </apply>
       <ci>normal-]</ci>
      </cerror>
      <eq></eq>
      <minus></minus>
      <csymbol cd="unknown">α</csymbol>
      <csymbol cd="unknown">l</csymbol>
      <csymbol cd="unknown">n</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">T</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <plus></plus>
      <csymbol cd="unknown">b</csymbol>
      <ci>normal-;</ci>
      <ci>normal-…</ci>
      <ci>normal-.</ci>
      <ci>normal-.</ci>
      <csymbol cd="unknown">E</csymbol>
      <csymbol cd="unknown">q</csymbol>
      <ci>normal-:</ci>
      <cn type="integer">1</cn>
     </cerror>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{aligned}\displaystyle ln\left[\frac{n\left(T\right)}{T}\right]=-\alpha
ln%
\left(T\right)+b;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ .....Eq:1\end{aligned}
  </annotation>
 </semantics>
</math>

</p>

<p>solving eq.1 for n(T),</p>

<p>

<math display="inline" id="Software_reliability_testing:1">
 <semantics>
  <mtable>
   <mtr>
    <mtd columnalign="right">
     <mrow>
      <mrow>
       <mrow>
        <mi>n</mi>
        <mrow>
         <mo>(</mo>
         <mi>T</mi>
         <mo>)</mo>
        </mrow>
       </mrow>
       <mo>=</mo>
       <mrow>
        <mrow>
         <mi>K</mi>
         <msup>
          <mi>T</mi>
          <mrow>
           <mn>1</mn>
           <mo>-</mo>
           <mi>α</mi>
          </mrow>
         </msup>
        </mrow>
        <mo rspace="97.5pt">;</mo>
        <mrow>
         <mi mathvariant="normal">…</mi>
         <mi mathvariant="normal">…</mi>
         <mi>E</mi>
         <mi>q</mi>
        </mrow>
       </mrow>
      </mrow>
      <mo>:</mo>
      <mn>2</mn>
     </mrow>
    </mtd>
   </mtr>
  </mtable>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <apply>
      <ci>normal-:</ci>
      <apply>
       <eq></eq>
       <apply>
        <times></times>
        <ci>n</ci>
        <ci>T</ci>
       </apply>
       <list>
        <apply>
         <times></times>
         <ci>K</ci>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>T</ci>
          <apply>
           <minus></minus>
           <cn type="integer">1</cn>
           <ci>α</ci>
          </apply>
         </apply>
        </apply>
        <apply>
         <times></times>
         <ci>normal-…</ci>
         <ci>normal-…</ci>
         <ci>E</ci>
         <ci>q</ci>
        </apply>
       </list>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{aligned}\displaystyle n\left(T\right)=KT^{1-\alpha};\ \ \ \ \ \ \ \ \ %
\ \ \ \ \ \ \ \ \ \ ......Eq:2\end{aligned}
  </annotation>
 </semantics>
</math>

</p>

<p>where K is e^b. If the value of alpha in the equation is zero the reliability can not be improved as expected for given number of failure. For alpha greater than zero, cumulative time T increases. This explains that number of the failures doesn't depends on test lengths.</p>
<h3 id="designing-test-cases-for-current-release">Designing test cases for current release</h3>

<p>If we are adding new features to the current version of software,then writing a test case for that operation is done differently.</p>
<ul>
<li>First plan how many new test cases are to be written for current version.</li>
<li>If the new feature is part of any existing feature, then share the test cases of new and existing features among them.</li>
<li>Finally combine all test cases from current version and previous one and record all the results.<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a></li>
</ul>

<p>There is a predefined rule to calculate count of new test cases for the software. if N is the probability of occurrence of new operations for new release of the software, R is the probability of occurrence of used operations in the current release and T is the number of all previously used test cases then</p>

<p>

<math display="inline" id="Software_reliability_testing:2">
 <semantics>
  <mtable>
   <mtr>
    <mtd columnalign="right">
     <mrow>
      <mrow>
       <mi>N</mi>
       <mi>e</mi>
       <mi>w</mi>
       <mi>T</mi>
       <mi>e</mi>
       <mi>s</mi>
       <mi>t</mi>
       <mi>c</mi>
       <mi>a</mi>
       <mi>s</mi>
       <mi>e</mi>
       <msub>
        <mi>s</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mi>c</mi>
          <mi>u</mi>
          <mi>r</mi>
          <mi>r</mi>
          <mi>e</mi>
          <mi>n</mi>
          <mi>t</mi>
          <mi>r</mi>
          <mi>e</mi>
          <mi>l</mi>
          <mi>e</mi>
          <mi>a</mi>
          <mi>s</mi>
          <mi>e</mi>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </msub>
      </mrow>
      <mo>=</mo>
      <mrow>
       <mrow>
        <mo>(</mo>
        <mstyle displaystyle="true">
         <mfrac>
          <mi>N</mi>
          <mi>R</mi>
         </mfrac>
        </mstyle>
        <mo>)</mo>
       </mrow>
       <mo>*</mo>
       <mi>T</mi>
      </mrow>
     </mrow>
    </mtd>
   </mtr>
  </mtable>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <ci>N</ci>
       <ci>e</ci>
       <ci>w</ci>
       <ci>T</ci>
       <ci>e</ci>
       <ci>s</ci>
       <ci>t</ci>
       <ci>c</ci>
       <ci>a</ci>
       <ci>s</ci>
       <ci>e</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>s</ci>
        <apply>
         <times></times>
         <ci>c</ci>
         <ci>u</ci>
         <ci>r</ci>
         <ci>r</ci>
         <ci>e</ci>
         <ci>n</ci>
         <ci>t</ci>
         <ci>r</ci>
         <ci>e</ci>
         <ci>l</ci>
         <ci>e</ci>
         <ci>a</ci>
         <ci>s</ci>
         <ci>e</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <ci>N</ci>
        <ci>R</ci>
       </apply>
       <ci>T</ci>
      </apply>
     </apply>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{aligned}\displaystyle NewTestcases_{(currentrelease)}=\left(\frac{N}{R}%
\right)*T\end{aligned}
  </annotation>
 </semantics>
</math>

</p>
<h2 id="reliability-evaluation-based-on-operational-testing">Reliability evaluation based on operational testing</h2>

<p>The method of operational testing is used to test the reliability of software. Here one checks how the software works in its relevant operational environment. The main problem with this type of evaluation is constructing such an operational environment. Such type of simulation is observed in some industries like nuclear industries, in aircraft etc. Predicting future reliability is a part of reliability evaluation.</p>

<p>There are two techniques used for this:</p>
<dl>
<dt>Steady state reliability estimation : In this case, we use feedback from delivered software products. Depending on those results, we can predict the future reliability for the next version of product. This is similar to sample testing for physical products.<br/>
Reliability growth based prediction : This method uses documentation of the testing procedure. For example, consider a developed software and that we are creating different new versions of that software. We consider data on the testing of each version and based on the observed trend, we predict the reliability of the new version of software.<a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a></dt>
</dl>
<h3 id="reliability-growth-assessment-and-prediction">Reliability growth assessment and prediction</h3>

<p>In the assessment and prediction of software reliability, we use the reliability growth model. During operation of the software, any data about its failure is stored in statistical form and is given as input to the reliability growth model. Using this data, the reliability growth model can evaluate the reliability of software. Lots of data about reliability growth model is available with probability models claiming to represent failure process. But there is no model which is best suited for all conditions. Therefore we must choose a model based on the appropriate conditions.</p>
<h3 id="reliability-estimation-based-on-failure-free-working">Reliability estimation based on failure-free working</h3>

<p>In this case, the reliability of the software is estimated with assumptions like the following:</p>
<ul>
<li>If a bug is found, then it is sure that it is going to be fixed by someone.</li>
<li>Fixing the bug will not have any effect on the reliability of the software.</li>
<li>Each fix in the software is accurate.<a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a></li>
</ul>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Software_testing" title="wikilink">Software testing</a></li>
<li><a href="Load_testing" title="wikilink">Load testing</a></li>
<li><a href="Regression_testing" title="wikilink">Regression testing</a></li>
<li><a href="Reliability_engineering" title="wikilink">Reliability engineering</a></li>
</ul>
<h2 id="references">References</h2>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.weibull.com/hotwire/issue94/relbasics94.htm/">Mean Time Between Failure</a></li>
<li><a href="http://www.weibull.com/basics/accelerated.htm/">Software Life Testing</a></li>
</ul>

<p>"</p>

<p><a href="Category:Articles_created_via_the_Article_Wizard" title="wikilink">Category:Articles created via the Article Wizard</a> <a href="Category:Software_testing" title="wikilink">Category:Software testing</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
<li id="fn10"><a href="#fnref10">↩</a></li>
<li id="fn11"><a href="#fnref11">↩</a></li>
<li id="fn12"></li>
<li id="fn13"></li>
<li id="fn14"></li>
<li id="fn15"></li>
<li id="fn16"><a href="#fnref16">↩</a></li>
<li id="fn17"></li>
<li id="fn18"></li>
<li id="fn19"><a href="#fnref19">↩</a></li>
<li id="fn20"></li>
</ol>
</section>
</body>
</html>
