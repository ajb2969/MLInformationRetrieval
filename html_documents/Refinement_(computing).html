<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1150">Refinement (computing)</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Refinement (computing)</h1>
<hr/>

<p><strong>Refinement</strong> is a generic term of computer science that encompasses various approaches for producing <a href="correctness_(computer_science)" title="wikilink">correct</a> computer programs and simplifying existing programs to enable their formal verification.</p>
<h2 id="program-refinement">Program refinement</h2>

<p>In <a href="formal_methods" title="wikilink">formal methods</a>, <strong>program refinement</strong> is the <a href="formal_verification" title="wikilink">verifiable</a> transformation of an <em>abstract</em> (high-level) <a href="formal_specification" title="wikilink">formal specification</a> into a <em>concrete</em> (low-level) <a href="executable_program" title="wikilink">executable program</a>. <em><a href="Stepwise_refinement" title="wikilink">Stepwise refinement</a></em> allows this process to be done in stages. Logically, refinement normally involves <a href="logical_consequence" title="wikilink">implication</a>, but there can be additional complications.</p>
<h2 id="data-refinement">Data refinement</h2>

<p><strong>Data refinement</strong> is used to convert an abstract data model (in terms of <a href="set_(mathematics)" title="wikilink">sets</a> for example) into implementable <a href="data_structures" title="wikilink">data structures</a> (such as <a href="Array_data_structure" title="wikilink">arrays</a>). <em><a href="Operation_refinement" title="wikilink">Operation refinement</a></em> converts a <a class="uri" href="specification" title="wikilink">specification</a> of an operation on a system into an implementable <a href="computer_program" title="wikilink">program</a> (e.g., a <a href="Procedure_(computer_science)" title="wikilink">procedure</a>). The <a class="uri" href="postcondition" title="wikilink">postcondition</a> can be strengthened and/or the <a class="uri" href="precondition" title="wikilink">precondition</a> weakened in this process. This reduces any <a href="Nondeterministic_algorithm" title="wikilink">nondeterminism</a> in the specification, typically to a completely <a class="uri" href="deterministic" title="wikilink">deterministic</a> implementation.</p>

<p>For example, <em>x</em> ∈ {1,2,3} (where <em>x</em> is the value of the <a href="Variable_(programming)" title="wikilink">variable</a> <em>x</em> after an operation) could be refined to <em>x</em> ∈ {1,2}, then <em>x</em> ∈ {1}, and implemented as <em>x</em> := 1. Implementations of <em>x</em> := 2 and <em>x</em> := 3 would be equally acceptable in this case, using a different route for the refinement. However, we must be careful not to refine to <em>x</em> ∈ {} (equivalent to <em>false</em>) since this is unimplementable; it is impossible to select a <a href="Element_(mathematics)" title="wikilink">member</a> from the <a href="empty_set" title="wikilink">empty set</a>.</p>

<p>The term <a href="Reification_(computer_science)" title="wikilink">reification</a> is also sometimes used (coined by <a href="Cliff_Jones_(computer_scientist)" title="wikilink">Cliff Jones</a>). <a href="Retrenchment_(computing)" title="wikilink">Retrenchment</a> is an alternative technique when formal refinement is not possible. The opposite of refinement is <a href="Abstraction_(computer_science)" title="wikilink">abstraction</a>.</p>
<h2 id="refinement-calculus">Refinement calculus</h2>

<p><a href="Refinement_calculus" title="wikilink">Refinement calculus</a> is a <a href="formal_system" title="wikilink">formal system</a> (inspired from <a href="Hoare_logic" title="wikilink">Hoare logic</a>) that promotes program refinement. The <a href="FermaT_Transformation_System" title="wikilink">FermaT Transformation System</a> is an industrial-strength implementation of refinement. The <a class="uri" href="B-Method" title="wikilink">B-Method</a> is also a <a href="formal_method" title="wikilink">formal method</a> that extends refinement calculus with a component language: it has been used in industrial developments.</p>
<h2 id="refinement-types">Refinement types</h2>

<p>In <a href="type_theory" title="wikilink">type theory</a>, a <strong>refinement type</strong><a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a><a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a><a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> is a type endowed with a predicate which is assumed to hold for any element of the refined type. Refinement types can express <a href="precondition" title="wikilink">preconditions</a> when used as <a href="function_argument" title="wikilink">function arguments</a> or <a href="postcondition" title="wikilink">postconditions</a> when used as <a href="return_type" title="wikilink">return types</a>: for instance, the type of a function which accepts natural numbers and returns natural numbers greater than 5 may be written as 

<math display="inline" id="Refinement_(computing):0">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mo>:</mo>
   <mrow>
    <mi>ℕ</mi>
    <mo>→</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mi>n</mi>
     <mo>:</mo>
     <mrow>
      <mi>ℕ</mi>
      <mrow>
       <mo fence="true" stretchy="false">|</mo>
       <mi>n</mi>
       <mo>></mo>
      </mrow>
      <mn>5</mn>
     </mrow>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>f</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>ℕ</ci>
     <apply>
      <csymbol cd="latexml">conditional-set</csymbol>
      <ci>n</ci>
      <apply>
       <times></times>
       <ci>ℕ</ci>
       <apply>
        <csymbol cd="latexml">ket</csymbol>
        <ci>n</ci>
       </apply>
       <cn type="integer">5</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f:\mathbb{N}\rightarrow\{n:\mathbb{N}|n>5\}
  </annotation>
 </semantics>
</math>

. Refinement types are thus related to <a href="behavioral_subtyping" title="wikilink">behavioral subtyping</a>.</p>
<h2 id="references">References</h2>

<p>"</p>

<p><a href="Category:Formal_methods" title="wikilink">Category:Formal methods</a> <a href="Category:Computer_programming" title="wikilink">Category:Computer programming</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
</ol>
</section>
</body>
</html>
