<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="878">Abstract rewriting system</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Abstract rewriting system</h1>
<hr/>

<p>In <a href="mathematical_logic" title="wikilink">mathematical logic</a> and <a href="theoretical_computer_science" title="wikilink">theoretical computer science</a>, an <strong>abstract rewriting system</strong> (also <strong>(abstract) reduction system</strong> or <strong>abstract rewrite system</strong>; abbreviation <strong>ARS</strong>) is a <a href="Formalism_(mathematics)" title="wikilink">formalism</a> that captures the quintessential notion and properties of <a class="uri" href="rewriting" title="wikilink">rewriting</a> systems. In its simplest form, an ARS is simply a <a href="set_(mathematics)" title="wikilink">set</a> (of "objects") together with a <a href="binary_relation" title="wikilink">binary relation</a>, traditionally denoted with 

<math display="inline" id="Abstract_rewriting_system:0">
 <semantics>
  <mo>→</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-→</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rightarrow
  </annotation>
 </semantics>
</math>

; this definition can be further refined if we index (label) subsets of the binary relation. Despite its simplicity, an ARS is sufficient to describe important properties of rewriting systems like <a href="Normal_form_(abstract_rewriting)" title="wikilink">normal forms</a>, <a href="Termination_(term_rewriting)" title="wikilink">termination</a>, and various notions of <a href="Confluence_(abstract_rewriting)" title="wikilink">confluence</a>.</p>

<p>Historically, there have been several formalizations of rewriting in an abstract setting, each with its idiosyncrasies. This is due in part to the fact that some notions are equivalent, see below in this article. The formalization that is most commonly encountered in monographs and textbooks, and which is generally followed here, is due to <a href="Gérard_Huet" title="wikilink">Gérard Huet</a> (1980).<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>
<h2 id="definition">Definition</h2>

<p><strong>Abstract reduction system</strong>, (abbreviated <strong>ARS</strong>) is the most general (unidimensional) notion about specifying a set of objects and rules that can be applied to transform them. More recently authors use <strong>abstract rewriting system</strong> as well.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> (The preference for the word "reduction" here instead of "rewriting" constitutes a departure from the uniform use of "rewriting" in the names of systems that are particularizations of ARS. Because the word "reduction" does not appear in the names of more specialized systems, in older texts <strong>reduction system</strong> is a synonym for ARS).<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>

<p>An ARS is a set <em>A</em>, whose elements are usually called objects, together with a <a href="binary_relation" title="wikilink">binary relation</a> on <em>A</em>, traditionally denoted by →, and called the <strong>reduction relation</strong>, <strong>rewrite relation</strong><a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> or just <strong>reduction</strong>.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> This (entrenched) terminology using "reduction" is a little misleading, because the relation is not necessarily reducing some measure of the objects.</p>

<p>In some contexts it may be beneficial to distinguish between some subsets of the rules, i.e. some subsets of the reduction relation →, e.g. the entire reduction relation may consist of <a class="uri" href="associativity" title="wikilink">associativity</a> and <a class="uri" href="commutativity" title="wikilink">commutativity</a> rules. Consequently, some authors define the reduction relation → as the indexed union of some relations; for instance if 

<math display="inline" id="Abstract_rewriting_system:1">
 <semantics>
  <mrow>
   <msub>
    <mo>→</mo>
    <mn>1</mn>
   </msub>
   <mo>∪</mo>
   <msub>
    <mo>→</mo>
    <mn>2</mn>
   </msub>
   <mo>=</mo>
   <mo>→</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-→</ci>
     <cn type="integer">1</cn>
    </apply>
    <union></union>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-→</ci>
     <cn type="integer">2</cn>
    </apply>
    <eq></eq>
    <ci>normal-→</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rightarrow_{1}\cup\rightarrow_{2}=\rightarrow
  </annotation>
 </semantics>
</math>

, the notation used is (A, →<sub>1</sub>, →<sub>2</sub>).</p>

<p>As a mathematical object, an ARS is exactly the same as an unlabeled <a href="state_transition_system" title="wikilink">state transition system</a>, and if the relation is considered as an indexed union, then an ARS is the same as a labeled state transition system with the indices being the labels. The focus of the study, and the terminology are different however. In a <a href="state_transition_system" title="wikilink">state transition system</a> one is interested in interpreting the labels as actions, whereas in an ARS the focus is on how objects may be transformed (rewritten) into others.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>
<h2 id="example-1">Example 1</h2>

<p>Suppose the set of objects is <em>T</em> = {<em>a</em>, <em>b</em>, <em>c</em>} and the binary relation is given by the rules <em>a</em> → <em>b</em>, <em>b</em> → <em>a</em>, <em>a</em> → <em>c</em>, and <em>b</em> → <em>c</em>. Observe that these rules can be applied to both <em>a</em> and <em>b</em> to get <em>c</em>. Note also, that <em>c</em> is, in a sense, a "simplest" object in the system, since nothing can be applied to <em>c</em> to transform it any further. Such a property is clearly an important one.</p>
<h2 id="basic-notions">Basic notions</h2>

<p>Example 1 leads us to define some important notions in the general setting of an ARS. First we need some basic notions and notations.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>
<ul>
<li>

<math display="inline" id="Abstract_rewriting_system:2">
 <semantics>
  <mover>
   <mo movablelimits="false">→</mo>
   <mo>*</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>normal-→</ci>
    <times></times>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \stackrel{*}{\rightarrow}
  </annotation>
 </semantics>
</math>

 is the <a href="transitive_closure" title="wikilink">transitive closure</a> of 

<math display="inline" id="Abstract_rewriting_system:3">
 <semantics>
  <mrow>
   <mo>→</mo>
   <mo>∪</mo>
   <mo>=</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>normal-→</ci>
    <union></union>
    <eq></eq>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rightarrow\cup=
  </annotation>
 </semantics>
</math>

, where = is the <a href="identity_relation" title="wikilink">identity relation</a>, i.e. 

<math display="inline" id="Abstract_rewriting_system:4">
 <semantics>
  <mover>
   <mo movablelimits="false">→</mo>
   <mo>*</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>normal-→</ci>
    <times></times>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \stackrel{*}{\rightarrow}
  </annotation>
 </semantics>
</math>

 is the smallest <a class="uri" href="preorder" title="wikilink">preorder</a> (<a href="reflexive_relation" title="wikilink">reflexive</a> and <a href="transitive_relation" title="wikilink">transitive</a> relation) containing 

<math display="inline" id="Abstract_rewriting_system:5">
 <semantics>
  <mo>→</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-→</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rightarrow
  </annotation>
 </semantics>
</math>

. It is also called the <a href="reflexive_transitive_closure" title="wikilink">reflexive transitive closure</a> of 

<math display="inline" id="Abstract_rewriting_system:6">
 <semantics>
  <mo>→</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-→</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rightarrow
  </annotation>
 </semantics>
</math>

.</li>
<li>

<math display="inline" id="Abstract_rewriting_system:7">
 <semantics>
  <mo>↔</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-↔</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \leftrightarrow
  </annotation>
 </semantics>
</math>

 is 

<math display="inline" id="Abstract_rewriting_system:8">
 <semantics>
  <mrow>
   <mo>→</mo>
   <mo>∪</mo>
   <msup>
    <mo>→</mo>
    <mrow>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>normal-→</ci>
    <union></union>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-→</ci>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rightarrow\cup\rightarrow^{-1}
  </annotation>
 </semantics>
</math>

, that is the union of the relation → with its <a href="inverse_relation" title="wikilink">inverse relation</a>, also known as the <a href="symmetric_closure" title="wikilink">symmetric closure</a> of 

<math display="inline" id="Abstract_rewriting_system:9">
 <semantics>
  <mo>→</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-→</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rightarrow
  </annotation>
 </semantics>
</math>

.</li>
<li>

<math display="inline" id="Abstract_rewriting_system:10">
 <semantics>
  <mover>
   <mo movablelimits="false">↔</mo>
   <mo>*</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>normal-↔</ci>
    <times></times>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \stackrel{*}{\leftrightarrow}
  </annotation>
 </semantics>
</math>

 is the <a href="transitive_closure" title="wikilink">transitive closure</a> of 

<math display="inline" id="Abstract_rewriting_system:11">
 <semantics>
  <mrow>
   <mo>↔</mo>
   <mo>∪</mo>
   <mo>=</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>normal-↔</ci>
    <union></union>
    <eq></eq>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \leftrightarrow\cup=
  </annotation>
 </semantics>
</math>

, that is 

<math display="inline" id="Abstract_rewriting_system:12">
 <semantics>
  <mover>
   <mo movablelimits="false">↔</mo>
   <mo>*</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>normal-↔</ci>
    <times></times>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \stackrel{*}{\leftrightarrow}
  </annotation>
 </semantics>
</math>

 is the smallest <a href="equivalence_relation" title="wikilink">equivalence relation</a> containing 

<math display="inline" id="Abstract_rewriting_system:13">
 <semantics>
  <mo>→</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-→</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rightarrow
  </annotation>
 </semantics>
</math>

. It is also known as the <a href="reflexive_transitive_symmetric_closure" title="wikilink">reflexive transitive symmetric closure</a> of 

<math display="inline" id="Abstract_rewriting_system:14">
 <semantics>
  <mo>→</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-→</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rightarrow
  </annotation>
 </semantics>
</math>

.</li>
</ul>
<h2 id="normal-forms-and-the-word-problem">Normal forms and the word problem</h2>

<p>  An object <em>x</em> in <em>A</em> is called <strong>reducible</strong> if there exist some other <em>y</em> in <em>A</em> and 

<math display="inline" id="Abstract_rewriting_system:15">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>→</mo>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>x</ci>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\rightarrow y
  </annotation>
 </semantics>
</math>

; otherwise it is called <strong>irreducible</strong> or a <strong>normal form</strong>. An object <em>y</em> is called a normal form of <em>x</em> if 

<math display="inline" id="Abstract_rewriting_system:16">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mover>
    <mo movablelimits="false">→</mo>
    <mo>*</mo>
   </mover>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-→</ci>
     <times></times>
    </apply>
    <ci>x</ci>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\stackrel{*}{\rightarrow}y
  </annotation>
 </semantics>
</math>

, and <em>y</em> is irreducible. If <em>x</em> has a <em>unique</em> normal form, then this is usually denoted with 

<math display="inline" id="Abstract_rewriting_system:17">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>↓</mo>
   <mi></mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-↓</ci>
    <ci>x</ci>
    <csymbol cd="latexml">absent</csymbol>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\downarrow
  </annotation>
 </semantics>
</math>

. In example 1 above, <em>c</em> is a normal form, and 

<math display="inline" id="Abstract_rewriting_system:18">
 <semantics>
  <mrow>
   <mi>c</mi>
   <mo>=</mo>
   <mi>a</mi>
   <mo>↓</mo>
   <mo>=</mo>
   <mi>b</mi>
   <mo>↓</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">c</csymbol>
    <eq></eq>
    <csymbol cd="unknown">a</csymbol>
    <ci>normal-↓</ci>
    <eq></eq>
    <csymbol cd="unknown">b</csymbol>
    <ci>normal-↓</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c=a\downarrow=b\downarrow
  </annotation>
 </semantics>
</math>

. If every object has at least one normal form, the ARS is called <strong>normalizing</strong>.</p>

<p>One of the important problems that may be formulated in an ARS is the <strong>word problem</strong>: given <em>x</em> and <em>y</em> are they equivalent under 

<math display="inline" id="Abstract_rewriting_system:19">
 <semantics>
  <mover>
   <mo movablelimits="false">↔</mo>
   <mo>*</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>normal-↔</ci>
    <times></times>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \stackrel{*}{\leftrightarrow}
  </annotation>
 </semantics>
</math>

? This is a very general setting for formulating the <a href="Word_problem_(mathematics)" title="wikilink">word problem for the presentation of an algebraic structure</a>. For instance, the <a href="word_problem_for_groups" title="wikilink">word problem for groups</a> is a particular case of an ARS word problem. Central to an "easy" solution for the word problem is the existence of unique normal forms: in this case if two objects have the same normal form, then they are equivalent under 

<math display="inline" id="Abstract_rewriting_system:20">
 <semantics>
  <mover>
   <mo movablelimits="false">↔</mo>
   <mo>*</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>normal-↔</ci>
    <times></times>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \stackrel{*}{\leftrightarrow}
  </annotation>
 </semantics>
</math>

. The word problem for an ARS is <a href="undecidable_problem" title="wikilink">undecidable</a> in general.</p>
<h2 id="joinability-and-the-churchrosser-property">Joinability and the Church–Rosser property</h2>

<p>A related, but weaker notion than the existence of normal forms is that of two objects being <strong>joinable</strong>: <em>x</em> and <em>y</em> are said joinable if there exists some <em>z</em> with the property that 

<math display="inline" id="Abstract_rewriting_system:21">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mover>
    <mo movablelimits="false">→</mo>
    <mo>*</mo>
   </mover>
   <mi>z</mi>
   <mover>
    <mo movablelimits="false">←</mo>
    <mo>*</mo>
   </mover>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>normal-→</ci>
      <times></times>
     </apply>
     <ci>x</ci>
     <ci>z</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>normal-←</ci>
      <times></times>
     </apply>
     <share href="#.cmml">
     </share>
     <ci>y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\stackrel{*}{\rightarrow}z\stackrel{*}{\leftarrow}y
  </annotation>
 </semantics>
</math>

. From this definition, it's apparent one may define the joinability relation as 

<math display="inline" id="Abstract_rewriting_system:22">
 <semantics>
  <mrow>
   <mover>
    <mo movablelimits="false">→</mo>
    <mo>*</mo>
   </mover>
   <mo>∘</mo>
   <mover>
    <mo movablelimits="false">←</mo>
    <mo>*</mo>
   </mover>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-→</ci>
     <times></times>
    </apply>
    <compose></compose>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-←</ci>
     <times></times>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \stackrel{*}{\rightarrow}\circ\stackrel{*}{\leftarrow}
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Abstract_rewriting_system:23">
 <semantics>
  <mo>∘</mo>
  <annotation-xml encoding="MathML-Content">
   <compose></compose>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \circ
  </annotation>
 </semantics>
</math>

 is the <a href="composition_of_relations" title="wikilink">composition of relations</a>. Joinability is usually denoted, somewhat confusingly, also with 

<math display="inline" id="Abstract_rewriting_system:24">
 <semantics>
  <mo>↓</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-↓</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \downarrow
  </annotation>
 </semantics>
</math>

, but in this notation the down arrow is a binary relation, i.e. we write 

<math display="inline" id="Abstract_rewriting_system:25">
 <semantics>
  <mrow>
   <mi mathvariant="normal">↓</mi>
   <mrow>
    <mi>x</mi>
    <mo separator="true">,</mo>
    <mi>y</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-↓</ci>
    <ci>x</ci>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\mathbin{\downarrow}y
  </annotation>
 </semantics>
</math>

 if <em>x</em> and <em>y</em> are joinable.</p>

<p>An ARS is said to possess the <strong>Church-Rosser property</strong> if and only if 

<math display="inline" id="Abstract_rewriting_system:26">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mover>
    <mo movablelimits="false">↔</mo>
    <mo>*</mo>
   </mover>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-↔</ci>
     <times></times>
    </apply>
    <ci>x</ci>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\stackrel{*}{\leftrightarrow}y
  </annotation>
 </semantics>
</math>

 implies 

<math display="inline" id="Abstract_rewriting_system:27">
 <semantics>
  <mrow>
   <mi mathvariant="normal">↓</mi>
   <mrow>
    <mi>x</mi>
    <mo separator="true">,</mo>
    <mi>y</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-↓</ci>
    <ci>x</ci>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\mathbin{\downarrow}y
  </annotation>
 </semantics>
</math>

 for all objects <em>x</em>, <em>y</em>. Equivalently, the Church-Rosser property means that the reflexive transitive symmetric closure is contained in the joinability relation. <a href="Alonzo_Church" title="wikilink">Alonzo Church</a> and <a href="J._Barkley_Rosser" title="wikilink">J. Barkley Rosser</a> proved in 1936 that <a href="lambda_calculus" title="wikilink">lambda calculus</a> has this property;<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> hence the name of the property.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> (The fact that lambda calculus has this property is also known as the <a href="Church-Rosser_theorem" title="wikilink">Church-Rosser theorem</a>.) In an ARS with the Church-Rosser property the word problem may be reduced to the search for a common successor. In a Church-Rosser system, an object has <em>at most one</em> normal form; that is the normal form of an object is unique if it exists, but it may well not exist. In lambda calculus for instance, the expression (λx.xx)(λx.xx) does not have a normal form because there exists an infinite sequence of <a href="beta_reduction" title="wikilink">beta reductions</a> (λx.xx)(λx.xx) → (λx.xx)(λx.xx) → ...<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a></p>
<h2 id="notions-of-confluence">Notions of confluence</h2>

<p>Various properties, simpler than Church-Rosser, are equivalent to it. The existence of these equivalent properties allows one to prove that a system is Church-Rosser with less work. Furthermore, the notions of confluence can be defined as properties of a particular object, something that's not possible for Church-Rosser. An ARS 

<math display="inline" id="Abstract_rewriting_system:28">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>A</mi>
   <mo>,</mo>
   <mo>→</mo>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>A</ci>
    <ci>normal-→</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (A,\rightarrow)
  </annotation>
 </semantics>
</math>

 is said to be,</p>
<ul>
<li><strong>confluent</strong> if and only if for all <em>w</em>, <em>x</em>, and <em>y</em> in <em>A</em>, 

<math display="inline" id="Abstract_rewriting_system:29">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mover>
    <mo movablelimits="false">←</mo>
    <mo>*</mo>
   </mover>
   <mi>w</mi>
   <mover>
    <mo movablelimits="false">→</mo>
    <mo>*</mo>
   </mover>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>normal-←</ci>
      <times></times>
     </apply>
     <ci>x</ci>
     <ci>w</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>normal-→</ci>
      <times></times>
     </apply>
     <share href="#.cmml">
     </share>
     <ci>y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\stackrel{*}{\leftarrow}w\stackrel{*}{\rightarrow}y
  </annotation>
 </semantics>
</math>

 implies 

<math display="inline" id="Abstract_rewriting_system:30">
 <semantics>
  <mrow>
   <mi mathvariant="normal">↓</mi>
   <mrow>
    <mi>x</mi>
    <mo separator="true">,</mo>
    <mi>y</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-↓</ci>
    <ci>x</ci>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\mathbin{\downarrow}y
  </annotation>
 </semantics>
</math>

. Roughly speaking, confluence says that no matter how two paths diverge from a common ancestor (<em>w</em>), the paths are joining at <em>some</em> common successor. This notion may be refined as property of a particular object <em>w</em>, and the system called confluent if all its elements are confluent.</li>
<li><strong>semi-confluent</strong> if and only if for all <em>w</em>, <em>x</em>, and <em>y</em> in <em>A</em>, 

<math display="inline" id="Abstract_rewriting_system:31">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>←</mo>
   <mi>w</mi>
   <mover>
    <mo movablelimits="false">→</mo>
    <mo>*</mo>
   </mover>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-←</ci>
     <ci>x</ci>
     <ci>w</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>normal-→</ci>
      <times></times>
     </apply>
     <share href="#.cmml">
     </share>
     <ci>y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\leftarrow w\stackrel{*}{\rightarrow}y
  </annotation>
 </semantics>
</math>

 implies 

<math display="inline" id="Abstract_rewriting_system:32">
 <semantics>
  <mrow>
   <mi mathvariant="normal">↓</mi>
   <mrow>
    <mi>x</mi>
    <mo separator="true">,</mo>
    <mi>y</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-↓</ci>
    <ci>x</ci>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\mathbin{\downarrow}y
  </annotation>
 </semantics>
</math>

. This differs from confluence by the single step reduction from <em>w</em> to <em>x</em>.</li>
<li><strong>locally confluent</strong> if and only if for all <em>w</em>, <em>x</em>, and <em>y</em> in <em>A</em>, 

<math display="inline" id="Abstract_rewriting_system:33">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>←</mo>
   <mi>w</mi>
   <mo>→</mo>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-←</ci>
     <ci>x</ci>
     <ci>w</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <ci>y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\leftarrow w\rightarrow y
  </annotation>
 </semantics>
</math>

 implies 

<math display="inline" id="Abstract_rewriting_system:34">
 <semantics>
  <mrow>
   <mi mathvariant="normal">↓</mi>
   <mrow>
    <mi>x</mi>
    <mo separator="true">,</mo>
    <mi>y</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-↓</ci>
    <ci>x</ci>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\mathbin{\downarrow}y
  </annotation>
 </semantics>
</math>

. This property is sometimes called <strong>weak confluence</strong>.</li>
</ul>

<p><strong>Theorem.</strong> For an ARS the following three conditions are equivalent: (i) it has the Church-Rosser property, (ii) it is confluent, (iii) it is semi-confluent.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a></p>

<p><strong>Corollary</strong>.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> In a confluent ARS if 

<math display="inline" id="Abstract_rewriting_system:35">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mover>
    <mo movablelimits="false">↔</mo>
    <mo>*</mo>
   </mover>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-↔</ci>
     <times></times>
    </apply>
    <ci>x</ci>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\stackrel{*}{\leftrightarrow}y
  </annotation>
 </semantics>
</math>

 then</p>
<ul>
<li>If both <em>x</em> and <em>y</em> are normal forms, then <em>x</em> = <em>y</em>.</li>
<li>If <em>y</em> is a normal form, then 

<math display="inline" id="Abstract_rewriting_system:36">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mover>
    <mo movablelimits="false">→</mo>
    <mo>*</mo>
   </mover>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-→</ci>
     <times></times>
    </apply>
    <ci>x</ci>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\stackrel{*}{\rightarrow}y
  </annotation>
 </semantics>
</math>

</li>
</ul>

<p>Because of these equivalences, a fair bit of variation in definitions is encountered in the literature. For instance, in Terese the Church-Rosser property and confluence are defined to be synonymous and identical to the definition of confluence presented here; Church-Rosser as defined here remains unnamed, but is given as an equivalent property; this departure from other texts is deliberate.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> Because of the above corollary, one may define a normal form <em>y</em> of <em>x</em> as an irreducible <em>y</em> with the property that 

<math display="inline" id="Abstract_rewriting_system:37">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mover>
    <mo movablelimits="false">↔</mo>
    <mo>*</mo>
   </mover>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-↔</ci>
     <times></times>
    </apply>
    <ci>x</ci>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\stackrel{*}{\leftrightarrow}y
  </annotation>
 </semantics>
</math>

. This definition, found in Book and Otto, is equivalent to common one given here in a confluent system, but it is more inclusive in a non-confluent ARS.</p>

<p>Local confluence on the other hand is not equivalent with the other notions of confluence given in this section, but it is strictly weaker than confluence. The typical counterexample is 

<math display="inline" id="Abstract_rewriting_system:38">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mrow>
    <mrow>
     <mi>a</mi>
     <mo>→</mo>
     <mi>b</mi>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mrow>
      <mi>b</mi>
      <mo>→</mo>
      <mi>a</mi>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mrow>
       <mi>a</mi>
       <mo>→</mo>
       <mi>x</mi>
      </mrow>
      <mo>,</mo>
      <mrow>
       <mi>b</mi>
       <mo>→</mo>
       <mi>y</mi>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <csymbol cd="ambiguous">formulae-sequence</csymbol>
     <apply>
      <ci>normal-→</ci>
      <ci>a</ci>
      <ci>b</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">formulae-sequence</csymbol>
      <apply>
       <ci>normal-→</ci>
       <ci>b</ci>
       <ci>a</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">formulae-sequence</csymbol>
       <apply>
        <ci>normal-→</ci>
        <ci>a</ci>
        <ci>x</ci>
       </apply>
       <apply>
        <ci>normal-→</ci>
        <ci>b</ci>
        <ci>y</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{a\rightarrow b,b\rightarrow a,a\rightarrow x,b\rightarrow y\}
  </annotation>
 </semantics>
</math>

, which is locally confluent but not confluent.</p>
<h2 id="termination-and-convergence">Termination and convergence</h2>

<p>An abstract rewriting system is said to be <strong>terminating</strong> or <strong>noetherian</strong> if there is no infinite chain 

<math display="inline" id="Abstract_rewriting_system:39">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mn>0</mn>
   </msub>
   <mo>→</mo>
   <msub>
    <mi>x</mi>
    <mn>1</mn>
   </msub>
   <mo>→</mo>
   <msub>
    <mi>x</mi>
    <mn>2</mn>
   </msub>
   <mo>→</mo>
   <mi mathvariant="normal">⋯</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <ci>normal-⋯</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{0}\rightarrow x_{1}\rightarrow x_{2}\rightarrow\cdots
  </annotation>
 </semantics>
</math>

. (This is just saying that the rewriting relation is a <a href="Noetherian_relation" title="wikilink">Noetherian relation</a>.) In a terminating ARS, every object has at least one normal form, thus it is normalizing. The converse is not true. In example 1 for instance, there is an infinite rewriting chain, namely 

<math display="inline" id="Abstract_rewriting_system:40">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo>→</mo>
   <mi>b</mi>
   <mo>→</mo>
   <mi>a</mi>
   <mo>→</mo>
   <mi>b</mi>
   <mo>→</mo>
   <mi mathvariant="normal">⋯</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-→</ci>
     <ci>a</ci>
     <ci>b</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <ci>a</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <ci>b</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <ci>normal-⋯</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a\rightarrow b\rightarrow a\rightarrow b\rightarrow\cdots
  </annotation>
 </semantics>
</math>

, even though the system is normalizing. A confluent and terminating ARS is called <strong>canonical</strong>,<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a> or <strong>convergent</strong>. In a convergent ARS, every object has a unique normal form. But it is sufficient for the system to be confluent and normalizing for a unique normal to exist for every element, as seen in example 1.</p>

<p><strong>Theorem</strong> (<a href="Newman's_Lemma" title="wikilink">Newman's Lemma</a>): A terminating ARS is confluent if and only if it is locally confluent.</p>

<p>The original 1942 proof of this result by Newman was rather complicated. It wasn't until 1980 that Huet published a much simpler proof exploiting the fact that when 

<math display="inline" id="Abstract_rewriting_system:41">
 <semantics>
  <mo>→</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-→</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rightarrow
  </annotation>
 </semantics>
</math>

 is terminating we can apply <a href="well-founded_induction" title="wikilink">well-founded induction</a>.<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a></p>
<h2 id="notes">Notes</h2>
<h2 id="further-reading">Further reading</h2>
<ul>
<li>

<p>A textbook suitable for undergraduates.</p></li>
<li><a href="Nachum_Dershowitz" title="wikilink">Nachum Dershowitz</a> and <a href="Jean-Pierre_Jouannaud" title="wikilink">Jean-Pierre Jouannaud</a> <a href="http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.64.3114"><em>Rewrite Systems</em></a>, Chapter 6 in <a href="Jan_van_Leeuwen" title="wikilink">Jan van Leeuwen</a> (Ed.), <em>Handbook of Theoretical Computer Science, Volume B: Formal Models and Sematics.</em>, Elsevier and MIT Press, 1990, ISBN 0-444-88074-7, pp. 243–320. The <a class="uri" href="preprint" title="wikilink">preprint</a> of this chapter is freely available from the authors, but it misses the figures.</li>
<li><a href="Ronald_V._Book" title="wikilink">Ronald V. Book</a> and <a href="Friedrich_Otto" title="wikilink">Friedrich Otto</a>, <em>String-rewriting Systems</em>, Springer (1993). Chapter 1, "Abstract reduction systems"</li>
<li><a href="Marc_Bezem" title="wikilink">Marc Bezem</a>, <a href="Jan_Willem_Klop" title="wikilink">Jan Willem Klop</a>, <a href="Roel_de_Vrijer" title="wikilink">Roel de Vrijer</a> ("Terese"), <em>Term rewriting systems</em>, Cambridge University Press, 2003, ISBN 0-521-39115-6, Chapter 1. This is a comprehensive monograph. It uses however a fair deal of notations and definitions not commonly encountered elsewhere. For instance the Church–Rosser property is defined to be identical with confluence.</li>
<li><a href="John_Harrison" title="wikilink">John Harrison</a>, <em>Handbook of Practical Logic and Automated Reasoning</em>, Cambridge University Press, 2009, ISBN 978-0-521-89957-4, chapter 4 "Equality". Abstract rewriting from the practical perspective of solving problems in <a href="Propositional_calculus#Equivalence_to_equational_logics" title="wikilink">equational logic</a>.</li>
<li><a href="Gérard_Huet" title="wikilink">Gérard Huet</a>, <em>Confluent Reductions: Abstract Properties and Applications to Term Rewriting Systems</em>, Journal of the ACM (<a class="uri" href="JACM" title="wikilink">JACM</a>), October 1980, Volume 27, Issue 4, pp. 797–821. Huet's paper established many of the modern concepts, results and notations.</li>
<li>Sinyor, J.; <a href="http://downloads.hindawi.com/journals/ijmms/2010/458563.pdf">"The 3x+1 Problem as a String Rewriting System"</a>, <em>International Journal of Mathematics and Mathematical Sciences</em>, Volume 2010 (2010), Article ID 458563, 6 pages.</li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.pi23.net/art2/">Abstract Rewrite Tool</a> Java Applet to analyse abstract rewrite systems.</li>
</ul>

<p>"</p>

<p><a href="Category:Formal_languages" title="wikilink">Category:Formal languages</a> <a href="Category:Logic_in_computer_science" title="wikilink">Category:Logic in computer science</a> <a href="Category:Rewriting_systems" title="wikilink">Category:Rewriting systems</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Book and Otto, p. 9<a href="#fnref1">↩</a></li>
<li id="fn2">Terese, p. 7,<a href="#fnref2">↩</a></li>
<li id="fn3">Book and Otto, p. 10<a href="#fnref3">↩</a></li>
<li id="fn4">Terese, p. 7<a href="#fnref4">↩</a></li>
<li id="fn5">Book and Otto, p. 10<a href="#fnref5">↩</a></li>
<li id="fn6">Terese, p. 7-8<a href="#fnref6">↩</a></li>
<li id="fn7">Baader and Nipkow, pp. 8-9<a href="#fnref7">↩</a></li>
<li id="fn8">Alonzo Church and J. Barkley Rosser. Some properties of conversion. Trans. AMS, 39:472-482, 1936<a href="#fnref8">↩</a></li>
<li id="fn9">Baader and Nipkow, p. 9<a href="#fnref9">↩</a></li>
<li id="fn10">S.B. Cooper, <em>Computability theory</em>, p. 184<a href="#fnref10">↩</a></li>
<li id="fn11">Baader and Nipkow, p. 11<a href="#fnref11">↩</a></li>
<li id="fn12">Baader and Nipkow, p. 12<a href="#fnref12">↩</a></li>
<li id="fn13">Terese p.11<a href="#fnref13">↩</a></li>
<li id="fn14"> Here: sect.7.2.1, p.153<a href="#fnref14">↩</a></li>
<li id="fn15">Harrison, p. 260<a href="#fnref15">↩</a></li>
</ol>
</section>
</body>
</html>
