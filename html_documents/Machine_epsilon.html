<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1779">Machine epsilon</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Machine epsilon</h1>
<style>
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
<style>
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
</body></html>
<body>
<hr/>

<p><strong>Machine epsilon</strong> gives an upper bound on the <a href="Approximation_error" title="wikilink">relative error</a> due to <a class="uri" href="rounding" title="wikilink">rounding</a> in <a href="floating_point_arithmetic" title="wikilink">floating point arithmetic</a>. This value characterizes <a href="computer_arithmetic" title="wikilink">computer arithmetic</a> in the field of <a href="numerical_analysis" title="wikilink">numerical analysis</a>, and by extension in the subject of <a href="computational_science" title="wikilink">computational science</a>. The quantity is also called <strong>macheps</strong> or <strong>unit roundoff</strong>, and it has the symbols Greek <a class="uri" href="epsilon" title="wikilink">epsilon</a> 

<math display="inline" id="Machine_epsilon:0">
 <semantics>
  <mi>ϵ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϵ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon
  </annotation>
 </semantics>
</math>

 or bold Roman <strong>u</strong>, respectively.</p>
<h2 id="values-for-standard-hardware-floating-point-arithmetics">Values for standard hardware floating point arithmetics</h2>

<p>The following values of machine epsilon apply to standard floating point formats:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>IEEE 754 - 2008</p></th>
<th style="text-align: left;">
<p>Common name</p></th>
<th style="text-align: left;">
<p>C++ data type</p></th>
<th style="text-align: left;">
<p>Base 

<math display="inline" id="Machine_epsilon:1">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>

</p></th>
<th style="text-align: left;">
<p>Precision 

<math display="inline" id="Machine_epsilon:2">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

</p></th>
<th style="text-align: left;">
<p>Machine epsilon 

<math display="inline" id="Machine_epsilon:3">
 <semantics>
  <mrow>
   <msup>
    <mi>b</mi>
    <mrow>
     <mo>-</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>p</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </msup>
   <mo>/</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>b</ci>
     <apply>
      <minus></minus>
      <apply>
       <minus></minus>
       <ci>p</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b^{-(p-1)}/2
  </annotation>
 </semantics>
</math>

</p></th>
<th style="text-align: left;">
<p>Machine epsilon 

<math display="inline" id="Machine_epsilon:4">
 <semantics>
  <msup>
   <mi>b</mi>
   <mrow>
    <mo>-</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>p</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>b</ci>
    <apply>
     <minus></minus>
     <apply>
      <minus></minus>
      <ci>p</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b^{-(p-1)}
  </annotation>
 </semantics>
</math>

</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p><a href="Half_precision_floating-point_format" title="wikilink">binary16</a></p></td>
<td style="text-align: left;">
<p>half precision</p></td>
<td style="text-align: left;">
<p>short</p></td>
<td style="text-align: left;">
<p>2</p></td>
<td style="text-align: left;">
<p>11 (one bit is implicit)</p></td>
<td style="text-align: left;">
<p>2<sup>−11</sup> = 4.88e-04</p></td>
<td style="text-align: left;">
<p>2<sup>−10</sup> = 9.77e-04</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><a href="Single_precision_floating-point_format" title="wikilink">binary32</a></p></td>
<td style="text-align: left;">
<p>single precision</p></td>
<td style="text-align: left;">
<p>float</p></td>
<td style="text-align: left;">
<p>2</p></td>
<td style="text-align: left;">
<p>24 (one bit is implicit)</p></td>
<td style="text-align: left;">
<p>2<sup>−24</sup> = 5.96e-08</p></td>
<td style="text-align: left;">
<p>2<sup>−23</sup> = 1.19e-07</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><a href="Double_precision_floating-point_format" title="wikilink">binary64</a></p></td>
<td style="text-align: left;">
<p>double precision</p></td>
<td style="text-align: left;">
<p>double</p></td>
<td style="text-align: left;">
<p>2</p></td>
<td style="text-align: left;">
<p>53 (one bit is implicit)</p></td>
<td style="text-align: left;">
<p>2<sup>−53</sup> = 1.11e-16</p></td>
<td style="text-align: left;">
<p>2<sup>−52</sup> = 2.22e-16</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><a href="Extended_precision" title="wikilink">binary80</a></p></td>
<td style="text-align: left;">
<p>extended precision</p></td>
<td style="text-align: left;">
<p>_float80<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p></td>
<td style="text-align: left;">
<p>2</p></td>
<td style="text-align: left;">
<p>64</p></td>
<td style="text-align: left;">
<p>2<sup>−64</sup> = 5.42e-20</p></td>
<td style="text-align: left;">
<p>2<sup>−63</sup> = 1.08e-19</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><a href="Quadruple_precision_floating-point_format" title="wikilink">binary128</a></p></td>
<td style="text-align: left;">
<p>quad(ruple) precision</p></td>
<td style="text-align: left;">
<p>_float128<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p></td>
<td style="text-align: left;">
<p>2</p></td>
<td style="text-align: left;">
<p>113 (one bit is implicit)</p></td>
<td style="text-align: left;">
<p>2<sup>−113</sup> = 9.63e-35</p></td>
<td style="text-align: left;">
<p>2<sup>−112</sup> = 1.93e-34</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><a href="Decimal32_floating-point_format" title="wikilink">decimal32</a></p></td>
<td style="text-align: left;">
<p>single precision decimal</p></td>
<td style="text-align: left;">
<p>_Decimal32<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p></td>
<td style="text-align: left;">
<p>10</p></td>
<td style="text-align: left;">
<p>7</p></td>
<td style="text-align: left;">
<p>5 × 10<sup>−7</sup></p></td>
<td style="text-align: left;">
<p>10<sup>−6</sup></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><a href="Decimal64_floating-point_format" title="wikilink">decimal64</a></p></td>
<td style="text-align: left;">
<p>double precision decimal</p></td>
<td style="text-align: left;">
<p>_Decimal64<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p></td>
<td style="text-align: left;">
<p>10</p></td>
<td style="text-align: left;">
<p>16</p></td>
<td style="text-align: left;">
<p>5 × 10<sup>−16</sup></p></td>
<td style="text-align: left;">
<p>10<sup>−15</sup></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><a href="Decimal128_floating-point_format" title="wikilink">decimal128</a></p></td>
<td style="text-align: left;">
<p>quad(ruple) precision decimal</p></td>
<td style="text-align: left;">
<p>_Decimal128<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p></td>
<td style="text-align: left;">
<p>10</p></td>
<td style="text-align: left;">
<p>34</p></td>
<td style="text-align: left;">
<p>5 × 10<sup>−34</sup></p></td>
<td style="text-align: left;">
<p>10<sup>−33</sup></p></td>
</tr>
</tbody>
</table>

<p>according to Prof. Demmel, <a class="uri" href="LAPACK" title="wikilink">LAPACK</a>, <a class="uri" href="Scilab" title="wikilink">Scilab</a> according to Prof. Higham; ISO C standard; <a href="C_(programming_language)" title="wikilink">C</a>, <a class="uri" href="C++" title="wikilink">C++</a> and <a href="Python_(programming_language)" title="wikilink">Python</a> language constants; <a class="uri" href="Mathematica" title="wikilink">Mathematica</a>, <a class="uri" href="MATLAB" title="wikilink">MATLAB</a> and <a href="GNU_Octave" title="wikilink">Octave</a>; various textbooks - see below for the latter definition</p>
<h2 id="formal-definition">Formal definition</h2>

<p><em>Rounding</em> is a procedure for choosing the representation of a <a href="real_number" title="wikilink">real number</a> in a <a href="floating_point" title="wikilink">floating point</a> number system. For a <a href="number_system" title="wikilink">number system</a> and a rounding procedure, machine epsilon is the maximum <a href="relative_error" title="wikilink">relative error</a> of the chosen rounding procedure.</p>

<p>Some background is needed to determine a value from this definition. A floating point number system is characterized by a <a class="uri" href="radix" title="wikilink">radix</a> which is also called the base, 

<math display="inline" id="Machine_epsilon:5">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>

, and by the <a href="precision_(computer_science)" title="wikilink">precision</a> 

<math display="inline" id="Machine_epsilon:6">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

, i.e. the number of radix 

<math display="inline" id="Machine_epsilon:7">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>

 digits of the <a class="uri" href="significand" title="wikilink">significand</a> (including any leading implicit bit). All the numbers with the same <a class="uri" href="exponent" title="wikilink">exponent</a>, 

<math display="inline" id="Machine_epsilon:8">
 <semantics>
  <mi>e</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>e</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e
  </annotation>
 </semantics>
</math>

, have the spacing, 

<math display="inline" id="Machine_epsilon:9">
 <semantics>
  <msup>
   <mi>b</mi>
   <mrow>
    <mi>e</mi>
    <mo>-</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>p</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>b</ci>
    <apply>
     <minus></minus>
     <ci>e</ci>
     <apply>
      <minus></minus>
      <ci>p</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b^{e-(p-1)}
  </annotation>
 </semantics>
</math>

. The spacing changes at the numbers that are perfect powers of 

<math display="inline" id="Machine_epsilon:10">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>

; the spacing on the side of larger <a href="Magnitude_(mathematics)" title="wikilink">magnitude</a> is 

<math display="inline" id="Machine_epsilon:11">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>

 times larger than the spacing on the side of smaller magnitude.</p>

<p>Since machine epsilon is a bound for relative error, it suffices to consider numbers with exponent 

<math display="inline" id="Machine_epsilon:12">
 <semantics>
  <mrow>
   <mi>e</mi>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>e</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e=0
  </annotation>
 </semantics>
</math>

. It also suffices to consider positive numbers. For the usual round-to-nearest kind of rounding, the absolute rounding error is at most half the spacing, or 

<math display="inline" id="Machine_epsilon:13">
 <semantics>
  <mrow>
   <msup>
    <mi>b</mi>
    <mrow>
     <mo>-</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>p</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </msup>
   <mo>/</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>b</ci>
     <apply>
      <minus></minus>
      <apply>
       <minus></minus>
       <ci>p</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b^{-(p-1)}/2
  </annotation>
 </semantics>
</math>

. This value is the biggest possible numerator for the relative error. The <a class="uri" href="denominator" title="wikilink">denominator</a> in the relative error is the number being rounded, which should be as small as possible to make the relative error large. The worst relative error therefore happens when rounding is applied to numbers of the form 

<math display="inline" id="Machine_epsilon:14">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>+</mo>
   <mi>a</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <cn type="integer">1</cn>
    <ci>a</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1+a
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Machine_epsilon:15">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 is between 

<math display="inline" id="Machine_epsilon:16">
 <semantics>
  <mn>0</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">0</cn>
  </annotation-xml>
 </semantics>
</math>

 and 

<math display="inline" id="Machine_epsilon:17">
 <semantics>
  <mrow>
   <msup>
    <mi>b</mi>
    <mrow>
     <mo>-</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>p</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </msup>
   <mo>/</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>b</ci>
     <apply>
      <minus></minus>
      <apply>
       <minus></minus>
       <ci>p</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b^{-(p-1)}/2
  </annotation>
 </semantics>
</math>

. All these numbers round to 

<math display="inline" id="Machine_epsilon:18">
 <semantics>
  <mn>1</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">1</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1
  </annotation>
 </semantics>
</math>

 with relative error 

<math display="inline" id="Machine_epsilon:19">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo>/</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mn>1</mn>
     <mo>+</mo>
     <mi>a</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <ci>a</ci>
    <apply>
     <plus></plus>
     <cn type="integer">1</cn>
     <ci>a</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a/(1+a)
  </annotation>
 </semantics>
</math>

. The maximum occurs when 

<math display="inline" id="Machine_epsilon:20">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 is at the upper end of its range. The 

<math display="inline" id="Machine_epsilon:21">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>+</mo>
   <mi>a</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <cn type="integer">1</cn>
    <ci>a</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1+a
  </annotation>
 </semantics>
</math>

 in the denominator is negligible compared to the numerator, so it is left off for expediency, and just 

<math display="inline" id="Machine_epsilon:22">
 <semantics>
  <mrow>
   <msup>
    <mi>b</mi>
    <mrow>
     <mo>-</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>p</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </msup>
   <mo>/</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>b</ci>
     <apply>
      <minus></minus>
      <apply>
       <minus></minus>
       <ci>p</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b^{-(p-1)}/2
  </annotation>
 </semantics>
</math>

 is taken as machine epsilon. As has been shown here, the relative error is worst for numbers that round to 

<math display="inline" id="Machine_epsilon:23">
 <semantics>
  <mn>1</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">1</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1
  </annotation>
 </semantics>
</math>

, so machine epsilon also is called <em>unit roundoff</em> meaning roughly "the maximum error that can occur when rounding to the unit value".</p>

<p>Thus, the maximum spacing between a normalised floating point number, 

<math display="inline" id="Machine_epsilon:24">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

, and an adjacent normalised number is 

<math display="inline" id="Machine_epsilon:25">
 <semantics>
  <mrow>
   <mn>2</mn>
   <mi>ϵ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <cn type="integer">2</cn>
    <ci>ϵ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2\epsilon
  </annotation>
 </semantics>
</math>

 x 

<math display="inline" id="Machine_epsilon:26">
 <semantics>
  <mrow>
   <mo stretchy="false">|</mo>
   <mi>x</mi>
   <mo stretchy="false">|</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <abs></abs>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |x|
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>
<h2 id="arithmetic-model">Arithmetic model</h2>

<p>Numerical analysis uses machine epsilon to study the effects of rounding error. The actual errors of machine arithmetic are far too complicated to be studied directly, so instead, the following simple model is used. The IEEE arithmetic standard says all floating point operations are done as if it were possible to perform the infinite-precision operation, and then, the result is rounded to a floating point number. Suppose (1) 

<math display="inline" id="Machine_epsilon:27">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Machine_epsilon:28">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

 are floating point numbers, (2) 

<math display="inline" id="Machine_epsilon:29">
 <semantics>
  <mo>∙</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-∙</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bullet
  </annotation>
 </semantics>
</math>

 is an arithmetic operation on floating point numbers such as addition or multiplication, and (3) 

<math display="inline" id="Machine_epsilon:30">
 <semantics>
  <mo>∘</mo>
  <annotation-xml encoding="MathML-Content">
   <compose></compose>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \circ
  </annotation>
 </semantics>
</math>

 is the infinite precision operation. According to the standard, the computer calculates:</p>

<p>

<math display="block" id="Machine_epsilon:31">
 <semantics>
  <mrow>
   <mrow>
    <mi>x</mi>
    <mo>∙</mo>
    <mi>y</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mtext>round</mtext>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>x</mi>
      <mo>∘</mo>
      <mi>y</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>normal-∙</ci>
     <ci>x</ci>
     <ci>y</ci>
    </apply>
    <apply>
     <times></times>
     <mtext>round</mtext>
     <apply>
      <compose></compose>
      <ci>x</ci>
      <ci>y</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\bullet y=\mbox{round}(x\circ y)
  </annotation>
 </semantics>
</math>

</p>

<p>By the meaning of machine epsilon, the relative error of the rounding is at most machine epsilon in magnitude, so:</p>

<p>

<math display="block" id="Machine_epsilon:32">
 <semantics>
  <mrow>
   <mrow>
    <mi>x</mi>
    <mo>∙</mo>
    <mi>y</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>x</mi>
      <mo>∘</mo>
      <mi>y</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mn>1</mn>
      <mo>+</mo>
      <mi>z</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>normal-∙</ci>
     <ci>x</ci>
     <ci>y</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <compose></compose>
      <ci>x</ci>
      <ci>y</ci>
     </apply>
     <apply>
      <plus></plus>
      <cn type="integer">1</cn>
      <ci>z</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\bullet y=(x\circ y)(1+z)
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Machine_epsilon:33">
 <semantics>
  <mi>z</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>z</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z
  </annotation>
 </semantics>
</math>

 in absolute magnitude is at most 

<math display="inline" id="Machine_epsilon:34">
 <semantics>
  <mi>ϵ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϵ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon
  </annotation>
 </semantics>
</math>

 or <strong>u</strong>. The books by Demmel and Higham in the references can be consulted to see how this model is used to analyze the errors of, say, Gaussian elimination.</p>
<h2 id="variant-definitions">Variant definitions</h2>

<p>The IEEE standard does not define the terms <em>machine epsilon</em> and <em>unit roundoff</em>, so differing definitions of these terms are in use, which can cause some confusion.</p>

<p>The definition given here for <em>machine epsilon</em> is the one used by Prof. <a href="James_Demmel" title="wikilink">James Demmel</a> in lecture scripts<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> and his <em>LAPACK</em> linear algebra package,<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> and by numerics research papers<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> and some scientific computing software.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> Most numerical analysts use the words <em>machine epsilon</em> and <em>unit roundoff</em> interchangeably with this meaning.</p>

<p>The following different definition is much more widespread outside academia: <em>Machine epsilon is defined as the smallest number that, when added to one, yields a result different from one.</em> By this definition, 

<math display="inline" id="Machine_epsilon:35">
 <semantics>
  <mi>ϵ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϵ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon
  </annotation>
 </semantics>
</math>

 equals the value of the <a href="unit_in_the_last_place" title="wikilink">unit in the last place</a> relative to 1, i.e. 

<math display="inline" id="Machine_epsilon:36">
 <semantics>
  <msup>
   <mi>b</mi>
   <mrow>
    <mo>-</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>p</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>b</ci>
    <apply>
     <minus></minus>
     <apply>
      <minus></minus>
      <ci>p</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b^{-(p-1)}
  </annotation>
 </semantics>
</math>

,<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> and for the round-to-nearest kind of rounding procedure, <strong>u</strong>

<math display="inline" id="Machine_epsilon:37">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>=</mo>
   <mrow>
    <mi>ϵ</mi>
    <mo>/</mo>
    <mn>2</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <csymbol cd="latexml">absent</csymbol>
    <apply>
     <divide></divide>
     <ci>ϵ</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =\epsilon/2
  </annotation>
 </semantics>
</math>

. The prevalence of this definition is rooted in its use in the ISO C Standard for constants relating to floating-point types<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a><a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> and corresponding constants in other programming languages.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a><a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a> It is also widely used in scientific computing software,<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a><a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a><a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a> in the numerics and computing literature<a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a><a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a><a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a><a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a> and other academic resources.<a class="footnoteRef" href="#fn23" id="fnref23"><sup>23</sup></a><a class="footnoteRef" href="#fn24" id="fnref24"><sup>24</sup></a></p>
<h2 id="how-to-determine-machine-epsilon">How to determine machine epsilon</h2>

<p>Where standard libraries do not provide precomputed values (as  does with <code>FLT_EPSILON</code>, <code>DBL_EPSILON</code> and <code>LDBL_EPSILON</code> for C and  does with <code>std::numeric_limits&lt;<var>T</var>&gt;::epsilon()</code> in C++), the best way to determine machine epsilon is to refer to the table, above, and use the appropriate pow formula. Computing machine epsilon is often given as a textbook exercise. The following examples compute machine epsilon in the sense of the spacing of the floating point numbers at 1 rather than in the sense of the unit roundoff.</p>

<p>Note that results depend on the particular floating-point format used, such as <strong>float</strong>, <strong>double</strong>, <strong>long double</strong>, or similar as supported by the programming language, the compiler, and the runtime library for the actual platform.</p>

<p>Some formats supported by the processor might not be supported by the chosen compiler and operating system. Other formats might be emulated by the runtime library, including <a href="arbitrary-precision_arithmetic" title="wikilink">arbitrary-precision arithmetic</a> available in some languages and libraries.</p>

<p>In a strict sense the term <em>machine epsilon</em> means the <strong>1+eps</strong> accuracy directly supported by the processor (or coprocessor), not some <strong>1+eps</strong> accuracy supported by a specific compiler for a specific operating system, unless it's known to use the best format.</p>

<p><a href="IEEE_754" title="wikilink">IEEE 754</a> floating-point formats have the property that, when reinterpreted as a two's complement integer of the same width, they monotonically increase over positive values and monotonically decrease over negative values (see <a href="Single-precision_floating-point_format#IEEE_754_single-precision_binary_floating-point_format:_binary32" title="wikilink">the binary representation of 32 bit floats</a>). They also have the property that 0  typedef union {</p>

<p><code> long long i64;</code><br/>
<code> double d64;</code></p>

<p>} dbl_64; double machine_eps (double value) {</p>

<p><code>   dbl_64 s;</code><br/>
<code>   s.d64 = value;</code><br/>
<code>   s.i64++;</code><br/>
<code>   return s.d64 - value;</code></p>

<p>}</p>

<p>This will give a result of the same sign as value. If a positive result is always desired, the return statement of machine_eps can be replaced with:</p>
<div class="sourceCode"><pre class="sourceCode C"><code class="sourceCode c">    <span class="kw">return</span> (s.i64 &lt; <span class="dv">0</span> ? value - s.d64 : s.d64 - value);</code></pre></div>

<p>64-bit doubles give 2.220446e-16, which is 2<sup>−52</sup> as expected.</p>
<h3 id="approximation">Approximation</h3>

<p>The following simple algorithm can be used to approximate the machine epsilon, to within a factor of two (one <a href="order_of_magnitude" title="wikilink">order of magnitude</a>) of its true value, using a <a href="linear_search" title="wikilink">linear search</a>.</p>

<p><code>epsilon = 1.0;</code><br/>
<br/>
<code>while (1.0 + 0.5 * epsilon) ≠ 1.0:</code><br/>
<code>    epsilon = 0.5 * epsilon</code></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Floating_point" title="wikilink">Floating point</a>, general discussion of accuracy issues in floating point arithmetic</li>
<li><a href="Unit_in_the_last_place" title="wikilink">Unit in the last place</a> (ULP)</li>
</ul>
<h2 id="notes-and-references">Notes and references</h2>
<ul>
<li>Anderson, E.; <em>LAPACK Users' Guide,</em> Society for Industrial and Applied Mathematics (SIAM), Philadelphia, PA, third edition, 1999.</li>
<li>Cody, William J.; <em>MACHAR: A Soubroutine to Dynamically Determine Machine Parameters,</em> ACM Transactions on Mathematical Software, Vol. 14(4), 1988, 303-311.</li>
<li>Besset, Didier H.; <em>Object-Oriented Implementation of Numerical Methods,</em> Morgan &amp; Kaufmann, San Francisco, CA, 2000.</li>
<li><a href="James_Demmel" title="wikilink">Demmel, James W.</a>, <em>Applied Numerical Linear Algebra,</em> Society for Industrial and Applied Mathematics (SIAM), Philadelphia, PA, 1997.</li>
<li>Higham, Nicholas J.; <em>Accuracy and Stability of Numerical Algorithms,</em> Society for Industrial and Applied Mathematics (SIAM), Philadelphia, PA, second edition, 2002.</li>
<li>Press, William H.; Teukolsky, Saul A.; Vetterling, William T.; and Flannery, Brian P.; <em>Numerical Recipes in Fortran 77</em>, 2nd ed., Chap. 20.2, pp. 881–886</li>
<li>Forsythe, George E.; Malcolm, Michael A.; Moler, Cleve B.; "Computer Methods for Mathematical Computations", Prentice-Hall, ISBN 0-13-165332-6, 1977</li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://orion.math.iastate.edu/burkardt/c_src/machar/machar.html">MACHAR</a>, a routine (in C and Fortran) to "dynamically compute machine constants" (ACM algorithm 722)</li>
<li><a href="http://www.zinnamturm.eu/downloadsAC.htm#CpcFloat">Diagnosing floating point calculations precision</a>, Implementation of MACHAR in <a href="Component_Pascal" title="wikilink">Component Pascal</a> and <a href="Oberon_(programming_language)" title="wikilink">Oberon</a> based on the Fortran 77 version of MACHAR published in Numerical Recipes (Press et al., 1992).</li>
</ul>

<p><a href="it:Epsilon_di_macchina" title="wikilink">it:Epsilon di macchina</a>"</p>

<p><a href="Category:Computer_arithmetic" title="wikilink">Category:Computer arithmetic</a> <a href="Category:Articles_with_example_C_code" title="wikilink">Category:Articles with example C code</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="http://gcc.gnu.org/onlinedocs/gcc/Floating-Types.html#Floating-Types">Floating Types - Using the GNU Compiler Collection (GCC)</a><a href="#fnref1">↩</a></li>
<li id="fn2"></li>
<li id="fn3"><a href="http://gcc.gnu.org/onlinedocs/gcc/Decimal-Float.html#Decimal-Float">Decimal Float - Using the GNU Compiler Collection (GCC)</a><a href="#fnref3">↩</a></li>
<li id="fn4"></li>
<li id="fn5"></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
<li id="fn10"><a href="#fnref10">↩</a></li>
<li id="fn11">note that here p is defined as the precision, i.e. the total number of bits in the significand including implicit leading bit, as used in the table above<a href="#fnref11">↩</a></li>
<li id="fn12"><a href="#fnref12">↩</a></li>
<li id="fn13"><a href="#fnref13">↩</a></li>
<li id="fn14"><a href="#fnref14">↩</a></li>
<li id="fn15"><a href="#fnref15">↩</a></li>
<li id="fn16"><a href="#fnref16">↩</a></li>
<li id="fn17"><a href="#fnref17">↩</a></li>
<li id="fn18"><a href="#fnref18">↩</a></li>
<li id="fn19"><a href="#fnref19">↩</a></li>
<li id="fn20"><a href="#fnref20">↩</a></li>
<li id="fn21"><a href="#fnref21">↩</a></li>
<li id="fn22"><a href="#fnref22">↩</a></li>
<li id="fn23"><a href="#fnref23">↩</a></li>
<li id="fn24"><a href="#fnref24">↩</a></li>
</ol>
</section>
</body>

