<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="107">Pollard's kangaroo algorithm</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Pollard's kangaroo algorithm</h1>
<hr/>

<p>In <a href="computational_number_theory" title="wikilink">computational number theory</a> and <a href="computational_algebra" title="wikilink">computational algebra</a>, <strong>Pollard's kangaroo algorithm</strong> (aka <strong>Pollard's lambda algorithm</strong>, see <a href="#Naming" title="wikilink">Naming</a> below) is an <a class="uri" href="algorithm" title="wikilink">algorithm</a> for solving the <a href="discrete_logarithm" title="wikilink">discrete logarithm</a> problem. The algorithm was introduced in 1978 by the number theorist <a href="John_Pollard_(mathematician)" title="wikilink">J. M. Pollard</a>, in the same paper <a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> as his better-known <a href="Pollard's_rho_algorithm_for_logarithms" title="wikilink">ρ algorithm</a> for solving the same problem. Although Pollard described the application of his algorithm to the discrete logarithm problem in the multiplicative group of units modulo a prime <em>p</em>, it is in fact a generic discrete logarithm algorithm—it will work in any finite cyclic group.</p>
<h2 id="the-algorithm">The algorithm</h2>

<p>Suppose 

<math display="inline" id="Pollard's_kangaroo_algorithm:0">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

 is a finite cyclic group of order 

<math display="inline" id="Pollard's_kangaroo_algorithm:1">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 which is generated by the element 

<math display="inline" id="Pollard's_kangaroo_algorithm:2">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>

, and we seek to find the discrete logarithm 

<math display="inline" id="Pollard's_kangaroo_algorithm:3">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 of the element 

<math display="inline" id="Pollard's_kangaroo_algorithm:4">
 <semantics>
  <mi>β</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>β</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta
  </annotation>
 </semantics>
</math>

 to the base 

<math display="inline" id="Pollard's_kangaroo_algorithm:5">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>

. In other words, we seek 

<math display="inline" id="Pollard's_kangaroo_algorithm:6">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>∈</mo>
   <msub>
    <mi>Z</mi>
    <mi>n</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>x</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Z</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\in Z_{n}
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Pollard's_kangaroo_algorithm:7">
 <semantics>
  <mrow>
   <msup>
    <mi>α</mi>
    <mi>x</mi>
   </msup>
   <mo>=</mo>
   <mi>β</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>α</ci>
     <ci>x</ci>
    </apply>
    <ci>β</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha^{x}=\beta
  </annotation>
 </semantics>
</math>

. The lambda algorithm allows us to search for 

<math display="inline" id="Pollard's_kangaroo_algorithm:8">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 in some subset 

<math display="inline" id="Pollard's_kangaroo_algorithm:9">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">{</mo>
    <mi>a</mi>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mi>b</mi>
    <mo stretchy="false">}</mo>
   </mrow>
   <mo>⊂</mo>
   <msub>
    <mi>Z</mi>
    <mi>n</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <set>
     <ci>a</ci>
     <ci>normal-…</ci>
     <ci>b</ci>
    </set>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Z</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{a,\ldots,b\}\subset Z_{n}
  </annotation>
 </semantics>
</math>

. We may search the entire range of possible logarithms by setting 

<math display="inline" id="Pollard's_kangaroo_algorithm:10">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>a</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a=0
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Pollard's_kangaroo_algorithm:11">
 <semantics>
  <mrow>
   <mi>b</mi>
   <mo>=</mo>
   <mrow>
    <mi>n</mi>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>b</ci>
    <apply>
     <minus></minus>
     <ci>n</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b=n-1
  </annotation>
 </semantics>
</math>

, although in this case <a href="Pollard's_rho_algorithm" title="wikilink">Pollard's rho algorithm</a> is more efficient. We proceed as follows:</p>

<p>1. Choose a set 

<math display="inline" id="Pollard's_kangaroo_algorithm:12">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 of integers and define a <a class="uri" href="pseudorandom" title="wikilink">pseudorandom</a> map 

<math display="inline" id="Pollard's_kangaroo_algorithm:13">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mo>:</mo>
   <mrow>
    <mi>G</mi>
    <mo>→</mo>
    <mi>S</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>f</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>G</ci>
     <ci>S</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f:G\rightarrow S
  </annotation>
 </semantics>
</math>

.</p>

<p>2. Choose an integer 

<math display="inline" id="Pollard's_kangaroo_algorithm:14">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

 and compute a sequence of group elements 

<math display="inline" id="Pollard's_kangaroo_algorithm:15">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <msub>
    <mi>x</mi>
    <mn>0</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>x</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>x</mi>
    <mi>N</mi>
   </msub>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>N</ci>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{x_{0},x_{1},\ldots,x_{N}\}
  </annotation>
 </semantics>
</math>

 according to:</p>
<ul>
<li>

<math display="inline" id="Pollard's_kangaroo_algorithm:16">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mn>0</mn>
   </msub>
   <mo>=</mo>
   <mpadded width="+1.7pt">
    <msup>
     <mi>α</mi>
     <mi>b</mi>
    </msup>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>α</ci>
     <ci>b</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{0}=\alpha^{b}\,
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="Pollard's_kangaroo_algorithm:17">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>x</mi>
     <mrow>
      <mi>i</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>x</mi>
      <mi>i</mi>
     </msub>
     <msup>
      <mi>α</mi>
      <mrow>
       <mi>f</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>x</mi>
         <mi>i</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </msup>
     <mtext>for</mtext>
     <mi>i</mi>
    </mrow>
    <mo>=</mo>
    <mn>0</mn>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mn>1</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mrow>
     <mi>N</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <and></and>
     <apply>
      <eq></eq>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <apply>
        <plus></plus>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>α</ci>
        <apply>
         <times></times>
         <ci>f</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <ci>i</ci>
         </apply>
        </apply>
       </apply>
       <mtext>for</mtext>
       <ci>i</ci>
      </apply>
     </apply>
     <apply>
      <eq></eq>
      <share href="#.cmml">
      </share>
      <cn type="integer">0</cn>
     </apply>
    </apply>
    <list>
     <cn type="integer">1</cn>
     <ci>normal-…</ci>
     <apply>
      <minus></minus>
      <ci>N</ci>
      <cn type="integer">1</cn>
     </apply>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i+1}=x_{i}\alpha^{f(x_{i})}\mbox{ for }i=0,1,\ldots,N-1
  </annotation>
 </semantics>
</math>

</li>
</ul>

<p>3. Compute</p>

<p>

<math display="block" id="Pollard's_kangaroo_algorithm:18">
 <semantics>
  <mrow>
   <mi>d</mi>
   <mo>=</mo>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>0</mn>
     </mrow>
     <mrow>
      <mi>N</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </munderover>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mi>i</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>d</ci>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <apply>
       <minus></minus>
       <ci>N</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d=\sum_{i=0}^{N-1}f(x_{i})
  </annotation>
 </semantics>
</math>

. Observe that:</p>

<p>

<math display="block" id="Pollard's_kangaroo_algorithm:19">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>x</mi>
     <mi>N</mi>
    </msub>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>x</mi>
      <mn>0</mn>
     </msub>
     <msup>
      <mi>α</mi>
      <mi>d</mi>
     </msup>
    </mrow>
    <mo>=</mo>
    <mpadded width="+1.7pt">
     <msup>
      <mi>α</mi>
      <mrow>
       <mi>b</mi>
       <mo>+</mo>
       <mi>d</mi>
      </mrow>
     </msup>
    </mpadded>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>N</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">0</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>α</ci>
       <ci>d</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>α</ci>
      <apply>
       <plus></plus>
       <ci>b</ci>
       <ci>d</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{N}=x_{0}\alpha^{d}=\alpha^{b+d}\,.
  </annotation>
 </semantics>
</math>

 4. Begin computing a second sequence of group elements 

<math display="inline" id="Pollard's_kangaroo_algorithm:20">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <msub>
    <mi>y</mi>
    <mn>0</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>y</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{y_{0},y_{1},\ldots\}
  </annotation>
 </semantics>
</math>

 according to:</p>
<ul>
<li>

<math display="inline" id="Pollard's_kangaroo_algorithm:21">
 <semantics>
  <mrow>
   <msub>
    <mi>y</mi>
    <mn>0</mn>
   </msub>
   <mo>=</mo>
   <mpadded width="+1.7pt">
    <mi>β</mi>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <cn type="integer">0</cn>
    </apply>
    <ci>β</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{0}=\beta\,
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="Pollard's_kangaroo_algorithm:22">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>y</mi>
     <mrow>
      <mi>i</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>y</mi>
      <mi>i</mi>
     </msub>
     <msup>
      <mi>α</mi>
      <mrow>
       <mi>f</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>y</mi>
         <mi>i</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </msup>
     <mtext>for</mtext>
     <mi>i</mi>
    </mrow>
    <mo>=</mo>
    <mn>0</mn>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mn>1</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mrow>
     <mi>N</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <and></and>
     <apply>
      <eq></eq>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <apply>
        <plus></plus>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>α</ci>
        <apply>
         <times></times>
         <ci>f</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>y</ci>
          <ci>i</ci>
         </apply>
        </apply>
       </apply>
       <mtext>for</mtext>
       <ci>i</ci>
      </apply>
     </apply>
     <apply>
      <eq></eq>
      <share href="#.cmml">
      </share>
      <cn type="integer">0</cn>
     </apply>
    </apply>
    <list>
     <cn type="integer">1</cn>
     <ci>normal-…</ci>
     <apply>
      <minus></minus>
      <ci>N</ci>
      <cn type="integer">1</cn>
     </apply>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{i+1}=y_{i}\alpha^{f(y_{i})}\mbox{ for }i=0,1,\ldots,N-1
  </annotation>
 </semantics>
</math>

</li>
</ul>

<p>and a corresponding sequence of integers 

<math display="inline" id="Pollard's_kangaroo_algorithm:23">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <msub>
    <mi>d</mi>
    <mn>0</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>d</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>d</ci>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>d</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{d_{0},d_{1},\ldots\}
  </annotation>
 </semantics>
</math>

 according to:</p>

<p>

<math display="block" id="Pollard's_kangaroo_algorithm:24">
 <semantics>
  <mrow>
   <msub>
    <mi>d</mi>
    <mi>n</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>0</mn>
     </mrow>
     <mrow>
      <mi>n</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </munderover>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>y</mi>
       <mi>i</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>d</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <apply>
       <minus></minus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d_{n}=\sum_{i=0}^{n-1}f(y_{i})
  </annotation>
 </semantics>
</math>

. Observe that:</p>

<p>

<math display="block" id="Pollard's_kangaroo_algorithm:25">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>y</mi>
     <mi>i</mi>
    </msub>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>y</mi>
      <mn>0</mn>
     </msub>
     <msup>
      <mi>α</mi>
      <msub>
       <mi>d</mi>
       <mi>i</mi>
      </msub>
     </msup>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>β</mi>
     <msup>
      <mi>α</mi>
      <msub>
       <mi>d</mi>
       <mi>i</mi>
      </msub>
     </msup>
     <mtext>for</mtext>
     <mi>i</mi>
    </mrow>
    <mo>=</mo>
    <mn>0</mn>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mn>1</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mrow>
     <mi>N</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <and></and>
     <apply>
      <eq></eq>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <cn type="integer">0</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>α</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>d</ci>
         <ci>i</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <eq></eq>
      <share href="#.cmml">
      </share>
      <apply>
       <times></times>
       <ci>β</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>α</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>d</ci>
         <ci>i</ci>
        </apply>
       </apply>
       <mtext>for</mtext>
       <ci>i</ci>
      </apply>
     </apply>
     <apply>
      <eq></eq>
      <share href="#.cmml">
      </share>
      <cn type="integer">0</cn>
     </apply>
    </apply>
    <list>
     <cn type="integer">1</cn>
     <ci>normal-…</ci>
     <apply>
      <minus></minus>
      <ci>N</ci>
      <cn type="integer">1</cn>
     </apply>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{i}=y_{0}\alpha^{d_{i}}=\beta\alpha^{d_{i}}\mbox{ for }i=0,1,\ldots,N-1
  </annotation>
 </semantics>
</math>

 5. Stop computing terms of 

<math display="inline" id="Pollard's_kangaroo_algorithm:26">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <msub>
    <mi>y</mi>
    <mi>i</mi>
   </msub>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <ci>i</ci>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{y_{i}\}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Pollard's_kangaroo_algorithm:27">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <msub>
    <mi>d</mi>
    <mi>i</mi>
   </msub>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>d</ci>
     <ci>i</ci>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{d_{i}\}
  </annotation>
 </semantics>
</math>

 when either of the following conditions are met:</p>
<dl>
<dd>A) 

<math display="inline" id="Pollard's_kangaroo_algorithm:28">
 <semantics>
  <mrow>
   <msub>
    <mi>y</mi>
    <mi>j</mi>
   </msub>
   <mo>=</mo>
   <msub>
    <mi>x</mi>
    <mi>N</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <ci>j</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>N</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{j}=x_{N}
  </annotation>
 </semantics>
</math>

 for some 

<math display="inline" id="Pollard's_kangaroo_algorithm:29">
 <semantics>
  <mi>j</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>j</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   j
  </annotation>
 </semantics>
</math>

. If the sequences 

<math display="inline" id="Pollard's_kangaroo_algorithm:30">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <msub>
    <mi>x</mi>
    <mi>i</mi>
   </msub>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>i</ci>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{x_{i}\}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Pollard's_kangaroo_algorithm:31">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <msub>
    <mi>y</mi>
    <mi>j</mi>
   </msub>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <ci>j</ci>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{y_{j}\}
  </annotation>
 </semantics>
</math>

 "collide" in this manner, then we have:

<p>:<math>x_N = y_j \Rightarrow \alpha^{b+d} = \beta\alpha^{d_j} \Rightarrow \beta = \alpha^{b+d-d_j} \pmod{n} \Rightarrow</math></p>
</dd>
</dl>

<p>x \equiv b+d-d_j \pmod{n}</p>
<dl>
<dd>and so we are done.
</dd>
</dl>
<dl>
<dd>B) 

<math display="inline" id="Pollard's_kangaroo_algorithm:32">
 <semantics>
  <mrow>
   <msub>
    <mi>d</mi>
    <mi>i</mi>
   </msub>
   <mo>></mo>
   <mrow>
    <mrow>
     <mi>b</mi>
     <mo>-</mo>
     <mi>a</mi>
    </mrow>
    <mo>+</mo>
    <mi>d</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>d</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <minus></minus>
      <ci>b</ci>
      <ci>a</ci>
     </apply>
     <ci>d</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d_{i}>b-a+d
  </annotation>
 </semantics>
</math>

. If this occurs, then the algorithm has failed to find 

<math display="inline" id="Pollard's_kangaroo_algorithm:33">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

. Subsequent attempts can be made by changing the choice of 

<math display="inline" id="Pollard's_kangaroo_algorithm:34">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 and/or 

<math display="inline" id="Pollard's_kangaroo_algorithm:35">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

.
</dd>
</dl>
<h2 id="complexity">Complexity</h2>

<p>Pollard gives the time complexity of the algorithm as 

<math display="inline" id="Pollard's_kangaroo_algorithm:36">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msqrt>
     <mrow>
      <mi>b</mi>
      <mo>-</mo>
      <mi>a</mi>
     </mrow>
    </msqrt>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <root></root>
     <apply>
      <minus></minus>
      <ci>b</ci>
      <ci>a</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\scriptstyle O(\sqrt{b-a})}
  </annotation>
 </semantics>
</math>

, based on a probabilistic argument which follows from the assumption that <em>f</em> acts pseudorandomly. Note that when the size of the set {<em>a</em>, …, <em>b</em>} to be searched is measured in <a href="Binary_digit" title="wikilink">bits</a>, as is normal in <a href="Computational_complexity_theory" title="wikilink">complexity theory</a>, the set has size log(<em>b</em> − <em>a</em>), and so the algorithm's complexity is 

<math display="inline" id="Pollard's_kangaroo_algorithm:37">
 <semantics>
  <mrow>
   <mrow>
    <mi>O</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msqrt>
      <mrow>
       <mi>b</mi>
       <mo>-</mo>
       <mi>a</mi>
      </mrow>
     </msqrt>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>O</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mn>2</mn>
      <mrow>
       <mstyle scriptlevel="+1">
        <mfrac>
         <mn>1</mn>
         <mn>2</mn>
        </mfrac>
       </mstyle>
       <mrow>
        <mi>log</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mi>b</mi>
          <mo>-</mo>
          <mi>a</mi>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>O</ci>
     <apply>
      <root></root>
      <apply>
       <minus></minus>
       <ci>b</ci>
       <ci>a</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>O</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <log></log>
        <apply>
         <minus></minus>
         <ci>b</ci>
         <ci>a</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\scriptstyle O(\sqrt{b-a})=O(2^{\frac{1}{2}\log(b-a)})}
  </annotation>
 </semantics>
</math>

, which is exponential in the problem size. For this reason, Pollard's lambda algorithm is considered an <a href="exponential_time" title="wikilink">exponential time</a> algorithm. For an example of a <a href="subexponential_time" title="wikilink">subexponential time</a> discrete logarithm algorithm, see the <a href="index_calculus_algorithm" title="wikilink">index calculus algorithm</a>.</p>
<h2 id="naming">Naming</h2>

<p>The algorithm is well known by two names.</p>

<p>The first is "Pollard's kangaroo algorithm". This name is a reference to an analogy used in the paper presenting the algorithm, where the algorithm is explained in terms of using a <em>tame</em> <a class="uri" href="kangaroo" title="wikilink">kangaroo</a> to trap a <em>wild</em> kangaroo. Pollard has explained<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> that this analogy was inspired by a "fascinating" article published in the same issue of <em><a href="Scientific_American" title="wikilink">Scientific American</a></em> as an exposition of the <a href="RSA_(algorithm)" title="wikilink">RSA</a> <a href="public_key_cryptosystem" title="wikilink">public key cryptosystem</a>. The article<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> described an experiment in which a kangaroo's "energetic cost of locomotion, measured in terms of oxygen consumption at various speeds, was determined by placing kangaroos on a <a class="uri" href="treadmill" title="wikilink">treadmill</a>".</p>

<p>The second is "Pollard's lambda algorithm". Much like the name of another of Pollard's discrete logarithm algorithms, <a href="Pollard's_rho_algorithm_for_logarithms" title="wikilink">Pollard's rho algorithm</a>, this name refers to the similarity between a visualisation of the algorithm and the <a href="Greek_letter" title="wikilink">Greek letter</a> <a class="uri" href="lambda" title="wikilink">lambda</a> (

<math display="inline" id="Pollard's_kangaroo_algorithm:38">
 <semantics>
  <mi>λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda
  </annotation>
 </semantics>
</math>

). The shorter stroke of the letter lambda corresponds to the sequence 

<math display="inline" id="Pollard's_kangaroo_algorithm:39">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <msub>
    <mi>x</mi>
    <mi>i</mi>
   </msub>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>i</ci>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{x_{i}\}
  </annotation>
 </semantics>
</math>

, since it starts from the position b to the right of x. Accordingly, the longer stroke corresponds to the sequence 

<math display="inline" id="Pollard's_kangaroo_algorithm:40">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <msub>
    <mi>y</mi>
    <mi>i</mi>
   </msub>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <ci>i</ci>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{y_{i}\}
  </annotation>
 </semantics>
</math>

, which "collides with" the first sequence (just like the strokes of a lambda intersect) and then follows it subsequently.</p>

<p>Pollard has expressed a preference for the name "kangaroo algorithm",<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> as this avoids confusion with some parallel versions of his rho algorithm, which have also been called "lambda algorithms".</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Rainbow_table" title="wikilink">Rainbow table</a></li>
</ul>
<h2 id="references">References</h2>
<references>
</references>

<p>"</p>

<p><a href="Category:Number_theoretic_algorithms" title="wikilink">Category:Number theoretic algorithms</a> <a href="Category:Computer_algebra" title="wikilink">Category:Computer algebra</a> <a class="uri" href="Category:Logarithms" title="wikilink">Category:Logarithms</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">J. Pollard, <em>Monte Carlo methods for index computation mod p</em>, Mathematics of Computation, Volume 32, 1978<a href="#fnref1">↩</a></li>
<li id="fn2">J. M. Pollard, <em>Kangaroos, Monopoly and Discrete Logarithms</em>, Journal of Cryptology, Volume 13, pp 437-447, 2000<a href="#fnref2">↩</a></li>
<li id="fn3">T. J. Dawson, <em>Kangaroos</em>, Scientific American, August 1977, pp. 78-89<a href="#fnref3">↩</a></li>
<li id="fn4"><a class="uri" href="http://sites.google.com/site/jmptidcott2/">http://sites.google.com/site/jmptidcott2/</a><a href="#fnref4">↩</a></li>
</ol>
</section>
</body>
</html>
