<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="167">Combinatory categorial grammar</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Combinatory categorial grammar</h1>
<hr/>

<p><strong>Combinatory <a href="categorial_grammar" title="wikilink">categorial grammar</a> (CCG)</strong> is an efficiently parsable, yet linguistically expressive grammar formalism. It has a transparent interface between surface syntax and underlying semantic representation, including predicate-argument structure, quantification and information structure. The formalism generates constituency-based structures (as opposed to dependency-based ones) and is therefore a type of <a href="phrase_structure_grammar" title="wikilink">phrase structure grammar</a> (as opposed to a <a href="dependency_grammar" title="wikilink">dependency grammar</a>).</p>

<p>CCG relies on <a href="combinatory_logic" title="wikilink">combinatory logic</a>, which has the same expressive power as the <a href="lambda_calculus" title="wikilink">lambda calculus</a>, but builds its expressions differently. The first linguistic and psycholinguistic arguments for basing the grammar on combinators were put forth by <a href="Mark_Steedman" title="wikilink">Steedman</a> and <a href="Anna_Szabolcsi" title="wikilink">Szabolcsi</a>. More recent prominent proponents of the approach are <a href="http://cog.brown.edu/People/jacobson/">Jacobson</a> and <a href="http://www.jasonbaldridge.com/">Baldridge</a>.</p>

<p>For example, the <a class="uri" href="combinator" title="wikilink">combinator</a> B (the compositor) is useful in creating long-distance dependencies, as in "Who do you think Mary is talking about?" and the combinator W (the duplicator) is useful as the lexical interpretation of reflexive pronouns, as in "Mary talks about herself". Together with I (the identity mapping) and C (the permutator) these form a set of primitive, non-interdefinable combinators. Jacobson interprets personal pronouns as the combinator I, and their binding is aided by a complex combinator Z, as in "Mary lost her way". Z is definable using W and B.</p>
<h2 id="parts-of-the-formalism">Parts of the Formalism</h2>

<p>The CCG formalism defines a number of combinators (application, composition, and type-raising being the most common). These operate on syntactically-typed lexical items, by means of <a href="Natural_deduction" title="wikilink">Natural deduction</a> style proofs. The goal of the proof is to find some way of applying the combinators to a sequence of lexical items until no lexical item is unused in the proof. The resulting type after the proof is complete is the type of the whole expression. Thus, proving that some sequence of words is a sentence of some language amounts to proving that the words reduce to the type <em>S</em>.</p>
<h3 id="syntactic-types">Syntactic Types</h3>

<p>The syntactic type of a lexical item can be either a primitive type, such as <em>S</em>, <em>N</em>, or <em>NP</em>, or complex, such as <em>S\NP</em>, or <em>NP/N</em>.</p>

<p>The complex types, schematizable as <em>X/Y</em> and <em>X\Y</em>, denote functor types that take an argument of type <em>Y</em> and return an object of type <em>X</em>. A forward slash denotes that the argument should appear to the right, while a backslash denotes that the argument should appear on the left. Any type can stand in for the <em>X</em> and <em>Y</em> here, making syntactic types in CCG a recursive type system.</p>
<h3 id="application-combinators">Application Combinators</h3>

<p>The application combinators, often denoted by <em>&gt;</em> for forward application and ''\dfrac{\alpha : X/Y \qquad \beta : Y}{\alpha \beta : X}&gt; 

<math display="inline" id="Combinatory_categorial_grammar:0">
 <semantics>
  <mrow>
   <mstyle displaystyle="true">
    <mfrac>
     <mrow>
      <mi>β</mi>
      <mo>:</mo>
      <mrow>
       <mi>Y</mi>
       <mi>α</mi>
      </mrow>
      <mo>:</mo>
      <mrow>
       <mi>X</mi>
       <mo>\</mo>
       <mi>Y</mi>
      </mrow>
     </mrow>
     <mrow>
      <mrow>
       <mi>β</mi>
       <mi>α</mi>
      </mrow>
      <mo>:</mo>
      <mi>X</mi>
     </mrow>
    </mfrac>
   </mstyle>
   <mo><</mo>
   <mi></mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <divide></divide>
     <apply>
      <and></and>
      <apply>
       <ci>normal-:</ci>
       <ci>β</ci>
       <list>
        <ci>Y</ci>
        <ci>α</ci>
       </list>
      </apply>
      <apply>
       <ci>normal-:</ci>
       <share href="#.cmml">
       </share>
       <apply>
        <ci>normal-\</ci>
        <ci>X</ci>
        <ci>Y</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <ci>normal-:</ci>
      <apply>
       <times></times>
       <ci>β</ci>
       <ci>α</ci>
      </apply>
      <ci>X</ci>
     </apply>
    </apply>
    <csymbol cd="latexml">absent</csymbol>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \dfrac{\beta:Y\qquad\alpha:X\backslash Y}{\beta\alpha:X}<
  </annotation>
 </semantics>
</math>

</p>
<h3 id="composition-combinators">Composition Combinators</h3>

<p>The composition combinators, often denoted by 

<math display="inline" id="Combinatory_categorial_grammar:1">
 <semantics>
  <msub>
   <mi>B</mi>
   <mo>></mo>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>B</ci>
    <gt></gt>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B_{>}
  </annotation>
 </semantics>
</math>

 for forward composition and 

<math display="inline" id="Combinatory_categorial_grammar:2">
 <semantics>
  <msub>
   <mi>B</mi>
   <mo><</mo>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>B</ci>
    <lt></lt>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B_{<}
  </annotation>
 </semantics>
</math>

 for backward composition, are similar to function composition from mathematics, and can be defined as follows:</p>

<p>

<math display="inline" id="Combinatory_categorial_grammar:3">
 <semantics>
  <mrow>
   <mstyle displaystyle="true">
    <mfrac>
     <mrow>
      <mi>α</mi>
      <mo>:</mo>
      <mrow>
       <mrow>
        <mi>X</mi>
        <mo>/</mo>
        <mi>Y</mi>
       </mrow>
       <mi>β</mi>
      </mrow>
      <mo>:</mo>
      <mrow>
       <mi>Y</mi>
       <mo>/</mo>
       <mi>Z</mi>
      </mrow>
     </mrow>
     <mrow>
      <mrow>
       <mi>α</mi>
       <mi>β</mi>
      </mrow>
      <mo>:</mo>
      <mrow>
       <mi>X</mi>
       <mo>/</mo>
       <mi>Z</mi>
      </mrow>
     </mrow>
    </mfrac>
   </mstyle>
   <msub>
    <mi>B</mi>
    <mo>></mo>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <apply>
      <and></and>
      <apply>
       <ci>normal-:</ci>
       <ci>α</ci>
       <list>
        <apply>
         <divide></divide>
         <ci>X</ci>
         <ci>Y</ci>
        </apply>
        <ci>β</ci>
       </list>
      </apply>
      <apply>
       <ci>normal-:</ci>
       <share href="#.cmml">
       </share>
       <apply>
        <divide></divide>
        <ci>Y</ci>
        <ci>Z</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <ci>normal-:</ci>
      <apply>
       <times></times>
       <ci>α</ci>
       <ci>β</ci>
      </apply>
      <apply>
       <divide></divide>
       <ci>X</ci>
       <ci>Z</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>B</ci>
     <gt></gt>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \dfrac{\alpha:X/Y\qquad\beta:Y/Z}{\alpha\beta:X/Z}B_{>}
  </annotation>
 </semantics>
</math>


 

<math display="inline" id="Combinatory_categorial_grammar:4">
 <semantics>
  <mrow>
   <mstyle displaystyle="true">
    <mfrac>
     <mrow>
      <mi>β</mi>
      <mo>:</mo>
      <mrow>
       <mrow>
        <mi>Y</mi>
        <mo>\</mo>
        <mi>Z</mi>
       </mrow>
       <mi>α</mi>
      </mrow>
      <mo>:</mo>
      <mrow>
       <mi>X</mi>
       <mo>\</mo>
       <mi>Y</mi>
      </mrow>
     </mrow>
     <mrow>
      <mrow>
       <mi>β</mi>
       <mi>α</mi>
      </mrow>
      <mo>:</mo>
      <mrow>
       <mi>X</mi>
       <mo>\</mo>
       <mi>Z</mi>
      </mrow>
     </mrow>
    </mfrac>
   </mstyle>
   <msub>
    <mi>B</mi>
    <mo><</mo>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <apply>
      <and></and>
      <apply>
       <ci>normal-:</ci>
       <ci>β</ci>
       <list>
        <apply>
         <ci>normal-\</ci>
         <ci>Y</ci>
         <ci>Z</ci>
        </apply>
        <ci>α</ci>
       </list>
      </apply>
      <apply>
       <ci>normal-:</ci>
       <share href="#.cmml">
       </share>
       <apply>
        <ci>normal-\</ci>
        <ci>X</ci>
        <ci>Y</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <ci>normal-:</ci>
      <apply>
       <times></times>
       <ci>β</ci>
       <ci>α</ci>
      </apply>
      <apply>
       <ci>normal-\</ci>
       <ci>X</ci>
       <ci>Z</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>B</ci>
     <lt></lt>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \dfrac{\beta:Y\backslash Z\qquad\alpha:X\backslash Y}{\beta\alpha:X\backslash Z%
}B_{<}
  </annotation>
 </semantics>
</math>

</p>
<h3 id="type-raising-combinators">Type-raising Combinators</h3>

<p>The type-raising combinators, often denoted as 

<math display="inline" id="Combinatory_categorial_grammar:5">
 <semantics>
  <msub>
   <mi>T</mi>
   <mo>></mo>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>T</ci>
    <gt></gt>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T_{>}
  </annotation>
 </semantics>
</math>

 for forward type-raising and 

<math display="inline" id="Combinatory_categorial_grammar:6">
 <semantics>
  <msub>
   <mi>T</mi>
   <mo><</mo>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>T</ci>
    <lt></lt>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T_{<}
  </annotation>
 </semantics>
</math>

 for backward type-raising, take argument types (usually primitive types) to functor types, which take as their argument the functors that, before type-raising, would have taken them as arguments.</p>

<p>

<math display="inline" id="Combinatory_categorial_grammar:7">
 <semantics>
  <mrow>
   <mstyle displaystyle="true">
    <mfrac>
     <mrow>
      <mi>α</mi>
      <mo>:</mo>
      <mi>X</mi>
     </mrow>
     <mrow>
      <mi>α</mi>
      <mo>:</mo>
      <mrow>
       <mi>T</mi>
       <mo>/</mo>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>T</mi>
         <mo>\</mo>
         <mi>X</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </mfrac>
   </mstyle>
   <msub>
    <mi>T</mi>
    <mo>></mo>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <apply>
      <ci>normal-:</ci>
      <ci>α</ci>
      <ci>X</ci>
     </apply>
     <apply>
      <ci>normal-:</ci>
      <ci>α</ci>
      <apply>
       <divide></divide>
       <ci>T</ci>
       <apply>
        <ci>normal-\</ci>
        <ci>T</ci>
        <ci>X</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>T</ci>
     <gt></gt>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \dfrac{\alpha:X}{\alpha:T/(T\backslash X)}T_{>}
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Combinatory_categorial_grammar:8">
 <semantics>
  <mrow>
   <mstyle displaystyle="true">
    <mfrac>
     <mrow>
      <mi>α</mi>
      <mo>:</mo>
      <mi>X</mi>
     </mrow>
     <mrow>
      <mi>α</mi>
      <mo>:</mo>
      <mrow>
       <mi>T</mi>
       <mo>\</mo>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>T</mi>
         <mo>/</mo>
         <mi>X</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </mfrac>
   </mstyle>
   <msub>
    <mi>T</mi>
    <mo><</mo>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <apply>
      <ci>normal-:</ci>
      <ci>α</ci>
      <ci>X</ci>
     </apply>
     <apply>
      <ci>normal-:</ci>
      <ci>α</ci>
      <apply>
       <ci>normal-\</ci>
       <ci>T</ci>
       <apply>
        <divide></divide>
        <ci>T</ci>
        <ci>X</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>T</ci>
     <lt></lt>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \dfrac{\alpha:X}{\alpha:T\backslash(T/X)}T_{<}
  </annotation>
 </semantics>
</math>


</p>
<h2 id="example">Example</h2>

<p>The sentence "the dog bit John" has a number of different possible proofs. Below are a few of them. The variety of proofs demonstrates the fact that in CCG, sentences don't have a single structure, as in other models of grammar.</p>

<p>Let the types of these lexical items be</p>

<p>

<math display="inline" id="Combinatory_categorial_grammar:9">
 <semantics>
  <mrow>
   <mrow>
    <mi>t</mi>
    <mi>h</mi>
    <mi>e</mi>
   </mrow>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mrow>
      <mi>N</mi>
      <mi>P</mi>
     </mrow>
     <mo>/</mo>
     <mi>N</mi>
    </mrow>
    <mrow>
     <mi>d</mi>
     <mi>o</mi>
     <mi>g</mi>
    </mrow>
   </mrow>
   <mo>:</mo>
   <mrow>
    <mi>N</mi>
    <mrow>
     <mi>J</mi>
     <mi>o</mi>
     <mi>h</mi>
     <mi>n</mi>
    </mrow>
   </mrow>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mi>N</mi>
     <mi>P</mi>
    </mrow>
    <mrow>
     <mi>b</mi>
     <mi>i</mi>
     <mi>t</mi>
    </mrow>
   </mrow>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <mi>S</mi>
        <mo>\</mo>
        <mi>N</mi>
       </mrow>
       <mi>P</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>/</mo>
     <mi>N</mi>
    </mrow>
    <mi>P</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-:</ci>
     <apply>
      <times></times>
      <ci>t</ci>
      <ci>h</ci>
      <ci>e</ci>
     </apply>
     <list>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <ci>N</ci>
        <ci>P</ci>
       </apply>
       <ci>N</ci>
      </apply>
      <apply>
       <times></times>
       <ci>d</ci>
       <ci>o</ci>
       <ci>g</ci>
      </apply>
     </list>
    </apply>
    <apply>
     <ci>normal-:</ci>
     <share href="#.cmml">
     </share>
     <list>
      <ci>N</ci>
      <apply>
       <times></times>
       <ci>J</ci>
       <ci>o</ci>
       <ci>h</ci>
       <ci>n</ci>
      </apply>
     </list>
    </apply>
    <apply>
     <ci>normal-:</ci>
     <share href="#.cmml">
     </share>
     <list>
      <apply>
       <times></times>
       <ci>N</ci>
       <ci>P</ci>
      </apply>
      <apply>
       <times></times>
       <ci>b</ci>
       <ci>i</ci>
       <ci>t</ci>
      </apply>
     </list>
    </apply>
    <apply>
     <ci>normal-:</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <apply>
         <ci>normal-\</ci>
         <ci>S</ci>
         <ci>N</ci>
        </apply>
        <ci>P</ci>
       </apply>
       <ci>N</ci>
      </apply>
      <ci>P</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   the:NP/N\qquad dog:N\qquad John:NP\qquad bit:(S\backslash NP)/NP
  </annotation>
 </semantics>
</math>

</p>

<p>We can perform the simplest proof (changing notation slightly for brevity) as:</p>

<p>

<math display="inline" id="Combinatory_categorial_grammar:10">
 <semantics>
  <mrow>
   <mstyle displaystyle="true">
    <mfrac>
     <mrow>
      <mstyle displaystyle="true">
       <mfrac>
        <mrow>
         <mstyle displaystyle="true">
          <mfrac>
           <mrow>
            <mi>t</mi>
            <mi>h</mi>
            <mi>e</mi>
           </mrow>
           <mrow>
            <mrow>
             <mi>N</mi>
             <mi>P</mi>
            </mrow>
            <mo>/</mo>
            <mi>N</mi>
           </mrow>
          </mfrac>
         </mstyle>
         <mstyle displaystyle="true">
          <mfrac>
           <mrow>
            <mi>d</mi>
            <mi>o</mi>
            <mi>g</mi>
           </mrow>
           <mi>N</mi>
          </mfrac>
         </mstyle>
        </mrow>
        <mrow>
         <mi>N</mi>
         <mi>P</mi>
        </mrow>
       </mfrac>
      </mstyle>
      <mo>></mo>
      <mstyle displaystyle="true">
       <mfrac>
        <mrow>
         <mstyle displaystyle="true">
          <mfrac>
           <mrow>
            <mi>b</mi>
            <mi>i</mi>
            <mi>t</mi>
           </mrow>
           <mrow>
            <mrow>
             <mrow>
              <mo stretchy="false">(</mo>
              <mrow>
               <mrow>
                <mi>S</mi>
                <mo>\</mo>
                <mi>N</mi>
               </mrow>
               <mi>P</mi>
              </mrow>
              <mo stretchy="false">)</mo>
             </mrow>
             <mo>/</mo>
             <mi>N</mi>
            </mrow>
            <mi>P</mi>
           </mrow>
          </mfrac>
         </mstyle>
         <mstyle displaystyle="true">
          <mfrac>
           <mrow>
            <mi>J</mi>
            <mi>o</mi>
            <mi>h</mi>
            <mi>n</mi>
           </mrow>
           <mrow>
            <mi>N</mi>
            <mi>P</mi>
           </mrow>
          </mfrac>
         </mstyle>
        </mrow>
        <mrow>
         <mrow>
          <mi>S</mi>
          <mo>\</mo>
          <mi>N</mi>
         </mrow>
         <mi>P</mi>
        </mrow>
       </mfrac>
      </mstyle>
      <mo>></mo>
     </mrow>
     <mi>S</mi>
    </mfrac>
   </mstyle>
   <mo><</mo>
   <mi></mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <divide></divide>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <apply>
       <divide></divide>
       <list>
        <apply>
         <divide></divide>
         <apply>
          <times></times>
          <ci>t</ci>
          <ci>h</ci>
          <ci>e</ci>
         </apply>
         <apply>
          <divide></divide>
          <apply>
           <times></times>
           <ci>N</ci>
           <ci>P</ci>
          </apply>
          <ci>N</ci>
         </apply>
        </apply>
        <apply>
         <divide></divide>
         <apply>
          <times></times>
          <ci>d</ci>
          <ci>o</ci>
          <ci>g</ci>
         </apply>
         <ci>N</ci>
        </apply>
       </list>
       <apply>
        <times></times>
        <ci>N</ci>
        <ci>P</ci>
       </apply>
      </apply>
      <gt></gt>
      <ci>italic-</ci>
      <apply>
       <divide></divide>
       <list>
        <apply>
         <divide></divide>
         <apply>
          <times></times>
          <ci>b</ci>
          <ci>i</ci>
          <ci>t</ci>
         </apply>
         <apply>
          <times></times>
          <apply>
           <divide></divide>
           <apply>
            <times></times>
            <apply>
             <ci>normal-\</ci>
             <ci>S</ci>
             <ci>N</ci>
            </apply>
            <ci>P</ci>
           </apply>
           <ci>N</ci>
          </apply>
          <ci>P</ci>
         </apply>
        </apply>
        <apply>
         <divide></divide>
         <apply>
          <times></times>
          <ci>J</ci>
          <ci>o</ci>
          <ci>h</ci>
          <ci>n</ci>
         </apply>
         <apply>
          <times></times>
          <ci>N</ci>
          <ci>P</ci>
         </apply>
        </apply>
       </list>
       <apply>
        <times></times>
        <apply>
         <ci>normal-\</ci>
         <ci>S</ci>
         <ci>N</ci>
        </apply>
        <ci>P</ci>
       </apply>
      </apply>
      <gt></gt>
     </cerror>
     <ci>S</ci>
    </apply>
    <csymbol cd="latexml">absent</csymbol>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \dfrac{\dfrac{\dfrac{the}{NP/N}\qquad\dfrac{dog}{N}}{NP}>\qquad\dfrac{\dfrac{%
bit}{(S\backslash NP)/NP}\qquad\dfrac{John}{NP}}{S\backslash NP}>}{S}<
  </annotation>
 </semantics>
</math>

</p>

<p>Opting to type-raise and compose some, we could get a fully incremental, left-to-right proof. The ability to construct such a proof is an argument for the psycholinguistic plausibility of CCG, because listeners do in fact construct partial interpretations (syntactic and semantic) of utterances before they have been completed.</p>

<p>

<math display="inline" id="Combinatory_categorial_grammar:11">
 <semantics>
  <mrow>
   <mstyle displaystyle="true">
    <mfrac>
     <mrow>
      <mrow>
       <mstyle displaystyle="true">
        <mfrac>
         <mrow>
          <mrow>
           <mstyle displaystyle="true">
            <mfrac>
             <mrow>
              <mstyle displaystyle="true">
               <mfrac>
                <mrow>
                 <mstyle displaystyle="true">
                  <mfrac>
                   <mrow>
                    <mi>t</mi>
                    <mi>h</mi>
                    <mi>e</mi>
                   </mrow>
                   <mrow>
                    <mrow>
                     <mi>N</mi>
                     <mi>P</mi>
                    </mrow>
                    <mo>/</mo>
                    <mi>N</mi>
                   </mrow>
                  </mfrac>
                 </mstyle>
                 <mstyle displaystyle="true">
                  <mfrac>
                   <mrow>
                    <mi>d</mi>
                    <mi>o</mi>
                    <mi>g</mi>
                   </mrow>
                   <mi>N</mi>
                  </mfrac>
                 </mstyle>
                </mrow>
                <mrow>
                 <mi>N</mi>
                 <mi>P</mi>
                </mrow>
               </mfrac>
              </mstyle>
              <mo>></mo>
              <mi></mi>
             </mrow>
             <mrow>
              <mi>S</mi>
              <mo>/</mo>
              <mrow>
               <mo stretchy="false">(</mo>
               <mrow>
                <mrow>
                 <mi>S</mi>
                 <mo>\</mo>
                 <mi>N</mi>
                </mrow>
                <mi>P</mi>
               </mrow>
               <mo stretchy="false">)</mo>
              </mrow>
             </mrow>
            </mfrac>
           </mstyle>
           <msub>
            <mi>T</mi>
            <mo>></mo>
           </msub>
          </mrow>
          <mstyle displaystyle="true">
           <mfrac>
            <mrow>
             <mi>b</mi>
             <mi>i</mi>
             <mi>t</mi>
            </mrow>
            <mrow>
             <mrow>
              <mrow>
               <mo stretchy="false">(</mo>
               <mrow>
                <mrow>
                 <mi>S</mi>
                 <mo>\</mo>
                 <mi>N</mi>
                </mrow>
                <mi>P</mi>
               </mrow>
               <mo stretchy="false">)</mo>
              </mrow>
              <mo>/</mo>
              <mi>N</mi>
             </mrow>
             <mi>P</mi>
            </mrow>
           </mfrac>
          </mstyle>
         </mrow>
         <mrow>
          <mrow>
           <mi>S</mi>
           <mo>/</mo>
           <mi>N</mi>
          </mrow>
          <mi>P</mi>
         </mrow>
        </mfrac>
       </mstyle>
       <msub>
        <mi>B</mi>
        <mo>></mo>
       </msub>
      </mrow>
      <mstyle displaystyle="true">
       <mfrac>
        <mrow>
         <mi>J</mi>
         <mi>o</mi>
         <mi>h</mi>
         <mi>n</mi>
        </mrow>
        <mrow>
         <mi>N</mi>
         <mi>P</mi>
        </mrow>
       </mfrac>
      </mstyle>
     </mrow>
     <mi>S</mi>
    </mfrac>
   </mstyle>
   <mo>></mo>
   <mi></mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <apply>
     <divide></divide>
     <list>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <list>
         <apply>
          <times></times>
          <apply>
           <divide></divide>
           <apply>
            <gt></gt>
            <apply>
             <divide></divide>
             <cerror>
              <csymbol cd="ambiguous">fragments</csymbol>
              <apply>
               <divide></divide>
               <apply>
                <times></times>
                <ci>t</ci>
                <ci>h</ci>
                <ci>e</ci>
               </apply>
               <apply>
                <divide></divide>
                <apply>
                 <times></times>
                 <ci>N</ci>
                 <ci>P</ci>
                </apply>
                <ci>N</ci>
               </apply>
              </apply>
              <apply>
               <divide></divide>
               <apply>
                <times></times>
                <ci>d</ci>
                <ci>o</ci>
                <ci>g</ci>
               </apply>
               <ci>N</ci>
              </apply>
              <ci>italic-</ci>
             </cerror>
             <apply>
              <times></times>
              <ci>N</ci>
              <ci>P</ci>
             </apply>
            </apply>
            <csymbol cd="latexml">absent</csymbol>
           </apply>
           <apply>
            <divide></divide>
            <ci>S</ci>
            <apply>
             <times></times>
             <apply>
              <ci>normal-\</ci>
              <ci>S</ci>
              <ci>N</ci>
             </apply>
             <ci>P</ci>
            </apply>
           </apply>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>T</ci>
           <gt></gt>
          </apply>
         </apply>
         <apply>
          <divide></divide>
          <apply>
           <times></times>
           <ci>b</ci>
           <ci>i</ci>
           <ci>t</ci>
          </apply>
          <apply>
           <times></times>
           <apply>
            <divide></divide>
            <apply>
             <times></times>
             <apply>
              <ci>normal-\</ci>
              <ci>S</ci>
              <ci>N</ci>
             </apply>
             <ci>P</ci>
            </apply>
            <ci>N</ci>
           </apply>
           <ci>P</ci>
          </apply>
         </apply>
        </list>
        <apply>
         <times></times>
         <apply>
          <divide></divide>
          <ci>S</ci>
          <ci>N</ci>
         </apply>
         <ci>P</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>B</ci>
        <gt></gt>
       </apply>
      </apply>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <ci>J</ci>
        <ci>o</ci>
        <ci>h</ci>
        <ci>n</ci>
       </apply>
       <apply>
        <times></times>
        <ci>N</ci>
        <ci>P</ci>
       </apply>
      </apply>
     </list>
     <ci>S</ci>
    </apply>
    <csymbol cd="latexml">absent</csymbol>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \dfrac{\dfrac{\dfrac{\dfrac{\dfrac{the}{NP/N}\dfrac{dog}{N}\qquad}{NP}>}{S/(S%
\backslash NP)}T_{>}\qquad\dfrac{bit}{(S\backslash NP)/NP}}{S/NP}B_{>}\qquad%
\dfrac{John}{NP}}{S}>
  </annotation>
 </semantics>
</math>

</p>
<h2 id="formal-properties">Formal properties</h2>

<p>CCGs are known to be able to generate the language 

<math display="inline" id="Combinatory_categorial_grammar:12">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>a</mi>
     <mi>n</mi>
    </msup>
    <msup>
     <mi>b</mi>
     <mi>n</mi>
    </msup>
    <msup>
     <mi>c</mi>
     <mi>n</mi>
    </msup>
    <msup>
     <mi>d</mi>
     <mi>n</mi>
    </msup>
   </mrow>
   <mo>:</mo>
   <mrow>
    <mi>n</mi>
    <mo>≥</mo>
    <mn>0</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>a</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>b</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>c</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>d</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <geq></geq>
     <ci>n</ci>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {a^{n}b^{n}c^{n}d^{n}:n\geq 0}
  </annotation>
 </semantics>
</math>

 (which is an <a href="indexed_language" title="wikilink">indexed language</a>). Examples of this are unfortunately too complicated to provide here, but can be found in Vijay-Shanker and Weir (1994).<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>
<h3 id="equivalencies">Equivalencies</h3>

<p>Vijay-Shanker and Weir (1994)<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> demonstrates that <a href="Indexed_grammar#Linear_indexed_grammars" title="wikilink">Linear Indexed Grammars</a>, Combinatory Categorial Grammars, <a href="Tree-adjoining_grammar" title="wikilink">Tree-adjoining Grammars</a>, and <a href="Head_grammar" title="wikilink">Head Grammars</a> are <a href="Weak_equivalence_(formal_languages)" title="wikilink">weakly equivalent</a> formalisms, in that they all define the same string languages.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Categorial_grammar" title="wikilink">Categorial grammar</a></li>
<li><a href="Combinatory_logic" title="wikilink">Combinatory logic</a></li>
<li><a href="Embedded_pushdown_automaton" title="wikilink">Embedded pushdown automaton</a></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li>Baldridge, Jason (2002), "Lexically Specified Derivational Control in Combinatory Categorial Grammar." PhD Dissertation. Univ. of Edinburgh.</li>
<li>Curry, Haskell B. and Richard Feys (1958), Combinatory Logic, Vol. 1. North-Holland.</li>
<li>Jacobson, Pauline (1999), “Towards a variable-free semantics.” Linguistics and Philosophy 22, 1999. 117–184</li>
<li>Steedman, Mark (1987), “Combinatory grammars and parasitic gaps”. Natural Language and Linguistic Theory 5, 403–439.</li>
<li>Steedman, Mark (1996), Surface Structure and Interpretation. The MIT Press.</li>
<li>Steedman, Mark (2000), The Syntactic Process. The MIT Press.</li>
<li>Szabolcsi, Anna (1989), "Bound variables in syntax (are there any?)." Semantics and Contextual Expression, ed. by Bartsch, van Benthem, and van Emde Boas. Foris, 294–318.</li>
<li>Szabolcsi, Anna (1992), "Combinatory grammar and projection from the lexicon." Lexical Matters. CSLI Lecture Notes 24, ed. by Sag and Szabolcsi. Stanford, CSLI Publications. 241–269.</li>
<li>Szabolcsi, Anna (2003), “Binding on the fly: Cross-sentential anaphora in variable-free semantics”. Resource Sensitivity in Binding and Anaphora, ed. by Kruijff and Oehrle. Kluwer, 215–229.</li>
</ul>
<h2 id="further-reading">Further reading</h2>
<ul>
<li>Michael Moortgat, <em><a href="http://www.let.uu.nl/~Michael.Moortgat/personal/Courses/CG08/Docs/lola-ch2.pdf">Categorial Type Logics</a></em>, Chapter Two in J. van Benthem and A. ter Meulen (eds.) <em>Handbook of Logic and Language</em>. Elsevier, 1997, ISBN 0-262-22053-9</li>
<li><a class="uri" href="http://homepages.inf.ed.ac.uk/steedman/papers/ccg/SteedmanBaldridgeNTSyntax.pdf">http://homepages.inf.ed.ac.uk/steedman/papers/ccg/SteedmanBaldridgeNTSyntax.pdf</a></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://groups.inf.ed.ac.uk/ccg/">The Combinatory Categorial Grammar Site</a></li>
<li><a href="http://aclweb.org/aclwiki/index.php?title=Combinatory_Categorial_Grammar">The ACL CCG wiki page</a> (likely to be more up-to-date than this one)</li>
</ul>

<p>"</p>

<p><a href="Category:Grammar_frameworks" title="wikilink">Category:Grammar frameworks</a> <a href="Category:Combinatory_logic" title="wikilink">Category:Combinatory logic</a> <a href="Category:Type_theory" title="wikilink">Category:Type theory</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"></li>
<li id="fn2">Vijay-Shanker, K. and Weir, David J. 1994. <em>The Equivalence of Four Extensions of Context-Free Grammars</em>. Mathematical Systems Theory 27(6): 511–546.<a href="#fnref2">↩</a></li>
</ol>
</section>
</body>
</html>
