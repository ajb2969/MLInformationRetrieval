<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="754">Power transform</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Power transform</h1>
<hr/>

<p>In <a class="uri" href="statistics" title="wikilink">statistics</a>, the <strong>power transform</strong> corresponds to a family of functions that are applied to create a <a href="Monotonic_function" title="wikilink">monotonic transformation</a> of data using <a href="power_function" title="wikilink">power functions</a>. This is a useful <a href="data_transformation_(statistics)" title="wikilink">data transformation</a> technique used to stabilize variance, make the data more <a href="normal_distribution" title="wikilink">normal distribution</a>-like, improve the validity of measures of association such as the <a href="Pearson_product-moment_correlation_coefficient" title="wikilink">Pearson correlation</a> between variables and for other data stabilization procedures.</p>
<h2 id="definition">Definition</h2>

<p>The power transformation is defined as a continuously varying function, with respect to the power parameter <em>λ</em>, in a piece-wise function form that makes it continuous at the point of singularity (<em>λ</em> = 0). For data vectors (<em>y</em><sub>1</sub>,..., <em>y</em><sub><em>n</em></sub>) in which each <em>y</em><sub><em>i</em></sub> &gt; 0, the power transform is</p>

<p>

<math display="block" id="Power_transform:0">
 <semantics>
  <mrow>
   <msubsup>
    <mi>y</mi>
    <mi>i</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </msubsup>
   <mo>=</mo>
   <mrow>
    <mo>{</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="left">
       <mrow>
        <mfrac>
         <mrow>
          <msubsup>
           <mi>y</mi>
           <mi>i</mi>
           <mi>λ</mi>
          </msubsup>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
         <mrow>
          <mi>λ</mi>
          <msup>
           <mrow>
            <mo stretchy="false">(</mo>
            <mrow>
             <mo>GM</mo>
             <mrow>
              <mo stretchy="false">(</mo>
              <mi>y</mi>
              <mo stretchy="false">)</mo>
             </mrow>
            </mrow>
            <mo stretchy="false">)</mo>
           </mrow>
           <mrow>
            <mi>λ</mi>
            <mo>-</mo>
            <mn>1</mn>
           </mrow>
          </msup>
         </mrow>
        </mfrac>
        <mo>,</mo>
       </mrow>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mtext>if</mtext>
         <mi>λ</mi>
        </mrow>
        <mo>≠</mo>
        <mn>0</mn>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mrow>
          <mo>GM</mo>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>y</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mrow>
          <mi>ln</mi>
          <msub>
           <mi>y</mi>
           <mi>i</mi>
          </msub>
         </mrow>
        </mrow>
        <mo>,</mo>
       </mrow>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mtext>if</mtext>
         <mi>λ</mi>
        </mrow>
        <mo>=</mo>
        <mn>0</mn>
       </mrow>
      </mtd>
     </mtr>
    </mtable>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <ci>i</ci>
     </apply>
     <ci>λ</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">cases</csymbol>
     <apply>
      <divide></divide>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>y</ci>
         <ci>i</ci>
        </apply>
        <ci>λ</ci>
       </apply>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <times></times>
       <ci>λ</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <ci>GM</ci>
         <ci>y</ci>
        </apply>
        <apply>
         <minus></minus>
         <ci>λ</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <neq></neq>
      <apply>
       <times></times>
       <mtext>if</mtext>
       <ci>λ</ci>
      </apply>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <apply>
       <ci>GM</ci>
       <ci>y</ci>
      </apply>
      <apply>
       <ln></ln>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <ci>i</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <mtext>if</mtext>
       <ci>λ</ci>
      </apply>
      <cn type="integer">0</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{i}^{(\lambda)}=\begin{cases}\dfrac{y_{i}^{\lambda}-1}{\lambda(\operatorname%
{GM}(y))^{\lambda-1}},&\text{if }\lambda\neq 0\\
\operatorname{GM}(y)\ln{y_{i}},&\text{if }\lambda=0\end{cases}
  </annotation>
 </semantics>
</math>

</p>

<p>where</p>

<p>

<math display="block" id="Power_transform:1">
 <semantics>
  <mrow>
   <mrow>
    <mo>GM</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mpadded width="+1.7pt">
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>y</mi>
        <mn>1</mn>
       </msub>
       <mi mathvariant="normal">⋯</mi>
       <msub>
        <mi>y</mi>
        <mi>n</mi>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mn>1</mn>
      <mo>/</mo>
      <mi>n</mi>
     </mrow>
    </msup>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>GM</ci>
     <ci>y</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-⋯</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <ci>n</ci>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{GM}(y)=(y_{1}\cdots y_{n})^{1/n}\,
  </annotation>
 </semantics>
</math>

</p>

<p>is the <a href="geometric_mean" title="wikilink">geometric mean</a> of the observations <em>y</em><sub>1</sub>, ..., <em>y</em><sub><em>n</em></sub>.</p>

<p>The inclusion of the (<em>λ</em> − 1)th power of the geometric mean in the denominator simplifies the <a href="Dimensional_analysis" title="wikilink">scientific interpretation of any equation involving</a> 

<math display="inline" id="Power_transform:2">
 <semantics>
  <msubsup>
   <mi>y</mi>
   <mi>i</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <ci>i</ci>
    </apply>
    <ci>λ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{i}^{(\lambda)}
  </annotation>
 </semantics>
</math>

, because the units of measurement do not change as <em>λ</em> changes.</p>

<p>Box and Cox (1964) introduced the geometric mean into this transformation by first including the Jacobian of rescaled power transformation</p>

<p>

<math display="block" id="Power_transform:3">
 <semantics>
  <mfrac>
   <mrow>
    <msup>
     <mi>y</mi>
     <mi>λ</mi>
    </msup>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
   <mi>λ</mi>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>y</ci>
      <ci>λ</ci>
     </apply>
     <cn type="integer">1</cn>
    </apply>
    <ci>λ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \dfrac{y^{\lambda}-1}{\lambda}
  </annotation>
 </semantics>
</math>

.</p>

<p>with the likelihood. This Jacobian is as follows:</p>

<p>

<math display="block" id="Power_transform:4">
 <semantics>
  <mrow>
   <mi>J</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mo>;</mo>
    <msub>
     <mi>y</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>y</mi>
     <mi>n</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <munderover>
    <mo largeop="true" movablelimits="false" symmetric="true">∏</mo>
    <mrow>
     <mi>i</mi>
     <mo>=</mo>
     <mn>1</mn>
    </mrow>
    <mi>n</mi>
   </munderover>
   <mo stretchy="false">|</mo>
   <mi>d</mi>
   <msubsup>
    <mi>y</mi>
    <mi>i</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </msubsup>
   <mo>/</mo>
   <mi>d</mi>
   <mi>y</mi>
   <mo stretchy="false">|</mo>
   <mo>=</mo>
   <munderover>
    <mo largeop="true" movablelimits="false" symmetric="true">∏</mo>
    <mrow>
     <mi>i</mi>
     <mo>=</mo>
     <mn>1</mn>
    </mrow>
    <mi>n</mi>
   </munderover>
   <msubsup>
    <mi>y</mi>
    <mi>i</mi>
    <mrow>
     <mi>λ</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msubsup>
   <mo>=</mo>
   <mo>GM</mo>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mi>n</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>λ</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">J</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <ci>normal-;</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-,</ci>
     <ci>normal-…</ci>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <ci>n</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">product</csymbol>
      <apply>
       <eq></eq>
       <ci>i</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>n</ci>
    </apply>
    <ci>normal-|</ci>
    <csymbol cd="unknown">d</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <ci>i</ci>
     </apply>
     <ci>λ</ci>
    </apply>
    <divide></divide>
    <csymbol cd="unknown">d</csymbol>
    <csymbol cd="unknown">y</csymbol>
    <ci>normal-|</ci>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">product</csymbol>
      <apply>
       <eq></eq>
       <ci>i</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>n</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <minus></minus>
      <ci>λ</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <eq></eq>
    <ci>GM</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">y</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <apply>
      <times></times>
      <ci>n</ci>
      <apply>
       <minus></minus>
       <ci>λ</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   J(\lambda;y_{1},...,y_{n})=\prod_{i=1}^{n}|dy_{i}^{(\lambda)}/dy|=\prod_{i=1}^%
{n}y_{i}^{\lambda-1}=\operatorname{GM}(y)^{n(\lambda-1)}
  </annotation>
 </semantics>
</math>

</p>

<p>This allows the normal <a href="Maximum_likelihood#Continuous_distribution,_continuous_parameter_space" title="wikilink">log likelihood at its maximum</a> to be written as follows:</p>

<p>

<math display="block" id="Power_transform:5">
 <semantics>
  <mrow>
   <mi>log</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi class="ltx_font_mathcaligraphic">ℒ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mover accent="true">
      <mi>μ</mi>
      <mo stretchy="false">^</mo>
     </mover>
     <mo>,</mo>
     <mover accent="true">
      <mi>σ</mi>
      <mo stretchy="false">^</mo>
     </mover>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>-</mo>
    <mi>n</mi>
    <mo>/</mo>
    <mn>2</mn>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>log</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>2</mn>
     <mi>π</mi>
     <msup>
      <mover accent="true">
       <mi>σ</mi>
       <mo stretchy="false">^</mo>
      </mover>
      <mn>2</mn>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>+</mo>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>+</mo>
   <mi>n</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mo>-</mo>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi>log</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>GM</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>-</mo>
    <mi>n</mi>
    <mo>/</mo>
    <mn>2</mn>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>log</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>2</mn>
     <mi>π</mi>
     <msup>
      <mover accent="true">
       <mi>σ</mi>
       <mo stretchy="false">^</mo>
      </mover>
      <mn>2</mn>
     </msup>
     <mo>/</mo>
     <mo>GM</mo>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>y</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mrow>
       <mn>2</mn>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>λ</mi>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>+</mo>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <log></log>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">L</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <ci>normal-^</ci>
       <ci>μ</ci>
      </apply>
      <ci>normal-,</ci>
      <apply>
       <ci>normal-^</ci>
       <ci>σ</ci>
      </apply>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <minus></minus>
     <csymbol cd="unknown">n</csymbol>
     <divide></divide>
     <cn type="integer">2</cn>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <log></log>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <cn type="integer">2</cn>
      <csymbol cd="unknown">π</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <ci>normal-^</ci>
        <ci>σ</ci>
       </apply>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-)</ci>
     </cerror>
     <plus></plus>
     <cn type="integer">1</cn>
     <ci>normal-)</ci>
    </cerror>
    <plus></plus>
    <csymbol cd="unknown">n</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <minus></minus>
     <cn type="integer">1</cn>
     <ci>normal-)</ci>
    </cerror>
    <log></log>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <ci>GM</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">y</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <minus></minus>
     <csymbol cd="unknown">n</csymbol>
     <divide></divide>
     <cn type="integer">2</cn>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <log></log>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <cn type="integer">2</cn>
      <csymbol cd="unknown">π</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <ci>normal-^</ci>
        <ci>σ</ci>
       </apply>
       <cn type="integer">2</cn>
      </apply>
      <divide></divide>
      <ci>GM</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <csymbol cd="unknown">y</csymbol>
        <ci>normal-)</ci>
       </cerror>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <apply>
         <minus></minus>
         <ci>λ</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
      <ci>normal-)</ci>
     </cerror>
     <plus></plus>
     <cn type="integer">1</cn>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-.</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \log(\mathcal{L}(\hat{\mu},\hat{\sigma}))=(-n/2)(\log(2\pi\hat{\sigma}^{2})+1)%
+n(\lambda-1)\log(\operatorname{GM}(y))=(-n/2)(\log(2\pi\hat{\sigma}^{2}/%
\operatorname{GM}(y)^{2(\lambda-1)})+1).
  </annotation>
 </semantics>
</math>

</p>

<p>From here, absorbing 

<math display="inline" id="Power_transform:6">
 <semantics>
  <mrow>
   <mo>GM</mo>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mn>2</mn>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>λ</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>GM</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">y</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <apply>
       <minus></minus>
       <ci>λ</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{GM}(y)^{2(\lambda-1)}
  </annotation>
 </semantics>
</math>

 into the expression for 

<math display="inline" id="Power_transform:7">
 <semantics>
  <msup>
   <mover accent="true">
    <mi>σ</mi>
    <mo stretchy="false">^</mo>
   </mover>
   <mn>2</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <ci>normal-^</ci>
     <ci>σ</ci>
    </apply>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{\sigma}^{2}
  </annotation>
 </semantics>
</math>

 produces an expression that establishes that minimizing the sum of squares of <a href="errors_and_residuals_in_statistics" title="wikilink">residuals</a> from 

<math display="inline" id="Power_transform:8">
 <semantics>
  <msubsup>
   <mi>y</mi>
   <mi>i</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <ci>i</ci>
    </apply>
    <ci>λ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{i}^{(\lambda)}
  </annotation>
 </semantics>
</math>

 is equivalent to maximizing the sum of the normal <a href="Likelihood_function" title="wikilink">log likelihood</a> of deviations from 

<math display="inline" id="Power_transform:9">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msup>
      <mi>y</mi>
      <mi>λ</mi>
     </msup>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>/</mo>
   <mi>λ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>y</ci>
      <ci>λ</ci>
     </apply>
     <cn type="integer">1</cn>
    </apply>
    <ci>λ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (y^{\lambda}-1)/\lambda
  </annotation>
 </semantics>
</math>


 and the log of the Jacobian of the transformation.</p>

<p>The value at <em>Y</em> = 1 for any <em>λ</em> is 0, and the <a class="uri" href="derivative" title="wikilink">derivative</a> with respect to <em>Y</em> there is 1 for any <em>λ</em>. Sometimes <em>Y</em> is a version of some other variable scaled to give <em>Y</em> = 1 at some sort of average value.</p>

<p>The transformation is a <a href="power_(mathematics)" title="wikilink">power</a> transformation, but done in such a way as to make it <a href="continuous_function" title="wikilink">continuous</a> with the parameter <em>λ</em> at <em>λ</em> = 0. It has proved popular in <a href="regression_analysis" title="wikilink">regression analysis</a>, including <a class="uri" href="econometrics" title="wikilink">econometrics</a>.</p>

<p>Box and Cox also proposed a more general form of the transformation that incorporates a shift parameter.</p>

<p>

<math display="block" id="Power_transform:10">
 <semantics>
  <mrow>
   <mrow>
    <mi>τ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>y</mi>
      <mi>i</mi>
     </msub>
     <mo>;</mo>
     <mi>λ</mi>
     <mo>,</mo>
     <mi>α</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>{</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="left">
       <mfrac>
        <mrow>
         <msup>
          <mrow>
           <mo stretchy="false">(</mo>
           <mrow>
            <msub>
             <mi>y</mi>
             <mi>i</mi>
            </msub>
            <mo>+</mo>
            <mi>α</mi>
           </mrow>
           <mo stretchy="false">)</mo>
          </mrow>
          <mi>λ</mi>
         </msup>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
        <mrow>
         <mi>λ</mi>
         <msup>
          <mrow>
           <mo stretchy="false">(</mo>
           <mrow>
            <mo>GM</mo>
            <mrow>
             <mo stretchy="false">(</mo>
             <mrow>
              <mi>y</mi>
              <mo>+</mo>
              <mi>α</mi>
             </mrow>
             <mo stretchy="false">)</mo>
            </mrow>
           </mrow>
           <mo stretchy="false">)</mo>
          </mrow>
          <mrow>
           <mi>λ</mi>
           <mo>-</mo>
           <mn>1</mn>
          </mrow>
         </msup>
        </mrow>
       </mfrac>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mrow>
          <mtext>if</mtext>
          <mi>λ</mi>
         </mrow>
         <mo>≠</mo>
         <mn>0</mn>
        </mrow>
        <mo>,</mo>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="left">
       <mi></mi>
      </mtd>
      <mtd></mtd>
     </mtr>
     <mtr>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mo>GM</mo>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <mi>y</mi>
           <mo>+</mo>
           <mi>α</mi>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mrow>
         <mi>ln</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <msub>
            <mi>y</mi>
            <mi>i</mi>
           </msub>
           <mo>+</mo>
           <mi>α</mi>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mrow>
          <mtext>if</mtext>
          <mi>λ</mi>
         </mrow>
         <mo>=</mo>
         <mn>0</mn>
        </mrow>
        <mo>,</mo>
       </mrow>
      </mtd>
     </mtr>
    </mtable>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>τ</ci>
     <list>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <ci>i</ci>
      </apply>
      <ci>λ</ci>
      <ci>α</ci>
     </list>
    </apply>
    <apply>
     <csymbol cd="latexml">cases</csymbol>
     <apply>
      <divide></divide>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <plus></plus>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>y</ci>
          <ci>i</ci>
         </apply>
         <ci>α</ci>
        </apply>
        <ci>λ</ci>
       </apply>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <times></times>
       <ci>λ</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <ci>GM</ci>
         <apply>
          <plus></plus>
          <ci>y</ci>
          <ci>α</ci>
         </apply>
        </apply>
        <apply>
         <minus></minus>
         <ci>λ</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <neq></neq>
      <apply>
       <times></times>
       <mtext>if</mtext>
       <ci>λ</ci>
      </apply>
      <cn type="integer">0</cn>
     </apply>
     <csymbol cd="latexml">absent</csymbol>
     <mtext>otherwise</mtext>
     <apply>
      <apply>
       <ci>GM</ci>
       <apply>
        <plus></plus>
        <ci>y</ci>
        <ci>α</ci>
       </apply>
      </apply>
      <apply>
       <ln></ln>
       <apply>
        <plus></plus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>y</ci>
         <ci>i</ci>
        </apply>
        <ci>α</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <mtext>if</mtext>
       <ci>λ</ci>
      </apply>
      <cn type="integer">0</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau(y_{i};\lambda,\alpha)=\begin{cases}\dfrac{(y_{i}+\alpha)^{\lambda}-1}{%
\lambda(\operatorname{GM}(y+\alpha))^{\lambda-1}}&\text{if }\lambda\neq 0,\\
\\
\operatorname{GM}(y+\alpha)\ln(y_{i}+\alpha)&\text{if }\lambda=0,\end{cases}
  </annotation>
 </semantics>
</math>

 which holds if <em>y</em><sub><em>i</em></sub> + α &gt; 0 for all <em>i</em>. If τ(<em>Y</em>, λ, α) follows a <a href="truncated_normal_distribution" title="wikilink">truncated normal distribution</a>, then <em>Y</em> is said to follow a <a href="Box–Cox_distribution" title="wikilink">Box–Cox distribution</a>.</p>

<p>Bickel and Doksum eliminated the need to use a <a href="truncated_distribution" title="wikilink">truncated distribution</a> by extending the range of the transformation to all <em>y</em>, as follows:</p>

<p>

<math display="block" id="Power_transform:11">
 <semantics>
  <mrow>
   <mrow>
    <mi>τ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>y</mi>
      <mi>i</mi>
     </msub>
     <mo>;</mo>
     <mi>λ</mi>
     <mo>,</mo>
     <mi>α</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>{</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="left">
       <mfrac>
        <mrow>
         <mrow>
          <mrow>
           <mo>sgn</mo>
           <mrow>
            <mo stretchy="false">(</mo>
            <mrow>
             <msub>
              <mi>y</mi>
              <mi>i</mi>
             </msub>
             <mo>+</mo>
             <mi>α</mi>
            </mrow>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
          <msup>
           <mrow>
            <mo stretchy="false">|</mo>
            <mrow>
             <msub>
              <mi>y</mi>
              <mi>i</mi>
             </msub>
             <mo>+</mo>
             <mi>α</mi>
            </mrow>
            <mo stretchy="false">|</mo>
           </mrow>
           <mi>λ</mi>
          </msup>
         </mrow>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
        <mrow>
         <mi>λ</mi>
         <msup>
          <mrow>
           <mo stretchy="false">(</mo>
           <mrow>
            <mo>GM</mo>
            <mrow>
             <mo stretchy="false">(</mo>
             <mrow>
              <mi>y</mi>
              <mo>+</mo>
              <mi>α</mi>
             </mrow>
             <mo stretchy="false">)</mo>
            </mrow>
           </mrow>
           <mo stretchy="false">)</mo>
          </mrow>
          <mrow>
           <mi>λ</mi>
           <mo>-</mo>
           <mn>1</mn>
          </mrow>
         </msup>
        </mrow>
       </mfrac>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mrow>
          <mtext>if</mtext>
          <mi>λ</mi>
         </mrow>
         <mo>≠</mo>
         <mn>0</mn>
        </mrow>
        <mo>,</mo>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="left">
       <mi></mi>
      </mtd>
      <mtd></mtd>
     </mtr>
     <mtr>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mo>GM</mo>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <mi>y</mi>
           <mo>+</mo>
           <mi>α</mi>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mrow>
         <mrow>
          <mo>sgn</mo>
          <mrow>
           <mo stretchy="false">(</mo>
           <mrow>
            <mi>y</mi>
            <mo>+</mo>
            <mi>α</mi>
           </mrow>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mrow>
          <mi>ln</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mrow>
            <msub>
             <mi>y</mi>
             <mi>i</mi>
            </msub>
            <mo>+</mo>
            <mi>α</mi>
           </mrow>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
        </mrow>
       </mrow>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mrow>
          <mtext>if</mtext>
          <mi>λ</mi>
         </mrow>
         <mo>=</mo>
         <mn>0</mn>
        </mrow>
        <mo>,</mo>
       </mrow>
      </mtd>
     </mtr>
    </mtable>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>τ</ci>
     <list>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <ci>i</ci>
      </apply>
      <ci>λ</ci>
      <ci>α</ci>
     </list>
    </apply>
    <apply>
     <csymbol cd="latexml">cases</csymbol>
     <apply>
      <divide></divide>
      <apply>
       <minus></minus>
       <apply>
        <apply>
         <ci>sgn</ci>
         <apply>
          <plus></plus>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>y</ci>
           <ci>i</ci>
          </apply>
          <ci>α</ci>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <abs></abs>
          <apply>
           <plus></plus>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>y</ci>
            <ci>i</ci>
           </apply>
           <ci>α</ci>
          </apply>
         </apply>
         <ci>λ</ci>
        </apply>
       </apply>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <times></times>
       <ci>λ</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <ci>GM</ci>
         <apply>
          <plus></plus>
          <ci>y</ci>
          <ci>α</ci>
         </apply>
        </apply>
        <apply>
         <minus></minus>
         <ci>λ</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <neq></neq>
      <apply>
       <times></times>
       <mtext>if</mtext>
       <ci>λ</ci>
      </apply>
      <cn type="integer">0</cn>
     </apply>
     <csymbol cd="latexml">absent</csymbol>
     <mtext>otherwise</mtext>
     <apply>
      <times></times>
      <apply>
       <ci>GM</ci>
       <apply>
        <plus></plus>
        <ci>y</ci>
        <ci>α</ci>
       </apply>
      </apply>
      <apply>
       <apply>
        <ci>sgn</ci>
        <apply>
         <plus></plus>
         <ci>y</ci>
         <ci>α</ci>
        </apply>
       </apply>
       <apply>
        <ln></ln>
        <apply>
         <plus></plus>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>y</ci>
          <ci>i</ci>
         </apply>
         <ci>α</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <mtext>if</mtext>
       <ci>λ</ci>
      </apply>
      <cn type="integer">0</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau(y_{i};\lambda,\alpha)=\begin{cases}\dfrac{\operatorname{sgn}(y_{i}+\alpha%
)|y_{i}+\alpha|^{\lambda}-1}{\lambda(\operatorname{GM}(y+\alpha))^{\lambda-1}}%
&\text{if }\lambda\neq 0,\\
\\
\operatorname{GM}(y+\alpha)\operatorname{sgn}(y+\alpha)\ln(y_{i}+\alpha)&\text%
{if }\lambda=0,\end{cases}
  </annotation>
 </semantics>
</math>

,</p>

<p>where sgn(.) is the <a href="Sign_function" title="wikilink">Sign function</a>. This change in definition has little practical import as long as 

<math display="inline" id="Power_transform:12">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>

 is less than 

<math display="inline" id="Power_transform:13">
 <semantics>
  <mrow>
   <mo>min</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>y</mi>
     <mi>i</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>min</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{min}(y_{i})
  </annotation>
 </semantics>
</math>

, which it usually is.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>

<p>Bickel and Doksum also proved that the parameter estimates are <a href="Consistency_(statistics)" title="wikilink">consistent</a> and <a href="Local_asymptotic_normality" title="wikilink">asymptotically normal</a> under appropriate regularity conditions, though the standard <a href="Cramér–Rao_bound" title="wikilink">Cramér–Rao lower bound</a> can substantially underestimate the variance when parameter values are small relative to the noise variance.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> However, this problem of underestimating the variance may not be a substantive problem in many applications.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a><a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>
<h2 id="boxcox-transformation">Box–Cox transformation</h2>

<p>The one-parameter Box–Cox transformations are defined as:</p>

<p>

<math display="inline" id="Power_transform:14">
 <semantics>
  <mrow>
   <msubsup>
    <mi>y</mi>
    <mi>i</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </msubsup>
   <mo>=</mo>
   <mrow>
    <mo>{</mo>
    <mtable>
     <mtr>
      <mtd columnalign="left">
       <mstyle displaystyle="true">
        <mfrac>
         <mrow>
          <msubsup>
           <mi>y</mi>
           <mi>i</mi>
           <mi>λ</mi>
          </msubsup>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
         <mi>λ</mi>
        </mfrac>
       </mstyle>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mrow>
          <mtext>if</mtext>
          <mi>λ</mi>
         </mrow>
         <mo>≠</mo>
         <mn>0</mn>
        </mrow>
        <mo>,</mo>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="left">
       <mrow>
        <mi>ln</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>y</mi>
          <mi>i</mi>
         </msub>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mrow>
          <mtext>if</mtext>
          <mi>λ</mi>
         </mrow>
         <mo>=</mo>
         <mn>0</mn>
        </mrow>
        <mo>,</mo>
       </mrow>
      </mtd>
     </mtr>
    </mtable>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <ci>i</ci>
     </apply>
     <ci>λ</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">cases</csymbol>
     <apply>
      <divide></divide>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>y</ci>
         <ci>i</ci>
        </apply>
        <ci>λ</ci>
       </apply>
       <cn type="integer">1</cn>
      </apply>
      <ci>λ</ci>
     </apply>
     <apply>
      <neq></neq>
      <apply>
       <times></times>
       <mtext>if</mtext>
       <ci>λ</ci>
      </apply>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <ln></ln>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <ci>i</ci>
      </apply>
     </apply>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <mtext>if</mtext>
       <ci>λ</ci>
      </apply>
      <cn type="integer">0</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{i}^{(\lambda)}=\begin{cases}\dfrac{y_{i}^{\lambda}-1}{\lambda}&\text{if }%
\lambda\neq 0,\\
\ln{(y_{i})}&\text{if }\lambda=0,\end{cases}
  </annotation>
 </semantics>
</math>

</p>

<p>and the two-parameter Box-Cox transformations as:</p>

<p>

<math display="inline" id="Power_transform:15">
 <semantics>
  <mrow>
   <msubsup>
    <mi>y</mi>
    <mi>i</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>𝝀</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </msubsup>
   <mo>=</mo>
   <mrow>
    <mo>{</mo>
    <mtable>
     <mtr>
      <mtd columnalign="left">
       <mstyle displaystyle="true">
        <mfrac>
         <mrow>
          <msup>
           <mrow>
            <mo stretchy="false">(</mo>
            <mrow>
             <msub>
              <mi>y</mi>
              <mi>i</mi>
             </msub>
             <mo>+</mo>
             <msub>
              <mi>λ</mi>
              <mn>2</mn>
             </msub>
            </mrow>
            <mo stretchy="false">)</mo>
           </mrow>
           <msub>
            <mi>λ</mi>
            <mn>1</mn>
           </msub>
          </msup>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
         <msub>
          <mi>λ</mi>
          <mn>1</mn>
         </msub>
        </mfrac>
       </mstyle>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mrow>
          <mtext>if</mtext>
          <msub>
           <mi>λ</mi>
           <mn>1</mn>
          </msub>
         </mrow>
         <mo>≠</mo>
         <mn>0</mn>
        </mrow>
        <mo>,</mo>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="left">
       <mrow>
        <mi>ln</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <msub>
           <mi>y</mi>
           <mi>i</mi>
          </msub>
          <mo>+</mo>
          <msub>
           <mi>λ</mi>
           <mn>2</mn>
          </msub>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mrow>
          <mtext>if</mtext>
          <msub>
           <mi>λ</mi>
           <mn>1</mn>
          </msub>
         </mrow>
         <mo>=</mo>
         <mn>0</mn>
        </mrow>
        <mo>,</mo>
       </mrow>
      </mtd>
     </mtr>
    </mtable>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <ci>i</ci>
     </apply>
     <ci>𝝀</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">cases</csymbol>
     <apply>
      <divide></divide>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <plus></plus>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>y</ci>
          <ci>i</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>λ</ci>
          <cn type="integer">2</cn>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>λ</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>λ</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <neq></neq>
      <apply>
       <times></times>
       <mtext>if</mtext>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>λ</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <ln></ln>
      <apply>
       <plus></plus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>λ</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <mtext>if</mtext>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>λ</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <cn type="integer">0</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{i}^{(\boldsymbol{\lambda})}=\begin{cases}\dfrac{(y_{i}+\lambda_{2})^{%
\lambda_{1}}-1}{\lambda_{1}}&\text{if }\lambda_{1}\neq 0,\\
\ln{(y_{i}+\lambda_{2})}&\text{if }\lambda_{1}=0,\end{cases}
  </annotation>
 </semantics>
</math>

</p>

<p>as described in the original article.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a><a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> Moreover, the first transformations hold for 

<math display="inline" id="Power_transform:16">
 <semantics>
  <mrow>
   <msub>
    <mi>y</mi>
    <mi>i</mi>
   </msub>
   <mo>></mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <ci>i</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{i}>0
  </annotation>
 </semantics>
</math>

 and the second for 

<math display="inline" id="Power_transform:17">
 <semantics>
  <mrow>
   <msub>
    <mi>y</mi>
    <mi>i</mi>
   </msub>
   <mo>></mo>
   <mrow>
    <mo>-</mo>
    <msub>
     <mi>λ</mi>
     <mn>2</mn>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>λ</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{i}>-\lambda_{2}
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>

<p>The parameter 

<math display="inline" id="Power_transform:18">
 <semantics>
  <mi>λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda
  </annotation>
 </semantics>
</math>

 is estimated using the <a href="profile_likelihood" title="wikilink">profile likelihood</a> function.</p>
<h2 id="use-of-the-power-transform">Use of the power transform</h2>
<ul>
<li>Power transforms are ubiquitously used in various fields. For example, [<a class="uri" href="http://portal.acm.org/citation.cfm?id=1172964.1173292&amp;coll">http://portal.acm.org/citation.cfm?id=1172964.1173292&amp;coll;</a>;=&amp;dl;=acm&amp;CFID;=15151515&amp;CFTOKEN;=6184618 multi-resolution and wavelet analysis], statistical data analysis, <a href="http://www.andrologyjournal.org/cgi/reprint/23/5/629.pdf">medical research</a>, <a href="http://www.springerlink.com/content/y25q020x24602701/">modeling of physical processes</a>, <a href="http://www.springerlink.com/content/mt81u60813077641/">geochemical data analysis</a>, <a class="uri" href="epidemiology" title="wikilink">epidemiology</a><a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> and many other clinical, environmental and social research areas.</li>
</ul>
<h2 id="example">Example</h2>

<p>The BUPA liver data set<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> contains data on liver enzymes <a href="Alanine_transaminase" title="wikilink">ALT</a> and <a href="Gamma-glutamyl_transpeptidase" title="wikilink">γGT</a>. Suppose we are interested in using log(γGT) to predict ALT. A plot of the data appears in panel (a) of the figure. There appears to be non-constant variance, and a Box–Cox transformation might help.</p>

<p><a href="image:BUPA_BoxCox.JPG" title="wikilink">image:BUPA BoxCox.JPG</a></p>

<p>The log-likelihood of the power parameter appears in panel (b). The horizontal reference line is at a distance of χ<sub>1</sub><sup>2</sup>/2 from the maximum and can be used to read off an approximate 95% confidence interval for λ. It appears as though a value close to zero would be good, so we take logs.</p>

<p>Possibly, the transformation could be improved by adding a shift parameter to the log transformation. Panel (c) of the figure shows the log-likelihood. In this case, the maximum of the likelihood is close to zero suggesting that a shift parameter is not needed. The final panel shows the transformed data with a superimposed regression line.</p>

<p>Note that although Box–Cox transformations can make big improvements in model fit, there are some issues that the transformation cannot help with. In the current example, the data are rather heavy-tailed so that the assumption of normality is not realistic and a <a href="robust_regression" title="wikilink">robust regression</a> approach leads to a more precise model.</p>
<h2 id="econometric-application">Econometric application</h2>

<p>Economists often characterize production relationships by some variant of the Box–Cox transformation.</p>

<p>Consider a common representation of production <em>Q</em> as dependent on services provided by a capital stock <em>K</em> and by labor hours <em>N</em>:</p>

<p>

<math display="block" id="Power_transform:19">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>τ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>Q</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mi>α</mi>
      <mi>τ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>K</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mn>1</mn>
        <mo>-</mo>
        <mi>α</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>τ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>N</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>τ</ci>
     <ci>Q</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>α</ci>
      <ci>τ</ci>
      <ci>K</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
       <ci>α</ci>
      </apply>
      <ci>τ</ci>
      <ci>N</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau(Q)=\alpha\tau(K)+(1-\alpha)\tau(N).\,
  </annotation>
 </semantics>
</math>

</p>

<p>Solving for <em>Q</em> by inverting the Box–Cox transformation we find</p>

<p>

<math display="block" id="Power_transform:20">
 <semantics>
  <mrow>
   <mrow>
    <mi>Q</mi>
    <mo>=</mo>
    <msup>
     <mrow>
      <mo maxsize="120%" minsize="120%">(</mo>
      <mrow>
       <mrow>
        <mi>α</mi>
        <msup>
         <mi>K</mi>
         <mi>λ</mi>
        </msup>
       </mrow>
       <mo>+</mo>
       <mrow>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mn>1</mn>
          <mo>-</mo>
          <mi>α</mi>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
        <msup>
         <mi>N</mi>
         <mi>λ</mi>
        </msup>
       </mrow>
      </mrow>
      <mo maxsize="120%" minsize="120%">)</mo>
     </mrow>
     <mrow>
      <mn>1</mn>
      <mo>/</mo>
      <mi>λ</mi>
     </mrow>
    </msup>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>Q</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>α</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>K</ci>
        <ci>λ</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
        <ci>α</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>N</ci>
        <ci>λ</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <ci>λ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q=\big(\alpha K^{\lambda}+(1-\alpha)N^{\lambda}\big)^{1/\lambda},\,
  </annotation>
 </semantics>
</math>

</p>

<p>which is known as the <em>constant elasticity of substitution (CES)</em> production function.</p>

<p>The CES production function is a <a href="homogeneous_function" title="wikilink">homogeneous function</a> of degree one.</p>

<p>When <em>λ</em> = 1, this produces the linear production function:</p>

<p>

<math display="block" id="Power_transform:21">
 <semantics>
  <mrow>
   <mrow>
    <mi>Q</mi>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mi>α</mi>
      <mi>K</mi>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mn>1</mn>
        <mo>-</mo>
        <mi>α</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>N</mi>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>Q</ci>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>α</ci>
      <ci>K</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
       <ci>α</ci>
      </apply>
      <ci>N</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q=\alpha K+(1-\alpha)N.\,
  </annotation>
 </semantics>
</math>

</p>

<p>When <em>λ</em> → 0 this produces the famous <a class="uri" href="Cobb–Douglas" title="wikilink">Cobb–Douglas</a> production function:</p>

<p>

<math display="block" id="Power_transform:22">
 <semantics>
  <mrow>
   <mrow>
    <mi>Q</mi>
    <mo>=</mo>
    <mrow>
     <msup>
      <mi>K</mi>
      <mi>α</mi>
     </msup>
     <msup>
      <mi>N</mi>
      <mrow>
       <mn>1</mn>
       <mo>-</mo>
       <mi>α</mi>
      </mrow>
     </msup>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>Q</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>K</ci>
      <ci>α</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>N</ci>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
       <ci>α</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q=K^{\alpha}N^{1-\alpha}.\,
  </annotation>
 </semantics>
</math>

</p>
<h2 id="activities-and-demonstrations">Activities and demonstrations</h2>

<p>The <a class="uri" href="SOCR" title="wikilink">SOCR</a> resource pages contain a number of hands-on interactive activities<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> demonstrating the Box–Cox (Power) Transformation using Java applets and charts. These directly illustrate the effects of this transform on <a href="Q-Q_plot" title="wikilink">Q-Q plots</a>, X-Y <a href="scatterplot" title="wikilink">scatterplots</a>, <a class="uri" href="time-series" title="wikilink">time-series</a> plots and <a href="histogram" title="wikilink">histograms</a>.</p>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<ul>
<li></li>
<li>Carroll, RJ and Ruppert, D. <a href="http://wiki.stat.ucla.edu/socr/uploads/b/b8/PowerTransformFamily_Biometrica609.pdf">On prediction and the power transformation family</a>. Biometrika 68: 609–615.</li>
<li></li>
<li>Handelsman, DJ. Optimal Power Transformations for Analysis of Sperm Concentration and Other Semen Variables. Journal of Andrology, Vol. 23, No. 5, September/October 2002.</li>
<li></li>
<li></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li>

<p>(<a href="http://www.encyclopediaofmath.org/index.php/Box%E2%80%93Cox_transformation">fixed link</a>)</p></li>
</ul>

<p>"</p>

<p><a href="Category:Data_analysis" title="wikilink">Category:Data analysis</a> <a class="uri" href="Category:Transforms" title="wikilink">Category:Transforms</a> <a href="Category:Statistical_models" title="wikilink">Category:Statistical models</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
<li id="fn9"><a href="ftp://ftp.ics.uci.edu/pub/machine-learning-databases/liver-disorders">BUPA liver disorder dataset</a><a href="#fnref9">↩</a></li>
<li id="fn10"><a href="http://wiki.stat.ucla.edu/socr/index.php/SOCR_EduMaterials_Activities_PowerTransformFamily_Graphs">Power Transform Family Graphs</a>, SOCR webpages<a href="#fnref10">↩</a></li>
</ol>
</section>
</body>
</html>
