<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1789">Tower of Hanoi</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Tower of Hanoi</h1>
<hr/>

<p>   The <strong>Tower of Hanoi</strong> (also called the <strong>Tower of Brahma</strong> or <strong>Lucas' Tower</strong>,<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> and sometimes pluralized) is a <a href="mathematical_game" title="wikilink">mathematical game</a> or <a class="uri" href="puzzle" title="wikilink">puzzle</a>. It consists of three rods, and a number of disks of different sizes which can slide onto any rod. The puzzle starts with the disks in a neat stack in ascending order of size on one rod, the smallest at the top, thus making a <a href="cone" title="wikilink">conical</a> shape.</p>

<p>The objective of the puzzle is to move the entire stack to another rod, obeying the following simple rules:</p>
<ol>
<li>Only one disk can be moved at a time.</li>
<li>Each move consists of taking the upper disk from one of the stacks and placing it on top of another stack i.e. a disk can only be moved if it is the uppermost disk on a stack.</li>
<li>No disk may be placed on top of a smaller disk.</li>
</ol>

<p>With three disks, the puzzle can be solved in seven moves. The minimum number of moves required to solve a Tower of Hanoi puzzle is 2<sup><em>n</em></sup> - 1, where <em>n</em> is the number of disks.</p>
<h2 id="origins">Origins</h2>

<p>The puzzle was invented by the <a href="French_people" title="wikilink">French</a> <a class="uri" href="mathematician" title="wikilink">mathematician</a> <a href="Édouard_Lucas" title="wikilink">Édouard Lucas</a> in 1883. There is a story about an <a href="India" title="wikilink">Indian</a> temple in <a href="Kashi_Vishwanath_Temple" title="wikilink">Kashi Vishwanath</a> which contains a large room with three time-worn posts in it surrounded by 64 golden disks. <a class="uri" href="Brahmin" title="wikilink">Brahmin</a> priests, acting out the command of an ancient prophecy, have been moving these disks, in accordance with the immutable rules of the Brahma, since that time. The puzzle is therefore also known as the Tower of <a class="uri" href="Brahma" title="wikilink">Brahma</a> puzzle. According to the legend, when the last move of the puzzle will be completed, the world will end.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> It is not clear whether Lucas invented this legend or was inspired by it.</p>

<p>If the legend were true, and if the priests were able to move disks at a rate of one per second, using the smallest number of moves, it would take them 2<sup>64</sup>−1 seconds or roughly 585 <a href="1,000,000,000_(number)" title="wikilink">billion</a> years<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> or 18,446,744,073,709,551,615 turns to finish, or about 127 times the current age of the sun.</p>

<p>There are many variations on this legend. For instance, in some tellings, the temple is a <a class="uri" href="monastery" title="wikilink">monastery</a> and the priests are <a href="monk" title="wikilink">monks</a>. The temple or monastery may be said to be in different parts of the world — including <a class="uri" href="Hanoi" title="wikilink">Hanoi</a>, <a class="uri" href="Vietnam" title="wikilink">Vietnam</a>, and may be associated with any <a class="uri" href="religion" title="wikilink">religion</a>. In some versions, other elements are introduced, such as the fact that the tower was created at the beginning of the world, or that the priests or monks may make only one move per day.</p>
<h2 id="solution">Solution</h2>

<p>The puzzle can be played with any number of disks, although many toy versions have around seven to nine of them. The minimum number of moves required to solve a Tower of Hanoi puzzle is 2<sup><em>n</em></sup> - 1, where <em>n</em> is the number of disks.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>
<h3 id="iterative-solution">Iterative solution</h3>

<p>A simple solution for the toy puzzle: Alternate moves between the smallest piece and a non-smallest piece. When moving the smallest piece, always move it to the next position in the same direction (to the right if the starting number of pieces is even, to the left if the starting number of pieces is odd). If there is no tower position in the chosen direction, move the piece to the opposite end, but then continue to move in the correct direction. For example, if you started with three pieces, you would move the smallest piece to the opposite end, then continue in the left direction after that. When the turn is to move the non-smallest piece, there is only one legal move. Doing this will complete the puzzle in the fewest number of moves.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>
<h4 id="simpler-statement-of-iterative-solution">Simpler statement of iterative solution</h4>

<p>Alternating between the smallest and the next-smallest disks, follow the steps for the appropriate case:</p>

<p>For an even number of disks:</p>
<ul>
<li>make the legal move between pegs A and B</li>
</ul>
<ul>
<li>make the legal move between pegs A and C</li>
<li>make the legal move between pegs B and C</li>
<li>repeat until complete</li>
</ul>

<p>For an odd number of disks:</p>
<ul>
<li>make the legal move between pegs A and C</li>
<li>make the legal move between pegs A and B</li>
<li>make the legal move between pegs C and B</li>
<li>repeat until complete</li>
</ul>

<p>In each case, a total of 2<sup>n</sup>-1 moves are made.</p>
<h4 id="equivalent-iterative-solution">Equivalent iterative solution</h4>

<p>Another way to generate the unique optimal iterative solution:</p>

<p>Number the disks 1 through n (largest to smallest).</p>
<ul>
<li>If n is odd, the first move is from peg A to peg C.</li>
<li>If n is even, the first move is from peg A to peg B.</li>
</ul>

<p>Now, add these constraints:</p>
<ul>
<li>No odd disk may be placed directly on an odd disk.</li>
<li>No even disk may be placed directly on an even disk.</li>
<li>Never undo your previous move (that is, do not move a disk back to its immediate last peg).</li>
</ul>

<p>Considering those constraints after the first move, there is only one legal move at every subsequent turn.</p>

<p>The sequence of these unique moves is an optimal solution to the problem equivalent to the iterative solution described above.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>
<h3 id="recursive-solution">Recursive solution</h3>

<p><imagemap> <a class="uri" href="File:Tower_of_Hanoi_recursion_SMIL.svg|thumb|Interactive">File:Tower_of_Hanoi_recursion_SMIL.svg|thumb|Interactive</a> illustration of a recursive solution for the Towers of Hanoi puzzle with 4 disks. Click the grey buttons to reveal and hide stages. default <a href="http://upload.wikimedia.org/wikipedia/commons/2/20/Tower_of_Hanoi_recursion_SMIL.svg">1</a> </imagemap></p>

<p>A key to solving this puzzle is to recognize that it can be solved by breaking the problem down into a collection of smaller problems and further breaking those problems down into even smaller problems until a solution is reached. For example:</p>
<ul>
<li>label the pegs A, B, C</li>
<li>let <em>n</em> be the total number of discs</li>
<li>number the discs from 1 (smallest, topmost) to <em>n</em> (largest, bottommost)</li>
</ul>

<p>To move <em>n</em> discs from peg A to peg C:</p>
<ol>
<li>move <em>n</em>−1 discs from A to B. This leaves disc <em>n</em> alone on peg A</li>
<li>move disc <em>n</em> from A to C</li>
<li>move <em>n</em>−1 discs from B to C so they sit on disc <em>n</em></li>
</ol>

<p>The above is a recursive algorithm, to carry out steps 1 and 3, apply the same algorithm again for <em>n</em>−1. The entire procedure is a finite number of steps, since at some point the algorithm will be required for <em>n</em> = 1. This step, moving a single disc from peg A to peg C, is trivial. This approach can be given a rigorous mathematical formalism with the theory of <a href="dynamic_programming" title="wikilink">dynamic programming</a>,<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a><a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> and is often used as an example of recursion when teaching programming.</p>
<h4 id="logical-analysis-of-the-recursive-solution">Logical analysis of the recursive solution</h4>

<p>As in many mathematical puzzles, finding a solution is made easier by solving a slightly more general problem: how to move a tower of h (h=height) disks from a starting peg <strong>A</strong> (f=from) onto a destination peg <strong>C</strong> (t=to), <strong>B</strong> being the remaining third peg and assuming <strong>t</strong>≠<strong>f</strong>. First, observe that the problem is symmetric for permutations of the names of the pegs (<a href="Symmetric_group" title="wikilink">symmetric group S<sub><em>3</em></sub></a>). If a solution is known moving from peg <strong>A</strong> to peg <strong>C</strong>, then, by renaming the pegs, the same solution can be used for every other choice of starting and destination peg. If there is only one disk (or even none at all), the problem is trivial. If h=1, then simply move the disk from peg <strong>A</strong> to peg <strong>C</strong>. If h&gt;1, then somewhere along the sequence of moves, the largest disk must be moved from peg <strong>A</strong> to another peg, preferably to peg <strong>C</strong>. The only situation that allows this move is when all smaller h-1 disks are on peg <strong>B</strong>. Hence, first all h-1 smaller disks must go from <strong>A</strong> to <strong>B</strong>. Subsequently move the largest disk and finally move the h-1 smaller disks from peg <strong>B</strong> to peg <strong>C</strong>. The presence of the largest disk does not impede any move of the h-1 smaller disks and can temporarily be ignored. Now the problem is reduced to moving h-1 disks from one peg to another one, first from <strong>A</strong> to <strong>B</strong> and subsequently from <strong>B</strong> to <strong>C</strong>, but the same method can be used both times by renaming the pegs. The same strategy can be used to reduce the h-1 problem to h-2, h-3, and so on until only one disk is left. This is called recursion. This algorithm can be schematized as follows. Identify the disks in order of increasing size by the natural numbers from 0 up to but not including h. Hence disk 0 is the smallest one and disk h-1 the largest one.</p>

<p>The following is a procedure for moving a tower of h disks from a peg <strong>A</strong> onto a peg <strong>C</strong>, with <strong>B</strong> being the remaining third peg:</p>
<ul>
<li>Step 1: If h&gt;1 then first use this procedure to move the h-1 smaller disks from peg <strong>A</strong> to peg <strong>B</strong>.</li>
<li>Step 2: Now the largest disk, i.e. disk h can be moved from peg <strong>A</strong> to peg <strong>C</strong>.</li>
<li>Step 3: If h&gt;1 then again use this procedure to move the h-1 smaller disks from peg <strong>B</strong> to peg <strong>C</strong>.</li>
</ul>

<p>By means of <a href="mathematical_induction" title="wikilink">mathematical induction</a>, it is easily proven that the above procedure requires the minimal number of moves possible, and that the produced solution is the only one with this minimal number of moves. Using <a href="recurrence_relation" title="wikilink">recurrence relations</a>, the exact number of moves that this solution requires can be calculated by

<math display="block" id="Tower_of_Hanoi:0">
 <semantics>
  <mrow>
   <msup>
    <mn>2</mn>
    <mi>h</mi>
   </msup>
   <mo>-</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <ci>h</ci>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{h}-1
  </annotation>
 </semantics>
</math>

. This result is obtained by noting that steps 1 and 3 take 

<math display="inline" id="Tower_of_Hanoi:1">
 <semantics>
  <msub>
   <mi>T</mi>
   <mrow>
    <mi>h</mi>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>T</ci>
    <apply>
     <minus></minus>
     <ci>h</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T_{h-1}
  </annotation>
 </semantics>
</math>

 moves, and step 2 takes one move, giving 

<math display="inline" id="Tower_of_Hanoi:2">
 <semantics>
  <mrow>
   <msub>
    <mi>T</mi>
    <mi>h</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mn>2</mn>
     <msub>
      <mi>T</mi>
      <mrow>
       <mi>h</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msub>
    </mrow>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>T</ci>
     <ci>h</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>T</ci>
       <apply>
        <minus></minus>
        <ci>h</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T_{h}=2T_{h-1}+1
  </annotation>
 </semantics>
</math>

.</p>
<h3 id="non-recursive-solution">Non-recursive solution</h3>

<p>The list of moves for a tower being carried from one peg onto another one, as produced by the recursive algorithm has many regularities. When counting the moves starting from 1, the ordinal of the disk to be moved during move <em>m</em> is the number of times <em>m</em> can be divided by 2. Hence every odd move involves the smallest disk. It can also be observed that the smallest disk traverses the pegs f, t, r, f, t, r, etc. for odd height of the tower and traverses the pegs f, r, t, f, r, t, etc. for even height of the tower. This provides the following algorithm, which is easier, carried out by hand, than the recursive algorithm.</p>

<p>In alternate moves:</p>
<ul>
<li>move the smallest disk to the peg it has not recently come from.</li>
<li>move another disk legally (there will be one possibility only)</li>
</ul>

<p>For the very first move, the smallest disk goes to peg t if h is odd and to peg r if h is even.</p>

<p>Also observe that:</p>
<ul>
<li>Disks whose ordinals have even parity move in the same sense as the smallest disk.</li>
<li>Disks whose ordinals have odd parity move in opposite sense.</li>
<li>If h is even, the remaining third peg during successive moves is t, r, f, t, r, f, etc.</li>
<li>If h is odd, the remaining third peg during successive moves is r, t, f, r, t, f, etc.</li>
</ul>

<p>With this knowledge, a set of disks in the middle of an optimal solution can be recovered with no more state information than the positions of each disk:</p>
<ul>
<li>Call the moves detailed above a disk's 'natural' move.</li>
<li>Examine the smallest top disk that is not disk 0, and note what its only (legal) move would be: (if there is no such disc, then we are either at the first or last move).</li>
<li>If that move is the disk's 'natural' move, then the disc has not been moved since the last disc 0 move, and that move should be taken.</li>
<li>If that move is not the disk's 'natural' move, then move disk 0.</li>
</ul>
<h3 id="binary-solution">Binary solution</h3>

<p>Disk positions may be determined more directly from the <a href="binary_numeral_system" title="wikilink">binary</a> (base 2) representation of the move number (the initial state being move #0, with all digits 0, and the final state being #2<sup><em>n</em></sup>−1, with all digits 1), using the following rules:</p>
<ul>
<li>There is one binary digit (<a class="uri" href="bit" title="wikilink">bit</a>) for each disk</li>
<li>The most significant (leftmost) bit represents the largest disk. A value of 0 indicates that the largest disk is on the initial peg, while a 1 indicates that it's on the final peg (right peg if number of disks is odd and middle peg otherwise).</li>
<li>The bitstring is read from left to right, and each bit can be used to determine the location of the corresponding disk.</li>
<li>A bit with the same value as the previous one means that the corresponding disk is stacked on top the previous disk on the same peg.
<ul>
<li>(That is to say: a straight sequence of 1's or 0's means that the corresponding disks are all on the same peg).</li>
</ul></li>
<li>A bit with a different value to the previous one means that the corresponding disk is one position to the left or right of the previous one. Whether it is left or right is determined by this rule:
<ul>
<li>Assume that the initial peg is on the left.</li>
<li>Also assume "wrapping" - so the right peg counts as one peg "left" of the left peg, and vice versa.</li>
<li>Let n be the number of greater disks that are located on the same peg as their first greater disk and add 1 if the largest disk is on the left peg. If n is even, the disk is located one peg to the right, if n is odd, the disk located one peg to the left (in case of even number of disks and vice versa otherwise).</li>
</ul></li>
</ul>

<p>For example, in an 8-disk Hanoi:</p>
<ul>
<li>Move 0 = 00000000
<ul>
<li>The largest disk is 0, so it is on the left (initial) peg.</li>
<li>All other disks are 0 as well, so they are stacked on top of it. Hence all disks are on the initial peg.</li>
</ul></li>
<li>Move 2<sup>8</sup>-1 = 11111111
<ul>
<li>The largest disk is 1, so it is on the middle (final) peg.</li>
<li>All other disks are 1 as well, so they are stacked on top of it. Hence all disks are on the final peg and the puzzle is complete.</li>
</ul></li>
<li>Move 216<sub>10</sub> = 11011000
<ul>
<li>The largest disk is 1, so it is on the middle (final) peg.</li>
<li>Disk two is also 1, so it is stacked on top of it, on the middle peg.</li>
<li>Disk three is 0, so it is on another peg. Since n is odd (n=1), it is one peg to the left, i.e. on the left peg.</li>
<li>Disk four is 1, so it is on another peg. Since n is odd (n=1), it is one peg to the left, i.e. on the right peg.</li>
<li>Disk five is also 1, so it is stacked on top of it, on the right peg.</li>
<li>Disk six is 0, so it is on another peg. Since n is even (n=2), the disk is one peg to the right, i.e. on the left peg.</li>
<li>Disks seven and eight are also 0, so they are stacked on top of it, on the left peg.</li>
</ul></li>
</ul>

<p>The source and destination pegs for the <em>m</em>th move can also be found elegantly from the binary representation of <em>m</em> using <a href="bitwise_operation" title="wikilink">bitwise operations</a>. To use the syntax of the <a href="C_(programming_language)" title="wikilink">C programming language</a>, move <em>m</em> is from peg <code>(m&amp;m-1;)%3</code> to peg <code>((m|m-1)+1)%3</code>, where the disks begin on peg 0 and finish on peg 1 or 2 according as whether the number of disks is even or odd. Another formulation is from peg <code>(m-(m&amp;-m))%3</code> to peg <code>(m+(m&amp;-m))%3</code>.</p>

<p>Furthermore the disk to be moved is determined by the number of times the move count (m) can be divided by 2 (i.e. the number of zero bits at the right), counting the first move as 1 and identifying the disks by the numbers 0, 1, 2 etc. in order of increasing size. This permits a very fast non-recursive computer implementation to find the positions of the disks after m moves without reference to any previous move or distribution of disks.</p>

<p>The <a href="count_trailing_zeros" title="wikilink">count trailing zeros</a> (ctz) operation, which counts the number of consecutive zeros at the end of a binary number, gives a simple solution to the problem: the disks are numbered from zero, and at move <em>m</em>, disk number ctz(<em>m</em>) is moved the minimum possible distance to the right (circling back around to the left as needed).<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></p>
<h3 id="gray-code-solution">Gray code solution</h3>

<p>The binary numeral system of <a href="Gray_code" title="wikilink">Gray codes</a> gives an alternative way of solving the puzzle. In the Gray system, numbers are expressed in a binary combination of 0s and 1s, but rather than being a standard <a href="numeral_system" title="wikilink">positional numeral system</a>, Gray code operates on the premise that each value differs from its predecessor by only one (and exactly one) bit changed. The number of bits present in Gray code is important, and leading zeros are not optional, unlike in positional systems.</p>

<p>If one counts in Gray code of a bit size equal to the number of disks in a particular Tower of Hanoi, begins at zero, and counts up, then the bit changed each move corresponds to the disk to move, where the least-significant-bit is the smallest disk and the most-significant-bit is the largest.</p>
<dl>
<dd>Counting moves from 1 and identifying the disks by numbers starting from 0 in order of increasing size, the ordinal of the disk to be moved during move m is the number of times m can be divided by 2.
</dd>
</dl>

<p>This technique identifies which disk to move, but not where to move it to. For the smallest disk there are always two possibilities. For the other disks there is always one possibility, except when all disks are on the same peg, but in that case either it is the smallest disk that must be moved or the objective has already been achieved. Luckily, there is a rule which does say where to move the smallest disk to. Let f be the starting peg, t the destination peg and r the remaining third peg. If the number of disks is odd, the smallest disk cycles along the pegs in the order f→t→r→f→t→r, etc. If the number of disks is even, this must be reversed: f→r→t→f→r→t etc.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a></p>
<h2 id="graphical-representation">Graphical representation</h2>

<p>The game can be represented by an undirected <a href="graph_(mathematics)" title="wikilink">graph</a>, the nodes representing distributions of disks and the edges representing moves. For one disk, the graph is a triangle:</p>
<figure><b>(Figure)</b>
<figcaption>Tower of Hanoi 1-disk graph.svg</figcaption>
</figure>

<p>The graph for two disks is three triangles arranged in a larger triangle:</p>
<figure><b>(Figure)</b>
<figcaption>Tower of Hanoi-2.svg</figcaption>
</figure>

<p>The nodes at the vertices of the outermost triangle represent distributions with all disks on the same peg.</p>

<p>For h+1 disks, take the graph of h disks and replace each small triangle with the graph for two disks.</p>

<p>For three disks the graph is:</p>
<figure><b>(Figure)</b>
<figcaption>Tower of Hanoi-3.svg</figcaption>
</figure>
<ul>
<li>call the pegs a, b and c</li>
<li>list disk positions from left to right in order of increasing size</li>
</ul>

<p>The sides of the outermost triangle represent the shortest ways of moving a tower from one peg to another one. The edge in the middle of the sides of the largest triangle represents a move of the largest disk. The edge in the middle of the sides of each next smaller triangle represents a move of each next smaller disk. The sides of the smallest triangles represent moves of the smallest disk.</p>

<p> In general, for a puzzle with <em>n</em> disks, there are 3<sup><em>n</em></sup> nodes in the graph; every node has three edges to other nodes, except the three corner nodes, which have two: it is always possible to move the smallest disk to one of the two other pegs; and it is possible to move one disk between those two pegs <em>except</em> in the situation where all disks are stacked on one peg. The corner nodes represent the three cases where all the disks are stacked on one peg. The diagram for <em>n</em> + 1 disks is obtained by taking three copies of the <em>n</em>-disk diagram—each one representing all the states and moves of the smaller disks for one particular position of the new largest disk—and joining them at the corners with three new edges, representing the only three opportunities to move the largest disk. The resulting figure thus has 3<sup><em>n</em>+1</sup> nodes and still has three corners remaining with only two edges.</p>

<p>As more disks are added, the graph representation of the game will resemble a <a class="uri" href="fractal" title="wikilink">fractal</a> figure, the <a href="Sierpiński_triangle" title="wikilink">Sierpiński triangle</a>. It is clear that the great majority of positions in the puzzle will never be reached when using the shortest possible solution; indeed, if the priests of the legend are using the longest possible solution (without re-visiting any position), it will take them 3<sup>64</sup> − 1 moves, or more than 10<sup>23</sup> years.</p>

<p>The longest non-repetitive way for three disks can be visualized by erasing the unused edges:</p>
<figure><b>(Figure)</b>
<figcaption>Tower of Hanoi-3 Longest Path.svg</figcaption>
</figure>

<p>Incidentally, this longest non-repetitive path can be obtained by forbidding all moves from <em>a</em> to <em>b</em>.</p>

<p>The <a href="Hamiltonian_cycle" title="wikilink">Hamiltonian cycle</a> for three disks is:</p>
<figure><b>(Figure)</b>
<figcaption>Tower of Hanoi-4 Longest Cycle.svg</figcaption>
</figure>

<p>The graphs clearly show that:</p>
<ul>
<li>From every arbitrary distribution of disks, there is exactly one shortest way to move all disks onto one of the three pegs.</li>
<li>Between every pair of arbitrary distributions of disks there are one or two different shortest paths.</li>
<li>From every arbitrary distribution of disks, there are one or two different longest non selfcrossing paths to move all disks to one of the three pegs.</li>
<li>Between every pair of arbitrary distributions of disks there are one or two different longest non self-crossing paths.</li>
<li>Let <em>N</em><sub><em>h</em></sub> be the number of non selfcrossing paths for moving a tower of <em>h</em> disks from one peg to another one. Then:
<ul>
<li><em>N</em><sub>1</sub> = 2</li>
<li><em>N</em><sub><em>h</em>+1</sub> = (<em>N</em><sub><em>h</em></sub>)<sup>2</sup> + (<em>N</em><sub><em>h</em></sub>)<sup>3</sup>.</li>
<li>For example: <em>N</em><sub>8</sub> ≈ 1.5456×10<sup>795</sup></li>
</ul></li>
</ul>
<h2 id="applications">Applications</h2>

<p>The Tower of Hanoi is frequently used in psychological research on <a href="problem_solving" title="wikilink">problem solving</a>. There also exists a variant of this task called <a href="Tower_of_London_Test" title="wikilink">Tower of London</a> for neuropsychological diagnosis and treatment of executive functions.</p>

<p>Zhang and Norman (<a href="http://wexler.free.fr/library/files/zhang%20%281994%29%20representations%20in%20distributed%20cognitive%20tasks.pdf">Cognitive Science, 18, 87-122, 1994</a>) used several isomorphic (equivalent) representations of the game to study the impact of representational effect in task design. They demonstrated an impact on user performance by changing the way that the rules of the game are represented, using variations in the physical design of the game components. This knowledge has impacted on the development of the [<a href="http://J%20Biomed%20Inform.%202011%20Dec;44(6):1056-67.%20doi:%2010.1016/j.jbi.2011.08.005.%20Epub%202011%20Aug%2016">http://J%20Biomed%20Inform.%202011%20Dec;44(6):1056-67.%20doi:%2010.1016/j.jbi.2011.08.005.%20Epub%202011%20Aug%2016</a>. TURF framework] for the representation of <a href="Human-computer_interaction" title="wikilink">Human Computer Interaction</a></p>

<p>The Tower of Hanoi is also used as a <a href="Backup_rotation_scheme" title="wikilink">Backup rotation scheme</a> when performing computer data <a class="uri" href="Backups" title="wikilink">Backups</a> where multiple tapes/media are involved.</p>

<p>As mentioned above, the Tower of Hanoi is popular for teaching recursive algorithms to beginning programming students. A pictorial version of this puzzle is programmed into the <a class="uri" href="emacs" title="wikilink">emacs</a> editor, accessed by typing M-x hanoi. There is also a sample algorithm written in <a class="uri" href="Prolog" title="wikilink">Prolog</a>.</p>

<p>The Tower of Hanoi is also used as a test by neuropsychologists trying to evaluate <a href="frontal_lobe" title="wikilink">frontal lobe</a> deficits.</p>

<p>In 2010, researchers published the results of an experiment that found that the ant species <em><a href="Linepithema_humile" title="wikilink">Linepithema humile</a></em> were successfully able to solve the 3-disk version of the Tower of Hanoi problem through non-linear dynamics and pheromone signals.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a></p>
<h2 id="general-shortest-paths-and-the-number-466885">General shortest paths and the number 466/885</h2>

<p>A curious generalization of the original goal of the puzzle is to start from a given configuration of the disks where all disks are not necessarily on the same peg, and to arrive in a minimal number of moves at another given configuration. In general it can be quite difficult to compute a shortest sequence of moves to solve this problem. A solution was proposed by Andreas Hinz, and is based on the observation that in a shortest sequence of moves, the largest disk that needs to be moved (obviously one may ignore all of the largest disks that will occupy the same peg in both the initial and final configurations) will move either exactly once or exactly twice.</p>

<p>The mathematics related to this generalized problem becomes even more interesting when one considers the <strong>average</strong> number of moves in a shortest sequence of moves between two initial and final disk configurations that are chosen at random. Hinz and Chan Hat-Tung independently discovered <a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a><a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> (see also, <a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a> Chapter 1, p. 14) that the average number of moves in an n-disk Tower is given by the following exact formula:</p>

<p>

<math display="block" id="Tower_of_Hanoi:3">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mfrac>
       <mn>466</mn>
       <mn>885</mn>
      </mfrac>
      <mo>⋅</mo>
      <msup>
       <mn>2</mn>
       <mi>n</mi>
      </msup>
     </mrow>
     <mo>-</mo>
     <mfrac>
      <mn>1</mn>
      <mn>3</mn>
     </mfrac>
     <mo>-</mo>
     <mrow>
      <mfrac>
       <mn>3</mn>
       <mn>5</mn>
      </mfrac>
      <mo>⋅</mo>
      <msup>
       <mrow>
        <mo>(</mo>
        <mfrac>
         <mn>1</mn>
         <mn>3</mn>
        </mfrac>
        <mo>)</mo>
       </mrow>
       <mi>n</mi>
      </msup>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mrow>
      <mo>(</mo>
      <mrow>
       <mfrac>
        <mn>12</mn>
        <mn>29</mn>
       </mfrac>
       <mo>+</mo>
       <mrow>
        <mfrac>
         <mn>18</mn>
         <mn>1003</mn>
        </mfrac>
        <msqrt>
         <mn>17</mn>
        </msqrt>
       </mrow>
      </mrow>
      <mo>)</mo>
     </mrow>
     <msup>
      <mrow>
       <mo>(</mo>
       <mfrac>
        <mrow>
         <mn>5</mn>
         <mo>+</mo>
         <msqrt>
          <mn>17</mn>
         </msqrt>
        </mrow>
        <mn>18</mn>
       </mfrac>
       <mo>)</mo>
      </mrow>
      <mi>n</mi>
     </msup>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mrow>
      <mo>(</mo>
      <mrow>
       <mfrac>
        <mn>12</mn>
        <mn>29</mn>
       </mfrac>
       <mo>-</mo>
       <mrow>
        <mfrac>
         <mn>18</mn>
         <mn>1003</mn>
        </mfrac>
        <msqrt>
         <mn>17</mn>
        </msqrt>
       </mrow>
      </mrow>
      <mo>)</mo>
     </mrow>
     <msup>
      <mrow>
       <mo>(</mo>
       <mfrac>
        <mrow>
         <mn>5</mn>
         <mo>-</mo>
         <msqrt>
          <mn>17</mn>
         </msqrt>
        </mrow>
        <mn>18</mn>
       </mfrac>
       <mo>)</mo>
      </mrow>
      <mi>n</mi>
     </msup>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <minus></minus>
     <apply>
      <ci>normal-⋅</ci>
      <apply>
       <divide></divide>
       <cn type="integer">466</cn>
       <cn type="integer">885</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">2</cn>
       <ci>n</ci>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <cn type="integer">3</cn>
     </apply>
     <apply>
      <ci>normal-⋅</ci>
      <apply>
       <divide></divide>
       <cn type="integer">3</cn>
       <cn type="integer">5</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <cn type="integer">3</cn>
       </apply>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <plus></plus>
      <apply>
       <divide></divide>
       <cn type="integer">12</cn>
       <cn type="integer">29</cn>
      </apply>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <cn type="integer">18</cn>
        <cn type="integer">1003</cn>
       </apply>
       <apply>
        <root></root>
        <cn type="integer">17</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <divide></divide>
       <apply>
        <plus></plus>
        <cn type="integer">5</cn>
        <apply>
         <root></root>
         <cn type="integer">17</cn>
        </apply>
       </apply>
       <cn type="integer">18</cn>
      </apply>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <minus></minus>
      <apply>
       <divide></divide>
       <cn type="integer">12</cn>
       <cn type="integer">29</cn>
      </apply>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <cn type="integer">18</cn>
        <cn type="integer">1003</cn>
       </apply>
       <apply>
        <root></root>
        <cn type="integer">17</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <divide></divide>
       <apply>
        <minus></minus>
        <cn type="integer">5</cn>
        <apply>
         <root></root>
         <cn type="integer">17</cn>
        </apply>
       </apply>
       <cn type="integer">18</cn>
      </apply>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{466}{885}\cdot 2^{n}-\frac{1}{3}-\frac{3}{5}\cdot\left(\frac{1}{3}\right%
)^{n}+\left(\frac{12}{29}+\frac{18}{1003}\sqrt{17}\right)\left(\frac{5+\sqrt{1%
7}}{18}\right)^{n}+\left(\frac{12}{29}-\frac{18}{1003}\sqrt{17}\right)\left(%
\frac{5-\sqrt{17}}{18}\right)^{n}.
  </annotation>
 </semantics>
</math>

</p>

<p>Note that for large enough <em>n</em>, only the first and second terms do not converge to zero, so we get an <a href="asymptotic_analysis" title="wikilink">asymptotic expression</a>

<math display="block" id="Tower_of_Hanoi:4">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mn>466</mn>
      <mo>/</mo>
      <mn>885</mn>
     </mrow>
     <mo>⋅</mo>
     <msup>
      <mn>2</mn>
      <mi>n</mi>
     </msup>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mn>1</mn>
     <mo>/</mo>
     <mn>3</mn>
    </mrow>
   </mrow>
   <mo>+</mo>
   <mrow>
    <mi>o</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>1</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <minus></minus>
     <apply>
      <ci>normal-⋅</ci>
      <apply>
       <divide></divide>
       <cn type="integer">466</cn>
       <cn type="integer">885</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">2</cn>
       <ci>n</ci>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <cn type="integer">3</cn>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>o</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   466/885\cdot 2^{n}-1/3+o(1)
  </annotation>
 </semantics>
</math>

, as 

<math display="inline" id="Tower_of_Hanoi:5">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>→</mo>
   <mi mathvariant="normal">∞</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>n</ci>
    <infinity></infinity>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n\to\infty
  </annotation>
 </semantics>
</math>

. Thus intuitively, we could interpret the fraction of 

<math display="inline" id="Tower_of_Hanoi:6">
 <semantics>
  <mrow>
   <mrow>
    <mn>466</mn>
    <mo>/</mo>
    <mn>885</mn>
   </mrow>
   <mo>≈</mo>
   <mrow>
    <mn>52.6</mn>
    <mo lspace="0pt" rspace="3.5pt">%</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <apply>
     <divide></divide>
     <cn type="integer">466</cn>
     <cn type="integer">885</cn>
    </apply>
    <apply>
     <csymbol cd="latexml">percent</csymbol>
     <cn type="float">52.6</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   466/885\approx 52.6\%
  </annotation>
 </semantics>
</math>

 as representing the ratio of the labor one has to perform when going from a randomly chosen configuration to another randomly chosen configuration, relative to the difficulty of having to cross the "most difficult" path of length 

<math display="inline" id="Tower_of_Hanoi:7">
 <semantics>
  <mrow>
   <msup>
    <mn>2</mn>
    <mi>n</mi>
   </msup>
   <mo>-</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <ci>n</ci>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{n}-1
  </annotation>
 </semantics>
</math>

 which involves moving all the disks from one peg to another. An alternative explanation for the appearance of the constant 466/885, as well as a new and somewhat improved algorithm for computing the shortest path, was given by Romik.<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a></p>
<h2 id="variations">Variations</h2>
<h3 id="cyclic-hanoi">Cyclic Hanoi</h3>

<p>In Cyclic Hanoi, we are given three pegs (A, B, C), which are arranged as a circle with the clockwise and the counterclockwise directions being defined as A - B - C - A and A - C - B - A respectively. The moving direction of the disc must be clockwise. <a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a> It suffices to represent the sequence of discs to be moved. The solution can be found using two mutually recursive procedures:</p>

<p>To move <em>n</em> discs <strong>counterclockwise</strong> to the neighbouring target peg:</p>
<ol>
<li>move <em>n</em> − 1 discs <strong>counterclockwise</strong> to the target peg</li>
<li>move disc #<em>n</em> one step clockwise</li>
<li>move <em>n</em> − 1 discs <strong>clockwise</strong> to the start peg</li>
<li>move disc #<em>n</em> one step clockwise</li>
<li>move <em>n</em> − 1 discs <strong>counterclockwise</strong> to the target peg</li>
</ol>

<p>To move <em>n</em> discs <strong>clockwise</strong> to the neighbouring target peg:</p>
<ol>
<li>move <em>n</em> − 1 discs <strong>counterclockwise</strong> to a spare peg</li>
<li>move disc #<em>n</em> one step clockwise</li>
<li>move <em>n</em> − 1 discs <strong>counterclockwise</strong> to the target peg</li>
</ol>

<p>Let C(n) and A(n) represent moving n discs clockwise and counterclockwise, then we can write down both formulas:</p>

<p><code>      C(n) = A(n-1) n A(n-1)    and      A(n) = A(n-1) n C(n-1) n A(n-1).</code></p>

<p><code>Thus  C(1) = 1                  and      A(1) = 1 1,</code><br/>
<code>      C(2) = 1 1 2 1 1          and      A(2) = 1 1 2 1 2 1 1.</code></p>

<p>The solution for the Cyclic Hanoi has some interesting properties:</p>

<p>1)The move-patterns of transferring a tower of discs from a peg to another peg are symmetric with respect to the center points.</p>

<p>2)The smallest disc is the first and last disc to move.</p>

<p>3)Groups of the smallest disc moves alternate with single moves of other discs.</p>

<p>4)The number of discs moves specified by C(n) and A(n) are minimal.</p>
<h3 id="with-four-pegs-and-beyond">With four pegs and beyond</h3>

<p>Although the three-peg version has a simple recursive solution as outlined above, the <em>optimal</em> solution for the Tower of Hanoi problem with four pegs (called <strong>Reve's puzzle</strong>), let alone more pegs, is still an <a href="open_problem" title="wikilink">open problem</a>. This is a good example of how a simple, solvable problem can be made dramatically more difficult by slightly loosening one of the problem constraints.</p>

<p>The fact that the problem with four or more pegs is an open problem does not imply that no algorithm exists for finding (all of) the optimal solutions. Simply represent the game by an undirected graph, the nodes being distributions of disks and the edges being moves and use <a href="breadth_first_search" title="wikilink">breadth first search</a> to find one (or all) shortest path(s) moving a tower from one peg onto another one. However, even smartly implemented on the fastest computer now available, this algorithm provides no way of effectively computing solutions for large numbers of disks; the program would require more time and memory than available. Hence, even having an algorithm, it remains unknown how many moves an optimal solution requires and how many optimal solutions exist for 1000 disks and 10 pegs.</p>

<p>Though it is not known exactly how many moves must be made, there are some asymptotic results. There is also a "presumed-optimal solution" given by the <strong>Frame-Stewart algorithm</strong>, discovered independently by Frame and Stewart in 1941.<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a> The related open <strong>Frame-Stewart conjecture</strong> claims that the Frame-Stewart algorithm always gives an optimal solution. The optimality of the Frame-Stewart algorithm has been computationally verified for 4 pegs with up to 30 disks.<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a></p>

<p>For other variants of the four-peg Tower of Hanoi problem, see Paul Stockmeyer's survey paper.<a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a></p>
<h4 id="framestewart-algorithm">Frame–Stewart algorithm</h4>

<p>The Frame–Stewart algorithm, giving a <em>presumably optimal solution</em> for four (or even more) pegs, is described below:</p>
<ul>
<li>Let 

<math display="inline" id="Tower_of_Hanoi:8">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 be the number of disks.</li>
<li>Let 

<math display="inline" id="Tower_of_Hanoi:9">
 <semantics>
  <mi>r</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>r</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r
  </annotation>
 </semantics>
</math>

 be the number of pegs.</li>
<li>Define 

<math display="inline" id="Tower_of_Hanoi:10">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo>,</mo>
    <mi>r</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>T</ci>
    <interval closure="open">
     <ci>n</ci>
     <ci>r</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T(n,r)
  </annotation>
 </semantics>
</math>

 to be the minimum number of moves required to transfer n disks using r pegs</li>
</ul>

<p>The algorithm can be described recursively:</p>
<ol>
<li>For some 

<math display="inline" id="Tower_of_Hanoi:11">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Tower_of_Hanoi:12">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>≤</mo>
   <mi>k</mi>
   <mo><</mo>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <cn type="integer">1</cn>
     <ci>k</ci>
    </apply>
    <apply>
     <lt></lt>
     <share href="#.cmml">
     </share>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1\leq k<n
  </annotation>
 </semantics>
</math>

, transfer the top 

<math display="inline" id="Tower_of_Hanoi:13">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 disks to a single peg other than the start or destination pegs, taking 

<math display="inline" id="Tower_of_Hanoi:14">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>k</mi>
    <mo>,</mo>
    <mi>r</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>T</ci>
    <interval closure="open">
     <ci>k</ci>
     <ci>r</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T(k,r)
  </annotation>
 </semantics>
</math>

 moves.</li>
<li>Without disturbing the peg that now contains the top 

<math display="inline" id="Tower_of_Hanoi:15">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 disks, transfer the remaining 

<math display="inline" id="Tower_of_Hanoi:16">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>-</mo>
   <mi>k</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>n</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n-k
  </annotation>
 </semantics>
</math>

 disks to the destination peg, using only the remaining 

<math display="inline" id="Tower_of_Hanoi:17">
 <semantics>
  <mrow>
   <mi>r</mi>
   <mo>-</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>r</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r-1
  </annotation>
 </semantics>
</math>

 pegs, taking 

<math display="inline" id="Tower_of_Hanoi:18">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>n</mi>
     <mo>-</mo>
     <mi>k</mi>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mi>r</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>T</ci>
    <interval closure="open">
     <apply>
      <minus></minus>
      <ci>n</ci>
      <ci>k</ci>
     </apply>
     <apply>
      <minus></minus>
      <ci>r</ci>
      <cn type="integer">1</cn>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T(n-k,r-1)
  </annotation>
 </semantics>
</math>

 moves.</li>
<li>Finally, transfer the top 

<math display="inline" id="Tower_of_Hanoi:19">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 disks to the destination peg, taking 

<math display="inline" id="Tower_of_Hanoi:20">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>k</mi>
    <mo>,</mo>
    <mi>r</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>T</ci>
    <interval closure="open">
     <ci>k</ci>
     <ci>r</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T(k,r)
  </annotation>
 </semantics>
</math>

 moves.</li>
</ol>

<p>The entire process takes 

<math display="inline" id="Tower_of_Hanoi:21">
 <semantics>
  <mrow>
   <mrow>
    <mn>2</mn>
    <mi>T</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>k</mi>
     <mo>,</mo>
     <mi>r</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>+</mo>
   <mrow>
    <mi>T</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>n</mi>
      <mo>-</mo>
      <mi>k</mi>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mi>r</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <times></times>
     <cn type="integer">2</cn>
     <ci>T</ci>
     <interval closure="open">
      <ci>k</ci>
      <ci>r</ci>
     </interval>
    </apply>
    <apply>
     <times></times>
     <ci>T</ci>
     <interval closure="open">
      <apply>
       <minus></minus>
       <ci>n</ci>
       <ci>k</ci>
      </apply>
      <apply>
       <minus></minus>
       <ci>r</ci>
       <cn type="integer">1</cn>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2T(k,r)+T(n-k,r-1)
  </annotation>
 </semantics>
</math>

 moves. Therefore, the count 

<math display="inline" id="Tower_of_Hanoi:22">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 should be picked for which this quantity is minimum. (In a four-peg scenario, the ideal 

<math display="inline" id="Tower_of_Hanoi:23">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 is equal to 

<math display="inline" id="Tower_of_Hanoi:24">
 <semantics>
  <msqrt>
   <mrow>
    <mrow>
     <mn>2</mn>
     <mi>n</mi>
    </mrow>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </msqrt>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <root></root>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <ci>n</ci>
     </apply>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sqrt{2n+1}
  </annotation>
 </semantics>
</math>

 rounded minus 1.<a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a>)</p>

<p>This algorithm (with the above choice for 

<math display="inline" id="Tower_of_Hanoi:25">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

) is presumed to be optimal, and no counterexamples are known.</p>
<h3 id="multistack-tower-of-hanoi">Multistack Tower of Hanoi</h3>

<p>U.S. patent number 7,566,057 issued to Victor Mascolo discloses multistack Tower of Hanoi puzzles with two or more stacks and twice as many pegs as stacks. After beginning on a particular peg, each stack displaces and is displaced by a different colored stack on another peg when the puzzle is solved. Disks of one color also have another peg that excludes all other colors, so that there are three pegs available for each color disk, two that are shared with other colors, and one that is not shared. On the shared pegs, a disk may not be placed on a different colored disk of the same size, a possibility that does not arise in the standard puzzle.</p>

<p>The simplest multistack game, Tower of Hanoi (2 × 4), has two stacks and four pegs, and it requires 3[<em>T</em>(<em>n</em>)] moves to solve where <em>T</em>(<em>n</em>) is the number of moves needed to solve a single stack classic of <em>n</em> disks. The game proceeds in seesaw fashion with longer and longer series of moves that alternate between colors. It concludes in reverse seesaw fashion with shorter and shorter such series of moves. Starting with the second series of three moves, these alternate series of moves double in length for the first half of the game, and the lengths are halved as the game concludes. The solution involves nesting an algorithm suitable for Tower of Hanoi into an algorithm that indicates when to switch between colors. When there are k stacks of n disks apiece in a game, and <em>k</em> &gt; 2, it requires <em>k</em>[<em>T</em>(<em>n</em>)] + <em>T</em>(<em>n</em> − 1) + 1 moves to relocate them.</p>

<p>The addition of a centrally located universal peg open to disks from all stacks converts these multistack Tower of Hanoi puzzles to multistack Reve's puzzles as described in the preceding section. In these games each stack may move among four pegs, the same combination of three in the 2 × 4 game plus the central universal peg. The simplest game of this kind (2 × 5) has two stacks and five pegs. A solution conjectured to be optimal interlocks the optimal solution of the 2 × 4 puzzle with the presumed optimal solution to Reve's puzzle. It takes <em>R</em>(<em>n</em>) + 2<em>R</em>(<em>n</em> − 1) + 2 moves, where <em>R</em>(<em>n</em>) is the number of moves in the presumed optimal Reve's solution for a stack of <em>n</em> disks.</p>
<h2 id="in-popular-culture">In popular culture</h2>

<p>In the science fiction story "Now Inhale", by <a href="Eric_Frank_Russell" title="wikilink">Eric Frank Russell</a>,<a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a> the human is a held prisoner on a planet where the local custom is to make the prisoner play a game until it is won or lost before his execution. The protagonist knows that a rescue ship might take a year or more to arrive, so he chooses to play Towers of Hanoi with 64 disks. (This story makes reference to the legend about the Buddhist monks playing the game until the end of the world.)</p>

<p>In the 1966 <em><a href="Doctor_Who" title="wikilink">Doctor Who</a></em> story <em><a href="The_Celestial_Toymaker" title="wikilink">The Celestial Toymaker</a></em>, the <a href="eponym" title="wikilink">eponymous</a> villain forces <a href="The_Doctor_(Doctor_Who)" title="wikilink">the Doctor</a> to play a ten-piece 1,023-move Tower of Hanoi game entitled <a href="List_of_Doctor_Who_items#T" title="wikilink">The Trilogic Game</a> with the pieces forming a pyramid shape when stacked.</p>

<p>In 2007, the concept of the Towers Of Hanoi problem was used in <em><a href="Professor_Layton_and_the_Diabolical_Box" title="wikilink">Professor Layton and the Diabolical Box</a></em> in puzzles 6, 83, and 84, but the discs had been changed to pancakes. The puzzle was based around a dilemma where the chef of a restaurant had to move a pile of pancakes from one plate to the other with the basic principles of the original puzzle (i.e. three plates that the pancakes could be moved onto, not being able to put a larger pancake onto a smaller one, etc.)</p>

<p>In the film <em><a href="Rise_of_the_Planet_of_the_Apes" title="wikilink">Rise of the Planet of the Apes</a></em> (2011), this puzzle, called in the film the "Lucas Tower", is used as a test to study the intelligence of apes.</p>

<p>The puzzle is featured regularly in <a href="adventure_game" title="wikilink">adventure</a> and <a href="computer_puzzle_game" title="wikilink">puzzle</a> games. Since it is easy to implement, and easily recognised, it is well-suited to use as a puzzle in a larger graphical game (e.g. <em><a href="Star_Wars:_Knights_of_the_Old_Republic" title="wikilink">Star Wars: Knights of the Old Republic</a></em> and <em><a href="Mass_Effect_(video_game)" title="wikilink">Mass Effect</a></em><a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a>). Some implementations use straight disks, but others disguise the puzzle in some other form. There is an arcade version by <a class="uri" href="Sega" title="wikilink">Sega</a>/<a class="uri" href="Andamiro" title="wikilink">Andamiro</a>.<a class="footnoteRef" href="#fn23" id="fnref23"><sup>23</sup></a></p>

<p>The problem is featured as part of a reward challenge in a <a href='Survivor:_South_Pacific#Episode_1:_"I_Need_Redemption"' title="wikilink">2011 episode of the American version of the <em>Survivor</em> TV series</a>. Both players (<a href="Ozzy_Lusth" title="wikilink">Ozzy Lusth</a> and <a href="Benjamin_Wade_(Survivor_contestant)" title="wikilink">Benjamin "Coach" Wade</a>) struggled to understand how to solve the puzzle and are aided by their fellow tribe members.</p>
<h2 id="in-materials-science">In materials science</h2>

<p> In 2014, scientists synthesized multilayered palladium nanosheets with the Tower of Hanoi like structure.<a class="footnoteRef" href="#fn24" id="fnref24"><sup>24</sup></a> This is the first time that similar structure is observed in nature.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Backup_rotation_scheme" title="wikilink">Backup rotation scheme</a>, a TOH application</li>
<li><a class="uri" href="Baguenaudier" title="wikilink">Baguenaudier</a></li>
<li><a href="Recursion_(computer_science)" title="wikilink">Recursion (computer science)</a></li>
</ul>
<h2 id="notes">Notes</h2>
<h2 id="external-links">External links</h2>
<ul>
<li></li>
<li></li>
<li><a href="http://www.codeminima.com/Lisp:_Tower_of_Hanoi">Tower of Hanoi: Code in Lisp</a></li>
<li><a href="https://play.google.com/store/apps/details?id=com.ADP.pyramidmovers">Tower of Hanoi Variant Game: Pyramid Mover</a></li>
<li><a href="http://www.towerofhanoi.org">Tower of Hanoi: online game</a></li>
</ul>

<p>"</p>

<p><a href="Category:Mechanical_puzzles" title="wikilink">Category:Mechanical puzzles</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
<li id="fn10"><a href="#fnref10">↩</a></li>
<li id="fn11"><a href="#fnref11">↩</a></li>
<li id="fn12"><a href="#fnref12">↩</a></li>
<li id="fn13"><a href="#fnref13">↩</a></li>
<li id="fn14"><a href="#fnref14">↩</a></li>
<li id="fn15"><a href="#fnref15">↩</a></li>
<li id="fn16"><a href="#fnref16">↩</a></li>
<li id="fn17"><a href="#fnref17">↩</a></li>
<li id="fn18"><a href="#fnref18">↩</a></li>
<li id="fn19"><a href="#fnref19">↩</a></li>
<li id="fn20"><a href="#fnref20">↩</a></li>
<li id="fn21"><a href="#fnref21">↩</a></li>
<li id="fn22"><a href="#fnref22">↩</a></li>
<li id="fn23"><a class="uri" href="http://www.segaarcade.com/towerofhanoi">http://www.segaarcade.com/towerofhanoi</a><a href="#fnref23">↩</a></li>
<li id="fn24"></li>
</ol>
</section>
</body>
</html>
