<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1087">Activity selection problem</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Activity selection problem</h1>
<hr/>

<p>The <strong>activity selection problem</strong> is a <a href="mathematical_optimization" title="wikilink">mathematical optimization</a> problem concerning the selection of non-conflicting <a href="task_(project_management)" title="wikilink">activities</a> to perform within a given <a href="time_frame" title="wikilink">time frame</a>, given a set of activities each marked by a start time (s<sub>i</sub>) and finish time (f<sub>i</sub>). The problem is to select the maximum number of activities that can be performed by a single person or <a class="uri" href="machine" title="wikilink">machine</a>, assuming that a person can only work on a single activity at a time.</p>

<p>A classic application of this problem is in scheduling a room for multiple <a class="uri" href="competing" title="wikilink">competing</a> events, each having its own time requirements (start and end time), and many more arise within the framework of <a href="operations_research" title="wikilink">operations research</a>.</p>
<h2 id="formal-definition">Formal definition</h2>

<p>Assume there exist <em>n</em> activities with each of them being represented by a start time <em>s<sub>i</sub></em> and finish time <em>f<sub>i</sub></em>. Two activities <em>i</em> and <em>j</em> are said to be non-conflicting if <em>s<sub>i</sub></em> ≥ <em>f<sub>j</sub></em> or <em>s<sub>j</sub></em> ≥ <em>f<sub>i</sub></em>. The activity selection problem consists in finding the maximal solution set (S) of non-conflicting activities, or more precisely there must exist no <a href="solution_set" title="wikilink">solution set</a> S' such that |S'| &gt; |S| in the case that multiple maximal solutions have equal sizes.</p>
<h2 id="optimal-solution">Optimal Solution</h2>

<p>The activity selection problem is notable in that using a <a href="greedy_algorithm" title="wikilink">greedy algorithm</a> to find a solution will always result in an <a href="optimal_solution" title="wikilink">optimal solution</a>. A <a class="uri" href="pseudocode" title="wikilink">pseudocode</a> sketch of the algorithm and a proof of the optimality of its result are included below.</p>
<h3 id="algorithm">Algorithm</h3>
<dl>
<dd>Sort the set of activities by finishing time (f[i])
</dd>
<dd>S = {1}
</dd>
<dd>f = f[1]
</dd>
<dd><strong>for</strong> i=2 to n
<dl>
<dd><strong>if</strong> s[i] ≥ f
<dl>
<dd>S = S U i
</dd>
<dd>f = f[i]
</dd>
</dl>
</dd>
</dl>
</dd>
<dd><strong>end if</strong>
</dd>
</dl>
<h3 id="proof-of-optimality">Proof of optimality</h3>

<p>Let 

<math display="inline" id="Activity_selection_problem:0">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mn>1</mn>
    <mo>,</mo>
    <mn>2</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mi>n</mi>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>S</ci>
    <set>
     <cn type="integer">1</cn>
     <cn type="integer">2</cn>
     <ci>normal-…</ci>
     <ci>n</ci>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S=\{1,2,\ldots,n\}
  </annotation>
 </semantics>
</math>

 be the set of activities ordered by finish time. Thus activity 1 has the earliest finish time.</p>

<p>Suppose <em>A</em> is a subset of <em>S</em> is an optimal solution and let activities in <em>A</em> be ordered by finish time. Suppose that the first activity in <em>A</em> is <em>k</em> ≠ 1, that is, this optimal solution <em>does not</em> start with the "greedy choice." We want to show that there is another solution B that begins with the greedy choice, activity 1.</p>

<p>Let 

<math display="inline" id="Activity_selection_problem:1">
 <semantics>
  <mrow>
   <mi>B</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>A</mi>
      <mo>∖</mo>
      <mrow>
       <mo stretchy="false">{</mo>
       <mi>k</mi>
       <mo stretchy="false">}</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∪</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mn>1</mn>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>B</ci>
    <apply>
     <union></union>
     <apply>
      <setdiff></setdiff>
      <ci>A</ci>
      <set>
       <ci>k</ci>
      </set>
     </apply>
     <set>
      <cn type="integer">1</cn>
     </set>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B=(A\setminus\{k\})\cup\{1\}
  </annotation>
 </semantics>
</math>

. Because 

<math display="inline" id="Activity_selection_problem:2">
 <semantics>
  <mrow>
   <msub>
    <mi>f</mi>
    <mn>1</mn>
   </msub>
   <mo>≤</mo>
   <msub>
    <mi>f</mi>
    <mi>k</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>f</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>f</ci>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{1}\leq f_{k}
  </annotation>
 </semantics>
</math>

, the activities in <em>B</em> are <a href="Disjoint_sets" title="wikilink">disjoint</a> and since <em>B</em> has same number of activities as <em>A</em>, i.e., |<em>A</em>| = |<em>B</em>|, <em>B</em> is also optimal.</p>

<p>Once the greedy choice is made, the problem reduces to finding an optimal solution for the subproblem. If <em>A</em> is an optimal solution to the original problem <em>S</em>, then 

<math display="inline" id="Activity_selection_problem:3">
 <semantics>
  <mrow>
   <msup>
    <mi>A</mi>
    <mo>′</mo>
   </msup>
   <mo>=</mo>
   <mrow>
    <mi>A</mi>
    <mo>∖</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mn>1</mn>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>A</ci>
     <ci>normal-′</ci>
    </apply>
    <apply>
     <setdiff></setdiff>
     <ci>A</ci>
     <set>
      <cn type="integer">1</cn>
     </set>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A^{\prime}=A\setminus\{1\}
  </annotation>
 </semantics>
</math>

 is an optimal solution to the activity-selection problem 

<math display="inline" id="Activity_selection_problem:4">
 <semantics>
  <mrow>
   <msup>
    <mi>S</mi>
    <mo>′</mo>
   </msup>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mi>i</mi>
     <mo>∈</mo>
     <mi>S</mi>
    </mrow>
    <mo>:</mo>
    <mrow>
     <msub>
      <mi>s</mi>
      <mi>i</mi>
     </msub>
     <mo>≥</mo>
     <msub>
      <mi>f</mi>
      <mn>1</mn>
     </msub>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>S</ci>
     <ci>normal-′</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <apply>
      <in></in>
      <ci>i</ci>
      <ci>S</ci>
     </apply>
     <apply>
      <geq></geq>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>s</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>f</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S^{\prime}=\{i\in S:s_{i}\geq f_{1}\}
  </annotation>
 </semantics>
</math>

.</p>

<p>Why? If we could find a solution <em>B</em>′ to <em>S</em>′ with more activities then <em>A</em>′, adding 1 to <em>B</em>′ would yield a solution <em>B</em> to <em>S</em> with more activities than <em>A</em>, contradicting the optimality.</p>
<h3 id="weighted-activity-selection-problem">Weighted Activity Selection Problem</h3>

<p>The generalized version of the activity selection problem involves selecting an optimal set of non-overlapping activities such that the total weight is maximized. Unlike the unweighted version, there is no greedy solution to the weighted activity selection problem. However, a <a href="dynamic_programming" title="wikilink">dynamic programming</a> solution can readily be formed using the following approach:<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>

<p>Consider an optimal solution containing activity 

<math display="inline" id="Activity_selection_problem:5">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

. We now have non-overlapping activities on the left and right of 

<math display="inline" id="Activity_selection_problem:6">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

. We can recursively find solutions for these two sets because of optimal sub-structure. As we don't know 

<math display="inline" id="Activity_selection_problem:7">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

, we can try each of the activities. This approach leads to an 

<math display="inline" id="Activity_selection_problem:8">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>n</mi>
     <mn>3</mn>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>n</ci>
     <cn type="integer">3</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n^{3})
  </annotation>
 </semantics>
</math>

 solution. This can be optimized further considering that for each set of activities in 

<math display="inline" id="Activity_selection_problem:9">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>i</mi>
   <mo>,</mo>
   <mi>j</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>i</ci>
    <ci>j</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (i,j)
  </annotation>
 </semantics>
</math>

, we can find the optimal solution if we had known the solution for 

<math display="inline" id="Activity_selection_problem:10">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>i</mi>
   <mo>,</mo>
   <mi>t</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>i</ci>
    <ci>t</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (i,t)
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Activity_selection_problem:11">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 is the last non-overlapping interval with 

<math display="inline" id="Activity_selection_problem:12">
 <semantics>
  <mi>j</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>j</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   j
  </annotation>
 </semantics>
</math>

 in 

<math display="inline" id="Activity_selection_problem:13">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>i</mi>
   <mo>,</mo>
   <mi>j</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>i</ci>
    <ci>j</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (i,j)
  </annotation>
 </semantics>
</math>

. This yields an 

<math display="inline" id="Activity_selection_problem:14">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>n</mi>
     <mn>2</mn>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>n</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n^{2})
  </annotation>
 </semantics>
</math>

 solution. This can be further optimized considering the fact that we do not need to consider all ranges 

<math display="inline" id="Activity_selection_problem:15">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>i</mi>
   <mo>,</mo>
   <mi>j</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>i</ci>
    <ci>j</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (i,j)
  </annotation>
 </semantics>
</math>

 but instead just 

<math display="inline" id="Activity_selection_problem:16">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mn>1</mn>
   <mo>,</mo>
   <mi>j</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <cn type="integer">1</cn>
    <ci>j</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (1,j)
  </annotation>
 </semantics>
</math>

. The following algorithm thus yields an 

<math display="inline" id="Activity_selection_problem:17">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>n</mi>
     <mi>l</mi>
     <mi>o</mi>
     <mi>g</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>n</ci>
     <ci>l</ci>
     <ci>o</ci>
     <ci>g</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(nlog(n))
  </annotation>
 </semantics>
</math>

 solution:</p>
<pre class="pli"><code>procedure WeightedActivitySelection( S : list of activities )
   sort s by finish time
   opt[0] = 0
   for i = 1 to n
     t = binary search to find activity with finish time &lt;= start time for i
     opt[i] = MAX(opt[i-1], opt[t] + w(i))
   return opt[n]
end procedure</code></pre>
<h2 id="references">References</h2>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.personal.kent.edu/~rmuhamma/Algorithms/MyAlgorithms/Greedy/actSelectionGreedy.htm">Activity Selection Problem</a></li>
</ul>

<p>"</p>

<p><a href="Category:Scheduling_algorithms" title="wikilink">Category:Scheduling algorithms</a> <a href="Category:Articles_containing_proofs" title="wikilink">Category:Articles containing proofs</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="http://www.cs.princeton.edu/~wayne/cs423/lectures/dynamic-programming-4up.pdf">Dynamic Programming with introduction to Weighted Activity Selection</a><a href="#fnref1">↩</a></li>
</ol>
</section>
</body>
</html>
