<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1633">Trial division</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Trial division</h1>
<style>
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
<style>
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
</body></html>
<body>
<hr/>

<p><strong>Trial division</strong> is the most laborious but easiest to understand of the <a href="integer_factorization" title="wikilink">integer factorization</a> algorithms. The essential idea behind trial division tests to see if an integer <em>n</em>, the integer to be factored, can be divided by each number in turn that is less than <em>n</em>. For example, for the integer 

<math display="inline" id="Trial_division:0">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>=</mo>
   <mn>12</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>n</ci>
    <cn type="integer">12</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n=12
  </annotation>
 </semantics>
</math>

, the only numbers that divide it are 1,2,3,4,6,12. Selecting only the largest powers of <a href="prime_number" title="wikilink">primes</a> in this list gives that 

<math display="inline" id="Trial_division:1">
 <semantics>
  <mrow>
   <mn>12</mn>
   <mo>=</mo>
   <mrow>
    <mn>3</mn>
    <mi mathvariant="normal">×</mi>
    <mn>4</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <cn type="integer">12</cn>
    <apply>
     <times></times>
     <cn type="integer">3</cn>
     <ci>normal-×</ci>
     <cn type="integer">4</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   12=3×4
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="method">Method</h2>

<p>Given an integer <em>n</em> (throughout this article, <em>n</em> refers to "the integer to be factored"), trial division consists of systematically testing whether <em>n</em> is divisible by any smaller number. Clearly, it is only worthwhile to test candidate factors less than <em>n</em>, and in order from two upwards because an arbitrary <em>n</em> is more likely to be divisible by two than by three, and so on. With this ordering, there is no point in testing for divisibility by four if the number has already been determined not divisible by two, and so on for three and any multiple of three, etc. Therefore, effort can be reduced by selecting only <a href="Prime_number" title="wikilink">prime numbers</a> as candidate factors. Furthermore, the trial factors need go no further than 

<math display="inline" id="Trial_division:2">
 <semantics>
  <msqrt>
   <mi>n</mi>
  </msqrt>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <root></root>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle\sqrt{n}
  </annotation>
 </semantics>
</math>

 because, if <em>n</em> is divisible by some number <em>p</em>, then <em>n = p × q</em> and if <em>q</em> were smaller than <em>p</em>, <em>n</em> would have earlier been detected as being divisible by <em>q</em> or a prime factor of <em>q</em>.</p>

<p>A definite bound on the prime factors is possible. Suppose <em>P<sub>i</sub></em> is the <em>i</em>'th prime, so that <em>P<sub>1</sub></em> = 2, <em>P<sub>2</sub></em> = 3, <em>P<sub>3</sub></em> = 5, etc. Then the last prime number worth testing as a possible factor of <em>n</em> is <em>P<sub>i</sub></em> where <em>P<sup>2</sup><sub>i + 1</sub></em> &gt; <em>n</em>; equality here would mean that <em>P<sub>i + 1</sub></em> is a factor. Thus, testing with 2, 3, and 5 suffices up to <em>n</em> = 48 not just 25 because the square of the next prime is 49, and below <em>n</em> = 25 just 2 and 3 are sufficient. Should the square root of <em>n</em> be integral, then it is a factor and <em>n</em> is a <a href="square_number" title="wikilink">perfect square</a>.</p>

<p>An example of the trial division algorithm, using a <a href="Generating_primes#Prime_sieves" title="wikilink">prime sieve</a> for prime number generation, is as follows (in <a href="Python_(programming_language)" title="wikilink">Python</a>):</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> trial_division(n):
    <span class="co">"""Return a list of the prime factors for a natural number."""</span>
    <span class="cf">if</span> n <span class="op">&lt;</span> <span class="dv">2</span>:
        <span class="cf">return</span> []
    prime_factors <span class="op">=</span> []
    <span class="cf">for</span> p <span class="op">in</span> prime_sieve(<span class="bu">int</span>(n<span class="op">**</span><span class="fl">0.5</span>) <span class="op">+</span> <span class="dv">1</span>):
        <span class="cf">if</span> p<span class="op">*</span>p <span class="op">&gt;</span> n: <span class="cf">break</span>
        <span class="cf">while</span> n <span class="op">%</span> p <span class="op">==</span> <span class="dv">0</span>:
            prime_factors.append(p)
            n <span class="op">//=</span> p
    <span class="cf">if</span> n <span class="op">&gt;</span> <span class="dv">1</span>:
        prime_factors.append(n)
    <span class="cf">return</span> prime_factors</code></pre></div>

<p>Trial division is guaranteed to find a factor of <em>n</em> if there is one, since it checks all possible prime factors of <em>n</em>. Thus, if the algorithm finds one factor, n, it is proof that <em>n</em> is a <a href="Prime_number" title="wikilink">prime</a>. If more than one factor is found, then <em>n</em> is a <a href="composite_number" title="wikilink">composite integer</a>. A more computationally advantageous way of saying this is, if any prime whose square does not exceed <em>n</em> divides it without a remainder, then <em>n</em> is not prime.</p>
<h2 id="speed">Speed</h2>

<p>In the <a href="worst_case" title="wikilink">worst case</a>, trial division is a laborious algorithm. For a base-2 <em>n</em> digit number <em>a</em>, if it starts from two and works up to the square root of <em>a</em>, the algorithm requires</p>

<p>

<math display="block" id="Trial_division:3">
 <semantics>
  <mrow>
   <mrow>
    <mi>π</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mn>2</mn>
      <mrow>
       <mi>n</mi>
       <mo>/</mo>
       <mn>2</mn>
      </mrow>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≈</mo>
   <mfrac>
    <msup>
     <mn>2</mn>
     <mrow>
      <mi>n</mi>
      <mo>/</mo>
      <mn>2</mn>
     </mrow>
    </msup>
    <mrow>
     <mrow>
      <mo>(</mo>
      <mfrac>
       <mi>n</mi>
       <mn>2</mn>
      </mfrac>
      <mo>)</mo>
     </mrow>
     <mrow>
      <mi>ln</mi>
      <mn>2</mn>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <apply>
     <times></times>
     <ci>π</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <apply>
       <divide></divide>
       <ci>n</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <apply>
       <divide></divide>
       <ci>n</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <ci>n</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <ln></ln>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi(2^{n/2})\approx{2^{n/2}\over\left(\frac{n}{2}\right)\ln 2}
  </annotation>
 </semantics>
</math>

</p>

<p>trial divisions, where 

<math display="inline" id="Trial_division:4">
 <semantics>
  <mrow>
   <mi>π</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>π</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle\pi(x)
  </annotation>
 </semantics>
</math>

 denotes the <a href="prime-counting_function" title="wikilink">prime-counting function</a>, the number of primes less than <em>x</em>. This does not take into account the overhead of <a href="primality_testing" title="wikilink">primality testing</a> to obtain the prime numbers as candidate factors. A useful table need not be large: P(3512) = 32749, the last prime that fits into a sixteen-bit signed integer and P(6542) = 65521 for unsigned sixteen-bit integers. That would suffice to test primality for numbers up to 65537<sup>2</sup> = 4,295,098,369. Preparing such a table (usually via the <a href="Sieve_of_Eratosthenes" title="wikilink">Sieve of Eratosthenes</a>) would only be worthwhile if many numbers were to be tested. If instead a variant is used without primality testing, but simply dividing by every odd number less than the square root the base-2 <em>n</em> digit number <em>a</em>, prime or not, it can take up to about:</p>

<p>

<math display="block" id="Trial_division:5">
 <semantics>
  <msup>
   <mn>2</mn>
   <mrow>
    <mi>n</mi>
    <mo>/</mo>
    <mn>2</mn>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <apply>
     <divide></divide>
     <ci>n</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{n/2}
  </annotation>
 </semantics>
</math>

</p>

<p>In both cases the required time grows exponentially with the digits of the number.</p>

<p>Even so, this is a quite satisfactory method, considering that even the best known algorithms have exponential time growth. For <em>a</em> chosen uniformly at random from integers of a given length, there is a 50% chance that 2 is a factor of <em>a</em>, and a 33% chance that 3 is a factor of <em>a</em>, and so on. It can be shown that 88% of all positive integers have a factor under 100, and that 92% have a factor under 1000. Thus, when confronted by an arbitrary large <em>a</em>, it is worthwhile to check for divisibility by the small primes, since for 

<math display="inline" id="Trial_division:6">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo>=</mo>
   <mn>1000</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>a</ci>
    <cn type="integer">1000</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a=1000
  </annotation>
 </semantics>
</math>

, in base-2 

<math display="inline" id="Trial_division:7">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>=</mo>
   <mn>10</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>n</ci>
    <cn type="integer">10</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n=10
  </annotation>
 </semantics>
</math>

.</p>

<p>However, many-digit numbers that do not have factors in the small primes can require days or months to factor with trial division. In such cases other methods are used such as the <a href="quadratic_sieve" title="wikilink">quadratic sieve</a> and the <a href="general_number_field_sieve" title="wikilink">general number field sieve</a> (GNFS). Because these methods also have exponential time growth a practical limit of <em>n</em> digits is reached very quickly. For this reason, in <a href="public_key_cryptography" title="wikilink">public key cryptography</a>, values for <em>a</em> are chosen to have large prime factors of similar size so that they cannot be factored by any publicly known method in a useful time period on any available computer system or computer cluster such as <a href="supercomputer" title="wikilink">supercomputers</a> and <a href="Grid_computing" title="wikilink">computer grids</a>. The largest cryptography-grade number that has been factored is <a class="uri" href="RSA-768" title="wikilink">RSA-768</a>, using the GNFS and a network of hundreds of computers. The running time was approximately 2 years.</p>
<h2 id="references">References</h2>
<ul>
<li></li>
<li></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.se16.info/js/factor.htm">Javascript Prime Factor Calculator using trial division</a>. Can handle numbers up to about 9×10<sup>15</sup></li>
</ul>

<p>"</p>

<p><a href="Category:Integer_factorization_algorithms" title="wikilink">Category:Integer factorization algorithms</a> <a href="Category:Division_(mathematics)" title="wikilink">Category:Division (mathematics)</a> <a href="Category:Articles_with_example_Python_code" title="wikilink">Category:Articles with example Python code</a></p>
</body>

