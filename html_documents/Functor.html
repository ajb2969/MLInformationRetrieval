<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="394">Functor</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Functor</h1>
<hr/>

<p>In <a class="uri" href="mathematics" title="wikilink">mathematics</a>, a <strong>functor</strong> is a type of mapping between <a href="Category_(mathematics)" title="wikilink">categories</a> which is applied in <a href="category_theory" title="wikilink">category theory</a>. Functors can be thought of as <a href="homomorphism" title="wikilink">homomorphisms</a> between categories. In the <a href="category_of_small_categories" title="wikilink">category of small categories</a>, functors can be thought of more generally as <a href="morphism" title="wikilink">morphisms</a>.</p>

<p>Functors were first considered in <a href="algebraic_topology" title="wikilink">algebraic topology</a>, where algebraic objects (like the <a href="fundamental_group" title="wikilink">fundamental group</a>) are associated to <a href="topological_space" title="wikilink">topological spaces</a>, and algebraic homomorphisms are associated to <a href="continuous_function" title="wikilink">continuous</a> maps. Nowadays, functors are used throughout modern mathematics to relate various categories. Thus, functors are generally applicable in areas within mathematics that <a href="category_theory" title="wikilink">category theory</a> can make an abstraction of.</p>

<p>The word <em>functor</em> was borrowed by mathematicians from the <a class="uri" href="philosopher" title="wikilink">philosopher</a> <a href="Rudolf_Carnap" title="wikilink">Rudolf Carnap</a>,<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> who used the term in a <a href="Linguistics" title="wikilink">linguistic</a> context:<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> see <a href="function_word" title="wikilink">function word</a>.</p>
<h2 id="definition">Definition</h2>

<p>Let <em>C</em> and <em>D</em> be <a href="category_(mathematics)" title="wikilink">categories</a>. A <strong>functor</strong> <em>F</em> from <em>C</em> to <em>D</em> is a mapping that<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>
<ul>
<li>associates to each object 

<math display="inline" id="Functor:0">
 <semantics>
  <mrow>
   <mi>X</mi>
   <mo>∈</mo>
   <mi>C</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>X</ci>
    <ci>C</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X\in C
  </annotation>
 </semantics>
</math>

 an object 

<math display="inline" id="Functor:1">
 <semantics>
  <mrow>
   <mrow>
    <mi>F</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>∈</mo>
   <mi>D</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <times></times>
     <ci>F</ci>
     <ci>X</ci>
    </apply>
    <ci>D</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F(X)\in D
  </annotation>
 </semantics>
</math>

,</li>
<li>associates to each morphism 

<math display="inline" id="Functor:2">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mo>:</mo>
   <mrow>
    <mi>X</mi>
    <mo>→</mo>
    <mi>Y</mi>
    <mo>∈</mo>
    <mi>C</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>f</ci>
    <apply>
     <and></and>
     <apply>
      <ci>normal-→</ci>
      <ci>X</ci>
      <ci>Y</ci>
     </apply>
     <apply>
      <in></in>
      <share href="#.cmml">
      </share>
      <ci>C</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f:X\rightarrow Y\in C
  </annotation>
 </semantics>
</math>

 a morphism 

<math display="inline" id="Functor:3">
 <semantics>
  <mrow>
   <mrow>
    <mi>F</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>f</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mi>F</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>X</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>→</mo>
    <mrow>
     <mi>F</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>Y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>∈</mo>
    <mi>D</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <times></times>
     <ci>F</ci>
     <ci>f</ci>
    </apply>
    <apply>
     <and></and>
     <apply>
      <ci>normal-→</ci>
      <apply>
       <times></times>
       <ci>F</ci>
       <ci>X</ci>
      </apply>
      <apply>
       <times></times>
       <ci>F</ci>
       <ci>Y</ci>
      </apply>
     </apply>
     <apply>
      <in></in>
      <share href="#.cmml">
      </share>
      <ci>D</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F(f):F(X)\rightarrow F(Y)\in D
  </annotation>
 </semantics>
</math>

 such that the following two conditions hold:
<ul>
<li>

<math display="inline" id="Functor:4">
 <semantics>
  <mrow>
   <mrow>
    <mi>F</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>id</mi>
      <mi>X</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msub>
    <mi>id</mi>
    <mrow>
     <mi>F</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>X</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>F</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>id</ci>
      <ci>X</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>id</ci>
     <apply>
      <times></times>
      <ci>F</ci>
      <ci>X</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F(\mathrm{id}_{X})=\mathrm{id}_{F(X)}\,\!
  </annotation>
 </semantics>
</math>

 for every object 

<math display="inline" id="Functor:5">
 <semantics>
  <mrow>
   <mi>X</mi>
   <mo>∈</mo>
   <mi>C</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>X</ci>
    <ci>C</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X\in C
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="Functor:6">
 <semantics>
  <mrow>
   <mrow>
    <mi>F</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>g</mi>
      <mo>∘</mo>
      <mi>f</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <mi>F</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>g</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>∘</mo>
     <mi>F</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>f</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>F</ci>
     <apply>
      <compose></compose>
      <ci>g</ci>
      <ci>f</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <compose></compose>
      <apply>
       <times></times>
       <ci>F</ci>
       <ci>g</ci>
      </apply>
      <ci>F</ci>
     </apply>
     <ci>f</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F(g\circ f)=F(g)\circ F(f)
  </annotation>
 </semantics>
</math>

 for all morphisms 

<math display="inline" id="Functor:7">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mo>:</mo>
   <mrow>
    <mi>X</mi>
    <mo>→</mo>
    <mi>Y</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>f</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>X</ci>
     <ci>Y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f:X\rightarrow Y\,\!
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Functor:8">
 <semantics>
  <mrow>
   <mrow>
    <mi>g</mi>
    <mo>:</mo>
    <mrow>
     <mi>Y</mi>
     <mo>→</mo>
     <mi>Z</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>g</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>Y</ci>
     <ci>Z</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g:Y\rightarrow Z.\,\!
  </annotation>
 </semantics>
</math>

</li>
</ul></li>
</ul>

<p>That is, functors must preserve <a href="Morphism#Definition" title="wikilink">identity morphisms</a> and <a href="Function_composition" title="wikilink">composition</a> of morphisms.</p>
<h3 id="covariance-and-contravariance">Covariance and contravariance</h3>

<p>There are many constructions in mathematics that would be functors but for the fact that they "turn morphisms around" and "reverse composition". We then define a <strong>contravariant functor</strong> <em>F</em> from <em>C</em> to <em>D</em> as a mapping that</p>
<ul>
<li>associates to each object 

<math display="inline" id="Functor:9">
 <semantics>
  <mrow>
   <mi>X</mi>
   <mo>∈</mo>
   <mi>C</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>X</ci>
    <ci>C</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X\in C
  </annotation>
 </semantics>
</math>

 an object 

<math display="inline" id="Functor:10">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>F</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>X</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>∈</mo>
    <mi>D</mi>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <times></times>
     <ci>F</ci>
     <ci>X</ci>
    </apply>
    <ci>D</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F(X)\in D,
  </annotation>
 </semantics>
</math>

</li>
<li>associates to each morphism 

<math display="inline" id="Functor:11">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mo>:</mo>
   <mrow>
    <mi>X</mi>
    <mo>→</mo>
    <mi>Y</mi>
    <mo>∈</mo>
    <mi>C</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>f</ci>
    <apply>
     <and></and>
     <apply>
      <ci>normal-→</ci>
      <ci>X</ci>
      <ci>Y</ci>
     </apply>
     <apply>
      <in></in>
      <share href="#.cmml">
      </share>
      <ci>C</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f:X\rightarrow Y\in C
  </annotation>
 </semantics>
</math>

 a morphism 

<math display="inline" id="Functor:12">
 <semantics>
  <mrow>
   <mrow>
    <mi>F</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>f</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mi>F</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>Y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>→</mo>
    <mrow>
     <mi>F</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>X</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>∈</mo>
    <mi>D</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <times></times>
     <ci>F</ci>
     <ci>f</ci>
    </apply>
    <apply>
     <and></and>
     <apply>
      <ci>normal-→</ci>
      <apply>
       <times></times>
       <ci>F</ci>
       <ci>Y</ci>
      </apply>
      <apply>
       <times></times>
       <ci>F</ci>
       <ci>X</ci>
      </apply>
     </apply>
     <apply>
      <in></in>
      <share href="#.cmml">
      </share>
      <ci>D</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F(f):F(Y)\rightarrow F(X)\in D
  </annotation>
 </semantics>
</math>

 such that
<ul>
<li>

<math display="inline" id="Functor:13">
 <semantics>
  <mrow>
   <mrow>
    <mi>F</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>id</mi>
      <mi>X</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msub>
    <mi>id</mi>
    <mrow>
     <mi>F</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>X</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>F</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>id</ci>
      <ci>X</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>id</ci>
     <apply>
      <times></times>
      <ci>F</ci>
      <ci>X</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F(\mathrm{id}_{X})=\mathrm{id}_{F(X)}\,\!
  </annotation>
 </semantics>
</math>

 for every object 

<math display="inline" id="Functor:14">
 <semantics>
  <mrow>
   <mi>X</mi>
   <mo>∈</mo>
   <mi>C</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>X</ci>
    <ci>C</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X\in C
  </annotation>
 </semantics>
</math>

,</li>
<li>

<math display="inline" id="Functor:15">
 <semantics>
  <mrow>
   <mrow>
    <mi>F</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>g</mi>
      <mo>∘</mo>
      <mi>f</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <mi>F</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>f</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>∘</mo>
     <mi>F</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>g</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>F</ci>
     <apply>
      <compose></compose>
      <ci>g</ci>
      <ci>f</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <compose></compose>
      <apply>
       <times></times>
       <ci>F</ci>
       <ci>f</ci>
      </apply>
      <ci>F</ci>
     </apply>
     <ci>g</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F(g\circ f)=F(f)\circ F(g)
  </annotation>
 </semantics>
</math>

 for all morphisms 

<math display="inline" id="Functor:16">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mo>:</mo>
   <mrow>
    <mi>X</mi>
    <mo>→</mo>
    <mi>Y</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>f</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>X</ci>
     <ci>Y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f:X\rightarrow Y\,\!
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Functor:17">
 <semantics>
  <mrow>
   <mrow>
    <mi>g</mi>
    <mo>:</mo>
    <mrow>
     <mi>Y</mi>
     <mo>→</mo>
     <mi>Z</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>g</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>Y</ci>
     <ci>Z</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g:Y\rightarrow Z.\,\!
  </annotation>
 </semantics>
</math>

</li>
</ul></li>
</ul>

<p>Note that contravariant functors reverse the direction of composition.</p>

<p>Ordinary functors are also called <strong>covariant functors</strong> in order to distinguish them from contravariant ones. Note that one can also define a contravariant functor as a <em>covariant</em> functor on the <a href="opposite_category" title="wikilink">opposite category</a> 

<math display="inline" id="Functor:18">
 <semantics>
  <msup>
   <mi>C</mi>
   <mi>op</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>C</ci>
    <ci>op</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C^{\mathrm{op}}
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> Some authors prefer to write all expressions covariantly. That is, instead of saying 

<math display="inline" id="Functor:19">
 <semantics>
  <mrow>
   <mi>F</mi>
   <mo>:</mo>
   <mrow>
    <mi>C</mi>
    <mo>→</mo>
    <mi>D</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>F</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>C</ci>
     <ci>D</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F:C\rightarrow D
  </annotation>
 </semantics>
</math>

 is a contravariant functor, they simply write 

<math display="inline" id="Functor:20">
 <semantics>
  <mrow>
   <mi>F</mi>
   <mo>:</mo>
   <mrow>
    <msup>
     <mi>C</mi>
     <mi>op</mi>
    </msup>
    <mo>→</mo>
    <mi>D</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>F</ci>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>C</ci>
      <ci>op</ci>
     </apply>
     <ci>D</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F:C^{\mathrm{op}}\rightarrow D
  </annotation>
 </semantics>
</math>

 (or sometimes 

<math display="inline" id="Functor:21">
 <semantics>
  <mrow>
   <mi>F</mi>
   <mo>:</mo>
   <mrow>
    <mi>C</mi>
    <mo>→</mo>
    <msup>
     <mi>D</mi>
     <mi>op</mi>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>F</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>C</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>D</ci>
      <ci>op</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F:C\rightarrow D^{\mathrm{op}}
  </annotation>
 </semantics>
</math>

) and call it a functor.</p>

<p>Contravariant functors are also occasionally called <em>cofunctors</em>.</p>
<h3 id="opposite-functor">Opposite functor</h3>

<p>Every functor 

<math display="inline" id="Functor:22">
 <semantics>
  <mrow>
   <mi>F</mi>
   <mo>:</mo>
   <mrow>
    <mi>C</mi>
    <mo>→</mo>
    <mi>D</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>F</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>C</ci>
     <ci>D</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F:C\rightarrow D
  </annotation>
 </semantics>
</math>

 induces the <strong>opposite functor</strong> 

<math display="inline" id="Functor:23">
 <semantics>
  <mrow>
   <msup>
    <mi>F</mi>
    <mi>op</mi>
   </msup>
   <mo>:</mo>
   <mrow>
    <msup>
     <mi>C</mi>
     <mi>op</mi>
    </msup>
    <mo>→</mo>
    <msup>
     <mi>D</mi>
     <mi>op</mi>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>F</ci>
     <ci>op</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>C</ci>
      <ci>op</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>D</ci>
      <ci>op</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F^{\mathrm{op}}:C^{\mathrm{op}}\rightarrow D^{\mathrm{op}}
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Functor:24">
 <semantics>
  <msup>
   <mi>C</mi>
   <mi>op</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>C</ci>
    <ci>op</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C^{\mathrm{op}}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Functor:25">
 <semantics>
  <msup>
   <mi>D</mi>
   <mi>op</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>D</ci>
    <ci>op</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D^{\mathrm{op}}
  </annotation>
 </semantics>
</math>

 are the <a href="opposite_category" title="wikilink">opposite categories</a> to 

<math display="inline" id="Functor:26">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Functor:27">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> By definition, 

<math display="inline" id="Functor:28">
 <semantics>
  <msup>
   <mi>F</mi>
   <mi>op</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>F</ci>
    <ci>op</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F^{\mathrm{op}}
  </annotation>
 </semantics>
</math>

 maps objects and morphisms identically to 

<math display="inline" id="Functor:29">
 <semantics>
  <mi>F</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>F</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F
  </annotation>
 </semantics>
</math>

. Since 

<math display="inline" id="Functor:30">
 <semantics>
  <msup>
   <mi>C</mi>
   <mi>op</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>C</ci>
    <ci>op</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C^{\mathrm{op}}
  </annotation>
 </semantics>
</math>

 does not coincide with 

<math display="inline" id="Functor:31">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

 as a category, and similarly for 

<math display="inline" id="Functor:32">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Functor:33">
 <semantics>
  <msup>
   <mi>F</mi>
   <mi>op</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>F</ci>
    <ci>op</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F^{\mathrm{op}}
  </annotation>
 </semantics>
</math>

 is distinguished from 

<math display="inline" id="Functor:34">
 <semantics>
  <mi>F</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>F</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F
  </annotation>
 </semantics>
</math>

. For example, when composing 

<math display="inline" id="Functor:35">
 <semantics>
  <mrow>
   <mi>F</mi>
   <mo>:</mo>
   <mrow>
    <msub>
     <mi>C</mi>
     <mn>0</mn>
    </msub>
    <mo>→</mo>
    <msub>
     <mi>C</mi>
     <mn>1</mn>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>F</ci>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>C</ci>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>C</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F:C_{0}\rightarrow C_{1}
  </annotation>
 </semantics>
</math>

 with 

<math display="inline" id="Functor:36">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mo>:</mo>
   <mrow>
    <msubsup>
     <mi>C</mi>
     <mn>1</mn>
     <mi>op</mi>
    </msubsup>
    <mo>→</mo>
    <msub>
     <mi>C</mi>
     <mn>2</mn>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>G</ci>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>C</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>op</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>C</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G:C_{1}^{\mathrm{op}}\rightarrow C_{2}
  </annotation>
 </semantics>
</math>

, one should use either 

<math display="inline" id="Functor:37">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mo>∘</mo>
   <msup>
    <mi>F</mi>
    <mi>op</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <compose></compose>
    <ci>G</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>F</ci>
     <ci>op</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G\circ F^{\mathrm{op}}
  </annotation>
 </semantics>
</math>

 or 

<math display="inline" id="Functor:38">
 <semantics>
  <mrow>
   <msup>
    <mi>G</mi>
    <mi>op</mi>
   </msup>
   <mo>∘</mo>
   <mi>F</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <compose></compose>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>G</ci>
     <ci>op</ci>
    </apply>
    <ci>F</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G^{\mathrm{op}}\circ F
  </annotation>
 </semantics>
</math>

. Note that, following the property of <a href="opposite_category" title="wikilink">opposite category</a>, 

<math display="inline" id="Functor:39">
 <semantics>
  <mrow>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>F</mi>
      <mi>op</mi>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>op</mi>
   </msup>
   <mo>=</mo>
   <mi>F</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>F</ci>
      <ci>op</ci>
     </apply>
     <ci>op</ci>
    </apply>
    <ci>F</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (F^{\mathrm{op}})^{\mathrm{op}}=F
  </annotation>
 </semantics>
</math>

.</p>
<h3 id="bifunctors-and-multifunctors">Bifunctors and multifunctors</h3>

<p>A <strong>bifunctor</strong> (also known as a <strong>binary functor</strong>) is a functor whose domain is a <a href="product_category" title="wikilink">product category</a>. For example, the <a href="Hom_functor" title="wikilink">Hom functor</a> is of the type <em>C</em><sup>op</sup> × <em>C</em> → <strong>Set</strong>. It can be seen as a functor in <em>two</em> arguments. The <a href="Hom_functor" title="wikilink">Hom functor</a> is a natural example; it is contravariant in one argument, covariant in the other.</p>

<p>A <strong>multifunctor</strong> is a generalization of the functor concept to <em>n</em> variables. So, for example, a bifunctor is a multifunctor with <em>n</em> = 2.</p>
<h2 id="examples">Examples</h2>

<p><strong><a href="Diagram_(category_theory)" title="wikilink">Diagram</a></strong>: For categories <em>C</em> and <em>J</em>, a diagram of type <em>J</em> in <em>C</em> is a covariant functor 

<math display="inline" id="Functor:40">
 <semantics>
  <mrow>
   <mi>D</mi>
   <mo>:</mo>
   <mrow>
    <mi>J</mi>
    <mo>→</mo>
    <mi>C</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>D</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>J</ci>
     <ci>C</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D:J\rightarrow C
  </annotation>
 </semantics>
</math>

.</p>

<p><strong><a href="Presheaf_(category_theory)" title="wikilink">(Category theoretical) presheaf</a></strong>: For categories <em>C</em> and <em>J</em>, a <em>J</em>-presheaf on <em>C</em> is a contravariant functor 

<math display="inline" id="Functor:41">
 <semantics>
  <mrow>
   <mi>D</mi>
   <mo>:</mo>
   <mrow>
    <mi>C</mi>
    <mo>→</mo>
    <mi>J</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>D</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>C</ci>
     <ci>J</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D:C\rightarrow J
  </annotation>
 </semantics>
</math>

.</p>

<p><strong>Presheaves:</strong> If <em>X</em> is a <a href="topological_space" title="wikilink">topological space</a>, then the <a href="open_set" title="wikilink">open sets</a> in <em>X</em> form a <a href="partially_ordered_set" title="wikilink">partially ordered set</a> Open(<em>X</em>) under inclusion. Like every partially ordered set, Open(<em>X</em>) forms a small category by adding a single arrow <em>U</em> → <em>V</em> if and only if 

<math display="inline" id="Functor:42">
 <semantics>
  <mrow>
   <mi>U</mi>
   <mo>⊆</mo>
   <mi>V</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <ci>U</ci>
    <ci>V</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U\subseteq V
  </annotation>
 </semantics>
</math>

. Contravariant functors on Open(<em>X</em>) are called <em><a href="presheaf" title="wikilink">presheaves</a></em> on <em>X</em>. For instance, by assigning to every open set <em>U</em> the <a href="associative_algebra" title="wikilink">associative algebra</a> of real-valued continuous functions on <em>U</em>, one obtains a presheaf of algebras on <em>X</em>.</p>

<p><strong>Constant functor:</strong> The functor <em>C</em> → <em>D</em> which maps every object of <em>C</em> to a fixed object <em>X</em> in <em>D</em> and every morphism in <em>C</em> to the identity morphism on <em>X</em>. Such a functor is called a <em>constant</em> or <em>selection</em> functor.</p>

<p><strong>Endofunctor</strong>: A functor that maps a category to itself.</p>

<p><strong>Identity functor</strong> in category <em>C</em>, written 1<sub><em>C</em></sub> or id<sub><em>C</em></sub>, maps an object to itself and a morphism to itself. Identity functor is an endofunctor.</p>

<p><strong>Diagonal functor</strong>: The <a href="diagonal_functor" title="wikilink">diagonal functor</a> is defined as the functor from <em>D</em> to the functor category <em>D</em><sup><em>C</em></sup> which sends each object in <em>D</em> to the constant functor at that object.</p>

<p><strong>Limit functor</strong>: For a fixed <a href="index_category" title="wikilink">index category</a> <em>J</em>, if every functor <em>J</em>→<em>C</em> has a <a href="limit_(category_theory)" title="wikilink">limit</a> (for instance if <em>C</em> is complete), then the limit functor <em>C</em><sup><em>J</em></sup>→<em>C</em> assigns to each functor its limit. The existence of this functor can be proved by realizing that it is the <a href="Adjoint_functors" title="wikilink">right-adjoint</a> to the <a href="diagonal_functor" title="wikilink">diagonal functor</a> and invoking the <a href="Freyd_adjoint_functor_theorem" title="wikilink">Freyd adjoint functor theorem</a>. This requires a suitable version of the <a href="axiom_of_choice" title="wikilink">axiom of choice</a>. Similar remarks apply to the <a href="colimit_functor" title="wikilink">colimit functor</a> (which is covariant).</p>

<p><strong>Power sets:</strong> The power set functor <em>P</em> : <strong>Set</strong> → <strong>Set</strong> maps each set to its <a href="power_set" title="wikilink">power set</a> and each function 

<math display="inline" id="Functor:43">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mo>:</mo>
   <mrow>
    <mi>X</mi>
    <mo>→</mo>
    <mi>Y</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>f</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>X</ci>
     <ci>Y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f:X\to Y
  </annotation>
 </semantics>
</math>

 to the map which sends 

<math display="inline" id="Functor:44">
 <semantics>
  <mrow>
   <mi>U</mi>
   <mo>⊆</mo>
   <mi>X</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <ci>U</ci>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U\subseteq X
  </annotation>
 </semantics>
</math>

 to its image 

<math display="inline" id="Functor:45">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>U</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>⊆</mo>
   <mi>Y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>U</ci>
    </apply>
    <ci>Y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(U)\subseteq Y
  </annotation>
 </semantics>
</math>

. One can also consider the contravariant power set functor which sends 

<math display="inline" id="Functor:46">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mo>:</mo>
   <mrow>
    <mi>X</mi>
    <mo>→</mo>
    <mi>Y</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>f</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>X</ci>
     <ci>Y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f:X\to Y
  </annotation>
 </semantics>
</math>

 to the map which sends 

<math display="inline" id="Functor:47">
 <semantics>
  <mrow>
   <mi>V</mi>
   <mo>⊆</mo>
   <mi>Y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <ci>V</ci>
    <ci>Y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V\subseteq Y
  </annotation>
 </semantics>
</math>

 to its <a href="inverse_image" title="wikilink">inverse image</a> 

<math display="inline" id="Functor:48">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msup>
      <mi>f</mi>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>V</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>⊆</mo>
    <mi>X</mi>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>f</ci>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>V</ci>
    </apply>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f^{-1}(V)\subseteq X.
  </annotation>
 </semantics>
</math>

</p>

<p><strong>:</strong> The map which assigns to every <a href="vector_space" title="wikilink">vector space</a> its <a href="dual_space" title="wikilink">dual space</a> and to every <a href="linear_operator" title="wikilink">linear map</a> its dual or transpose is a contravariant functor from the category of all vector spaces over a fixed <a href="field_(mathematics)" title="wikilink">field</a> to itself.</p>

<p><strong>Fundamental group:</strong> Consider the category of <a href="pointed_topological_space" title="wikilink">pointed topological spaces</a>, i.e. topological spaces with distinguished points. The objects are pairs (<em>X</em>, <em>x</em><sub>0</sub>), where <em>X</em> is a topological space and <em>x</em><sub>0</sub> is a point in <em>X</em>. A morphism from (<em>X</em>, <em>x</em><sub>0</sub>) to (<em>Y</em>, <em>y</em><sub>0</sub>) is given by a <a href="continuous_function_(topology)" title="wikilink">continuous</a> map <em>f</em> : <em>X</em> → <em>Y</em> with <em>f</em>(<em>x</em><sub>0</sub>) = <em>y</em><sub>0</sub>.</p>

<p>To every topological space <em>X</em> with distinguished point <em>x</em><sub>0</sub>, one can define the <a href="fundamental_group" title="wikilink">fundamental group</a> based at <em>x</em><sub>0</sub>, denoted π<sub>1</sub>(<em>X</em>, <em>x</em><sub>0</sub>). This is the <a href="group_(mathematics)" title="wikilink">group</a> of <a class="uri" href="homotopy" title="wikilink">homotopy</a> classes of loops based at <em>x</em><sub>0</sub>. If <em>f</em> : <em>X</em> → <em>Y</em> morphism of <a href="pointed_space" title="wikilink">pointed spaces</a>, then every loop in <em>X</em> with base point <em>x</em><sub>0</sub> can be composed with <em>f</em> to yield a loop in <em>Y</em> with base point <em>y</em><sub>0</sub>. This operation is compatible with the homotopy <a href="equivalence_relation" title="wikilink">equivalence relation</a> and the composition of loops, and we get a <a href="group_homomorphism" title="wikilink">group homomorphism</a> from π(<em>X</em>, <em>x</em><sub>0</sub>) to π(<em>Y</em>, <em>y</em><sub>0</sub>). We thus obtain a functor from the category of pointed topological spaces to the <a href="category_of_groups" title="wikilink">category of groups</a>.</p>

<p>In the category of topological spaces (without distinguished point), one considers homotopy classes of generic curves, but they cannot be composed unless they share an endpoint. Thus one has the <strong>fundamental <a class="uri" href="groupoid" title="wikilink">groupoid</a></strong> instead of the fundamental group, and this construction is functorial.</p>

<p><strong>Algebra of continuous functions:</strong> a contravariant functor from the category of <a href="topology" title="wikilink">topological spaces</a> (with continuous maps as morphisms) to the category of real <a href="associative_algebra" title="wikilink">associative algebras</a> is given by assigning to every topological space <em>X</em> the algebra C(<em>X</em>) of all real-valued continuous functions on that space. Every continuous map <em>f</em> : <em>X</em> → <em>Y</em> induces an <a href="algebra_homomorphism" title="wikilink">algebra homomorphism</a> C(<em>f</em>) : C(<em>Y</em>) → C(<em>X</em>) by the rule C(<em>f</em>)(φ) = φ o <em>f</em> for every φ in C(<em>Y</em>).</p>

<p><strong>Tangent and cotangent bundles:</strong> The map which sends every <a href="differentiable_manifold" title="wikilink">differentiable manifold</a> to its <a href="tangent_bundle" title="wikilink">tangent bundle</a> and every <a href="smooth_map" title="wikilink">smooth map</a> to its <a class="uri" href="derivative" title="wikilink">derivative</a> is a covariant functor from the category of differentiable manifolds to the category of <a href="vector_bundle" title="wikilink">vector bundles</a>.</p>

<p>Doing this constructions pointwise gives the <a href="tangent_space" title="wikilink">tangent space</a>, a covariant functor from the category of pointed differentiable manifolds to the category of real vector spaces. Likewise, <a href="cotangent_space" title="wikilink">cotangent space</a> is a contravariant functor, essentially the composition of the tangent space with the <a href="#Dual_vector_space" title="wikilink">dual space</a> above.</p>

<p><strong>Group actions/representations:</strong> Every <a href="group_(mathematics)" title="wikilink">group</a> <em>G</em> can be considered as a category with a single object whose morphisms are the elements of <em>G</em>. A functor from <em>G</em> to <strong>Set</strong> is then nothing but a <a href="group_action" title="wikilink">group action</a> of <em>G</em> on a particular set, i.e. a <em>G</em>-set. Likewise, a functor from <em>G</em> to the <a href="category_of_vector_spaces" title="wikilink">category of vector spaces</a>, <strong>Vect</strong><sub><em>K</em></sub>, is a <a href="linear_representation" title="wikilink">linear representation</a> of <em>G</em>. In general, a functor <em>G</em> → <em>C</em> can be considered as an "action" of <em>G</em> on an object in the category <em>C</em>. If <em>C</em> is a group, then this action is a group homomorphism.</p>

<p><strong>Lie algebras:</strong> Assigning to every real (complex) <a href="Lie_group" title="wikilink">Lie group</a> its real (complex) <a href="Lie_algebra" title="wikilink">Lie algebra</a> defines a functor.</p>

<p><strong>Tensor products:</strong> If <em>C</em> denotes the category of vector spaces over a fixed field, with <a href="linear_operator" title="wikilink">linear maps</a> as morphisms, then the <a href="tensor_product" title="wikilink">tensor product</a> 

<math display="inline" id="Functor:49">
 <semantics>
  <mrow>
   <mi>V</mi>
   <mo>⊗</mo>
   <mi>W</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">tensor-product</csymbol>
    <ci>V</ci>
    <ci>W</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V\otimes W
  </annotation>
 </semantics>
</math>

 defines a functor <em>C</em> × <em>C</em> → <em>C</em> which is covariant in both arguments.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>

<p><strong>Forgetful functors:</strong> The functor <em>U</em> : <strong>Grp</strong> → <strong>Set</strong> which maps a <a href="group_(mathematics)" title="wikilink">group</a> to its underlying set and a <a href="group_homomorphism" title="wikilink">group homomorphism</a> to its underlying function of sets is a functor.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> Functors like these, which "forget" some structure, are termed <em><a href="forgetful_functor" title="wikilink">forgetful functors</a></em>. Another example is the functor <strong>Rng</strong> → <strong>Ab</strong> which maps a <a href="ring_(algebra)" title="wikilink">ring</a> to its underlying additive <a href="abelian_group" title="wikilink">abelian group</a>. Morphisms in <strong>Rng</strong> (<a href="ring_homomorphism" title="wikilink">ring homomorphisms</a>) become morphisms in <strong>Ab</strong> (abelian group homomorphisms).</p>

<p><strong>Free functors:</strong> Going in the opposite direction of forgetful functors are free functors. The free functor <em>F</em> : <strong>Set</strong> → <strong>Grp</strong> sends every set <em>X</em> to the <a href="free_group" title="wikilink">free group</a> generated by <em>X</em>. Functions get mapped to group homomorphisms between free groups. Free constructions exist for many categories based on structured sets. See <a href="free_object" title="wikilink">free object</a>.</p>

<p><strong>Homomorphism groups:</strong> To every pair <em>A</em>, <em>B</em> of <a href="group_(mathematics)" title="wikilink">abelian groups</a> one can assign the abelian group Hom(<em>A</em>,<em>B</em>) consisting of all <a href="group_homomorphism" title="wikilink">group homomorphisms</a> from <em>A</em> to <em>B</em>. This is a functor which is contravariant in the first and covariant in the second argument, i.e. it is a functor <strong>Ab</strong><sup>op</sup> × <strong>Ab</strong> → <strong>Ab</strong> (where <strong>Ab</strong> denotes the <a href="category_of_abelian_groups" title="wikilink">category of abelian groups</a> with group homomorphisms). If <em>f</em> : <em>A</em><sub>1</sub> → <em>A</em><sub>2</sub> and <em>g</em> : <em>B</em><sub>1</sub> → <em>B</em><sub>2</sub> are morphisms in <strong>Ab</strong>, then the group homomorphism Hom(<em>f</em>,<em>g</em>) : Hom(<em>A</em><sub>2</sub>,<em>B</em><sub>1</sub>) → Hom(<em>A</em><sub>1</sub>,<em>B</em><sub>2</sub>) is given by φ 

<math display="inline" id="Functor:50">
 <semantics>
  <mo>↦</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">maps-to</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mapsto
  </annotation>
 </semantics>
</math>

 <em>g</em> ∘ φ ∘ <em>f</em>. See <a href="Hom_functor" title="wikilink">Hom functor</a>.</p>

<p><strong>Representable functors:</strong> We can generalize the previous example to any category <em>C</em>. To every pair <em>X</em>, <em>Y</em> of objects in <em>C</em> one can assign the set Hom(<em>X</em>,<em>Y</em>) of morphisms from <em>X</em> to <em>Y</em>. This defines a functor to <strong>Set</strong> which is contravariant in the first argument and covariant in the second, i.e. it is a functor <em>C</em><sup>op</sup> × <em>C</em> → <strong>Set</strong>. If <em>f</em> : <em>X</em><sub>1</sub> → <em>X</em><sub>2</sub> and <em>g</em> : <em>Y</em><sub>1</sub> → <em>Y</em><sub>2</sub> are morphisms in <em>C</em>, then the group homomorphism Hom(<em>f</em>,<em>g</em>) : Hom(<em>X</em><sub>2</sub>,<em>Y</em><sub>1</sub>) → Hom(<em>X</em><sub>1</sub>,<em>Y</em><sub>2</sub>) is given by φ 

<math display="inline" id="Functor:51">
 <semantics>
  <mo>↦</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">maps-to</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mapsto
  </annotation>
 </semantics>
</math>

 <em>g</em> ∘ φ ∘ <em>f</em>.</p>

<p>Functors like these are called <a href="representable_functor" title="wikilink">representable functors</a>. An important goal in many settings is to determine whether a given functor is representable.</p>
<h2 id="properties">Properties</h2>

<p>Two important consequences of the functor <a href="axiom" title="wikilink">axioms</a> are:</p>
<ul>
<li><em>F</em> transforms each <a href="commutative_diagram" title="wikilink">commutative diagram</a> in <em>C</em> into a commutative diagram in <em>D</em>;</li>
<li>if <em>f</em> is an <a class="uri" href="isomorphism" title="wikilink">isomorphism</a> in <em>C</em>, then <em>F</em>(<em>f</em>) is an isomorphism in <em>D</em>.</li>
</ul>

<p>One can compose functors, i.e. if <em>F</em> is a functor from <em>A</em> to <em>B</em> and <em>G</em> is a functor from <em>B</em> to <em>C</em> then one can form the composite functor <em>G∘F</em> from <em>A</em> to <em>C</em>. Composition of functors is associative where defined. Identity of composition of functors is identity functor. This shows that functors can be considered as morphisms in categories of categories, for example in the <a href="category_of_small_categories" title="wikilink">category of small categories</a>.</p>

<p>A small category with a single object is the same thing as a <a class="uri" href="monoid" title="wikilink">monoid</a>: the morphisms of a one-object category can be thought of as elements of the monoid, and composition in the category is thought of as the monoid operation. Functors between one-object categories correspond to monoid <a href="homomorphism" title="wikilink">homomorphisms</a>. So in a sense, functors between arbitrary categories are a kind of generalization of monoid homomorphisms to categories with more than one object.</p>
<h2 id="relation-to-other-categorical-concepts">Relation to other categorical concepts</h2>

<p>Let <em>C</em> and <em>D</em> be categories. The collection of all functors <em>C</em> → <em>D</em> form the objects of a category: the <a href="functor_category" title="wikilink">functor category</a>. Morphisms in this category are <a href="natural_transformation" title="wikilink">natural transformations</a> between functors.</p>

<p>Functors are often defined by <a href="universal_property" title="wikilink">universal properties</a>; examples are the <a href="tensor_product" title="wikilink">tensor product</a>, the <a href="direct_sum_of_modules" title="wikilink">direct sum</a> and <a href="direct_product" title="wikilink">direct product</a> of groups or vector spaces, construction of free groups and modules, <a href="direct_limit" title="wikilink">direct</a> and <a href="inverse_limit" title="wikilink">inverse</a> limits. The concepts of <a href="limit_(category_theory)" title="wikilink">limit and colimit</a> generalize several of the above.</p>

<p>Universal constructions often give rise to pairs of <a href="adjoint_functors" title="wikilink">adjoint functors</a>.</p>
<h2 id="computer-implementations">Computer implementations</h2>

<p>Functors sometimes appear in <a href="functional_programming" title="wikilink">functional programming</a>. For instance, the programming language <a href="Haskell_(programming_language)" title="wikilink">Haskell</a> has a <a href="type_class" title="wikilink">class</a> <code>Functor</code> where <a href="Map_(higher-order_function)#Generalization" title="wikilink"><code>fmap</code></a> is a <a href="polytypic_function" title="wikilink">polytypic function</a> used to map <a href="function_(computer_programming)" title="wikilink">functions</a> (<em>morphisms</em> on <em>Hask</em>, the category of Haskell types) between existing types to functions between some new types.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Functor_category" title="wikilink">Functor category</a></li>
<li><a href="Kan_extension" title="wikilink">Kan extension</a></li>
<li><a class="uri" href="Pseudofunctor" title="wikilink">Pseudofunctor</a></li>
</ul>
<h2 id="notes">Notes</h2>
<references>
</references>
<h2 id="references">References</h2>
<ul>
<li>

<p>.</p></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li></li>
<li>see  and the variations discussed and linked to there.</li>
<li><a href="André_Joyal" title="wikilink">André Joyal</a>, <a href="http://ncatlab.org/nlab">CatLab</a>, a wiki project dedicated to the exposition of categorical mathematics</li>
<li>

<p>formal introduction to category theory.</p></li>
<li>J. Adamek, H. Herrlich, G. Stecker, <a href="http://katmat.math.uni-bremen.de/acc/acc.pdf">Abstract and Concrete Categories-The Joy of Cats</a></li>
<li><a href="Stanford_Encyclopedia_of_Philosophy" title="wikilink">Stanford Encyclopedia of Philosophy</a>: "<a href="http://plato.stanford.edu/entries/category-theory/">Category Theory</a>" — by Jean-Pierre Marquis. Extensive bibliography.</li>
<li><a href="http://www.mta.ca/~cat-dist/">List of academic conferences on category theory</a></li>
<li>Baez, John, 1996,"<a href="http://math.ucr.edu/home/baez/week73.html">The Tale of <em>n</em>-categories.</a>" An informal introduction to higher order categories.</li>
<li><a href="http://wildcatsformma.wordpress.com">WildCats</a> is a <a href="category_theory" title="wikilink">category theory</a> package for <a class="uri" href="Mathematica" title="wikilink">Mathematica</a>. Manipulation and visualization of objects, <a href="morphism" title="wikilink">morphisms</a>, categories, functors, <a href="natural_transformation" title="wikilink">natural transformations</a>, <a href="universal_properties" title="wikilink">universal properties</a>.</li>
<li><a href="http://www.youtube.com/user/TheCatsters">The catsters</a>, a YouTube channel about category theory.</li>
<li></li>
<li><a href="http://categorieslogicphysics.wikidot.com/events">Video archive</a> of recorded talks relevant to categories, logic and the foundations of physics.</li>
<li><a href="http://www.j-paine.org/cgi-bin/webcats/webcats.php">Interactive Web page</a> which generates examples of categorical constructions in the category of finite sets.</li>
</ul>

<p><a class="uri" href="de:Kategorientheorie#Funktor" title="wikilink">de:Kategorientheorie#Funktor</a>"</p>

<p><a href="Category:Functors" title="wikilink"> </a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2">Carnap, The Logical Syntax of Language, p. 13–14, 1937, Routledge &amp; Kegan Paul<a href="#fnref2">↩</a></li>
<li id="fn3">Jacobson (2009), p. 19, def. 1.2.<a href="#fnref3">↩</a></li>
<li id="fn4">Jacobson (2009), p. 19–20.<a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7">Jacobson (2009), p. 20, ex. 2.<a href="#fnref7">↩</a></li>
</ol>
</section>
</body>
</html>
