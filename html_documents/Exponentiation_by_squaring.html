<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="365">Exponentiation by squaring</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Exponentiation by squaring</h1>
<style>
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
<style>
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
</body></html>
<body>
<hr/>

<p>In <a class="uri" href="mathematics" title="wikilink">mathematics</a> and <a href="computer_programming" title="wikilink">computer programming</a>, <strong>exponentiating by squaring</strong> is a general method for fast computation of large <a href="positive_integer" title="wikilink">positive integer</a> powers of a <a class="uri" href="number" title="wikilink">number</a>, or more generally of an element of a <a class="uri" href="semigroup" title="wikilink">semigroup</a>, like a <a class="uri" href="polynomial" title="wikilink">polynomial</a> or a <a href="square_matrix" title="wikilink">square matrix</a>. Some variants are commonly referred to as <strong>square-and-multiply</strong> algorithms or <strong>binary exponentiation</strong>. These can be of quite general use, for example in <a href="modular_arithmetic" title="wikilink">modular arithmetic</a> or powering of matrices. For semigroups for which <a href="Abelian_group#Notation" title="wikilink">additive notation</a> is commonly used, like <a href="elliptic_curve" title="wikilink">elliptic curves</a> used in <a class="uri" href="cryptography" title="wikilink">cryptography</a>, this method is also referred to as <strong>double-and-add</strong>.</p>
<h2 id="basic-method">Basic method</h2>

<p>The method is based on the observation that, for a positive integer <em>n</em>, we have</p>

<p>

<math display="block" id="Exponentiation_by_squaring:0">
 <semantics>
  <mrow>
   <msup>
    <mi>x</mi>
    <mi>n</mi>
   </msup>
   <mo>=</mo>
   <mrow>
    <mo>{</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mpadded width="+1.7pt">
          <mi>x</mi>
         </mpadded>
         <msup>
          <mrow>
           <mo stretchy="false">(</mo>
           <msup>
            <mi>x</mi>
            <mn>2</mn>
           </msup>
           <mo stretchy="false">)</mo>
          </mrow>
          <mfrac>
           <mrow>
            <mi>n</mi>
            <mo>-</mo>
            <mn>1</mn>
           </mrow>
           <mn>2</mn>
          </mfrac>
         </msup>
        </mrow>
        <mo>,</mo>
       </mrow>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mtext>if</mtext>
        <mi>n</mi>
        <mtext>is odd</mtext>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="left">
       <mrow>
        <msup>
         <mrow>
          <mo stretchy="false">(</mo>
          <msup>
           <mi>x</mi>
           <mn>2</mn>
          </msup>
          <mo stretchy="false">)</mo>
         </mrow>
         <mfrac>
          <mi>n</mi>
          <mn>2</mn>
         </mfrac>
        </msup>
        <mo>,</mo>
       </mrow>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mtext>if</mtext>
         <mi>n</mi>
         <mtext>is even</mtext>
        </mrow>
        <mo>.</mo>
       </mrow>
      </mtd>
     </mtr>
    </mtable>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">cases</csymbol>
     <apply>
      <times></times>
      <ci>x</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>x</ci>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <divide></divide>
        <apply>
         <minus></minus>
         <ci>n</ci>
         <cn type="integer">1</cn>
        </apply>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <mtext>if</mtext>
      <ci>n</ci>
      <mtext>is odd</mtext>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <divide></divide>
       <ci>n</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <mtext>if</mtext>
      <ci>n</ci>
      <mtext>is even</mtext>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{n}=\begin{cases}x\,(x^{2})^{\frac{n-1}{2}},&\mbox{if }n\mbox{ is odd}\\
(x^{2})^{\frac{n}{2}},&\mbox{if }n\mbox{ is even}.\end{cases}
  </annotation>
 </semantics>
</math>

</p>

<p>This may be easily implemented as the following <a href="recursion_(computer_science)" title="wikilink">recursive algorithm</a>:</p>
<div class="sourceCode"><pre class="sourceCode pascal"><code class="sourceCode pascal">  <span class="kw">Function</span> exp-by-squaring(x, n )
    <span class="kw">if</span> n &lt; <span class="dv">0</span>  <span class="kw">then</span> return exp-by-squaring(<span class="dv">1</span> / x, - n );
    <span class="kw">else</span> <span class="kw">if</span> n = <span class="dv">0</span>  <span class="kw">then</span> return  <span class="dv">1</span>;
    <span class="kw">else</span> <span class="kw">if</span> n = <span class="dv">1</span>  <span class="kw">then</span> return  x ;
    <span class="kw">else</span> <span class="kw">if</span> n <span class="kw">is</span> even  <span class="kw">then</span> return exp-by-squaring(x * x,  n / <span class="dv">2</span>);
    <span class="kw">else</span> <span class="kw">if</span> n <span class="kw">is</span> odd  <span class="kw">then</span> return x * exp-by-squaring(x * x, (n - <span class="dv">1</span>) / <span class="dv">2</span>).</code></pre></div>

<p>Although not <a href="Tail_call" title="wikilink">tail-recursive</a>, this algorithm may be rewritten into a tail recursive algorithm by introducing an auxiliary function:</p>
<div class="sourceCode"><pre class="sourceCode pascal"><code class="sourceCode pascal">  <span class="kw">Function</span> exp-by-squaring(x, n)
    exp-by-squaring2(<span class="dv">1</span>, x, n)
  <span class="kw">Function</span> exp-by-squaring2(y, x, n)
    <span class="kw">if</span> n &lt; <span class="dv">0</span>  <span class="kw">then</span> return exp-by-squaring2(y, <span class="dv">1</span> / x, - n);
    <span class="kw">else</span> <span class="kw">if</span> n = <span class="dv">0</span>  <span class="kw">then</span> return  y;
    <span class="kw">else</span> <span class="kw">if</span> n = <span class="dv">1</span>  <span class="kw">then</span> return  x * y;
    <span class="kw">else</span> <span class="kw">if</span> n <span class="kw">is</span> even  <span class="kw">then</span> return exp-by-squaring2(y, x * x,  n / <span class="dv">2</span>);
    <span class="kw">else</span> <span class="kw">if</span> n <span class="kw">is</span> odd  <span class="kw">then</span> return exp-by-squaring2(x * y, x * x, (n - <span class="dv">1</span>) / <span class="dv">2</span>).</code></pre></div>

<p>The iterative version of the algorithm also uses a bounded auxiliary space, and is given by</p>
<div class="sourceCode"><pre class="sourceCode pascal"><code class="sourceCode pascal">  <span class="kw">Function</span> exp-by-squaring-iterative(x, n)
    <span class="kw">if</span> n &lt; <span class="dv">0</span> <span class="kw">then</span>
      x := <span class="dv">1</span> / x;
      n := -n;
    <span class="kw">if</span> n = <span class="dv">0</span> <span class="kw">then</span> return <span class="dv">1</span>
    y := <span class="dv">1</span>;
    <span class="kw">while</span> n &gt; <span class="dv">1</span> <span class="kw">do</span>
      <span class="kw">if</span> n <span class="kw">is</span> even <span class="kw">then</span> 
        x := x * x;
        n := n / <span class="dv">2</span>;
      <span class="kw">else</span>
        y := x * y
        x := x * x;
        n := (n – <span class="dv">1</span>) / <span class="dv">2</span>;
    return x * y</code></pre></div>
<h2 id="computational-complexity">Computational complexity</h2>

<p>A brief analysis shows that such an algorithm uses 

<math display="inline" id="Exponentiation_by_squaring:1">
 <semantics>
  <mrow>
   <mo stretchy="false">⌊</mo>
   <mrow>
    <msub>
     <mi>log</mi>
     <mn>2</mn>
    </msub>
    <mi>n</mi>
   </mrow>
   <mo stretchy="false">⌋</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <floor></floor>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <log></log>
      <cn type="integer">2</cn>
     </apply>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lfloor\log_{2}n\rfloor
  </annotation>
 </semantics>
</math>

 squarings and at most 

<math display="inline" id="Exponentiation_by_squaring:2">
 <semantics>
  <mrow>
   <mo stretchy="false">⌊</mo>
   <mrow>
    <msub>
     <mi>log</mi>
     <mn>2</mn>
    </msub>
    <mi>n</mi>
   </mrow>
   <mo stretchy="false">⌋</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <floor></floor>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <log></log>
      <cn type="integer">2</cn>
     </apply>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lfloor\log_{2}n\rfloor
  </annotation>
 </semantics>
</math>

 multiplications, where 

<math display="inline" id="Exponentiation_by_squaring:3">
 <semantics>
  <mrow>
   <mo rspace="5.3pt" stretchy="false">⌊</mo>
   <mo stretchy="false">⌋</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list></list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lfloor\;\rfloor
  </annotation>
 </semantics>
</math>

 denotes the <a href="floor_function" title="wikilink">floor function</a>. More precisely, the number of multiplications is one less than the number of 1 in the <a href="binary_expansion" title="wikilink">binary expansion</a> of <em>n</em>. For <em>n</em> greater than about 4 this is computationally more efficient than naively multiplying the base with itself repeatedly.</p>

<p>Each squaring results in approximately double the number of digits of the previous, and so, if multiplication of two <em>d</em> digit numbers is implemented in O(<em>d</em><sup><em>k</em></sup>) operations for some fixed <em>k</em> then the complexity of computing <em>x</em><sup><em>n</em></sup> is given by:</p>

<p>

<math display="block" id="Exponentiation_by_squaring:4">
 <semantics>
  <mrow>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>0</mn>
     </mrow>
     <mrow>
      <mi>O</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>log</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>n</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </munderover>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msup>
        <mn>2</mn>
        <mi>i</mi>
       </msup>
       <mi>O</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>log</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>x</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>k</mi>
    </msup>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>O</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>n</mi>
        <mrow>
         <mi>log</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>x</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>k</mi>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>O</ci>
       <apply>
        <log></log>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <cn type="integer">2</cn>
        <ci>i</ci>
       </apply>
       <ci>O</ci>
       <apply>
        <log></log>
        <ci>x</ci>
       </apply>
      </apply>
      <ci>k</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>O</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <times></times>
       <ci>n</ci>
       <apply>
        <log></log>
        <ci>x</ci>
       </apply>
      </apply>
      <ci>k</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum\limits_{i=0}^{O(\log(n))}(2^{i}O(\log(x)))^{k}=O((n\log(x))^{k})
  </annotation>
 </semantics>
</math>

</p>
<h2 id="k-ary-method">2<sup>k</sup>-ary method</h2>

<p>This algorithm calculates the value of x<sup>n</sup> after expanding the exponent in base 2<sup>k</sup>. It was first proposed by <a class="uri" href="Brauer" title="wikilink">Brauer</a> in 1939. In the algorithm below we make use of the following function f(0) = (k,0) and f(m) = (s,u) where m = u·2<sup>s</sup> with <em>u</em> odd.</p>

<p>Algorithm:</p>
<dl>
<dt>Input: An element x of G, a parameter k &gt; 0, a non-negative integer <mtpl></mtpl> and the precomputed values 

<math display="inline" id="Exponentiation_by_squaring:5">
 <semantics>
  <mrow>
   <msup>
    <mi>x</mi>
    <mn>3</mn>
   </msup>
   <mo>,</mo>
   <msup>
    <mi>x</mi>
    <mn>5</mn>
   </msup>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msup>
    <mi>x</mi>
    <mrow>
     <msup>
      <mn>2</mn>
      <mi>k</mi>
     </msup>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <cn type="integer">3</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <cn type="integer">5</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">2</cn>
       <ci>k</ci>
      </apply>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{3},x^{5},...,x^{2^{k}-1}
  </annotation>
 </semantics>
</math>

.</dt>
</dl>
<dl>
<dt>Output: The element x<sup>n</sup> in <em>G</em></dt>
</dl>

<p><code> 1. y := 1; i := l-1</code><br/>
<code> 2. </code><strong><code>while</code></strong><code> i&gt;=0 do</code><br/>
<code> 3.    (s,u) := f(n</code><sub><code>i</code></sub><code>)</code><br/>
<code> 4.    </code><strong><code>for</code></strong><code> j:=1 </code><strong><code>to</code></strong><code> k-s </code><strong><code>do</code></strong><br/>
<code> 5.        y := y</code><sup><code>2</code></sup><code> </code><br/>
<code> 6.    y := y*x</code><sup><code>u</code></sup><br/>
<code> 7.    </code><strong><code>for</code></strong><code> j:=1 </code><strong><code>to</code></strong><code> s </code><strong><code>do</code></strong><br/>
<code> 8.        y := y</code><sup><code>2</code></sup><br/>
<code> 9.    i := i-1</code><br/>
<code>10. </code><strong><code>return</code></strong><code> y</code></p>

<p>For optimal efficiency, <em>k</em> should be the smallest integer satisfying <a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>

<p>

<math display="block" id="Exponentiation_by_squaring:6">
 <semantics>
  <mrow>
   <mrow>
    <mi>log</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo><</mo>
   <mrow>
    <mfrac>
     <mrow>
      <mrow>
       <mi>k</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>k</mi>
         <mo>+</mo>
         <mn>1</mn>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>⋅</mo>
      <msup>
       <mn>2</mn>
       <mrow>
        <mn>2</mn>
        <mi>k</mi>
       </mrow>
      </msup>
     </mrow>
     <mrow>
      <msup>
       <mn>2</mn>
       <mrow>
        <mi>k</mi>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
      </msup>
      <mo>-</mo>
      <mi>k</mi>
      <mo>-</mo>
      <mn>2</mn>
     </mrow>
    </mfrac>
    <mo>+</mo>
    <mn>1.</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <log></log>
     <ci>n</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <divide></divide>
      <apply>
       <ci>normal-⋅</ci>
       <apply>
        <times></times>
        <ci>k</ci>
        <apply>
         <plus></plus>
         <ci>k</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <cn type="integer">2</cn>
        <apply>
         <times></times>
         <cn type="integer">2</cn>
         <ci>k</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <cn type="integer">2</cn>
        <apply>
         <plus></plus>
         <ci>k</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>k</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <cn type="float">1.</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \log(n)<\frac{k(k+1)\cdot 2^{2k}}{2^{k+1}-k-2}+1.
  </annotation>
 </semantics>
</math>

</p>
<h2 id="sliding-window-method">Sliding window method</h2>

<p>This method is an efficient variant of the 2<sup>k</sup>-ary method. For example, to calculate the exponent 398 which has binary expansion (110 001 110)<sub>2</sub>, we take a window of length 3 using the 2<sup>k</sup>-ary method algorithm we calculate 1,x<sup>3</sup>,x<sup>6</sup>,x<sup>12</sup>,x<sup>24</sup>,x<sup>48</sup>,x<sup>49</sup>,x<sup>98</sup>,x<sup>99</sup>,x<sup>198</sup>,x<sup>199</sup>,x<sup>398</sup>. But, we can also compute 1,x<sup>3</sup>,x<sup>6</sup>,x<sup>12</sup>,x<sup>24</sup>,x<sup>48</sup>,x<sup>96</sup>,x<sup>192</sup>,x<sup>199</sup>, x<sup>398</sup> which saves one multiplication and amounts to evaluating (110 001 110)n<sub>2</sub></p>

<p>Here is the general algorithm:</p>

<p>Algorithm:</p>
<dl>
<dt>Input:An element <em>x</em> of <em>G</em>,a non negative integer <mtpl></mtpl>, a parameter k&gt;0 and the pre-computed values 

<math display="inline" id="Exponentiation_by_squaring:7">
 <semantics>
  <mrow>
   <msup>
    <mi>x</mi>
    <mn>3</mn>
   </msup>
   <mo>,</mo>
   <msup>
    <mi>x</mi>
    <mn>5</mn>
   </msup>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msup>
    <mi>x</mi>
    <mrow>
     <msup>
      <mn>2</mn>
      <mi>k</mi>
     </msup>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <cn type="integer">3</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <cn type="integer">5</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">2</cn>
       <ci>k</ci>
      </apply>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{3},x^{5},...,x^{2^{k}-1}
  </annotation>
 </semantics>
</math>

.</dt>
</dl>
<dl>
<dt>Output: The element <em>x<sup>n</sup></em> ∈ <em>G</em></dt>
</dl>

<p>Algorithm:</p>

<p><code>1.  y := 1; i := l-1</code><br/>
<code>2.  </code><strong><code>while</code></strong><code> i &gt; -1 </code><strong><code>do</code></strong><br/>
<code>3.      </code><strong><code>if</code></strong><code> n</code><sub><code>i</code></sub><code>=0 </code><strong><code>then</code></strong><code> y:=y</code><sup><code>2</code></sup><code>' i:=i-1</code><br/>
<code>4.      </code><strong><code>else</code></strong><br/>
<code>5.          s:=max{i-k+1,0}</code><br/>
<code>6.          </code><strong><code>while</code></strong><code> n</code><sub><code>s</code></sub><code>=0 </code><strong><code>do</code></strong><code> s:=s+1 </code><a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a><br/>
<code>7.          </code><strong><code>for</code></strong><code> h:=1 </code><strong><code>to</code></strong><code> i-s+1 </code><strong><code>do</code></strong><code> y:=y</code><sup><code>2</code></sup><br/>
<code>8.          u:=(n</code><sub><code>i</code></sub><code>,n</code><sub><code>i-1</code></sub><code>,....,n</code><sub><code>s</code></sub><code>)</code><sub><code>2</code></sub><br/>
<code>9.          y:=y*x</code><sup><code>u</code></sup><br/>
<code>10.         i:=s-1</code><br/>
<code>11. </code><strong><code>return</code></strong><code> y</code></p>
<h2 id="montgomerys-ladder-technique">Montgomery's ladder technique</h2>

<p>Many algorithms for exponentiation do not provide defence against <a href="side-channel_attack" title="wikilink">side-channel attacks</a>. Namely, an attacker observing the sequence of squarings and multiplications can (partially) recover the exponent involved in the computation. This is a problem if the exponent should remain secret, as with many <a href="Public-key_cryptography" title="wikilink">public-key cryptosystems</a>. A technique called <a href="Peter_Montgomery_(mathematician)" title="wikilink">Montgomery's</a> Ladder<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> addresses this concern.</p>

<p>Given the <a href="binary_expansion" title="wikilink">binary expansion</a> of a positive, non-zero integer n=(n<sub>k-1</sub>...n<sub>0</sub>)<sub>2</sub> with n<sub>k-1</sub>=1 we can compute x<sup>n</sup> as follows:</p>

<p><code>x</code><sub><code>1</code></sub><code>=x; x</code><sub><code>2</code></sub><code>=x</code><sup><code>2</code></sup><br/>
<code>for i=k-2 to 0 do</code><br/>
<code>  If n</code><sub><code>i</code></sub><code>=0 then</code><br/>
<code>    x</code><sub><code>2</code></sub><code>=x</code><sub><code>1</code></sub><code>*x</code><sub><code>2</code></sub><code>; x</code><sub><code>1</code></sub><code>=x</code><sub><code>1</code></sub><sup><code>2</code></sup><br/>
<code>  else</code><br/>
<code>    x</code><sub><code>1</code></sub><code>=x</code><sub><code>1</code></sub><code>*x</code><sub><code>2</code></sub><code>; x</code><sub><code>2</code></sub><code>=x</code><sub><code>2</code></sub><sup><code>2</code></sup><br/>
<code>return x</code><sub><code>1</code></sub></p>

<p>The algorithm performs a fixed sequence of operations (<a href="up_to" title="wikilink">up to</a> log n): a multiplication and squaring takes place for each bit in the exponent, regardless of the bit's specific value.</p>

<p>This specific implementation of Montgomery's ladder is not yet protected against cache <a href="timing_attack" title="wikilink">timing attacks</a>: memory access latencies might still be observable to an attacker as you access different variables depending on the value of bits of the secret exponent.</p>
<h2 id="fixed-base-exponent">Fixed base exponent</h2>

<p>There are several methods which can be employed to calculate x<sup>n</sup> when the base is fixed and the exponent varies. As one can see, <a href="precomputation" title="wikilink">precomputations</a> play a key role in these algorithms.</p>
<h3 id="yaos-method">Yao's method</h3>

<p>Yao's method is orthogonal to the 2<sup>k</sup>-ary method where the exponent is expanded in radix b=2<sup>k</sup> and the computation is as performed in the algorithm above. Let "n", "n<sub>i</sub>", "b", and "b<sub>i</sub>" be integers.</p>

<p>Let the exponent "n" be written as</p>

<p>

<math display="block" id="Exponentiation_by_squaring:8">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>=</mo>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>0</mn>
     </mrow>
     <mrow>
      <mi>w</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </munderover>
    <mrow>
     <msub>
      <mi>n</mi>
      <mi>i</mi>
     </msub>
     <msub>
      <mi>b</mi>
      <mi>i</mi>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>n</ci>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <apply>
       <minus></minus>
       <ci>w</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>n</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n=\sum_{i=0}^{w-1}n_{i}b_{i}
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Exponentiation_by_squaring:9">
 <semantics>
  <mrow>
   <mn>0</mn>
   <mo>⩽</mo>
   <msub>
    <mi>n</mi>
    <mi>i</mi>
   </msub>
   <mo><</mo>
   <mi>h</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <cn type="integer">0</cn>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>n</ci>
      <ci>i</ci>
     </apply>
    </apply>
    <apply>
     <lt></lt>
     <share href="#.cmml">
     </share>
     <ci>h</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0\leqslant n_{i}<h
  </annotation>
 </semantics>
</math>

 for all 

<math display="inline" id="Exponentiation_by_squaring:10">
 <semantics>
  <mrow>
   <mi>i</mi>
   <mo>∈</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mrow>
     <mi>w</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>i</ci>
    <interval closure="closed">
     <cn type="integer">0</cn>
     <apply>
      <minus></minus>
      <ci>w</ci>
      <cn type="integer">1</cn>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i\in[0,w-1]
  </annotation>
 </semantics>
</math>

</p>

<p>Let x<sub>i</sub> = x<sup>b<sub>i</sub></sup>. Then the algorithm uses the equality</p>

<p>

<math display="block" id="Exponentiation_by_squaring:11">
 <semantics>
  <mrow>
   <msup>
    <mi>x</mi>
    <mi>n</mi>
   </msup>
   <mo>=</mo>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∏</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>0</mn>
     </mrow>
     <mrow>
      <mi>w</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </munderover>
    <mmultiscripts>
     <mi>x</mi>
     <mi>i</mi>
     <none></none>
     <none></none>
     <msub>
      <mi>n</mi>
      <mi>i</mi>
     </msub>
    </mmultiscripts>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∏</mo>
     <mrow>
      <mi>j</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mrow>
      <mi>h</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </munderover>
    <msup>
     <mrow>
      <mo maxsize="210%" minsize="210%">[</mo>
      <mrow>
       <munder>
        <mo largeop="true" movablelimits="false" symmetric="true">∏</mo>
        <mrow>
         <msub>
          <mi>n</mi>
          <mi>i</mi>
         </msub>
         <mo>=</mo>
         <mi>j</mi>
        </mrow>
       </munder>
       <msub>
        <mi>x</mi>
        <mi>i</mi>
       </msub>
      </mrow>
      <mo maxsize="210%" minsize="210%">]</mo>
     </mrow>
     <mi>j</mi>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <csymbol cd="latexml">product</csymbol>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">0</cn>
        </apply>
       </apply>
       <apply>
        <minus></minus>
        <ci>w</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>n</ci>
        <ci>i</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <csymbol cd="latexml">product</csymbol>
        <apply>
         <eq></eq>
         <ci>j</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <minus></minus>
        <ci>h</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <csymbol cd="latexml">product</csymbol>
          <apply>
           <eq></eq>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>n</ci>
            <ci>i</ci>
           </apply>
           <ci>j</ci>
          </apply>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <ci>i</ci>
         </apply>
        </apply>
       </apply>
       <ci>j</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{n}=\prod_{i=0}^{w-1}{x_{i}}^{n_{i}}=\prod_{j=1}^{h-1}{\bigg[\prod_{n_{i}=j}%
x_{i}\bigg]}^{j}
  </annotation>
 </semantics>
</math>

</p>

<p>Given the element 'x' of G, and the exponent 'n' written in the above form, along with the precomputed values x<sup>b<sub>0</sub></sup>....x<sup>b<sub>w-1</sub></sup> the element x<sup>n</sup> is calculated using the algorithm below.</p>

<p><code>
#y=1,u=1 and j=h-1
#while j &gt; 0 do
##for i=0 to w-1 do
###if n<sub>i</sub>=j then u=u*x<sup>b<sub>i</sub></sup>
##y=y*u
##j=j-1
#return y
</code> If we set h=2<sup>k</sup> and b<sub>i</sub> = h<sup>i</sup> then the n<sub>i</sub> 's are simply the digits of n in base h. Yao's method collects in u first those x<sub>i</sub> which appear to the highest power h-1; in the next round those with power h-2 are collected in u as well etc. The variable y is multiplied h-1 times with the initial u, h-2 times with the next highest powers etc. The algorithm uses w+h-2 multiplications and w+1 elements must be stored to compute x<sup>n</sup> (see <a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a>).</p>
<h3 id="euclidean-method">Euclidean method</h3>

<p>The Euclidean method was first introduced in <em>Efficient exponentiation using precomputation and vector addition chains</em> by P.D Rooij.</p>

<p>This method for computing 

<math display="inline" id="Exponentiation_by_squaring:12">
 <semantics>
  <msup>
   <mi>x</mi>
   <mi>n</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>x</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{n}
  </annotation>
 </semantics>
</math>

 in group 

<math display="inline" id="Exponentiation_by_squaring:13">
 <semantics>
  <mi>𝐆</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐆</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{G}
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Exponentiation_by_squaring:14">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 is a natural integer, whose algorithm is given below, is using the following equality recursively:</p>

<p>

<math display="block" id="Exponentiation_by_squaring:15">
 <semantics>
  <mrow>
   <mrow>
    <mmultiscripts>
     <mi>x</mi>
     <mn>0</mn>
     <none></none>
     <none></none>
     <msub>
      <mi>n</mi>
      <mn>0</mn>
     </msub>
    </mmultiscripts>
    <mo>⋅</mo>
    <mmultiscripts>
     <mi>x</mi>
     <mn>1</mn>
     <none></none>
     <none></none>
     <msub>
      <mi>n</mi>
      <mn>1</mn>
     </msub>
    </mmultiscripts>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msup>
     <mrow>
      <mo>(</mo>
      <mrow>
       <msub>
        <mi>x</mi>
        <mn>0</mn>
       </msub>
       <mo>⋅</mo>
       <mmultiscripts>
        <mi>x</mi>
        <mn>1</mn>
        <none></none>
        <none></none>
        <mi>q</mi>
       </mmultiscripts>
      </mrow>
      <mo>)</mo>
     </mrow>
     <msub>
      <mi>n</mi>
      <mn>0</mn>
     </msub>
    </msup>
    <mo>⋅</mo>
    <mmultiscripts>
     <mi>x</mi>
     <mn>1</mn>
     <none></none>
     <none></none>
     <mrow>
      <msub>
       <mi>n</mi>
       <mn>1</mn>
      </msub>
      <mo lspace="2.5pt" rspace="2.5pt">mod</mo>
      <msub>
       <mi>n</mi>
       <mn>0</mn>
      </msub>
     </mrow>
    </mmultiscripts>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>normal-⋅</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">0</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>n</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <ci>normal-⋅</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <ci>normal-⋅</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <cn type="integer">0</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <cn type="integer">1</cn>
        </apply>
        <ci>q</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>n</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="latexml">modulo</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>n</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {x_{0}}^{n_{0}}\cdot{x_{1}}^{n_{1}}={\left(x_{0}\cdot{x_{1}}^{q}\right)}^{n_{0%
}}\cdot{x_{1}}^{n_{1}\mod{n_{0}}}
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Exponentiation_by_squaring:16">
 <semantics>
  <mrow>
   <mi>q</mi>
   <mo>=</mo>
   <mrow>
    <mo>⌊</mo>
    <mrow>
     <msub>
      <mi>n</mi>
      <mn>1</mn>
     </msub>
     <mo>/</mo>
     <msub>
      <mi>n</mi>
      <mn>0</mn>
     </msub>
    </mrow>
    <mo>⌋</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>q</ci>
    <apply>
     <floor></floor>
     <apply>
      <divide></divide>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>n</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q=\left\lfloor{n_{1}}/{n_{0}}\right\rfloor
  </annotation>
 </semantics>
</math>

</p>
<dl>
<dd>(in other words a Euclidean division of the exponent <mtpl></mtpl> by <mtpl></mtpl> is used to return a quotient 

<math display="inline" id="Exponentiation_by_squaring:17">
 <semantics>
  <mi>q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q
  </annotation>
 </semantics>
</math>

 and a rest 

<math display="inline" id="Exponentiation_by_squaring:18">
 <semantics>
  <mrow>
   <msub>
    <mi>n</mi>
    <mn>1</mn>
   </msub>
   <mo lspace="2.5pt" rspace="2.5pt">mod</mo>
   <msub>
    <mi>n</mi>
    <mn>0</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">modulo</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>n</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>n</ci>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n_{1}\mod n_{0}
  </annotation>
 </semantics>
</math>

).
</dd>
</dl>

<p>Given the base element 

<math display="inline" id="Exponentiation_by_squaring:19">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 in group 

<math display="inline" id="Exponentiation_by_squaring:20">
 <semantics>
  <mi>𝐆</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐆</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{G}
  </annotation>
 </semantics>
</math>

, and the exponent 

<math display="inline" id="Exponentiation_by_squaring:21">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 written as in Yao's method, the element 

<math display="inline" id="Exponentiation_by_squaring:22">
 <semantics>
  <msup>
   <mi>x</mi>
   <mi>n</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>x</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{n}
  </annotation>
 </semantics>
</math>

 is calculated using 

<math display="inline" id="Exponentiation_by_squaring:23">
 <semantics>
  <mi>l</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>l</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   l
  </annotation>
 </semantics>
</math>

 precomputed values 

<math display="inline" id="Exponentiation_by_squaring:24">
 <semantics>
  <mrow>
   <msup>
    <mi>x</mi>
    <msub>
     <mi>b</mi>
     <mn>0</mn>
    </msub>
   </msup>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msup>
    <mi>x</mi>
    <msub>
     <mi>b</mi>
     <msub>
      <mi>l</mi>
      <mi>i</mi>
     </msub>
    </msub>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>b</ci>
      <cn type="integer">0</cn>
     </apply>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>b</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>l</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{b_{0}},...,x^{b_{l_{i}}}
  </annotation>
 </semantics>
</math>

 and then the algorithm below.</p>

<p><code>    </code><strong><code>Begin</code> <code>loop</code></strong><code>   </code><br/>
<code>        Find </code>

<math display="inline" id="Exponentiation_by_squaring:25">
 <semantics>
  <mrow>
   <mi>M</mi>
   <mo>∈</mo>
   <mrow>
    <mo>[</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mrow>
     <mi>l</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
    <mo>]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>M</ci>
    <interval closure="closed">
     <cn type="integer">0</cn>
     <apply>
      <minus></minus>
      <ci>l</ci>
      <cn type="integer">1</cn>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M\in\left[0,l-1\right]
  </annotation>
 </semantics>
</math>

<code>, such that </code>

<math display="inline" id="Exponentiation_by_squaring:26">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>∀</mo>
     <mi>i</mi>
    </mrow>
    <mo>∈</mo>
    <mrow>
     <mo>[</mo>
     <mn>0</mn>
     <mo>,</mo>
     <mrow>
      <mi>l</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
     <mo>]</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mrow>
    <msub>
     <mi>n</mi>
     <mi>M</mi>
    </msub>
    <mo>≥</mo>
    <msub>
     <mi>n</mi>
     <mi>i</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <in></in>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <ci>i</ci>
     </apply>
     <interval closure="closed">
      <cn type="integer">0</cn>
      <apply>
       <minus></minus>
       <ci>l</ci>
       <cn type="integer">1</cn>
      </apply>
     </interval>
    </apply>
    <apply>
     <geq></geq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>n</ci>
      <ci>M</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>n</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall i\in\left[0,l-1\right],{n_{M}}\geq{n_{i}}
  </annotation>
 </semantics>
</math>

<code>;</code><br/>
<code>        Find </code>

<math display="inline" id="Exponentiation_by_squaring:27">
 <semantics>
  <mrow>
   <mi>N</mi>
   <mo>∈</mo>
   <mrow>
    <mo>(</mo>
    <mrow>
     <mrow>
      <mo>[</mo>
      <mn>0</mn>
      <mo>,</mo>
      <mrow>
       <mi>l</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
      <mo>]</mo>
     </mrow>
     <mo>-</mo>
     <mi>M</mi>
    </mrow>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>N</ci>
    <apply>
     <minus></minus>
     <interval closure="closed">
      <cn type="integer">0</cn>
      <apply>
       <minus></minus>
       <ci>l</ci>
       <cn type="integer">1</cn>
      </apply>
     </interval>
     <ci>M</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N\in\left(\left[0,l-1\right]-M\right)
  </annotation>
 </semantics>
</math>

<code>, such that </code>

<math display="inline" id="Exponentiation_by_squaring:28">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>∀</mo>
     <mi>i</mi>
    </mrow>
    <mo>∈</mo>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mrow>
       <mo>[</mo>
       <mn>0</mn>
       <mo>,</mo>
       <mrow>
        <mi>l</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
       <mo>]</mo>
      </mrow>
      <mo>-</mo>
      <mi>M</mi>
     </mrow>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mrow>
    <msub>
     <mi>n</mi>
     <mi>N</mi>
    </msub>
    <mo>≥</mo>
    <msub>
     <mi>n</mi>
     <mi>i</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <in></in>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <ci>i</ci>
     </apply>
     <apply>
      <minus></minus>
      <interval closure="closed">
       <cn type="integer">0</cn>
       <apply>
        <minus></minus>
        <ci>l</ci>
        <cn type="integer">1</cn>
       </apply>
      </interval>
      <ci>M</ci>
     </apply>
    </apply>
    <apply>
     <geq></geq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>n</ci>
      <ci>N</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>n</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall i\in\left(\left[0,l-1\right]-M\right),{n_{N}}\geq{n_{i}}
  </annotation>
 </semantics>
</math>

<code>;</code><br/>
<code>        </code><strong><code>Break</code> <code>loop</code></strong><code> if </code>

<math display="inline" id="Exponentiation_by_squaring:29">
 <semantics>
  <mrow>
   <msub>
    <mi>n</mi>
    <mi>N</mi>
   </msub>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>n</ci>
     <ci>N</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {n_{N}}=0
  </annotation>
 </semantics>
</math>

<code>;</code><br/>
<code>        </code><strong><code>Let</code></strong><code> </code>

<math display="inline" id="Exponentiation_by_squaring:30">
 <semantics>
  <mrow>
   <mi>q</mi>
   <mo>=</mo>
   <mrow>
    <mo>⌊</mo>
    <mrow>
     <msub>
      <mi>n</mi>
      <mi>M</mi>
     </msub>
     <mo>/</mo>
     <msub>
      <mi>n</mi>
      <mi>N</mi>
     </msub>
    </mrow>
    <mo>⌋</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>q</ci>
    <apply>
     <floor></floor>
     <apply>
      <divide></divide>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>n</ci>
       <ci>M</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>n</ci>
       <ci>N</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q=\left\lfloor{n_{M}}/{n_{N}}\right\rfloor
  </annotation>
 </semantics>
</math>

<code>, and then </code><strong><code>let</code></strong><code> </code>

<math display="inline" id="Exponentiation_by_squaring:31">
 <semantics>
  <mrow>
   <msub>
    <mi>n</mi>
    <mi>N</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo>(</mo>
    <mrow>
     <msub>
      <mi>n</mi>
      <mi>M</mi>
     </msub>
     <mo lspace="2.5pt" rspace="2.5pt">mod</mo>
     <msub>
      <mi>n</mi>
      <mi>N</mi>
     </msub>
    </mrow>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>n</ci>
     <ci>N</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">modulo</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>n</ci>
      <ci>M</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>n</ci>
      <ci>N</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {n_{N}}=\left({n_{M}}\mod{n_{N}}\right)
  </annotation>
 </semantics>
</math>

<code>;</code><br/>
<code>        Compute recursively </code>

<math display="inline" id="Exponentiation_by_squaring:32">
 <semantics>
  <mmultiscripts>
   <mi>x</mi>
   <mi>M</mi>
   <none></none>
   <none></none>
   <mi>q</mi>
  </mmultiscripts>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>M</ci>
    </apply>
    <ci>q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {x_{M}}^{q}
  </annotation>
 </semantics>
</math>

<code>, and then </code><strong><code>let</code></strong><code> </code>

<math display="inline" id="Exponentiation_by_squaring:33">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mi>N</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>x</mi>
     <mi>N</mi>
    </msub>
    <mo>⋅</mo>
    <mmultiscripts>
     <mi>x</mi>
     <mi>M</mi>
     <none></none>
     <none></none>
     <mi>q</mi>
    </mmultiscripts>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>N</ci>
    </apply>
    <apply>
     <ci>normal-⋅</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>N</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>M</ci>
      </apply>
      <ci>q</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {x_{N}}={x_{N}}\cdot{x_{M}}^{q}
  </annotation>
 </semantics>
</math>

<code>;</code><br/>
<code>    </code><strong><code>End</code> <code>loop</code></strong><code>;</code><br/>
<code>    </code><strong><code>Return</code></strong><code> </code>

<math display="inline" id="Exponentiation_by_squaring:34">
 <semantics>
  <mrow>
   <msup>
    <mi>x</mi>
    <mi>n</mi>
   </msup>
   <mo>=</mo>
   <mmultiscripts>
    <mi>x</mi>
    <mi>M</mi>
    <none></none>
    <none></none>
    <msub>
     <mi>n</mi>
     <mi>M</mi>
    </msub>
   </mmultiscripts>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>M</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>n</ci>
      <ci>M</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{n}={x_{M}}^{n_{M}}
  </annotation>
 </semantics>
</math>

<code>.</code></p>

<p>The algorithm first finds the largest value amongst the <mtpl></mtpl> and then the supremum within the set of <mtpl> <em>n</em><sub><em>i</em></sub> \ <em>i</em> ≠ <em>M</em> {{)}}}}</mtpl>. Then it raises <mtpl></mtpl> to the power 

<math display="inline" id="Exponentiation_by_squaring:35">
 <semantics>
  <mi>q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q
  </annotation>
 </semantics>
</math>

, multiplies this value with <mtpl></mtpl>, and then assigns <mtpl></mtpl> the result of this computation and <mtpl></mtpl> the value <mtpl></mtpl> modulo <mtpl></mtpl>.</p>
<h2 id="further-applications">Further applications</h2>

<p>The same idea allows fast computation of large <a href="Modular_exponentiation" title="wikilink">exponents modulo</a> a number. Especially in <a class="uri" href="cryptography" title="wikilink">cryptography</a>, it is useful to compute powers in a <a href="Ring_(mathematics)" title="wikilink">ring</a> of <a href="modular_arithmetic" title="wikilink">integers modulo <em>q</em></a>. It can also be used to compute integer powers in a <a href="group_(mathematics)" title="wikilink">group</a>, using the rule</p>
<dl>
<dd>Power(<em>x</em>, −<em>n</em>) = (Power(<em>x</em>, <em>n</em>))<sup>−1</sup>.
</dd>
</dl>

<p>The method works in every <a class="uri" href="semigroup" title="wikilink">semigroup</a> and is often used to compute powers of <a href="matrix_(math)" title="wikilink">matrices</a>.</p>

<p>For example, the evaluation of</p>
<dl>
<dd>13789<sup>722341</sup> (mod 2345)
</dd>
</dl>

<p>would take a very long time and lots of storage space if the naïve method were used: compute 13789<sup>722341</sup> then take the <a class="uri" href="remainder" title="wikilink">remainder</a> when divided by 2345. Even using a more effective method will take a long time: square 13789, take the remainder when divided by 2345, multiply the <a class="uri" href="result" title="wikilink">result</a> by 13789, and so on. This will take less than 

<math display="inline" id="Exponentiation_by_squaring:36">
 <semantics>
  <mrow>
   <mrow>
    <mn>2</mn>
    <mrow>
     <msub>
      <mi>log</mi>
      <mn>2</mn>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>722340</mn>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mn>40</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <times></times>
     <cn type="integer">2</cn>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <log></log>
       <cn type="integer">2</cn>
      </apply>
      <cn type="integer">722340</cn>
     </apply>
    </apply>
    <cn type="integer">40</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2\log_{2}(722340)\leq 40
  </annotation>
 </semantics>
</math>

 modular multiplications.</p>

<p>Applying above <em>exp-by-squaring</em> algorithm, with "*" interpreted as <em>x</em>*<em>y</em> = <em>xy</em> mod 2345 (that is a multiplication followed by a division with remainder) leads to only 27 multiplications and divisions of integers which may all be stored in a single machine word.</p>
<h2 id="example-implementations">Example implementations</h2>
<h3 id="computation-by-powers-of-2">Computation by powers of 2</h3>

<p>This is a non-recursive implementation of the above algorithm in <a href="Ruby_(programming_language)" title="wikilink">Ruby</a>.</p>

<p>In most <a href="static_typing" title="wikilink">statically typed</a> languages, <code>result=1</code> must be replaced with code assigning an <a href="identity_matrix" title="wikilink">identity matrix</a> of the same size as <code>x</code> to <code>result</code> to get a matrix exponentiating algorithm. In Ruby, thanks to coercion, <code>result</code> is automatically upgraded to the appropriate type, so this function works with matrices as well as with integers and floats. Note that n=n-1 is redundant when n=n/2 implicitly rounds towards zero, as lower level languages would do. n[0] is the rightmost bit of the binary representation of n, so if it is 1, the number is odd, if it is zero, the number is even.</p>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span class="kw">def</span> power(x,n)
  result = <span class="dv">1</span>
  <span class="kw">while</span> n.nonzero?
    <span class="kw">if</span> n[<span class="dv">0</span>].nonzero?
      result *= x
      n -= <span class="dv">1</span>
    <span class="kw">end</span>
    x *= x
    n /= <span class="dv">2</span>
  <span class="kw">end</span>
  <span class="kw">return</span> result
<span class="kw">end</span></code></pre></div>
<h4 id="runtime-example-compute-310">Runtime example: compute 3<sup>10</sup></h4>

<p><code>parameter x =  3</code><br/>
<code>parameter n = 10</code><br/>
<code>result := 1</code><br/>
<br/>
<strong><code>Iteration</code> <code>1</code></strong><br/>
<code>  n = 10 -&gt; n is even</code><br/>
<code>  x := x</code><sup><code>2</code></sup><code> = 3</code><sup><code>2</code></sup><code> = 9</code><br/>
<code>  n := n / 2 = 5</code><br/>
<br/>
<strong><code>Iteration</code> <code>2</code></strong><br/>
<code>  n = 5 -&gt; n is odd</code><br/>
<code>      -&gt; result := result * x = 1 * x = 1 * 3</code><sup><code>2</code></sup><code> = 9</code><br/>
<code>         n := n - 1 = 4</code><br/>
<code>  x := x</code><sup><code>2</code></sup><code> = 9</code><sup><code>2</code></sup><code> = 3</code><sup><code>4</code></sup><code> = 81</code><br/>
<code>  n := n / 2 = 2</code><br/>
<br/>
<strong><code>Iteration</code> <code>3</code></strong><br/>
<code>  n = 2 -&gt; n is even</code><br/>
<code>  x := x</code><sup><code>2</code></sup><code> = 81</code><sup><code>2</code></sup><code> = 3</code><sup><code>8</code></sup><code> = 6561</code><br/>
<code>  n := n / 2 = 1</code><br/>
<br/>
<strong><code>Iteration</code> <code>4</code></strong><br/>
<code>  n = 1 -&gt; n is odd</code><br/>
<code>      -&gt; result := result * x = 3</code><sup><code>2</code></sup><code> * 3</code><sup><code>8</code></sup><code> = 3</code><sup><code>10</code></sup><code> = 9 * 6561 = 59049</code><br/>
<code>         n := n - 1 = 0</code><br/>
<br/>
<code>return result</code></p>
<h4 id="runtime-example-compute-310-1">Runtime example: compute 3<sup>10</sup></h4>

<p><code>result := 3</code><br/>
<code>bin := "1010"</code><br/>
<br/>
<strong><code>Iteration</code> <code>for</code> <code>digit</code> <code>2:</code></strong><br/>
<code>  result := result</code><sup><code>2</code></sup><code> = 3</code><sup><code>2</code></sup><code> = 9</code><br/>
<code>  1</code><strong><code>0</code></strong><code>10</code><sub><code>bin</code></sub><code> - Digit equals "0"</code><br/>
<br/>
<strong><code>Iteration</code> <code>for</code> <code>digit</code> <code>3:</code></strong><br/>
<code>  result := result</code><sup><code>2</code></sup><code> = (3</code><sup><code>2</code></sup><code>)</code><sup><code>2</code></sup><code> = 3</code><sup><code>4</code></sup><code>  = 81</code><br/>
<code>  10</code><strong><code>1</code></strong><code>0</code><sub><code>bin</code></sub><code> - Digit equals "1" --&gt; result := result*3 = (3</code><sup><code>2</code></sup><code>)</code><sup><code>2</code></sup><code>*3 = 3</code><sup><code>5</code></sup><code>  = 243</code><br/>
<br/>
<strong><code>Iteration</code> <code>for</code> <code>digit</code> <code>4:</code></strong><br/>
<code>  result := result</code><sup><code>2</code></sup><code> = ((3</code><sup><code>2</code></sup><code>)</code><sup><code>2</code></sup><code>*3)</code><sup><code>2</code></sup><code> = 3</code><sup><code>10</code></sup><code>  = 59049</code><br/>
<code>  101</code><strong><code>0</code></strong><sub><code>bin</code></sub><code> - Digit equals "0"</code><br/>
<br/>
<code>return result</code></p>

<p>JavaScript-Demonstration: <a class="uri" href="http://home.mnet-online.de/wzwz.de/temp/ebs/en.htm">http://home.mnet-online.de/wzwz.de/temp/ebs/en.htm</a></p>
<h3 id="calculation-of-products-of-powers">Calculation of products of powers</h3>

<p>Exponentiation by squaring may also be used to calculate the product of 2 or more powers. If the underlying group or semigroup is <a class="uri" href="commutative" title="wikilink">commutative</a> then it is often possible to reduce the number of multiplications by computing the product simultaneously.</p>
<h4 id="example">Example</h4>

<p>The formula a<sup>7</sup>×b<sup>5</sup> may be calculated within 3 steps:</p>
<dl>
<dd>((a)<span style="color:red;"><sup>2</sup>×</span>a)<span style="color:red;"><sup>2</sup>×</span>a (four multiplications for calculating a<sup>7</sup>)
</dd>
<dd>((b)<span style="color:red;"><sup>2</sup></span>)<span style="color:red;"><sup>2</sup>×</span>b (three multiplications for calculating b<sup>5</sup>)
</dd>
<dd>(a<sup>7</sup>)<span style="color:red;">×</span>(b<sup>5</sup>) (one multiplication to calculate the product of the two)
</dd>
</dl>

<p>so one gets eight multiplications in total.</p>

<p>A faster solution is to calculate both powers simultaneously:</p>
<dl>
<dd>((a<span style="color:red;">×</span>b)<span style="color:red;"><sup>2</sup>×</span>a)<span style="color:red;"><sup>2</sup>×</span>a<span style="color:red;">×</span>b
</dd>
</dl>

<p>which needs only 6 multiplications in total. Note that a×b is calculated twice, the result could be stored after the first calculation which reduces the count of multiplication to 5.</p>

<p>Example with numbers:</p>
<dl>
<dd>2<sup>7</sup>×3<sup>5</sup> = ((2×3)<sup>2</sup>×2)<sup>2</sup>×2×3 = (6<sup>2</sup>×2)<sup>2</sup>×6 = 72<sup>2</sup>×6 = 31,104
</dd>
</dl>

<p>Calculating the powers simultaneously instead of calculating them separately always reduces the count of multiplications if at least two of the exponents are greater than 1.</p>
<h4 id="using-transformation">Using transformation</h4>

<p>The example above a<sup>7</sup>×b<sup>5</sup> may also be calculated with only 5 multiplications if the expression is transformed before calculation:</p>

<p>a<sup>7</sup>×b<sup>5</sup> = a<sup>2</sup>×(ab)<sup>5</sup> with ab := a×b</p>
<dl>
<dd>

<p>ab := a<span style="color:red;">×</span>b (one multiplication)</p>
</dd>
<dd>

<p>a<sup>2</sup>×(ab)<sup>5</sup> = ((ab)<span style="color:red;"><sup>2</sup>×</span>a)<span style="color:red;"><sup>2</sup>×</span>ab (four multiplications)</p>
</dd>
</dl>

<p>Generalization of transformation shows the following scheme:<br/>
For calculating a<sup>A</sup>×b<sup>B</sup>×...×m<sup>M</sup>×n<sup>N</sup><br/>
1st: define ab := a×b, abc = ab×c, ...<br/>
2nd: calculate the transformed expression a<sup>A−B</sup>×ab<sup>B−C</sup>×...×abc..m<sup>M−N</sup>×abc..mn<sup>N</sup></p>

<p>Transformation before calculation often reduces the count of multiplications but in some cases it also increases the count (see the last one of the examples below), so it may be a good idea to check the count of multiplications before using the transformed expression for calculation.</p>
<h4 id="examples">Examples</h4>

<p>For the following expressions the count of multiplications is shown for calculating each power separately, calculating them simultaneously without transformation and calculating them simultaneously after transformation.</p>

<p>Example: a<sup>7</sup>×b<sup>5</sup>×c<sup>3</sup><br/>
separate: [((a)<span style="color:red;"><sup>2</sup>×</span>a)<span style="color:red;"><sup>2</sup>×</span>a] <span style="color:red;">×</span> [((b)<span style="color:red;"><sup>2</sup></span>)<span style="color:red;"><sup>2</sup>×</span>b] <span style="color:red;">×</span> [(c)<span style="color:red;"><sup>2</sup>×</span>c] ( <strong>11</strong> multiplications )<br/>
simultaneous: ((a<span style="color:red;">×</span>b)<span style="color:red;"><sup>2</sup>×</span>a<span style="color:red;">×</span>c)<span style="color:red;"><sup>2</sup>×</span>a<span style="color:red;">×</span>b<span style="color:red;">×</span>c ( <strong>8</strong> multiplications )<br/>
transformation: a := 2   ab := a<span style="color:red;">×</span>b   abc := ab<span style="color:red;">×</span>c ( 2 multiplications )<br/>
calculation after that: (a<span style="color:red;">×</span>ab<span style="color:red;">×</span>abc)<span style="color:red;"><sup>2</sup>×</span>abc ( 4 multiplications ⇒ <strong>6</strong> in total )</p>

<p>Example: a<sup>5</sup>×b<sup>5</sup>×c<sup>3</sup><br/>
separate: [((a)<span style="color:red;"><sup>2</sup></span>)<span style="color:red;"><sup>2</sup>×</span>a] <span style="color:red;">×</span> [((b)<span style="color:red;"><sup>2</sup></span>)<span style="color:red;"><sup>2</sup>×</span>b] <span style="color:red;">×</span> [(c)<span style="color:red;"><sup>2</sup>×</span>c] ( <strong>10</strong> multiplications )<br/>
simultaneous: ((a<span style="color:red;">×</span>b)<span style="color:red;"><sup>2</sup>×</span>c)<span style="color:red;"><sup>2</sup>×</span>a<span style="color:red;">×</span>b<span style="color:red;">×</span>c ( <strong>7</strong> multiplications )<br/>
transformation: a := 2   ab := a<span style="color:red;">×</span>b   abc := ab<span style="color:red;">×</span>c ( 2 multiplications )<br/>
calculation after that: (ab<span style="color:red;">×</span>abc)<span style="color:red;"><sup>2</sup>×</span>abc ( 3 multiplications ⇒ <strong>5</strong> in total )</p>

<p>Example: a<sup>7</sup>×b<sup>4</sup>×c<sup>1</sup><br/>
separate: [((a)<span style="color:red;"><sup>2</sup>×</span>a)<span style="color:red;"><sup>2</sup>×</span>a] <span style="color:red;">×</span> [((b)<span style="color:red;"><sup>2</sup></span>)<span style="color:red;"><sup>2</sup></span>] <span style="color:red;">×</span> [c] ( <strong>8</strong> multiplications )<br/>
simultaneous: ((a<span style="color:red;">×</span>b)<span style="color:red;"><sup>2</sup>×</span>a)<span style="color:red;"><sup>2</sup>×</span>a<span style="color:red;">×</span>c ( <strong>6</strong> multiplications )<br/>
transformation: a := 2   ab := a<span style="color:red;">×</span>b   abc := ab<span style="color:red;">×</span>c ( 2 multiplications )<br/>
calculation after that: (a<span style="color:red;">×</span>ab)<span style="color:red;"><sup>2</sup>×</span>a<span style="color:red;">×</span>ab<span style="color:red;">×</span>abc ( 5 multiplications ⇒ <strong>7</strong> in total )</p>
<h2 id="signed-digit-recoding">Signed-digit recoding</h2>

<p>In certain computations it may be more efficient to allow negative coefficients and hence use the inverse of the base, provided inversion in G is 'fast' or has been precomputed. For example, when computing x<sup>2<sup>k</sup>−1</sup> the binary method requires k−1 multiplications and k−1 squarings. However one could perform k squarings to get x<sup>2<sup>k</sup></sup> and then multiply by x<sup>−1</sup> to obtain x<sup>2<sup>k</sup>−1</sup>.</p>

<p>To this end we define the <a href="signed-digit_representation" title="wikilink">signed-digit representation</a> of an integer 

<math display="inline" id="Exponentiation_by_squaring:37">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 in radix 

<math display="inline" id="Exponentiation_by_squaring:38">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>

 as</p>

<p>

<math display="inline" id="Exponentiation_by_squaring:39">
 <semantics>
  <mrow>
   <msub>
    <mi>n</mi>
    <mi>i</mi>
   </msub>
   <mo>∈</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
    <mo>,</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mn>1</mn>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>n</ci>
     <ci>i</ci>
    </apply>
    <set>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
     <cn type="integer">0</cn>
     <cn type="integer">1</cn>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n_{i}\in\{-1,0,1\}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Exponentiation_by_squaring:40">
 <semantics>
  <msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msub>
      <mi>n</mi>
      <mrow>
       <mi>l</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msub>
     <mi mathvariant="normal">…</mi>
     <msub>
      <mi>n</mi>
      <mn>0</mn>
     </msub>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi>s</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>n</ci>
      <apply>
       <minus></minus>
       <ci>l</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>n</ci>
      <cn type="integer">0</cn>
     </apply>
    </apply>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (n_{l-1}\dots n_{0})_{s}
  </annotation>
 </semantics>
</math>

. It is denoted by 

<math display="inline" id="Exponentiation_by_squaring:41">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>=</mo>
   <mn>478</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>n</ci>
    <cn type="integer">478</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n=478
  </annotation>
 </semantics>
</math>

. There are several methods for computing this representation. The representation is not unique, for example take 

<math display="inline" id="Exponentiation_by_squaring:42">
 <semantics>
  <msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mn>10</mn>
     <mover accent="true">
      <mn>1</mn>
      <mo stretchy="false">¯</mo>
     </mover>
     <mn>1100</mn>
     <mover accent="true">
      <mn>1</mn>
      <mo stretchy="false">¯</mo>
     </mover>
     <mn>10</mn>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi>s</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <times></times>
     <cn type="integer">10</cn>
     <apply>
      <ci>normal-¯</ci>
      <cn type="integer">1</cn>
     </apply>
     <cn type="integer">1100</cn>
     <apply>
      <ci>normal-¯</ci>
      <cn type="integer">1</cn>
     </apply>
     <cn type="integer">10</cn>
    </apply>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (10\bar{1}1100\bar{1}10)_{s}
  </annotation>
 </semantics>
</math>

. Two distinct signed-binary representations are given by 

<math display="inline" id="Exponentiation_by_squaring:43">
 <semantics>
  <msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mn>100</mn>
     <mover accent="true">
      <mn>1</mn>
      <mo stretchy="false">¯</mo>
     </mover>
     <mn>1000</mn>
     <mover accent="true">
      <mn>1</mn>
      <mo stretchy="false">¯</mo>
     </mover>
     <mn>0</mn>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi>s</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <times></times>
     <cn type="integer">100</cn>
     <apply>
      <ci>normal-¯</ci>
      <cn type="integer">1</cn>
     </apply>
     <cn type="integer">1000</cn>
     <apply>
      <ci>normal-¯</ci>
      <cn type="integer">1</cn>
     </apply>
     <cn type="integer">0</cn>
    </apply>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (100\bar{1}1000\bar{1}0)_{s}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Exponentiation_by_squaring:44">
 <semantics>
  <mover accent="true">
   <mn>1</mn>
   <mo stretchy="false">¯</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-¯</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bar{1}
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Exponentiation_by_squaring:45">
 <semantics>
  <mrow>
   <mo>-</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   -1
  </annotation>
 </semantics>
</math>

 is used to denote 

<math display="inline" id="Exponentiation_by_squaring:46">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

. Since the binary method computes a multiplication for every non-zero entry in the base 2 representation of 

<math display="inline" id="Exponentiation_by_squaring:47">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>n</mi>
     <mi>i</mi>
    </msub>
    <msub>
     <mi>n</mi>
     <mrow>
      <mi>i</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msub>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mn>0</mn>
    <mtext>for all</mtext>
    <mi>i</mi>
   </mrow>
   <mo>⩾</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>n</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>n</ci>
       <apply>
        <plus></plus>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">0</cn>
      <mtext>for all</mtext>
      <ci>i</ci>
     </apply>
    </apply>
    <apply>
     <geq></geq>
     <share href="#.cmml">
     </share>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n_{i}n_{i+1}=0\text{ for all }i\geqslant 0
  </annotation>
 </semantics>
</math>

, we are interested in finding the signed-binary representation with the smallest number of non-zero entries, that is, the one with <em>minimal</em> <a href="Hamming_weight" title="wikilink">Hamming weight</a>. One method of doing this is to compute the representation in <a href="non-adjacent_form" title="wikilink">non-adjacent form</a>, or NAF for short, which is one that satisfies 

<math display="inline" id="Exponentiation_by_squaring:48">
 <semantics>
  <msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msub>
      <mi>n</mi>
      <mrow>
       <mi>l</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msub>
     <mi mathvariant="normal">…</mi>
     <msub>
      <mi>n</mi>
      <mn>0</mn>
     </msub>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mtext>NAF</mtext>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>n</ci>
      <apply>
       <minus></minus>
       <ci>l</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>n</ci>
      <cn type="integer">0</cn>
     </apply>
    </apply>
    <mtext>NAF</mtext>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (n_{l-1}\dots n_{0})_{\text{NAF}}
  </annotation>
 </semantics>
</math>

 and denoted by 

<math display="inline" id="Exponentiation_by_squaring:49">
 <semantics>
  <msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mn>1000</mn>
     <mover accent="true">
      <mn>1</mn>
      <mo stretchy="false">¯</mo>
     </mover>
     <mn>000</mn>
     <mover accent="true">
      <mn>1</mn>
      <mo stretchy="false">¯</mo>
     </mover>
     <mn>0</mn>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mtext>NAF</mtext>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <times></times>
     <cn type="integer">1000</cn>
     <apply>
      <ci>normal-¯</ci>
      <cn type="integer">1</cn>
     </apply>
     <cn type="integer">000</cn>
     <apply>
      <ci>normal-¯</ci>
      <cn type="integer">1</cn>
     </apply>
     <cn type="integer">0</cn>
    </apply>
    <mtext>NAF</mtext>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (1000\bar{1}000\bar{1}0)_{\text{NAF}}
  </annotation>
 </semantics>
</math>

. For example the NAF representation of 478 is equal to 

<math display="inline" id="Exponentiation_by_squaring:50">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>=</mo>
   <msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>n</mi>
       <mi>l</mi>
      </msub>
      <msub>
       <mi>n</mi>
       <mrow>
        <mi>l</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msub>
      <mi mathvariant="normal">…</mi>
      <msub>
       <mi>n</mi>
       <mn>0</mn>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mn>2</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>n</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>n</ci>
       <ci>l</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>n</ci>
       <apply>
        <minus></minus>
        <ci>l</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>n</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n=(n_{l}n_{l-1}\dots n_{0})_{2}
  </annotation>
 </semantics>
</math>

. This representation always has minimal Hamming weight. A simple algorithm to compute the NAF representation of a given integer 

<math display="inline" id="Exponentiation_by_squaring:51">
 <semantics>
  <mrow>
   <msub>
    <mi>n</mi>
    <mi>l</mi>
   </msub>
   <mo>=</mo>
   <msub>
    <mi>n</mi>
    <mrow>
     <mi>l</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>n</ci>
      <ci>l</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>n</ci>
      <apply>
       <minus></minus>
       <ci>l</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n_{l}=n_{l-1}=0
  </annotation>
 </semantics>
</math>

 with 

<math display="inline" id="Exponentiation_by_squaring:52">
 <semantics>
  <mrow>
   <msub>
    <mi>c</mi>
    <mn>0</mn>
   </msub>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>c</ci>
     <cn type="integer">0</cn>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{0}=0
  </annotation>
 </semantics>
</math>

 is the following:</p>
<ol>
<li>

<math display="inline" id="Exponentiation_by_squaring:53">
 <semantics>
  <mrow>
   <mi>i</mi>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>i</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i=0
  </annotation>
 </semantics>
</math>

</li>
<li>for 

<math display="inline" id="Exponentiation_by_squaring:54">
 <semantics>
  <mrow>
   <mi>l</mi>
   <mo>-</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>l</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   l-1
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Exponentiation_by_squaring:55">
 <semantics>
  <mrow>
   <msub>
    <mi>c</mi>
    <mrow>
     <mi>i</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo>⌊</mo>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <mn>2</mn>
     </mfrac>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>c</mi>
        <mi>i</mi>
       </msub>
       <mo>+</mo>
       <msub>
        <mi>n</mi>
        <mi>i</mi>
       </msub>
       <mo>+</mo>
       <msub>
        <mi>n</mi>
        <mrow>
         <mi>i</mi>
         <mo>+</mo>
         <mn>1</mn>
        </mrow>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>⌋</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>c</ci>
     <apply>
      <plus></plus>
      <ci>i</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <floor></floor>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <plus></plus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>c</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>n</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>n</ci>
        <apply>
         <plus></plus>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{i+1}=\left\lfloor\frac{1}{2}(c_{i}+n_{i}+n_{i+1})\right\rfloor
  </annotation>
 </semantics>
</math>

 do</li>
<li>

<math display="inline" id="Exponentiation_by_squaring:56">
 <semantics>
  <mrow>
   <msubsup>
    <mi>n</mi>
    <mi>i</mi>
    <mo>′</mo>
   </msubsup>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>c</mi>
      <mi>i</mi>
     </msub>
     <mo>+</mo>
     <msub>
      <mi>n</mi>
      <mi>i</mi>
     </msub>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mn>2</mn>
     <msub>
      <mi>c</mi>
      <mrow>
       <mi>i</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>n</ci>
      <ci>i</ci>
     </apply>
     <ci>normal-′</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>c</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>n</ci>
       <ci>i</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>c</ci>
       <apply>
        <plus></plus>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n_{i}^{\prime}=c_{i}+n_{i}-2c_{i+1}
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="Exponentiation_by_squaring:57">
 <semantics>
  <msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msubsup>
      <mi>n</mi>
      <mrow>
       <mi>l</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
      <mo>′</mo>
     </msubsup>
     <mi mathvariant="normal">…</mi>
     <msubsup>
      <mi>n</mi>
      <mn>0</mn>
      <mo>′</mo>
     </msubsup>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mtext>NAF</mtext>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>n</ci>
       <apply>
        <minus></minus>
        <ci>l</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>normal-′</ci>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>n</ci>
       <cn type="integer">0</cn>
      </apply>
      <ci>normal-′</ci>
     </apply>
    </apply>
    <mtext>NAF</mtext>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (n_{l-1}^{\prime}\dots n_{0}^{\prime})_{\text{NAF}}
  </annotation>
 </semantics>
</math>

</li>
<li>return 

<math display="inline" id="Exponentiation_by_squaring:58">
 <semantics>
  <mrow>
   <msub>
    <mi>n</mi>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <msub>
    <mi>n</mi>
    <mrow>
     <mi>i</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>n</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>n</ci>
      <apply>
       <plus></plus>
       <ci>i</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n_{i}=n_{i+1}=0
  </annotation>
 </semantics>
</math>

</li>
</ol>

<p>Another algorithm by Koyama and Tsuruoka does not require the condition that 

<math display="block" id="Exponentiation_by_squaring:59">
 <semantics>
  <mrow>
   <msup>
    <mi>a</mi>
    <mn>15</mn>
   </msup>
   <mo>=</mo>
   <mrow>
    <mi>x</mi>
    <mo>×</mo>
    <mpadded width="-1.7pt">
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>x</mi>
        <mo>×</mo>
        <msup>
         <mrow>
          <mo stretchy="false">[</mo>
          <mrow>
           <mi>x</mi>
           <mo>×</mo>
           <msup>
            <mi>x</mi>
            <mn>2</mn>
           </msup>
          </mrow>
          <mo stretchy="false">]</mo>
         </mrow>
         <mn>2</mn>
        </msup>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mn>2</mn>
     </msup>
    </mpadded>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>a</ci>
     <cn type="integer">15</cn>
    </apply>
    <apply>
     <times></times>
     <ci>x</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <times></times>
       <ci>x</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="latexml">delimited-[]</csymbol>
         <apply>
          <times></times>
          <ci>x</ci>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>x</ci>
           <cn type="integer">2</cn>
          </apply>
         </apply>
        </apply>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a^{15}=x\times(x\times[x\times x^{2}]^{2})^{2}\!
  </annotation>
 </semantics>
</math>

; it still minimizes the Hamming weight.</p>
<h2 id="alternatives-and-generalizations">Alternatives and generalizations</h2>

<p>Exponentiation by squaring can be viewed as a suboptimal <a href="addition-chain_exponentiation" title="wikilink">addition-chain exponentiation</a> algorithm: it computes the exponent via an <a href="addition_chain" title="wikilink">addition chain</a> consisting of repeated exponent doublings (squarings) and/or incrementing exponents by <em>one</em> (multiplying by <em>x</em>) only. More generally, if one allows <em>any</em> previously computed exponents to be summed (by multiplying those powers of <em>x</em>), one can sometimes perform the exponentiation using fewer multiplications (but typically using more memory). The smallest power where this occurs is for <em>n</em>=15:</p>

<p>

<math display="block" id="Exponentiation_by_squaring:60">
 <semantics>
  <mrow>
   <msup>
    <mi>a</mi>
    <mn>15</mn>
   </msup>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>x</mi>
     <mn>3</mn>
    </msup>
    <mo>×</mo>
    <mpadded width="-1.7pt">
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <msup>
        <mrow>
         <mo stretchy="false">[</mo>
         <msup>
          <mi>x</mi>
          <mn>3</mn>
         </msup>
         <mo stretchy="false">]</mo>
        </mrow>
        <mn>2</mn>
       </msup>
       <mo stretchy="false">)</mo>
      </mrow>
      <mn>2</mn>
     </msup>
    </mpadded>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>a</ci>
     <cn type="integer">15</cn>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <cn type="integer">3</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>x</ci>
         <cn type="integer">3</cn>
        </apply>
       </apply>
       <cn type="integer">2</cn>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a^{15}=x^{3}\times([x^{3}]^{2})^{2}\!
  </annotation>
 </semantics>
</math>

 (squaring, 6 multiplies)</p>

<p>

<math display="inline" id="Exponentiation_by_squaring:61">
 <semantics>
  <msup>
   <mi>x</mi>
   <mrow>
    <msup>
     <mn>2</mn>
     <mi>k</mi>
    </msup>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>x</ci>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <ci>k</ci>
     </apply>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{2^{k}-1}
  </annotation>
 </semantics>
</math>

 (optimal addition chain, 5 multiplies if <em>x</em><sup>3</sup> is re-used)</p>

<p>In general, finding the <em>optimal</em> addition chain for a given exponent is a hard problem, for which no efficient algorithms are known, so optimal chains are typically only used for small exponents (e.g. in <a href="compiler" title="wikilink">compilers</a> where the chains for small powers have been pre-tabulated). However, there are a number of <a class="uri" href="heuristic" title="wikilink">heuristic</a> algorithms that, while not being optimal, have fewer multiplications than exponentiation by squaring at the cost of additional bookkeeping work and memory usage. Regardless, the number of multiplications never grows more slowly than <a href="Big-O_notation" title="wikilink">Θ</a>(log <em>n</em>), so these algorithms only improve asymptotically upon exponentiation by squaring by a constant factor at best.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Modular_exponentiation" title="wikilink">Modular exponentiation</a></li>
<li><a href="Vectorial_addition_chain" title="wikilink">Vectorial addition chain</a></li>
<li><a href="Montgomery_reduction" title="wikilink">Montgomery reduction</a></li>
<li><a href="Non-adjacent_form" title="wikilink">Non-adjacent form</a></li>
<li><a href="Addition_chain" title="wikilink">Addition chain</a></li>
</ul>
<h2 id="notes">Notes</h2>

<p>"</p>

<p><a class="uri" href="Category:Exponentials" title="wikilink">Category:Exponentials</a> <a href="Category:Computer_arithmetic_algorithms" title="wikilink">Category:Computer arithmetic algorithms</a> <a href="Category:Computer_arithmetic" title="wikilink">Category:Computer arithmetic</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Cohen, H., Frey, G. (editors): Handbook of elliptic and hyperelliptic curve cryptography. Discrete Math.Appl., Chapman &amp; Hall/CRC (2006)<a href="#fnref1">↩</a></li>
<li id="fn2"><code>In</code> <code>this</code> <code>line,</code> <code>the</code> <code>loop</code> <code>finds</code> <code>the</code> <code>longest</code> <code>string</code> <code>of</code> <code>length</code> <code>less</code> <code>than</code> <code>or</code> <code>equal</code> <code>to</code> <code>'k'</code> <code>which</code> <code>ends</code> <code>in</code> <code>a</code> <code>non</code> <code>zero</code> <code>value.</code> <code>And</code> <code>not</code> <code>all</code> <code>odd</code> <code>powers</code> <code>of</code> <code>2</code> <code>up</code> <code>to</code> <span class="LaTeX">$x^{2^k-1}$</span> <code>need</code> <code>be</code> <code>computed</code> <code>and</code> <code>only</code> <code>those</code> <code>specifically</code> <code>involved</code> <code>in</code> <code>the</code> <code>computation</code> <code>need</code> <code>be</code> <code>considered.</code><a href="#fnref2">↩</a></li>
<li id="fn3">Montgomery, P. L. "Speeding the Pollard and Elliptic Curve Methods of Factorization." Math. Comput. 48, 243-264, 1987.<a href="#fnref3">↩</a></li>
<li id="fn4"></li>
</ol>
</section>
</body>

