<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="968">Default logic</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Default logic</h1>
<hr/>

<p><strong>Default logic</strong> is a <a href="non-monotonic_logic" title="wikilink">non-monotonic logic</a> proposed by <a href="Raymond_Reiter" title="wikilink">Raymond Reiter</a> to formalize reasoning with default assumptions.</p>

<p>Default logic can express facts like “by default, something is true”; by contrast, standard logic can only express that something is true or that something is false. This is a problem because reasoning often involves facts that are true in the majority of cases but not always. A classical example is: “birds typically fly”. This rule can be expressed in standard logic either by “all birds fly”, which is inconsistent with the fact that penguins do not fly, or by “all birds that are not penguins and not ostriches and ... fly”, which requires all exceptions to the rule to be specified. Default logic aims at formalizing inference rules like this one without explicitly mentioning all their exceptions.</p>
<h2 id="syntax-of-default-logic">Syntax of default logic</h2>

<p>A default theory is a pair 

<math display="inline" id="Default_logic:0">
 <semantics>
  <mrow>
   <mo stretchy="false">⟨</mo>
   <mi>W</mi>
   <mo>,</mo>
   <mi>D</mi>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>W</ci>
    <ci>D</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle W,D\rangle
  </annotation>
 </semantics>
</math>

. 

<math display="inline" id="Default_logic:1">
 <semantics>
  <mi>W</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>W</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W
  </annotation>
 </semantics>
</math>

 is a set of logical formulae, called <em>the background theory</em>, that formalize the facts that are known for sure. 

<math display="inline" id="Default_logic:2">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>

 is a set of <em>default rules</em>, each one being of the form:</p>

<p>

<math display="block" id="Default_logic:3">
 <semantics>
  <mfrac>
   <mrow>
    <msub>
     <mtext>Prerequisite : Justification</mtext>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mtext>Justification</mtext>
     <mi>n</mi>
    </msub>
   </mrow>
   <mtext>Conclusion</mtext>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <list>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <mtext>Prerequisite : Justification</mtext>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <mtext>Justification</mtext>
      <ci>n</ci>
     </apply>
    </list>
    <mtext>Conclusion</mtext>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{\text{Prerequisite : Justification}_{1},\dots,\text{Justification}_{n}}{%
\text{Conclusion}}
  </annotation>
 </semantics>
</math>

</p>

<p>According to this default, if we believe that 

<math display="inline" id="Default_logic:4">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mi>r</mi>
   <mi>e</mi>
   <mi>r</mi>
   <mi>e</mi>
   <mi>q</mi>
   <mi>u</mi>
   <mi>i</mi>
   <mi>s</mi>
   <mi>i</mi>
   <mi>t</mi>
   <mi>e</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <ci>r</ci>
    <ci>e</ci>
    <ci>r</ci>
    <ci>e</ci>
    <ci>q</ci>
    <ci>u</ci>
    <ci>i</ci>
    <ci>s</ci>
    <ci>i</ci>
    <ci>t</ci>
    <ci>e</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Prerequisite
  </annotation>
 </semantics>
</math>

 is true, and each of 

<math display="inline" id="Default_logic:5">
 <semantics>
  <mrow>
   <mi>J</mi>
   <mi>u</mi>
   <mi>s</mi>
   <mi>t</mi>
   <mi>i</mi>
   <mi>f</mi>
   <mi>i</mi>
   <mi>c</mi>
   <mi>a</mi>
   <mi>t</mi>
   <mi>i</mi>
   <mi>o</mi>
   <msub>
    <mi>n</mi>
    <mi>i</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>J</ci>
    <ci>u</ci>
    <ci>s</ci>
    <ci>t</ci>
    <ci>i</ci>
    <ci>f</ci>
    <ci>i</ci>
    <ci>c</ci>
    <ci>a</ci>
    <ci>t</ci>
    <ci>i</ci>
    <ci>o</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>n</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Justification_{i}
  </annotation>
 </semantics>
</math>

 is consistent with our current beliefs, we are led to believe that 

<math display="inline" id="Default_logic:6">
 <semantics>
  <mrow>
   <mi>C</mi>
   <mi>o</mi>
   <mi>n</mi>
   <mi>c</mi>
   <mi>l</mi>
   <mi>u</mi>
   <mi>s</mi>
   <mi>i</mi>
   <mi>o</mi>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>C</ci>
    <ci>o</ci>
    <ci>n</ci>
    <ci>c</ci>
    <ci>l</ci>
    <ci>u</ci>
    <ci>s</ci>
    <ci>i</ci>
    <ci>o</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Conclusion
  </annotation>
 </semantics>
</math>

 is true.</p>

<p>The logical formulae in 

<math display="inline" id="Default_logic:7">
 <semantics>
  <mi>W</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>W</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W
  </annotation>
 </semantics>
</math>

 and all formulae in a default were originally assumed to be <a href="first-order_logic" title="wikilink">first-order logic</a> formulae, but they can potentially be formulae in an arbitrary formal logic. The case in which they are formulae in <a href="propositional_logic" title="wikilink">propositional logic</a> is one of the most studied.</p>
<h3 id="examples">Examples</h3>

<p>The default rule “birds typically fly” is formalized by the following default:</p>

<p>

<math display="block" id="Default_logic:8">
 <semantics>
  <mrow>
   <mi>D</mi>
   <mo>=</mo>
   <mrow>
    <mo>{</mo>
    <mfrac>
     <mrow>
      <mrow>
       <mi>B</mi>
       <mi>i</mi>
       <mi>r</mi>
       <mi>d</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>X</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>:</mo>
      <mrow>
       <mi>F</mi>
       <mi>l</mi>
       <mi>i</mi>
       <mi>e</mi>
       <mi>s</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>X</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mrow>
      <mi>F</mi>
      <mi>l</mi>
      <mi>i</mi>
      <mi>e</mi>
      <mi>s</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>X</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mfrac>
    <mo>}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>D</ci>
    <set>
     <apply>
      <divide></divide>
      <apply>
       <ci>normal-:</ci>
       <apply>
        <times></times>
        <ci>B</ci>
        <ci>i</ci>
        <ci>r</ci>
        <ci>d</ci>
        <ci>X</ci>
       </apply>
       <apply>
        <times></times>
        <ci>F</ci>
        <ci>l</ci>
        <ci>i</ci>
        <ci>e</ci>
        <ci>s</ci>
        <ci>X</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>F</ci>
       <ci>l</ci>
       <ci>i</ci>
       <ci>e</ci>
       <ci>s</ci>
       <ci>X</ci>
      </apply>
     </apply>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D=\left\{\frac{Bird(X):Flies(X)}{Flies(X)}\right\}
  </annotation>
 </semantics>
</math>

</p>

<p>This rule means that, if 

<math display="inline" id="Default_logic:9">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

 is a bird, and it can be assumed that it flies, then we can conclude that it flies. A background theory containing some facts about birds is the following one:</p>

<p>

<math display="block" id="Default_logic:10">
 <semantics>
  <mrow>
   <mi>W</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mi>B</mi>
     <mi>i</mi>
     <mi>r</mi>
     <mi>d</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>C</mi>
       <mi>o</mi>
       <mi>n</mi>
       <mi>d</mi>
       <mi>o</mi>
       <mi>r</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mi>B</mi>
     <mi>i</mi>
     <mi>r</mi>
     <mi>d</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>P</mi>
       <mi>e</mi>
       <mi>n</mi>
       <mi>g</mi>
       <mi>u</mi>
       <mi>i</mi>
       <mi>n</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mi mathvariant="normal">¬</mi>
     <mi>F</mi>
     <mi>l</mi>
     <mi>i</mi>
     <mi>e</mi>
     <mi>s</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>P</mi>
       <mi>e</mi>
       <mi>n</mi>
       <mi>g</mi>
       <mi>u</mi>
       <mi>i</mi>
       <mi>n</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mi>F</mi>
     <mi>l</mi>
     <mi>i</mi>
     <mi>e</mi>
     <mi>s</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>B</mi>
       <mi>e</mi>
       <mi>e</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>W</ci>
    <set>
     <apply>
      <times></times>
      <ci>B</ci>
      <ci>i</ci>
      <ci>r</ci>
      <ci>d</ci>
      <apply>
       <times></times>
       <ci>C</ci>
       <ci>o</ci>
       <ci>n</ci>
       <ci>d</ci>
       <ci>o</ci>
       <ci>r</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>B</ci>
      <ci>i</ci>
      <ci>r</ci>
      <ci>d</ci>
      <apply>
       <times></times>
       <ci>P</ci>
       <ci>e</ci>
       <ci>n</ci>
       <ci>g</ci>
       <ci>u</ci>
       <ci>i</ci>
       <ci>n</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <not></not>
      <ci>F</ci>
      <ci>l</ci>
      <ci>i</ci>
      <ci>e</ci>
      <ci>s</ci>
      <apply>
       <times></times>
       <ci>P</ci>
       <ci>e</ci>
       <ci>n</ci>
       <ci>g</ci>
       <ci>u</ci>
       <ci>i</ci>
       <ci>n</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>F</ci>
      <ci>l</ci>
      <ci>i</ci>
      <ci>e</ci>
      <ci>s</ci>
      <apply>
       <times></times>
       <ci>B</ci>
       <ci>e</ci>
       <ci>e</ci>
      </apply>
     </apply>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W=\{Bird(Condor),Bird(Penguin),\neg Flies(Penguin),Flies(Bee)\}
  </annotation>
 </semantics>
</math>

.</p>

<p>According to this default rule, a condor flies because the precondition 

<math display="inline" id="Default_logic:11">
 <semantics>
  <mrow>
   <mi>B</mi>
   <mi>i</mi>
   <mi>r</mi>
   <mi>d</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>C</mi>
     <mi>o</mi>
     <mi>n</mi>
     <mi>d</mi>
     <mi>o</mi>
     <mi>r</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>B</ci>
    <ci>i</ci>
    <ci>r</ci>
    <ci>d</ci>
    <apply>
     <times></times>
     <ci>C</ci>
     <ci>o</ci>
     <ci>n</ci>
     <ci>d</ci>
     <ci>o</ci>
     <ci>r</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Bird(Condor)
  </annotation>
 </semantics>
</math>

 is true and the justification 

<math display="inline" id="Default_logic:12">
 <semantics>
  <mrow>
   <mi>F</mi>
   <mi>l</mi>
   <mi>i</mi>
   <mi>e</mi>
   <mi>s</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>C</mi>
     <mi>o</mi>
     <mi>n</mi>
     <mi>d</mi>
     <mi>o</mi>
     <mi>r</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>F</ci>
    <ci>l</ci>
    <ci>i</ci>
    <ci>e</ci>
    <ci>s</ci>
    <apply>
     <times></times>
     <ci>C</ci>
     <ci>o</ci>
     <ci>n</ci>
     <ci>d</ci>
     <ci>o</ci>
     <ci>r</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Flies(Condor)
  </annotation>
 </semantics>
</math>

 is not inconsistent with what is currently known. On the contrary, 

<math display="inline" id="Default_logic:13">
 <semantics>
  <mrow>
   <mi>B</mi>
   <mi>i</mi>
   <mi>r</mi>
   <mi>d</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>P</mi>
     <mi>e</mi>
     <mi>n</mi>
     <mi>g</mi>
     <mi>u</mi>
     <mi>i</mi>
     <mi>n</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>B</ci>
    <ci>i</ci>
    <ci>r</ci>
    <ci>d</ci>
    <apply>
     <times></times>
     <ci>P</ci>
     <ci>e</ci>
     <ci>n</ci>
     <ci>g</ci>
     <ci>u</ci>
     <ci>i</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Bird(Penguin)
  </annotation>
 </semantics>
</math>

 does not allow concluding 

<math display="inline" id="Default_logic:14">
 <semantics>
  <mrow>
   <mi>F</mi>
   <mi>l</mi>
   <mi>i</mi>
   <mi>e</mi>
   <mi>s</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>P</mi>
     <mi>e</mi>
     <mi>n</mi>
     <mi>g</mi>
     <mi>u</mi>
     <mi>i</mi>
     <mi>n</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>F</ci>
    <ci>l</ci>
    <ci>i</ci>
    <ci>e</ci>
    <ci>s</ci>
    <apply>
     <times></times>
     <ci>P</ci>
     <ci>e</ci>
     <ci>n</ci>
     <ci>g</ci>
     <ci>u</ci>
     <ci>i</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Flies(Penguin)
  </annotation>
 </semantics>
</math>

: even if the precondition of the default 

<math display="inline" id="Default_logic:15">
 <semantics>
  <mrow>
   <mi>B</mi>
   <mi>i</mi>
   <mi>r</mi>
   <mi>d</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>P</mi>
     <mi>e</mi>
     <mi>n</mi>
     <mi>g</mi>
     <mi>u</mi>
     <mi>i</mi>
     <mi>n</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>B</ci>
    <ci>i</ci>
    <ci>r</ci>
    <ci>d</ci>
    <apply>
     <times></times>
     <ci>P</ci>
     <ci>e</ci>
     <ci>n</ci>
     <ci>g</ci>
     <ci>u</ci>
     <ci>i</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Bird(Penguin)
  </annotation>
 </semantics>
</math>

 is true, the justification 

<math display="inline" id="Default_logic:16">
 <semantics>
  <mrow>
   <mi>F</mi>
   <mi>l</mi>
   <mi>i</mi>
   <mi>e</mi>
   <mi>s</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>P</mi>
     <mi>e</mi>
     <mi>n</mi>
     <mi>g</mi>
     <mi>u</mi>
     <mi>i</mi>
     <mi>n</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>F</ci>
    <ci>l</ci>
    <ci>i</ci>
    <ci>e</ci>
    <ci>s</ci>
    <apply>
     <times></times>
     <ci>P</ci>
     <ci>e</ci>
     <ci>n</ci>
     <ci>g</ci>
     <ci>u</ci>
     <ci>i</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Flies(Penguin)
  </annotation>
 </semantics>
</math>

 is inconsistent with what is known. From this background theory and this default, 

<math display="inline" id="Default_logic:17">
 <semantics>
  <mrow>
   <mi>B</mi>
   <mi>i</mi>
   <mi>r</mi>
   <mi>d</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>B</mi>
     <mi>e</mi>
     <mi>e</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>B</ci>
    <ci>i</ci>
    <ci>r</ci>
    <ci>d</ci>
    <apply>
     <times></times>
     <ci>B</ci>
     <ci>e</ci>
     <ci>e</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Bird(Bee)
  </annotation>
 </semantics>
</math>

 cannot be concluded because the default rule only allows deriving 

<math display="inline" id="Default_logic:18">
 <semantics>
  <mrow>
   <mi>F</mi>
   <mi>l</mi>
   <mi>i</mi>
   <mi>e</mi>
   <mi>s</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>F</ci>
    <ci>l</ci>
    <ci>i</ci>
    <ci>e</ci>
    <ci>s</ci>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Flies(X)
  </annotation>
 </semantics>
</math>

 from 

<math display="inline" id="Default_logic:19">
 <semantics>
  <mrow>
   <mi>B</mi>
   <mi>i</mi>
   <mi>r</mi>
   <mi>d</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>B</ci>
    <ci>i</ci>
    <ci>r</ci>
    <ci>d</ci>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Bird(X)
  </annotation>
 </semantics>
</math>

, but not vice versa. Deriving the antecedents of an inference rule from the consequences is a form of explanation of the consequences, and is the aim of <a href="abductive_reasoning" title="wikilink">abductive reasoning</a>.</p>

<p>A common default assumption is that what is not known to be true is believed to be false. This is known as the <a href="Closed_World_Assumption" title="wikilink">Closed World Assumption</a>, and is formalized in default logic using a default like the following one for every fact 

<math display="inline" id="Default_logic:20">
 <semantics>
  <mi>F</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>F</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F
  </annotation>
 </semantics>
</math>

.</p>

<p>

<math display="block" id="Default_logic:21">
 <semantics>
  <mfrac>
   <mrow>
    <mi></mi>
    <mo>:</mo>
    <mrow>
     <mi mathvariant="normal">¬</mi>
     <mi>F</mi>
    </mrow>
   </mrow>
   <mrow>
    <mi mathvariant="normal">¬</mi>
    <mi>F</mi>
   </mrow>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <ci>normal-:</ci>
     <csymbol cd="latexml">absent</csymbol>
     <apply>
      <times></times>
      <not></not>
      <ci>F</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <not></not>
     <ci>F</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{:{\neg}F}{{\neg}F}
  </annotation>
 </semantics>
</math>

</p>

<p>For example, the computer language <a class="uri" href="Prolog" title="wikilink">Prolog</a> uses a sort of default assumption when dealing with negation: if a negative atom cannot be proved to be true, then it is assumed to be false. Note, however, that Prolog uses the so-called <a href="negation_as_failure" title="wikilink">negation as failure</a>: when the interpreter has to evaluate the atom 

<math display="inline" id="Default_logic:22">
 <semantics>
  <mrow>
   <mi mathvariant="normal">¬</mi>
   <mi>F</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <not></not>
    <ci>F</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg F
  </annotation>
 </semantics>
</math>

, it tries to prove that 

<math display="inline" id="Default_logic:23">
 <semantics>
  <mi>F</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>F</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F
  </annotation>
 </semantics>
</math>

 is true, and conclude that 

<math display="inline" id="Default_logic:24">
 <semantics>
  <mrow>
   <mi mathvariant="normal">¬</mi>
   <mi>F</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <not></not>
    <ci>F</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg F
  </annotation>
 </semantics>
</math>

 is true if it fails. In default logic, instead, a default having 

<math display="inline" id="Default_logic:25">
 <semantics>
  <mrow>
   <mi mathvariant="normal">¬</mi>
   <mi>F</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <not></not>
    <ci>F</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg F
  </annotation>
 </semantics>
</math>

 as a justification can only be applied if 

<math display="inline" id="Default_logic:26">
 <semantics>
  <mrow>
   <mi mathvariant="normal">¬</mi>
   <mi>F</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <not></not>
    <ci>F</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg F
  </annotation>
 </semantics>
</math>

 is consistent with the current knowledge.</p>
<h3 id="restrictions">Restrictions</h3>

<p>A default is categorical or prerequisite-free if it has no prerequisite (or, equivalently, its prerequisite is <a href="tautology_(logic)" title="wikilink">tautological</a>). A default is normal if it has a single justification that is equivalent to its conclusion. A default is supernormal if it is both categorical and normal. A default is seminormal if all its justifications entail its conclusion. A default theory is called categorical, normal, supernormal, or seminormal if all defaults it contains are categorical, normal, supernormal, or seminormal, respectively.</p>
<h2 id="semantics-of-default-logic">Semantics of default logic</h2>

<p>A default rule can be applied to a theory if its precondition is entailed by the theory and its justifications are all <strong><em>consistent with</em></strong> the theory. The application of a default rule leads to the addition of its consequence to the theory. Other default rules may then be applied to the resulting theory. <strong>When the theory is such that no other default can be applied, the theory is called an extension of the default theory.</strong> The default rules may be applied in different order, and this may lead to different extensions. The <a href="Nixon_diamond" title="wikilink">Nixon diamond</a> example is a default theory with two extensions:</p>

<p>

<math display="block" id="Default_logic:27">
 <semantics>
  <mrow>
   <mo>⟨</mo>
   <mrow>
    <mo>{</mo>
    <mfrac>
     <mrow>
      <mrow>
       <mi>R</mi>
       <mi>e</mi>
       <mi>p</mi>
       <mi>u</mi>
       <mi>b</mi>
       <mi>l</mi>
       <mi>i</mi>
       <mi>c</mi>
       <mi>a</mi>
       <mi>n</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>X</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>:</mo>
      <mrow>
       <mi mathvariant="normal">¬</mi>
       <mi>P</mi>
       <mi>a</mi>
       <mi>c</mi>
       <mi>i</mi>
       <mi>f</mi>
       <mi>i</mi>
       <mi>s</mi>
       <mi>t</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>X</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mrow>
      <mi mathvariant="normal">¬</mi>
      <mi>P</mi>
      <mi>a</mi>
      <mi>c</mi>
      <mi>i</mi>
      <mi>f</mi>
      <mi>i</mi>
      <mi>s</mi>
      <mi>t</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>X</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mfrac>
    <mo>,</mo>
    <mfrac>
     <mrow>
      <mrow>
       <mi>Q</mi>
       <mi>u</mi>
       <mi>a</mi>
       <mi>k</mi>
       <mi>e</mi>
       <mi>r</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>X</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>:</mo>
      <mrow>
       <mi>P</mi>
       <mi>a</mi>
       <mi>c</mi>
       <mi>i</mi>
       <mi>f</mi>
       <mi>i</mi>
       <mi>s</mi>
       <mi>t</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>X</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mrow>
      <mi>P</mi>
      <mi>a</mi>
      <mi>c</mi>
      <mi>i</mi>
      <mi>f</mi>
      <mi>i</mi>
      <mi>s</mi>
      <mi>t</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>X</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mfrac>
    <mo>}</mo>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mo>{</mo>
    <mrow>
     <mi>R</mi>
     <mi>e</mi>
     <mi>p</mi>
     <mi>u</mi>
     <mi>b</mi>
     <mi>l</mi>
     <mi>i</mi>
     <mi>c</mi>
     <mi>a</mi>
     <mi>n</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>N</mi>
       <mi>i</mi>
       <mi>x</mi>
       <mi>o</mi>
       <mi>n</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mi>Q</mi>
     <mi>u</mi>
     <mi>a</mi>
     <mi>k</mi>
     <mi>e</mi>
     <mi>r</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>N</mi>
       <mi>i</mi>
       <mi>x</mi>
       <mi>o</mi>
       <mi>n</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>}</mo>
   </mrow>
   <mo>⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <set>
     <apply>
      <divide></divide>
      <apply>
       <ci>normal-:</ci>
       <apply>
        <times></times>
        <ci>R</ci>
        <ci>e</ci>
        <ci>p</ci>
        <ci>u</ci>
        <ci>b</ci>
        <ci>l</ci>
        <ci>i</ci>
        <ci>c</ci>
        <ci>a</ci>
        <ci>n</ci>
        <ci>X</ci>
       </apply>
       <apply>
        <times></times>
        <not></not>
        <ci>P</ci>
        <ci>a</ci>
        <ci>c</ci>
        <ci>i</ci>
        <ci>f</ci>
        <ci>i</ci>
        <ci>s</ci>
        <ci>t</ci>
        <ci>X</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <not></not>
       <ci>P</ci>
       <ci>a</ci>
       <ci>c</ci>
       <ci>i</ci>
       <ci>f</ci>
       <ci>i</ci>
       <ci>s</ci>
       <ci>t</ci>
       <ci>X</ci>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <ci>normal-:</ci>
       <apply>
        <times></times>
        <ci>Q</ci>
        <ci>u</ci>
        <ci>a</ci>
        <ci>k</ci>
        <ci>e</ci>
        <ci>r</ci>
        <ci>X</ci>
       </apply>
       <apply>
        <times></times>
        <ci>P</ci>
        <ci>a</ci>
        <ci>c</ci>
        <ci>i</ci>
        <ci>f</ci>
        <ci>i</ci>
        <ci>s</ci>
        <ci>t</ci>
        <ci>X</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>P</ci>
       <ci>a</ci>
       <ci>c</ci>
       <ci>i</ci>
       <ci>f</ci>
       <ci>i</ci>
       <ci>s</ci>
       <ci>t</ci>
       <ci>X</ci>
      </apply>
     </apply>
    </set>
    <set>
     <apply>
      <times></times>
      <ci>R</ci>
      <ci>e</ci>
      <ci>p</ci>
      <ci>u</ci>
      <ci>b</ci>
      <ci>l</ci>
      <ci>i</ci>
      <ci>c</ci>
      <ci>a</ci>
      <ci>n</ci>
      <apply>
       <times></times>
       <ci>N</ci>
       <ci>i</ci>
       <ci>x</ci>
       <ci>o</ci>
       <ci>n</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>Q</ci>
      <ci>u</ci>
      <ci>a</ci>
      <ci>k</ci>
      <ci>e</ci>
      <ci>r</ci>
      <apply>
       <times></times>
       <ci>N</ci>
       <ci>i</ci>
       <ci>x</ci>
       <ci>o</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </set>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left\langle\left\{\frac{Republican(X):\neg Pacifist(X)}{\neg Pacifist(X)},%
\frac{Quaker(X):Pacifist(X)}{Pacifist(X)}\right\},\left\{Republican(Nixon),%
Quaker(Nixon)\right\}\right\rangle
  </annotation>
 </semantics>
</math>

</p>

<p>Since <a href="Richard_Nixon" title="wikilink">Nixon</a> is both a <a href="American_Republican" title="wikilink">Republican</a> and a <a class="uri" href="Quaker" title="wikilink">Quaker</a>, both defaults can be applied. However, applying the first default leads to the conclusion that Nixon is not a pacifist, which makes the second default not applicable. In the same way, applying the second default we obtain that Nixon is a pacifist, thus making the first default not applicable. This particular default theory has therefore two extensions, one in which 

<math display="inline" id="Default_logic:28">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mi>a</mi>
   <mi>c</mi>
   <mi>i</mi>
   <mi>f</mi>
   <mi>i</mi>
   <mi>s</mi>
   <mi>t</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>N</mi>
     <mi>i</mi>
     <mi>x</mi>
     <mi>o</mi>
     <mi>n</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <ci>a</ci>
    <ci>c</ci>
    <ci>i</ci>
    <ci>f</ci>
    <ci>i</ci>
    <ci>s</ci>
    <ci>t</ci>
    <apply>
     <times></times>
     <ci>N</ci>
     <ci>i</ci>
     <ci>x</ci>
     <ci>o</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Pacifist(Nixon)
  </annotation>
 </semantics>
</math>

 is true, and one in which 

<math display="inline" id="Default_logic:29">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mi>a</mi>
   <mi>c</mi>
   <mi>i</mi>
   <mi>f</mi>
   <mi>i</mi>
   <mi>s</mi>
   <mi>t</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>N</mi>
     <mi>i</mi>
     <mi>x</mi>
     <mi>o</mi>
     <mi>n</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <ci>a</ci>
    <ci>c</ci>
    <ci>i</ci>
    <ci>f</ci>
    <ci>i</ci>
    <ci>s</ci>
    <ci>t</ci>
    <apply>
     <times></times>
     <ci>N</ci>
     <ci>i</ci>
     <ci>x</ci>
     <ci>o</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Pacifist(Nixon)
  </annotation>
 </semantics>
</math>

 is false.</p>

<p>The original semantics of default logic was based on the <a href="Fixed_point_(mathematics)" title="wikilink">fixed point</a> of a function. The following is an equivalent algorithmic definition. If a default contains formulae with free variables, it is considered to represent the set of all defaults obtained by giving a value to all these variables. A default 

<math display="inline" id="Default_logic:30">
 <semantics>
  <mfrac>
   <mrow>
    <mi>α</mi>
    <mo>:</mo>
    <mrow>
     <msub>
      <mi>β</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <msub>
      <mi>β</mi>
      <mi>n</mi>
     </msub>
    </mrow>
   </mrow>
   <mi>γ</mi>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <ci>normal-:</ci>
     <ci>α</ci>
     <list>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>β</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>β</ci>
       <ci>n</ci>
      </apply>
     </list>
    </apply>
    <ci>γ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{\alpha:\beta_{1},\ldots,\beta_{n}}{\gamma}
  </annotation>
 </semantics>
</math>


 is applicable to a propositional theory 

<math display="inline" id="Default_logic:31">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

 if 

<math display="inline" id="Default_logic:32">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mo>⊧</mo>
   <mi>α</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">models</csymbol>
    <ci>T</ci>
    <ci>α</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T\models\alpha
  </annotation>
 </semantics>
</math>

 and all theories 

<math display="inline" id="Default_logic:33">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mo>∪</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <msub>
     <mi>β</mi>
     <mi>i</mi>
    </msub>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <union></union>
    <ci>T</ci>
    <set>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>β</ci>
      <ci>i</ci>
     </apply>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T\cup\{\beta_{i}\}
  </annotation>
 </semantics>
</math>

 are consistent. The application of this default to 

<math display="inline" id="Default_logic:34">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

 leads to the theory 

<math display="inline" id="Default_logic:35">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mo>∪</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mi>γ</mi>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <union></union>
    <ci>T</ci>
    <set>
     <ci>γ</ci>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T\cup\{\gamma\}
  </annotation>
 </semantics>
</math>


. An extension can be generated by applying the following algorithm:</p>

<p><code>T=W           /* current theory */</code><br/>
<code>A=0           /* set of defaults applied so far */</code><br/>
<code> </code><br/>
<code>              /* apply a sequence of defaults */</code><br/>
<code>while there is a default d that is not in A and is applicable to T</code><br/>
<code>  add the consequence of d to T</code><br/>
<code>  add d to A</code><br/>
<code> </code><br/>
<code>              /* final consistency check */</code><br/>
<code>if </code><br/>
<code>  for every default d in A</code><br/>
<code>    T is consistent with all justifications of d</code><br/>
<code>then</code><br/>
<code>  output T</code></p>

<p>This algorithm is <a href="nondeterministic_algorithm" title="wikilink">non-deterministic</a>, as several defaults can alternatively be applied to a given theory 

<math display="inline" id="Default_logic:36">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

. In the Nixon diamond example, the application of the first default leads to a theory to which the second default cannot be applied and vice versa. As a result, two extensions are generated: one in which Nixon is a pacifist and one in which Nixon is not a pacifist.</p>

<p>The final check of consistency of the justifications of all defaults that have been applied implies that some theories do not have any extensions. In particular, this happens whenever this check fails for every possible sequence of applicable defaults. The following default theory has no extension:</p>

<p>

<math display="block" id="Default_logic:37">
 <semantics>
  <mrow>
   <mo>⟨</mo>
   <mrow>
    <mo>{</mo>
    <mfrac>
     <mrow>
      <mi></mi>
      <mo>:</mo>
      <mrow>
       <mi>A</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>b</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mrow>
      <mi mathvariant="normal">¬</mi>
      <mi>A</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>b</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mfrac>
    <mo>}</mo>
   </mrow>
   <mo>,</mo>
   <mi mathvariant="normal">∅</mi>
   <mo>⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <set>
     <apply>
      <divide></divide>
      <apply>
       <ci>normal-:</ci>
       <csymbol cd="latexml">absent</csymbol>
       <apply>
        <times></times>
        <ci>A</ci>
        <ci>b</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <not></not>
       <ci>A</ci>
       <ci>b</ci>
      </apply>
     </apply>
    </set>
    <emptyset></emptyset>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left\langle\left\{\frac{:A(b)}{\neg A(b)}\right\},\emptyset\right\rangle
  </annotation>
 </semantics>
</math>

</p>

<p>Since 

<math display="inline" id="Default_logic:38">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>b</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>A</ci>
    <ci>b</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A(b)
  </annotation>
 </semantics>
</math>

 is consistent with the background theory, the default can be applied, thus leading to the conclusion that 

<math display="inline" id="Default_logic:39">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>b</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>A</ci>
    <ci>b</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A(b)
  </annotation>
 </semantics>
</math>


 is false. This result however undermines the assumption that has been made for applying the first default. Consequently, this theory has no extensions.</p>

<p>In a normal default theory, all defaults are normal: each default has the form 

<math display="inline" id="Default_logic:40">
 <semantics>
  <mfrac>
   <mrow>
    <mi>ϕ</mi>
    <mo>:</mo>
    <mi>ψ</mi>
   </mrow>
   <mi>ψ</mi>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <ci>normal-:</ci>
     <ci>ϕ</ci>
     <ci>ψ</ci>
    </apply>
    <ci>ψ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{\phi:\psi}{\psi}
  </annotation>
 </semantics>
</math>

. A normal default theory is guaranteed to have at least one extension. Furthermore, the extensions of a normal default theory are mutually inconsistent, i.e., inconsistent with each other.</p>
<h3 id="entailment">Entailment</h3>

<p>A default theory can have zero, one, or more extensions. <a class="uri" href="Entailment" title="wikilink">Entailment</a> of a formula from a default theory can be defined in two ways:</p>
<dl>
<dt>Skeptical : a formula is entailed by a default theory if it is entailed by all its extensions;</dt>
</dl>
<dl>
<dt>Credulous : a formula is entailed by a default theory if it is entailed by at least one of its extensions.</dt>
</dl>

<p>Thus, the Nixon diamond example theory has two extensions, one in which Nixon is a pacifist and one in which he is not a pacifist. Consequently, neither 

<math display="inline" id="Default_logic:41">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mi>a</mi>
   <mi>c</mi>
   <mi>i</mi>
   <mi>f</mi>
   <mi>i</mi>
   <mi>s</mi>
   <mi>t</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>N</mi>
     <mi>i</mi>
     <mi>x</mi>
     <mi>o</mi>
     <mi>n</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <ci>a</ci>
    <ci>c</ci>
    <ci>i</ci>
    <ci>f</ci>
    <ci>i</ci>
    <ci>s</ci>
    <ci>t</ci>
    <apply>
     <times></times>
     <ci>N</ci>
     <ci>i</ci>
     <ci>x</ci>
     <ci>o</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Pacifist(Nixon)
  </annotation>
 </semantics>
</math>

 nor 

<math display="inline" id="Default_logic:42">
 <semantics>
  <mrow>
   <mi mathvariant="normal">¬</mi>
   <mi>P</mi>
   <mi>a</mi>
   <mi>c</mi>
   <mi>i</mi>
   <mi>f</mi>
   <mi>i</mi>
   <mi>s</mi>
   <mi>t</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>N</mi>
     <mi>i</mi>
     <mi>x</mi>
     <mi>o</mi>
     <mi>n</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <not></not>
    <ci>P</ci>
    <ci>a</ci>
    <ci>c</ci>
    <ci>i</ci>
    <ci>f</ci>
    <ci>i</ci>
    <ci>s</ci>
    <ci>t</ci>
    <apply>
     <times></times>
     <ci>N</ci>
     <ci>i</ci>
     <ci>x</ci>
     <ci>o</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg Pacifist(Nixon)
  </annotation>
 </semantics>
</math>

 are skeptically entailed, while both of them are credulously entailed. As this example shows, the credulous consequences of a default theory may be inconsistent with each other.</p>
<h3 id="alternative-default-inference-rules">Alternative default inference rules</h3>

<p>The following alternative inference rules for default logic are all based on the same syntax as the original system.</p>
<dl>
<dt>Justified: differs from the original one in that a default is not applied if thereby the set 

<math display="inline" id="Default_logic:43">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

 becomes <a class="uri" href="inconsistent" title="wikilink">inconsistent</a> with a justification of an applied default;</dt>
</dl>
<dl>
<dt>Concise: a default is applied only if its consequence is not already entailed by 

<math display="inline" id="Default_logic:44">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>


 (the exact definition is more complicated than this one; this is only the main idea behind it);</dt>
</dl>
<dl>
<dt>Constrained: a default is applied only if the set composed of the background theory, the justifications of all applied defaults, and the consequences of all applied defaults (including this one) is consistent;</dt>
</dl>
<dl>
<dt>Rational: similar to constrained default logic, but the consequence of the default to add is not considered in the consistency check;</dt>
</dl>
<dl>
<dt>Cautious: defaults that can be applied but are conflicting with each other (like the ones of the Nixon diamond example) are not applied.</dt>
</dl>

<p>The justified and constrained versions of the inference rule assign at least an extension to every default theory.</p>
<h2 id="variants-of-default-logic">Variants of default logic</h2>

<p>The following variants of default logic differ from the original one on both syntax and semantics.</p>
<dl>
<dt>Assertional variants : An assertion is a pair 

<math display="inline" id="Default_logic:45">
 <semantics>
  <mrow>
   <mo stretchy="false">⟨</mo>
   <mrow>
    <mi>p</mi>
    <mo>:</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <msub>
      <mi>r</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <msub>
      <mi>r</mi>
      <mi>n</mi>
     </msub>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">delimited-⟨⟩</csymbol>
    <apply>
     <ci>normal-:</ci>
     <ci>p</ci>
     <set>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>r</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>r</ci>
       <ci>n</ci>
      </apply>
     </set>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle p:\{r_{1},\ldots,r_{n}\}\rangle
  </annotation>
 </semantics>
</math>

 composed of a formula and a set of formulae. Such a pair indicates that 

<math display="inline" id="Default_logic:46">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 is true while the formulae 

<math display="inline" id="Default_logic:47">
 <semantics>
  <mrow>
   <msub>
    <mi>r</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>r</mi>
    <mi>n</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>r</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>r</ci>
     <ci>n</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r_{1},\ldots,r_{n}
  </annotation>
 </semantics>
</math>

 have been assumed consistent to prove that 

<math display="inline" id="Default_logic:48">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 is true. An assertional default theory is composed of an assertional theory (a set of assertional formulae) called the background theory and a set of defaults defined as in the original syntax. Whenever a default is applied to an assertional theory, the pair composed of its consequence and its set of justifications is added to the theory. The following semantics use assertional theories:</dt>
</dl>
<ul>
<li>Cumulative default logic</li>
<li>Commitment to assumptions default logic</li>
<li>Quasi-default logic</li>
</ul>
<dl>
<dt>Weak extensions : rather than checking whether the preconditions are valid in the theory composed of the background theory and the consequences of the applied defaults, the preconditions are checked for validity in the extension that will be generated; in other words, the algorithm for generating extensions starts by guessing a theory and using it in place of the background theory; what results from the process of extension generation is actually an extension only if it is equivalent to the theory guessed at the beginning. This variant of default logic is related in principle to <a href="autoepistemic_logic" title="wikilink">autoepistemic logic</a>, where a theory 

<math display="inline" id="Default_logic:49">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">□</mi>
    <mi>x</mi>
   </mrow>
   <mo>→</mo>
   <mi>x</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <times></times>
     <ci>normal-□</ci>
     <ci>x</ci>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Box x\rightarrow x
  </annotation>
 </semantics>
</math>


 has the model in which 

<math display="inline" id="Default_logic:50">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 is true just because, assuming 

<math display="inline" id="Default_logic:51">
 <semantics>
  <mrow>
   <mi mathvariant="normal">□</mi>
   <mi>x</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-□</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Box x
  </annotation>
 </semantics>
</math>

 true, the formula 

<math display="inline" id="Default_logic:52">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">□</mi>
    <mi>x</mi>
   </mrow>
   <mo>→</mo>
   <mi>x</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <times></times>
     <ci>normal-□</ci>
     <ci>x</ci>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Box x\rightarrow x
  </annotation>
 </semantics>
</math>

 supports the initial assumption.</dt>
</dl>
<dl>
<dt>Disjunctive default logic : the consequence of a default is a set of formulae instead of a single formula. Whenever the default is applied, at least one of its consequences is nondeterministically chosen and made true.</dt>
</dl>
<dl>
<dt>Priorities on defaults : the relative priority of defaults can be explicitly specified; among the defaults that are applicable to a theory, only one of the most preferred ones can be applied. Some semantics of default logic do not require priorities to be explicitly specified; rather, more specific defaults (those that are applicable in fewer cases) are preferred over less specific ones.</dt>
</dl>
<dl>
<dt>Statistical variant : a statistical default is a default with an attached upper bound on its frequency of error; in other words, the default is assumed to be an incorrect inference rule in at most that fraction of times it is applied.</dt>
</dl>
<h2 id="translations">Translations</h2>

<p>Default theories can be translated into theories in other logics and vice versa. The following conditions on translations have been considered:</p>
<dl>
<dt>Consequence-Preserving : the original and the translated theories have the same (propositional) consequences;</dt>
</dl>
<dl>
<dt>Faithful : this condition only makes sense when translating between two variants of default logic or between default logic and a logic in which a concept similar to extension exists, e.g., models in modal logic; a translation is faithful if there exists a mapping (typically, a bijection) between the extensions (or models) of the original and translated theories;</dt>
</dl>
<dl>
<dt>Modular : a translation from default logic to another logic is modular if the defaults and the background theory can be translated separately; moreover, the addition of formulae to the background theory only leads to adding the new formulae to the result of the translation;</dt>
</dl>
<dl>
<dt>Same-Alphabet : the original and translated theories are built on the same alphabet;</dt>
</dl>
<dl>
<dt>Polynomial : the running time of the translation or the size of the generated theory are required to be polynomial in the size of the original theory.</dt>
</dl>

<p>Translations are typically required to be faithful or at least consequence-preserving, while the conditions of modularity and same alphabet are sometimes ignored.</p>

<p>The translatability between propositional default logic and the following logics have been studied:</p>
<ul>
<li>classical propositional logic;</li>
<li>autoepistemic logic;</li>
<li>propositional default logic restricted to seminormal theories;</li>
<li>alternative semantics of default logic;</li>
<li>circumscription.</li>
</ul>

<p>Translations exist or not depending on which conditions are imposed. Translations from propositional default logic to classical propositional logic cannot always generate a polynomially sized propositional theory, unless the <a href="polynomial_hierarchy" title="wikilink">polynomial hierarchy</a> collapses. Translations to autoepistemic logic exists or not depending on whether modularity or the use of the same alphabet is required.</p>
<h2 id="complexity">Complexity</h2>

<p>The <a href="Analysis_of_algorithms" title="wikilink">computational complexity</a> of the following problems about default logic is known:</p>
<dl>
<dt>Existence of extensions : deciding whether a propositional default theory has at least one extension is 

<math display="inline" id="Default_logic:53">
 <semantics>
  <msubsup>
   <mi mathvariant="normal">Σ</mi>
   <mn>2</mn>
   <mi>P</mi>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-Σ</ci>
     <ci>P</ci>
    </apply>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma^{P}_{2}
  </annotation>
 </semantics>
</math>

-complete;</dt>
</dl>
<dl>
<dt>Skeptical entailment : deciding whether a propositional default theory skeptically entails a <a href="propositional_formula" title="wikilink">propositional formula</a> is 

<math display="inline" id="Default_logic:54">
 <semantics>
  <msubsup>
   <mi mathvariant="normal">Π</mi>
   <mn>2</mn>
   <mi>P</mi>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-Π</ci>
     <ci>P</ci>
    </apply>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Pi^{P}_{2}
  </annotation>
 </semantics>
</math>


-complete;</dt>
</dl>
<dl>
<dt>Credulous entailment : deciding whether a propositional default theory credulously entails a propositional formula is 

<math display="inline" id="Default_logic:55">
 <semantics>
  <msubsup>
   <mi mathvariant="normal">Σ</mi>
   <mn>2</mn>
   <mi>P</mi>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-Σ</ci>
     <ci>P</ci>
    </apply>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma^{P}_{2}
  </annotation>
 </semantics>
</math>

-complete;</dt>
</dl>
<dl>
<dt>Extension checking : deciding whether a propositional formula is equivalent to an extension of a propositional default theory is 

<math display="inline" id="Default_logic:56">
 <semantics>
  <msubsup>
   <mi mathvariant="normal">Δ</mi>
   <mn>2</mn>
   <mrow>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mi>l</mi>
      <mi>o</mi>
      <mi>g</mi>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-Δ</ci>
     <apply>
      <times></times>
      <ci>P</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <times></times>
        <ci>l</ci>
        <ci>o</ci>
        <ci>g</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta^{P[log]}_{2}
  </annotation>
 </semantics>
</math>

-complete;</dt>
</dl>
<dl>
<dt>Model checking : deciding whether a propositional interpretation is a model of an extension of a propositional default theory is 

<math display="inline" id="Default_logic:57">
 <semantics>
  <msubsup>
   <mi mathvariant="normal">Σ</mi>
   <mn>2</mn>
   <mi>P</mi>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-Σ</ci>
     <ci>P</ci>
    </apply>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma^{P}_{2}
  </annotation>
 </semantics>
</math>

-complete.</dt>
</dl>
<h2 id="implementations">Implementations</h2>

<p>Three systems implementing default logics are <a href="ftp://www.cs.engr.uky.edu/cs/manuscripts/deres.ps">DeReS</a>, <a href="http://www.cs.uni-potsdam.de/wv/xray/">XRay</a> and <a href="http://www.info.univ-angers.fr/pub/stephan/Research/GADEL/GADEL_prolog.html">GADeL</a></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Answer_set_programming" title="wikilink">Answer set programming</a></li>
<li><a href="Defeasible_logic" title="wikilink">Defeasible logic</a></li>
<li><a href="Non-monotonic_logic" title="wikilink">Non-monotonic logic</a></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li>G. Antoniou (1999). A tutorial on default logics. <em>ACM Computing Surveys</em>, 31(4):337-359.</li>
<li>M. Cadoli, F. M. Donini, P. Liberatore, and M. Schaerf (2000). Space efficiency of propositional knowledge representation formalisms. <em>Journal of Artificial Intelligence Research</em>, 13:1-31.</li>
<li>P. Cholewinski, V. Marek, and M. Truszczynski (1996). Default reasoning system DeReS. In <em>Proceedings of the Fifth International Conference on the Principles of Knowledge Representation and Reasoning (KR'96)</em>, pages 518-528.</li>
<li>J. Delgrande and T. Schaub (2003). On the relation between Reiter's default logic and its (major) variants. In <em>Seventh European Conference on Symbolic and Quantitative Approaches to Reasoning with Uncertainty (ECSQARU 2003)</em>, pages 452-463.</li>
<li>J. P. Delgrande, T. Schaub, and W. K. Jackson (1994). Alternative approaches to default logic. <em>Artificial Intelligence</em>, 70:167-237.</li>
<li>G. Gottlob (1992). Complexity results for nonmonotonic logics. <em>Journal of Logic and Computation</em>, 2:397-425.</li>
<li>G. Gottlob (1995). Translating default logic into standard autoepistemic logic. <em>Journal of the ACM</em>, 42:711-740.</li>
<li>T. Imielinski (1987). Results on translating defaults to circumscription. <em>Artificial Intelligence</em>, 32:131-146.</li>
<li>T. Janhunen (1998). On the intertranslatability of autoepistemic, default and priority logics, and parallel circumscription. In <em>Proceedings of the Sixth European Workshop on Logics in Artificial Intelligence (JELIA'98)</em>, pages 216-232.</li>
<li>T. Janhunen (2003). Evaluating the effect of semi-normality on the expressiveness of defaults. <em>Artificial Intelligence</em>, 144:233-250.</li>
<li>H. E. Kyburg and C-M. Teng (2006). Nonmonotonic Logic and Statistical Inference. <em>Computational Intelligence</em>, 22(1): 26-51.</li>
<li>P. Liberatore and M. Schaerf (1998). The complexity of model checking for propositional default logics. In <em>Proceedings of the Thirteenth European Conference on Artificial Intelligence (ECAI'98)</em>, pages 18–22.</li>
<li>W. Lukaszewicz (1988). Considerations on default logic: an alternative approach. <em>Computational Intelligence</em>, 4(1):1-16.</li>
<li>W. Marek and M. Truszczynski (1993). <em>Nonmonotonic Logics: Context-Dependent Reasoning</em>. Springer.</li>
<li>A. Mikitiuk and M. Truszczynski (1995). Constrained and rational default logics. In <em>Proceedings of the Fourteenth International Joint Conference on Artificial Intelligence (IJCAI'95)</em>, pages 1509-1517.</li>
<li>P. Nicolas, F. Saubion and I. Stéphan (2001). Heuristics for a Default Logic Reasoning System. <em>International Journal on Artificial Intelligence Tools</em>, 10(4):503-523.</li>
<li>R. Reiter (1980). A logic for default reasoning. <em>Artificial Intelligence</em>, 13:81-132.</li>
<li>T. Schaub, S. Brüning, and P. Nicolas (1996). XRay: A prolog technology theorem prover for default reasoning: A system description. In <em>Proceedings of the Thirteenth International Conference on Automated Deduction (CADE'96)</em>, pages 293-297.</li>
<li>G. Wheeler (2004). A resource bounded default logic. In <em>Proceedings of the 10th International Workshop on Non-Monotonic Reasoning (NMR-04)</em>, Whistler, British Columbia, 416-422.</li>
<li>G. Wheeler and C. Damasio (2004). An Implementation of Statistical Default Logic. In <em>Proceedings of the 9th European Conference on Logics in Artificial Intelligence (JELIA 2004)</em>, LNCS Series, Springer, pages 121-133.</li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li>Schmidt, Charles F. <a href="http://www.rci.rutgers.edu/~cfs/472_html/Logic_KR/DefaultTheory.html">RCI.Rutgers.edu</a>, Default Logic. Retrieved August 10, 2004.</li>
<li>Ramsay, Allan (1999). <a href="http://www.ccl.umist.ac.uk/teaching/material/5005/node33.html">UMIST.ac.uk</a>, Default Logic. Retrieved August 10, 2004.</li>
<li><a href="http://plato.stanford.edu/entries/reasoning-defeasible/">Stanford.edu</a>, Defeasible reasoning, <a href="Stanford_Encyclopedia_of_Philosophy" title="wikilink">Stanford Encyclopedia of Philosophy</a>.</li>
</ul>

<p>"</p>

<p><a href="Category:Logic_programming" title="wikilink">Category:Logic programming</a> <a href="Category:Knowledge_representation" title="wikilink">Category:Knowledge representation</a> <a href="Category:Logical_calculi" title="wikilink">Category:Logical calculi</a> <a href="Category:Non-classical_logic" title="wikilink">Category:Non-classical logic</a></p>
</body>
</html>
