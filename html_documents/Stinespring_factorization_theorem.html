<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="25">Stinespring factorization theorem</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Stinespring factorization theorem</h1>
<hr/>

<p>In <a class="uri" href="mathematics" title="wikilink">mathematics</a>, <strong>Stinespring's dilation theorem</strong>, also called <strong>Stinespring's factorization theorem</strong>, named after W. Forrest Stinespring, is a result from <a href="operator_theory" title="wikilink">operator theory</a> that represents any <a href="completely_positive_map" title="wikilink">completely positive map</a> on a <a class="uri" href="C*-algebra" title="wikilink">C*-algebra</a> as a composition of two completely positive maps each of which has a special form:</p>
<ol>
<li>A *-representation of <em>A</em> on some auxiliary <a href="Hilbert_space" title="wikilink">Hilbert space</a> <em>K</em> followed by</li>
<li>An operator map of the form <em>T</em> → <em>VTV</em>*.</li>
</ol>

<p>Moreover, Stinespring's theorem is a structure theorem from a C*-algebra into the algebra of <a href="bounded_operators" title="wikilink">bounded operators</a> on a Hilbert space. Completely positive maps are shown to be simple modifications of *-representations, or sometimes called <a href="*-algebra" title="wikilink">*-homomorphisms</a>.</p>
<h2 id="formulation">Formulation</h2>

<p>In the case of a unital C*-algebra, the result is as follows:</p>
<dl>
<dd><strong>Theorem</strong>. Let <em>A</em> be a unital C*-algebra, <em>H</em> be a Hilbert space, and <em>B(H)</em> be the bounded operators on <em>H</em>. For every completely positive

<p>

<math display="block" id="Stinespring_factorization_theorem:0">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">Φ</mi>
    <mo>:</mo>
    <mrow>
     <mi>A</mi>
     <mo>→</mo>
     <mrow>
      <mi>B</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>H</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>normal-Φ</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>A</ci>
     <apply>
      <times></times>
      <ci>B</ci>
      <ci>H</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Phi:A\to B(H),
  </annotation>
 </semantics>
</math>

</p>
</dd>
<dd>there exists a Hilbert space <em>K</em> and a unital *-homomorphism

<p>

<math display="block" id="Stinespring_factorization_theorem:1">
 <semantics>
  <mrow>
   <mi>π</mi>
   <mo>:</mo>
   <mrow>
    <mi>A</mi>
    <mo>→</mo>
    <mrow>
     <mi>B</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>K</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>π</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>A</ci>
     <apply>
      <times></times>
      <ci>B</ci>
      <ci>K</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi:A\to B(K)
  </annotation>
 </semantics>
</math>

</p>
</dd>
<dd>such that

<p>

<math display="block" id="Stinespring_factorization_theorem:2">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi mathvariant="normal">Φ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>a</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msup>
      <mi>V</mi>
      <mo>∗</mo>
     </msup>
     <mi>π</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>a</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>V</mi>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>normal-Φ</ci>
     <ci>a</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>V</ci>
      <ci>normal-∗</ci>
     </apply>
     <ci>π</ci>
     <ci>a</ci>
     <ci>V</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Phi(a)=V^{\ast}\pi(a)V,
  </annotation>
 </semantics>
</math>

</p>
</dd>
<dd>where 

<math display="inline" id="Stinespring_factorization_theorem:3">
 <semantics>
  <mrow>
   <mi>V</mi>
   <mo>:</mo>
   <mrow>
    <mi>H</mi>
    <mo>→</mo>
    <mi>K</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>V</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>H</ci>
     <ci>K</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V:H\to K
  </annotation>
 </semantics>
</math>

 is a bounded operator. Furthermore, we have

<p>

<math display="block" id="Stinespring_factorization_theorem:4">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>∥</mo>
     <mrow>
      <mi mathvariant="normal">Φ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mn>1</mn>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>∥</mo>
    </mrow>
    <mo>=</mo>
    <msup>
     <mrow>
      <mo>∥</mo>
      <mi>V</mi>
      <mo>∥</mo>
     </mrow>
     <mn>2</mn>
    </msup>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="latexml">norm</csymbol>
     <apply>
      <times></times>
      <ci>normal-Φ</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="latexml">norm</csymbol>
      <ci>V</ci>
     </apply>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \|\Phi(1)\|=\|V\|^{2}.
  </annotation>
 </semantics>
</math>

</p>
</dd>
</dl>

<p>Informally, one can say that every completely positive map 

<math display="inline" id="Stinespring_factorization_theorem:5">
 <semantics>
  <mi mathvariant="normal">Φ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Φ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Phi
  </annotation>
 </semantics>
</math>

 can be "lifted" up to a map of the form 

<math display="inline" id="Stinespring_factorization_theorem:6">
 <semantics>
  <mrow>
   <mi>V</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>⋅</mo>
    <mo stretchy="false">)</mo>
   </mrow>
   <msup>
    <mi>V</mi>
    <mo>*</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>V</ci>
    <ci>normal-⋅</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>V</ci>
     <times></times>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V(\cdot)V^{*}
  </annotation>
 </semantics>
</math>

.</p>

<p>The converse of the theorem is true trivially. So Stinespring's result classifies completely positive maps.</p>
<h2 id="sketch-of-proof">Sketch of proof</h2>

<p>We now briefly sketch the proof. Let 

<math display="inline" id="Stinespring_factorization_theorem:7">
 <semantics>
  <mrow>
   <mi>K</mi>
   <mo>=</mo>
   <mrow>
    <mi>A</mi>
    <mo>⊗</mo>
    <mi>H</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>K</ci>
    <apply>
     <csymbol cd="latexml">tensor-product</csymbol>
     <ci>A</ci>
     <ci>H</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K=A\otimes H
  </annotation>
 </semantics>
</math>

. For 

<math display="inline" id="Stinespring_factorization_theorem:8">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>a</mi>
     <mo>⊗</mo>
     <mi>h</mi>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mi>b</mi>
     <mo>⊗</mo>
     <mi>g</mi>
    </mrow>
   </mrow>
   <mo>∈</mo>
   <mi>K</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <list>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <ci>a</ci>
      <ci>h</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <ci>b</ci>
      <ci>g</ci>
     </apply>
    </list>
    <ci>K</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a\otimes h,b\otimes g\in K
  </annotation>
 </semantics>
</math>

, define</p>

<p>

<math display="block" id="Stinespring_factorization_theorem:9">
 <semantics>
  <mrow>
   <msub>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mrow>
      <mi>a</mi>
      <mo>⊗</mo>
      <mi>h</mi>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mi>b</mi>
      <mo>⊗</mo>
      <mi>g</mi>
     </mrow>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mi>K</mi>
   </msub>
   <mo>:=</mo>
   <msub>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mrow>
      <mi mathvariant="normal">Φ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <msup>
         <mi>b</mi>
         <mo>*</mo>
        </msup>
        <mi>a</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>h</mi>
     </mrow>
     <mo>,</mo>
     <mi>g</mi>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mi>H</mi>
   </msub>
   <mo>=</mo>
   <msub>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mi>h</mi>
     <mo>,</mo>
     <mrow>
      <mi mathvariant="normal">Φ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <msup>
         <mi>a</mi>
         <mo>*</mo>
        </msup>
        <mi>b</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>g</mi>
     </mrow>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mi>H</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <csymbol cd="latexml">assign</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <list>
       <apply>
        <csymbol cd="latexml">tensor-product</csymbol>
        <ci>a</ci>
        <ci>h</ci>
       </apply>
       <apply>
        <csymbol cd="latexml">tensor-product</csymbol>
        <ci>b</ci>
        <ci>g</ci>
       </apply>
      </list>
      <ci>K</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <list>
       <apply>
        <times></times>
        <ci>normal-Φ</ci>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>b</ci>
          <times></times>
         </apply>
         <ci>a</ci>
        </apply>
        <ci>h</ci>
       </apply>
       <ci>g</ci>
      </list>
      <ci>H</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <list>
       <ci>h</ci>
       <apply>
        <times></times>
        <ci>normal-Φ</ci>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>a</ci>
          <times></times>
         </apply>
         <ci>b</ci>
        </apply>
        <ci>g</ci>
       </apply>
      </list>
      <ci>H</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle a\otimes h,b\otimes g\rangle_{K}:=\langle\Phi(b^{*}a)h,g\rangle_{H}=%
\langle h,\Phi(a^{*}b)g\rangle_{H}
  </annotation>
 </semantics>
</math>

</p>

<p>and extend by semi-linearity to all of <em>K</em>. This is a hermitian sesquilinear form because 

<math display="inline" id="Stinespring_factorization_theorem:10">
 <semantics>
  <mi mathvariant="normal">Φ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Φ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Phi
  </annotation>
 </semantics>
</math>

 is compatible with the * operation. Complete positivity of 

<math display="inline" id="Stinespring_factorization_theorem:11">
 <semantics>
  <mi mathvariant="normal">Φ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Φ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Phi
  </annotation>
 </semantics>
</math>

 is then used to show that this sesquilinear form is in fact positive semidefinite. Since positive semidefinite hermitian sesquilinear forms satisfy the Cauchy Schwarz inequality, the subset</p>

<p>

<math display="block" id="Stinespring_factorization_theorem:12">
 <semantics>
  <mrow>
   <msup>
    <mi>K</mi>
    <mo>′</mo>
   </msup>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mi>x</mi>
     <mo>∈</mo>
     <mi>K</mi>
    </mrow>
    <mo stretchy="false">|</mo>
    <mrow>
     <msub>
      <mrow>
       <mo stretchy="false">⟨</mo>
       <mi>x</mi>
       <mo>,</mo>
       <mi>x</mi>
       <mo stretchy="false">⟩</mo>
      </mrow>
      <mi>K</mi>
     </msub>
     <mo>=</mo>
     <mn>0</mn>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
   <mo>⊂</mo>
   <mi>K</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>K</ci>
      <ci>normal-′</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">conditional-set</csymbol>
      <apply>
       <in></in>
       <ci>x</ci>
       <ci>K</ci>
      </apply>
      <apply>
       <eq></eq>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <list>
         <ci>x</ci>
         <ci>x</ci>
        </list>
        <ci>K</ci>
       </apply>
       <cn type="integer">0</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <subset></subset>
     <share href="#.cmml">
     </share>
     <ci>K</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K^{\prime}=\{x\in K|\langle x,x\rangle_{K}=0\}\subset K
  </annotation>
 </semantics>
</math>

</p>

<p>is a subspace. We can remove degeneracy by considering the <a href="Quotient_space_(linear_algebra)#Quotient_of_a_Banach_space_by_a_subspace" title="wikilink">quotient space</a> 

<math display="inline" id="Stinespring_factorization_theorem:13">
 <semantics>
  <mrow>
   <mi>K</mi>
   <mo>/</mo>
   <msup>
    <mi>K</mi>
    <mo>′</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <ci>K</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>K</ci>
     <ci>normal-′</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K/K^{\prime}
  </annotation>
 </semantics>
</math>

. The completion of this quotient space is then a Hilbert space, also denoted by 

<math display="inline" id="Stinespring_factorization_theorem:14">
 <semantics>
  <mi>K</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>K</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K
  </annotation>
 </semantics>
</math>

. Next define 

<math display="inline" id="Stinespring_factorization_theorem:15">
 <semantics>
  <mrow>
   <mrow>
    <mi>π</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>a</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>b</mi>
      <mo>⊗</mo>
      <mi>g</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>a</mi>
     <mi>b</mi>
    </mrow>
    <mo>⊗</mo>
    <mi>g</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>π</ci>
     <ci>a</ci>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <ci>b</ci>
      <ci>g</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">tensor-product</csymbol>
     <apply>
      <times></times>
      <ci>a</ci>
      <ci>b</ci>
     </apply>
     <ci>g</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi(a)(b\otimes g)=ab\otimes g
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Stinespring_factorization_theorem:16">
 <semantics>
  <mrow>
   <mrow>
    <mi>V</mi>
    <mi>h</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mn>1</mn>
     <mi>A</mi>
    </msub>
    <mo>⊗</mo>
    <mi>h</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>V</ci>
     <ci>h</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">tensor-product</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <cn type="integer">1</cn>
      <ci>A</ci>
     </apply>
     <ci>h</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Vh=1_{A}\otimes h
  </annotation>
 </semantics>
</math>

. One can check that 

<math display="inline" id="Stinespring_factorization_theorem:17">
 <semantics>
  <mi>π</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>π</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Stinespring_factorization_theorem:18">
 <semantics>
  <mi>V</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>V</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V
  </annotation>
 </semantics>
</math>

 have the desired properties.</p>

<p>Notice that 

<math display="inline" id="Stinespring_factorization_theorem:19">
 <semantics>
  <mi>V</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>V</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V
  </annotation>
 </semantics>
</math>

 is just the natural algebraic embedding of <em>H</em> into <em>K</em>. One can verify that 

<math display="inline" id="Stinespring_factorization_theorem:20">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>V</mi>
     <mo>∗</mo>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>a</mi>
      <mo>⊗</mo>
      <mi>h</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi mathvariant="normal">Φ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>a</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>h</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>V</ci>
      <ci>normal-∗</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <ci>a</ci>
      <ci>h</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>normal-Φ</ci>
     <ci>a</ci>
     <ci>h</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V^{\ast}(a\otimes h)=\Phi(a)h
  </annotation>
 </semantics>
</math>

 holds. In particular 

<math display="inline" id="Stinespring_factorization_theorem:21">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>V</mi>
     <mo>∗</mo>
    </msup>
    <mi>V</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi mathvariant="normal">Φ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>1</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>V</ci>
      <ci>normal-∗</ci>
     </apply>
     <ci>V</ci>
    </apply>
    <apply>
     <times></times>
     <ci>normal-Φ</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V^{\ast}V=\Phi(1)
  </annotation>
 </semantics>
</math>

 holds so that 

<math display="inline" id="Stinespring_factorization_theorem:22">
 <semantics>
  <mi>V</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>V</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V
  </annotation>
 </semantics>
</math>

 is an isometry if and only if 

<math display="inline" id="Stinespring_factorization_theorem:23">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">Φ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>1</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>normal-Φ</ci>
     <cn type="integer">1</cn>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Phi(1)=1
  </annotation>
 </semantics>
</math>

. In this case <em>H</em> can be embedded, in the Hilbert space sense, into <em>K</em> and 

<math display="inline" id="Stinespring_factorization_theorem:24">
 <semantics>
  <msup>
   <mi>V</mi>
   <mo>∗</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>V</ci>
    <ci>normal-∗</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V^{\ast}
  </annotation>
 </semantics>
</math>

, acting on <em>K</em>, becomes the projection onto <em>H</em>. Symbolically, we can write</p>

<p>

<math display="block" id="Stinespring_factorization_theorem:25">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi mathvariant="normal">Φ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>a</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <msub>
     <mrow>
      <mrow>
       <mpadded width="+2.8pt">
        <msub>
         <mi>P</mi>
         <mi>H</mi>
        </msub>
       </mpadded>
       <mi>π</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>a</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo fence="true">|</mo>
     </mrow>
     <mi>H</mi>
    </msub>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>normal-Φ</ci>
     <ci>a</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">evaluated-at</csymbol>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>P</ci>
       <ci>H</ci>
      </apply>
      <ci>π</ci>
      <ci>a</ci>
     </apply>
     <ci>H</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Phi(a)=P_{H}\;\pi(a)|_{H}.
  </annotation>
 </semantics>
</math>

</p>

<p>In the language of dilation theory, this is to say that 

<math display="inline" id="Stinespring_factorization_theorem:26">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Φ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>a</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Φ</ci>
    <ci>a</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Phi(a)
  </annotation>
 </semantics>
</math>

 is a <em>compression</em> of 

<math display="inline" id="Stinespring_factorization_theorem:27">
 <semantics>
  <mrow>
   <mi>π</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>a</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>π</ci>
    <ci>a</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi(a)
  </annotation>
 </semantics>
</math>

. It is therefore a corollary of Stinespring's theorem that every unital completely positive map is the compression of some *-homomorphism.</p>
<h2 id="minimality">Minimality</h2>

<p>The triple (π, <em>V</em>, <em>K</em>) is called a <strong>Stinespring representation</strong> of Φ. A natural question is now whether one can reduce a given Stinespring representation in some sense.</p>

<p>Let <em>K</em><sub>1</sub> be the closed linear span of π(<em>A</em>) <em>V</em>*<em>H</em>. By property of *-representations in general, <em>K</em><sub>1</sub> is an invariant subspace of π(<em>a</em>) for all <em>a</em>. Also, <em>K</em><sub>1</sub> contains <em>V</em>*<em>H</em>. Define</p>

<p>

<math display="block" id="Stinespring_factorization_theorem:28">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>π</mi>
      <mn>1</mn>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>a</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <msub>
     <mrow>
      <mrow>
       <mi>π</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>a</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo fence="true">|</mo>
     </mrow>
     <msub>
      <mi>K</mi>
      <mn>1</mn>
     </msub>
    </msub>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>π</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>a</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">evaluated-at</csymbol>
     <apply>
      <times></times>
      <ci>π</ci>
      <ci>a</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>K</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi_{1}(a)=\pi(a)|_{K_{1}}.
  </annotation>
 </semantics>
</math>

</p>

<p>We can compute directly</p>

<p>

<math display="block" id="Stinespring_factorization_theorem:29">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>π</mi>
     <mn>1</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>a</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <msub>
     <mi>π</mi>
     <mn>1</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>b</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msub>
    <mrow>
     <mrow>
      <msub>
       <mrow>
        <mrow>
         <mi>π</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>a</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo fence="true">|</mo>
       </mrow>
       <msub>
        <mi>K</mi>
        <mn>1</mn>
       </msub>
      </msub>
      <mi>π</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>b</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo fence="true">|</mo>
    </mrow>
    <msub>
     <mi>K</mi>
     <mn>1</mn>
    </msub>
   </msub>
   <mo>=</mo>
   <msub>
    <mrow>
     <mrow>
      <mi>π</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>a</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>π</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>b</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo fence="true">|</mo>
    </mrow>
    <msub>
     <mi>K</mi>
     <mn>1</mn>
    </msub>
   </msub>
   <mo>=</mo>
   <msub>
    <mrow>
     <mrow>
      <mi>π</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>a</mi>
        <mi>b</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo fence="true">|</mo>
    </mrow>
    <msub>
     <mi>K</mi>
     <mn>1</mn>
    </msub>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>π</mi>
     <mn>1</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>a</mi>
      <mi>b</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>π</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>a</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>π</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>b</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">evaluated-at</csymbol>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="latexml">evaluated-at</csymbol>
        <apply>
         <times></times>
         <ci>π</ci>
         <ci>a</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>K</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>π</ci>
       <ci>b</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>K</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="latexml">evaluated-at</csymbol>
      <apply>
       <times></times>
       <ci>π</ci>
       <ci>a</ci>
       <ci>π</ci>
       <ci>b</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>K</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="latexml">evaluated-at</csymbol>
      <apply>
       <times></times>
       <ci>π</ci>
       <apply>
        <times></times>
        <ci>a</ci>
        <ci>b</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>K</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>π</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <times></times>
       <ci>a</ci>
       <ci>b</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi_{1}(a)\pi_{1}(b)=\pi(a)|_{K_{1}}\pi(b)|_{K_{1}}=\pi(a)\pi(b)|_{K_{1}}=\pi(%
ab)|_{K_{1}}=\pi_{1}(ab)
  </annotation>
 </semantics>
</math>

</p>

<p>and if <em>k</em> and <em>l</em> lie in <em>K</em><sub>1</sub></p>

<p>

<math display="block" id="Stinespring_factorization_theorem:30">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mrow>
      <msub>
       <mi>π</mi>
       <mn>1</mn>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <msup>
        <mi>a</mi>
        <mo>*</mo>
       </msup>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>k</mi>
     </mrow>
     <mo>,</mo>
     <mi>l</mi>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mrow>
      <mi>π</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msup>
        <mi>a</mi>
        <mo>*</mo>
       </msup>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>k</mi>
     </mrow>
     <mo>,</mo>
     <mi>l</mi>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mrow>
      <mi>π</mi>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>a</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <mo>*</mo>
      </msup>
      <mi>k</mi>
     </mrow>
     <mo>,</mo>
     <mi>l</mi>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mi>k</mi>
     <mo>,</mo>
     <mrow>
      <mi>π</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>a</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>l</mi>
     </mrow>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mi>k</mi>
     <mo>,</mo>
     <mrow>
      <msub>
       <mi>π</mi>
       <mn>1</mn>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>a</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>l</mi>
     </mrow>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mrow>
      <msub>
       <mi>π</mi>
       <mn>1</mn>
      </msub>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>a</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <mo>*</mo>
      </msup>
      <mi>k</mi>
     </mrow>
     <mo>,</mo>
     <mi>l</mi>
     <mo stretchy="false">⟩</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <list>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>π</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>a</ci>
        <times></times>
       </apply>
       <ci>k</ci>
      </apply>
      <ci>l</ci>
     </list>
     <list>
      <apply>
       <times></times>
       <ci>π</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>a</ci>
        <times></times>
       </apply>
       <ci>k</ci>
      </apply>
      <ci>l</ci>
     </list>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <list>
      <apply>
       <times></times>
       <ci>π</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>a</ci>
        <times></times>
       </apply>
       <ci>k</ci>
      </apply>
      <ci>l</ci>
     </list>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <list>
      <ci>k</ci>
      <apply>
       <times></times>
       <ci>π</ci>
       <ci>a</ci>
       <ci>l</ci>
      </apply>
     </list>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <list>
      <ci>k</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>π</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>a</ci>
       <ci>l</ci>
      </apply>
     </list>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <list>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>π</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>a</ci>
        <times></times>
       </apply>
       <ci>k</ci>
      </apply>
      <ci>l</ci>
     </list>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle\pi_{1}(a^{*})k,l\rangle=\langle\pi(a^{*})k,l\rangle=\langle\pi(a)^{*}k%
,l\rangle=\langle k,\pi(a)l\rangle=\langle k,\pi_{1}(a)l\rangle=\langle\pi_{1}%
(a)^{*}k,l\rangle.
  </annotation>
 </semantics>
</math>

</p>

<p>So (π<sub>1</sub>, <em>V</em>, <em>K</em><sub>1</sub>) is also a Stinespring representation of Φ and has the additional property that <em>K</em><sub>1</sub> is the closed linear span of π(<em>A</em>) <em>V</em>*<em>H</em>. Such a representation is called a <strong>minimal Stinespring representation</strong>.</p>
<h2 id="uniqueness">Uniqueness</h2>

<p>Let (π<sub>1</sub>, <em>V</em><sub>1</sub>, <em>K</em><sub>1</sub>) and (π<sub>2</sub>, <em>V</em><sub>2</sub>, <em>K</em><sub>2</sub>) be two Stinespring representations of a given Φ. Define a <a href="partial_isometry" title="wikilink">partial isometry</a> <em>W</em> : <em>K</em><sub>1</sub> → <em>K</em><sub>2</sub> by</p>

<p>

<math display="block" id="Stinespring_factorization_theorem:31">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mpadded lspace="2.8pt" width="+2.8pt">
      <mi>W</mi>
     </mpadded>
     <msub>
      <mi>π</mi>
      <mn>1</mn>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>a</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <msub>
      <mi>V</mi>
      <mn>1</mn>
     </msub>
     <mi>h</mi>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>π</mi>
      <mn>2</mn>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>a</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <msub>
      <mi>V</mi>
      <mn>2</mn>
     </msub>
     <mi>h</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>W</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>π</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>a</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>V</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>h</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>π</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>a</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>V</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>h</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \;W\pi_{1}(a)V_{1}h=\pi_{2}(a)V_{2}h.
  </annotation>
 </semantics>
</math>

</p>

<p>On <em>V</em><sub>1</sub><em>H</em> ⊂ <em>K</em><sub>1</sub>, this gives the interwining relation</p>

<p>

<math display="block" id="Stinespring_factorization_theorem:32">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mpadded lspace="2.8pt" width="+2.8pt">
      <mi>W</mi>
     </mpadded>
     <msub>
      <mi>π</mi>
      <mn>1</mn>
     </msub>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>π</mi>
      <mn>2</mn>
     </msub>
     <mi>W</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>W</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>π</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>π</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>W</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \;W\pi_{1}=\pi_{2}W.
  </annotation>
 </semantics>
</math>

</p>

<p>In particular, if both Stinespring representations are minimal, <em>W</em> is unitary. Thus minimal Stinespring representations are unique up to a unitary transformation.</p>
<h2 id="some-consequences">Some consequences</h2>

<p>We mention a few of the results which can be viewed as consequences of Stinespring's theorem. Historically, some of the results below preceded Stinespring's theorem.</p>
<h3 id="gns-construction"><a href="GNS_construction" title="wikilink">GNS construction</a></h3>

<p>Let <em>H</em> in Stinespring's theorem be 1-dimensional, i.e. the complex numbers. So Φ now is a positive linear functional on <em>A</em>. If we assume Φ is a <a href="state_(functional_analysis)" title="wikilink">state</a>, that is, Φ has norm 1, then the isometry 

<math display="inline" id="Stinespring_factorization_theorem:33">
 <semantics>
  <mrow>
   <msup>
    <mi>V</mi>
    <mo>*</mo>
   </msup>
   <mo>:</mo>
   <mrow>
    <mi>H</mi>
    <mo>→</mo>
    <mi>K</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>V</ci>
     <times></times>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <ci>H</ci>
     <ci>K</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V^{*}:H\to K
  </annotation>
 </semantics>
</math>

 is determined by</p>

<p>

<math display="block" id="Stinespring_factorization_theorem:34">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>V</mi>
     <mo>*</mo>
    </msup>
    <mn>1</mn>
   </mrow>
   <mo>=</mo>
   <mi>ξ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>V</ci>
      <times></times>
     </apply>
     <cn type="integer">1</cn>
    </apply>
    <ci>ξ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V^{*}1=\xi
  </annotation>
 </semantics>
</math>

</p>

<p>for some 

<math display="inline" id="Stinespring_factorization_theorem:35">
 <semantics>
  <mrow>
   <mi>ξ</mi>
   <mo>∈</mo>
   <mi>K</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>ξ</ci>
    <ci>K</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \xi\in K
  </annotation>
 </semantics>
</math>

 of unit norm. So</p>

<p>

<math display="block" id="Stinespring_factorization_theorem:36">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">Φ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>a</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>V</mi>
    <mi>π</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>a</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <msup>
     <mi>V</mi>
     <mo>*</mo>
    </msup>
   </mrow>
   <mo>=</mo>
   <msub>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mrow>
      <mi>V</mi>
      <mi>π</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>a</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <msup>
       <mi>V</mi>
       <mo>*</mo>
      </msup>
      <mn>1</mn>
     </mrow>
     <mo>,</mo>
     <mn>1</mn>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mi>H</mi>
   </msub>
   <mo>=</mo>
   <msub>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mrow>
      <mi>π</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>a</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <msup>
       <mi>V</mi>
       <mo>*</mo>
      </msup>
      <mn>1</mn>
     </mrow>
     <mo>,</mo>
     <mrow>
      <msup>
       <mi>V</mi>
       <mo>*</mo>
      </msup>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mi>K</mi>
   </msub>
   <mo>=</mo>
   <msub>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mrow>
      <mi>π</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>a</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>ξ</mi>
     </mrow>
     <mo>,</mo>
     <mi>ξ</mi>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mi>K</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>normal-Φ</ci>
      <ci>a</ci>
     </apply>
     <apply>
      <times></times>
      <ci>V</ci>
      <ci>π</ci>
      <ci>a</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>V</ci>
       <times></times>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <list>
       <apply>
        <times></times>
        <ci>V</ci>
        <ci>π</ci>
        <ci>a</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>V</ci>
         <times></times>
        </apply>
        <cn type="integer">1</cn>
       </apply>
       <cn type="integer">1</cn>
      </list>
      <ci>H</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <list>
       <apply>
        <times></times>
        <ci>π</ci>
        <ci>a</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>V</ci>
         <times></times>
        </apply>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>V</ci>
         <times></times>
        </apply>
        <cn type="integer">1</cn>
       </apply>
      </list>
      <ci>K</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <list>
       <apply>
        <times></times>
        <ci>π</ci>
        <ci>a</ci>
        <ci>ξ</ci>
       </apply>
       <ci>ξ</ci>
      </list>
      <ci>K</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Phi(a)=V\pi(a)V^{*}=\langle V\pi(a)V^{*}1,1\rangle_{H}=\langle\pi(a)V^{*}1,V^%
{*}1\rangle_{K}=\langle\pi(a)\xi,\xi\rangle_{K}
  </annotation>
 </semantics>
</math>

</p>

<p>and we have recovered the GNS representation of states. This is one way to see that completely positive maps, rather than merely positive ones, are the true generalizations of positive functionals.</p>

<p>A linear positive functional on a C*-algebra is absolutely continuous with respect to another such (called reference) functional if it is zero on any positive element on which the reference positive functional is zero. This leads to a noncommutative generalization of <a href="Radon-Nikodym_theorem" title="wikilink">Radon-Nikodym theorem</a>. The usual density operator of states on the matrix algebras with respect to the standard trace is nothing but the Radon-Nikodym derivative when the reference functional is chosen to be trace. <a href="Viacheslav_Belavkin" title="wikilink">Belavkin</a> introduced the notion of complete absolute continuity of one completely positive map with respect to another (reference) map and proved an operator variant of the noncommutative Radon-Nikodym theorem for completely positive maps. A particular case of this theorem corresponding to a tracial completely positive reference map on the matrix algebras leads to the Choi operator as a Radon-Nikodym derivative of a CP map with respect to the standard trace (see Choi's Theorem).</p>
<h3 id="chois-theorem"><a href="Choi's_theorem_on_completely_positive_maps" title="wikilink">Choi's theorem</a></h3>

<p>It was shown by Choi that if 

<math display="inline" id="Stinespring_factorization_theorem:37">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Φ</mi>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mi>B</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>G</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>→</mo>
    <mrow>
     <mi>B</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>H</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>normal-Φ</ci>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <times></times>
      <ci>B</ci>
      <ci>G</ci>
     </apply>
     <apply>
      <times></times>
      <ci>B</ci>
      <ci>H</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Phi:B(G)\to B(H)
  </annotation>
 </semantics>
</math>

 is completely positive, where <em>G</em> and <em>H</em> are finite-dimensional Hilbert spaces of dimensions <em>n</em> and <em>m</em> respectively, then Φ takes the form:</p>

<p>

<math display="block" id="Stinespring_factorization_theorem:38">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi mathvariant="normal">Φ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>a</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mrow>
       <mi>n</mi>
       <mi>m</mi>
      </mrow>
     </munderover>
     <mrow>
      <msub>
       <mi>V</mi>
       <mi>i</mi>
      </msub>
      <mi>a</mi>
      <msubsup>
       <mi>V</mi>
       <mi>i</mi>
       <mo>*</mo>
      </msubsup>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>normal-Φ</ci>
     <ci>a</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>n</ci>
       <ci>m</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>V</ci>
       <ci>i</ci>
      </apply>
      <ci>a</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>V</ci>
        <ci>i</ci>
       </apply>
       <times></times>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Phi(a)=\sum_{i=1}^{nm}V_{i}aV_{i}^{*}.
  </annotation>
 </semantics>
</math>

</p>

<p>Choi proved this using linear algebra techniques, but his result can also be viewed as a special case of Stinespring's theorem: Let (π, <em>V</em>, <em>K</em>) be a minimal Stinespring representation of Φ. By minimality, <em>K</em> has dimension less than that of 

<math display="inline" id="Stinespring_factorization_theorem:39">
 <semantics>
  <mrow>
   <msup>
    <mi>C</mi>
    <mrow>
     <mi>n</mi>
     <mo>×</mo>
     <mi>n</mi>
    </mrow>
   </msup>
   <mo>⊗</mo>
   <msup>
    <mi>C</mi>
    <mi>m</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">tensor-product</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>C</ci>
     <apply>
      <times></times>
      <ci>n</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>C</ci>
     <ci>m</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C^{n\times n}\otimes C^{m}
  </annotation>
 </semantics>
</math>

. So without loss of generality, <em>K</em> can be identified with</p>

<p>

<math display="block" id="Stinespring_factorization_theorem:40">
 <semantics>
  <mrow>
   <mrow>
    <mi>K</mi>
    <mo>=</mo>
    <mrow>
     <msubsup>
      <mo>⊕</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mrow>
       <mi>n</mi>
       <mi>m</mi>
      </mrow>
     </msubsup>
     <msubsup>
      <mi>C</mi>
      <mi>i</mi>
      <mi>n</mi>
     </msubsup>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>K</ci>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <csymbol cd="latexml">direct-sum</csymbol>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>n</ci>
       <ci>m</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>C</ci>
       <ci>i</ci>
      </apply>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K=\oplus_{i=1}^{nm}C_{i}^{n}.
  </annotation>
 </semantics>
</math>

</p>

<p>Each 

<math display="inline" id="Stinespring_factorization_theorem:41">
 <semantics>
  <msubsup>
   <mi>C</mi>
   <mi>i</mi>
   <mi>n</mi>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <ci>i</ci>
    </apply>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{i}^{n}
  </annotation>
 </semantics>
</math>

 is a copy of the <em>n</em>-dimensional Hilbert space. From 

<math display="inline" id="Stinespring_factorization_theorem:42">
 <semantics>
  <mrow>
   <mrow>
    <mi>π</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>a</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>b</mi>
      <mo>⊗</mo>
      <mi>g</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>a</mi>
     <mi>b</mi>
    </mrow>
    <mo>⊗</mo>
    <mi>g</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>π</ci>
     <ci>a</ci>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <ci>b</ci>
      <ci>g</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">tensor-product</csymbol>
     <apply>
      <times></times>
      <ci>a</ci>
      <ci>b</ci>
     </apply>
     <ci>g</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi(a)(b\otimes g)=ab\otimes g
  </annotation>
 </semantics>
</math>

, we see that the above identification of <em>K</em> can be arranged so 

<math display="inline" id="Stinespring_factorization_theorem:43">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mpadded lspace="2.8pt" width="+2.8pt">
      <mi>P</mi>
     </mpadded>
     <mi>i</mi>
    </msub>
    <mi>π</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>a</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <msub>
     <mi>P</mi>
     <mi>i</mi>
    </msub>
   </mrow>
   <mo>=</mo>
   <mi>a</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>P</ci>
      <ci>i</ci>
     </apply>
     <ci>π</ci>
     <ci>a</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>P</ci>
      <ci>i</ci>
     </apply>
    </apply>
    <ci>a</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \;P_{i}\pi(a)P_{i}=a
  </annotation>
 </semantics>
</math>

, where <em>P<sub>i</sub></em> is the projection from <em>K</em> to 

<math display="inline" id="Stinespring_factorization_theorem:44">
 <semantics>
  <msubsup>
   <mi>C</mi>
   <mi>i</mi>
   <mi>n</mi>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <ci>i</ci>
    </apply>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{i}^{n}
  </annotation>
 </semantics>
</math>

. Let 

<math display="inline" id="Stinespring_factorization_theorem:45">
 <semantics>
  <mrow>
   <msubsup>
    <mi>V</mi>
    <mi>i</mi>
    <mo>*</mo>
   </msubsup>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>P</mi>
     <mi>i</mi>
    </msub>
    <msup>
     <mi>V</mi>
     <mo>*</mo>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>V</ci>
      <ci>i</ci>
     </apply>
     <times></times>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>P</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>V</ci>
      <times></times>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V_{i}^{*}=P_{i}V^{*}
  </annotation>
 </semantics>
</math>

. We have</p>

<p>

<math display="block" id="Stinespring_factorization_theorem:46">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">Φ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>a</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mrow>
      <mi>n</mi>
      <mi>m</mi>
     </mrow>
    </munderover>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>V</mi>
       <msub>
        <mi>P</mi>
        <mi>i</mi>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>P</mi>
        <mi>i</mi>
       </msub>
       <mi>π</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>a</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <msub>
        <mi>P</mi>
        <mi>i</mi>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>P</mi>
        <mi>i</mi>
       </msub>
       <msup>
        <mi>V</mi>
        <mo>*</mo>
       </msup>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mrow>
      <mi>n</mi>
      <mi>m</mi>
     </mrow>
    </munderover>
    <mrow>
     <msub>
      <mi>V</mi>
      <mi>i</mi>
     </msub>
     <mi>a</mi>
     <msubsup>
      <mi>V</mi>
      <mi>i</mi>
      <mo>*</mo>
     </msubsup>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>normal-Φ</ci>
      <ci>a</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <times></times>
        <ci>n</ci>
        <ci>m</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <times></times>
        <ci>V</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>P</ci>
         <ci>i</ci>
        </apply>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>P</ci>
         <ci>i</ci>
        </apply>
        <ci>π</ci>
        <ci>a</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>P</ci>
         <ci>i</ci>
        </apply>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>P</ci>
         <ci>i</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>V</ci>
         <times></times>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <times></times>
        <ci>n</ci>
        <ci>m</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>V</ci>
        <ci>i</ci>
       </apply>
       <ci>a</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>V</ci>
         <ci>i</ci>
        </apply>
        <times></times>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Phi(a)=\sum_{i=1}^{nm}(VP_{i})(P_{i}\pi(a)P_{i})(P_{i}V^{*})=\sum_{i=1}^{nm}V%
_{i}aV_{i}^{*}
  </annotation>
 </semantics>
</math>

</p>

<p>and Choi's result is proved.</p>

<p>Choi's result is a particular case of noncommutative Radon-Nikodym theorem for completely positive (CP) maps corresponding to a tracial completely positive reference map on the matrix algebras. In strong operator form this general theorem was proven by Belavkin in 1985 who showed the existence of the positive density operator representing a CP map which is completely absolutely continuous with respect to a reference CP map. The uniqueness of this density operator in the reference Steinspring representation simply follows from the minimality of this representation. Thus, Choi's operator is the Radon-Nikodym derivative of a finite-dimensional CP map with respect to the standard trace.</p>

<p>Notice that, in proving Choi's theorem, as well as Belavkin's theorem from Stinespring's formulation, the argument does not give the Kraus operators <em>V<sub>i</sub></em> explicitly, unless one makes the various identification of spaces explicit. On the other hand, Choi's original proof involves direct calculation of those operators.</p>
<h3 id="naimarks-dilation-theorem"><a href="Naimark's_dilation_theorem" title="wikilink">Naimark's dilation theorem</a></h3>

<p>Naimark's theorem says that every <em>B(H)</em>-valued, weakly countably-additive measure on some compact Hausdorff space <em>X</em> can be "lifted" so that the measure becomes a spectral measure. It can be proved by combining the fact that <em>C(X)</em> is a commutative C*-algebra and Stinespring's theorem.</p>
<h3 id="sz.-nagys-dilation-theorem"><a href="Sz.-Nagy's_dilation_theorem" title="wikilink">Sz.-Nagy's dilation theorem</a></h3>

<p>This result states that every contraction on a Hilbert space has a <a href="unitary_dilation" title="wikilink">unitary dilation</a> with the minimality property.</p>
<h2 id="application">Application</h2>

<p>In <a href="quantum_information_theory" title="wikilink">quantum information theory</a>, <a href="quantum_channel" title="wikilink">quantum channels</a>, or <a href="quantum_operation" title="wikilink">quantum operations</a>, are defined to be completely positive maps between C*-algebras. Being a classification for all such maps, Stinespring's theorem is important in that context. For example, the uniqueness part of the theorem has been used to classify certain classes of quantum channels.</p>

<p>For the comparison of different channels and computation of their mutual fidelities and information another representation of the channels by their "Radon-Nikodym" derivatives introduced by Belavkin is useful. In the finite-dimensional case, Choi's theorem as the tracial variant of the Belavkin's Radon-Nikodym theorem for completely positive maps is also relevant. The operators 

<math display="inline" id="Stinespring_factorization_theorem:47">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <msub>
    <mi>V</mi>
    <mi>i</mi>
   </msub>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>V</ci>
     <ci>i</ci>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{V_{i}\}
  </annotation>
 </semantics>
</math>

 from the expression</p>

<p>

<math display="block" id="Stinespring_factorization_theorem:48">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi mathvariant="normal">Φ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>a</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mrow>
       <mi>n</mi>
       <mi>m</mi>
      </mrow>
     </munderover>
     <mrow>
      <msub>
       <mi>V</mi>
       <mi>i</mi>
      </msub>
      <mi>a</mi>
      <msubsup>
       <mi>V</mi>
       <mi>i</mi>
       <mo>*</mo>
      </msubsup>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>normal-Φ</ci>
     <ci>a</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>n</ci>
       <ci>m</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>V</ci>
       <ci>i</ci>
      </apply>
      <ci>a</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>V</ci>
        <ci>i</ci>
       </apply>
       <times></times>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Phi(a)=\sum_{i=1}^{nm}V_{i}aV_{i}^{*}.
  </annotation>
 </semantics>
</math>

</p>

<p>are called the <strong>Kraus operators</strong> of Φ. The expression</p>

<p>

<math display="block" id="Stinespring_factorization_theorem:49">
 <semantics>
  <mrow>
   <munderover>
    <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
    <mrow>
     <mi>i</mi>
     <mo>=</mo>
     <mn>1</mn>
    </mrow>
    <mrow>
     <mi>n</mi>
     <mi>m</mi>
    </mrow>
   </munderover>
   <mrow>
    <msub>
     <mi>V</mi>
     <mi>i</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mo>⋅</mo>
     <mo stretchy="false">)</mo>
    </mrow>
    <msubsup>
     <mi>V</mi>
     <mi>i</mi>
     <mo>*</mo>
    </msubsup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <eq></eq>
       <ci>i</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>n</ci>
      <ci>m</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>V</ci>
      <ci>i</ci>
     </apply>
     <ci>normal-⋅</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>V</ci>
       <ci>i</ci>
      </apply>
      <times></times>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{i=1}^{nm}V_{i}(\cdot)V_{i}^{*}
  </annotation>
 </semantics>
</math>

</p>

<p>is sometimes called the <strong>operator sum representation</strong> of Φ.</p>
<h2 id="references">References</h2>
<ul>
<li>M. Choi, <em>Completely Positive Linear Maps on Complex matrices</em>, Linear Algebra and Its Applications, 285–290, 1975</li>
<li>V. P. Belavkin, P. Staszewski, <em>Radon-Nikodym Theorem for Completely Positive Maps</em>, Reports on Mathematical Physics, v.24, No 1, 49–55, 1986.</li>
<li>V. Paulsen, <em>Completely Bounded Maps and Operator Algebras</em>, Cambridge University Press, 2003.</li>
<li>W. F. Stinespring, <em>Positive Functions on C*-algebras</em>, Proceedings of the American Mathematical Society, 211–216, 1955</li>
</ul>

<p>"</p>

<p><a href="Category:Operator_theory" title="wikilink">Category:Operator theory</a> <a href="Category:Operator_algebras" title="wikilink">Category:Operator algebras</a> <a href="Category:Theorems_in_functional_analysis" title="wikilink">Category:Theorems in functional analysis</a></p>
</body>
</html>
