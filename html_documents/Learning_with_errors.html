<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="856">Learning with errors</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Learning with errors</h1>
<hr>'''Learning with errors (LWE)''' is a problem in [[machine learning]] that is conjectured to be hard to solve. It is a generalization of the [[parity learning]] problem, introduced<ref name="regev05"></ref> by Oded Regev in 2005. Regev showed, furthermore, that the LWE problem is as hard to solve as several worst-case [[lattice problems]]. The LWE problem has recently<ref name="regev05">Oded Regev, â€œOn lattices, learning with errors, random linear codes, and cryptography,â€ in Proceedings of the thirt
<p>y-seventh annual ACM symposium on Theory of computing (Baltimore, MD, USA: ACM, 2005), 84-93, <a class="uri" href="http://portal.acm.org/citation.cfm?id=1060590.1060603">http://portal.acm.org/citation.cfm?id=1060590.1060603</a>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> been used as a <a href="Computational_hardness_assumption" title="wikilink">hardness assumption</a> to create <a href="Public-key_cryptography" title="wikilink">public-key cryptosystems</a>. such as the <a href="ring_learning_with_errors_key_exchange" title="wikilink">ring learning with errors key exchange</a> by Peikert.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>

<p>An algorithm is said to solve the LWE problem if, when given access to samples 

<math display="inline" id="Learning_with_errors:0">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>x</mi>
   <mo>,</mo>
   <mi>y</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>x</ci>
    <ci>y</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x,y)
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Learning_with_errors:1">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>âˆˆ</mo>
   <msubsup>
    <mi>â„¤</mi>
    <mi>q</mi>
    <mi>n</mi>
   </msubsup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>x</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>â„¤</ci>
      <ci>q</ci>
     </apply>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\in\mathbb{Z}_{q}^{n}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Learning_with_errors:2">
 <semantics>
  <mrow>
   <mi>y</mi>
   <mo>âˆˆ</mo>
   <msub>
    <mi>â„¤</mi>
    <mi>q</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>y</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>â„¤</ci>
     <ci>q</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y\in\mathbb{Z}_{q}
  </annotation>
 </semantics>
</math>

, with the assurance, for some fixed <a href="linear_function" title="wikilink">linear function</a> 

<math display="inline" id="Learning_with_errors:3">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mo>:</mo>
    <mrow>
     <msubsup>
      <mi>â„¤</mi>
      <mi>q</mi>
      <mi>n</mi>
     </msubsup>
     <mo>â†’</mo>
     <msub>
      <mi>â„¤</mi>
      <mi>q</mi>
     </msub>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>f</ci>
    <apply>
     <ci>normal-â†’</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>â„¤</ci>
       <ci>q</ci>
      </apply>
      <ci>n</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>â„¤</ci>
      <ci>q</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f:\mathbb{Z}_{q}^{n}\rightarrow\mathbb{Z}_{q},
  </annotation>
 </semantics>
</math>


 that 

<math display="inline" id="Learning_with_errors:4">
 <semantics>
  <mrow>
   <mi>y</mi>
   <mo>=</mo>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>y</ci>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y=f(x)
  </annotation>
 </semantics>
</math>

 with high probability and deviates from it according to some known noise model, the algorithm can recreate 

<math display="inline" id="Learning_with_errors:5">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 or some close approximation of it with high probability.</p>
<h2 id="definition">Definition</h2>

<p>Denote by 

<math display="inline" id="Learning_with_errors:6">
 <semantics>
  <mrow>
   <mi>ğ•‹</mi>
   <mo>=</mo>
   <mrow>
    <mi>â„</mi>
    <mo>/</mo>
    <mi>â„¤</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>ğ•‹</ci>
    <apply>
     <divide></divide>
     <ci>â„</ci>
     <ci>â„¤</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{T}=\mathbb{R}/\mathbb{Z}
  </annotation>
 </semantics>
</math>

 the additive group on reals modulo one. Denote by 

<math display="inline" id="Learning_with_errors:7">
 <semantics>
  <msub>
   <mi>A</mi>
   <mrow>
    <mi>ğ¬</mi>
    <mo>,</mo>
    <mi>Ï•</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>A</ci>
    <list>
     <ci>ğ¬</ci>
     <ci>Ï•</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{\mathbf{s},\phi}
  </annotation>
 </semantics>
</math>

 the distribution on 

<math display="inline" id="Learning_with_errors:8">
 <semantics>
  <mrow>
   <msubsup>
    <mi>â„¤</mi>
    <mi>q</mi>
    <mi>n</mi>
   </msubsup>
   <mo>Ã—</mo>
   <mi>ğ•‹</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>â„¤</ci>
      <ci>q</ci>
     </apply>
     <ci>n</ci>
    </apply>
    <ci>ğ•‹</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{Z}_{q}^{n}\times\mathbb{T}
  </annotation>
 </semantics>
</math>


 obtained by choosing a vector 

<math display="inline" id="Learning_with_errors:9">
 <semantics>
  <mrow>
   <mi>ğš</mi>
   <mo>âˆˆ</mo>
   <msubsup>
    <mi>â„¤</mi>
    <mi>q</mi>
    <mi>n</mi>
   </msubsup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>ğš</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>â„¤</ci>
      <ci>q</ci>
     </apply>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{a}\in\mathbb{Z}_{q}^{n}
  </annotation>
 </semantics>
</math>

 uniformly at random, choosing 

<math display="inline" id="Learning_with_errors:10">
 <semantics>
  <mi>e</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>e</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e
  </annotation>
 </semantics>
</math>

 according to a probability distribution 

<math display="inline" id="Learning_with_errors:11">
 <semantics>
  <mi>Ï•</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Ï•</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi
  </annotation>
 </semantics>
</math>

 on 

<math display="inline" id="Learning_with_errors:12">
 <semantics>
  <mi>ğ•‹</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ğ•‹</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{T}
  </annotation>
 </semantics>
</math>

 and outputting 

<math display="inline" id="Learning_with_errors:13">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>ğš</mi>
   <mo>,</mo>
   <mrow>
    <mrow>
     <mrow>
      <mo stretchy="false">âŸ¨</mo>
      <mi>ğš</mi>
      <mo>,</mo>
      <mi>ğ¬</mi>
      <mo stretchy="false">âŸ©</mo>
     </mrow>
     <mo>/</mo>
     <mi>q</mi>
    </mrow>
    <mo>+</mo>
    <mi>e</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>ğš</ci>
    <apply>
     <plus></plus>
     <apply>
      <divide></divide>
      <list>
       <ci>ğš</ci>
       <ci>ğ¬</ci>
      </list>
      <ci>q</ci>
     </apply>
     <ci>e</ci>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\mathbf{a},\langle\mathbf{a},\mathbf{s}\rangle/q+e)
  </annotation>
 </semantics>
</math>


 for some fixed vector 

<math display="inline" id="Learning_with_errors:14">
 <semantics>
  <mrow>
   <mi>ğ¬</mi>
   <mo>âˆˆ</mo>
   <msubsup>
    <mi>â„¤</mi>
    <mi>q</mi>
    <mi>n</mi>
   </msubsup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>ğ¬</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>â„¤</ci>
      <ci>q</ci>
     </apply>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{s}\in\mathbb{Z}_{q}^{n}
  </annotation>
 </semantics>
</math>

. Here 

<math display="inline" id="Learning_with_errors:15">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">âŸ¨</mo>
    <mi>ğš</mi>
    <mo>,</mo>
    <mi>ğ¬</mi>
    <mo stretchy="false">âŸ©</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">âˆ‘</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>n</mi>
    </msubsup>
    <mrow>
     <msub>
      <mi>a</mi>
      <mi>i</mi>
     </msub>
     <msub>
      <mi>s</mi>
      <mi>i</mi>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <list>
     <ci>ğš</ci>
     <ci>ğ¬</ci>
    </list>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>n</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>s</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle\langle\mathbf{a},\mathbf{s}\rangle=\sum_{i=1}^{n}a_{i}s_{i}
  </annotation>
 </semantics>
</math>

 is the standard inner product 

<math display="inline" id="Learning_with_errors:16">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mi>â„¤</mi>
     <mi>q</mi>
     <mi>n</mi>
    </msubsup>
    <mo>Ã—</mo>
    <msubsup>
     <mi>â„¤</mi>
     <mi>q</mi>
     <mi>n</mi>
    </msubsup>
   </mrow>
   <mo>âŸ¶</mo>
   <msub>
    <mi>â„¤</mi>
    <mi>q</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-âŸ¶</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>â„¤</ci>
       <ci>q</ci>
      </apply>
      <ci>n</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>â„¤</ci>
       <ci>q</ci>
      </apply>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>â„¤</ci>
     <ci>q</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{Z}_{q}^{n}\times\mathbb{Z}_{q}^{n}\longrightarrow\mathbb{Z}_{q}
  </annotation>
 </semantics>
</math>

, the division is done in the <a href="field_of_reals" title="wikilink">field of reals</a> (or more formally, this "division by 

<math display="inline" id="Learning_with_errors:17">
 <semantics>
  <mi>q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q
  </annotation>
 </semantics>
</math>

" is notation for the group homomorphism 

<math display="inline" id="Learning_with_errors:18">
 <semantics>
  <mrow>
   <msub>
    <mi>â„¤</mi>
    <mi>q</mi>
   </msub>
   <mo>âŸ¶</mo>
   <mi>ğ•‹</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-âŸ¶</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>â„¤</ci>
     <ci>q</ci>
    </apply>
    <ci>ğ•‹</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{Z}_{q}\longrightarrow\mathbb{T}
  </annotation>
 </semantics>
</math>


 mapping 

<math display="inline" id="Learning_with_errors:19">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>âˆˆ</mo>
   <msub>
    <mi>â„¤</mi>
    <mi>q</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <cn type="integer">1</cn>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>â„¤</ci>
     <ci>q</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1\in\mathbb{Z}_{q}
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Learning_with_errors:20">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mn>1</mn>
     <mo>/</mo>
     <mi>q</mi>
    </mrow>
    <mo>+</mo>
    <mi>â„¤</mi>
   </mrow>
   <mo>âˆˆ</mo>
   <mi>ğ•‹</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <plus></plus>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <ci>q</ci>
     </apply>
     <ci>â„¤</ci>
    </apply>
    <ci>ğ•‹</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1/q+\mathbb{Z}\in\mathbb{T}
  </annotation>
 </semantics>
</math>

), and the final addition is in 

<math display="inline" id="Learning_with_errors:21">
 <semantics>
  <mi>ğ•‹</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ğ•‹</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{T}
  </annotation>
 </semantics>
</math>

.</p>

<p>The <strong>learning with errors problem</strong> 

<math display="inline" id="Learning_with_errors:22">
 <semantics>
  <msub>
   <mi>LWE</mi>
   <mrow>
    <mi>q</mi>
    <mo>,</mo>
    <mi>Ï•</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>LWE</ci>
    <list>
     <ci>q</ci>
     <ci>Ï•</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{LWE}_{q,\phi}
  </annotation>
 </semantics>
</math>

 is to find 

<math display="inline" id="Learning_with_errors:23">
 <semantics>
  <mrow>
   <mi>ğ¬</mi>
   <mo>âˆˆ</mo>
   <msubsup>
    <mi>â„¤</mi>
    <mi>q</mi>
    <mi>n</mi>
   </msubsup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>ğ¬</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>â„¤</ci>
      <ci>q</ci>
     </apply>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{s}\in\mathbb{Z}_{q}^{n}
  </annotation>
 </semantics>
</math>


, given access to polynomially many samples of choice from 

<math display="inline" id="Learning_with_errors:24">
 <semantics>
  <msub>
   <mi>A</mi>
   <mrow>
    <mi>ğ¬</mi>
    <mo>,</mo>
    <mi>Ï•</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>A</ci>
    <list>
     <ci>ğ¬</ci>
     <ci>Ï•</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{\mathbf{s},\phi}
  </annotation>
 </semantics>
</math>

.</p>

<p>For every 

<math display="inline" id="Learning_with_errors:25">
 <semantics>
  <mrow>
   <mi>Î±</mi>
   <mo>></mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <ci>Î±</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha>0
  </annotation>
 </semantics>
</math>

, denote by 

<math display="inline" id="Learning_with_errors:26">
 <semantics>
  <msub>
   <mi>D</mi>
   <mi>Î±</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>D</ci>
    <ci>Î±</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D_{\alpha}
  </annotation>
 </semantics>
</math>

 the one-dimensional <a href="Normal_distribution" title="wikilink">Gaussian</a> with density function 

<math display="inline" id="Learning_with_errors:27">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>D</mi>
     <mi>Î±</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>Ï</mi>
      <mi>Î±</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>/</mo>
    <mi>Î±</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>D</ci>
      <ci>Î±</ci>
     </apply>
     <ci>x</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Ï</ci>
       <ci>Î±</ci>
      </apply>
      <ci>x</ci>
     </apply>
     <ci>Î±</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D_{\alpha}(x)=\rho_{\alpha}(x)/\alpha
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Learning_with_errors:28">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>Ï</mi>
     <mi>Î±</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msup>
    <mi>e</mi>
    <mrow>
     <mo>-</mo>
     <mrow>
      <mi>Ï€</mi>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mrow>
          <mo stretchy="false">|</mo>
          <mi>x</mi>
          <mo stretchy="false">|</mo>
         </mrow>
         <mo>/</mo>
         <mi>Î±</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mn>2</mn>
      </msup>
     </mrow>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Ï</ci>
      <ci>Î±</ci>
     </apply>
     <ci>x</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>e</ci>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>Ï€</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <divide></divide>
         <apply>
          <abs></abs>
          <ci>x</ci>
         </apply>
         <ci>Î±</ci>
        </apply>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho_{\alpha}(x)=e^{-\pi(|x|/\alpha)^{2}}
  </annotation>
 </semantics>
</math>


, and let 

<math display="inline" id="Learning_with_errors:29">
 <semantics>
  <msub>
   <mi mathvariant="normal">Î¨</mi>
   <mi>Î±</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>normal-Î¨</ci>
    <ci>Î±</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Psi_{\alpha}
  </annotation>
 </semantics>
</math>

 be the distribution on 

<math display="inline" id="Learning_with_errors:30">
 <semantics>
  <mi>ğ•‹</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ğ•‹</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{T}
  </annotation>
 </semantics>
</math>

 obtained by considering 

<math display="inline" id="Learning_with_errors:31">
 <semantics>
  <msub>
   <mi>D</mi>
   <mi>Î±</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>D</ci>
    <ci>Î±</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D_{\alpha}
  </annotation>
 </semantics>
</math>

 modulo one. The version of LWE considered in most of the results would be 

<math display="inline" id="Learning_with_errors:32">
 <semantics>
  <msub>
   <mi>LWE</mi>
   <mrow>
    <mi>q</mi>
    <mo>,</mo>
    <msub>
     <mi mathvariant="normal">Î¨</mi>
     <mi>Î±</mi>
    </msub>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>LWE</ci>
    <list>
     <ci>q</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-Î¨</ci>
      <ci>Î±</ci>
     </apply>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{LWE}_{q,\Psi_{\alpha}}
  </annotation>
 </semantics>
</math>

</p>
<h2 id="decision-version">Decision version</h2>

<p>The <strong>LWE</strong> problem described above is the <em>search</em> version of the problem. In the <em>decision</em> version (<strong>DLWE</strong>), the goal is to distinguish between noisy inner products and uniformly random samples from 

<math display="inline" id="Learning_with_errors:33">
 <semantics>
  <mrow>
   <msubsup>
    <mi>â„¤</mi>
    <mi>q</mi>
    <mi>n</mi>
   </msubsup>
   <mo>Ã—</mo>
   <mi>ğ•‹</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>â„¤</ci>
      <ci>q</ci>
     </apply>
     <ci>n</ci>
    </apply>
    <ci>ğ•‹</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{Z}_{q}^{n}\times\mathbb{T}
  </annotation>
 </semantics>
</math>


 (practically, some discretized version of it). Regev<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> showed that the <em>decision</em> and <em>search</em> versions are equivalent when 

<math display="inline" id="Learning_with_errors:34">
 <semantics>
  <mi>q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q
  </annotation>
 </semantics>
</math>

 is a prime bounded by some polynomial in 

<math display="inline" id="Learning_with_errors:35">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

.</p>
<h3 id="solving-decision-assuming-search">Solving decision assuming search</h3>

<p>Intuitively, if we have a procedure for the search problem, the decision version can be solved easily: just feed the input samples for the decision problem to the solver for the search problem. Denote the given samples by 

<math display="inline" id="Learning_with_errors:36">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>ğš</mi>
      <mi>ğ¢</mi>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>ğ›</mi>
      <mi>ğ¢</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
   <mo>âŠ‚</mo>
   <mrow>
    <msubsup>
     <mi>â„¤</mi>
     <mi>q</mi>
     <mi>n</mi>
    </msubsup>
    <mo>Ã—</mo>
    <mi>ğ•‹</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <set>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ğš</ci>
       <ci>ğ¢</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ğ›</ci>
       <ci>ğ¢</ci>
      </apply>
     </interval>
    </set>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>â„¤</ci>
       <ci>n</ci>
      </apply>
      <ci>q</ci>
     </apply>
     <ci>ğ•‹</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{(\mathbf{a_{i}},\mathbf{b_{i}})\}\subset\mathbb{Z}^{n}_{q}\times\mathbb{T}
  </annotation>
 </semantics>
</math>

. If the solver returns a candidate 

<math display="inline" id="Learning_with_errors:37">
 <semantics>
  <mi>ğ¬</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ğ¬</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{s}
  </annotation>
 </semantics>
</math>

, for all 

<math display="inline" id="Learning_with_errors:38">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>


, calculate 

<math display="inline" id="Learning_with_errors:39">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">âŸ¨</mo>
     <msub>
      <mi>ğš</mi>
      <mi>ğ¢</mi>
     </msub>
     <mo>,</mo>
     <mi>ğ¬</mi>
     <mo stretchy="false">âŸ©</mo>
    </mrow>
    <mo>-</mo>
    <msub>
     <mi>ğ›</mi>
     <mi>ğ¢</mi>
    </msub>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <minus></minus>
     <list>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ğš</ci>
       <ci>ğ¢</ci>
      </apply>
      <ci>ğ¬</ci>
     </list>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ğ›</ci>
      <ci>ğ¢</ci>
     </apply>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{\langle\mathbf{a_{i}},\mathbf{s}\rangle-\mathbf{b_{i}}\}
  </annotation>
 </semantics>
</math>

. If the samples are from an LWE distribution, then the results of this calculation will be distributed according 

<math display="inline" id="Learning_with_errors:40">
 <semantics>
  <mi>Ï‡</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Ï‡</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \chi
  </annotation>
 </semantics>
</math>

, but if the samples are uniformly random, these quantities will be distributed uniformly as well.</p>
<h3 id="solving-search-assuming-decision">Solving search assuming decision</h3>

<p>For the other direction, given a solver for the decision problem, the search version can be solved as follows: Recover 

<math display="inline" id="Learning_with_errors:41">
 <semantics>
  <mi>ğ¬</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ğ¬</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{s}
  </annotation>
 </semantics>
</math>

 one coordinate at a time. To obtain the first coordinate, 

<math display="inline" id="Learning_with_errors:42">
 <semantics>
  <msub>
   <mi>ğ¬</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ğ¬</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{s}_{1}
  </annotation>
 </semantics>
</math>

, make a guess 

<math display="inline" id="Learning_with_errors:43">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>âˆˆ</mo>
   <msub>
    <mi>Z</mi>
    <mi>q</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>k</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Z</ci>
     <ci>q</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k\in Z_{q}
  </annotation>
 </semantics>
</math>


, and do the following. Choose a number 

<math display="inline" id="Learning_with_errors:44">
 <semantics>
  <mrow>
   <mi>r</mi>
   <mo>âˆˆ</mo>
   <msub>
    <mi>â„¤</mi>
    <mi>q</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>r</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>â„¤</ci>
     <ci>q</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r\in\mathbb{Z}_{q}
  </annotation>
 </semantics>
</math>

 uniformly at random. Transform the given samples 

<math display="inline" id="Learning_with_errors:45">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>ğš</mi>
      <mi>ğ¢</mi>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>ğ›</mi>
      <mi>ğ¢</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
   <mo>âŠ‚</mo>
   <mrow>
    <msubsup>
     <mi>â„¤</mi>
     <mi>q</mi>
     <mi>n</mi>
    </msubsup>
    <mo>Ã—</mo>
    <mi>ğ•‹</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <set>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ğš</ci>
       <ci>ğ¢</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ğ›</ci>
       <ci>ğ¢</ci>
      </apply>
     </interval>
    </set>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>â„¤</ci>
       <ci>n</ci>
      </apply>
      <ci>q</ci>
     </apply>
     <ci>ğ•‹</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{(\mathbf{a_{i}},\mathbf{b_{i}})\}\subset\mathbb{Z}^{n}_{q}\times\mathbb{T}
  </annotation>
 </semantics>
</math>

 as follows. Calculate 

<math display="inline" id="Learning_with_errors:46">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msub>
      <mi>ğš</mi>
      <mi>ğ¢</mi>
     </msub>
     <mo>+</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>r</mi>
      <mo>,</mo>
      <mn>0</mn>
      <mo>,</mo>
      <mi mathvariant="normal">â€¦</mi>
      <mo>,</mo>
      <mn>0</mn>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>,</mo>
    <mrow>
     <msub>
      <mi>ğ›</mi>
      <mi>ğ¢</mi>
     </msub>
     <mo>+</mo>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>r</mi>
        <mi>k</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>/</mo>
      <mi>q</mi>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <interval closure="open">
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ğš</ci>
       <ci>ğ¢</ci>
      </apply>
      <vector>
       <ci>r</ci>
       <cn type="integer">0</cn>
       <ci>normal-â€¦</ci>
       <cn type="integer">0</cn>
      </vector>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ğ›</ci>
       <ci>ğ¢</ci>
      </apply>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <ci>r</ci>
        <ci>k</ci>
       </apply>
       <ci>q</ci>
      </apply>
     </apply>
    </interval>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{(\mathbf{a_{i}}+(r,0,\ldots,0),\mathbf{b_{i}}+(rk)/q)\}
  </annotation>
 </semantics>
</math>

. Send the transformed samples to the decision solver.</p>

<p>If the guess 

<math display="inline" id="Learning_with_errors:47">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 was correct, the transformation takes the distribution 

<math display="inline" id="Learning_with_errors:48">
 <semantics>
  <msub>
   <mi>A</mi>
   <mrow>
    <mi>ğ¬</mi>
    <mo>,</mo>
    <mi>Ï‡</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>A</ci>
    <list>
     <ci>ğ¬</ci>
     <ci>Ï‡</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{\mathbf{s},\chi}
  </annotation>
 </semantics>
</math>


 to itself, and otherwise, since 

<math display="inline" id="Learning_with_errors:49">
 <semantics>
  <mi>q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q
  </annotation>
 </semantics>
</math>

 is prime, it takes it to the uniform distribution. So, given a polynomial-time solver for the decision problem that errs with very small probability, since 

<math display="inline" id="Learning_with_errors:50">
 <semantics>
  <mi>q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q
  </annotation>
 </semantics>
</math>

 is bounded by some polynomial in 

<math display="inline" id="Learning_with_errors:51">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

, it only takes polynomial time to guess every possible value for 

<math display="inline" id="Learning_with_errors:52">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 and use the solver to see which one is correct.</p>

<p>After obtaining 

<math display="inline" id="Learning_with_errors:53">
 <semantics>
  <msub>
   <mi>ğ¬</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ğ¬</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{s}_{1}
  </annotation>
 </semantics>
</math>


, we follow an analogous procedure for each other coordinate 

<math display="inline" id="Learning_with_errors:54">
 <semantics>
  <msub>
   <mi>ğ¬</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ğ¬</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{s}_{j}
  </annotation>
 </semantics>
</math>

. Namely, we transform our 

<math display="inline" id="Learning_with_errors:55">
 <semantics>
  <msub>
   <mi>ğ›</mi>
   <mi>ğ¢</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ğ›</ci>
    <ci>ğ¢</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{b_{i}}
  </annotation>
 </semantics>
</math>

 samples the same way, and transform our 

<math display="inline" id="Learning_with_errors:56">
 <semantics>
  <msub>
   <mi>ğš</mi>
   <mi>ğ¢</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ğš</ci>
    <ci>ğ¢</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{a_{i}}
  </annotation>
 </semantics>
</math>

 samples by calculating 

<math display="inline" id="Learning_with_errors:57">
 <semantics>
  <mrow>
   <msub>
    <mi>ğš</mi>
    <mi>ğ¢</mi>
   </msub>
   <mo>+</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mi mathvariant="normal">â€¦</mi>
    <mo>,</mo>
    <mi>r</mi>
    <mo>,</mo>
    <mi mathvariant="normal">â€¦</mi>
    <mo>,</mo>
    <mn>0</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ğš</ci>
     <ci>ğ¢</ci>
    </apply>
    <vector>
     <cn type="integer">0</cn>
     <ci>normal-â€¦</ci>
     <ci>r</ci>
     <ci>normal-â€¦</ci>
     <cn type="integer">0</cn>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{a_{i}}+(0,\ldots,r,\ldots,0)
  </annotation>
 </semantics>
</math>

, where the 

<math display="inline" id="Learning_with_errors:58">
 <semantics>
  <mi>r</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>r</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r
  </annotation>
 </semantics>
</math>


 is in the 

<math display="inline" id="Learning_with_errors:59">
 <semantics>
  <msup>
   <mi>j</mi>
   <mrow>
    <mi>t</mi>
    <mi>h</mi>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>j</ci>
    <apply>
     <times></times>
     <ci>t</ci>
     <ci>h</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   j^{th}
  </annotation>
 </semantics>
</math>

 coordinate.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>

<p>Peikert<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> showed that this reduction, with a small modification, works for any 

<math display="inline" id="Learning_with_errors:60">
 <semantics>
  <mi>q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q
  </annotation>
 </semantics>
</math>

 that is a product of distinct, small (polynomial in 

<math display="inline" id="Learning_with_errors:61">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

) primes. The main idea is if 

<math display="inline" id="Learning_with_errors:62">
 <semantics>
  <mrow>
   <mi>q</mi>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>q</mi>
     <mn>1</mn>
    </msub>
    <msub>
     <mi>q</mi>
     <mn>2</mn>
    </msub>
    <mi mathvariant="normal">â‹¯</mi>
    <msub>
     <mi>q</mi>
     <mi>t</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>q</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>q</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>q</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-â‹¯</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>q</ci>
      <ci>t</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q=q_{1}q_{2}\cdots q_{t}
  </annotation>
 </semantics>
</math>

, for each 

<math display="inline" id="Learning_with_errors:63">
 <semantics>
  <msub>
   <mi>q</mi>
   <mi mathvariant="normal">â„“</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>q</ci>
    <ci>normal-â„“</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q_{\ell}
  </annotation>
 </semantics>
</math>


, guess and check to see if 

<math display="inline" id="Learning_with_errors:64">
 <semantics>
  <msub>
   <mi>ğ¬</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ğ¬</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{s}_{j}
  </annotation>
 </semantics>
</math>

 is congruent to 

<math display="inline" id="Learning_with_errors:65">
 <semantics>
  <mrow>
   <mn>0</mn>
   <mo lspace="2.5pt" rspace="2.5pt">mod</mo>
   <msub>
    <mi>q</mi>
    <mi mathvariant="normal">â„“</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">modulo</csymbol>
    <cn type="integer">0</cn>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>q</ci>
     <ci>normal-â„“</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0\mod q_{\ell}
  </annotation>
 </semantics>
</math>

, and then use the <a href="Chinese_remainder_theorem" title="wikilink">Chinese remainder theorem</a> to recover 

<math display="inline" id="Learning_with_errors:66">
 <semantics>
  <msub>
   <mi>ğ¬</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ğ¬</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{s}_{j}
  </annotation>
 </semantics>
</math>

.</p>
<h3 id="average-case-hardness">Average case hardness</h3>

<p>Regev<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> showed the <a href="Random_self-reducibility" title="wikilink">Random self-reducibility</a> of the <strong>LWE</strong> and <strong>DLWE</strong> problems for arbitrary 

<math display="inline" id="Learning_with_errors:67">
 <semantics>
  <mi>q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Learning_with_errors:68">
 <semantics>
  <mi>Ï‡</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Ï‡</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \chi
  </annotation>
 </semantics>
</math>


. Given samples 

<math display="inline" id="Learning_with_errors:69">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>ğš</mi>
     <mi>ğ¢</mi>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>ğ›</mi>
     <mi>ğ¢</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ğš</ci>
      <ci>ğ¢</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ğ›</ci>
      <ci>ğ¢</ci>
     </apply>
    </interval>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{(\mathbf{a_{i}},\mathbf{b_{i}})\}
  </annotation>
 </semantics>
</math>

 from 

<math display="inline" id="Learning_with_errors:70">
 <semantics>
  <msub>
   <mi>A</mi>
   <mrow>
    <mi>ğ¬</mi>
    <mo>,</mo>
    <mi>Ï‡</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>A</ci>
    <list>
     <ci>ğ¬</ci>
     <ci>Ï‡</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{\mathbf{s},\chi}
  </annotation>
 </semantics>
</math>

, it is easy to see that 

<math display="inline" id="Learning_with_errors:71">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>ğš</mi>
      <mi>ğ¢</mi>
     </msub>
     <mo>,</mo>
     <mrow>
      <msub>
       <mi>ğ›</mi>
       <mi>ğ¢</mi>
      </msub>
      <mo>+</mo>
      <mrow>
       <mo stretchy="false">âŸ¨</mo>
       <msub>
        <mi>ğš</mi>
        <mi>ğ¢</mi>
       </msub>
       <mo>,</mo>
       <mi>ğ­</mi>
       <mo stretchy="false">âŸ©</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>/</mo>
    <mi>q</mi>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <divide></divide>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ğš</ci>
       <ci>ğ¢</ci>
      </apply>
      <apply>
       <plus></plus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ğ›</ci>
        <ci>ğ¢</ci>
       </apply>
       <list>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>ğš</ci>
         <ci>ğ¢</ci>
        </apply>
        <ci>ğ­</ci>
       </list>
      </apply>
     </interval>
     <ci>q</ci>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{(\mathbf{a_{i}},\mathbf{b_{i}}+\langle\mathbf{a_{i}},\mathbf{t}\rangle)/q\}
  </annotation>
 </semantics>
</math>

 are samples from 

<math display="inline" id="Learning_with_errors:72">
 <semantics>
  <msub>
   <mi>A</mi>
   <mrow>
    <mrow>
     <mi>ğ¬</mi>
     <mo>+</mo>
     <mi>ğ­</mi>
    </mrow>
    <mo>,</mo>
    <mi>Ï‡</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>A</ci>
    <list>
     <apply>
      <plus></plus>
      <ci>ğ¬</ci>
      <ci>ğ­</ci>
     </apply>
     <ci>Ï‡</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{\mathbf{s}+\mathbf{t},\chi}
  </annotation>
 </semantics>
</math>

.</p>

<p>So, suppose there was some set 

<math display="inline" id="Learning_with_errors:73">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">ğ’®</mi>
   <mo>âŠ‚</mo>
   <msubsup>
    <mi>â„¤</mi>
    <mi>q</mi>
    <mi>n</mi>
   </msubsup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <ci>ğ’®</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>â„¤</ci>
      <ci>q</ci>
     </apply>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{S}\subset\mathbb{Z}_{q}^{n}
  </annotation>
 </semantics>
</math>


 such that 

<math display="inline" id="Learning_with_errors:74">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">|</mo>
     <mi class="ltx_font_mathcaligraphic">ğ’®</mi>
     <mo stretchy="false">|</mo>
    </mrow>
    <mo>/</mo>
    <mrow>
     <mo stretchy="false">|</mo>
     <msubsup>
      <mi>â„¤</mi>
      <mi>q</mi>
      <mi>n</mi>
     </msubsup>
     <mo stretchy="false">|</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mn>1</mn>
     <mo>/</mo>
     <mi>p</mi>
    </mrow>
    <mi>o</mi>
    <mi>l</mi>
    <mi>y</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <divide></divide>
     <apply>
      <abs></abs>
      <ci>ğ’®</ci>
     </apply>
     <apply>
      <abs></abs>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>â„¤</ci>
        <ci>q</ci>
       </apply>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <ci>p</ci>
     </apply>
     <ci>o</ci>
     <ci>l</ci>
     <ci>y</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\mathcal{S}|/|\mathbb{Z}_{q}^{n}|=1/poly(n)
  </annotation>
 </semantics>
</math>

, and for distributions 

<math display="inline" id="Learning_with_errors:75">
 <semantics>
  <msub>
   <mi>A</mi>
   <mrow>
    <msup>
     <mi>ğ¬</mi>
     <mo>â€²</mo>
    </msup>
    <mo>,</mo>
    <mi>Ï‡</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>A</ci>
    <list>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ğ¬</ci>
      <ci>normal-â€²</ci>
     </apply>
     <ci>Ï‡</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{\mathbf{s^{\prime}},\chi}
  </annotation>
 </semantics>
</math>

, with 

<math display="inline" id="Learning_with_errors:76">
 <semantics>
  <mrow>
   <msup>
    <mi>ğ¬</mi>
    <mo>â€²</mo>
   </msup>
   <mo>â†</mo>
   <mi class="ltx_font_mathcaligraphic">ğ’®</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-â†</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ğ¬</ci>
     <ci>normal-â€²</ci>
    </apply>
    <ci>ğ’®</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{s^{\prime}}\leftarrow\mathcal{S}
  </annotation>
 </semantics>
</math>

, <strong>DLWE</strong> was easy.</p>

<p>Then there would be some distinguisher 

<math display="inline" id="Learning_with_errors:77">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ğ’œ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ğ’œ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{A}
  </annotation>
 </semantics>
</math>

, who, given samples 

<math display="inline" id="Learning_with_errors:78">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>ğš</mi>
     <mi>ğ¢</mi>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>ğ›</mi>
     <mi>ğ¢</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ğš</ci>
      <ci>ğ¢</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ğ›</ci>
      <ci>ğ¢</ci>
     </apply>
    </interval>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{(\mathbf{a_{i}},\mathbf{b_{i}})\}
  </annotation>
 </semantics>
</math>


, could tell whether they were uniformly random or from 

<math display="inline" id="Learning_with_errors:79">
 <semantics>
  <msub>
   <mi>A</mi>
   <mrow>
    <msup>
     <mi>ğ¬</mi>
     <mo>â€²</mo>
    </msup>
    <mo>,</mo>
    <mi>Ï‡</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>A</ci>
    <list>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ğ¬</ci>
      <ci>normal-â€²</ci>
     </apply>
     <ci>Ï‡</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{\mathbf{s^{\prime}},\chi}
  </annotation>
 </semantics>
</math>

. If we need to distinguish uniformly random samples from 

<math display="inline" id="Learning_with_errors:80">
 <semantics>
  <msub>
   <mi>A</mi>
   <mrow>
    <mi>ğ¬</mi>
    <mo>,</mo>
    <mi>Ï‡</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>A</ci>
    <list>
     <ci>ğ¬</ci>
     <ci>Ï‡</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{\mathbf{s},\chi}
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Learning_with_errors:81">
 <semantics>
  <mi>ğ¬</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ğ¬</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{s}
  </annotation>
 </semantics>
</math>

 is chosen uniformly at random from 

<math display="inline" id="Learning_with_errors:82">
 <semantics>
  <msubsup>
   <mi>â„¤</mi>
   <mi>q</mi>
   <mi>n</mi>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>â„¤</ci>
     <ci>q</ci>
    </apply>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{Z}_{q}^{n}
  </annotation>
 </semantics>
</math>

, we could simply try different values 

<math display="inline" id="Learning_with_errors:83">
 <semantics>
  <mi>ğ­</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ğ­</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{t}
  </annotation>
 </semantics>
</math>


 sampled uniformly at random from 

<math display="inline" id="Learning_with_errors:84">
 <semantics>
  <msubsup>
   <mi>â„¤</mi>
   <mi>q</mi>
   <mi>n</mi>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>â„¤</ci>
     <ci>q</ci>
    </apply>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{Z}_{q}^{n}
  </annotation>
 </semantics>
</math>

, calculate 

<math display="inline" id="Learning_with_errors:85">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>ğš</mi>
      <mi>ğ¢</mi>
     </msub>
     <mo>,</mo>
     <mrow>
      <msub>
       <mi>ğ›</mi>
       <mi>ğ¢</mi>
      </msub>
      <mo>+</mo>
      <mrow>
       <mo stretchy="false">âŸ¨</mo>
       <msub>
        <mi>ğš</mi>
        <mi>ğ¢</mi>
       </msub>
       <mo>,</mo>
       <mi>ğ­</mi>
       <mo stretchy="false">âŸ©</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>/</mo>
    <mi>q</mi>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <divide></divide>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ğš</ci>
       <ci>ğ¢</ci>
      </apply>
      <apply>
       <plus></plus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ğ›</ci>
        <ci>ğ¢</ci>
       </apply>
       <list>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>ğš</ci>
         <ci>ğ¢</ci>
        </apply>
        <ci>ğ­</ci>
       </list>
      </apply>
     </interval>
     <ci>q</ci>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{(\mathbf{a_{i}},\mathbf{b_{i}}+\langle\mathbf{a_{i}},\mathbf{t}\rangle)/q\}
  </annotation>
 </semantics>
</math>

 and feed these samples to 

<math display="inline" id="Learning_with_errors:86">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ğ’œ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ğ’œ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{A}
  </annotation>
 </semantics>
</math>

. Since 

<math display="inline" id="Learning_with_errors:87">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ğ’®</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ğ’®</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{S}
  </annotation>
 </semantics>
</math>

 comprises a large fraction of 

<math display="inline" id="Learning_with_errors:88">
 <semantics>
  <msubsup>
   <mi>â„¤</mi>
   <mi>q</mi>
   <mi>n</mi>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>â„¤</ci>
     <ci>q</ci>
    </apply>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{Z}_{q}^{n}
  </annotation>
 </semantics>
</math>


, with high probability, if we choose a polynomial number of values for 

<math display="inline" id="Learning_with_errors:89">
 <semantics>
  <mi>ğ­</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ğ­</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{t}
  </annotation>
 </semantics>
</math>

, we will find one such that 

<math display="inline" id="Learning_with_errors:90">
 <semantics>
  <mrow>
   <mrow>
    <mi>ğ¬</mi>
    <mo>+</mo>
    <mi>ğ­</mi>
   </mrow>
   <mo>âˆˆ</mo>
   <mi class="ltx_font_mathcaligraphic">ğ’®</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <plus></plus>
     <ci>ğ¬</ci>
     <ci>ğ­</ci>
    </apply>
    <ci>ğ’®</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{s}+\mathbf{t}\in\mathcal{S}
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="Learning_with_errors:91">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ğ’œ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ğ’œ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{A}
  </annotation>
 </semantics>
</math>

 will successfully distinguish the samples.</p>

<p>Thus, no such 

<math display="inline" id="Learning_with_errors:92">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ğ’®</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ğ’®</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{S}
  </annotation>
 </semantics>
</math>

 can exist, meaning <strong>LWE</strong> and <strong>DLWE</strong> are (up to a polynomial factor) as hard in the average case as they are in the worst case.</p>
<h2 id="hardness-results">Hardness results</h2>
<h3 id="regevs-result">Regev's result</h3>

<p>For a n-dimensional lattice 

<math display="inline" id="Learning_with_errors:93">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>


, let <em>smoothing parameter</em> 

<math display="inline" id="Learning_with_errors:94">
 <semantics>
  <mrow>
   <msub>
    <mi>Î·</mi>
    <mi>Ïµ</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>L</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Î·</ci>
     <ci>Ïµ</ci>
    </apply>
    <ci>L</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \eta_{\epsilon}(L)
  </annotation>
 </semantics>
</math>

 denote the smallest 

<math display="inline" id="Learning_with_errors:95">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Learning_with_errors:96">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>Ï</mi>
     <mrow>
      <mn>1</mn>
      <mo>/</mo>
      <mi>s</mi>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msup>
       <mi>L</mi>
       <mo>*</mo>
      </msup>
      <mo>âˆ–</mo>
      <mrow>
       <mo stretchy="false">{</mo>
       <mn>ğŸ</mn>
       <mo stretchy="false">}</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>â‰¤</mo>
   <mi>Ïµ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Ï</ci>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <ci>s</ci>
      </apply>
     </apply>
     <apply>
      <setdiff></setdiff>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>L</ci>
       <times></times>
      </apply>
      <set>
       <cn type="integer">0</cn>
      </set>
     </apply>
    </apply>
    <ci>Ïµ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho_{1/s}(L^{*}\setminus\{\mathbf{0}\})\leq\epsilon
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Learning_with_errors:97">
 <semantics>
  <msup>
   <mi>L</mi>
   <mo>*</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>L</ci>
    <times></times>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L^{*}
  </annotation>
 </semantics>
</math>

 is the dual of 

<math display="inline" id="Learning_with_errors:98">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>


 and 

<math display="inline" id="Learning_with_errors:99">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>Ï</mi>
     <mi>Î±</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msup>
    <mi>e</mi>
    <mrow>
     <mo>-</mo>
     <mrow>
      <mi>Ï€</mi>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mrow>
          <mo stretchy="false">|</mo>
          <mi>x</mi>
          <mo stretchy="false">|</mo>
         </mrow>
         <mo>/</mo>
         <mi>Î±</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mn>2</mn>
      </msup>
     </mrow>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Ï</ci>
      <ci>Î±</ci>
     </apply>
     <ci>x</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>e</ci>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>Ï€</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <divide></divide>
         <apply>
          <abs></abs>
          <ci>x</ci>
         </apply>
         <ci>Î±</ci>
        </apply>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho_{\alpha}(x)=e^{-\pi(|x|/\alpha)^{2}}
  </annotation>
 </semantics>
</math>

 is extended to sets by summing over function values at each element in the set. Let 

<math display="inline" id="Learning_with_errors:100">
 <semantics>
  <msub>
   <mi>D</mi>
   <mrow>
    <mi>L</mi>
    <mo>,</mo>
    <mi>r</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>D</ci>
    <list>
     <ci>L</ci>
     <ci>r</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D_{L,r}
  </annotation>
 </semantics>
</math>

 denote the discrete Gaussian distribution on 

<math display="inline" id="Learning_with_errors:101">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

 of width 

<math display="inline" id="Learning_with_errors:102">
 <semantics>
  <mi>r</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>r</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r
  </annotation>
 </semantics>
</math>

 for a lattice 

<math display="inline" id="Learning_with_errors:103">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>


 and real 

<math display="inline" id="Learning_with_errors:104">
 <semantics>
  <mrow>
   <mi>r</mi>
   <mo>></mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <ci>r</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r>0
  </annotation>
 </semantics>
</math>

. The probability of each 

<math display="inline" id="Learning_with_errors:105">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>âˆˆ</mo>
   <mi>L</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>x</ci>
    <ci>L</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\in L
  </annotation>
 </semantics>
</math>

 is proportional to 

<math display="inline" id="Learning_with_errors:106">
 <semantics>
  <mrow>
   <msub>
    <mi>Ï</mi>
    <mi>r</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Ï</ci>
     <ci>r</ci>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho_{r}(x)
  </annotation>
 </semantics>
</math>

.</p>

<p>The <em>discrete Gaussian sampling problem</em>(DGS) is defined as follows: An instance of 

<math display="inline" id="Learning_with_errors:107">
 <semantics>
  <mrow>
   <mi>D</mi>
   <mi>G</mi>
   <msub>
    <mi>S</mi>
    <mi>Ï•</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>D</ci>
    <ci>G</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>S</ci>
     <ci>Ï•</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   DGS_{\phi}
  </annotation>
 </semantics>
</math>

 is given by an 

<math display="inline" id="Learning_with_errors:108">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>


-dimensional lattice 

<math display="inline" id="Learning_with_errors:109">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

 and a number 

<math display="inline" id="Learning_with_errors:110">
 <semantics>
  <mrow>
   <mi>r</mi>
   <mo>â‰¥</mo>
   <mrow>
    <mi>Ï•</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>L</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <ci>r</ci>
    <apply>
     <times></times>
     <ci>Ï•</ci>
     <ci>L</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r\geq\phi(L)
  </annotation>
 </semantics>
</math>

. The goal is to output a sample from 

<math display="inline" id="Learning_with_errors:111">
 <semantics>
  <msub>
   <mi>D</mi>
   <mrow>
    <mi>L</mi>
    <mo>,</mo>
    <mi>r</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>D</ci>
    <list>
     <ci>L</ci>
     <ci>r</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D_{L,r}
  </annotation>
 </semantics>
</math>

. Regev shows that there is a reduction from 

<math display="inline" id="Learning_with_errors:112">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mi>a</mi>
   <mi>p</mi>
   <mi>S</mi>
   <mi>V</mi>
   <msub>
    <mi>P</mi>
    <mrow>
     <mn>100</mn>
     <msqrt>
      <mi>n</mi>
     </msqrt>
     <mi>Î³</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>G</ci>
    <ci>a</ci>
    <ci>p</ci>
    <ci>S</ci>
    <ci>V</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>P</ci>
     <apply>
      <times></times>
      <cn type="integer">100</cn>
      <apply>
       <root></root>
       <ci>n</ci>
      </apply>
      <ci>Î³</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   GapSVP_{100\sqrt{n}\gamma(n)}
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Learning_with_errors:113">
 <semantics>
  <mrow>
   <mi>D</mi>
   <mi>G</mi>
   <msub>
    <mi>S</mi>
    <mrow>
     <mrow>
      <mrow>
       <msqrt>
        <mi>n</mi>
       </msqrt>
       <mi>Î³</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>n</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>/</mo>
      <mi>Î»</mi>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <msup>
       <mi>L</mi>
       <mo>*</mo>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>D</ci>
    <ci>G</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>S</ci>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <apply>
         <root></root>
         <ci>n</ci>
        </apply>
        <ci>Î³</ci>
        <ci>n</ci>
       </apply>
       <ci>Î»</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>L</ci>
       <times></times>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   DGS_{\sqrt{n}\gamma(n)/\lambda(L^{*})}
  </annotation>
 </semantics>
</math>


 for any function 

<math display="inline" id="Learning_with_errors:114">
 <semantics>
  <mrow>
   <mi>Î³</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>Î³</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gamma(n)
  </annotation>
 </semantics>
</math>

.</p>

<p>Regev then shows that there exists an efficient quantum algorithm for 

<math display="inline" id="Learning_with_errors:115">
 <semantics>
  <mrow>
   <mi>D</mi>
   <mi>G</mi>
   <msub>
    <mi>S</mi>
    <mrow>
     <mrow>
      <msqrt>
       <mrow>
        <mn>2</mn>
        <mi>n</mi>
       </mrow>
      </msqrt>
      <msub>
       <mi>Î·</mi>
       <mi>Ïµ</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>L</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>/</mo>
     <mi>Î±</mi>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>D</ci>
    <ci>G</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>S</ci>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <apply>
        <root></root>
        <apply>
         <times></times>
         <cn type="integer">2</cn>
         <ci>n</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Î·</ci>
        <ci>Ïµ</ci>
       </apply>
       <ci>L</ci>
      </apply>
      <ci>Î±</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   DGS_{\sqrt{2n}\eta_{\epsilon}(L)/\alpha}
  </annotation>
 </semantics>
</math>

 given access to an oracle for 

<math display="inline" id="Learning_with_errors:116">
 <semantics>
  <mrow>
   <mi>L</mi>
   <mi>W</mi>
   <msub>
    <mi>E</mi>
    <mrow>
     <mi>q</mi>
     <mo>,</mo>
     <msub>
      <mi mathvariant="normal">Î¨</mi>
      <mi>Î±</mi>
     </msub>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>L</ci>
    <ci>W</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>E</ci>
     <list>
      <ci>q</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>normal-Î¨</ci>
       <ci>Î±</ci>
      </apply>
     </list>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   LWE_{q,\Psi_{\alpha}}
  </annotation>
 </semantics>
</math>

 for integer 

<math display="inline" id="Learning_with_errors:117">
 <semantics>
  <mi>q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Learning_with_errors:118">
 <semantics>
  <mrow>
   <mi>Î±</mi>
   <mo>âˆˆ</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>Î±</ci>
    <interval closure="open">
     <cn type="integer">0</cn>
     <cn type="integer">1</cn>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha\in(0,1)
  </annotation>
 </semantics>
</math>


 such that 

<math display="inline" id="Learning_with_errors:119">
 <semantics>
  <mrow>
   <mrow>
    <mi>Î±</mi>
    <mi>q</mi>
   </mrow>
   <mo>></mo>
   <mrow>
    <mn>2</mn>
    <msqrt>
     <mi>n</mi>
    </msqrt>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <apply>
     <times></times>
     <ci>Î±</ci>
     <ci>q</ci>
    </apply>
    <apply>
     <times></times>
     <cn type="integer">2</cn>
     <apply>
      <root></root>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha q>2\sqrt{n}
  </annotation>
 </semantics>
</math>

. This implies the hardness for 

<math display="inline" id="Learning_with_errors:120">
 <semantics>
  <mrow>
   <mi>L</mi>
   <mi>W</mi>
   <mi>E</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>L</ci>
    <ci>W</ci>
    <ci>E</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   LWE
  </annotation>
 </semantics>
</math>

. Although the proof of this assertion works for any 

<math display="inline" id="Learning_with_errors:121">
 <semantics>
  <mi>q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q
  </annotation>
 </semantics>
</math>

, for creating a cryptosystem, the 

<math display="inline" id="Learning_with_errors:122">
 <semantics>
  <mi>q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q
  </annotation>
 </semantics>
</math>

 has to be polynomial in 

<math display="inline" id="Learning_with_errors:123">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>


.</p>
<h3 id="peikerts-result">Peikert's result</h3>

<p>Peikert proves<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> that there is a probabilistic polynomial time reduction from the <a href="Lattice_problems#GapSVP" title="wikilink">

<math display="inline" id="Learning_with_errors:124">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mi>a</mi>
   <mi>p</mi>
   <mi>S</mi>
   <mi>V</mi>
   <msub>
    <mi>P</mi>
    <mrow>
     <mi>Î¶</mi>
     <mo>,</mo>
     <mi>Î³</mi>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>G</ci>
    <ci>a</ci>
    <ci>p</ci>
    <ci>S</ci>
    <ci>V</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>P</ci>
     <list>
      <ci>Î¶</ci>
      <ci>Î³</ci>
     </list>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   GapSVP_{\zeta,\gamma}
  </annotation>
 </semantics>
</math>

</a> problem in the worst case to solving 

<math display="inline" id="Learning_with_errors:125">
 <semantics>
  <mrow>
   <mi>L</mi>
   <mi>W</mi>
   <msub>
    <mi>E</mi>
    <mrow>
     <mi>q</mi>
     <mo>,</mo>
     <msub>
      <mi mathvariant="normal">Î¨</mi>
      <mi>Î±</mi>
     </msub>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>L</ci>
    <ci>W</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>E</ci>
     <list>
      <ci>q</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>normal-Î¨</ci>
       <ci>Î±</ci>
      </apply>
     </list>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   LWE_{q,\Psi_{\alpha}}
  </annotation>
 </semantics>
</math>

 using 

<math display="inline" id="Learning_with_errors:126">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mi>o</mi>
   <mi>l</mi>
   <mi>y</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>p</ci>
    <ci>o</ci>
    <ci>l</ci>
    <ci>y</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   poly(n)
  </annotation>
 </semantics>
</math>

 samples for parameters 

<math display="inline" id="Learning_with_errors:127">
 <semantics>
  <mrow>
   <mi>Î±</mi>
   <mo>âˆˆ</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>Î±</ci>
    <interval closure="open">
     <cn type="integer">0</cn>
     <cn type="integer">1</cn>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha\in(0,1)
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Learning_with_errors:128">
 <semantics>
  <mrow>
   <mrow>
    <mi>Î³</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>â‰¥</mo>
   <mrow>
    <mi>n</mi>
    <mo>/</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>Î±</mi>
      <msqrt>
       <mrow>
        <mi>log</mi>
        <mi>n</mi>
       </mrow>
      </msqrt>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <times></times>
     <ci>Î³</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <divide></divide>
     <ci>n</ci>
     <apply>
      <times></times>
      <ci>Î±</ci>
      <apply>
       <root></root>
       <apply>
        <log></log>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gamma(n)\geq n/(\alpha\sqrt{\log{n}})
  </annotation>
 </semantics>
</math>


, 

<math display="inline" id="Learning_with_errors:129">
 <semantics>
  <mrow>
   <mrow>
    <mi>Î¶</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>â‰¥</mo>
   <mrow>
    <mi>Î³</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <times></times>
     <ci>Î¶</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <times></times>
     <ci>Î³</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \zeta(n)\geq\gamma(n)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Learning_with_errors:130">
 <semantics>
  <mrow>
   <mi>q</mi>
   <mo>â‰¥</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>Î¶</mi>
    <mo>/</mo>
    <msqrt>
     <mi>n</mi>
    </msqrt>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi>Ï‰</mi>
   <msqrt>
    <mrow>
     <mi>log</mi>
     <mi>n</mi>
    </mrow>
   </msqrt>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">q</csymbol>
    <geq></geq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">Î¶</csymbol>
     <divide></divide>
     <apply>
      <root></root>
      <ci>n</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">Ï‰</csymbol>
    <apply>
     <root></root>
     <apply>
      <log></log>
      <ci>n</ci>
     </apply>
    </apply>
    <ci>normal-)</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q\geq(\zeta/\sqrt{n})\omega\sqrt{\log{n}})
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="use-in-cryptography">Use in Cryptography</h2>

<p>The <strong>LWE</strong> problem serves as a versatile problem used in construction of several<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a><a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a><a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a><a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> cryptosystems. In 2005, Regev<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> showed that the decision version of LWE is hard assuming quantum hardness of the <a href="lattice_problems" title="wikilink">lattice problems</a> 

<math display="inline" id="Learning_with_errors:131">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mi>a</mi>
   <mi>p</mi>
   <mi>S</mi>
   <mi>V</mi>
   <msub>
    <mi>P</mi>
    <mi>Î³</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>G</ci>
    <ci>a</ci>
    <ci>p</ci>
    <ci>S</ci>
    <ci>V</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>P</ci>
     <ci>Î³</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   GapSVP_{\gamma}
  </annotation>
 </semantics>
</math>

 (for 

<math display="inline" id="Learning_with_errors:132">
 <semantics>
  <mi>Î³</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Î³</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gamma
  </annotation>
 </semantics>
</math>

 as above) and 

<math display="inline" id="Learning_with_errors:133">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mi>I</mi>
   <mi>V</mi>
   <msub>
    <mi>P</mi>
    <mi>t</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>S</ci>
    <ci>I</ci>
    <ci>V</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>P</ci>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   SIVP_{t}
  </annotation>
 </semantics>
</math>


 with t=Ã•(n/

<math display="inline" id="Learning_with_errors:134">
 <semantics>
  <mi>Î±</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Î±</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>

). In 2009, Peikert<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> proved a similar result assuming only the classical hardness of the related problem <a href="Lattice_problems#GapSVP" title="wikilink">

<math display="inline" id="Learning_with_errors:135">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mi>a</mi>
   <mi>p</mi>
   <mi>S</mi>
   <mi>V</mi>
   <msub>
    <mi>P</mi>
    <mrow>
     <mi>Î¶</mi>
     <mo>,</mo>
     <mi>Î³</mi>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>G</ci>
    <ci>a</ci>
    <ci>p</ci>
    <ci>S</ci>
    <ci>V</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>P</ci>
     <list>
      <ci>Î¶</ci>
      <ci>Î³</ci>
     </list>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   GapSVP_{\zeta,\gamma}
  </annotation>
 </semantics>
</math>

</a>. The disadvantage of Peikert's result is that it bases itself on a non-standard version of an easier (when compared to SIVP) problem GapSVP.</p>
<h3 id="public-key-cryptosystem">Public-key cryptosystem</h3>

<p>Regev<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a> proposed a <a href="public-key_cryptosystem" title="wikilink">public-key cryptosystem</a> based on the hardness of the <strong>LWE</strong> problem. The cryptosystem as well as the proof of security and correctness are completely classical. The system is characterized by 

<math display="inline" id="Learning_with_errors:136">
 <semantics>
  <mrow>
   <mi>m</mi>
   <mo>,</mo>
   <mi>q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>m</ci>
    <ci>q</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m,q
  </annotation>
 </semantics>
</math>

 and a probability distribution 

<math display="inline" id="Learning_with_errors:137">
 <semantics>
  <mi>Ï‡</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Ï‡</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \chi
  </annotation>
 </semantics>
</math>

 on 

<math display="inline" id="Learning_with_errors:138">
 <semantics>
  <mi>ğ•‹</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ğ•‹</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{T}
  </annotation>
 </semantics>
</math>


. The setting of the parameters used in proofs of correctness and security is</p>
<ul>
<li>

<math display="inline" id="Learning_with_errors:139">
 <semantics>
  <mrow>
   <mi>q</mi>
   <mo>â‰¥</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <ci>q</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q\geq 2
  </annotation>
 </semantics>
</math>

, a prime number between 

<math display="inline" id="Learning_with_errors:140">
 <semantics>
  <msup>
   <mi>n</mi>
   <mn>2</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>n</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n^{2}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Learning_with_errors:141">
 <semantics>
  <mrow>
   <mn>2</mn>
   <msup>
    <mi>n</mi>
    <mn>2</mn>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <cn type="integer">2</cn>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>n</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2n^{2}
  </annotation>
 </semantics>
</math>

.</li>
<li>

<math display="inline" id="Learning_with_errors:142">
 <semantics>
  <mrow>
   <mi>m</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mn>1</mn>
      <mo>+</mo>
      <mi>Ïµ</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>n</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mi>log</mi>
     <mi>q</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>m</ci>
    <apply>
     <times></times>
     <apply>
      <plus></plus>
      <cn type="integer">1</cn>
      <ci>Ïµ</ci>
     </apply>
     <apply>
      <plus></plus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <log></log>
      <ci>q</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m=(1+\epsilon)(n+1)\log{q}
  </annotation>
 </semantics>
</math>

 for an arbitrary constant 

<math display="inline" id="Learning_with_errors:143">
 <semantics>
  <mi>Ïµ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Ïµ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon
  </annotation>
 </semantics>
</math>


</li>
<li>

<math display="inline" id="Learning_with_errors:144">
 <semantics>
  <mrow>
   <mi>Ï‡</mi>
   <mo>=</mo>
   <msub>
    <mi mathvariant="normal">Î¨</mi>
    <mrow>
     <mi>Î±</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>Ï‡</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-Î¨</ci>
     <apply>
      <times></times>
      <ci>Î±</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \chi=\Psi_{\alpha(n)}
  </annotation>
 </semantics>
</math>

 for 

<math display="inline" id="Learning_with_errors:145">
 <semantics>
  <mrow>
   <mrow>
    <mi>Î±</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>âˆˆ</mo>
   <mrow>
    <mi>o</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mn>1</mn>
       <mo>/</mo>
       <msqrt>
        <mi>n</mi>
       </msqrt>
      </mrow>
      <mrow>
       <mi>log</mi>
       <mi>n</mi>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <times></times>
     <ci>Î±</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <times></times>
     <ci>o</ci>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <apply>
        <root></root>
        <ci>n</ci>
       </apply>
      </apply>
      <apply>
       <log></log>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha(n)\in o(1/\sqrt{n}\log{n})
  </annotation>
 </semantics>
</math>

</li>
</ul>

<p>The cryptosystem is then defined by:</p>
<ul>
<li><em>Private Key</em>: Private key is an 

<math display="inline" id="Learning_with_errors:146">
 <semantics>
  <mrow>
   <mi>ğ¬</mi>
   <mo>âˆˆ</mo>
   <msubsup>
    <mi>â„¤</mi>
    <mi>q</mi>
    <mi>n</mi>
   </msubsup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>ğ¬</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>â„¤</ci>
      <ci>n</ci>
     </apply>
     <ci>q</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{s}\in\mathbb{Z}^{n}_{q}
  </annotation>
 </semantics>
</math>

 chosen uniformly at random.</li>
<li><em>Public Key</em>: Choose 

<math display="inline" id="Learning_with_errors:147">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

 vectors 

<math display="inline" id="Learning_with_errors:148">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>a</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">â€¦</mi>
    <mo>,</mo>
    <msub>
     <mi>a</mi>
     <mi>m</mi>
    </msub>
   </mrow>
   <mo>âˆˆ</mo>
   <msubsup>
    <mi>â„¤</mi>
    <mi>q</mi>
    <mi>n</mi>
   </msubsup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <list>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-â€¦</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <ci>m</ci>
     </apply>
    </list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>â„¤</ci>
      <ci>n</ci>
     </apply>
     <ci>q</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{1},\ldots,a_{m}\in\mathbb{Z}^{n}_{q}
  </annotation>
 </semantics>
</math>


 uniformly and independently. Choose error offsets 

<math display="inline" id="Learning_with_errors:149">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>e</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">â€¦</mi>
    <mo>,</mo>
    <msub>
     <mi>e</mi>
     <mi>m</mi>
    </msub>
   </mrow>
   <mo>âˆˆ</mo>
   <mi>ğ•‹</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <list>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>e</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-â€¦</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>e</ci>
      <ci>m</ci>
     </apply>
    </list>
    <ci>ğ•‹</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e_{1},\ldots,e_{m}\in\mathbb{T}
  </annotation>
 </semantics>
</math>

 independently according to 

<math display="inline" id="Learning_with_errors:150">
 <semantics>
  <mi>Ï‡</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Ï‡</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \chi
  </annotation>
 </semantics>
</math>

. The public key consists of 

<math display="inline" id="Learning_with_errors:151">
 <semantics>
  <msubsup>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>a</mi>
     <mi>i</mi>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>b</mi>
     <mi>i</mi>
    </msub>
    <mo>=</mo>
    <mrow>
     <mo stretchy="false">âŸ¨</mo>
     <msub>
      <mi>a</mi>
      <mi>i</mi>
     </msub>
     <mo>,</mo>
     <mi>ğ¬</mi>
     <mo stretchy="false">âŸ©</mo>
    </mrow>
    <mo>/</mo>
    <mi>q</mi>
    <mo>+</mo>
    <msub>
     <mi>e</mi>
     <mi>i</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mi>i</mi>
    <mo>=</mo>
    <mn>1</mn>
   </mrow>
   <mi>m</mi>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <ci>i</ci>
      </apply>
      <ci>normal-,</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <ci>i</ci>
      </apply>
      <eq></eq>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-âŸ¨</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <ci>i</ci>
       </apply>
       <ci>normal-,</ci>
       <csymbol cd="unknown">s</csymbol>
       <ci>normal-âŸ©</ci>
      </cerror>
      <divide></divide>
      <csymbol cd="unknown">q</csymbol>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>e</ci>
       <ci>i</ci>
      </apply>
      <ci>normal-)</ci>
     </cerror>
     <ci>m</ci>
    </apply>
    <apply>
     <eq></eq>
     <ci>i</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (a_{i},b_{i}=\langle a_{i},\mathbf{s}\rangle/q+e_{i})^{m}_{i=1}
  </annotation>
 </semantics>
</math>

</li>
<li><em>Encryption</em>: The encryption of a bit 

<math display="inline" id="Learning_with_errors:152">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>âˆˆ</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mn>1</mn>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>x</ci>
    <set>
     <cn type="integer">0</cn>
     <cn type="integer">1</cn>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\in\{0,1\}
  </annotation>
 </semantics>
</math>

 is done by choosing a random subset 

<math display="inline" id="Learning_with_errors:153">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>


 of 

<math display="inline" id="Learning_with_errors:154">
 <semantics>
  <mrow>
   <mo stretchy="false">[</mo>
   <mi>m</mi>
   <mo stretchy="false">]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">delimited-[]</csymbol>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [m]
  </annotation>
 </semantics>
</math>

 and then defining 

<math display="inline" id="Learning_with_errors:155">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mi>n</mi>
   <mi>c</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>E</ci>
    <ci>n</ci>
    <ci>c</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Enc(x)
  </annotation>
 </semantics>
</math>

 as 

<math display="inline" id="Learning_with_errors:156">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <msub>
     <mo largeop="true" symmetric="true">âˆ‘</mo>
     <mrow>
      <mi>i</mi>
      <mo>âˆˆ</mo>
      <mi>S</mi>
     </mrow>
    </msub>
    <msub>
     <mi>a</mi>
     <mi>i</mi>
    </msub>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mrow>
     <mi>x</mi>
     <mo>/</mo>
     <mn>2</mn>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msub>
      <mo largeop="true" symmetric="true">âˆ‘</mo>
      <mrow>
       <mi>i</mi>
       <mo>âˆˆ</mo>
       <mi>S</mi>
      </mrow>
     </msub>
     <msub>
      <mi>b</mi>
      <mi>i</mi>
     </msub>
    </mrow>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <in></in>
       <ci>i</ci>
       <ci>S</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <ci>i</ci>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <divide></divide>
      <ci>x</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <in></in>
        <ci>i</ci>
        <ci>S</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\sum_{i\in S}a_{i},x/2+\sum_{i\in S}b_{i})
  </annotation>
 </semantics>
</math>

</li>
<li><em>Decryption</em>: The decryption of 

<math display="inline" id="Learning_with_errors:157">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>a</mi>
   <mo>,</mo>
   <mi>b</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>a</ci>
    <ci>b</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (a,b)
  </annotation>
 </semantics>
</math>

 is 

<math display="inline" id="Learning_with_errors:158">
 <semantics>
  <mn>0</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">0</cn>
  </annotation-xml>
 </semantics>
</math>


 if 

<math display="inline" id="Learning_with_errors:159">
 <semantics>
  <mrow>
   <mi>b</mi>
   <mo>-</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">âŸ¨</mo>
     <mi>a</mi>
     <mo>,</mo>
     <mi>ğ¬</mi>
     <mo stretchy="false">âŸ©</mo>
    </mrow>
    <mo>/</mo>
    <mi>q</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>b</ci>
    <apply>
     <divide></divide>
     <list>
      <ci>a</ci>
      <ci>ğ¬</ci>
     </list>
     <ci>q</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b-\langle a,\mathbf{s}\rangle/q
  </annotation>
 </semantics>
</math>

 is closer to 

<math display="inline" id="Learning_with_errors:160">
 <semantics>
  <mn>0</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">0</cn>
  </annotation-xml>
 </semantics>
</math>

 than to 

<math display="inline" id="Learning_with_errors:161">
 <semantics>
  <mfrac>
   <mn>1</mn>
   <mn>2</mn>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <cn type="integer">1</cn>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{1}{2}
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="Learning_with_errors:162">
 <semantics>
  <mn>1</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">1</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1
  </annotation>
 </semantics>
</math>

 otherwise.</li>
</ul>

<p>The proof of correctness follows from choice of parameters and some probability analysis. The proof of security is by reduction to the decision version of <strong>LWE</strong>: an algorithm for distinguishing between encryptions (with above parameters) of 

<math display="inline" id="Learning_with_errors:163">
 <semantics>
  <mn>0</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">0</cn>
  </annotation-xml>
 </semantics>
</math>


 and 

<math display="inline" id="Learning_with_errors:164">
 <semantics>
  <mn>1</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">1</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1
  </annotation>
 </semantics>
</math>

 can be used to distinguish between 

<math display="inline" id="Learning_with_errors:165">
 <semantics>
  <msub>
   <mi>A</mi>
   <mrow>
    <mi>s</mi>
    <mo>,</mo>
    <mi>Ï‡</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>A</ci>
    <list>
     <ci>s</ci>
     <ci>Ï‡</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{s,\chi}
  </annotation>
 </semantics>
</math>

 and the uniform distribution over 

<math display="inline" id="Learning_with_errors:166">
 <semantics>
  <mrow>
   <msubsup>
    <mi>â„¤</mi>
    <mi>q</mi>
    <mi>n</mi>
   </msubsup>
   <mo>Ã—</mo>
   <msub>
    <mi>â„¤</mi>
    <mi>q</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>â„¤</ci>
      <ci>n</ci>
     </apply>
     <ci>q</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>â„¤</ci>
     <ci>q</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{Z}^{n}_{q}\times\mathbb{Z}_{q}
  </annotation>
 </semantics>
</math>

</p>
<h3 id="cca-secure-cryptosystem">CCA-secure cryptosystem</h3>

<p>Peikert<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a> proposed a system that is secure even against any <a href="chosen-ciphertext_attack" title="wikilink">chosen-ciphertext attack</a>.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Lattice-based_cryptography" title="wikilink">Lattice-based cryptography</a></li>
<li><a href="Ring_learning_with_errors_key_exchange" title="wikilink">Ring Learning with Errors Key Exchange</a></li>
</ul>
<h2 id="references">References</h2>
<references>
</references>

<p>"</p>

<p><a href="Category:Machine_learning" title="wikilink">Category:Machine learning</a> <a class="uri" href="Category:Cryptography" title="wikilink">Category:Cryptography</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Chris Peikert, â€œPublic-key cryptosystems from the worst-case shortest vector problem: extended abstract,â€ in Proceedings of the 41st annual ACM symposium on Theory of computing (Bethesda, MD, USA: ACM, 2009), 333-342, <a class="uri" href="http://portal.acm.org/citation.cfm?id=1536414.1536461">http://portal.acm.org/citation.cfm?id=1536414.1536461</a>.<a href="#fnref1">â†©</a></li>
<li id="fn2"><a href="#fnref2">â†©</a></li>
<li id="fn3"></li>
<li id="fn4"></li>
<li id="fn5"></li>
<li id="fn6"></li>
<li id="fn7"></li>
<li id="fn8"></li>
<li id="fn9"></li>
<li id="fn10">Chris Peikert and Brent Waters, â€œLossy trapdoor functions and their applications,â€ in Proceedings of the 40th annual ACM symposium on Theory of computing (Victoria, British Columbia, Canada: ACM, 2008), 187-196, <a class="uri" href="http://portal.acm.org/citation.cfm?id=1374406">http://portal.acm.org/citation.cfm?id=1374406</a>.<a href="#fnref10">â†©</a></li>
<li id="fn11">Craig Gentry, Chris Peikert, and Vinod Vaikuntanathan, â€œTrapdoors for hard lattices and new cryptographic constructions,â€ in Proceedings of the 40th annual ACM symposium on Theory of computing (Victoria, British Columbia, Canada: ACM, 2008), 197-206, <a class="uri" href="http://portal.acm.org/citation.cfm?id=1374407">http://portal.acm.org/citation.cfm?id=1374407</a>.<a href="#fnref11">â†©</a></li>
<li id="fn12"></li>
<li id="fn13"></li>
<li id="fn14"></li>
<li id="fn15"></li>
</ol>
</section>
</ref></hr></body>
</html>
