<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1195">Limit (category theory)</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Limit (category theory)</h1>
<hr/>

<p>In <a href="category_theory" title="wikilink">category theory</a>, a branch of <a class="uri" href="mathematics" title="wikilink">mathematics</a>, the abstract notion of a <strong>limit</strong> captures the essential properties of universal constructions such as <a href="product_(category_theory)" title="wikilink">products</a>, <a href="pullback_(category_theory)" title="wikilink">pullbacks</a> and <a href="inverse_limit" title="wikilink">inverse limits</a>. The <a href="duality_(category_theory)" title="wikilink">dual notion</a> of a <strong>colimit</strong> generalizes constructions such as <a href="disjoint_union" title="wikilink">disjoint unions</a>, <a href="direct_sum" title="wikilink">direct sums</a>, <a href="coproduct" title="wikilink">coproducts</a>, <a href="pushout_(category_theory)" title="wikilink">pushouts</a> and <a href="direct_limit" title="wikilink">direct limits</a>.</p>

<p>Limits and colimits, like the strongly related notions of <a href="universal_property" title="wikilink">universal properties</a> and <a href="adjoint_functors" title="wikilink">adjoint functors</a>, exist at a high level of abstraction. In order to understand them, it is helpful to first study the specific examples these concepts are meant to generalize.</p>
<h2 id="definition">Definition</h2>

<p>Limits and colimits in a <a href="category_(mathematics)" title="wikilink">category</a> <em>C</em> are defined by means of diagrams in <em>C</em>. Formally, a <strong><a href="diagram_(category_theory)" title="wikilink">diagram</a></strong> of type <em>J</em> in <em>C</em> is a <a class="uri" href="functor" title="wikilink">functor</a> from <em>J</em> to <em>C</em>:</p>
<dl>
<dd><em>F</em> : <em>J</em> → <em>C</em>.
</dd>
</dl>

<p>The category <em>J</em> is thought of as <a href="index_category" title="wikilink">index category</a>, and the diagram <em>F</em> is thought of as indexing a collection of objects and <a href="morphism" title="wikilink">morphisms</a> in <em>C</em> patterned on <em>J</em>.</p>

<p>One is most often interested in the case where the category <em>J</em> is a <a href="small_category" title="wikilink">small</a> or even <a href="Finite_set" title="wikilink">finite</a> category. A diagram is said to be <strong>small</strong> or <strong>finite</strong> whenever <em>J</em> is.</p>
<h3 id="limits">Limits</h3>

<p>Let <em>F</em> : <em>J</em> → <em>C</em> be a diagram of type <em>J</em> in a category <em>C</em>. A <strong><a href="cone_(category_theory)" title="wikilink">cone</a></strong> to <em>F</em> is an object <em>N</em> of <em>C</em> together with a family ψ<sub><em>X</em></sub> : <em>N</em> → <em>F</em>(<em>X</em>) of morphisms indexed by the objects <em>X</em> of <em>J</em>, such that for every morphism <em>f</em> : <em>X</em> → <em>Y</em> in <em>J</em>, we have <em>F</em>(<em>f</em>) o ψ<sub><em>X</em></sub> = ψ<sub><em>Y</em></sub>.</p>

<p>A <strong>limit</strong> of the diagram <em>F</em> : <em>J</em> → <em>C</em> is a cone (<em>L</em>, φ) to <em>F</em> such that for any other cone (<em>N</em>, ψ) to <em>F</em> there exists a <em>unique</em> morphism <em>u</em> : <em>N</em> → <em>L</em> such that φ<sub><em>X</em></sub> o <em>u</em> = ψ<sub><em>X</em></sub> for all <em>X</em> in <em>J</em>.  One says that the cone (<em>N</em>, ψ) factors through the cone (<em>L</em>, φ) with the unique factorization <em>u</em>. The morphism <em>u</em> is sometimes called the <strong>mediating morphism</strong>.</p>

<p>Limits are also referred to as <em><a href="universal_cone" title="wikilink">universal cones</a></em>, since they are characterized by a <a href="universal_property" title="wikilink">universal property</a> (see below for more information). As with every universal property, the above definition describes a balanced state of generality: The limit object <em>L</em> has to be general enough to allow any other cone to factor through it; on the other hand, <em>L</em> has to be sufficiently specific, so that only <em>one</em> such factorization is possible for every cone.</p>

<p>Limits may also be characterized as <a href="terminal_object" title="wikilink">terminal objects</a> in the <a href="category_of_cones" title="wikilink">category of cones</a> to <em>F</em>.</p>

<p>It is possible that a diagram does not have a limit at all. However, if a diagram does have a limit then this limit is essentially unique: it is unique <a href="up_to" title="wikilink">up to</a> a unique <a class="uri" href="isomorphism" title="wikilink">isomorphism</a>. For this reason one often speaks of <em>the</em> limit of <em>F</em>.</p>
<h3 id="colimits">Colimits</h3>

<p>The <a href="Dual_(category_theory)" title="wikilink">dual notions</a> of limits and cones are colimits and co-cones. Although it is straightforward to obtain the definitions of these by inverting all morphisms in the above definitions, we will explicitly state them here:</p>

<p>A <strong><a class="uri" href="co-cone" title="wikilink">co-cone</a></strong> of a diagram <em>F</em> : <em>J</em> → <em>C</em> is an object <em>N</em> of <em>C</em> together with a family of morphisms</p>
<dl>
<dd>ψ<sub><em>X</em></sub> : <em>F</em>(<em>X</em>) → <em>N</em>
</dd>
</dl>

<p>for every object <em>X</em> of <em>J</em>, such that for every morphism <em>f</em> : <em>X</em> → <em>Y</em> in <em>J</em>, we have ψ<sub><em>Y</em></sub> o <em>F</em>(<em>f</em>)= ψ<sub><em>X</em></sub>.</p>

<p>A <strong>colimit</strong> of a diagram <em>F</em> : <em>J</em> → <em>C</em> is a co-cone (<em>L</em>, 

<math display="inline" id="Limit_(category_theory):0">
 <semantics>
  <mi>ϕ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϕ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi
  </annotation>
 </semantics>
</math>

) of <em>F</em> such that for any other co-cone (<em>N</em>, ψ) of <em>F</em> there exists a unique morphism <em>u</em> : <em>L</em> → <em>N</em> such that <em>u</em> o 

<math display="inline" id="Limit_(category_theory):1">
 <semantics>
  <mi>ϕ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϕ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi
  </annotation>
 </semantics>
</math>

<sub><em>X</em></sub> = ψ<sub><em>X</em></sub> for all <em>X</em> in <em>J</em>.</p>
<figure><b>(Figure)</b>
<figcaption>A universal co-cone</figcaption>
</figure>

<p>Colimits are also referred to as <em><a href="universal_co-cone" title="wikilink">universal co-cones</a></em>. They can be characterized as <a href="initial_object" title="wikilink">initial objects</a> in the <a href="category_of_co-cones" title="wikilink">category of co-cones</a> from <em>F</em>.</p>

<p>As with limits, if a diagram <em>F</em> has a colimit then this colimit is unique up to a unique isomorphism.</p>
<h3 id="variations">Variations</h3>

<p>Limits and colimits can also be defined for collections of objects and morphisms without the use of diagrams. The definitions are the same (note that in definitions above we never needed to use composition of morphisms in <em>J</em>). This variation, however, adds no new information. Any collection of objects and morphisms defines a (possibly large) <a href="directed_graph" title="wikilink">directed graph</a> <em>G</em>. If we let <em>J</em> be the <a href="free_category" title="wikilink">free category</a> generated by <em>G</em>, there is a universal diagram <em>F</em> : <em>J</em> → <em>C</em> whose image contains <em>G</em>. The limit (or colimit) of this diagram is the same as the limit (or colimit) of the original collection of objects and morphisms.</p>

<p><strong>Weak limit</strong> and <strong>weak colimits</strong> are defined like limits and colimits, except that the uniqueness property of the mediating morphism is dropped.</p>
<h2 id="examples">Examples</h2>
<h3 id="limits-1">Limits</h3>

<p>The definition of limits is general enough to subsume several constructions useful in practical settings. In the following we will consider the limit (<em>L</em>, φ) of a diagram <em>F</em> : <em>J</em> → <em>C</em>.</p>
<ul>
<li><strong><a href="Terminal_object" title="wikilink">Terminal objects</a></strong>. If <em>J</em> is the empty category there is only one diagram of type <em>J</em>: the empty one (similar to the <a href="empty_function" title="wikilink">empty function</a> in set theory). A cone to the empty diagram is essentially just an object of <em>C</em>. The limit of <em>F</em> is any object that is uniquely factored through by every other object. This is just the definition of a <em>terminal object</em>.</li>
<li><strong><a href="Product_(category_theory)" title="wikilink">Products</a></strong>. If <em>J</em> is a <a href="discrete_category" title="wikilink">discrete category</a> then a diagram <em>F</em> is essentially nothing but a <a href="indexed_family" title="wikilink">family</a> of objects of <em>C</em>, indexed by <em>J</em>. The limit <em>L</em> of <em>F</em> is called the <em>product</em> of these objects. The cone φ consists of a family of morphisms φ<sub><em>X</em></sub> : <em>L</em> → <em>F</em>(<em>X</em>) called the <em>projections</em> of the product. In the <a href="category_of_sets" title="wikilink">category of sets</a>, for instance, the products are given by <a href="Cartesian_product" title="wikilink">Cartesian products</a> and the projections are just the natural projections onto the various factors.
<ul>
<li><strong>Powers</strong>. A special case of a product is when the diagram <em>F</em> is a constant functor to an object <em>X</em> of <em>C</em>. The limit of this diagram is called the <em>J<sup>th</sup> power</em> of <em>X</em> and denoted <em>X</em><sup><em>J</em></sup>.</li>
</ul></li>
<li><strong><a href="Equalizer_(mathematics)" title="wikilink">Equalizers</a></strong>. If <em>J</em> is a category with two objects and two parallel morphisms from object <em>1</em> to object <em>2</em> then a diagram of type <em>J</em> is a pair of parallel morphisms in <em>C</em>. The limit <em>L</em> of such a diagram is called an <em>equalizer</em> of those morphisms.
<ul>
<li><strong><a href="Kernel_(category_theory)" title="wikilink">Kernels</a></strong>. A <em>kernel</em> is a special case of an equalizer where one of the morphisms is a <a href="zero_morphism" title="wikilink">zero morphism</a>.</li>
</ul></li>
<li><strong><a href="Pullback_(category_theory)" title="wikilink">Pullbacks</a></strong>. Let <em>F</em> be a diagram that picks out three objects <em>X</em>, <em>Y</em>, and <em>Z</em> in <em>C</em>, where the only non-identity morphisms are <em>f</em> : <em>X</em> → <em>Z</em> and <em>g</em> : <em>Y</em> → <em>Z</em>. The limit <em>L</em> of <em>F</em> is called a <em>pullback</em> or a <em>fiber product</em>. It can nicely be visualized as a <a href="commutative_diagram" title="wikilink">commutative square</a>:</li>
</ul>
<figure><b>(Figure)</b>
<figcaption>Pullback_categories.svg</figcaption>
</figure>
<ul>
<li><strong><a href="Inverse_limit" title="wikilink">Inverse limits</a></strong>. Let <em>J</em> be a <a href="directed_set" title="wikilink">directed</a> <a class="uri" href="poset" title="wikilink">poset</a> (considered as a small category by adding arrows <em>i</em> → <em>j</em> if and only if <em>i</em> ≤ <em>j</em>) and let <em>F</em> : <em>J</em><sup>op</sup> → <em>C</em> be a diagram. The limit of <em>F</em> is called (confusingly) an <em>inverse limit</em> or <em>projective limit</em>.</li>
<li>If <em>J</em> = <strong>1</strong>, the category with a single object and morphism, then a diagram of type <em>J</em> is essentially just an object <em>X</em> of <em>C</em>. A cone to an object <em>X</em> is just a morphism with codomain <em>X</em>. A morphism <em>f</em> : <em>Y</em> → <em>X</em> is a limit of the diagram <em>X</em> if and only if <em>f</em> is an <a class="uri" href="isomorphism" title="wikilink">isomorphism</a>. More generally, if <em>J</em> is any category with an <a href="initial_object" title="wikilink">initial object</a> <em>i</em>, then any diagram of type <em>J</em> has a limit, namely any object isomorphic to <em>F</em>(<em>i</em>). Such an isomorphism uniquely determines a universal cone to <em>F</em>.</li>
<li><strong>Topological limits</strong>. Limits of functions are a special case of <a href="Filter_(mathematics)#Convergent_filter_bases" title="wikilink">limits of filters</a>, which are related to categorical limits as follows. Given a <a href="topological_space" title="wikilink">topological space</a> <em>X</em>, denote <em>F</em> the set of filters on <em>X</em>, <em>x</em> ∈ <em>X</em> a point, <em>V</em>(<em>x</em>) ∈ <em>F</em> the <a href="Filter_(mathematics)#Neighbourhood_bases" title="wikilink">neighborhood filter</a> of <em>x</em>, <em>A</em> ∈ <em>F</em> a particular filter and 

<math display="inline" id="Limit_(category_theory):2">
 <semantics>
  <mrow>
   <msub>
    <mi>F</mi>
    <mrow>
     <mi>x</mi>
     <mo>,</mo>
     <mi>A</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mi>G</mi>
     <mo>∈</mo>
     <mi>F</mi>
    </mrow>
    <mo>∣</mo>
    <mrow>
     <mrow>
      <mrow>
       <mi>V</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>∪</mo>
      <mi>A</mi>
     </mrow>
     <mo>⊂</mo>
     <mi>G</mi>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>F</ci>
     <list>
      <ci>x</ci>
      <ci>A</ci>
     </list>
    </apply>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <apply>
      <in></in>
      <ci>G</ci>
      <ci>F</ci>
     </apply>
     <apply>
      <subset></subset>
      <apply>
       <union></union>
       <apply>
        <times></times>
        <ci>V</ci>
        <ci>x</ci>
       </apply>
       <ci>A</ci>
      </apply>
      <ci>G</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F_{x,A}=\{G\in F\mid V(x)\cup A\subset G\}
  </annotation>
 </semantics>
</math>

 the set of filters finer than <em>A</em> and that converge to <em>x</em>. The filters <em>F</em> are given a small and thin category structure by adding an arrow <em>A</em> → <em>B</em> if and only if <em>A</em> ⊆ <em>B</em>. The injection 

<math display="inline" id="Limit_(category_theory):3">
 <semantics>
  <mrow>
   <msub>
    <mi>I</mi>
    <mrow>
     <mi>x</mi>
     <mo>,</mo>
     <mi>A</mi>
    </mrow>
   </msub>
   <mo>:</mo>
   <mrow>
    <msub>
     <mi>F</mi>
     <mrow>
      <mi>x</mi>
      <mo>,</mo>
      <mi>A</mi>
     </mrow>
    </msub>
    <mo>→</mo>
    <mi>F</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>I</ci>
     <list>
      <ci>x</ci>
      <ci>A</ci>
     </list>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>F</ci>
      <list>
       <ci>x</ci>
       <ci>A</ci>
      </list>
     </apply>
     <ci>F</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I_{x,A}:F_{x,A}\to F
  </annotation>
 </semantics>
</math>


 becomes a functor and the following equivalence holds :</li>
</ul>
<dl>
<dd><dl>
<dd><em>x</em> is a topological limit of <em>A</em> if and only if <em>A</em> is a categorical limit of 

<math display="inline" id="Limit_(category_theory):4">
 <semantics>
  <msub>
   <mi>I</mi>
   <mrow>
    <mi>x</mi>
    <mo>,</mo>
    <mi>A</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>I</ci>
    <list>
     <ci>x</ci>
     <ci>A</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I_{x,A}
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>
<h3 id="colimits-1">Colimits</h3>

<p>Examples of colimits are given by the dual versions of the examples above:</p>
<ul>
<li><strong><a href="Initial_object" title="wikilink">Initial objects</a></strong> are colimits of empty diagrams.</li>
<li><strong><a href="Coproduct" title="wikilink">Coproducts</a></strong> are colimits of diagrams indexed by discrete categories.
<ul>
<li><strong>Copowers</strong> are colimits of constant diagrams from discrete categories.</li>
</ul></li>
<li><strong><a href="Coequalizer" title="wikilink">Coequalizers</a></strong> are colimits of a parallel pair of morphisms.
<ul>
<li><strong><a href="Cokernel" title="wikilink">Cokernels</a></strong> are coequalizers of a morphism and a parallel zero morphism.</li>
</ul></li>
<li><strong><a href="Pushout_(category_theory)" title="wikilink">Pushouts</a></strong> are colimits of a pair of morphisms with common domain.</li>
<li><strong><a href="Direct_limit" title="wikilink">Direct limits</a></strong> are colimits of diagrams indexed by directed sets.</li>
</ul>
<h2 id="properties">Properties</h2>
<h3 id="existence-of-limits">Existence of limits</h3>

<p>A given diagram <em>F</em> : <em>J</em> → <em>C</em> may or may not have a limit (or colimit) in <em>C</em>. Indeed, there may not even be a cone to <em>F</em>, let alone a universal cone.</p>

<p>A category <em>C</em> is said to <strong>have limits of type <em>J</em></strong> if every diagram of type <em>J</em> has a limit in <em>C</em>. Specifically, a category <em>C</em> is said to</p>
<ul>
<li><strong>have products</strong> if it has limits of type <em>J</em> for every <em>small</em> discrete category <em>J</em> (it need not have large products),</li>
<li><strong>have equalizers</strong> if it has limits of type 

<math display="inline" id="Limit_(category_theory):5">
 <semantics>
  <mrow>
   <mo>∙</mo>
   <mo>⇉</mo>
   <mo>∙</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>normal-∙</ci>
    <ci>normal-⇉</ci>
    <ci>normal-∙</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bullet\rightrightarrows\bullet
  </annotation>
 </semantics>
</math>

 (i.e. every parallel pair of morphisms has an equalizer),</li>
<li><strong>have pullbacks</strong> if it has limits of type 

<math display="inline" id="Limit_(category_theory):6">
 <semantics>
  <mrow>
   <mo>∙</mo>
   <mo>→</mo>
   <mo>∙</mo>
   <mo>←</mo>
   <mo>∙</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>normal-∙</ci>
    <ci>normal-→</ci>
    <ci>normal-∙</ci>
    <ci>normal-←</ci>
    <ci>normal-∙</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bullet\rightarrow\bullet\leftarrow\bullet
  </annotation>
 </semantics>
</math>

 (i.e. every pair of morphisms with common codomain has a pullback).</li>
</ul>

<p>A <strong><a href="complete_category" title="wikilink">complete category</a></strong> is a category that has all small limits (i.e. all limits of type <em>J</em> for every small category <em>J</em>).</p>

<p>One can also make the dual definitions. A category <strong>has colimits of type <em>J</em></strong> if every diagram of type <em>J</em> has a colimit in <em>C</em>. A <strong><a href="cocomplete_category" title="wikilink">cocomplete category</a></strong> is one that has all small colimits.</p>

<p>The <strong>existence theorem for limits</strong> states that if a category <em>C</em> has equalizers and all products indexed by the classes Ob(<em>J</em>) and Hom(<em>J</em>), then <em>C</em> has all limits of type <em>J</em>. In this case, the limit of a diagram <em>F</em> : <em>J</em> → <em>C</em> can be constructed as the equalizer of the two morphisms</p>

<p>

<math display="block" id="Limit_(category_theory):7">
 <semantics>
  <mrow>
   <mrow>
    <mi>s</mi>
    <mo>,</mo>
    <mi>t</mi>
   </mrow>
   <mo>:</mo>
   <mrow>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∏</mo>
      <mrow>
       <mi>i</mi>
       <mo>∈</mo>
       <mrow>
        <mi>Ob</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>J</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
     </munder>
     <mrow>
      <mi>F</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>i</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>⇉</mo>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∏</mo>
      <mrow>
       <mi>f</mi>
       <mo>∈</mo>
       <mrow>
        <mi>Hom</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>J</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
     </munder>
     <mrow>
      <mi>F</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>cod</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>f</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <list>
     <ci>s</ci>
     <ci>t</ci>
    </list>
    <apply>
     <ci>normal-⇉</ci>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <csymbol cd="latexml">product</csymbol>
       <apply>
        <in></in>
        <ci>i</ci>
        <apply>
         <times></times>
         <ci>Ob</ci>
         <ci>J</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>F</ci>
       <ci>i</ci>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <csymbol cd="latexml">product</csymbol>
       <apply>
        <in></in>
        <ci>f</ci>
        <apply>
         <times></times>
         <ci>Hom</ci>
         <ci>J</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>F</ci>
       <apply>
        <times></times>
        <ci>cod</ci>
        <ci>f</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s,t:\prod_{i\in\mathrm{Ob}(J)}F(i)\rightrightarrows\prod_{f\in\mathrm{Hom}(J)}%
F(\mathrm{cod}(f))
  </annotation>
 </semantics>
</math>

 given (in component form) by</p>

<p>

<math display="inline" id="Limit_(category_theory):8">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle s
  </annotation>
 </semantics>
</math>


 There is a dual <strong>existence theorem for colimits</strong> in terms of coequalizers and coproducts. Both of these theorems give sufficient and necessary conditions for the existence of all (co)limits of type <em>J</em>.</p>
<h3 id="universal-property">Universal property</h3>

<p>Limits and colimits are important special cases of <a href="universal_construction" title="wikilink">universal constructions</a>.</p>

<p>Let <em>C</em> be a category and let <em>J</em> be a small index category. The <a href="functor_category" title="wikilink">functor category</a> <em>C</em><sup><em>J</em></sup> may be thought of the category of all diagrams of type <em>J</em> in <em>C</em>. The <em><a href="diagonal_functor" title="wikilink">diagonal functor</a></em></p>

<p>

<math display="block" id="Limit_(category_theory):9">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Δ</mi>
   <mo>:</mo>
   <mrow>
    <mi class="ltx_font_mathcaligraphic">𝒞</mi>
    <mo>→</mo>
    <msup>
     <mi class="ltx_font_mathcaligraphic">𝒞</mi>
     <mi class="ltx_font_mathcaligraphic">𝒥</mi>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>normal-Δ</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>𝒞</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>𝒞</ci>
      <ci>𝒥</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta:\mathcal{C}\to\mathcal{C}^{\mathcal{J}}
  </annotation>
 </semantics>
</math>

 is the functor that maps each object <em>N</em> in <em>C</em> to the constant functor Δ(<em>N</em>) : <em>J</em> → <em>C</em> to <em>N</em>. That is, Δ(<em>N</em>)(<em>X</em>) = <em>N</em> for each object <em>X</em> in <em>J</em> and Δ(<em>N</em>)(<em>f</em>) = id<sub><em>N</em></sub> for each morphism <em>f</em> in <em>J</em>.</p>

<p>Given a diagram <em>F</em>: <em>J</em> → <em>C</em> (thought of as an object in <em>C</em><sup><em>J</em></sup>), a <a href="natural_transformation" title="wikilink">natural transformation</a> ψ : Δ(<em>N</em>) → <em>F</em> (which is just a morphism in the category <em>C</em><sup><em>J</em></sup>) is the same thing as a cone from <em>N</em> to <em>F</em>. To see this, first note that Δ(<em>N</em>)(<em>X</em>) = <em>N</em> for all X implies that the components of ψ are morphisms ψ<sub><em>X</em></sub> : <em>N</em> → <em>F</em>(<em>X</em>), which all share the domain <em>N</em>. Moreover the requirement that the cones diagrams commute is true simply because this ψ is a natural transformation. (Dually, a natural transformation ψ : <em>F</em> → Δ(<em>N</em>) is the same thing as a co-cone from <em>F</em> to <em>N</em>.)</p>

<p>Therefore, the definitions of limits and colimits can then be restated in the form:</p>
<ul>
<li>A limit of <em>F</em> is a universal morphism from Δ to <em>F</em>.</li>
<li>A colimit of <em>F</em> is a universal morphism from <em>F</em> to Δ.</li>
</ul>
<h3 id="adjunctions">Adjunctions</h3>

<p>Like all universal constructions, the formation of limits and colimits is functorial in nature. In other words, if every diagram of type <em>J</em> has a limit in <em>C</em> (for <em>J</em> small) there exists a <strong>limit functor</strong></p>

<p>

<math display="block" id="Limit_(category_theory):10">
 <semantics>
  <mrow>
   <mi>lim</mi>
   <mo>:</mo>
   <mrow>
    <msup>
     <mi class="ltx_font_mathcaligraphic">𝒞</mi>
     <mi class="ltx_font_mathcaligraphic">𝒥</mi>
    </msup>
    <mo>→</mo>
    <mi class="ltx_font_mathcaligraphic">𝒞</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>lim</ci>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>𝒞</ci>
      <ci>𝒥</ci>
     </apply>
     <ci>𝒞</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{lim}:\mathcal{C}^{\mathcal{J}}\to\mathcal{C}
  </annotation>
 </semantics>
</math>

 which assigns each diagram its limit and each <a href="natural_transformation" title="wikilink">natural transformation</a> η : <em>F</em> → <em>G</em> the unique morphism lim η : lim <em>F</em> → lim <em>G</em> commuting with the corresponding universal cones. This functor is <a href="right_adjoint" title="wikilink">right adjoint</a> to the diagonal functor Δ : <em>C</em> → <em>C</em><sup><em>J</em></sup>. This adjunction gives a bijection between the set of all morphisms from <em>N</em> to lim <em>F</em> and the set of all cones from <em>N</em> to <em>F</em></p>

<p>

<math display="block" id="Limit_(category_theory):11">
 <semantics>
  <mrow>
   <mrow>
    <mi>Hom</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>N</mi>
     <mo>,</mo>
     <mrow>
      <mi>lim</mi>
      <mi>F</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≅</mo>
   <mrow>
    <mi>Cone</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>N</mi>
     <mo>,</mo>
     <mi>F</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <apply>
     <times></times>
     <ci>Hom</ci>
     <interval closure="open">
      <ci>N</ci>
      <apply>
       <times></times>
       <ci>lim</ci>
       <ci>F</ci>
      </apply>
     </interval>
    </apply>
    <apply>
     <times></times>
     <ci>Cone</ci>
     <interval closure="open">
      <ci>N</ci>
      <ci>F</ci>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{Hom}(N,\mathrm{lim}F)\cong\mathrm{Cone}(N,F)
  </annotation>
 </semantics>
</math>

 which is natural in the variables <em>N</em> and <em>F</em>. The counit of this adjunction is simply the universal cone from lim <em>F</em> to <em>F</em>. If the index category <em>J</em> is <a href="connected_category" title="wikilink">connected</a> (and nonempty) then the unit of the adjunction is an isomorphism so that lim is a left inverse of Δ. This fails if <em>J</em> is not connected. For example, if <em>J</em> is a discrete category, the components of the unit are the <a href="diagonal_morphism" title="wikilink">diagonal morphisms</a> δ : <em>N</em> → <em>N</em><sup><em>J</em></sup>.</p>

<p>Dually, if every diagram of type <em>J</em> has a colimit in <em>C</em> (for <em>J</em> small) there exists a <strong>colimit functor</strong></p>

<p>

<math display="block" id="Limit_(category_theory):12">
 <semantics>
  <mrow>
   <mi>colim</mi>
   <mo>:</mo>
   <mrow>
    <msup>
     <mi class="ltx_font_mathcaligraphic">𝒞</mi>
     <mi class="ltx_font_mathcaligraphic">𝒥</mi>
    </msup>
    <mo>→</mo>
    <mi class="ltx_font_mathcaligraphic">𝒞</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>colim</ci>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>𝒞</ci>
      <ci>𝒥</ci>
     </apply>
     <ci>𝒞</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{colim}:\mathcal{C}^{\mathcal{J}}\to\mathcal{C}
  </annotation>
 </semantics>
</math>

 which assigns each diagram its colimit. This functor is <a href="left_adjoint" title="wikilink">left adjoint</a> to the diagonal functor Δ : <em>C</em> → <em>C</em><sup><em>J</em></sup>, and one has a natural isomorphism</p>

<p>

<math display="block" id="Limit_(category_theory):13">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>Hom</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>colim</mi>
       <mi>F</mi>
      </mrow>
      <mo>,</mo>
      <mi>N</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>≅</mo>
    <mrow>
     <mi>Cocone</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>F</mi>
      <mo>,</mo>
      <mi>N</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <apply>
     <times></times>
     <ci>Hom</ci>
     <interval closure="open">
      <apply>
       <times></times>
       <ci>colim</ci>
       <ci>F</ci>
      </apply>
      <ci>N</ci>
     </interval>
    </apply>
    <apply>
     <times></times>
     <ci>Cocone</ci>
     <interval closure="open">
      <ci>F</ci>
      <ci>N</ci>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{Hom}(\mathrm{colim}F,N)\cong\mathrm{Cocone}(F,N).
  </annotation>
 </semantics>
</math>

 The unit of this adjunction is the universal cocone from <em>F</em> to colim <em>F</em>. If <em>J</em> is connected (and nonempty) then the counit is an isomorphism, so that colim is a left inverse of Δ.</p>

<p>Note that both the limit and the colimit functors are <a href="covariant_functor" title="wikilink"><em>covariant</em></a> functors.</p>
<h3 id="as-representations-of-functors">As representations of functors</h3>

<p>One can use <a href="Hom_functor" title="wikilink">Hom functors</a> to relate limits and colimits in a category <em>C</em> to limits in <strong>Set</strong>, the <a href="category_of_sets" title="wikilink">category of sets</a>. This follows, in part, from the fact the covariant Hom functor Hom(<em>N</em>, –) : <em>C</em> → <strong>Set</strong> <a href="#Preservation_of_limits" title="wikilink">preserves all limits</a> in <em>C</em>. By duality, the contravariant Hom functor must take colimits to limits.</p>

<p>If a diagram <em>F</em> : <em>J</em> → <em>C</em> has a limit in <em>C</em>, denoted by lim <em>F</em>, there is a <a href="canonical_isomorphism" title="wikilink">canonical isomorphism</a></p>

<p>

<math display="block" id="Limit_(category_theory):14">
 <semantics>
  <mrow>
   <mrow>
    <mi>Hom</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>N</mi>
     <mo>,</mo>
     <mrow>
      <mi>lim</mi>
      <mi>F</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≅</mo>
   <mrow>
    <mpadded width="+1.7pt">
     <mi>lim</mi>
    </mpadded>
    <mi>Hom</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>N</mi>
     <mo>,</mo>
     <mrow>
      <mi>F</mi>
      <mo>-</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <apply>
     <times></times>
     <ci>Hom</ci>
     <interval closure="open">
      <ci>N</ci>
      <apply>
       <times></times>
       <ci>lim</ci>
       <ci>F</ci>
      </apply>
     </interval>
    </apply>
    <apply>
     <times></times>
     <ci>lim</ci>
     <ci>Hom</ci>
     <interval closure="open">
      <ci>N</ci>
      <apply>
       <csymbol cd="latexml">limit-from</csymbol>
       <ci>F</ci>
       <minus></minus>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{Hom}(N,\mathrm{lim}F)\cong\mathrm{lim}\,\mathrm{Hom}(N,F-)
  </annotation>
 </semantics>
</math>

 which is natural in the variable <em>N</em>. Here the functor Hom(<em>N</em>, <em>F</em>–) is the composition of the Hom functor Hom(<em>N</em>, –) with <em>F</em>. This isomorphism is the unique one which respects the limiting cones.</p>

<p>One can use the above relationship to define the limit of <em>F</em> in <em>C</em>. The first step is to observe that the limit of the functor Hom(<em>N</em>, <em>F</em>–) can be identified with the set of all cones from <em>N</em> to <em>F</em>:</p>

<p>

<math display="block" id="Limit_(category_theory):15">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mpadded width="+1.7pt">
      <mi>lim</mi>
     </mpadded>
     <mi>Hom</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>N</mi>
      <mo>,</mo>
      <mrow>
       <mi>F</mi>
       <mo>-</mo>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>Cone</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>N</mi>
      <mo>,</mo>
      <mi>F</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>lim</ci>
     <ci>Hom</ci>
     <interval closure="open">
      <ci>N</ci>
      <apply>
       <csymbol cd="latexml">limit-from</csymbol>
       <ci>F</ci>
       <minus></minus>
      </apply>
     </interval>
    </apply>
    <apply>
     <times></times>
     <ci>Cone</ci>
     <interval closure="open">
      <ci>N</ci>
      <ci>F</ci>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{lim}\,\mathrm{Hom}(N,F-)=\mathrm{Cone}(N,F).
  </annotation>
 </semantics>
</math>

 The limiting cone is given by the family of maps π<sub><em>X</em></sub> : Cone(<em>N</em>, <em>F</em>) → Hom(<em>N</em>, <em>FX</em>) where π<sub><em>X</em></sub>(ψ) = ψ<sub><em>X</em></sub>. If one is given an object <em>L</em> of <em>C</em> together with a <a href="natural_isomorphism" title="wikilink">natural isomorphism</a> Φ : Hom(–, <em>L</em>) → Cone(–, <em>F</em>), the object <em>L</em> will be a limit of <em>F</em> with the limiting cone given by Φ<sub><em>L</em></sub>(id<sub><em>L</em></sub>). In fancy language, this amounts to saying that a limit of <em>F</em> is a <a href="representable_functor" title="wikilink">representation</a> of the functor Cone(–, <em>F</em>) : <em>C</em> → <strong>Set</strong>.</p>

<p>Dually, if a diagram <em>F</em> : <em>J</em> → <em>C</em> has a colimit in <em>C</em>, denoted colim <em>F</em>, there is a unique canonical isomorphism</p>

<p>

<math display="block" id="Limit_(category_theory):16">
 <semantics>
  <mrow>
   <mrow>
    <mi>Hom</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>colim</mi>
      <mi>F</mi>
     </mrow>
     <mo>,</mo>
     <mi>N</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≅</mo>
   <mrow>
    <mpadded width="+1.7pt">
     <mi>lim</mi>
    </mpadded>
    <mi>Hom</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>F</mi>
      <mo>-</mo>
     </mrow>
     <mo>,</mo>
     <mi>N</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <apply>
     <times></times>
     <ci>Hom</ci>
     <interval closure="open">
      <apply>
       <times></times>
       <ci>colim</ci>
       <ci>F</ci>
      </apply>
      <ci>N</ci>
     </interval>
    </apply>
    <apply>
     <times></times>
     <ci>lim</ci>
     <ci>Hom</ci>
     <interval closure="open">
      <apply>
       <csymbol cd="latexml">limit-from</csymbol>
       <ci>F</ci>
       <minus></minus>
      </apply>
      <ci>N</ci>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{Hom}(\mathrm{colim}F,N)\cong\mathrm{lim}\,\mathrm{Hom}(F-,N)
  </annotation>
 </semantics>
</math>

 which is natural in the variable <em>N</em> and respects the colimiting cones. Identifying the limit of Hom(<em>F</em>–, <em>N</em>) with the set Cocone(<em>F</em>, <em>N</em>), this relationship can be used to define the colimit of the diagram <em>F</em> as a representation of the functor Cocone(<em>F</em>, –).</p>
<h3 id="interchange-of-limits-and-colimits-of-sets">Interchange of limits and colimits of sets</h3>

<p>Let <em>I</em> be a finite category and <em>J</em> be a small <a href="filtered_category" title="wikilink">filtered category</a>. For any <a class="uri" href="bifunctor" title="wikilink">bifunctor</a></p>
<dl>
<dd><em>F</em> : <em>I</em> × <em>J</em> → <strong>Set</strong>
</dd>
</dl>

<p>there is a <a href="natural_isomorphism" title="wikilink">natural isomorphism</a></p>

<p>

<math display="block" id="Limit_(category_theory):17">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mpadded width="+1.7pt">
      <msub>
       <mi>colim</mi>
       <mi>J</mi>
      </msub>
     </mpadded>
     <msub>
      <mi>lim</mi>
      <mi>I</mi>
     </msub>
     <mi>F</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>i</mi>
      <mo>,</mo>
      <mi>j</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>→</mo>
    <mrow>
     <mpadded width="+1.7pt">
      <msub>
       <mi>lim</mi>
       <mi>I</mi>
      </msub>
     </mpadded>
     <msub>
      <mi>colim</mi>
      <mi>J</mi>
     </msub>
     <mi>F</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>i</mi>
      <mo>,</mo>
      <mi>j</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>colim</ci>
      <ci>J</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>lim</ci>
      <ci>I</ci>
     </apply>
     <ci>F</ci>
     <interval closure="open">
      <ci>i</ci>
      <ci>j</ci>
     </interval>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>lim</ci>
      <ci>I</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>colim</ci>
      <ci>J</ci>
     </apply>
     <ci>F</ci>
     <interval closure="open">
      <ci>i</ci>
      <ci>j</ci>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{colim}_{J}\,\mathrm{lim}_{I}F(i,j)\rightarrow\mathrm{lim}_{I}\,\mathrm%
{colim}_{J}F(i,j).
  </annotation>
 </semantics>
</math>

</p>

<p>In words, filtered colimits in <strong>Set</strong> commute with finite limits.</p>
<h2 id="functors-and-limits">Functors and limits</h2>

<p>If <em>F</em> : <em>J</em> → <em>C</em> is a diagram in <em>C</em> and <em>G</em> : <em>C</em> → <em>D</em> is a <a class="uri" href="functor" title="wikilink">functor</a> then by composition (recall that a diagram is just a functor) one obtains a diagram <em>GF</em> : <em>J</em> → <em>D</em>. A natural question is then:</p>
<dl>
<dd>“How are the limits of <em>GF</em> related to those of <em>F</em>?”
</dd>
</dl>
<h3 id="preservation-of-limits">Preservation of limits</h3>

<p>A functor <em>G</em> : <em>C</em> → <em>D</em> induces a map from Cone(<em>F</em>) to Cone(<em>GF</em>): if Ψ is a cone from <em>N</em> to <em>F</em> then <em>G</em>Ψ is a cone from <em>GN</em> to <em>GF</em>. The functor <em>G</em> is said to <strong>preserve the limits of <em>F</em></strong> if (<em>GL</em>, <em>G</em>φ) is a limit of <em>GF</em> whenever (<em>L</em>, φ) is a limit of <em>F</em>. (Note that if the limit of <em>F</em> does not exist, then <em>G</em> <a href="vacuous_truth" title="wikilink">vacuously</a> preserves the limits of <em>F</em>.)</p>

<p>A functor <em>G</em> is said to <strong>preserve all limits of type <em>J</em></strong> if it preserves the limits of all diagrams <em>F</em> : <em>J</em> → <em>C</em>. For example, one can say that <em>G</em> preserves products, equalizers, pullbacks, etc. A <strong>continuous functor</strong> is one that preserves all <em>small</em> limits.</p>

<p>One can make analogous definitions for colimits. For instance, a functor <em>G</em> preserves the colimits of <em>F</em> if <em>G</em>(<em>L</em>, φ) is a colimit of <em>GF</em> whenever (<em>L</em>, φ) is a colimit of <em>F</em>. A <strong>cocontinuous functor</strong> is one that preserves all <em>small</em> colimits.</p>

<p>If <em>C</em> is a <a href="complete_category" title="wikilink">complete category</a>, then, by the above existence theorem for limits, a functor <em>G</em> : <em>C</em> → <em>D</em> is continuous if and only if it preserves (small) products and equalizers. Dually, <em>G</em> is cocontinuous if and only if it preserves (small) coproducts and coequalizers.</p>

<p>An important property of <a href="adjoint_functors" title="wikilink">adjoint functors</a> is that every right adjoint functor is continuous and every left adjoint functor is cocontinuous. Since adjoint functors exist in abundance, this gives numerous examples of continuous and cocontinuous functors.</p>

<p>For a given diagram <em>F</em> : <em>J</em> → <em>C</em> and functor <em>G</em> : <em>C</em> → <em>D</em>, if both <em>F</em> and <em>GF</em> have specified limits there is a unique canonical morphism</p>
<dl>
<dd>τ<sub><em>F</em></sub> : <em>G</em> lim <em>F</em> → lim <em>GF</em>
</dd>
</dl>

<p>which respects the corresponding limit cones. The functor <em>G</em> preserves the limits of <em>F</em> if and only this map is an isomorphism. If the categories <em>C</em> and <em>D</em> have all limits of type <em>J</em> then lim is a functor and the morphisms τ<sub><em>F</em></sub> form the components of a <a href="natural_transformation" title="wikilink">natural transformation</a></p>
<dl>
<dd>τ : <em>G</em> lim → lim <em>G</em><sup><em>J</em></sup>.
</dd>
</dl>

<p>The functor <em>G</em> preserves all limits of type <em>J</em> if and only if τ is a natural isomorphism. In this sense, the functor <em>G</em> can be said to <em>commute with limits</em> (<a href="up_to" title="wikilink">up to</a> a canonical natural isomorphism).</p>

<p>Preservation of limits and colimits is a concept that only applies to <em><a href="covariant_functor" title="wikilink">covariant</a></em> functors. For <a href="contravariant_functor" title="wikilink">contravariant functors</a> the corresponding notions would be a functor that takes colimits to limits, or one that takes limits to colimits.</p>
<h3 id="lifting-of-limits">Lifting of limits</h3>

<p>A functor <em>G</em> : <em>C</em> → <em>D</em> is said to <strong>lift limits</strong> for a diagram <em>F</em> : <em>J</em> → <em>C</em> if whenever (<em>L</em>, φ) is a limit of <em>GF</em> there exists a limit (<em>L</em>′, φ′) of <em>F</em> such that <em>G</em>(<em>L</em>′, φ′) = (<em>L</em>, φ). A functor <em>G</em> <strong>lifts limits of type <em>J</em></strong> if it lifts limits for all diagrams of type <em>J</em>. One can therefore talk about lifting products, equalizers, pullbacks, etc. Finally, one says that <em>G</em> <strong>lifts limits</strong> if it lifts all limits. There are dual definitions for the lifting of colimits.</p>

<p>A functor <em>G</em> <strong>lifts limits uniquely</strong> for a diagram <em>F</em> if there is a unique preimage cone (<em>L</em>′, φ′) such that (<em>L</em>′, φ′) is a limit of <em>F</em> and <em>G</em>(<em>L</em>′, φ′) = (<em>L</em>, φ). One can show that <em>G</em> lifts limits uniquely if and only if it lifts limits and is <a href="amnestic_functor" title="wikilink">amnestic</a>.</p>

<p>Lifting of limits is clearly related to preservation of limits. If <em>G</em> lifts limits for a diagram <em>F</em> and <em>GF</em> has a limit, then <em>F</em> also has a limit and <em>G</em> preserves the limits of <em>F</em>. It follows that:</p>
<ul>
<li>If <em>G</em> lifts limits of all type <em>J</em> and <em>D</em> has all limits of type <em>J</em>, then <em>C</em> also has all limits of type <em>J</em> and <em>G</em> preserves these limits.</li>
<li>If <em>G</em> lifts all small limits and <em>D</em> is complete, then <em>C</em> is also complete and <em>G</em> is continuous.</li>
</ul>

<p>The dual statements for colimits are equally valid.</p>
<h3 id="creation-and-reflection-of-limits">Creation and reflection of limits</h3>

<p>Let <em>F</em> : <em>J</em> → <em>C</em> be a diagram. A functor <em>G</em> : <em>C</em> → <em>D</em> is said to</p>
<ul>
<li><strong>create limits</strong> for <em>F</em> if whenever (<em>L</em>, φ) is a limit of <em>GF</em> there exists a unique cone (<em>L</em>′, φ′) to <em>F</em> such that <em>G</em>(<em>L</em>′, φ′) = (<em>L</em>, φ), and furthermore, this cone is a limit of <em>F</em>.</li>
<li><strong>reflect limits</strong> for <em>F</em> if each cone to <em>F</em> whose image under <em>G</em> is a limit of <em>GF</em> is already a limit of <em>F</em>.</li>
</ul>

<p>Dually, one can define creation and reflection of colimits.</p>

<p>The following statements are easily seen to be equivalent:</p>
<ul>
<li>The functor <em>G</em> creates limits.</li>
<li>The functor <em>G</em> lifts limits uniquely and reflects limits.</li>
</ul>

<p>There are examples of functors which lift limits uniquely but neither create nor reflect them.</p>
<h3 id="examples-1">Examples</h3>
<ul>
<li>For any category <em>C</em> and object <em>A</em> of <em>C</em> the covariant <a href="Hom_functor" title="wikilink">Hom functor</a> Hom(<em>A</em>,–) : <em>C</em> → <strong>Set</strong> preserves all limits in <em>C</em>. In particular, Hom functors are continuous. Hom functors need not preserve colimits.</li>
<li>Every <a href="representable_functor" title="wikilink">representable functor</a> <em>C</em> → <strong>Set</strong> preserves limits (but not necessarily colimits).</li>
<li>The <a href="forgetful_functor" title="wikilink">forgetful functor</a> <em>U</em> : <strong>Grp</strong> → <strong>Set</strong> creates (and preserves) all small limits and <a href="filtered_colimit" title="wikilink">filtered colimits</a>; however, <em>U</em> does not preserve coproducts. This situation is typical of algebraic forgetful functors.</li>
<li>The <a href="free_functor" title="wikilink">free functor</a> <em>F</em> : <strong>Set</strong> → <strong>Grp</strong> (which assigns to every set <em>S</em> the <a href="free_group" title="wikilink">free group</a> over <em>S</em>) is left adjoint to forgetful functor <em>U</em> and is, therefore, cocontinuous. This explains why the <a href="free_product" title="wikilink">free product</a> of two free groups <em>G</em> and <em>H</em> is the free group generated by the <a href="disjoint_union" title="wikilink">disjoint union</a> of the generators of <em>G</em> and <em>H</em>.</li>
<li>The inclusion functor <strong>Ab</strong> → <strong>Grp</strong> creates limits but does not preserve coproducts (the coproduct of two abelian groups being the <a href="Direct_sum_of_abelian_groups" title="wikilink">direct sum</a>).</li>
<li>The forgetful functor <strong>Top</strong> → <strong>Set</strong> lifts limits and colimits uniquely but creates neither.</li>
<li>Let <strong>Met</strong><sub><em>c</em></sub> be the category of <a href="metric_space" title="wikilink">metric spaces</a> with <a href="continuous_function" title="wikilink">continuous functions</a> for morphisms. The forgetful functor <strong>Met</strong><sub><em>c</em></sub> → <strong>Set</strong> lifts finite limits but does not lift them uniquely.</li>
</ul>
<h2 id="a-note-on-terminology">A note on terminology</h2>

<p>Older terminology referred to limits as "inverse limits" or "projective limits," and to colimits as "direct limits" or "inductive limits." This has been the source of a lot of confusion.</p>

<p>There are several ways to remember the modern terminology. First of all,</p>
<ul>
<li>cokernels,</li>
<li>coproducts,</li>
<li>coequalizers, and</li>
<li>codomains</li>
</ul>

<p>are types of colimits, whereas</p>
<ul>
<li>kernels,</li>
<li>products</li>
<li>equalizers, and</li>
<li>domains</li>
</ul>

<p>are types of limits. Second, the prefix "co" implies "first variable of the 

<math display="inline" id="Limit_(category_theory):18">
 <semantics>
  <mo>Hom</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>Hom</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{Hom}
  </annotation>
 </semantics>
</math>

". Terms like "cohomology" and "cofibration" all have a slightly stronger association with the first variable, i.e., the contravariant variable, of the 

<math display="inline" id="Limit_(category_theory):19">
 <semantics>
  <mo>Hom</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>Hom</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{Hom}
  </annotation>
 </semantics>
</math>

 bifunctor.</p>
<h2 id="references">References</h2>
<ul>
<li></li>
<li></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.j-paine.org/cgi-bin/webcats/webcats.php">Interactive Web page</a> which generates examples of limits and colimits in the category of finite sets. Written by <a href="http://www.j-paine.org/">Jocelyn Paine</a>.</li>
</ul>

<p>"</p>

<p><a href="Category:Limits_(category_theory)" title="wikilink"> </a></p>
</body>
</html>
