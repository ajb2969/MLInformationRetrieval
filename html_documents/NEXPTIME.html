<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="163">NEXPTIME</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>NEXPTIME</h1>
<hr/>

<p>In <a href="computational_complexity_theory" title="wikilink">computational complexity theory</a>, the <a href="complexity_class" title="wikilink">complexity class</a> <strong>NEXPTIME</strong> (sometimes called <strong>NEXP</strong>) is the set of <a href="decision_problem" title="wikilink">decision problems</a> that can be solved by a <a href="non-deterministic_Turing_machine" title="wikilink">non-deterministic Turing machine</a> using time 2<sup><em>n</em><sup><a href="Big_O_notation" title="wikilink">O</a>(1)</sup></sup> and unlimited space.</p>

<p>In terms of <a class="uri" href="NTIME" title="wikilink">NTIME</a>,</p>

<p>

<math display="block" id="NEXPTIME:0">
 <semantics>
  <mrow>
   <mtext>NEXPTIME</mtext>
   <mo>=</mo>
   <mrow>
    <munder>
     <mo largeop="true" mathsize="160%" movablelimits="false" stretchy="false" symmetric="true">⋃</mo>
     <mrow>
      <mi>k</mi>
      <mo>∈</mo>
      <mi>ℕ</mi>
     </mrow>
    </munder>
    <mrow>
     <mtext>NTIME</mtext>
     <mrow>
      <mo stretchy="false">(</mo>
      <msup>
       <mn>2</mn>
       <msup>
        <mi>n</mi>
        <mi>k</mi>
       </msup>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <mtext>NEXPTIME</mtext>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <union></union>
      <apply>
       <in></in>
       <ci>k</ci>
       <ci>ℕ</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <mtext>NTIME</mtext>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">2</cn>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>n</ci>
        <ci>k</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mbox{NEXPTIME}=\bigcup_{k\in\mathbb{N}}\mbox{NTIME}(2^{n^{k}})
  </annotation>
 </semantics>
</math>

</p>

<p>Alternatively, <strong>NEXPTIME</strong> can be defined using deterministic Turing machines as verifiers. A <a href="formal_language" title="wikilink">language</a> <em>L</em> is in <strong>NEXPTIME</strong> if and only if there exist polynomials <em>p</em> and <em>q</em>, and a deterministic Turing machine <em>M</em>, such that</p>
<ul>
<li>For all <em>x</em> and <em>y</em>, the machine <em>M</em> runs in time 2<sup><em>p(|x|)</em></sup> on input <em>(x,y)</em></li>
<li>For all <em>x</em> in <em>L</em>, there exists a string <em>y</em> of length 2<sup><em>q(|x|)</em></sup> such that <em>M(x,y)</em> = 1</li>
<li>For all <em>x</em> not in <em>L</em> and all strings <em>y</em> of length 2<sup><em>q(|x|)</em></sup>, <em>M(x,y)</em> = 0</li>
</ul>

<p>We know</p>
<dl>
<dd><a href="P_(complexity)" title="wikilink">P</a> 

<math display="inline" id="NEXPTIME:1">
 <semantics>
  <mo>⊆</mo>
  <annotation-xml encoding="MathML-Content">
   <subset></subset>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \subseteq
  </annotation>
 </semantics>
</math>

 <a href="NP_(complexity)" title="wikilink">NP</a> 

<math display="inline" id="NEXPTIME:2">
 <semantics>
  <mo>⊆</mo>
  <annotation-xml encoding="MathML-Content">
   <subset></subset>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \subseteq
  </annotation>
 </semantics>
</math>

 EXPTIME 

<math display="inline" id="NEXPTIME:3">
 <semantics>
  <mo>⊆</mo>
  <annotation-xml encoding="MathML-Content">
   <subset></subset>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \subseteq
  </annotation>
 </semantics>
</math>

 NEXPTIME
</dd>
</dl>

<p>and also, by the <a href="time_hierarchy_theorem" title="wikilink">time hierarchy theorem</a>, that</p>
<dl>
<dd>

<p>NP 

<math display="inline" id="NEXPTIME:4">
 <semantics>
  <mo>⊊</mo>
  <annotation-xml encoding="MathML-Content">
   <prsubset></prsubset>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \subsetneq
  </annotation>
 </semantics>
</math>

 NEXPTIME</p>
</dd>
</dl>

<p>If <a href="P_=_NP_problem" title="wikilink"><strong>P</strong> = <strong>NP</strong></a>, then <strong>NEXPTIME</strong> = <strong>EXPTIME</strong> (<a href="padding_argument" title="wikilink">padding argument</a>); more precisely, <strong><a href="E_(complexity)" title="wikilink">E</a></strong> ≠ <strong><a href="NE_(complexity)" title="wikilink">NE</a></strong> if and only if there exist <a href="sparse_language" title="wikilink">sparse languages</a> in <strong>NP</strong> that are not in <strong>P</strong>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>
<h2 id="alternative-characterizations">Alternative characterizations</h2>

<p><strong>NEXPTIME</strong> often arises in the context of <a href="interactive_proof_system" title="wikilink">interactive proof systems</a>, where there are two major characterizations of it. The first is the <strong>MIP</strong> proof system, where we have two all-powerful provers which communicate with a randomized polynomial-time verifier (but not with each other). If the string is in the language, they must be able to convince the verifier of this with high probability. If the string is not in the language, they must not be able to collaboratively trick the verifier into accepting the string except with low probability. The fact that <strong>MIP</strong> proof systems can solve every problem in <strong>NEXPTIME</strong> is quite impressive when we consider that when only one prover is present, we can only recognize all of <strong>PSPACE</strong>; the verifier's ability to "cross-examine" the two provers gives it great power. See <a href="interactive_proof_system#MIP" title="wikilink">interactive proof system#MIP</a> for more details.</p>

<p>Another interactive proof system characterizing <strong>NEXPTIME</strong> is a certain class of <a href="probabilistically_checkable_proof" title="wikilink">probabilistically checkable proofs</a>. Recall that <strong>NP</strong> can be seen as the class of problems where an all-powerful prover gives a purported proof that a string is in the language, and a deterministic polynomial-time machine verifies that it is a valid proof. We make two changes to this setup:</p>
<ul>
<li>Add randomness, the ability to flip coins, to the verifier machine.</li>
<li>Instead of simply giving the purported proof to the verifier on a tape, give it random access to the proof. The verifier can specify an index into the proof string and receive the corresponding bit. Since the verifier can write an index of polynomial length, it can potentially index into an exponentially long proof string.</li>
</ul>

<p>These two extensions together greatly extend the proof system's power, enabling it to recognize all languages in <strong>NEXPTIME</strong>. The class is called <strong>PCP</strong>(poly, poly). What more, in this characterization the verifier may be limited to read only a constant number of bits, i.e. <strong>NEXPTIME</strong> = <strong>PCP</strong>(poly, 1). See <a href="probabilistically_checkable_proof" title="wikilink">probabilistically checkable proofs</a> for more details.</p>
<h2 id="nexptime-complete">NEXPTIME-complete</h2>

<p>A decision problem is NEXPTIME-complete if it is in NEXPTIME, and every problem in NEXPTIME has a <a href="polynomial-time_many-one_reduction" title="wikilink">polynomial-time many-one reduction</a> to it. In other words, there is a polynomial-time <a class="uri" href="algorithm" title="wikilink">algorithm</a> that transforms instances of one to instances of the other with the same answer. Problems that are NEXPTIME-complete might be thought of as the hardest problems in NEXPTIME. We know that NEXPTIME-complete problems are not in NP; it has been proven that these problems cannot be verified in <a href="polynomial_time" title="wikilink">polynomial time</a>, by the <a href="time_hierarchy_theorem" title="wikilink">time hierarchy theorem</a>.</p>

<p>An important set of <strong>NEXPTIME</strong>-complete problems relates to <a href="succinct_circuit" title="wikilink">succinct circuits</a>. Succinct circuits are simple machines used to describe graphs in exponentially less space. They accept two vertex numbers as input and output whether there is an edge between them. If solving a problem on a graph in a natural representation, such as an <a href="adjacency_matrix" title="wikilink">adjacency matrix</a>, is <a class="uri" href="NP-complete" title="wikilink">NP-complete</a>, then solving the same problem on a succinct circuit representation is <strong>NEXPTIME</strong>-complete, because the input is exponentially smaller (under some mild condition that the NP-completeness reduction is achieved by a "projection").<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a><a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> As one simple example, finding a <a href="Hamiltonian_path" title="wikilink">Hamiltonian path</a> for a graph thus encoded is <strong>NEXPTIME</strong>-complete.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Game_complexity" title="wikilink">Game complexity</a></li>
<li><a href="NP_(complexity)" title="wikilink">NP</a></li>
<li><a class="uri" href="EXPTIME" title="wikilink">EXPTIME</a></li>
</ul>
<h2 id="references">References</h2>
<references>
</references>
<ul>
<li>

<p>, </p></li>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Complexity_classes" title="wikilink">Category:Complexity classes</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Juris Hartmanis, Neil Immerman, Vivian Sewelson. Sparse Sets in NP-P: EXPTIME versus NEXPTIME. <em>Information and Control</em>, volume 65, issue 2/3, pp.158–181. 1985. <a href="http://portal.acm.org/citation.cfm?id=808769">At ACM Digital Library</a><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="Christos_Papadimitriou" title="wikilink">C. Papadimitriou</a> &amp; <a href="Mihalis_Yannakakis" title="wikilink">M. Yannakakis</a>, <em>A note on succinct representations of graphs</em>, Information and control, vol 71 num 3, décember 1986, pp. 181—185, <a href="#fnref2">↩</a></li>
<li id="fn3">C. Papadimitriou. <em>Computational Complexity</em> Addison-Wesley, 1994. ISBN 0-201-53082-1. Section 20.1, pg.492.<a href="#fnref3">↩</a></li>
</ol>
</section>
</body>
</html>
