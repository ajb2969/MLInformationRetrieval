<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="615">Software testability</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Software testability</h1>
<hr/>

<p><strong>Software testability</strong> is the degree to which a software artifact (i.e. a software system, software module, requirements- or design document) supports testing in a given test context. If the testability of the software artifact is high, then finding faults in the system (if it has any) by means of testing is easier.</p>

<p>Testability is not an <a class="uri" href="intrinsic" title="wikilink">intrinsic</a> property of a software artifact and can not be measured directly (such as software size). Instead testability is an <a class="uri" href="extrinsic" title="wikilink">extrinsic</a> property which results from interdependency of the software to be tested and the test goals, test methods used, and test resources (i.e., the test context).</p>

<p>A lower degree of testability results in increased <a href="test_effort" title="wikilink">test effort</a>. In extreme cases a lack of testability may hinder testing parts of the software or <a href="software_requirements" title="wikilink">software requirements</a> <u>at all</u>.</p>

<p>In order to link the testability with the difficulty to find potential faults in a system (if they exist) by testing it, a relevant measure to assess the testability is how many test cases are needed in each case to form a complete test suite (i.e. a test suite such that, after applying all test cases to the system, collected outputs will let us unambiguously determine whether the system is correct or not according to some specification). If this size is small, then the testability is high. Based on this measure, a <a href="#Testability_hierarchy" title="wikilink">testability hierarchy</a> has been proposed.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> <a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>
<h2 id="background">Background</h2>

<p>Testability, a property applying to empirical hypothesis, involves two components. The effort and effectiveness of software tests depends on numerous factors including:</p>
<ul>
<li>Properties of the software requirements</li>
<li>Properties of the software itself (such as size, complexity and testability)</li>
<li>Properties of the test methods used</li>
<li>Properties of the development- and testing processes</li>
<li>Qualification and motivation of the persons involved in the test process</li>
</ul>
<h2 id="testability-of-software-components">Testability of software components</h2>

<p>The testability of software components (modules, classes) is determined by factors such as:</p>
<ul>
<li>Controllability: The degree to which it is possible to control the state of the component under test (CUT) as required for testing.</li>
<li>Observability: The degree to which it is possible to observe (intermediate and final) test results.</li>
<li>Isolateability: The degree to which the component under test (CUT) can be tested in isolation.</li>
<li><a href="Separation_of_concerns" title="wikilink">Separation of concerns</a>: The degree to which the component under test has a single, well defined responsibility.</li>
<li>Understandability: The degree to which the component under test is documented or self-explaining.</li>
<li>Automatability: The degree to which it is possible to automate testing of the component under test.</li>
<li>Heterogeneity: The degree to which the use of diverse technologies requires to use diverse test methods and tools in parallel.</li>
</ul>

<p>The testability of software components can be improved by:</p>
<ul>
<li><a href="Test-driven_development" title="wikilink">Test-driven development</a></li>
<li>Design for testability (similar to <a href="design_for_test" title="wikilink">design for test</a> in the hardware domain)</li>
</ul>
<h2 id="testability-hierarchy">Testability hierarchy</h2>

<p>Based on the amount of test cases required to construct a complete test suite in each context (i.e. a test suite such that, if it is applied to the implementation under test, then we collect enough information to precisely determine whether the system is correct or incorrect according to some specification), a testability hierarchy with the following testability classes has been proposed:<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> <a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>
<ul>
<li>Class I: there exists a finite complete test suite.</li>
<li>Class II: any partial distinguishing rate (i.e. any incomplete capability to distinguish correct systems from incorrect systems) can be reached with a finite test suite.</li>
<li>Class III: there exists a countable complete test suite.</li>
<li>Class IV: there exists a complete test suite.</li>
<li>Class V: all cases.</li>
</ul>

<p>It has been proved that each class is strictly included into the next. For instance, testing when we assume that the behavior of the implementation under test can be denoted by a deterministic <a href="finite-state_machine" title="wikilink">finite-state machine</a> for some known finite sets of inputs and outputs and with some known number of states belongs to Class I (and all subsequent classes). However, if the number of states is not known, then it only belongs to all classes from Class II on. If the implementation under test must be a deterministic finite-state machine failing the specification for a single trace (and its continuations), and its number of states is unknown, then it only belongs to classes from Class III on. Testing temporal machines where transitions are triggered if inputs are produced within some real-bounded interval only belongs to classes from Class IV on, whereas testing many non-deterministic systems only belongs to Class V (but not all, and some even belong to Class I). The inclusion into Class I does not require the simplicity of the assumed computation model, as some testing cases involving implementations written in any programming language, and testing implementations defined as machines depending on continuous magnitudes, have been proved to be in Class I. Other elaborated cases, such as the testing framework by <a href="Matthew_Hennessy" title="wikilink">Matthew Hennessy</a> under must semantics, and temporal machines with rational timeouts, belong to Class II.</p>
<h2 id="testability-of-requirements">Testability of requirements</h2>

<p>Requirements need to fulfill the following criteria in order to be testable:</p>
<ul>
<li>consistent</li>
<li>complete</li>
<li>unambiguous</li>
<li>quantitative (a requirement like "fast response time" can not be <a href="Verification_and_Validation_(software)" title="wikilink">verification/verified</a>)</li>
<li>verification/verifiable in practice (a test is feasible not only in theory but also in practice with limited resources)</li>
</ul>

<p>Treating the requirement as axioms, testability can be treated via asserting existence of a function 

<math display="inline" id="Software_testability:0">
 <semantics>
  <msub>
   <mi>F</mi>
   <mi>S</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>F</ci>
    <ci>S</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F_{S}
  </annotation>
 </semantics>
</math>

 (software) such that input 

<math display="inline" id="Software_testability:1">
 <semantics>
  <msub>
   <mi>I</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>I</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I_{k}
  </annotation>
 </semantics>
</math>

 generates output 

<math display="inline" id="Software_testability:2">
 <semantics>
  <msub>
   <mi>O</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>O</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O_{k}
  </annotation>
 </semantics>
</math>

, therefore 

<math display="inline" id="Software_testability:3">
 <semantics>
  <mrow>
   <msub>
    <mi>F</mi>
    <mi>S</mi>
   </msub>
   <mo>:</mo>
   <mrow>
    <mi>I</mi>
    <mo>→</mo>
    <mi>O</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>F</ci>
     <ci>S</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <ci>I</ci>
     <ci>O</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F_{S}:I\to O
  </annotation>
 </semantics>
</math>


. Therefore, the ideal software generates the tuple 

<math display="inline" id="Software_testability:4">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msub>
    <mi>I</mi>
    <mi>k</mi>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>O</mi>
    <mi>k</mi>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>I</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>O</ci>
     <ci>k</ci>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (I_{k},O_{k})
  </annotation>
 </semantics>
</math>

 which is the input-output set 

<math display="inline" id="Software_testability:5">
 <semantics>
  <mi mathvariant="normal">Σ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma
  </annotation>
 </semantics>
</math>

, standing for specification.</p>

<p>Now, take a test input 

<math display="inline" id="Software_testability:6">
 <semantics>
  <msub>
   <mi>I</mi>
   <mi>t</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>I</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I_{t}
  </annotation>
 </semantics>
</math>

, which generates the output 

<math display="inline" id="Software_testability:7">
 <semantics>
  <msub>
   <mi>O</mi>
   <mi>t</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>O</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O_{t}
  </annotation>
 </semantics>
</math>

, that is the test tuple 

<math display="inline" id="Software_testability:8">
 <semantics>
  <mrow>
   <mi>τ</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>I</mi>
     <mi>t</mi>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>O</mi>
     <mi>t</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>τ</ci>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>I</ci>
      <ci>t</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>O</ci>
      <ci>t</ci>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau=(I_{t},O_{t})
  </annotation>
 </semantics>
</math>


. Now, the question is whether or not 

<math display="inline" id="Software_testability:9">
 <semantics>
  <mrow>
   <mi>τ</mi>
   <mo>∈</mo>
   <mi mathvariant="normal">Σ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>τ</ci>
    <ci>normal-Σ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau\in\Sigma
  </annotation>
 </semantics>
</math>

 or 

<math display="inline" id="Software_testability:10">
 <semantics>
  <mrow>
   <mi>τ</mi>
   <mo>∉</mo>
   <mi mathvariant="normal">Σ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <notin></notin>
    <ci>τ</ci>
    <ci>normal-Σ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau\not\in\Sigma
  </annotation>
 </semantics>
</math>

. If it is in the set, the test tuple 

<math display="inline" id="Software_testability:11">
 <semantics>
  <mi>τ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>τ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau
  </annotation>
 </semantics>
</math>

 passes, else the system fails the test input. Therefore, it is of imperative importance to figure out : can we or can we not create a function that effectively translates into the notion of the set <a href="indicator_function" title="wikilink">indicator function</a> for the specification set 

<math display="inline" id="Software_testability:12">
 <semantics>
  <mi mathvariant="normal">Σ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma
  </annotation>
 </semantics>
</math>

.</p>

<p>By the notion, 

<math display="inline" id="Software_testability:13">
 <semantics>
  <msub>
   <mn>1</mn>
   <mi mathvariant="normal">Σ</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <cn type="integer">1</cn>
    <ci>normal-Σ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1_{\Sigma}
  </annotation>
 </semantics>
</math>


 is the testability function for the specification 

<math display="inline" id="Software_testability:14">
 <semantics>
  <mi mathvariant="normal">Σ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma
  </annotation>
 </semantics>
</math>

. The existence should not merely be asserted, should be proven rigorously. Therefore, obviously without algebraic consistency, no such function can be found, and therefore, the specification cease to be termed as testable.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a class="uri" href="Testability" title="wikilink">Testability</a></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li>Robert V. Binder: Testing Object-Oriented Systems: Models, Patterns, and Tools, ISBN 0-201-80938-9</li>
<li>Stefan Jungmayr: <a href="http://www.dissertation.de/index.php3?active_document=/FDP/sj929.pdf">Improving testability of object-oriented systems</a>, ISBN 3-89825-781-9</li>
<li>Wanderlei Souza: <a href="http://patterns-wg.fuka.info.waseda.ac.jp/SPAQU/proceedings2009/3-P2-AbstractTestabilityPatterns.pdf">Abstract Testability Patterns</a>, ISSN 1884-0760</li>
<li>Boris Beizer: <a href="http://books.google.co.in/books?id=Ixf97h356zcC">1</a>, Software Testing Techniques</li>
</ul>

<p>"</p>

<p><a href="Category:Software_testing" title="wikilink">Category:Software testing</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"></li>
<li id="fn4"></li>
</ol>
</section>
</body>
</html>
