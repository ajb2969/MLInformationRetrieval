<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1780">Triad method</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Triad method</h1>
<hr>Triad is one of the earliest and simplest solutions to the spacecraft attitude determination problem,<ref>{{cite journal|last=Black|first=Harold|title=A Passive System for Determining the Attitude of a Satellite|journal=AIAA Journal|date=July 1964|volume=2|issue=7|pages=1350–1351|doi=10.2514/3.2555|bibcode = 1964AIAAJ...2.1350. }}</ref><ref>{{cite journal|last=Black|first=Harold|title=Early Developments of Transit, the Navy Navigation Satellite System|journal=Journal of Guidance, Control and Dynamics|date=July–Aug 1990|volume=13|issue=4|pages=577–585|doi=10.2514/3.25373|bibcode = 1990JGCD...13..577B }}</ref> due to Harold Black. Black played a key role in the development of the guidance, navigation and control of the U.S. Navy's Transit satellite system at Johns Hopkins
<p><code>Applied Physics Laboratories. As evident from the literature, TRIAD represents the state of practice in spacecraft attitude determination, well before the advent of the </code><a href="Wahba's_problem" title="wikilink"><code>Wahba's</code> <code>problem</code></a><code> </code><a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a><code>  and its several optimal solutions. Given the knowledge of two vectors in the reference and body coordinates of a satellite, the TRIAD algorithm obtains the direction cosine matrix relating both frames. Covariance analysis for Black's classical solution was subsequently provided by Markley.</code><a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>
<h2 id="summary">Summary</h2>

<p>We consider the linearly independent reference vectors 

<math display="inline" id="Triad_method:0">
 <semantics>
  <msub>
   <mover accent="true">
    <mi>R</mi>
    <mo stretchy="false">→</mo>
   </mover>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <ci>normal-→</ci>
     <ci>R</ci>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vec{R}_{1}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Triad_method:1">
 <semantics>
  <msub>
   <mover accent="true">
    <mi>R</mi>
    <mo stretchy="false">→</mo>
   </mover>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <ci>normal-→</ci>
     <ci>R</ci>
    </apply>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vec{R}_{2}
  </annotation>
 </semantics>
</math>

. Let 

<math display="inline" id="Triad_method:2">
 <semantics>
  <mrow>
   <msub>
    <mover accent="true">
     <mi>r</mi>
     <mo stretchy="false">→</mo>
    </mover>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mover accent="true">
     <mi>r</mi>
     <mo stretchy="false">→</mo>
    </mover>
    <mn>2</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <ci>normal-→</ci>
      <ci>r</ci>
     </apply>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <ci>normal-→</ci>
      <ci>r</ci>
     </apply>
     <cn type="integer">2</cn>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vec{r}_{1},\vec{r}_{2}
  </annotation>
 </semantics>
</math>

 be the corresponding measured directions of the reference unit vectors as resolved in a body fixed frame of reference. Then they are related by the equations,</p>

<p>for 

<math display="inline" id="Triad_method:3">
 <semantics>
  <mrow>
   <mi>i</mi>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mo>,</mo>
    <mn>2</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>i</ci>
    <list>
     <cn type="integer">1</cn>
     <cn type="integer">2</cn>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i=1,2
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Triad_method:4">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 is a rotation matrix (sometimes also known as a proper <a href="orthogonal_matrix" title="wikilink">orthogonal matrix</a>, i.e., 

<math display="inline" id="Triad_method:5">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msup>
      <mi>A</mi>
      <mi>T</mi>
     </msup>
     <mi>A</mi>
    </mrow>
    <mo>=</mo>
    <mi>I</mi>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mrow>
     <mi>d</mi>
     <mi>e</mi>
     <mi>t</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>A</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>A</ci>
       <ci>T</ci>
      </apply>
      <ci>A</ci>
     </apply>
     <ci>I</ci>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>d</ci>
      <ci>e</ci>
      <ci>t</ci>
      <ci>A</ci>
     </apply>
     <apply>
      <plus></plus>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A^{T}A=I,det(A)=+1
  </annotation>
 </semantics>
</math>

). 

<math display="inline" id="Triad_method:6">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 transforms vectors in the body fixed frame into the frame of the reference vectors. Among other properties, rotational matrices preserve the length of the vector they operate on. Note that the direction cosine matrix 

<math display="inline" id="Triad_method:7">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 also transforms the cross product vector, written as,</p>

<p>Triad proposes an estimate of the direction cosine matrix 

<math display="inline" id="Triad_method:8">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 as a solution to the linear system equations given by</p>

<p>where 

<math display="inline" id="Triad_method:9">
 <semantics>
  <mi mathvariant="normal">⋮</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-⋮</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vdots
  </annotation>
 </semantics>
</math>

 have been used to separate different column vectors.</p>

<p>The solution presented above works well in the noise-free case. However, in practice, 

<math display="inline" id="Triad_method:10">
 <semantics>
  <mrow>
   <msub>
    <mover accent="true">
     <mi>r</mi>
     <mo stretchy="false">→</mo>
    </mover>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mover accent="true">
     <mi>r</mi>
     <mo stretchy="false">→</mo>
    </mover>
    <mn>2</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <ci>normal-→</ci>
      <ci>r</ci>
     </apply>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <ci>normal-→</ci>
      <ci>r</ci>
     </apply>
     <cn type="integer">2</cn>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vec{r}_{1},\vec{r}_{2}
  </annotation>
 </semantics>
</math>

 are noisy and the orthogonality condition of the attitude matrix (or the direction cosine matrix) is not preserved by the above procedure. Triad incorporates the following elegant procedure to redress this problem. To this end, we define unit vectors</p>

<p>and</p>

<p>to be used in place of the first two columns of (). Their cross product is used as the third column in the linear system of equations obtaining a proper orthogonal matrix for the spacecraft attitude given by</p>

<p>While the normalizations of Equations () - () are not necessary, they have been carried out to achieve a computational advantage in solving the linear system of equations in (). Thus an estimate of the spacecraft attitude is given by the proper orthogonal matrix as  Note that computational efficiency has been achieved in this procedure by replacing the matrix inverse with a transpose. Equation() shows that the matrices used for computing attitude are each composed of an orthogonal triad of basis vectors. "TRIAD" derives its name from this observation.</p>
<h2 id="triad-attitude-matrix-and-handed-ness-of-measurements">Triad Attitude Matrix and Handed-ness of Measurements</h2>

<p>It is of consequence to note that the Triad method always produces a proper orthogonal matrix irrespective of the handedness of the reference and body vectors employed in the estimation process. This can be shown as follows. Let us re-write Eq. () in a matrix form given by</p>

<p>where 

<math display="inline" id="Triad_method:11">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Γ</mi>
   <mo>:=</mo>
   <mrow>
    <mo>[</mo>
    <mrow>
     <mrow>
      <mpadded width="+3.3pt">
       <mover accent="true">
        <mi>S</mi>
        <mo stretchy="false">^</mo>
       </mover>
      </mpadded>
      <mpadded width="+3.3pt">
       <mi mathvariant="normal">⋮</mi>
      </mpadded>
      <mpadded width="+3.3pt">
       <mover accent="true">
        <mi>M</mi>
        <mo stretchy="false">^</mo>
       </mover>
      </mpadded>
      <mpadded width="+3.3pt">
       <mi mathvariant="normal">⋮</mi>
      </mpadded>
      <mover accent="true">
       <mi>S</mi>
       <mo stretchy="false">^</mo>
      </mover>
     </mrow>
     <mo>×</mo>
     <mover accent="true">
      <mi>M</mi>
      <mo stretchy="false">^</mo>
     </mover>
    </mrow>
    <mo>]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <ci>normal-Γ</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <apply>
      <times></times>
      <apply>
       <times></times>
       <apply>
        <ci>normal-^</ci>
        <ci>S</ci>
       </apply>
       <ci>normal-⋮</ci>
       <apply>
        <ci>normal-^</ci>
        <ci>M</ci>
       </apply>
       <ci>normal-⋮</ci>
       <apply>
        <ci>normal-^</ci>
        <ci>S</ci>
       </apply>
      </apply>
      <apply>
       <ci>normal-^</ci>
       <ci>M</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Gamma:=\left[\hat{S}~{}\vdots~{}\hat{M}~{}\vdots~{}\hat{S}\times\hat{M}\right]
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Triad_method:12">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">Δ</mi>
    <mo>=</mo>
    <mrow>
     <mo>[</mo>
     <mrow>
      <mrow>
       <mpadded width="+3.3pt">
        <mover accent="true">
         <mi>s</mi>
         <mo stretchy="false">^</mo>
        </mover>
       </mpadded>
       <mpadded width="+3.3pt">
        <mi mathvariant="normal">⋮</mi>
       </mpadded>
       <mpadded width="+3.3pt">
        <mover accent="true">
         <mi>m</mi>
         <mo stretchy="false">^</mo>
        </mover>
       </mpadded>
       <mpadded width="+3.3pt">
        <mi mathvariant="normal">⋮</mi>
       </mpadded>
       <mover accent="true">
        <mi>s</mi>
        <mo stretchy="false">^</mo>
       </mover>
      </mrow>
      <mo>×</mo>
      <mover accent="true">
       <mi>m</mi>
       <mo stretchy="false">^</mo>
      </mover>
     </mrow>
     <mo>]</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>normal-Δ</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <apply>
      <times></times>
      <apply>
       <times></times>
       <apply>
        <ci>normal-^</ci>
        <ci>s</ci>
       </apply>
       <ci>normal-⋮</ci>
       <apply>
        <ci>normal-^</ci>
        <ci>m</ci>
       </apply>
       <ci>normal-⋮</ci>
       <apply>
        <ci>normal-^</ci>
        <ci>s</ci>
       </apply>
      </apply>
      <apply>
       <ci>normal-^</ci>
       <ci>m</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta=\left[\hat{s}~{}\vdots~{}\hat{m}~{}\vdots~{}\hat{s}\times\hat{m}\right].
  </annotation>
 </semantics>
</math>

 Note that if the columns of 

<math display="inline" id="Triad_method:13">
 <semantics>
  <mi mathvariant="normal">Γ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Γ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Gamma
  </annotation>
 </semantics>
</math>

 form a left handed triad, then the columns of 

<math display="inline" id="Triad_method:14">
 <semantics>
  <mi mathvariant="normal">Δ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Δ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta
  </annotation>
 </semantics>
</math>

 are also left handed because of the one-one correspondence between the vectors. This is because of the simple fact that, in Euclidean geometry, the angle between any two vectors remains invariant to coordinate transformations. Therefore, the determinant 

<math display="inline" id="Triad_method:15">
 <semantics>
  <mrow>
   <mi>d</mi>
   <mi>e</mi>
   <mi>t</mi>
   <mrow>
    <mo>(</mo>
    <mi mathvariant="normal">Γ</mi>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>d</ci>
    <ci>e</ci>
    <ci>t</ci>
    <ci>normal-Γ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   det\left(\Gamma\right)
  </annotation>
 </semantics>
</math>

 is 

<math display="inline" id="Triad_method:16">
 <semantics>
  <mn>1</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">1</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1
  </annotation>
 </semantics>
</math>

 or 

<math display="inline" id="Triad_method:17">
 <semantics>
  <mrow>
   <mo>-</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   -1
  </annotation>
 </semantics>
</math>

 depending on whether its columns are right or left - handed respectively (similarly, 

<math display="inline" id="Triad_method:18">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Δ</mi>
   <mo>=</mo>
   <mrow>
    <mo>±</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>normal-Δ</ci>
    <apply>
     <csymbol cd="latexml">plus-or-minus</csymbol>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta=\pm 1
  </annotation>
 </semantics>
</math>

 ). Taking determinant on both sides of the relation in Eq. (), we conclude that  This is quite useful in practical applications since the analyst is always guaranteed a proper orthogonal matrix irrespective of the nature of the reference and measured vector quantities.</p>
<h2 id="applications">Applications</h2>

<p>Triad was used as an attitude determination technique to process the telemetry data from the Transit satellite system (used by the U.S. Navy for navigation). It is interesting to note that the principles of the Transit system gave rise to what we now know as the GPS satellite constellation. In an application problem, the reference vectors are usually known directions (e.g., stars, Earth magnetic field, gravity vector, etc.). Body fixed vectors are the measured directions as observed by an on-board sensor (e.g., star tracker, magnetometer, etc.). With advances in micro-electronics, attitude determination algorithms such as Triad have found their place in a variety of devices (e.g., smart phones, cars, tablets, UAVs etc.) with a broad impact on the modern society.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Attitude_dynamics_and_control" title="wikilink">Attitude Dynamics and Control</a></li>
<li><a href="Orientation_(geometry)" title="wikilink">Orientation (Geometry)</a></li>
<li><a href="Wahba's_problem" title="wikilink">Wahba's problem</a></li>
</ul>
<h2 id="references">References</h2>

<p>"</p>

<p><a href="Category:Spacecraft_attitude_control" title="wikilink">Category:Spacecraft attitude control</a> <a href="Category:Rotation_in_three_dimensions" title="wikilink">Category:Rotation in three dimensions</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
</ol>
</section>
</hr></body>
</html>
