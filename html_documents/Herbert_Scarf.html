<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1028">Herbert Scarf</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Herbert Scarf</h1>
<hr/>

<p><strong>Herbert Eli Scarf</strong> (born on July 25, 1930 in Philadelphia, PA) is a distinguished American economist and <a href="Sterling_Professor" title="wikilink">Sterling Professor</a> (Emeritus as of 2010) of <a class="uri" href="Economics" title="wikilink">Economics</a> at <a href="Yale_University" title="wikilink">Yale University</a>. He is a member of the <a href="American_Academy_of_Arts_and_Sciences" title="wikilink">American Academy of Arts and Sciences</a>, the <a href="National_Academy_of_Sciences" title="wikilink">National Academy of Sciences</a> and the <a href="American_Philosophical_Society" title="wikilink">American Philosophical Society</a>. He served as the president of the <a href="Econometric_Society" title="wikilink">Econometric Society</a> in 1983. He received both the <a href="Frederick_W._Lanchester_Prize" title="wikilink">Frederick Lanchester Award</a> in 1973 and the <a href="John_von_Neumann_Medal" title="wikilink">John von Neumann Medal</a> in 1983 from the <a href="Operations_Research_Society_of_America" title="wikilink">Operations Research Society of America</a> and was elected as a Distinguished Fellow of the <a href="American_Economic_Association" title="wikilink">American Economic Association</a> in 1991.</p>

<p>Scarf never received formal training in economics. Both his undergraduate training at <a href="Temple_University" title="wikilink">Temple University</a> and his graduate work at <a href="Princeton_University" title="wikilink">Princeton University</a> were in <a class="uri" href="mathematics" title="wikilink">mathematics</a>. For the past five decades, however, he has worked at the frontiers of both economic theory and operations research and has made a number of extraordinarily significant contributions to both of these fields. He is internationally famous for his early epoch-making work on optimal inventory policies and his highly influential study with Andrew Clark on optimal policies for a multi-echelon inventory problem, which initiated the important and flourishing field of supply chain management. Equally, he has gained world recognition for his classic study on the stability of the Walrasian price adjustment processes, his fundamental analysis (with <a href="Gerard_Debreu" title="wikilink">Gerard Debreu</a>) on the relation between the core and the set of competitive equilibria (the so-called <a href="Edgeworth_conjecture" title="wikilink">Edgeworth conjecture</a>, named after the Irish economist, <a href="Francis_Ysidro_Edgeworth" title="wikilink">Francis Ysidro Edgeworth</a>, Feb 8, 1845–Feb 13, 1926), his remarkable sufficient condition (i.e., balancedness) for the existence of a core in non-transferable utility games and general exchange economies, his seminal paper with <a href="Lloyd_Shapley" title="wikilink">Lloyd Shapley</a> on housing markets, and his pioneering study on increasing returns and models of production in the presence of indivisibilities. All in all, however, the name of Scarf is always remembered as a synonym for the computation of economic equilibria and fixed points. In the early 1960s he invented a path-breaking technique for computing equilibrium prices. This method is nowadays known as Scarf’s algorithm and has made general equilibrium theory applicable to large, realistic economic problems. This work has generated a major research field in economics termed Applied General Equilibrium Analysis and a corresponding area in operations research known as Simplicial Fixed Point Methods (or Algorithms). Scarf’s algorithm and its subsequent refinements and alternatives have become practical tools for assessing the consequences for the entire economy of a change in the economic environment or a major change in economic policy – to engage in comparative statics when the model of equilibrium is too large to be solved graphically or by simple numerical calculations.</p>
<h2 id="early-life-and-education">Early life and Education</h2>

<p>Scarf was born on July 25, 1930, in Philadelphia, Pennsylvania, to parents of Ukrainian Jewish origins. His father Louis Harris Scarf immigrated to the United States in 1905 from Ukraine at the age of 18 and his mother Lena Elkman also came to the US in the same year at the age of 5. They married in 1929 and had two twin sons next year: Frederick Leonard Scarf and Herbert Eli Scarf. Herbert and Frederick went to the same public primary and high schools in Philadelphia. Herbert Scarf became very interested in mathematics in his early adolescence after reading the book: Men of Mathematics by <a href="Eric_Temple_Bell" title="wikilink">E.T.Bell</a>. He began to read calculus, geometry, number theory and theoretical mechanics by himself in high school. Herbert’s teachers at the South Philadelphia High School apparently did not know he had such avid mathematical interests, and were astonished when he was ranked first in the Pennsylvania Statewide Mathematical Tournament for high school students organized by <a href="Temple_University" title="wikilink">Temple University</a> in 1947.</p>

<p>Herbert Scarf and his brother Frederick went to Temple University in 1948 for their undergraduate education. During their undergraduate studies, they lived with their parents and commuted by subway between their parents’ house and the university. Their father had a small business but was hit badly by the Great Depression and did not quite recover from it.</p>

<p>At Temple University, Herbert Scarf chose mathematics as his major subject. He started to attend graduate courses on Real and Complex Variables, Analysis, Probability Theory, and Statistics in his sophomore year. He vividly remembers one of the faculty members of the mathematics department, Professor Marie Wurster, who was very kind to him, always encouraged him and spent an enormous amount of time talking to him about mathematical topics. In 1950, he placed in the top 10 of the 1950 <a href="William_Lowell_Putnam_Mathematical_Competition" title="wikilink">William Lowell Putnam Mathematical Competition</a>, the major mathematics competition among universities in the United States and Canada.</p>

<p>In the fall of 1951, Herbert Scarf got a scholarship from Princeton University and went there for his graduate training in mathematics, whereas his brother Frederick went to MIT for graduate study in physics. Frederick ultimately became a distinguished space scientist – he unfortunately died in Moscow at the early age of 57.</p>

<p>Among Scarf’s many classmates at Princeton were <a href="Ralph_E._Gomory" title="wikilink">Ralph E. Gomory</a>, <a href="Lloyd_Shapley" title="wikilink">Lloyd Shapley</a>, <a href="John_McCarthy_(computer_scientist)" title="wikilink">John McCarthy</a>, <a href="Marvin_Minsky" title="wikilink">Marvin Minsky</a>, <a href="Serge_Lang" title="wikilink">Serge Lang</a> and <a href="John_Milnor" title="wikilink">John Milnor</a>. He also met <a href="Martin_Shubik" title="wikilink">Martin Shubik</a> who was then a graduate student at the Department of Economics. At that time <a href="John_Forbes_Nash,_Jr." title="wikilink">John Nash</a> and <a href="Harold_W._Kuhn" title="wikilink">Harold Kuhn</a> had already left Princeton, but Scarf often saw them during their regular returns. At Princeton, Scarf became a close friend of Gomory – they remain friends after these many years and often meet each other. When Scarf was at Princeton, he did not study game theory or economics but knew Martin Shubik, Lloyd Shapley, and John Nash who were actively involved in the early development of game theory.</p>

<p>After World War II, Princeton had become a sanctuary for a large number of world leading scientists who had escaped from Nazi occupied Europe. Among them were <a href="Albert_Einstein" title="wikilink">Albert Einstein</a>, <a href="John_von_Neumann" title="wikilink">John von Neumann</a>, and <a href="Kurt_Gödel" title="wikilink">Kurt Gödel</a>. Scarf often saw Einstein strolling with Gödel from Einstein’s office at the <a href="Institute_for_Advanced_Studies" title="wikilink">Institute for Advanced Studies</a> to his house on Mercer Street. Einstein always smiled benignly but his friend Gödel rarely did.</p>

<p>Scarf published his first scientific article ``Group invariant integration and the fundamental theorem of algebra” in the Proceedings of the National Academy of Sciences, in May, 1952. He attended Professor Saloman Bochner’s lectures about Haar Measure on Compact Topological Groups. One day Scarf made a sudden connection between this topic and a quite distant theme that he had been thinking about for quite some time. As a result he proposed an entirely novel proof for the fundamental theorem of algebra, stating that every polynomial in a single variable has at least one complex root.</p>

<p>Scarf’s academic adviser was <a href="Salomon_Bochner" title="wikilink">Salomon Bochner</a>. Scarf admired Bochner and maintained a good relationship with him until his death in 1982. Other professors in the Department of Mathematics were <a href="Emil_Artin" title="wikilink">Emil Artin</a>, <a href="William_Feller" title="wikilink">William Feller</a>, <a href="Ralph_Fox" title="wikilink">Ralph Fox</a>, <a href="Solomon_Lefschetz" title="wikilink">Solomon Lefschetz</a> and <a href="Albert_W._Tucker" title="wikilink">Albert Tucker</a>. Scarf wrote his PhD dissertation on partial differential equations over manifolds and received his PhD in 1954.</p>
<h2 id="career-at-rand-stanford-and-yale">Career at Rand, Stanford, and Yale</h2>

<p>Scarf worked at Bell Labs in the summer of 1953 and travelled every day between Princeton and the laboratory with <a href="John_Tukey" title="wikilink">John Tukey</a>, an eminent statistician. At Bell Labs Scarf encountered <a href="Claude_Shannon" title="wikilink">Claude Shannon</a>, the inventor of information theory. In June 1954, Scarf left Princeton to join the Rand Corporation. He chose Rand instead a more conventional academic job, because he desired to be involved in applied rather than abstract mathematics. The <a href="Rand_Corporation" title="wikilink">Rand Corporation</a> was founded by the US Defense Department in 1948 in order to apply a variety of analytical tools to the economic, political and strategic problems of the Cold War and provided an ideal environment for researchers with applied interests.</p>

<p>Among his colleagues at Rand were <a href="Lloyd_Shapley" title="wikilink">Lloyd Shapley</a>, <a href="George_Dantzig" title="wikilink">George Dantzig</a>, <a href="Richard_Bellman" title="wikilink">Richard Bellman</a>, <a href="D._R._Fulkerson" title="wikilink">Ray Fulkerson</a>, and <a href="L._R._Ford,_Jr." title="wikilink">Lester Ford</a>. Dantzig, the inventor of the simplex method, had arrived a bit earlier and was applying his methods to a large variety of basic problems. Bellman was trying to formulate and solve all possible optimization problems with a dynamic structure as dynamic programming problems. Fulkerson and Ford were working together on network flow problems which became the springboard for the flourishing field of combinatorial optimization. At Rand, Scarf worked with Shapley on games with partial information and differential games with survival payoffs and was occasionally joined by John Nash when he visited as a consultant. This activity resulted in two early papers of Scarf and Shapley on game theory.</p>

<p>At Rand, Scarf was first assigned to the Mathematics Department but after a year the organization was visited by a budgetary crisis and Scarf was transferred to the Department of Logistics – a junior subset of the Department of Economics. His colleagues in the logistics group were mainly concerned with maintenance, repair, scheduling and inventory management which had little to do with the economic and strategic questions of the Cold War. Scarf was not assigned to any specific research topic. He learned about inventory problems by himself and wrote his first paper in this field. He met <a href="Samuel_Karlin" title="wikilink">Samuel Karlin</a> and <a href="Kenneth_Arrow" title="wikilink">Kenneth Arrow</a> at Rand. They were both interested in inventory problems (Arrow had already written a remarkable paper on inventory theory with Harris and Marschak) and they invited Scarf to spend the academic year of 1956–1957 at the Department of Statistics, <a href="Stanford_University" title="wikilink">Stanford University</a>.</p>

<p>At Stanford, Scarf worked intensively on inventory problems and demonstrated his extraordinary analytical skill and penetrating discernment on the nature of fundamental problems, when he published his two epoch-making papers on dynamic inventory problems: the first (1959) is on the optimality of policies and the second paper (1960), with <a href="Andrew_Clark" title="wikilink">Andrew Clark</a>, on optimal policies for a multi-echelon inventory problem. Scarf also collaborated intensively with Arrow and Karlin on inventory problems. This collaboration resulted in three landmark volumes: Studies in Mathematical Theory of Inventory and Production, 1958, Contributions to the Theory of Inventory and Replacement, 1961, and Multistage Inventory Models and Techniques, 1963. Arrow and Karlin also became Scarf’s good friends and mentors.</p>

<p>Scarf’s visit was originally for a single year but the invitation was extended and in the fall of 1957 he was appointed as assistant professor in the Department of Statistics and subsequently an associate professor until he left Stanford in 1963. While working on inventory problems, Scarf became very interested in economics from discussions with Arrow and Hirofumi Uzawa and by attending the seminars on Mathematics in the Social Sciences organized by Arrow, Karlin and Patrick Suppes. He was particularly fascinated by general equilibrium models which he considered to be the central paradigm of economic theory.</p>

<p>In 1958 and 1959, Arrow and <a href="Leonid_Hurwicz" title="wikilink">Leonid Hurwicz</a> published two basic papers (the latter one with <a href="Robert_Block" title="wikilink">Robert Block</a>) in Econometrica. They proved that the Walrasian price adjustment process formalized by <a href="Paul_Samuelson" title="wikilink">Paul Samuelson</a> (1941) converges globally to an equilibrium for exchange economies with divisible goods when all goods are gross substitutes. It was much speculated that such processes would converge in any reasonable economy with divisible goods. But Scarf (1960) soon dashed such hopes by producing a simple example with three consumers and three commodities that was globally unstable. This was Scarf’s first classic article in economic theory and was the very beginning of his remarkable career in the economics profession.</p>

<p>On <a href="Tjalling_Charles_Koopmans" title="wikilink">Tjalling Charles Koopmans</a>’ invitation, Scarf spent the academic year of 1959–1960 at the <a href="Cowles_Foundation" title="wikilink">Cowles Foundation</a> at Yale University. Koopmans, whom Scarf had met earlier at Rand, became a very close friend and mentor of Scarf. During his visit Scarf gave a seminar talk on his counter-examples. The seminar was chaired by <a href="James_Tobin" title="wikilink">James Tobin</a> who was then the director. Among his audience were <a href="Gerard_Debreu" title="wikilink">Gerard Debreu</a>, <a href="Donald_Hester" title="wikilink">Donald Hester</a>, <a href="Alan_Manne" title="wikilink">Alan Manne</a>, <a href="Arthur_Melvin_Okun" title="wikilink">Art Okun</a>, <a href="Edmund_Phelps" title="wikilink">Edmund Phelps</a>, <a href="Bob_Summers" title="wikilink">Bob Summers</a>, and <a href="Jacob_Marschak" title="wikilink">Jacob Marschak</a>. During the same academic year, Scarf was invited to give a talk at <a href="Columbia_University" title="wikilink">Columbia University</a> on his counter-examples. His old colleague <a href="Martin_Shubik" title="wikilink">Martin Shubik</a> was in the audience. After the talk Scarf and Shubik took a long walk from 125th street to Shubik’s apartment in Sutton Place, New York. During the walk, Shubik passionately talked about and tried to persuade Scarf to solve the so-called Edgeworth conjecture that the core of an exchange economy would converge to its set of competitive equilibria if the number of traders in the economy tends to infinity.</p>

<p>Shubik’s enthusiasm sparked Scarf’s interest in this question and he started thinking seriously about the topic. He read von Neumann and Morgenstern’s book: The Theory of Games and Economic Behavior, Edgeworth’s analysis of the contract curve with two goods and two types of traders in his book: Mathematical Psychics, and Shubik’s 1959 paper on this subject. Several months later a decisive moment came when Scarf found a way, albeit extremely complicated, of proving the Edgeworth conjecture; see his 1961 paper: ``An analysis of markets with a large number of participants”. Debreu subsequently improved Scarf’s argument and published it in his 1963 paper: ``On a theorem of Scarf”. But a significant simplification of Scarf’s argument came when Scarf met Debreu on one occasion in December 1961, as Debreu eloquently described it in his 1983 Nobel Prize lecture: ``Associated with our joint paper is one of my vivid memories of the instant when a problem is solved. Scarf, then at Stanford, had met me at the San Francisco Airport in December 1961, and as he was driving to Palo Alto on the freeway, one of us, in one sentence, provided a key to the solution; the other, also in one sentence, immediately provided the other key; and the lock clicked open.” This collaboration yielded their 1963 paper: ``A limit theorem on the core of an economy,” which is one of the most fundamental results in general equilibrium theory. It is an important milestone for at least three reasons: First, it provides an important justification for the assumption of <a href="perfect_competition" title="wikilink">perfect competition</a> that is fundamental in the treatment of neoclassical economic equilibrium models; second, it shows that competition and cooperation are just two sides of a coin for economic activities under the right circumstances; third, it became the starting point for a large literature on the core equivalence.</p>

<p>In 1963, Scarf moved to the Cowles Foundation and the Department of Economics at Yale University and was appointed as a full professor. In 1979 he became a <a href="Sterling_Professor" title="wikilink">Sterling Professor</a>—the highest recognition for academic staff at Yale. He was the Director of the Cowles Foundation for the periods of 1967–71 and 1981–84. Since 1963 Scarf has remained at Cowles except for visiting appointments at Cambridge, Stanford and other institutes. He found the environment at Cowles extremely suited to him, as he describes it in the preface of his 1973 book: ``The standard of mathematical rigor and clarity of thought which prevail at Cowles are well known to the economics profession. But perhaps more important is the persistent though subtle suggestion that the highest aim of even the most theoretical work in economics is an ultimate practical applicability.”</p>

<p>During his first few years at Cowles Scarf concentrated on the problem of finding a method for computing economic equilibria. His work on the core equivalence result had suggested a roadmap. If he could find a way to calculate a point in the core of a game based on a general equilibrium model, then this method would serve to find an approximate equilibrium allocation, at least in an economy with a large number of traders. This activity resulted in the first major core existence theorem for a large class of cooperative games without side payments. He proved that an N-person game has a nonempty core if the game is balanced. Scarf’s first proof of this theorem relied on <a href="Brouwer’s_fixed_point_theorem" title="wikilink">Brouwer’s fixed point theorem</a>, but his hope was to provide a numerical method for computing a point in the core, making no use of fixed point theorems. Good fortune loves those who are well-prepared. <a href="Robert_Aumann" title="wikilink">Robert Aumann</a> was visiting the Cowles Foundation during the academic year 1964–65. Scarf described his problem to Aumann, who suggested that he take a look at a recent paper by Lemke and Howson (1964). In this article, they proposed an algorithm for computing a Nash equilibrium in a finite two person non zero-sum game. In a single evening, Scarf realized that he could directly translate the Lemke-Howson’s algorithm through a limiting process into an elementary and constructive proof of his core existence theorem. This result was reported in his 1967 classic article: ``The core of an N-person game,” and became one of the most important theorems in cooperative game theory.</p>

<p>Having found an algorithm for the core, in November 1965, Scarf finally realized that he could explore this technique to design a novel algorithm for approximating equilibrium prices directly, without relying on the relation between the core and the competitive equilibrium. This path-breaking work marked the successful culmination of his long battle for transforming abstract general equilibrium analysis into a practical tool for the evaluation of economic policy. The result is published in his 1967 article: ``The approximation of fixed points of a continuous mapping.”</p>

<p>Since the early 1970s, Scarf launched his longest, hardest and most ambitious struggle: to tackle economies with indivisibilities, increasing returns and nonconvexity. In fact in 1963 he already wrote: ``Notes on the core of production economy,” which was widely circulated but was not published until 1986. In this note, he studied economies where the production set exhibits increasing returns. He showed that if the production possibility set satisfies customary properties, but is not a cone, then there is a collection of consumers with conventional preferences and specific initial endowments for which the core is empty. His seminal article with Shapley in 1974: ``On cores and indivisibilities,” marked the first victory in his battle tackling indivisibilities and has become a most-cited classic article in the field.</p>

<p>In the 1940s and 1950s, Dantzig and Koopmans had developed the activity analysis model of a production possibility set with constant returns to scale. When factor endowments are specified, the model leads directly to a linear program which can be solved by Dantzig’s simplex method. The method makes use of competitive prices to test for the optimality of a proposed feasible solution.</p>

<p>However, neither decreasing returns nor constant returns reflect economic reality. Since the beginning of the Industrial Revolution in the 1760s, economies of scale and increasing returns based on large indivisible pieces of machinery or forms of productive organization such as the assembly line are prominent features of every industrialized nation. Unfortunately, economic theory based on the assumption of convexity and perfect divisibility does not offer any clue to this challenging economic problem. The difficulty of dealing with indivisibilities has long been recognized by many leading economists including Lerner (1944), Koopmans and Beckmann (1957), and Debreu (1959), as Lerner (1944) points out: ``We see then that indivisibility leads to an expansion in the output of the firm, and this either makes the output big enough to render the indivisibility insignificant, or it destroys the perfection of competition. Significant indivisibility destroys perfect competition.”</p>

<p>Scarf was interested in economies with indivisibilities in production, i.e., where activity levels are constrained to be integers, an extreme form of non-convexity. When factor endowments are specified we are led to the general integer program for which there is no pricing test to detect whether a feasible production plan is indeed optimal. His major goals have been (1) to replace the pricing test by a local neighbourhood search and (2) to develop a mechanism for efficiently finding this test set. In the early 1980s, he made a decisive victory in achieving his first goal. Using his early concept of primitive sets arising in his research on the core and the computation of equilibria, Scarf succeeded in developing a quantity test set. He proved that this test set is unique and minimal, depending on the technology matrix alone and not on the specification of the particular factor endowment. It consists of a finite number of integral production plans. When this test set is available, one can easily use it to verify if a production plan is optimal or not, and if it is not optimal, one can use the test set to obtain a better production plan.</p>

<p>Scarf has worked with a group of mathematicians on this subject for many years. He has found several important special classes of technology matrices for which the test set can be easily identified. However, important questions remain open and the battle is not yet over, as he states in his 1983 Presidential Address of the Econometric Society (1986, Econometrica):``At the present time, I am far from being able to present a convincing argument which relates the structure of neighbourhood systems (i.e., test sets) to the administrative arrangements that might be taken by a large industrial enterprise.” Up to this very moment, his struggle goes on. Indeed, as a Chinese poem says: ``An old war-horse may be stabled, yet still it longs to gallop a thousand miles; and a noble-hearted man though advanced in years never abandons his proud aspirations.”</p>
<h2 id="major-works">Major Works</h2>
<h3 id="ss-optimal-inventory-policies">1. 

<math display="inline" id="Herbert_Scarf:0">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>S</mi>
   <mo>,</mo>
   <mi>s</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>S</ci>
    <ci>s</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (S,s)
  </annotation>
 </semantics>
</math>

 Optimal Inventory Policies</h3>

<p>Every organization encounters inventory problems of one kind or another. Consider a typical situation: A retailer faces uncertain demand for its product from customers over time. He has to pay a reorder cost and a unit cost when he orders the good from its producer. Over time, he also needs to pay the holding cost of its inventory and a shortage cost if the good runs out of stock. The retailer’s problem is to determine how much to order in each period of time so as to minimize expected cost. Scarf (1958) solved the problem in a characteristic manner by introducing a generalized notion of convexity, called 

<math display="inline" id="Herbert_Scarf:1">
 <semantics>
  <mi>K</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>K</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K
  </annotation>
 </semantics>
</math>

-convexity. Given a constant 

<math display="inline" id="Herbert_Scarf:2">
 <semantics>
  <mrow>
   <mi>K</mi>
   <mo>≥</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <ci>K</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K\geq 0
  </annotation>
 </semantics>
</math>

 a function 

<math display="inline" id="Herbert_Scarf:3">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x)
  </annotation>
 </semantics>
</math>

 is called 

<math display="inline" id="Herbert_Scarf:4">
 <semantics>
  <mi>K</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>K</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K
  </annotation>
 </semantics>
</math>

-convex if,</p>

<p>

<math display="inline" id="Herbert_Scarf:5">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>a</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mfrac>
       <mrow>
        <mrow>
         <mi>f</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>x</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>-</mo>
        <mrow>
         <mi>f</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <mi>x</mi>
           <mo>-</mo>
           <mi>b</mi>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
       <mi>b</mi>
      </mfrac>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>x</mi>
       <mo>+</mo>
       <mi>a</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mi>K</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>x</ci>
     </apply>
     <apply>
      <times></times>
      <ci>a</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <divide></divide>
        <apply>
         <minus></minus>
         <apply>
          <times></times>
          <ci>f</ci>
          <ci>x</ci>
         </apply>
         <apply>
          <times></times>
          <ci>f</ci>
          <apply>
           <minus></minus>
           <ci>x</ci>
           <ci>b</ci>
          </apply>
         </apply>
        </apply>
        <ci>b</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>f</ci>
      <apply>
       <plus></plus>
       <ci>x</ci>
       <ci>a</ci>
      </apply>
     </apply>
     <ci>K</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x)+a[\frac{f(x)-f(x-b)}{b}]\leq f(x+a)+K
  </annotation>
 </semantics>
</math>

</p>

<p>for all positive 

<math display="inline" id="Herbert_Scarf:6">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo rspace="4.2pt">,</mo>
   <mi>b</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>a</ci>
    <ci>b</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a,\,b
  </annotation>
 </semantics>
</math>

, and all 

<math display="inline" id="Herbert_Scarf:7">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x.
  </annotation>
 </semantics>
</math>

 Note that 

<math display="inline" id="Herbert_Scarf:8">
 <semantics>
  <mn>0</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">0</cn>
  </annotation-xml>
 </semantics>
</math>

-convexity is equivalent to ordinary convexity.</p>

<p>Scarf demonstrated inductively that the minimum expected cost was 

<math display="inline" id="Herbert_Scarf:9">
 <semantics>
  <mi>K</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>K</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K
  </annotation>
 </semantics>
</math>

-convex and that the optimal policy for the dynamic inventory problem is given, for each period of time, by a pair 

<math display="inline" id="Herbert_Scarf:10">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>S</mi>
   <mo>,</mo>
   <mi>s</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>S</ci>
    <ci>s</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (S,s)
  </annotation>
 </semantics>
</math>

 of numbers. If, at the beginning of an ordering period, the stock has fallen below the lower level, 

<math display="inline" id="Herbert_Scarf:11">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

, it is optimal for the retailer to raise the stock to the upper level, 

<math display="inline" id="Herbert_Scarf:12">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

, otherwise no order is placed. The cost functions may be shown to be 

<math display="inline" id="Herbert_Scarf:13">
 <semantics>
  <mi>K</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>K</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K
  </annotation>
 </semantics>
</math>

-convex under a variety of conditions – for example whenever holding and shortage costs are linear, more generally, convex. Thus 

<math display="inline" id="Herbert_Scarf:14">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>S</mi>
   <mo>,</mo>
   <mi>s</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>S</ci>
    <ci>s</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (S,s)
  </annotation>
 </semantics>
</math>

 policies are optimal for many practical dynamic inventory problems and have become a benchmark solution in inventory management. 

<math display="inline" id="Herbert_Scarf:15">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>S</mi>
   <mo>,</mo>
   <mi>s</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>S</ci>
    <ci>s</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (S,s)
  </annotation>
 </semantics>
</math>

 policies had been used in practice for many years. Their operating characteristics were first discussed in Arrow, Harris and Marschak (1951), but the proof of optimality was first provided by Scarf.</p>
<h3 id="optimal-policies-in-multi-echelon-inventory-problems">2. Optimal Policies in Multi-echelon Inventory Problems</h3>

<p>Clark and Scarf (1960) were the first to study a multi-echelon inventory problem and initiated the field of supply chain management. They considered a general situation in which there are several installations, say 1, 2, …, N, with installation 1 receiving stock from 2, with 2 receiving stock from 3, etc. If installation k-1 places an order from installation from k, the length of time for the order to be filled is determined not only by the natural delivery time between these two sites, but also by the availability of stock at installation k. The problem is to determine optimal purchasing quantities at each installation when delivery times, purchase costs, demand distributions, holding and shortage costs and other parameters are given.</p>

<p>They proved that the optimal policies for the N installations can be found by solving recursively a dynamic programming problem in which the value function depends on the inventory levels at each installation and the orders from successive installations which have not yet been delivered. Their important contribution was to demonstrate that under certain plausible conditions, the value functions can be decomposed into the sum of functions of a single variable, each of which satisfies its own recursive equation which can be solved easily.</p>
<h3 id="global-instability-of-the-competitive-equilibrium">3. Global Instability of the Competitive Equilibrium</h3>

<p>Consider a situation: Several traders each bring his/her bundle of goods to a market place and wish to exchange their goods. In the general equilibrium model, the exchange takes place at prices that equilibrate demand and supply for every good. How are these prices to be found?</p>

<p>The market is guided by an invisible hand – a price adjustment mechanism – to an equilibrium state. You examine each good in the market and increase the price of the good if its demand is more than its supply but decrease its price if the relation holds the other way. Léon Walras had proposed the first such process in 1874, and Paul Samuelson formalized such a procedure as a system of differential equations in 1948.</p>

<p>Arrow and Hurwicz (1958), and Arrow, Block and Hurwicz (1959) found that the price adjustment process proposed by Samuelson always converges to an equilibrium if the goods are gross substitutes. It was then speculated that the same process would work for any reasonable market of divisible goods. Scarf (1963) dashed such hopes by showing a series of counterexamples among which the first example involves three consumers and three complementary commodities, and has a unique equilibrium. He demonstrated that if the initial price vector is not the equilibrium price vector, this process will generate a cycle of non-equilibrium price vectors and never converge to the equilibrium.</p>
<h3 id="core-and-competitive-equilibrium-equivalence">4. Core and Competitive Equilibrium Equivalence</h3>

<p>Consider an economic system composed of many self-interested individuals each of whom is endowed with a bundle of goods, has preferences over the available bundles and wishes to achieve a maximal satisfaction by exchanging his/her own goods with others. The system requires every individual to respect the private ownership and the voluntary and non-coercive trade rule. Given this system, what will be a natural outcome of chaotic and countless independent actions of these self-interested agents? Adam Smith in his book ``The Wealth of Nations” (1776) first recognized how the invisible hand – a competitive market mechanism – can reconcile the complicated and conflicting forces of self-interested agents and guides the system to an equilibrium. The equilibrium is a state in which there exists a system of prices (i.e., market-clearing prices) at which every agent gets a best bundle of goods under his/her budget constraint and the supply of each good meets its demand. The list of the bundles obtained by all agents in the equilibrium state is called a competitive equilibrium allocation and is a redistribution of all agents’ initial endowments of goods. Wald (1936), Arrow and Debreu (1954), and McKenzie (1959) among many others established fundamental results on the existence of competitive equilibrium. The assumption of perfect competition or price-taking behaviour is crucial in these analyses. It essentially requires that the influence of every agent in the system should be negligible.</p>

<p>Another equally appealing and natural outcome of the economic system was first proposed by Francis Edgeworth in his book ``Mathematical Psychics’’ (1881), and is now known as the core allocation (in the case of two goods, it is any point in the contract curve of the Edgeworth box). Formally, a redistribution of all agents’ initial endowments of goods among all agents in the system is a core allocation if no group of agents can redistribute their own initial endowments among themselves so as to improve the satisfaction of someone in the group without impairing that of any other in the group. Clearly, a core allocation is Pareto efficient in the sense that there is no way to make some agent better off without making any other worse off. It is now well known that every competitive equilibrium allocation must be a core allocation but a core allocation need not be a competitive equilibrium allocation. Edgeworth worked with an economic system consisting of only two agents and two goods, and then replicated the economy many times. What he found is that as the replication tends to infinity, the set of core allocations converges to the set of competitive equilibrium allocations. This result provides a perfect justification of price-taking behaviour but in a very specific setting. However, Edgeworth’s approach is based on the geometrical picture of the Edgeworth box and cannot be applied to the general case involving more than two agents and more than two types of goods. The general case is known as Edgeworth conjecture and remained widely open for many several decades.</p>

<p>Based on the earlier paper of Scarf (1962), Debreu and Scarf (1963) resolved the outstanding theoretical problem in a brilliant and elegant manner. They started with a general economy consisting of any finitely many agents and a finite number of goods and proved that if one replicates the economy infinitely many times, then the set of core allocations coincides with the set of competitive equilibrium allocations. This offers an impeccable validation of perfect competition in a most general and most natural setting. This study has spawned a large body of literature on the relationship between the core and the set of competitive equilibrium allocations. One of the most significant contributions to this literature is the paper of Aumann (1964). Having heard Scarf’s discussion on his original 1962 paper at a conference at Princeton in 1962, Aumann established a model of pure exchange economy with a continuum of agents in which the core and the set of competitive equilibrium allocations are the same.</p>
<h3 id="the-core-of-an-n-person-game">5. The Core of an N-Person Game</h3>

<p>The problems of resource distribution in an economic system may be resolved by the tool of competitive equilibrium theory or by more general and more flexible techniques of game theory. In a competitive equilibrium setting, every consumer acts in response to a set of prices by choosing bundles to maximize her utility under her budget constraint and every firm selects production levels at which the highest profit is achieved . The system reaches an equilibrium at which consistent production plans and allocation of goods are made and all participants are in harmony with one another. When these economic problems are studied in the framework of game theory, we need to specify a set of production and distribution activities available to each possible coalition of economic agents. It is, however, often sufficient and also convenient to summarize the detailed strategic possibilities open to each coalition by a set of possible utilities that can be achieved by the coalition. A stable and desirable outcome of the system is a core allocation of the game which assigns every agent a utility, and from which neither any individual agent nor any group of agents will have incentive to deviate. Scarf (1967) studied this problem and provided sufficient conditions under which a core allocation always exists.</p>

<p>Formally, Scarf considers the following general game with a finite number of agents. Let 

<math display="inline" id="Herbert_Scarf:16">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

 denote all the agents in a system who are engaging in some business, economic, or political activities. These agents are called players and each nonempty group of players is called a coalition. For each coalition 

<math display="inline" id="Herbert_Scarf:17">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>⊆</mo>
   <mi>N</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <ci>S</ci>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S\subseteq N
  </annotation>
 </semantics>
</math>

, let 

<math display="inline" id="Herbert_Scarf:18">
 <semantics>
  <msup>
   <mi>ℝ</mi>
   <mi>S</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>ℝ</ci>
    <ci>S</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{R}^{S}
  </annotation>
 </semantics>
</math>

 stand for the Euclidean space of dimension equal to the number of players in 

<math display="inline" id="Herbert_Scarf:19">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 and whose coordinates are indexed by the elements in 

<math display="inline" id="Herbert_Scarf:20">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

. Each coalition 

<math display="inline" id="Herbert_Scarf:21">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 is associated with a set 

<math display="inline" id="Herbert_Scarf:22">
 <semantics>
  <mrow>
   <mi>V</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>S</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>V</ci>
    <ci>S</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V(S)
  </annotation>
 </semantics>
</math>

 of possible utility vectors which can be achieved by the coalition if all players in the coalition cooperate. The set 

<math display="inline" id="Herbert_Scarf:23">
 <semantics>
  <mrow>
   <mi>V</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>S</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>V</ci>
    <ci>S</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V(S)
  </annotation>
 </semantics>
</math>

 is a subset of 

<math display="inline" id="Herbert_Scarf:24">
 <semantics>
  <msup>
   <mi>ℝ</mi>
   <mi>N</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>ℝ</ci>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{R}^{N}
  </annotation>
 </semantics>
</math>

and the i-th component 

<math display="inline" id="Herbert_Scarf:25">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i}
  </annotation>
 </semantics>
</math>

 of each element 

<math display="inline" id="Herbert_Scarf:26">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>∈</mo>
   <mrow>
    <mi>V</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>S</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>x</ci>
    <apply>
     <times></times>
     <ci>V</ci>
     <ci>S</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\in V(S)
  </annotation>
 </semantics>
</math>

 indicates a utility for player 

<math display="inline" id="Herbert_Scarf:27">
 <semantics>
  <mrow>
   <mrow>
    <mi>i</mi>
    <mo>∈</mo>
    <mi>S</mi>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>i</ci>
    <ci>S</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i\in S.
  </annotation>
 </semantics>
</math>

 The following assumptions are made on the sets 

<math display="inline" id="Herbert_Scarf:28">
 <semantics>
  <mrow>
   <mi>V</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>S</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>V</ci>
    <ci>S</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V(S)
  </annotation>
 </semantics>
</math>

:</p>

<p>1. For each coalition 

<math display="inline" id="Herbert_Scarf:29">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Herbert_Scarf:30">
 <semantics>
  <mrow>
   <mi>V</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>S</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>V</ci>
    <ci>S</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V(S)
  </annotation>
 </semantics>
</math>

 is closed and bounded from above.</p>

<p>2. If 

<math display="inline" id="Herbert_Scarf:31">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>∈</mo>
   <mrow>
    <mi>V</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>S</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>x</ci>
    <apply>
     <times></times>
     <ci>V</ci>
     <ci>S</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\in V(S)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Herbert_Scarf:32">
 <semantics>
  <mrow>
   <mi>y</mi>
   <mo>∈</mo>
   <msup>
    <mi>ℝ</mi>
    <mi>N</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>y</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ℝ</ci>
     <ci>N</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y\in\mathbb{R}^{N}
  </annotation>
 </semantics>
</math>

 with 

<math display="inline" id="Herbert_Scarf:33">
 <semantics>
  <mrow>
   <msub>
    <mi>y</mi>
    <mi>i</mi>
   </msub>
   <mo>≤</mo>
   <msub>
    <mi>x</mi>
    <mi>i</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{i}\leq x_{i}
  </annotation>
 </semantics>
</math>

 for all 

<math display="inline" id="Herbert_Scarf:34">
 <semantics>
  <mrow>
   <mi>i</mi>
   <mo>∈</mo>
   <mi>S</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>i</ci>
    <ci>S</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i\in S
  </annotation>
 </semantics>
</math>

, then 

<math display="inline" id="Herbert_Scarf:35">
 <semantics>
  <mrow>
   <mi>y</mi>
   <mo>∈</mo>
   <mrow>
    <mi>v</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>S</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>y</ci>
    <apply>
     <times></times>
     <ci>v</ci>
     <ci>S</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y\in v(S)
  </annotation>
 </semantics>
</math>

.</p>

<p>We say that a utility vector 

<math display="inline" id="Herbert_Scarf:36">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>∈</mo>
   <mrow>
    <mi>V</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>N</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>x</ci>
    <apply>
     <times></times>
     <ci>V</ci>
     <ci>N</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\in V(N)
  </annotation>
 </semantics>
</math>

 is blocked by a coalition 

<math display="inline" id="Herbert_Scarf:37">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 if there exists a utility vector 

<math display="inline" id="Herbert_Scarf:38">
 <semantics>
  <mrow>
   <mi>y</mi>
   <mo>∈</mo>
   <mrow>
    <mi>V</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>S</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>y</ci>
    <apply>
     <times></times>
     <ci>V</ci>
     <ci>S</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y\in V(S)
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Herbert_Scarf:39">
 <semantics>
  <mrow>
   <msub>
    <mi>y</mi>
    <mi>i</mi>
   </msub>
   <mo>></mo>
   <msub>
    <mi>x</mi>
    <mi>i</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{i}>x_{i}
  </annotation>
 </semantics>
</math>

 for all 

<math display="inline" id="Herbert_Scarf:40">
 <semantics>
  <mrow>
   <mi>i</mi>
   <mo>∈</mo>
   <mi>S</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>i</ci>
    <ci>S</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i\in S
  </annotation>
 </semantics>
</math>

. That is, when the coalition cooperates, every player in the coalition can actually achieve a higher utility than that given by 

<math display="inline" id="Herbert_Scarf:41">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

. A utility vector in 

<math display="inline" id="Herbert_Scarf:42">
 <semantics>
  <mrow>
   <mi>V</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>N</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>V</ci>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V(N)
  </annotation>
 </semantics>
</math>

 is in the core if no coalition can block it. An intriguing and fundamental question is what kind of game has a nonempty core. To answer this question, Scarf introduces the class of so-called balanced games.</p>

<p>A family 

<math display="inline" id="Herbert_Scarf:43">
 <semantics>
  <mi mathvariant="normal">Ω</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Ω</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Omega
  </annotation>
 </semantics>
</math>

 of coalitions in the game is said to be balanced if there exist nonnegative numbers 

<math display="inline" id="Herbert_Scarf:44">
 <semantics>
  <mrow>
   <mi>δ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>S</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>δ</ci>
    <ci>S</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta(S)
  </annotation>
 </semantics>
</math>

, for every coalition 

<math display="inline" id="Herbert_Scarf:45">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>∈</mo>
   <mi mathvariant="normal">Ω</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>S</ci>
    <ci>normal-Ω</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S\in\Omega
  </annotation>
 </semantics>
</math>

, such that 

<math display="inline" id="Herbert_Scarf:46">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mo largeop="true" symmetric="true">∑</mo>
     <mrow>
      <mi>i</mi>
      <mo>∈</mo>
      <mi>S</mi>
      <mo>∈</mo>
      <mi mathvariant="normal">Ω</mi>
     </mrow>
    </msub>
    <mrow>
     <mi>δ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>S</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <and></and>
       <apply>
        <in></in>
        <ci>i</ci>
        <ci>S</ci>
       </apply>
       <apply>
        <in></in>
        <share href="#.cmml">
        </share>
        <ci>normal-Ω</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>δ</ci>
      <ci>S</ci>
     </apply>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{i\in S\in\Omega}\delta(S)=1
  </annotation>
 </semantics>
</math>

 for every 

<math display="inline" id="Herbert_Scarf:47">
 <semantics>
  <mrow>
   <mrow>
    <mi>i</mi>
    <mo>∈</mo>
    <mi>N</mi>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>i</ci>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i\in N.
  </annotation>
 </semantics>
</math>

 (Any partition of the grand coalition 

<math display="inline" id="Herbert_Scarf:48">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

 is a simple example of a balanced family.) The game is said to be balanced if for every balanced family 

<math display="inline" id="Herbert_Scarf:49">
 <semantics>
  <mi mathvariant="normal">Ω</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Ω</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Omega
  </annotation>
 </semantics>
</math>

, a utility vector 

<math display="inline" id="Herbert_Scarf:50">
 <semantics>
  <mi>u</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>u</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u
  </annotation>
 </semantics>
</math>

 must be in 

<math display="inline" id="Herbert_Scarf:51">
 <semantics>
  <mrow>
   <mi>V</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>N</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>V</ci>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V(N)
  </annotation>
 </semantics>
</math>

 if 

<math display="inline" id="Herbert_Scarf:52">
 <semantics>
  <mi>u</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>u</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u
  </annotation>
 </semantics>
</math>

 is in 

<math display="inline" id="Herbert_Scarf:53">
 <semantics>
  <mrow>
   <mi>V</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>S</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>V</ci>
    <ci>S</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V(S)
  </annotation>
 </semantics>
</math>

 for every coalition 

<math display="inline" id="Herbert_Scarf:54">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>∈</mo>
   <mi mathvariant="normal">Ω</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>S</ci>
    <ci>normal-Ω</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S\in\Omega
  </annotation>
 </semantics>
</math>

. Scarf proved the following theorem based on a finite algorithm.</p>

<p><strong>Scarf’s Theorem</strong>: Every balanced game has a nonempty core.</p>
<h3 id="scarfs-combinatorial-lemma">6. Scarf’s Combinatorial Lemma</h3>

<p>To prove his core existence theorem on the balanced game, Scarf (1967) introduced an elegant and fundamental combinatorial lemma which has found applications in various subjects.</p>

<p>Let 

<math display="inline" id="Herbert_Scarf:55">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Herbert_Scarf:56">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

 be two 

<math display="inline" id="Herbert_Scarf:57">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>×</mo>
   <mi>m</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>n</ci>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n\times m
  </annotation>
 </semantics>
</math>

 matrices of the following form:</p>

<p>

<math display="inline" id="Herbert_Scarf:58">
 <semantics>
  <mrow>
   <mi>𝐀</mi>
   <mo>=</mo>
   <mrow>
    <mo>[</mo>
    <mtable>
     <mtr>
      <mtd columnalign="center">
       <mn>1</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mi mathvariant="normal">⋯</mi>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mrow>
        <mi>a</mi>
        <mo>;</mo>
        <mrow>
         <mo stretchy="false">(</mo>
         <mn>1</mn>
         <mo>,</mo>
         <mrow>
          <mi>n</mi>
          <mo>+</mo>
          <mn>1</mn>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mtd>
      <mtd columnalign="center">
       <mi mathvariant="normal">⋯</mi>
      </mtd>
      <mtd columnalign="center">
       <mrow>
        <mi>a</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mn>1</mn>
         <mo>,</mo>
         <mi>m</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>1</mn>
      </mtd>
      <mtd columnalign="center">
       <mi mathvariant="normal">⋯</mi>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mrow>
        <mi>a</mi>
        <mo>;</mo>
        <mrow>
         <mo stretchy="false">(</mo>
         <mn>2</mn>
         <mo>,</mo>
         <mrow>
          <mi>n</mi>
          <mo>+</mo>
          <mn>2</mn>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mtd>
      <mtd columnalign="center">
       <mi mathvariant="normal">⋯</mi>
      </mtd>
      <mtd columnalign="center">
       <mrow>
        <mi>a</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mn>2</mn>
         <mo>,</mo>
         <mi>m</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mi></mi>
      </mtd>
      <mtd columnalign="center">
       <mi></mi>
      </mtd>
      <mtd columnalign="center">
       <mi mathvariant="normal">⋯</mi>
      </mtd>
      <mtd columnalign="center">
       <mi></mi>
      </mtd>
      <mtd columnalign="center">
       <mi></mi>
      </mtd>
      <mtd columnalign="center">
       <mi mathvariant="normal">⋯</mi>
      </mtd>
      <mtd columnalign="center">
       <mi></mi>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mi mathvariant="normal">⋯</mi>
      </mtd>
      <mtd columnalign="center">
       <mn>1</mn>
      </mtd>
      <mtd columnalign="center">
       <mrow>
        <mi>a</mi>
        <mo>;</mo>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>n</mi>
         <mo>,</mo>
         <mrow>
          <mi>n</mi>
          <mo>+</mo>
          <mn>1</mn>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mtd>
      <mtd columnalign="center">
       <mi mathvariant="normal">⋯</mi>
      </mtd>
      <mtd columnalign="center">
       <mrow>
        <mi>a</mi>
        <mo>;</mo>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>n</mi>
         <mo>,</mo>
         <mi>m</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mtd>
     </mtr>
    </mtable>
    <mo>]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>𝐀</ci>
    <matrix>
     <matrixrow>
      <cn type="integer">1</cn>
      <cn type="integer">0</cn>
      <ci>normal-⋯</ci>
      <cn type="integer">0</cn>
      <list>
       <ci>a</ci>
       <interval closure="open">
        <cn type="integer">1</cn>
        <apply>
         <plus></plus>
         <ci>n</ci>
         <cn type="integer">1</cn>
        </apply>
       </interval>
      </list>
      <ci>normal-⋯</ci>
      <apply>
       <times></times>
       <ci>a</ci>
       <interval closure="open">
        <cn type="integer">1</cn>
        <ci>m</ci>
       </interval>
      </apply>
     </matrixrow>
     <matrixrow>
      <cn type="integer">0</cn>
      <cn type="integer">1</cn>
      <ci>normal-⋯</ci>
      <cn type="integer">0</cn>
      <list>
       <ci>a</ci>
       <interval closure="open">
        <cn type="integer">2</cn>
        <apply>
         <plus></plus>
         <ci>n</ci>
         <cn type="integer">2</cn>
        </apply>
       </interval>
      </list>
      <ci>normal-⋯</ci>
      <apply>
       <times></times>
       <ci>a</ci>
       <interval closure="open">
        <cn type="integer">2</cn>
        <ci>m</ci>
       </interval>
      </apply>
     </matrixrow>
     <matrixrow>
      <csymbol cd="latexml">absent</csymbol>
      <csymbol cd="latexml">absent</csymbol>
      <ci>normal-⋯</ci>
      <csymbol cd="latexml">absent</csymbol>
      <csymbol cd="latexml">absent</csymbol>
      <ci>normal-⋯</ci>
      <csymbol cd="latexml">absent</csymbol>
     </matrixrow>
     <matrixrow>
      <cn type="integer">0</cn>
      <cn type="integer">0</cn>
      <ci>normal-⋯</ci>
      <cn type="integer">1</cn>
      <list>
       <ci>a</ci>
       <interval closure="open">
        <ci>n</ci>
        <apply>
         <plus></plus>
         <ci>n</ci>
         <cn type="integer">1</cn>
        </apply>
       </interval>
      </list>
      <ci>normal-⋯</ci>
      <list>
       <ci>a</ci>
       <interval closure="open">
        <ci>n</ci>
        <ci>m</ci>
       </interval>
      </list>
     </matrixrow>
    </matrix>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{A}=\begin{bmatrix}1&0&\cdots&0&a;(1,n+1)&\cdots&a(1,m)\\
0&1&\cdots&0&a;(2,n+2)&\cdots&a(2,m)\\
&&\cdots&&&\cdots&\\
0&0&\cdots&1&a;(n,n+1)&\cdots&a;(n,m)\end{bmatrix}
  </annotation>
 </semantics>
</math>

</p>

<p>and 

<math display="inline" id="Herbert_Scarf:59">
 <semantics>
  <mrow>
   <mi>𝐂</mi>
   <mo>=</mo>
   <mrow>
    <mo>[</mo>
    <mtable>
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <mi>c</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mn>1</mn>
         <mo>,</mo>
         <mn>1</mn>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mtd>
      <mtd columnalign="center">
       <mi mathvariant="normal">⋯</mi>
      </mtd>
      <mtd columnalign="center">
       <mrow>
        <mi>c</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mn>1</mn>
         <mo>,</mo>
         <mi>n</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mtd>
      <mtd columnalign="center">
       <mrow>
        <mi>c</mi>
        <mo>;</mo>
        <mrow>
         <mo stretchy="false">(</mo>
         <mn>1</mn>
         <mo>,</mo>
         <mrow>
          <mi>n</mi>
          <mo>+</mo>
          <mn>1</mn>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mtd>
      <mtd columnalign="center">
       <mi mathvariant="normal">⋯</mi>
      </mtd>
      <mtd columnalign="center">
       <mrow>
        <mi>c</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mn>1</mn>
         <mo>,</mo>
         <mi>m</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <mi>c</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mn>2</mn>
         <mo>,</mo>
         <mn>1</mn>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mtd>
      <mtd columnalign="center">
       <mi mathvariant="normal">⋯</mi>
      </mtd>
      <mtd columnalign="center">
       <mrow>
        <mi>c</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mn>2</mn>
         <mo>,</mo>
         <mi>n</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mtd>
      <mtd columnalign="center">
       <mrow>
        <mi>c</mi>
        <mo>;</mo>
        <mrow>
         <mo stretchy="false">(</mo>
         <mn>2</mn>
         <mo>,</mo>
         <mrow>
          <mi>n</mi>
          <mo>+</mo>
          <mn>2</mn>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mtd>
      <mtd columnalign="center">
       <mi mathvariant="normal">⋯</mi>
      </mtd>
      <mtd columnalign="center">
       <mrow>
        <mi>c</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mn>2</mn>
         <mo>,</mo>
         <mi>m</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mi></mi>
      </mtd>
      <mtd columnalign="center">
       <mi mathvariant="normal">⋯</mi>
      </mtd>
      <mtd columnalign="center">
       <mi></mi>
      </mtd>
      <mtd columnalign="center">
       <mi></mi>
      </mtd>
      <mtd columnalign="center">
       <mi mathvariant="normal">⋯</mi>
      </mtd>
      <mtd columnalign="center">
       <mi></mi>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <mi>c</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>n</mi>
         <mo>,</mo>
         <mn>1</mn>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mtd>
      <mtd columnalign="center">
       <mi mathvariant="normal">⋯</mi>
      </mtd>
      <mtd columnalign="center">
       <mrow>
        <mi>c</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>n</mi>
         <mo>,</mo>
         <mi>n</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mtd>
      <mtd columnalign="center">
       <mrow>
        <mi>c</mi>
        <mo>;</mo>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>n</mi>
         <mo>,</mo>
         <mrow>
          <mi>n</mi>
          <mo>+</mo>
          <mn>1</mn>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mtd>
      <mtd columnalign="center">
       <mi mathvariant="normal">⋯</mi>
      </mtd>
      <mtd columnalign="center">
       <mrow>
        <mi>c</mi>
        <mo>;</mo>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>n</mi>
         <mo>,</mo>
         <mi>m</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mtd>
     </mtr>
    </mtable>
    <mo>]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>𝐂</ci>
    <matrix>
     <matrixrow>
      <apply>
       <times></times>
       <ci>c</ci>
       <interval closure="open">
        <cn type="integer">1</cn>
        <cn type="integer">1</cn>
       </interval>
      </apply>
      <ci>normal-⋯</ci>
      <apply>
       <times></times>
       <ci>c</ci>
       <interval closure="open">
        <cn type="integer">1</cn>
        <ci>n</ci>
       </interval>
      </apply>
      <list>
       <ci>c</ci>
       <interval closure="open">
        <cn type="integer">1</cn>
        <apply>
         <plus></plus>
         <ci>n</ci>
         <cn type="integer">1</cn>
        </apply>
       </interval>
      </list>
      <ci>normal-⋯</ci>
      <apply>
       <times></times>
       <ci>c</ci>
       <interval closure="open">
        <cn type="integer">1</cn>
        <ci>m</ci>
       </interval>
      </apply>
     </matrixrow>
     <matrixrow>
      <apply>
       <times></times>
       <ci>c</ci>
       <interval closure="open">
        <cn type="integer">2</cn>
        <cn type="integer">1</cn>
       </interval>
      </apply>
      <ci>normal-⋯</ci>
      <apply>
       <times></times>
       <ci>c</ci>
       <interval closure="open">
        <cn type="integer">2</cn>
        <ci>n</ci>
       </interval>
      </apply>
      <list>
       <ci>c</ci>
       <interval closure="open">
        <cn type="integer">2</cn>
        <apply>
         <plus></plus>
         <ci>n</ci>
         <cn type="integer">2</cn>
        </apply>
       </interval>
      </list>
      <ci>normal-⋯</ci>
      <apply>
       <times></times>
       <ci>c</ci>
       <interval closure="open">
        <cn type="integer">2</cn>
        <ci>m</ci>
       </interval>
      </apply>
     </matrixrow>
     <matrixrow>
      <csymbol cd="latexml">absent</csymbol>
      <ci>normal-⋯</ci>
      <csymbol cd="latexml">absent</csymbol>
      <csymbol cd="latexml">absent</csymbol>
      <ci>normal-⋯</ci>
      <csymbol cd="latexml">absent</csymbol>
     </matrixrow>
     <matrixrow>
      <apply>
       <times></times>
       <ci>c</ci>
       <interval closure="open">
        <ci>n</ci>
        <cn type="integer">1</cn>
       </interval>
      </apply>
      <ci>normal-⋯</ci>
      <apply>
       <times></times>
       <ci>c</ci>
       <interval closure="open">
        <ci>n</ci>
        <ci>n</ci>
       </interval>
      </apply>
      <list>
       <ci>c</ci>
       <interval closure="open">
        <ci>n</ci>
        <apply>
         <plus></plus>
         <ci>n</ci>
         <cn type="integer">1</cn>
        </apply>
       </interval>
      </list>
      <ci>normal-⋯</ci>
      <list>
       <ci>c</ci>
       <interval closure="open">
        <ci>n</ci>
        <ci>m</ci>
       </interval>
      </list>
     </matrixrow>
    </matrix>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{C}=\begin{bmatrix}c(1,1)&\cdots&c(1,n)&c;(1,n+1)&\cdots&c(1,m)\\
c(2,1)&\cdots&c(2,n)&c;(2,n+2)&\cdots&c(2,m)\\
&\cdots&&&\cdots&\\
c(n,1)&\cdots&c(n,n)&c;(n,n+1)&\cdots&c;(n,m)\end{bmatrix}
  </annotation>
 </semantics>
</math>

</p>

<p>The matrices 

<math display="inline" id="Herbert_Scarf:60">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Herbert_Scarf:61">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

 are said to be in standard form if for every row 

<math display="inline" id="Herbert_Scarf:62">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Herbert_Scarf:63">
 <semantics>
  <mrow>
   <mi>c</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>i</mi>
    <mo>,</mo>
    <mi>i</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>c</ci>
    <interval closure="open">
     <ci>i</ci>
     <ci>i</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c(i,i)
  </annotation>
 </semantics>
</math>

 is the minimum of the elements in its row, and if for every non-diagonal element 

<math display="inline" id="Herbert_Scarf:64">
 <semantics>
  <mrow>
   <mi>c</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>i</mi>
    <mo>,</mo>
    <mi>j</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>c</ci>
    <interval closure="open">
     <ci>i</ci>
     <ci>j</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c(i,j)
  </annotation>
 </semantics>
</math>

 in the square submatrix of 

<math display="inline" id="Herbert_Scarf:65">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

 formed by the first 

<math display="inline" id="Herbert_Scarf:66">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 columns, and for every 

<math display="inline" id="Herbert_Scarf:67">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 with 

<math display="inline" id="Herbert_Scarf:68">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

.</p>

<p><strong>Scarf’s Lemma</strong>: Assume that 

<math display="inline" id="Herbert_Scarf:69">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Herbert_Scarf:70">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>×</mo>
   <mi>m</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>n</ci>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n\times m
  </annotation>
 </semantics>
</math>

 are two 

<math display="inline" id="Herbert_Scarf:71">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>

 matrices in standard form, and that 

<math display="inline" id="Herbert_Scarf:72">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mi>x</mi>
   <mo>∣</mo>
   <mrow>
    <mrow>
     <mi>A</mi>
     <mi>x</mi>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mpadded width="+1.7pt">
      <mi>b</mi>
     </mpadded>
     <mpadded width="+1.7pt">
      <mtext>and</mtext>
     </mpadded>
     <mi>x</mi>
    </mrow>
    <mo>≥</mo>
    <mn>0</mn>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">conditional-set</csymbol>
    <ci>x</ci>
    <apply>
     <and></and>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <ci>A</ci>
       <ci>x</ci>
      </apply>
      <apply>
       <times></times>
       <ci>b</ci>
       <mtext>and</mtext>
       <ci>x</ci>
      </apply>
     </apply>
     <apply>
      <geq></geq>
      <share href="#.cmml">
      </share>
      <cn type="integer">0</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{x\mid Ax=b\,\mbox{and}\,x\geq 0\}
  </annotation>
 </semantics>
</math>

 is a nonnegative vector such that the set 

<math display="inline" id="Herbert_Scarf:73">
 <semantics>
  <mrow>
   <mrow>
    <mi>A</mi>
    <mi>x</mi>
   </mrow>
   <mo>=</mo>
   <mi>b</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>A</ci>
     <ci>x</ci>
    </apply>
    <ci>b</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Ax=b
  </annotation>
 </semantics>
</math>

 is bounded. Then there exists a feasible basis for the system of linear equations 

<math display="inline" id="Herbert_Scarf:74">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>≥</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <ci>x</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\geq 0
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Herbert_Scarf:75">
 <semantics>
  <mrow>
   <msub>
    <mi>u</mi>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>min</mi>
     <mi>c</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>i</mi>
     <mo>,</mo>
     <mi>j</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>u</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <min></min>
      <ci>c</ci>
     </apply>
     <interval closure="open">
      <ci>i</ci>
      <ci>j</ci>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u_{i}=\min c(i,j)
  </annotation>
 </semantics>
</math>

, so that if we define 

<math display="inline" id="Herbert_Scarf:76">
 <semantics>
  <mi>j</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>j</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   j
  </annotation>
 </semantics>
</math>

 for all columns 

<math display="inline" id="Herbert_Scarf:77">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 in this basis, then for every column 

<math display="inline" id="Herbert_Scarf:78">
 <semantics>
  <mrow>
   <msub>
    <mi>u</mi>
    <mi>i</mi>
   </msub>
   <mo>≥</mo>
   <mrow>
    <mi>c</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>i</mi>
     <mo>,</mo>
     <mi>k</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>u</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <times></times>
     <ci>c</ci>
     <interval closure="open">
      <ci>i</ci>
      <ci>k</ci>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u_{i}\geq c(i,k)
  </annotation>
 </semantics>
</math>

, we have 

<math display="inline" id="Herbert_Scarf:79">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

 for some index 

<math display="inline" id="Herbert_Scarf:80">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mo>:</mo>
   <mrow>
    <msup>
     <mi>S</mi>
     <mi>n</mi>
    </msup>
    <mo>→</mo>
    <msup>
     <mi>S</mi>
     <mi>n</mi>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>f</ci>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>S</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>S</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f:S^{n}\to S^{n}
  </annotation>
 </semantics>
</math>

.</p>
<h3 id="the-computation-of-economic-equilibria">7. The Computation of Economic Equilibria</h3>

<p>Scarf’s book ``The Computation of Economic Equilibria” (Yale University Press, 1973) is considered his magnum opus. It is a monumental work both in economic theory and in applied mathematics. Scarf ingeniously developed the first general constructive method for the explicit numerical solution to the neoclassical model of economic equilibrium and has made it possible to transform such a model from an abstract representation of an economy into realistic models of actual economies, permitting us to evaluate the effects of significant changes in the environment and in economic policies.</p>

<p>One of the central themes of economic theory is that the behaviour of a highly complex economic system can be seen as an equilibrium outcome arising from the interactions of many individuals within the system with different and even conflicting interests and motivations. This fundamental idea was first formulated by Walras (1874) and further significantly developed by Wald (1936), Arrow and Debreu (1954), and McKenzie (1959) among many others as the neoclassical model of competitive equilibrium. When cast in a mathematical form such a model will become a system of highly nonlinear equations with multiple variables which represent prices of goods and services in the studied economy. The typical argument for the existence of a solution in this system is to apply Brouwer’s fixed point theorem (1912) – a fundamental theorem in mathematics which, however, does not offer any effective numerical solution. Brouwer’s theorem states that every continuous function 

<math display="inline" id="Herbert_Scarf:81">
 <semantics>
  <msup>
   <mi>S</mi>
   <mi>n</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>S</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S^{n}
  </annotation>
 </semantics>
</math>

 mapping from a unit simplex 

<math display="inline" id="Herbert_Scarf:82">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>p</mi>
      <mo>*</mo>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msup>
    <mi>p</mi>
    <mo>*</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>p</ci>
      <times></times>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>p</ci>
     <times></times>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(p^{*})=p^{*}
  </annotation>
 </semantics>
</math>

 into itself must have a fixed point 

<math display="inline" id="Herbert_Scarf:83">
 <semantics>
  <mrow>
   <msup>
    <mi>S</mi>
    <mi>n</mi>
   </msup>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mi>x</mi>
     <mo>∈</mo>
     <msubsup>
      <mi>ℝ</mi>
      <mo>+</mo>
      <mi>n</mi>
     </msubsup>
    </mrow>
    <mo>∣</mo>
    <mrow>
     <mrow>
      <msubsup>
       <mo largeop="true" symmetric="true">∑</mo>
       <mrow>
        <mi>i</mi>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <mi>n</mi>
      </msubsup>
      <msub>
       <mi>x</mi>
       <mi>i</mi>
      </msub>
     </mrow>
     <mo>=</mo>
     <mn>1</mn>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>S</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <apply>
      <in></in>
      <ci>x</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>ℝ</ci>
        <ci>n</ci>
       </apply>
       <plus></plus>
      </apply>
     </apply>
     <apply>
      <eq></eq>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <ci>i</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>n</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>i</ci>
       </apply>
      </apply>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S^{n}=\{x\in\mathbb{R}^{n}_{+}\mid\sum_{i=1}^{n}x_{i}=1\}
  </annotation>
 </semantics>
</math>

, where</p>

<p>

<math display="inline" id="Herbert_Scarf:84">
 <semantics>
  <msup>
   <mi>S</mi>
   <mi>n</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>S</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S^{n}
  </annotation>
 </semantics>
</math>

</p>

<p>is the unit simplex whose elements are non-negative and the sum of all components equals one. As soon as we know a fixed point for the function constructed from the studied economy, we know its corresponding equilibrium in the economy.</p>

<p>Scarf proposed an algorithm for calculating a fixed point as stated in Brouwer’s theorem. As a result, he gave the first constructive proof for Brouwer’s theorem which is a major tool for establishing the existence of a solution to problems arising in various subjects. Scarf’s algorithm can be described as follows. One first subdivides the unit simplex 

<math display="inline" id="Herbert_Scarf:85">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mn>1</mn>
   <mo>,</mo>
   <mn>2</mn>
   <mo>,</mo>
   <mi mathvariant="normal">⋯</mi>
   <mo>,</mo>
   <mi>n</mi>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <cn type="integer">1</cn>
    <cn type="integer">2</cn>
    <ci>normal-⋯</ci>
    <ci>n</ci>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{1,2,\cdots,n\}
  </annotation>
 </semantics>
</math>

 into a finite simplicial subdivision. Each subsimplex is the convex hull of its vertices. Then one assigns each vertex a label from the set 

<math display="inline" id="Herbert_Scarf:86">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

, where the label of each vertex 

<math display="inline" id="Herbert_Scarf:87">
 <semantics>
  <mrow>
   <mrow>
    <mi>l</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>min</mi>
    <mrow>
     <mo stretchy="false">{</mo>
     <mrow>
      <mi>j</mi>
      <mrow>
       <mo fence="true">∣</mo>
       <mrow>
        <mrow>
         <msub>
          <mi>f</mi>
          <mi>j</mi>
         </msub>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>x</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>≤</mo>
        <msub>
         <mi>x</mi>
         <mi>j</mi>
        </msub>
       </mrow>
       <mo>></mo>
      </mrow>
      <mn>0</mn>
     </mrow>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>l</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <min></min>
     <apply>
      <times></times>
      <ci>j</ci>
      <apply>
       <csymbol cd="latexml">ket</csymbol>
       <apply>
        <leq></leq>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>f</ci>
          <ci>j</ci>
         </apply>
         <ci>x</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>j</ci>
        </apply>
       </apply>
      </apply>
      <cn type="integer">0</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   l(x)=\min\{j\mid f_{j}(x)\leq x_{j}>0\}
  </annotation>
 </semantics>
</math>

 is given by 

<math display="inline" id="Herbert_Scarf:88">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mi>j</mi>
   </msub>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>j</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{j}=0
  </annotation>
 </semantics>
</math>

. By definition, 

<math display="inline" id="Herbert_Scarf:89">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>l</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>≠</mo>
    <mi>j</mi>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <neq></neq>
    <apply>
     <times></times>
     <ci>l</ci>
     <ci>x</ci>
    </apply>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   l(x)\neq j.
  </annotation>
 </semantics>
</math>

 implies 

<math display="inline" id="Herbert_Scarf:90">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 A labelling rule with this property is said to be proper. According to a remarkable combinatorial theorem called Sperner’s lemma (1928), if we are given a simplicial subdivision of a unit simplex and a proper labelling rule, there always exists a completely labelled subsimplex, i.e., a simplex each of whose 

<math display="inline" id="Herbert_Scarf:91">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>=</mo>
   <mn>3</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>n</ci>
    <cn type="integer">3</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n=3
  </annotation>
 </semantics>
</math>

 vertices carry a distinct label.</p>

<p>It is easy to show that if the labels are correctly selected, a completely labelled subsimplex contains an approximate fixed point of the function. The finer the subdivision, the better will be the approximation. Now the problem of finding an approximate fixed point is to search for a completely labelled subsimplex. Unfortunately, the original proof and its subsequent arguments for Sperner’s lemma were inductive in nature and thus virtually impossible to implement. Scarf (1967, 1973) introduced an effective and finite algorithm that can always find a completely labelled subsimplex.</p>

<p>The basic idea of Scarf’s algorithm can be clearly illustrated for 

<math display="inline" id="Herbert_Scarf:92">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n.
  </annotation>
 </semantics>
</math>

 and the same logic applies to higher values of 

<math display="inline" id="Herbert_Scarf:93">
 <semantics>
  <mrow>
   <mrow>
    <mi>l</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>x</mi>
      <mn>1</mn>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>l</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   l(x^{1})=1
  </annotation>
 </semantics>
</math>

 We can embed the unit simplex in a larger simplex as shown in Figure 1. The larger simplex is subdivided by linking its three new vertices with the vertices lying on the boundary of the original unit simplex. A proper labelling always leads to</p>

<p>

<math display="inline" id="Herbert_Scarf:94">
 <semantics>
  <mrow>
   <mrow>
    <mi>l</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>x</mi>
      <mn>2</mn>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>l</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   l(x^{2})=2
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Herbert_Scarf:95">
 <semantics>
  <mrow>
   <mrow>
    <mi>l</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>x</mi>
      <mn>3</mn>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>3</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>l</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <cn type="integer">3</cn>
     </apply>
    </apply>
    <cn type="integer">3</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   l(x^{3})=3
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="Herbert_Scarf:96">
 <semantics>
  <mrow>
   <msup>
    <mi>x</mi>
    <mn>1</mn>
   </msup>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>1</mn>
    <mo>,</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mn>0</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
    <vector>
     <cn type="integer">1</cn>
     <cn type="integer">0</cn>
     <cn type="integer">0</cn>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{1}=(1,0,0)
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Herbert_Scarf:97">
 <semantics>
  <mrow>
   <msup>
    <mi>x</mi>
    <mn>2</mn>
   </msup>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mn>1</mn>
    <mo>,</mo>
    <mn>0</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <cn type="integer">2</cn>
    </apply>
    <vector>
     <cn type="integer">0</cn>
     <cn type="integer">1</cn>
     <cn type="integer">0</cn>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{2}=(0,1,0)
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Herbert_Scarf:98">
 <semantics>
  <mrow>
   <msup>
    <mi>x</mi>
    <mn>3</mn>
   </msup>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <cn type="integer">3</cn>
    </apply>
    <vector>
     <cn type="integer">0</cn>
     <cn type="integer">0</cn>
     <cn type="integer">1</cn>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{3}=(0,0,1)
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="Herbert_Scarf:99">
 <semantics>
  <mrow>
   <msup>
    <mi>S</mi>
    <mn>3</mn>
   </msup>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>S</ci>
    <cn type="integer">3</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S^{3}.
  </annotation>
 </semantics>
</math>

</p>

<p>are the vertices of the original unit simplex 

<math display="inline" id="Herbert_Scarf:100">
 <semantics>
  <mtable>
   <mtr>
    <mtd></mtd>
    <mtd></mtd>
    <mtd columnalign="right">
     <mrow>
      <mi>max</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mrow>
         <mi>a</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mn>0</mn>
          <mo>,</mo>
          <mn>1</mn>
          <mo stretchy="false">)</mo>
         </mrow>
         <msub>
          <mi>h</mi>
          <mn>1</mn>
         </msub>
        </mrow>
        <mo>+</mo>
        <mrow>
         <mi>a</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mn>0</mn>
          <mo>,</mo>
          <mn>2</mn>
          <mo stretchy="false">)</mo>
         </mrow>
         <msub>
          <mi>h</mi>
          <mn>2</mn>
         </msub>
        </mrow>
        <mo>+</mo>
        <mi mathvariant="normal">⋯</mi>
        <mo>+</mo>
        <mrow>
         <mi>a</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mn>0</mn>
          <mo>,</mo>
          <mi>n</mi>
          <mo stretchy="false">)</mo>
         </mrow>
         <msub>
          <mi>h</mi>
          <mi>n</mi>
         </msub>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd></mtd>
    <mtd></mtd>
    <mtd columnalign="right">
     <mrow>
      <mrow>
       <mrow>
        <mi mathvariant="normal">s</mi>
        <mo>.</mo>
        <mi mathvariant="normal">t</mi>
        <mo>.</mo>
       </mrow>
       <mrow>
        <mrow>
         <mi>a</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mn>1</mn>
          <mo>,</mo>
          <mn>1</mn>
          <mo stretchy="false">)</mo>
         </mrow>
         <msub>
          <mi>h</mi>
          <mn>1</mn>
         </msub>
        </mrow>
        <mo>+</mo>
        <mrow>
         <mi>a</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mn>1</mn>
          <mo>,</mo>
          <mn>2</mn>
          <mo stretchy="false">)</mo>
         </mrow>
         <msub>
          <mi>h</mi>
          <mn>2</mn>
         </msub>
        </mrow>
        <mo>+</mo>
        <mi mathvariant="normal">⋯</mi>
        <mo>+</mo>
        <mrow>
         <mi>a</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mn>1</mn>
          <mo>,</mo>
          <mi>n</mi>
          <mo stretchy="false">)</mo>
         </mrow>
         <msub>
          <mi>h</mi>
          <mi>n</mi>
         </msub>
        </mrow>
       </mrow>
      </mrow>
      <mo>≥</mo>
      <msub>
       <mi>b</mi>
       <mn>1</mn>
      </msub>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd></mtd>
    <mtd></mtd>
    <mtd columnalign="right">
     <mrow>
      <mrow>
       <mrow>
        <mpadded lspace="10pt" width="+10pt">
         <mi>a</mi>
        </mpadded>
        <mrow>
         <mo stretchy="false">(</mo>
         <mn>2</mn>
         <mo>,</mo>
         <mn>1</mn>
         <mo stretchy="false">)</mo>
        </mrow>
        <msub>
         <mi>h</mi>
         <mn>1</mn>
        </msub>
       </mrow>
       <mo>+</mo>
       <mrow>
        <mi>a</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mn>2</mn>
         <mo>,</mo>
         <mn>2</mn>
         <mo stretchy="false">)</mo>
        </mrow>
        <msub>
         <mi>h</mi>
         <mn>2</mn>
        </msub>
       </mrow>
       <mo>+</mo>
       <mi mathvariant="normal">⋯</mi>
       <mo>+</mo>
       <mrow>
        <mi>a</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mn>2</mn>
         <mo>,</mo>
         <mi>n</mi>
         <mo stretchy="false">)</mo>
        </mrow>
        <msub>
         <mi>h</mi>
         <mi>n</mi>
        </msub>
       </mrow>
      </mrow>
      <mo>≥</mo>
      <msub>
       <mi>b</mi>
       <mn>2</mn>
      </msub>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd></mtd>
    <mtd></mtd>
    <mtd columnalign="right">
     <mrow>
      <mpadded lspace="10pt" width="+10pt">
       <mi mathvariant="normal">⋮</mi>
      </mpadded>
      <mi mathvariant="normal">⋮</mi>
      <mi mathvariant="normal">⋮</mi>
      <mi mathvariant="normal">⋮</mi>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd></mtd>
    <mtd></mtd>
    <mtd columnalign="right">
     <mrow>
      <mrow>
       <mrow>
        <mpadded lspace="10pt" width="+10pt">
         <mi>a</mi>
        </mpadded>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>m</mi>
         <mo>,</mo>
         <mn>1</mn>
         <mo stretchy="false">)</mo>
        </mrow>
        <msub>
         <mi>h</mi>
         <mn>1</mn>
        </msub>
       </mrow>
       <mo>+</mo>
       <mrow>
        <mi>a</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>m</mi>
         <mo>,</mo>
         <mn>2</mn>
         <mo stretchy="false">)</mo>
        </mrow>
        <msub>
         <mi>h</mi>
         <mn>2</mn>
        </msub>
       </mrow>
       <mo>+</mo>
       <mi mathvariant="normal">⋯</mi>
       <mo>+</mo>
       <mrow>
        <mi>a</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>m</mi>
         <mo>,</mo>
         <mi>n</mi>
         <mo stretchy="false">)</mo>
        </mrow>
        <msub>
         <mi>h</mi>
         <mi>n</mi>
        </msub>
       </mrow>
      </mrow>
      <mo>≥</mo>
      <msub>
       <mi>b</mi>
       <mi>m</mi>
      </msub>
     </mrow>
    </mtd>
   </mtr>
  </mtable>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <apply>
      <max></max>
      <apply>
       <plus></plus>
       <apply>
        <times></times>
        <ci>a</ci>
        <interval closure="open">
         <cn type="integer">0</cn>
         <cn type="integer">1</cn>
        </interval>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>h</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <times></times>
        <ci>a</ci>
        <interval closure="open">
         <cn type="integer">0</cn>
         <cn type="integer">2</cn>
        </interval>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>h</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
       <ci>normal-⋯</ci>
       <apply>
        <times></times>
        <ci>a</ci>
        <interval closure="open">
         <cn type="integer">0</cn>
         <ci>n</ci>
        </interval>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>h</ci>
         <ci>n</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </matrixrow>
    <matrixrow>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <apply>
      <geq></geq>
      <list>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <csymbol cd="unknown">s</csymbol>
        <ci>normal-.</ci>
        <csymbol cd="unknown">t</csymbol>
        <ci>normal-.</ci>
       </cerror>
       <apply>
        <plus></plus>
        <apply>
         <times></times>
         <ci>a</ci>
         <interval closure="open">
          <cn type="integer">1</cn>
          <cn type="integer">1</cn>
         </interval>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>h</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <apply>
         <times></times>
         <ci>a</ci>
         <interval closure="open">
          <cn type="integer">1</cn>
          <cn type="integer">2</cn>
         </interval>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>h</ci>
          <cn type="integer">2</cn>
         </apply>
        </apply>
        <ci>normal-⋯</ci>
        <apply>
         <times></times>
         <ci>a</ci>
         <interval closure="open">
          <cn type="integer">1</cn>
          <ci>n</ci>
         </interval>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>h</ci>
          <ci>n</ci>
         </apply>
        </apply>
       </apply>
      </list>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </matrixrow>
    <matrixrow>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <apply>
      <geq></geq>
      <apply>
       <plus></plus>
       <apply>
        <times></times>
        <ci>a</ci>
        <interval closure="open">
         <cn type="integer">2</cn>
         <cn type="integer">1</cn>
        </interval>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>h</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <times></times>
        <ci>a</ci>
        <interval closure="open">
         <cn type="integer">2</cn>
         <cn type="integer">2</cn>
        </interval>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>h</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
       <ci>normal-⋯</ci>
       <apply>
        <times></times>
        <ci>a</ci>
        <interval closure="open">
         <cn type="integer">2</cn>
         <ci>n</ci>
        </interval>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>h</ci>
         <ci>n</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </matrixrow>
    <matrixrow>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <list>
      <ci>normal-⋮</ci>
      <ci>normal-⋮</ci>
      <ci>normal-⋮</ci>
      <ci>normal-⋮</ci>
     </list>
    </matrixrow>
    <matrixrow>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <apply>
      <geq></geq>
      <apply>
       <plus></plus>
       <apply>
        <times></times>
        <ci>a</ci>
        <interval closure="open">
         <ci>m</ci>
         <cn type="integer">1</cn>
        </interval>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>h</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <times></times>
        <ci>a</ci>
        <interval closure="open">
         <ci>m</ci>
         <cn type="integer">2</cn>
        </interval>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>h</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
       <ci>normal-⋯</ci>
       <apply>
        <times></times>
        <ci>a</ci>
        <interval closure="open">
         <ci>m</ci>
         <ci>n</ci>
        </interval>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>h</ci>
         <ci>n</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <ci>m</ci>
      </apply>
     </apply>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{aligned}&&\displaystyle\max(a(0,1)h_{1}+a(0,2)h_{2}+\cdots+a(0,n)h_{n})%
\\
&&\displaystyle{\operatorname{s.t.}}\quad a(1,1)h_{1}+a(1,2)h_{2}+\cdots+a(1,n%
)h_{n}\geq b_{1}\\
&&\displaystyle\quad a(2,1)h_{1}+a(2,2)h_{2}+\cdots+a(2,n)h_{n}\geq b_{2}\\
&&\displaystyle\quad\vdots\quad\vdots\quad\vdots\quad\vdots\\
&&\displaystyle\quad a(m,1)h_{1}+a(m,2)h_{2}+\cdots+a(m,n)h_{n}\geq b_{m}\end{aligned}
  </annotation>
 </semantics>
</math>

 Each of the new vertices can be labelled by 1, 2, or 3 in such a way that no additional completely labelled simplex is created. This construction makes it very easy to find a triangle whose three vertices carry two of the three desired labels. Scarf’s algorithm begins with the triangle whose two vertices are the vertices of the larger simplex and bear labels 1 and 2, as shown in Figure 1. Then the algorithm generates a sequence of adjacent triangles, each of which has vertices labelled 1 and 2. The sequence is uniquely determined by the initial triangle. When the algorithm enters a new triangle, it exits through an edge whose vertices bear labels 1 and 2, which is different from the edge used to enter the triangle. If the triangle is not completely labelled, there will be a unique other edge whose vertices carry labels 1 and 2, and the algorithm leaves this edge to move into a new triangle. Remarkably, this algorithm will never return to any triangle that it has previously visited. Since the number of the triangles is finite, the algorithm must terminate with a completely labelled triangle.</p>

<p>The argument for the convergence can be vividly described with a tale (Scarf (1973, p. 48)): We can think of the larger simplex as a house, and of its triangles as rooms. A room has a door if the two vertices of one of its edges bear labels 1 and 2. It is clear that a completely labelled triangle is a room with only one door, all other rooms have either two doors or no door at all. By the construction, the house has precisely one door leading to the outside. Scarf’s algorithm begins with the known outside door and proceeds from room to room, never departing from a room by the door used in entering it. The algorithm can never return to a room previously entered nor leave the house, and therefore must find a room with only one door – a completely labelled simplex! This idea has been explored to create the so-called Sperner Game (Kyle Burke <a class="uri" href="http://www4.wittenberg.edu/academics/mathcomp/kburke">http://www4.wittenberg.edu/academics/mathcomp/kburke</a> and Shang-Hua Teng <a href="http://www-rcf.usc.edu/%7Eshanghua/">http://www-rcf.usc.edu/%7Eshanghua/</a>).</p>
<figure><b>(Figure)</b>
<figcaption>Figure 1: The Illustration of Scarf's Algorithm</figcaption>
</figure>

<p>Scarf’s algorithm has initiated a major research field in economics known as Applied General Equilibrium Analysis (see Shoven and Whalley (1992)) and a corresponding area in operations research termed Simplicial Fixed Point Methods or Algorithms (see Todd (1976) and Yang (1999)).</p>
<h3 id="the-housing-market">8. The Housing Market</h3>

<p>The assumption of perfect divisibility is essential in neoclassical economic analysis. However, this assumption often contradicts our casual observation of economic reality. In fact, many traded commodities are inherently indivisible, such as houses and cars. In a pioneering article (Shapley and Scarf (1974)), Scarf and Shapley studied a market with a finite number of traders, each with a single indivisible good (e.g., a house) that they wish to exchange. Each trader has preferences over houses but has no use for more than one item. There is no money or other medium of exchange so the only effect of the market activity is to permute the indivisible goods among the traders in accordance with their purely ordinal preferences. With the aid of Scarf’s core existence theorem they proved that this market always possesses a core allocation—a redistribution of items among all traders that cannot be improved upon by any individual, or any group of individuals. To find a core allocation, they also introduced a mechanism – called the top trading cycle method which had been discovered by David Gale.</p>

<p>The mechanism works as follows: Each trader i points to the trader j whose house trader i likes best. Clearly, there is at least one cycle of traders such that each trader most prefers the house owned by the subsequent trader in the cycle. The mechanism assigns every trader in the cycle the house he likes best, and removes all of the members of the cycle from the market. The remaining traders repeat the same process until every trader is accounted for. Remarkably it is now known that when faced with this mechanism, it is in the best interest of every trader and every group of traders to act sincerely – there are no gains to be made by misrepresenting an individual’s preferences.</p>
<h3 id="production-with-indivisibilities-and-integer-programming">9. Production with Indivisibilities and Integer Programming</h3>

<p>The assumption of convex production sets plays a pivotal role in neoclassical economic theory. If the production possibility set is convex then any efficient production plan will be supported by a set of competitive prices. The simplex method proposed by George Dantzig is an effective device for discovering these prices from the underlying linear programming problem. Unfortunately, such prices will no longer exist when the production set displays increasing returns to scale, indivisibilities, or other forms of nonconvexity. The most important example of a production set with indivisibilities is an activity analysis model in which all activity levels are constrained to be integers rather than arbitrary real numbers. Production sets with indivisibilities represents the most extreme form of nonconvexities in production and correspond to integer rather than ordinary linear programming problem. In this case, there is no simple test, like the pricing test arising from convex production sets, to verify whether a production plan is optimal or not.</p>

<p>To study this problem, Scarf (1981, 1986) developed an entirely different analytical apparatus-called a neighbourhood system, to replace the pricing test. Consider a general integer programming problem of the form:</p>

<p>

<math display="inline" id="Herbert_Scarf:101">
 <semantics>
  <mrow>
   <msub>
    <mi>h</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>h</mi>
    <mn>2</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">⋯</mi>
   <mo>,</mo>
   <msub>
    <mi>h</mi>
    <mi>n</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>h</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>h</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>normal-⋯</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>h</ci>
     <ci>n</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h_{1},h_{2},\cdots,h_{n}
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Herbert_Scarf:102">
 <semantics>
  <mrow>
   <msub>
    <mi>b</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>b</mi>
    <mn>2</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">⋯</mi>
   <mo>,</mo>
   <msub>
    <mi>b</mi>
    <mi>m</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>b</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>b</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>normal-⋯</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>b</ci>
     <ci>m</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b_{1},b_{2},\cdots,b_{m}
  </annotation>
 </semantics>
</math>

 are integer-valued variables, and 

<math display="inline" id="Herbert_Scarf:103">
 <semantics>
  <mrow>
   <mi>h</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>h</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>h</mi>
     <mn>2</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">⋯</mi>
    <mo>,</mo>
    <msub>
     <mi>h</mi>
     <mi>n</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>h</ci>
    <vector>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>h</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>h</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-⋯</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>h</ci>
      <ci>n</ci>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h=(h_{1},h_{2},\cdots,h_{n})
  </annotation>
 </semantics>
</math>

 are integer constants. For each integral vector 

<math display="inline" id="Herbert_Scarf:104">
 <semantics>
  <mi>h</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>h</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h
  </annotation>
 </semantics>
</math>

, the neighbourhood of the vector 

<math display="inline" id="Herbert_Scarf:105">
 <semantics>
  <mrow>
   <mi>N</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>h</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>N</ci>
    <ci>h</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N(h)
  </annotation>
 </semantics>
</math>

 is a finite set 

<math display="inline" id="Herbert_Scarf:106">
 <semantics>
  <mrow>
   <mrow>
    <mi>N</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>h</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">{</mo>
     <mi>h</mi>
     <mo stretchy="false">}</mo>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>N</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>0</mn>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>N</ci>
     <ci>h</ci>
    </apply>
    <apply>
     <plus></plus>
     <set>
      <ci>h</ci>
     </set>
     <apply>
      <times></times>
      <ci>N</ci>
      <cn type="integer">0</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N(h)=\{h\}+N(0)
  </annotation>
 </semantics>
</math>

 of integral vectors satisfying the two conditions: (i) 

<math display="inline" id="Herbert_Scarf:107">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>∈</mo>
   <mrow>
    <mi>N</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>h</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>k</ci>
    <apply>
     <times></times>
     <ci>N</ci>
     <ci>h</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k\in N(h)
  </annotation>
 </semantics>
</math>

, and (ii) 

<math display="inline" id="Herbert_Scarf:108">
 <semantics>
  <mrow>
   <mrow>
    <mi>h</mi>
    <mo>∈</mo>
    <mrow>
     <mi>N</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>k</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>h</ci>
    <apply>
     <times></times>
     <ci>N</ci>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h\in N(k).
  </annotation>
 </semantics>
</math>

 implies 

<math display="inline" id="Herbert_Scarf:109">
 <semantics>
  <mrow>
   <mi>N</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>h</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>N</ci>
    <ci>h</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N(h)
  </annotation>
 </semantics>
</math>

</p>

<p>The first condition indicates that for any two different integral points, their neighbourhoods are translates of each other, and the second condition shows the symmetric property of the neighbourhood system. Each element in 

<math display="inline" id="Herbert_Scarf:110">
 <semantics>
  <mrow>
   <mi>h</mi>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <ci>h</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h.
  </annotation>
 </semantics>
</math>

 is called a neighbour of 

<math display="inline" id="Herbert_Scarf:111">
 <semantics>
  <mi>h</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>h</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h
  </annotation>
 </semantics>
</math>

 If we are given a feasible solution 

<math display="inline" id="Herbert_Scarf:112">
 <semantics>
  <mrow>
   <mi>h</mi>
   <mo>+</mo>
   <mi>k</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>h</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h+k
  </annotation>
 </semantics>
</math>

 to the above integer program we can test its set of neighbours 

<math display="inline" id="Herbert_Scarf:113">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>∈</mo>
   <mrow>
    <mi>N</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>h</mi>
      <mo>′</mo>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>k</ci>
    <apply>
     <times></times>
     <ci>N</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>h</ci>
      <ci>normal-′</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k\in N(h^{\prime})
  </annotation>
 </semantics>
</math>

, for 

<math display="inline" id="Herbert_Scarf:114">
 <semantics>
  <mi>h</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>h</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h
  </annotation>
 </semantics>
</math>

, to see if one of them is feasible and yields a higher value of the objective function. If none of them is feasible, then 

<math display="inline" id="Herbert_Scarf:115">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>a</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>i</mi>
      <mo>,</mo>
      <mi>j</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>A</ci>
    <apply>
     <times></times>
     <ci>a</ci>
     <interval closure="open">
      <ci>i</ci>
      <ci>j</ci>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A=(a(i,j))
  </annotation>
 </semantics>
</math>

 is a local maximum with respect to this neighbourhood system.</p>

<p>Scarf has shown that under mild conditions on the technology matrix <span class="LaTeX">$A=(a(i,j))$</span> there is a unique, smallest neighbourhood system, with the property that a local maximum is always global. This unique minimal neighbourhood system depends only on the technology matrix and not on the factor endowment. Thus to verify whether a production plan is optimal, one just needs to check if all its neighbours are either infeasible or yield an inferior value of the objective function. Therefore the minimal neighbourhood system provides a unique quantity test for optimality in the case of a production set with indivisibilities analogous to the pricing test in the case of a convex production set. Scarf (also together with his coauthors) has identified many important classes of production technology matrices for which the minimal neighbourhood system can be easily computed.</p>

<p>Scarf’s neighbourhood system has found applications in a variety of different areas: Algebraic Geometry, Cooperative Game Theory, Reliability Theory Multi-Commodity Network Flows, Graph Theory and the Stable Paths Problem. However, it is difficult to find the minimal neighbourhood system associated with an arbitrarily given technology matrix and one is forced to use computational procedures borrowed from Algebraic Geometry.</p>
<h2 id="personal-life">Personal life</h2>

<p>Scarf met Margaret Klein a month or so before his graduation from Temple University in 1951, and married her in 1953. They have three daughters and eight grandchildren. <a href="Maggie_Scarf" title="wikilink">Maggie Scarf</a> is a well-known writer of best-selling books on psychological issues.</p>
<h2 id="mentors">Mentors</h2>

<p>Herbert Scarf was intellectually influenced by Kenneth Arrow, Saloman Bochner (Scarf’s PhD adviser), George Dantzig, Gerard Debreu, Tjalling Koopmans, and Maxwell Scarf (Herbert Scarf’s uncle). Scarf has deep respect for them and regards them as his close friends and mentors.</p>
<h2 id="phd-students">PhD Students</h2>

<p>Scarf is a superb teacher and adviser, a concerned and dedicated colleague, and has been an inspiration and role model to his students at Yale and Stanford and to his colleagues all over the world. His clarity of thought and vision and thoroughness of knowledge are highly appreciated by his students and the readers of his work. He has supervised about 30 PhD students. They are Frank Proschan (1959, Stanford), Donald Roberts (1960, Stanford), Donald Iglehart (1961, Stanford), Murray Geisler (1962, Stanford), Menahem Yaari (1962, Stanford), Louis Billera (1968, City University of New York), and the rest all graduated from Yale, Rolf Mantel (1965), Ana Martirena-Mantel (1965), Duncan Foley (1966), Eugene Poirier (1966), Terje Hansen (1968), Michael Keren (1968), Frank Levy (1969), Yukio Noguchi (1972), Michael Todd (1972), John Shoven (1973), John Walley (1973), Andrew Feltenstein (1976), Marcos Fonseca (1978), Timothy Kehoe (1979), Ludo van der Heyden (1979), Jaime Serra Puche (1979), Andrew Caplin (1983), Phillip White (1983), Kazuya Kamiya (1986), Joshua Reichert (1986), Michael Mandler (1989), Jingang Zhao (1992), and Xin Wang (1997).</p>
<h2 id="major-publications">Major Publications</h2>

<p>1. On differential games with survival payoffs (with L.Shapley), 1958, in Volume III, Contribution to the Theory of Games, eds. D. Dresher, A.W.Tucker and P.Wolfe, Princeton University Press.</p>

<p>2. </p>

<p>3. Optimal policies for a multi-echelon inventory problem (with A.J.Clark), 1960, in Management Science, Vol. 6, No.4, pp. 475–490.</p>

<p>4. Some examples of global instability of the competitive equilibrium, 1960, in International Economic Review, Vol.1, No. 3, pp. 157–172.</p>

<p>5. An analysis of markets with a large number of participants, 1962, in Recent Advances in Game Theory, ed. M. Maschler, The Ivy Curtis Press.</p>

<p>6. A limit theorem on the core of an economy (with G.Debreu), 1963, in International Economic Review, Vol.4, No.3, pp. 235–246.</p>

<p>7. The core of an N-person game, 1967, in Econometrica, Vol. 35, No. 1, pp. 50–69.</p>

<p>8. The approximation of fixed points of a continuous mapping, 1967, in SIAM Journal of Applied Mathematics, Vol. 15, No.5, pp. 1328–1343.</p>

<p>9. On the existence of a cooperative solution for a general class of N-person games, 1971, in Journal of Economic Theory, Vol. 3, No. 2, pp. 169–181.</p>

<p>10. The Computation of Economic Equilibria, Yale University Press, New Haven, 1973.</p>

<p>11. On cores and indivisibilities (with L.Shapley), 1974, in Journal of Mathematical Economics, Vol.1, No. 1, pp. 23–37.</p>

<p>12. The solution of systems of piecewise linear equations (with B.C. Eaves), 1976, in Mathematics of Operations Research, Vol.1, No.1, pp. 1–27.</p>

<p>13. Production sets with indivisibilities, part I: generalities, 1981, in Econometrica, Vol. 49, No. 1, pp. 1–32.</p>

<p>14. Production sets with indivisibilities, part II: the case of two activities, 1981, in Econometrica, Vol. 49, No. 2, pp. 395–423.</p>

<p>15. Integral polyhedral in three spaces, 1985, in Mathematics of Operations Research, Vol.10, No.3, pp. 403–438.</p>

<p>16. Neighbourhood systems for production sets with indivisibilities, 1986, in Econometrica, Vol.54, No.3, 507–532.</p>

<p>17. The generalized basis reduction algorithm (with L.Lovász), 1992, in Mathematics of Operations Research, Vol.17, No.3, pp. 751–764</p>

<p>18. The Frobenius problem and maximal lattice free bodies (with D.F.Shallcross), 1993, in Mathematics of Operations Research, Vol.18, No.3, pp. 511–515.</p>

<p>19. The complex of maximal lattice free simplices (with I.Bárány and R.Howe), 1994, in Mathematical Programming, Vol. 66, No. 3, pp. 273–281.</p>

<p>20. The allocation of resources in the presence of indivisibilities,1994, in Journal of Economic Perspectives, Vol. 8, No. 4, pp. 111–128.</p>

<p>21. Matrices with identical sets of neighbours (with I.Bárány), 1998, in Mathematics of Operations Research, Vol.23, No.4, pp. 863–873.</p>

<p>22. The topological structure of maximal lattice free convex bodies: the general case (with I.Bárány and D.F.Shallcross), 1998, in Mathematical Programming, Vol. 80, No. 1, pp. 1–15.</p>

<p>23. Uniqueness of equilibrium in a multi-country Ricardo model (with C.A. Wilson), 2005, in Frontiers in Applied General Equilibrium Modeling: In Honor of Herbert Scarf, eds. T.J. Kehoe, T.N. Srinivasan and J. Whalley, Cambridge University Press.</p>
<h2 id="references">References</h2>

<p>1. Arrow, K. J., H.Block, and L.Hurwicz (1959): ``On the stability of the competitive equilibrium, II," Econometrica, 27, 82–109.</p>

<p>2. Arrow, K.J., and G.Debreu (1954): ``Existence of an equilibrium for a competitive economy,” Econometrica, 22, 265–290.</p>

<p>3. Arrow, K.J., T.Harris, and J. Marschak (1951): ``Optimal inventory policy,” Econometrica, 19, 250–272.</p>

<p>4. Arrow, K.J., and L.Hurwicz (1958): ``On the stability of the competitive equilibrium, I," Econometrica, 26, 522–552.</p>

<p>5. Aumann, R.J. (1964): ``Markets with a continuum of traders,” Econometrica, 32, 39–50.</p>

<p>6. Brouwer, L.E.J. (1912):[<a class="uri" href="http://gdz.sub.uni-goettingen.de/index.php?id=11&amp;PPN">http://gdz.sub.uni-goettingen.de/index.php?id=11&amp;PPN;</a>;=PPN235181684_0071&amp;DMDID;=DMDLOG_0012&amp;L;=1 ``Über Abbildungen von Mannigfaltigkeiten,”] <a href="Mathematische_Annalen" title="wikilink">Mathematische Annalen</a>, 71, 97-115.</p>

<p>7. Debreu, G. (1959): Theory of Value, Yale University Press, New Haven.</p>

<p>8. Edgeworth, F.Y. (1881): Mathematical Psychics, Kegan Paul, London.</p>

<p>9. Koopmans, T.C., and M. Beckmann (1957): ``Assignment problems and the location of economic activities,” Econometrica, 25, 53–76.</p>

<p>10. Lemke, C.E., and J.T. Howson (1964): ``Equilibrium points of Bi-matrix games,” SIAM Journal of Applied Mathematics, 12, 413–423.</p>

<p>11. Lerner, A. (1944): The Economics of Control, Macmillan, New York.</p>

<p>12. McKenzie, L.W. (1959): ``On the existence of general equilibrium for a competitive market,” Econometrica, 27, 54–71.</p>

<p>13. Samuelson, P. (1941): ``The stability of equilibrium: comparative statics and dynamics," Econometrica, 19, 97–120.</p>

<p>14. Shoven, J.B., and J.Whalley (1992): Applying General Equilibrium, Cambridge University Press, New York.</p>

<p>15. Shubik, M., (1959): ``Edgeworth market games.” In Tucker, A.W., and R.D.Luce, eds., Contributions to the Theory of Games, IV. Princeton University Press, 267–278.</p>

<p>16. Smith, A., (1776): The Wealth of Nations, W.P.Strahan and T. Cadell, London.</p>

<p>17. Sperner, E. (1928): ``Neur Beweis für die Invarianz der Dimensionszahl und des Gebietes,” Abh.a.d. Math.Sem. d. Univ. Hamburg, 6, 265–272.</p>

<p>18. Todd, M.J., (1976): The Computation of Fixed Points and Applications, Springer-Verlag, Berlin.</p>

<p>19. Von Neumann, J., and O.Morgenstern (1947): Theory of Games and Economic Behavior, Princeton University Press, Princeton.</p>

<p>20. Wald, A., (1936): ``Über einige Gleichungssysteme der mathematischen Ökonomie,” Zeitschrift für Nationalökonomie, 7, 637–670.</p>

<p>21. Walras, L., (1874): Eléments ďEconomie Politique Pure. Corbaz, Lausanne.</p>

<p>22. Yang, Z., (1999): Computing Equilibria and Fixed Points, Kluwer Academic Publishers, Boston.</p>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://cowles.econ.yale.edu/~hes/">Personal web site</a></li>
<li><a href="http://homepage.newschool.edu/~het/profiles/scarf.htm">The works of Herbert Scarf</a></li>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:1930_births" title="wikilink">Category:1930 births</a> <a href="Category:Members_of_the_United_States_National_Academy_of_Sciences" title="wikilink">Category:Members of the United States National Academy of Sciences</a> <a href="Category:Living_people" title="wikilink">Category:Living people</a> <a href="Category:General_equilibrium_theorists" title="wikilink">Category:General equilibrium theorists</a> <a href="Category:American_economists" title="wikilink">Category:American economists</a> <a href="Category:American_mathematicians" title="wikilink">Category:American mathematicians</a> <a href="Category:Yale_University_faculty" title="wikilink">Category:Yale University faculty</a> <a href="Category:Fellows_of_the_Econometric_Society" title="wikilink">Category:Fellows of the Econometric Society</a> <a href="Category:Presidents_of_the_Econometric_Society" title="wikilink">Category:Presidents of the Econometric Society</a> <a href="Category:Yale_Sterling_Professors" title="wikilink">Category:Yale Sterling Professors</a></p>
</body>
</html>
