<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="716">Uncertainty quantification</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Uncertainty quantification</h1>
<hr/>

<p><strong>Uncertainty quantification (UQ)</strong> is the science of quantitative characterization and reduction of <a href="Uncertainty" title="wikilink">uncertainties</a> in both computational and real world applications. It tries to determine how likely certain outcomes are if some aspects of the system are not exactly known. An example would be to predict the acceleration of a human body in a head-on crash with another car: even if we exactly knew the speed, small differences in the manufacturing of individual cars, how tightly every bolt has been tightened, etc., will lead to different results that can only be predicted in a statistical sense.</p>

<p>Many problems in the natural sciences and engineering are also rife with sources of uncertainty. <a href="Computer_experiment" title="wikilink">Computer experiments</a> on <a href="computer_model" title="wikilink">computer simulations</a> are the most common approach to study problems in uncertainty quantification.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a><a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a><a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>
<h2 id="sources-of-uncertainty">Sources of uncertainty</h2>

<p>Uncertainty can enter <a href="mathematical_model" title="wikilink">mathematical models</a> and experimental measurements in various contexts. One way to categorize the sources of uncertainty is to consider:<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>
<ul>
<li><strong>Parameter uncertainty</strong>, which comes from the model parameters that are inputs to the computer model (mathematical model) but whose exact values are unknown to experimentalists and cannot be controlled in physical experiments, or whose values cannot be exactly inferred by <a href="statistical_methods" title="wikilink">statistical methods</a>. Examples are the local <a href="free_fall" title="wikilink">free-fall</a> acceleration in a falling object experiment, various material properties in a finite element analysis for engineering, and <a href="multiplier_uncertainty" title="wikilink">multiplier uncertainty</a> in the context of <a href="macroeconomic_policy" title="wikilink">macroeconomic policy</a> optimization.</li>
<li><strong>Parametric variability</strong>, which comes from the variability of input variables of the model. For example, the dimensions of a work piece in a process of manufacture may not be exactly as designed and instructed, which would cause variability in its performance.</li>
<li><strong>Structural uncertainty</strong>, aka model inadequacy, model bias, or model discrepancy, which comes from the lack of knowledge of the underlying true physics. It depends on how accurately a mathematical model describes the true system for a real-life situation, considering the fact that models are almost always only approximations to reality. One example is when modeling the process of a falling object using the free-fall model; the model itself is inaccurate since there always exists air friction. In this case, even if there is no unknown parameter in the model, a discrepancy is still expected between the model and true physics.</li>
<li><strong>Algorithmic uncertainty</strong>, aka numerical uncertainty, which comes from numerical errors and numerical approximations per implementation of the computer model. Most models are too complicated to solve exactly. For example the <a href="finite_element_method" title="wikilink">finite element method</a> or <a href="finite_difference" title="wikilink">finite difference method</a> may be used to approximate the solution of a <a href="partial_differential_equation" title="wikilink">partial differential equation</a>, which, however, introduces numerical errors. Other examples are numerical integration and infinite sum truncation that are necessary approximations in numerical implementation.</li>
<li><strong>Experimental uncertainty</strong>, aka observation error, which comes from the variability of experimental measurements. The experimental uncertainty is inevitable and can be noticed by repeating a measurement for many times using exactly the same settings for all inputs/variables.</li>
<li><strong>Interpolation uncertainty</strong>, which comes a lack of available data collected from computer model simulations and/or experimental measurements. For other input settings that don't have simulation data or experimental measurements, one must interpolate or extrapolate in order to predict the corresponding responses.</li>
</ul>
<h3 id="aleatoric-and-epistemic-uncertainty">Aleatoric and epistemic uncertainty</h3>

<p>It is commonly assumed that uncertainty can be classified into two categories,<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a><a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> although the existence of this categorization is open to debate. These categories are prominenly seen in medical applications.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>
<ul>
<li><strong>Aleatoric uncertainty</strong>, aka statistical uncertainty, which is representative of unknowns that differ each time we run the same experiment. For example, a single arrow shot with a mechanical bow that exactly duplicates each launch (the same acceleration, altitude, direction and final velocity) will not all impact the same point on the target due to random and complicated vibrations of the arrow shaft, the knowledge of which cannot be determined sufficiently to eliminate the resulting scatter of impact points. The argument here is obviously in the definition of "cannot". Just because we cannot measure sufficiently with our currently available measurement devices does not preclude necessarily the existence of such information, which would move this uncertainty into the below category. Indeed it is a philosophical question as to whether ‘aleatoric uncertainty’ is even a meaningful concept.</li>
</ul>
<ul>
<li><strong>Epistemic uncertainty</strong>, aka systematic uncertainty, which is due to things we could in principle know but don't in practice. This may be because we have not measured a quantity sufficiently accurately, or because our model neglects certain effects, or because particular data are deliberately hidden. An example of a source of this uncertainty would be the <a href="Drag_(physics)" title="wikilink">drag</a> of a feather in an experiment designed to measure the acceleration of gravity near the earth's surface. The commonly used gravitational acceleration of 9.8 m/s^2 ignores the effects of air resistance, but the air resistance for the feather could be measured and incorporated into the experiment to reduce the resulting uncertainty in the calculation of the gravitational acceleration.</li>
</ul>

<p>In real life applications, both kinds of uncertainties are present. Uncertainty quantification intends to work toward reducing epistemic uncertainties to aleatoric uncertainties. The quantification for the aleatoric uncertainties can be relatively straightforward to perform, depending on the application. Techniques such as the <a href="Monte_Carlo_method" title="wikilink">Monte Carlo method</a> are frequently used. A probability distribution can be represented by its <a href="Moment_(mathematics)" title="wikilink">moments</a> (in the <a href="Normal_distribution" title="wikilink">Gaussian</a> case, the <a class="uri" href="mean" title="wikilink">mean</a> and <a class="uri" href="covariance" title="wikilink">covariance</a> suffice, although it should be noted that, in general, even knowledge of all moments to arbitrarily high order still does not specify the distribution function uniquely), or more recently, by techniques such as <a href="Karhunen–Loève_theorem" title="wikilink">Karhunen–Loève</a> and <a href="polynomial_chaos" title="wikilink">polynomial chaos</a> expansions. To evaluate epistemic uncertainties, the efforts are made to gain better knowledge of the system, process or mechanism. Methods such as <a href="fuzzy_logic" title="wikilink">fuzzy logic</a> or evidence theory (<a href="Dempster–Shafer_theory" title="wikilink">Dempster–Shafer theory</a> – a generalization of the Bayesian theory of subjective probability) are used.</p>
<h2 id="two-types-of-uncertainty-quantification-problems">Two types of uncertainty quantification problems</h2>

<p>There are two major types of problems in uncertainty quantification: one is the <strong>forward</strong> propagation of uncertainty (where the various sources of uncertainty are propagated through the model to predict the overall uncertainty in the system response) and the other is the <strong>inverse</strong> assessment of model uncertainty and parameter uncertainty (where the model parameters are calibrated simultaneously using test data). There has been a proliferation of research on the former problem and a majority of uncertainty analysis techniques were developed for it. On the other hand, the latter problem is drawing increasing attention in the engineering design community, since uncertainty quantification of a model and the subsequent predictions of the true system response(s) are of great interest in designing robust systems.</p>
<h3 id="forward-uncertainty-propagation">Forward uncertainty propagation</h3>

<p>Uncertainty propagation is the quantification of uncertainties in system output(s) propagated from uncertain inputs. It focuses on the influence on the outputs from the <em>parametric variability</em> listed in the sources of uncertainty. The targets of uncertainty propagation analysis can be:</p>
<ul>
<li>To evaluate low-order moments of the outputs, i.e. <a class="uri" href="mean" title="wikilink">mean</a> and <a class="uri" href="variance" title="wikilink">variance</a>.</li>
<li>To evaluate the reliability of the outputs. This is especially useful in <a href="reliability_engineering" title="wikilink">reliability engineering</a> where outputs of a system are usually closely related to the performance of the system.</li>
<li>To assess the complete probability distribution of the outputs. This is useful in the scenario of <a class="uri" href="utility" title="wikilink">utility</a> optimization where the complete distribution is used to calculate the utility.</li>
</ul>
<h3 id="inverse-uncertainty-quantification">Inverse uncertainty quantification</h3>

<p>Given some experimental measurements of a system and some computer simulation results from its mathematical model, inverse uncertainty quantification estimates the discrepancy between the experiment and the mathematical model (which is called <strong>bias correction</strong>), and estimates the values of unknown parameters in the model if there are any (which is called <strong>parameter calibration</strong> or simply <strong>calibration</strong>). Generally this is a much more difficult problem than forward uncertainty propagation; however it is of great importance since it is typically implemented in a model updating process. There are several scenarios in inverse uncertainty quantification: </p>
<h4 id="bias-correction-only">Bias correction only</h4>

<p>Bias correction quantifies the <em>model inadequacy</em>, i.e. the discrepancy between the experiment and the mathematical model. The general model updating formula for bias correction is:</p>

<p>

<math display="block" id="Uncertainty_quantification:0">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>y</mi>
     <mi>e</mi>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>𝐱</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msup>
      <mi>y</mi>
      <mi>m</mi>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>𝐱</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>δ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>𝐱</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mi>ε</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>y</ci>
      <ci>e</ci>
     </apply>
     <ci>𝐱</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>y</ci>
       <ci>m</ci>
      </apply>
      <ci>𝐱</ci>
     </apply>
     <apply>
      <times></times>
      <ci>δ</ci>
      <ci>𝐱</ci>
     </apply>
     <ci>ε</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y^{e}(\mathbf{x})=y^{m}(\mathbf{x})+\delta(\mathbf{x})+\varepsilon
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Uncertainty_quantification:1">
 <semantics>
  <mrow>
   <msup>
    <mi>y</mi>
    <mi>e</mi>
   </msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>𝐱</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>y</ci>
     <ci>e</ci>
    </apply>
    <ci>𝐱</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y^{e}(\mathbf{x})
  </annotation>
 </semantics>
</math>

 denotes the experimental measurements as a function of several input variables 

<math display="inline" id="Uncertainty_quantification:2">
 <semantics>
  <mi>𝐱</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐱</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{x}
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Uncertainty_quantification:3">
 <semantics>
  <mrow>
   <msup>
    <mi>y</mi>
    <mi>m</mi>
   </msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>𝐱</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>y</ci>
     <ci>m</ci>
    </apply>
    <ci>𝐱</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y^{m}(\mathbf{x})
  </annotation>
 </semantics>
</math>

 denotes the computer model (mathematical model) response, 

<math display="inline" id="Uncertainty_quantification:4">
 <semantics>
  <mrow>
   <mi>δ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>𝐱</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>δ</ci>
    <ci>𝐱</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta(\mathbf{x})
  </annotation>
 </semantics>
</math>

 denotes the additive discrepancy function (aka bias function), and 

<math display="inline" id="Uncertainty_quantification:5">
 <semantics>
  <mi>ε</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ε</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varepsilon
  </annotation>
 </semantics>
</math>

 denotes the experimental uncertainty. The objective is to estimate the discrepancy function 

<math display="inline" id="Uncertainty_quantification:6">
 <semantics>
  <mrow>
   <mi>δ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>𝐱</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>δ</ci>
    <ci>𝐱</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta(\mathbf{x})
  </annotation>
 </semantics>
</math>

, and as a by-product, the resulting updated model is 

<math display="inline" id="Uncertainty_quantification:7">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>y</mi>
     <mi>m</mi>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>𝐱</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>+</mo>
   <mrow>
    <mi>δ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>𝐱</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>y</ci>
      <ci>m</ci>
     </apply>
     <ci>𝐱</ci>
    </apply>
    <apply>
     <times></times>
     <ci>δ</ci>
     <ci>𝐱</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y^{m}(\mathbf{x})+\delta(\mathbf{x})
  </annotation>
 </semantics>
</math>

. A prediction confidence interval is provided with the updated model as the quantification of the uncertainty.</p>
<h4 id="parameter-calibration-only">Parameter calibration only</h4>

<p>Parameter calibration estimates the values of one or more unknown parameters in a mathematical model. The general model updating formulation for calibration is:</p>

<p>

<math display="block" id="Uncertainty_quantification:8">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>y</mi>
     <mi>e</mi>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>𝐱</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msup>
      <mi>y</mi>
      <mi>m</mi>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>𝐱</mi>
      <mo>,</mo>
      <msup>
       <mi>𝜽</mi>
       <mo>*</mo>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mi>ε</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>y</ci>
      <ci>e</ci>
     </apply>
     <ci>𝐱</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>y</ci>
       <ci>m</ci>
      </apply>
      <interval closure="open">
       <ci>𝐱</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>𝜽</ci>
        <times></times>
       </apply>
      </interval>
     </apply>
     <ci>ε</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y^{e}(\mathbf{x})=y^{m}(\mathbf{x},\boldsymbol{\theta}^{*})+\varepsilon
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Uncertainty_quantification:9">
 <semantics>
  <mrow>
   <msup>
    <mi>y</mi>
    <mi>m</mi>
   </msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>𝐱</mi>
    <mo>,</mo>
    <mi>𝜽</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>y</ci>
     <ci>m</ci>
    </apply>
    <interval closure="open">
     <ci>𝐱</ci>
     <ci>𝜽</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y^{m}(\mathbf{x},\boldsymbol{\theta})
  </annotation>
 </semantics>
</math>

 denotes the computer model response that depends on several unknown model parameters 

<math display="inline" id="Uncertainty_quantification:10">
 <semantics>
  <mi>𝜽</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝜽</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \boldsymbol{\theta}
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="Uncertainty_quantification:11">
 <semantics>
  <msup>
   <mi>𝜽</mi>
   <mo>*</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>𝜽</ci>
    <times></times>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \boldsymbol{\theta}^{*}
  </annotation>
 </semantics>
</math>

 denotes the true values of the unknown parameters in the course of experiments. The objective is to either estimate 

<math display="inline" id="Uncertainty_quantification:12">
 <semantics>
  <msup>
   <mi>𝜽</mi>
   <mo>*</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>𝜽</ci>
    <times></times>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \boldsymbol{\theta}^{*}
  </annotation>
 </semantics>
</math>

, or to come up with a probability distribution of 

<math display="inline" id="Uncertainty_quantification:13">
 <semantics>
  <msup>
   <mi>𝜽</mi>
   <mo>*</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>𝜽</ci>
    <times></times>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \boldsymbol{\theta}^{*}
  </annotation>
 </semantics>
</math>

 that encompasses the best knowledge of the true parameter values.</p>
<h4 id="bias-correction-and-parameter-calibration">Bias correction and parameter calibration</h4>

<p>It considers an inaccurate model with one or more unknown parameters, and its model updating formulation combines the two together:</p>

<p>

<math display="block" id="Uncertainty_quantification:14">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>y</mi>
     <mi>e</mi>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>𝐱</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msup>
      <mi>y</mi>
      <mi>m</mi>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>𝐱</mi>
      <mo>,</mo>
      <msup>
       <mi>𝜽</mi>
       <mo>*</mo>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>δ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>𝐱</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mi>ε</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>y</ci>
      <ci>e</ci>
     </apply>
     <ci>𝐱</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>y</ci>
       <ci>m</ci>
      </apply>
      <interval closure="open">
       <ci>𝐱</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>𝜽</ci>
        <times></times>
       </apply>
      </interval>
     </apply>
     <apply>
      <times></times>
      <ci>δ</ci>
      <ci>𝐱</ci>
     </apply>
     <ci>ε</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y^{e}(\mathbf{x})=y^{m}(\mathbf{x},\boldsymbol{\theta}^{*})+\delta(\mathbf{x})+\varepsilon
  </annotation>
 </semantics>
</math>

 It is the most comprehensive model updating formulation that includes all possible sources of uncertainty, and it requires the most effort to solve.</p>
<h2 id="selective-methodologies-for-uncertainty-quantification">Selective methodologies for uncertainty quantification</h2>

<p>Much research has been done to solve uncertainty quantification problems, though a majority of them deal with uncertainty propagation. During the past one to two decades, a number of approaches for inverse uncertainty quantification problems have also been developed and have proved to be useful for most small- to medium-scale problems.</p>
<h3 id="methodologies-for-forward-uncertainty-propagation">Methodologies for forward uncertainty propagation</h3>

<p>Existing uncertainty propagation approaches include probabilistic approaches and non-probabilistic approaches. There are basically five categories of probabilistic approaches for uncertainty propagation:<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></p>
<ul>
<li>Simulation-based methods: <a href="Monte_Carlo_method" title="wikilink">Monte Carlo simulations</a>, <a href="importance_sampling" title="wikilink">importance sampling</a>, adaptive sampling, etc.</li>
<li>Local expansion-based methods: Taylor series, <a href="Perturbation_theory" title="wikilink">perturbation method</a>, etc. These methods have advantages when dealing with relatively small input variability and outputs that don't express high nonlinearity. These linear or linearized methods are detailed in the article <a href="Uncertainty_propagation" title="wikilink">Uncertainty propagation</a>.</li>
<li>Functional expansion-based methods: Neumann expansion, orthogonal or Karhunen-Loeve expansions (KLE), with <a href="Polynomial_chaos" title="wikilink">polynomial chaos expansion (PCE)</a> and wavelet expansions as special cases.</li>
<li>Most probable point (MPP)-based methods: first-order reliability method (FORM) and second-order reliability method (SORM).</li>
<li>Numerical integration-based methods: Full factorial numerical integration (FFNI) and dimension reduction (DR).</li>
</ul>

<p>For non-probabilistic approaches, <a href="Interval_arithmetic" title="wikilink">interval analysis</a> <a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> , <a href="Fuzzy_logic" title="wikilink">Fuzzy theory</a>, possibility theory and evidence theory are among the most widely used.</p>

<p>The probabilistic approach is considered as the most rigorous approach to uncertainty analysis in engineering design due to its consistency with the theory of decision analysis. Its cornerstone is the calculation of probability density functions for sampling statistics.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> This can be performed rigorously for random variables that are obtainable as transformations of Gaussian variables, leading to exact confidence intervals.</p>
<h3 id="methodologies-for-inverse-uncertainty-quantification">Methodologies for inverse uncertainty quantification</h3>
<h4 id="frequentist">Frequentist</h4>

<p>In <a href="regression_analysis" title="wikilink">regression analysis</a> and <a href="least_squares" title="wikilink">least squares</a> problems, the <a href="standard_error" title="wikilink">standard error</a> of <a href="parameter_estimate" title="wikilink">parameter estimates</a> is readily available, which can be expanded into a <a href="confidence_interval" title="wikilink">confidence interval</a>.</p>
<h4 id="bayesian">Bayesian</h4>

<p>Several methodologies for inverse uncertainty quantification exist under the <a href="Bayesian_inference" title="wikilink">Bayesian framework</a>. The most complicated direction is to aim at solving problems with both bias correction and parameter calibration. The challenges of such problems include not only the influences from model inadequacy and parameter uncertainty, but also the lack of data from both computer simulations and experiments. A common situation is that the input settings are not the same over experiments and simulations.</p>
<h5 id="modular-bayesian-approach">Modular Bayesian approach</h5>

<p>An approach to inverse uncertainty quantification is the modular Bayesian approach.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a><a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> The modular Bayesian approach derives its name from its four-module procedure. Apart from the current available data, a <a href="prior_distribution" title="wikilink">prior distribution</a> of unknown parameters should be assigned.</p>
<dl>
<dt><strong>Module 1:</strong> Gaussian process modeling for the computer model</dt>
</dl>

<p>To address the issue from lack of simulation results, the computer model is replaced with a <a href="Gaussian_process" title="wikilink">Gaussian Process (GP)</a> model</p>

<p>

<math display="block" id="Uncertainty_quantification:15">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>y</mi>
     <mi>m</mi>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>𝐱</mi>
     <mo>,</mo>
     <mi>𝜽</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>∼</mo>
   <mrow>
    <mi class="ltx_font_mathcaligraphic">𝒢</mi>
    <mi class="ltx_font_mathcaligraphic">𝒫</mi>
    <mrow>
     <mo maxsize="120%" minsize="120%">(</mo>
     <mrow>
      <msup>
       <mi>𝐡</mi>
       <mi>m</mi>
      </msup>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mo>⋅</mo>
        <mo stretchy="false">)</mo>
       </mrow>
       <mi>T</mi>
      </msup>
      <msup>
       <mi>𝜷</mi>
       <mi>m</mi>
      </msup>
     </mrow>
     <mo>,</mo>
     <mrow>
      <msubsup>
       <mi>σ</mi>
       <mi>m</mi>
       <mn>2</mn>
      </msubsup>
      <msup>
       <mi>R</mi>
       <mi>m</mi>
      </msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mo>⋅</mo>
       <mo>,</mo>
       <mo>⋅</mo>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo maxsize="120%" minsize="120%">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">similar-to</csymbol>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>y</ci>
      <ci>m</ci>
     </apply>
     <interval closure="open">
      <ci>𝐱</ci>
      <ci>𝜽</ci>
     </interval>
    </apply>
    <apply>
     <times></times>
     <ci>𝒢</ci>
     <ci>𝒫</ci>
     <interval closure="open">
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>𝐡</ci>
        <ci>m</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>normal-⋅</ci>
        <ci>T</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>𝜷</ci>
        <ci>m</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>σ</ci>
         <ci>m</ci>
        </apply>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>R</ci>
        <ci>m</ci>
       </apply>
       <interval closure="open">
        <ci>normal-⋅</ci>
        <ci>normal-⋅</ci>
       </interval>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y^{m}(\mathbf{x},\boldsymbol{\theta})\sim\mathcal{GP}\big(\mathbf{h}^{m}(\cdot%
)^{T}\boldsymbol{\beta}^{m},\sigma_{m}^{2}R^{m}(\cdot,\cdot)\big)
  </annotation>
 </semantics>
</math>

 where</p>

<p>

<math display="block" id="Uncertainty_quantification:16">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msup>
      <mi>R</mi>
      <mi>m</mi>
     </msup>
     <mrow>
      <mo maxsize="120%" minsize="120%">(</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>𝐱</mi>
       <mo>,</mo>
       <mi>𝜽</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>,</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <msup>
        <mi>𝐱</mi>
        <mo>′</mo>
       </msup>
       <mo>,</mo>
       <msup>
        <mi>𝜽</mi>
        <mo>′</mo>
       </msup>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo maxsize="120%" minsize="120%">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mi>exp</mi>
      <mrow>
       <mo>{</mo>
       <mrow>
        <mo>-</mo>
        <mrow>
         <munderover>
          <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
          <mrow>
           <mi>k</mi>
           <mo>=</mo>
           <mn>1</mn>
          </mrow>
          <mi>d</mi>
         </munderover>
         <mrow>
          <msubsup>
           <mi>ω</mi>
           <mi>k</mi>
           <mi>m</mi>
          </msubsup>
          <msup>
           <mrow>
            <mo stretchy="false">(</mo>
            <mrow>
             <msub>
              <mi>x</mi>
              <mi>k</mi>
             </msub>
             <mo>-</mo>
             <msubsup>
              <mi>x</mi>
              <mi>k</mi>
              <mo>′</mo>
             </msubsup>
            </mrow>
            <mo stretchy="false">)</mo>
           </mrow>
           <mn>2</mn>
          </msup>
         </mrow>
        </mrow>
       </mrow>
       <mo>}</mo>
      </mrow>
     </mrow>
     <mrow>
      <mi>exp</mi>
      <mrow>
       <mo>{</mo>
       <mrow>
        <mo>-</mo>
        <mrow>
         <munderover>
          <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
          <mrow>
           <mi>k</mi>
           <mo>=</mo>
           <mn>1</mn>
          </mrow>
          <mi>r</mi>
         </munderover>
         <mrow>
          <msubsup>
           <mi>ω</mi>
           <mrow>
            <mi>d</mi>
            <mo>+</mo>
            <mi>k</mi>
           </mrow>
           <mi>m</mi>
          </msubsup>
          <msup>
           <mrow>
            <mo stretchy="false">(</mo>
            <mrow>
             <msub>
              <mi>θ</mi>
              <mi>k</mi>
             </msub>
             <mo>-</mo>
             <msubsup>
              <mi>θ</mi>
              <mi>k</mi>
              <mo>′</mo>
             </msubsup>
            </mrow>
            <mo stretchy="false">)</mo>
           </mrow>
           <mn>2</mn>
          </msup>
         </mrow>
        </mrow>
       </mrow>
       <mo>}</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>R</ci>
      <ci>m</ci>
     </apply>
     <interval closure="open">
      <interval closure="open">
       <ci>𝐱</ci>
       <ci>𝜽</ci>
      </interval>
      <interval closure="open">
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>𝐱</ci>
        <ci>normal-′</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>𝜽</ci>
        <ci>normal-′</ci>
       </apply>
      </interval>
     </interval>
    </apply>
    <apply>
     <times></times>
     <apply>
      <exp></exp>
      <apply>
       <minus></minus>
       <apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <sum></sum>
          <apply>
           <eq></eq>
           <ci>k</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
         <ci>d</ci>
        </apply>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>ω</ci>
           <ci>k</ci>
          </apply>
          <ci>m</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <minus></minus>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>x</ci>
            <ci>k</ci>
           </apply>
           <apply>
            <csymbol cd="ambiguous">superscript</csymbol>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <ci>x</ci>
             <ci>k</ci>
            </apply>
            <ci>normal-′</ci>
           </apply>
          </apply>
          <cn type="integer">2</cn>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <exp></exp>
      <apply>
       <minus></minus>
       <apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <sum></sum>
          <apply>
           <eq></eq>
           <ci>k</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
         <ci>r</ci>
        </apply>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>ω</ci>
           <apply>
            <plus></plus>
            <ci>d</ci>
            <ci>k</ci>
           </apply>
          </apply>
          <ci>m</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <minus></minus>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>θ</ci>
            <ci>k</ci>
           </apply>
           <apply>
            <csymbol cd="ambiguous">superscript</csymbol>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <ci>θ</ci>
             <ci>k</ci>
            </apply>
            <ci>normal-′</ci>
           </apply>
          </apply>
          <cn type="integer">2</cn>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R^{m}\big((\mathbf{x},\boldsymbol{\theta}),(\mathbf{x}^{\prime},\boldsymbol{%
\theta}^{\prime})\big)=\exp\left\{-\sum_{k=1}^{d}\omega_{k}^{m}(x_{k}-x_{k}^{%
\prime})^{2}\right\}\exp\left\{-\sum_{k=1}^{r}\omega_{d+k}^{m}(\theta_{k}-%
\theta_{k}^{\prime})^{2}\right\}.
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Uncertainty_quantification:17">
 <semantics>
  <mi>d</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>d</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d
  </annotation>
 </semantics>
</math>

 is the dimension of input variables, and 

<math display="inline" id="Uncertainty_quantification:18">
 <semantics>
  <mi>r</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>r</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r
  </annotation>
 </semantics>
</math>

 is the dimension of unknown parameters.While 

<math display="inline" id="Uncertainty_quantification:19">
 <semantics>
  <mrow>
   <msup>
    <mi>𝐡</mi>
    <mi>m</mi>
   </msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>⋅</mo>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>𝐡</ci>
     <ci>m</ci>
    </apply>
    <ci>normal-⋅</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{h}^{m}(\cdot)
  </annotation>
 </semantics>
</math>

 is pre-defined, 

<math display="inline" id="Uncertainty_quantification:20">
 <semantics>
  <mrow>
   <mo>{</mo>
   <mrow>
    <mrow>
     <mrow>
      <msup>
       <mi>𝜷</mi>
       <mi>m</mi>
      </msup>
      <mo>,</mo>
      <msub>
       <mi>σ</mi>
       <mi>m</mi>
      </msub>
      <mo>,</mo>
      <msubsup>
       <mi>ω</mi>
       <mi>k</mi>
       <mi>m</mi>
      </msubsup>
      <mo>,</mo>
      <mi>k</mi>
     </mrow>
     <mo>=</mo>
     <mn>1</mn>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <mrow>
      <mi>d</mi>
      <mo>+</mo>
      <mi>r</mi>
     </mrow>
    </mrow>
   </mrow>
   <mo>}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <csymbol cd="ambiguous">formulae-sequence</csymbol>
     <apply>
      <eq></eq>
      <list>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>𝜷</ci>
        <ci>m</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>σ</ci>
        <ci>m</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>ω</ci>
         <ci>k</ci>
        </apply>
        <ci>m</ci>
       </apply>
       <ci>k</ci>
      </list>
      <cn type="integer">1</cn>
     </apply>
     <list>
      <ci>normal-…</ci>
      <apply>
       <plus></plus>
       <ci>d</ci>
       <ci>r</ci>
      </apply>
     </list>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left\{\boldsymbol{\beta}^{m},\sigma_{m},\omega_{k}^{m},k=1,\ldots,d+r\right\}
  </annotation>
 </semantics>
</math>

, known as <em><a href="hyperparameter" title="wikilink">hyperparameters</a></em> of the GP model, need to be estimated via <a href="Maximum_likelihood" title="wikilink">maximum likelihood estimation (MLE)</a>. This module can be considered as a generalized <a class="uri" href="Kriging" title="wikilink">Kriging</a> method.</p>
<dl>
<dt><strong>Module 2:</strong> Gaussian process modeling for the discrepancy function</dt>
</dl>

<p>Similarly with the first module, the discrepancy function is replaced with a GP model</p>

<p>

<math display="block" id="Uncertainty_quantification:21">
 <semantics>
  <mrow>
   <mrow>
    <mi>δ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>𝐱</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>∼</mo>
   <mrow>
    <mi class="ltx_font_mathcaligraphic">𝒢</mi>
    <mi class="ltx_font_mathcaligraphic">𝒫</mi>
    <mrow>
     <mo maxsize="120%" minsize="120%">(</mo>
     <mrow>
      <msup>
       <mi>𝐡</mi>
       <mi>δ</mi>
      </msup>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mo>⋅</mo>
        <mo stretchy="false">)</mo>
       </mrow>
       <mi>T</mi>
      </msup>
      <msup>
       <mi>𝜷</mi>
       <mi>δ</mi>
      </msup>
     </mrow>
     <mo>,</mo>
     <mrow>
      <msubsup>
       <mi>σ</mi>
       <mi>δ</mi>
       <mn>2</mn>
      </msubsup>
      <msup>
       <mi>R</mi>
       <mi>δ</mi>
      </msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mo>⋅</mo>
       <mo>,</mo>
       <mo>⋅</mo>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo maxsize="120%" minsize="120%">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">similar-to</csymbol>
    <apply>
     <times></times>
     <ci>δ</ci>
     <ci>𝐱</ci>
    </apply>
    <apply>
     <times></times>
     <ci>𝒢</ci>
     <ci>𝒫</ci>
     <interval closure="open">
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>𝐡</ci>
        <ci>δ</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>normal-⋅</ci>
        <ci>T</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>𝜷</ci>
        <ci>δ</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>σ</ci>
         <ci>δ</ci>
        </apply>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>R</ci>
        <ci>δ</ci>
       </apply>
       <interval closure="open">
        <ci>normal-⋅</ci>
        <ci>normal-⋅</ci>
       </interval>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta(\mathbf{x})\sim\mathcal{GP}\big(\mathbf{h}^{\delta}(\cdot)^{T}%
\boldsymbol{\beta}^{\delta},\sigma_{\delta}^{2}R^{\delta}(\cdot,\cdot)\big)
  </annotation>
 </semantics>
</math>

 where</p>

<p>

<math display="block" id="Uncertainty_quantification:22">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msup>
      <mi>R</mi>
      <mi>δ</mi>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>𝐱</mi>
      <mo>,</mo>
      <msup>
       <mi>𝐱</mi>
       <mo>′</mo>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>exp</mi>
     <mrow>
      <mo>{</mo>
      <mrow>
       <mo>-</mo>
       <mrow>
        <munderover>
         <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
         <mrow>
          <mi>k</mi>
          <mo>=</mo>
          <mn>1</mn>
         </mrow>
         <mi>d</mi>
        </munderover>
        <mrow>
         <msubsup>
          <mi>ω</mi>
          <mi>k</mi>
          <mi>δ</mi>
         </msubsup>
         <msup>
          <mrow>
           <mo stretchy="false">(</mo>
           <mrow>
            <msub>
             <mi>x</mi>
             <mi>k</mi>
            </msub>
            <mo>-</mo>
            <msubsup>
             <mi>x</mi>
             <mi>k</mi>
             <mo>′</mo>
            </msubsup>
           </mrow>
           <mo stretchy="false">)</mo>
          </mrow>
          <mn>2</mn>
         </msup>
        </mrow>
       </mrow>
      </mrow>
      <mo>}</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>R</ci>
      <ci>δ</ci>
     </apply>
     <interval closure="open">
      <ci>𝐱</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>𝐱</ci>
       <ci>normal-′</ci>
      </apply>
     </interval>
    </apply>
    <apply>
     <exp></exp>
     <apply>
      <minus></minus>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <ci>k</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>d</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>ω</ci>
          <ci>k</ci>
         </apply>
         <ci>δ</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <minus></minus>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>x</ci>
           <ci>k</ci>
          </apply>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>x</ci>
            <ci>k</ci>
           </apply>
           <ci>normal-′</ci>
          </apply>
         </apply>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R^{\delta}(\mathbf{x},\mathbf{x}^{\prime})=\exp\left\{-\sum_{k=1}^{d}\omega_{k%
}^{\delta}(x_{k}-x_{k}^{\prime})^{2}\right\}.
  </annotation>
 </semantics>
</math>

 Together with the prior distribution of unknown parameters, and data from both computer models and experiments, one can derive the maximum likelihood estimates for 

<math display="inline" id="Uncertainty_quantification:23">
 <semantics>
  <mrow>
   <mo>{</mo>
   <mrow>
    <mrow>
     <mrow>
      <msup>
       <mi>𝜷</mi>
       <mi>δ</mi>
      </msup>
      <mo>,</mo>
      <msub>
       <mi>σ</mi>
       <mi>δ</mi>
      </msub>
      <mo>,</mo>
      <msubsup>
       <mi>ω</mi>
       <mi>k</mi>
       <mi>δ</mi>
      </msubsup>
      <mo>,</mo>
      <mi>k</mi>
     </mrow>
     <mo>=</mo>
     <mn>1</mn>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <mi>d</mi>
    </mrow>
   </mrow>
   <mo>}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <csymbol cd="ambiguous">formulae-sequence</csymbol>
     <apply>
      <eq></eq>
      <list>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>𝜷</ci>
        <ci>δ</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>σ</ci>
        <ci>δ</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>ω</ci>
         <ci>k</ci>
        </apply>
        <ci>δ</ci>
       </apply>
       <ci>k</ci>
      </list>
      <cn type="integer">1</cn>
     </apply>
     <list>
      <ci>normal-…</ci>
      <ci>d</ci>
     </list>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left\{\boldsymbol{\beta}^{\delta},\sigma_{\delta},\omega_{k}^{\delta},k=1,%
\ldots,d\right\}
  </annotation>
 </semantics>
</math>

. At the same time, 

<math display="inline" id="Uncertainty_quantification:24">
 <semantics>
  <msup>
   <mi>𝜷</mi>
   <mi>m</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>𝜷</ci>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \boldsymbol{\beta}^{m}
  </annotation>
 </semantics>
</math>

 from Module 1 gets updated as well.</p>
<dl>
<dt><strong>Module 3:</strong> Posterior distribution of unknown parameters</dt>
</dl>

<p><a href="Bayes'_theorem" title="wikilink">Bayes' theorem</a> is applied to calculate the <a href="posterior_distribution" title="wikilink">posterior distribution</a> of the unknown parameters:</p>

<p>

<math display="block" id="Uncertainty_quantification:25">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>𝜽</mi>
    <mo stretchy="false">|</mo>
    <mi>data</mi>
    <mo>,</mo>
    <mi mathvariant="bold-italic">ϕ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∝</mo>
   <mi mathvariant="normal">p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>data</mi>
    <mo stretchy="false">|</mo>
    <mi>𝜽</mi>
    <mo>,</mo>
    <mi mathvariant="bold-italic">ϕ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi mathvariant="normal">p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>𝜽</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">θ</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">data</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">ϕ</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="latexml">proportional-to</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">data</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">θ</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">ϕ</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">θ</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(\boldsymbol{\theta}|\rm{data},\boldsymbol{\phi})\propto p(\rm{data}|%
\boldsymbol{\theta},\boldsymbol{\phi})p(\boldsymbol{\theta})
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Uncertainty_quantification:26">
 <semantics>
  <mi mathvariant="bold-italic">ϕ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>bold-italic-ϕ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \boldsymbol{\phi}
  </annotation>
 </semantics>
</math>

 includes all the fixed hyperparameters in previous modules.</p>
<dl>
<dt><strong>Module 4:</strong> Prediction of the experimental response and discrepancy function</dt>
</dl>
<h5 id="fully-bayesian-approach">Fully Bayesian approach</h5>

<p>Fully Bayesian approach requires that not only the priors for unknown parameters 

<math display="inline" id="Uncertainty_quantification:27">
 <semantics>
  <mi>𝜽</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝜽</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \boldsymbol{\theta}
  </annotation>
 </semantics>
</math>

 but also the priors for the other hyperparameters 

<math display="inline" id="Uncertainty_quantification:28">
 <semantics>
  <mi mathvariant="bold-italic">ϕ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>bold-italic-ϕ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \boldsymbol{\phi}
  </annotation>
 </semantics>
</math>

 should be assigned. It follows the following steps:<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a></p>
<ol>
<li>Derive the posterior distribution 

<math display="inline" id="Uncertainty_quantification:29">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>𝜽</mi>
    <mo>,</mo>
    <mi mathvariant="bold-italic">ϕ</mi>
    <mo stretchy="false">|</mo>
    <mi>data</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">θ</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">ϕ</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">data</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(\boldsymbol{\theta},\boldsymbol{\phi}|\rm{data})
  </annotation>
 </semantics>
</math>

;</li>
<li>Integrate 

<math display="inline" id="Uncertainty_quantification:30">
 <semantics>
  <mi mathvariant="bold-italic">ϕ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>bold-italic-ϕ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \boldsymbol{\phi}
  </annotation>
 </semantics>
</math>

 out and obtain 

<math display="inline" id="Uncertainty_quantification:31">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>𝜽</mi>
    <mo stretchy="false">|</mo>
    <mi>data</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">θ</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">data</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(\boldsymbol{\theta}|\rm{data})
  </annotation>
 </semantics>
</math>

. This single step accomplishes the calibration;</li>
<li>Prediction of the experimental response and discrepancy function.</li>
</ol>

<p>However, the approach has significant drawbacks:</p>
<ul>
<li>For most cases, 

<math display="inline" id="Uncertainty_quantification:32">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>𝜽</mi>
    <mo>,</mo>
    <mi mathvariant="bold-italic">ϕ</mi>
    <mo stretchy="false">|</mo>
    <mi>data</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">θ</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">ϕ</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">data</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(\boldsymbol{\theta},\boldsymbol{\phi}|\rm{data})
  </annotation>
 </semantics>
</math>

 is a highly intractable function of 

<math display="inline" id="Uncertainty_quantification:33">
 <semantics>
  <mi mathvariant="bold-italic">ϕ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>bold-italic-ϕ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \boldsymbol{\phi}
  </annotation>
 </semantics>
</math>

. Hence the integration becomes very troublesome. Moreover, if priors for the other hyperparameters 

<math display="inline" id="Uncertainty_quantification:34">
 <semantics>
  <mi mathvariant="bold-italic">ϕ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>bold-italic-ϕ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \boldsymbol{\phi}
  </annotation>
 </semantics>
</math>

 are not carefully chosen, the complexity in numerical integration increases even more.</li>
<li>In the prediction stage, the prediction (which should at least include the expected value of system responses) also requires numerical integration. <a href="Markov_chain_Monte_Carlo" title="wikilink">Markov chain Monte Carlo (MCMC)</a> is often used for integration; however it is computationally expensive.</li>
</ul>

<p>The fully Bayesian approach requires a huge amount of calculations and may not yet be practical for dealing with the most complicated modelling situations.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a></p>
<h2 id="known-issues">Known issues</h2>

<p>The theories and methodologies for uncertainty propagation are much better established, compared with inverse uncertainty quantification. For the latter, several difficulties remain unsolved:</p>
<ol>
<li>Dimensionality issue: The computational cost increases dramatically with the dimensionality of the problem, i.e. the number of input variables and/or the number of unknown parameters.</li>
<li>Identifiability issue:<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a> Multiple combinations of unknown parameters and discrepancy function can yield the same experimental prediction. Hence different values of parameters cannot be distinguished/identified.</li>
</ol>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Computer_experiment" title="wikilink">Computer experiment</a></li>
<li><a href="Quantification_of_margins_and_uncertainties" title="wikilink">Quantification of margins and uncertainties</a></li>
</ul>
<h2 id="references">References</h2>
<h2 id="further-reading">Further reading</h2>
<ul>
<li>da Silva, R.B., Bulska, E., Godlewska-Zylkiewicz, B., Hedrich, M., Majcen, N., Magnusson, B., Marincic, S., Papadakis, I., Patriarca, M., Vassileva, E., Taylor, P., Analytical measurement: measurement uncertainty and statistics; ISBN 978-92-79-23070-7, 2012.</li>
<li><a href="http://publications.npl.co.uk/npl_web/pdf/tqe2.pdf">Arnaut, L. R. Measurement uncertainty in reverberation chambers - I. Sample statistics. Technical report TQE 2, 2nd. ed., National Physical Laboratory, 2008.</a></li>
</ul>

<p>"</p>

<p><a href="Category:Applied_mathematics" title="wikilink">Category:Applied mathematics</a> <a href="Category:Mathematical_modeling" title="wikilink">Category:Mathematical modeling</a> <a href="Category:Operations_research" title="wikilink">Category:Operations research</a> <a href="Category:Uncertainty_of_numbers" title="wikilink">Category:Uncertainty of numbers</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Jerome Sacks, William J. Welch, Toby J. Mitchell and Henry P. Wynn, <em>Design and Analysis of Computer Experiments</em>, Statistical Science, Vol. 4, No. 4 (Nov., 1989), pp. 409-423<a href="#fnref1">↩</a></li>
<li id="fn2">Ronald L. Iman, Jon C. Helton, <em>An Investigation of Uncertainty and Sensitivity Analysis Techniques for Computer Models</em>, Risk Analysis, Volume 8, Issue 1, pages 71–90, March 1988, DOI: 10.1111/j.1539-6924.1988.tb01155.x<a href="#fnref2">↩</a></li>
<li id="fn3">W.E. Walker, P. Harremoës, J. Rotmans, J.P. van der Sluijs, M.B.A. van Asselt, P. Janssen and M.P. Krayer von Krauss, <em>Defining Uncertainty: A Conceptual Basis for Uncertainty Management in Model-Based Decision Support</em>, Integrated Assessment, Volume 4, Issue 1, 2003, DOI: 10.1076/iaij.4.1.5.16466<a href="#fnref3">↩</a></li>
<li id="fn4">Marc C. Kennedy, Anthony O'Hagan, <em>Bayesian calibration of computer models</em>, Journal of the Royal Statistical Society, Series B Volume 63, Issue 3, pages 425–464, 2001<a href="#fnref4">↩</a></li>
<li id="fn5">Armen Der Kiureghiana, Ove Ditlevsen, <em>Aleatory or epistemic? Does it matter?</em>, Structural Safety, Volume 31, Issue 2, March 2009, Pages 105–112<a href="#fnref5">↩</a></li>
<li id="fn6">Hermann G. Matthies, <em>Quantifying uncertainty: modern computational representation of probability and applications</em>, Extreme Man-Made and Natural Hazards in Dynamics of Structures, NATO Security through Science Series, 2007, 105-135, DOI: 10.1007/978-1-4020-5656-7_4<a href="#fnref6">↩</a></li>
<li id="fn7">Abhaya Indrayan, "Medical Biostatistics, Second Edition", Chapman &amp; Hall/CRC Press, 2008, pages 8, 673<a href="#fnref7">↩</a></li>
<li id="fn8">S. H. Lee and W. Chen, <em>A comparative study of uncertainty propagation methods for black-box-type problems</em>, Structural and Multidisciplinary Optimization Volume 37, Number 3 (2009), 239-253, DOI: 10.1007/s00158-008-0234-7<a href="#fnref8">↩</a></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
<li id="fn10"><a href="http://publications.npl.co.uk/npl_web/pdf/tqe2.pdf">Arnaut, L. R. Measurement uncertainty in reverberation chambers - I. Sample statistics. Technical report TQE 2, 2nd. ed., sec. 3.1, National Physical Laboratory, 2008.</a><a href="#fnref10">↩</a></li>
<li id="fn11"></li>
<li id="fn12">Marc C. Kennedy, Anthony O'Hagan, <em>Supplementary Details on Bayesian Calibration of Computer Models</em>, Sheffield, University of Sheffield: 1-13, 2000<a href="#fnref12">↩</a></li>
<li id="fn13">F. Liu, M.J. Bayarriy and J.O.Bergerz, <em>Modularization in Bayesian Analysis, with Emphasis on Analysis of Computer Models</em>, Bayesian Analysis (2009) 4, Number 1, pp. 119-150, <a class="uri" href="DOI:10.1214/09-BA404">DOI:10.1214/09-BA404</a><a href="#fnref13">↩</a></li>
<li id="fn14"></li>
<li id="fn15">Arendt, P., W. Chen, and D. Apley, <em>Improving Identifiability in Model Calibration Using Multiple Responses</em>, DETC2011-48623, ASME International Design Engineering Technical Conferences, August 28–31, Washington, D.C., 2011<a href="#fnref15">↩</a></li>
</ol>
</section>
</body>
</html>
