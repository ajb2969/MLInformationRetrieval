<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1947">Turing reduction</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Turing reduction</h1>
<hr/>

<p>In <a href="computability_theory" title="wikilink">computability theory</a>, a <strong>Turing reduction</strong> from a problem <em>A</em> to a problem <em>B</em>, is a <a href="reduction_(complexity)" title="wikilink">reduction</a> which solves <em>A</em>, assuming the solution to <em>B</em> is already known (Rogers 1967, Soare 1987). It can be understood as an <a class="uri" href="algorithm" title="wikilink">algorithm</a> that could be used to solve <em>A</em> if it had available to it a <a class="uri" href="subroutine" title="wikilink">subroutine</a> for solving <em>B</em>. More formally, a Turing reduction is a function computable by an <a href="oracle_machine" title="wikilink">oracle machine</a> with an oracle for <em>B</em>. Turing reductions can be applied to both <a href="decision_problem" title="wikilink">decision problems</a> and <a href="function_problem" title="wikilink">function problems</a>.</p>

<p>If a Turing reduction of <em>A</em> to <em>B</em> exists then every <a class="uri" href="algorithm" title="wikilink">algorithm</a> for <em>B</em> can be used to produce an algorithm for <em>A</em>, by inserting the algorithm for <em>B</em> at each place where the oracle machine computing <em>A</em> queries the oracle for <em>B</em>. However, because the oracle machine may query the oracle a large number of times, the resulting algorithm may require more time asymptotically than either the algorithm for <em>B</em> or the oracle machine computing <em>A</em>, and may require as much space as both together.</p>

<p>The first formal definition of relative computability, then called relative reducibility, was given by <a href="Alan_Turing" title="wikilink">Alan Turing</a> in 1939 in terms of <a href="oracle_machine" title="wikilink">oracle machines</a>. Later in 1943 and 1952 <a href="Stephen_Kleene" title="wikilink">Stephen Kleene</a> defined an equivalent concept in terms of <a href="Mu-recursive_function" title="wikilink">recursive functions</a>. In 1944 <a href="Emil_Post" title="wikilink">Emil Post</a> used the term "Turing reducibility" to refer to the concept.</p>

<p>A <a href="polynomial-time_reduction" title="wikilink">polynomial-time</a> Turing reduction is known as a <strong>Cook reduction</strong>, after <a href="Stephen_Cook" title="wikilink">Stephen Cook</a>.</p>
<h2 id="definition">Definition</h2>

<p>Given two sets 

<math display="inline" id="Turing_reduction:0">
 <semantics>
  <mrow>
   <mrow>
    <mi>A</mi>
    <mo>,</mo>
    <mi>B</mi>
   </mrow>
   <mo>âŠ†</mo>
   <mi>â„•</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <list>
     <ci>A</ci>
     <ci>B</ci>
    </list>
    <ci>â„•</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A,B\subseteq\mathbb{N}
  </annotation>
 </semantics>
</math>

 of natural numbers, we say 

<math display="inline" id="Turing_reduction:1">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 is <strong>Turing reducible</strong> to 

<math display="inline" id="Turing_reduction:2">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

 and write</p>

<p>

<math display="block" id="Turing_reduction:3">
 <semantics>
  <mrow>
   <mi>A</mi>
   <msub>
    <mo>â‰¤</mo>
    <mi>T</mi>
   </msub>
   <mi>B</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <leq></leq>
     <ci>T</ci>
    </apply>
    <ci>A</ci>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\leq_{T}B
  </annotation>
 </semantics>
</math>

 if there is an <a href="oracle_machine" title="wikilink">oracle machine</a> that computes the <a href="Indicator_function" title="wikilink">characteristic function</a> of <em>A</em> when run with oracle <em>B</em>. In this case, we also say <em>A</em> is <strong><em>B</em>-recursive</strong> and <strong><em>B</em>-computable</strong>.</p>

<p>If there is an oracle machine that, when run with oracle <em>B</em>, computes a partial function with domain <em>A</em>, then <em>A</em> is said to be <strong><em>B</em>-<a href="recursively_enumerable_set" title="wikilink">recursively enumerable</a></strong> and <strong><em>B</em>-computably enumerable</strong>.</p>

<p>We say 

<math display="inline" id="Turing_reduction:4">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 is <strong>Turing equivalent</strong> to 

<math display="inline" id="Turing_reduction:5">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

 and write 

<math display="inline" id="Turing_reduction:6">
 <semantics>
  <mrow>
   <mi>A</mi>
   <msub>
    <mo>â‰¡</mo>
    <mi>T</mi>
   </msub>
   <mpadded width="+1.7pt">
    <mi>B</mi>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <equivalent></equivalent>
     <ci>T</ci>
    </apply>
    <ci>A</ci>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\equiv_{T}B\,
  </annotation>
 </semantics>
</math>

 if both 

<math display="inline" id="Turing_reduction:7">
 <semantics>
  <mrow>
   <mi>A</mi>
   <msub>
    <mo>â‰¤</mo>
    <mi>T</mi>
   </msub>
   <mi>B</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <leq></leq>
     <ci>T</ci>
    </apply>
    <ci>A</ci>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\leq_{T}B
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Turing_reduction:8">
 <semantics>
  <mrow>
   <mrow>
    <mi>B</mi>
    <msub>
     <mo>â‰¤</mo>
     <mi>T</mi>
    </msub>
    <mi>A</mi>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <leq></leq>
     <ci>T</ci>
    </apply>
    <ci>B</ci>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B\leq_{T}A.
  </annotation>
 </semantics>
</math>

 The <a href="equivalence_class" title="wikilink">equivalence classes</a> of Turing equivalent sets are called <strong><a href="Turing_degree" title="wikilink">Turing degrees</a></strong>. The Turing degree of a set 

<math display="inline" id="Turing_reduction:9">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

 is written 

<math display="inline" id="Turing_reduction:10">
 <semantics>
  <mrow>
   <mtext>ğğğ </mtext>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <mtext>deg</mtext>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textbf{deg}(X)
  </annotation>
 </semantics>
</math>

.</p>

<p>Given a set 

<math display="inline" id="Turing_reduction:11">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">ğ’³</mi>
   <mo>âŠ†</mo>
   <mrow>
    <mi class="ltx_font_mathcaligraphic">ğ’«</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>â„•</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <ci>ğ’³</ci>
    <apply>
     <times></times>
     <ci>ğ’«</ci>
     <ci>â„•</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{X}\subseteq\mathcal{P}(\mathbb{N})
  </annotation>
 </semantics>
</math>

, a set 

<math display="inline" id="Turing_reduction:12">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>âŠ†</mo>
   <mi>â„•</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <ci>A</ci>
    <ci>â„•</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\subseteq\mathbb{N}
  </annotation>
 </semantics>
</math>

 is called <strong>Turing hard</strong> for 

<math display="inline" id="Turing_reduction:13">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ğ’³</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ğ’³</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{X}
  </annotation>
 </semantics>
</math>

 if 

<math display="inline" id="Turing_reduction:14">
 <semantics>
  <mrow>
   <mi>X</mi>
   <msub>
    <mo>â‰¤</mo>
    <mi>T</mi>
   </msub>
   <mi>A</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <leq></leq>
     <ci>T</ci>
    </apply>
    <ci>X</ci>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X\leq_{T}A
  </annotation>
 </semantics>
</math>

 for all 

<math display="inline" id="Turing_reduction:15">
 <semantics>
  <mrow>
   <mi>X</mi>
   <mo>âˆˆ</mo>
   <mi class="ltx_font_mathcaligraphic">ğ’³</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>X</ci>
    <ci>ğ’³</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X\in\mathcal{X}
  </annotation>
 </semantics>
</math>

. If additionally 

<math display="inline" id="Turing_reduction:16">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>âˆˆ</mo>
   <mi class="ltx_font_mathcaligraphic">ğ’³</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>A</ci>
    <ci>ğ’³</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\in\mathcal{X}
  </annotation>
 </semantics>
</math>

 then 

<math display="inline" id="Turing_reduction:17">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 is called <strong>Turing complete</strong> for 

<math display="inline" id="Turing_reduction:18">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ğ’³</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ğ’³</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{X}
  </annotation>
 </semantics>
</math>

.</p>
<h3 id="relation-of-turing-completeness-to-computational-universality">Relation of Turing completeness to computational universality</h3>

<p>Turing completeness, as just defined above, corresponds only partially to <a href="Turing_completeness" title="wikilink">Turing completeness</a> in the sense of computational universality. Specifically, a Turing machine is a <a href="universal_Turing_machine" title="wikilink">universal Turing machine</a> if its <a href="halting_problem" title="wikilink">halting problem</a> (i.e., the set of inputs for which it eventually halts) is <a href="Many-one_reduction" title="wikilink">many-one complete</a>. Thus, a necessary <em>but insufficient</em> condition for a machine to be computationally universal, is that the machine's halting problem be Turing-complete for the set 

<math display="inline" id="Turing_reduction:19">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ğ’³</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ğ’³</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{X}
  </annotation>
 </semantics>
</math>

 of recursively enumerable sets.</p>
<h2 id="example">Example</h2>

<p>Let 

<math display="inline" id="Turing_reduction:20">
 <semantics>
  <msub>
   <mi>W</mi>
   <mi>e</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>W</ci>
    <ci>e</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W_{e}
  </annotation>
 </semantics>
</math>

 denote the set of input values for which the Turing machine with index <em>e</em> halts. Then the sets 

<math display="inline" id="Turing_reduction:21">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mi>e</mi>
    <mo>âˆ£</mo>
    <mrow>
     <mi>e</mi>
     <mo>âˆˆ</mo>
     <msub>
      <mi>W</mi>
      <mi>e</mi>
     </msub>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>A</ci>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <ci>e</ci>
     <apply>
      <in></in>
      <ci>e</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>W</ci>
       <ci>e</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A=\{e\mid e\in W_{e}\}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Turing_reduction:22">
 <semantics>
  <mrow>
   <mi>B</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>e</mi>
     <mo>,</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>âˆ£</mo>
    <mrow>
     <mi>n</mi>
     <mo>âˆˆ</mo>
     <msub>
      <mi>W</mi>
      <mi>e</mi>
     </msub>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>B</ci>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <interval closure="open">
      <ci>e</ci>
      <ci>n</ci>
     </interval>
     <apply>
      <in></in>
      <ci>n</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>W</ci>
       <ci>e</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B=\{(e,n)\mid n\in W_{e}\}
  </annotation>
 </semantics>
</math>

 are Turing equivalent (here 

<math display="inline" id="Turing_reduction:23">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>e</mi>
   <mo>,</mo>
   <mi>n</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>e</ci>
    <ci>n</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (e,n)
  </annotation>
 </semantics>
</math>

 denotes an effective pairing function). A reduction showing 

<math display="inline" id="Turing_reduction:24">
 <semantics>
  <mrow>
   <mi>A</mi>
   <msub>
    <mo>â‰¤</mo>
    <mi>T</mi>
   </msub>
   <mi>B</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <leq></leq>
     <ci>T</ci>
    </apply>
    <ci>A</ci>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\leq_{T}B
  </annotation>
 </semantics>
</math>

 can be constructed using the fact that 

<math display="inline" id="Turing_reduction:25">
 <semantics>
  <mrow>
   <mrow>
    <mi>e</mi>
    <mo>âˆˆ</mo>
    <mi>A</mi>
   </mrow>
   <mo>â‡”</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>e</mi>
     <mo>,</mo>
     <mi>e</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>âˆˆ</mo>
    <mi>B</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-â‡”</ci>
    <apply>
     <in></in>
     <ci>e</ci>
     <ci>A</ci>
    </apply>
    <apply>
     <in></in>
     <interval closure="open">
      <ci>e</ci>
      <ci>e</ci>
     </interval>
     <ci>B</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e\in A\Leftrightarrow(e,e)\in B
  </annotation>
 </semantics>
</math>

. Given a pair 

<math display="inline" id="Turing_reduction:26">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>e</mi>
   <mo>,</mo>
   <mi>n</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>e</ci>
    <ci>n</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (e,n)
  </annotation>
 </semantics>
</math>

, a new index 

<math display="inline" id="Turing_reduction:27">
 <semantics>
  <mrow>
   <mi>i</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>e</mi>
    <mo>,</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>i</ci>
    <interval closure="open">
     <ci>e</ci>
     <ci>n</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i(e,n)
  </annotation>
 </semantics>
</math>

 can be constructed using the <a href="Smn_theorem" title="wikilink">s<sub>mn</sub> theorem</a> such that the program coded by 

<math display="inline" id="Turing_reduction:28">
 <semantics>
  <mrow>
   <mi>i</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>e</mi>
    <mo>,</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>i</ci>
    <interval closure="open">
     <ci>e</ci>
     <ci>n</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i(e,n)
  </annotation>
 </semantics>
</math>

 ignores its input and merely simulates the computation of the machine with index <em>e</em> on input <em>n</em>. In particular, the machine with index 

<math display="inline" id="Turing_reduction:29">
 <semantics>
  <mrow>
   <mi>i</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>e</mi>
    <mo>,</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>i</ci>
    <interval closure="open">
     <ci>e</ci>
     <ci>n</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i(e,n)
  </annotation>
 </semantics>
</math>

 either halts on every input or halts on no input. Thus 

<math display="inline" id="Turing_reduction:30">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>i</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>e</mi>
      <mo>,</mo>
      <mi>n</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>âˆˆ</mo>
    <mi>A</mi>
   </mrow>
   <mo>â‡”</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>e</mi>
     <mo>,</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>âˆˆ</mo>
    <mi>B</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-â‡”</ci>
    <apply>
     <in></in>
     <apply>
      <times></times>
      <ci>i</ci>
      <interval closure="open">
       <ci>e</ci>
       <ci>n</ci>
      </interval>
     </apply>
     <ci>A</ci>
    </apply>
    <apply>
     <in></in>
     <interval closure="open">
      <ci>e</ci>
      <ci>n</ci>
     </interval>
     <ci>B</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i(e,n)\in A\Leftrightarrow(e,n)\in B
  </annotation>
 </semantics>
</math>

 holds for all <em>e</em> and <em>n</em>. Because the function <em>i</em> is computable, this shows 

<math display="inline" id="Turing_reduction:31">
 <semantics>
  <mrow>
   <mi>B</mi>
   <msub>
    <mo>â‰¤</mo>
    <mi>T</mi>
   </msub>
   <mi>A</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <leq></leq>
     <ci>T</ci>
    </apply>
    <ci>B</ci>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B\leq_{T}A
  </annotation>
 </semantics>
</math>

. The reductions presented here are not only Turing reductions but <em>many-one reductions</em>, discussed below.</p>
<h2 id="properties">Properties</h2>
<ul>
<li>Every set is Turing equivalent to its complement</li>
<li>Every <a href="computable_set" title="wikilink">computable set</a> is Turing reducible to every other computable set. Because these sets can be computed with no oracle, they can be computed by an oracle machine that ignores the oracle it is given.</li>
<li>The relation 

<math display="inline" id="Turing_reduction:32">
 <semantics>
  <msub>
   <mo>â‰¤</mo>
   <mi>T</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <leq></leq>
    <ci>T</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \leq_{T}
  </annotation>
 </semantics>
</math>

 is transitive: if 

<math display="inline" id="Turing_reduction:33">
 <semantics>
  <mrow>
   <mi>A</mi>
   <msub>
    <mo>â‰¤</mo>
    <mi>T</mi>
   </msub>
   <mi>B</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <leq></leq>
     <ci>T</ci>
    </apply>
    <ci>A</ci>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\leq_{T}B
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Turing_reduction:34">
 <semantics>
  <mrow>
   <mi>B</mi>
   <msub>
    <mo>â‰¤</mo>
    <mi>T</mi>
   </msub>
   <mi>C</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <leq></leq>
     <ci>T</ci>
    </apply>
    <ci>B</ci>
    <ci>C</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B\leq_{T}C
  </annotation>
 </semantics>
</math>

 then 

<math display="inline" id="Turing_reduction:35">
 <semantics>
  <mrow>
   <mi>A</mi>
   <msub>
    <mo>â‰¤</mo>
    <mi>T</mi>
   </msub>
   <mi>C</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <leq></leq>
     <ci>T</ci>
    </apply>
    <ci>A</ci>
    <ci>C</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\leq_{T}C
  </annotation>
 </semantics>
</math>

. Moreover 

<math display="inline" id="Turing_reduction:36">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>â‰¤</mo>
   <mi>A</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <ci>A</ci>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\leq A
  </annotation>
 </semantics>
</math>

 holds for every set <em>A</em>, and thus the relation 

<math display="inline" id="Turing_reduction:37">
 <semantics>
  <msub>
   <mo>â‰¤</mo>
   <mi>T</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <leq></leq>
    <ci>T</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \leq_{T}
  </annotation>
 </semantics>
</math>

 is a <a class="uri" href="preorder" title="wikilink">preorder</a> (it is not a <a href="partial_order" title="wikilink">partial order</a> because 

<math display="inline" id="Turing_reduction:38">
 <semantics>
  <mrow>
   <mi>A</mi>
   <msub>
    <mo>â‰¤</mo>
    <mi>T</mi>
   </msub>
   <mi>B</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <leq></leq>
     <ci>T</ci>
    </apply>
    <ci>A</ci>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\leq_{T}B
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Turing_reduction:39">
 <semantics>
  <mrow>
   <mi>B</mi>
   <msub>
    <mo>â‰¤</mo>
    <mi>T</mi>
   </msub>
   <mi>A</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <leq></leq>
     <ci>T</ci>
    </apply>
    <ci>B</ci>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B\leq_{T}A
  </annotation>
 </semantics>
</math>

 does not necessarily imply 

<math display="inline" id="Turing_reduction:40">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>=</mo>
   <mi>B</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>A</ci>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A=B
  </annotation>
 </semantics>
</math>

).</li>
<li>There are pairs of sets 

<math display="inline" id="Turing_reduction:41">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>A</mi>
   <mo>,</mo>
   <mi>B</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>A</ci>
    <ci>B</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (A,B)
  </annotation>
 </semantics>
</math>

 such that <em>A</em> is not Turing reducible to <em>B</em> and <em>B</em> is not Turing reducible to <em>A</em>. Thus 

<math display="inline" id="Turing_reduction:42">
 <semantics>
  <msub>
   <mo>â‰¤</mo>
   <mi>T</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <leq></leq>
    <ci>T</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \leq_{T}
  </annotation>
 </semantics>
</math>

 is not a linear order.</li>
<li>There are infinite decreasing sequences of sets under 

<math display="inline" id="Turing_reduction:43">
 <semantics>
  <msub>
   <mo>â‰¤</mo>
   <mi>T</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <leq></leq>
    <ci>T</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \leq_{T}
  </annotation>
 </semantics>
</math>

. Thus this relation is not <a class="uri" href="well-founded" title="wikilink">well-founded</a>.</li>
<li>Every set is Turing reducible to its own <a href="Turing_jump" title="wikilink">Turing jump</a>, but the Turing jump of a set is never Turing reducible to the original set.</li>
</ul>
<h2 id="the-use-of-a-reduction">The use of a reduction</h2>

<p>Since every reduction from a set <em>B</em> to a set <em>A</em> has to determine whether a single element is in <em>A</em> in only finitely many steps, it can only make finitely many queries of membership in the set <em>B</em>. When the amount of information about the set <em>B</em> used to compute a single bit of <em>A</em> is discussed, this is made precise by the use function. Formally, the <em>use</em> of a reduction is the function that sends each natural number <em>n</em> to the largest natural number <em>m</em> whose membership in the set <em>B</em> was queried by the reduction while determining the membership of <em>n</em> in <em>A</em>.</p>
<h2 id="stronger-reductions">Stronger reductions</h2>

<p>There are two common ways of producing reductions stronger than Turing reducibility. The first way is to limit the number and manner of oracle queries.</p>
<ul>
<li>A set <em>A</em> is <strong><a href="many-one_reduction" title="wikilink">many-one reducible</a></strong> to <em>B</em> if there is a <a href="Computable_function" title="wikilink">total computable function</a> <em>f</em> such that an element <em>n</em> is in <em>A</em> if and only if <em>f</em>(<em>n</em>) is in <em>B</em>. Such a function can be used to generate a Turing reduction (by computing <em>f</em>(<em>n</em>), querying the oracle, and then interpreting the result).</li>
<li>A <strong><a href="truth_table_reduction" title="wikilink">truth table reduction</a></strong> or a <strong><a href="truth_table_reduction" title="wikilink">weak truth table reduction</a></strong> must present all of its oracle queries at the same time. In a truth table reduction, the reduction also gives a boolean function (a <strong>truth table</strong>) which, when given the answers to the queries, will produce the final answer of the reduction. In a weak truth table reduction, the reduction uses the oracle answers as a basis for further computation depending on the given answers (but not using the oracle). Equivalently, a weak truth table reduction is one for which the use of the reduction is bounded by a computable function. For this reason, weak truth table reductions are sometimes called "bounded Turing" reductions.</li>
</ul>

<p>The second way to produce a stronger reducibility notion is to limit the computational resources that the program implementing the Turing reduction may use. These limits on the <a href="Computational_complexity_theory" title="wikilink">computational complexity</a> of the reduction are important when studying subrecursive classes such as <a href="P_(complexity)" title="wikilink">P</a>. A set <em>A</em> is <strong><a href="Polynomial-time_reduction" title="wikilink">polynomial-time reducible</a></strong> to a set <em>B</em> if there is a Turing reduction of <em>A</em> to <em>B</em> that runs in polynomial time. The concept of <strong><a href="log-space_reduction" title="wikilink">log-space reduction</a></strong> is similar.</p>

<p>These reductions are stronger in the sense that they provide a finer distinction into equivalence classes, and satisfy more restrictive requirements than Turing reductions. Consequently, such reductions are harder to find. There may be no way to build a many-one reduction from one set to another even when a Turing reduction for the same sets exists.</p>
<h2 id="weaker-reductions">Weaker reductions</h2>

<p>According to the <a href="Churchâ€“Turing_thesis" title="wikilink">Churchâ€“Turing thesis</a>, a Turing reduction is the most general form of an effectively calculable reduction. Nevertheless, weaker reductions are also considered. A set <em>A</em> is said to be <strong><a href="arithmetical_set" title="wikilink">arithmetical</a> in</strong> <em>B</em> if <em>A</em> is definable by a formula of <a href="Peano_arithmetic" title="wikilink">Peano arithmetic</a> with <em>B</em> as a parameter. The set <em>A</em> is <strong><a href="hyperarithmetical_hierarchy" title="wikilink">hyperarithmetical</a> in</strong> <em>B</em> if there is a <a href="recursive_ordinal" title="wikilink">recursive ordinal</a> Î± such that <em>A</em> is computable from 

<math display="inline" id="Turing_reduction:44">
 <semantics>
  <msup>
   <mi>B</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>Î±</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>B</ci>
    <ci>Î±</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B^{(\alpha)}
  </annotation>
 </semantics>
</math>

, the Î±-iterated Turing jump of <em>B</em>. The notion of <strong><a href="Constructible_universe" title="wikilink">relative constructibility</a></strong> is an important reducibility notion in set theory.</p>
<h2 id="references">References</h2>
<ul>
<li>M. Davis, ed., 1965. <em>The Undecidableâ€”Basic Papers on Undecidable Propositions, Unsolvable Problems and Computable Functions</em>, Raven, New York. Reprint, Dover, 2004. ISBN 0-486-43228-9.</li>
<li>S. C. Kleene, 1952. Introduction to Metamathematics. Amsterdam: North-Holland.</li>
<li>S. C. Kleene and E. L. Post, 1954. "The upper semi-lattice of degrees of recursive unsolvability". <em>Annals of Mathematics</em> v. 2 n. 59, 379â€”407.</li>
<li>E. Post, 1944. "Recursively enumerable sets of positive integers and their decision problems." Bulletin of the American Mathematical Society, v. 50, pp.Â 284â€“316. Reprinted in "The Undecidable", M. Davis ed., 1965.</li>
<li>A. Turing, 1939. "Systems of logic based on ordinals." <em>Proceedings of the London Mathematics Society</em>, ser. 2 v. 45, pp.Â 161â€“228. Reprinted in "The Undecidable", M. Davis ed., 1965.</li>
<li>H. Rogers, 1967. Theory of recursive functions and effective computability. McGraw-Hill.</li>
<li>R. Soare, 1987. Recursively enumerable sets and degrees, Springer.</li>
<li>{{ cite journal</li>
</ul>

<p><code>Â Â |Â lastÂ =Â Davis</code><br/>
<code>Â Â |Â firstÂ =Â Martin</code><br/>
<code>Â Â |Â authorlinkÂ =Â MartinÂ Davis</code><br/>
<code>Â Â |Â titleÂ =Â WhatÂ is...TuringÂ Reducibility?</code><br/>
<code>Â Â |Â journalÂ =Â </code><a href="Notices_of_the_American_Mathematical_Society" title="wikilink"><code>Notices</code> <code>of</code> <code>the</code> <code>American</code> <code>Mathematical</code> <code>Society</code></a><br/>
<code>Â Â |date=NovemberÂ 2006</code><br/>
<code>Â Â |Â volumeÂ =Â 53</code><br/>
<code>Â Â |Â issueÂ =Â 10</code><br/>
<code>Â Â |Â pagesÂ =Â pp.1218â€“1219</code><br/>
<code>Â Â |Â urlÂ =Â </code><a href="http://www.ams.org/notices/200610/whatis-davis.pdf"><code>http://www.ams.org/notices/200610/whatis-davis.pdf</code></a><br/>
<code>Â Â |Â formatÂ =Â </code><a href="PDF" title="wikilink"><code>PDF</code></a><br/>
<code>Â Â |Â accessdateÂ =Â 2008-01-16Â }}</code></p>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.nist.gov/dads/HTML/turingredctn.html">NIST Dictionary of Algorithms and Data Structures: Turing reduction</a></li>
</ul>

<p><a href="he:×¨×“×•×§×¦×™×”_×—×™×©×•×‘×™×ª" title="wikilink">he:×¨×“×•×§×¦×™×” ×—×™×©×•×‘×™×ª</a>"</p>

<p><a href="Category:Computability_theory" title="wikilink">Category:Computability theory</a> <a href="Category:Computational_complexity_theory" title="wikilink">Category:Computational complexity theory</a> <a href="Category:Alan_Turing" title="wikilink">Category:Alan Turing</a></p>
</body>
</html>
