<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1376">Specular highlight</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Specular highlight</h1>
<hr/>
<figure><b>(Figure)</b>
<figcaption>Specular highlights on a pair of spheres.</figcaption>
</figure>

<p>A <strong>specular highlight</strong> is the bright spot of <a class="uri" href="light" title="wikilink">light</a> that appears on shiny objects when illuminated (for example, see image at right). Specular highlights are important in <a href="3D_computer_graphics" title="wikilink">3D computer graphics</a>, as they provide a strong visual cue for the shape of an object and its location with respect to light sources in the scene.</p>
<h2 id="microfacets">Microfacets</h2>

<p>The term <em>specular</em> means that light is <a href="specular_reflection" title="wikilink">perfectly reflected</a> in a mirror-like way from the light source to the viewer. Specular reflection is visible only where the <a href="surface_normal" title="wikilink">surface normal</a> is oriented precisely halfway between the direction of incoming light and the direction of the viewer; this is called the <strong>half-angle</strong> direction because it bisects (divides into halves) the angle between the incoming light and the viewer. Thus, a specularly reflecting surface would show a specular highlight as the perfectly sharp reflected image of a light source. However, many shiny objects show blurred specular highlights.</p>

<p>This can be explained by the existence of <strong>microfacets</strong>. We assume that surfaces that are not perfectly smooth are composed of many very tiny facets, each of which is a perfect specular reflector. These microfacets have normals that are distributed about the normal of the approximating smooth surface. The degree to which microfacet normals differ from the smooth surface normal is determined by the roughness of the surface. At points on the object where the smooth normal is close to the half-angle direction, many of the microfacets point in the half-angle direction and so the specular highlight is bright. As one moves away from the center of the highlight, the smooth normal and the half-angle direction get farther apart; the number of microfacets oriented in the half-angle direction falls, and so the intensity of the highlight falls off to zero.</p>

<p>The specular highlight often reflects the color of the light source, not the color of the reflecting object. This is because many materials have a thin layer of clear material above the surface of the pigmented material. For example plastic is made up of tiny beads of color suspended in a clear polymer and human skin often has a thin layer of oil or sweat above the pigmented cells. Such materials will show specular highlights in which all parts of the color spectrum are reflected equally. On metallic materials such as gold the color of the specular highlight will reflect the color of the material.</p>
<h2 id="models-of-specular-highlight">Models of specular highlight</h2>

<p>A number of different models exist to predict the distribution of microfacets. Most assume that the microfacet normals are distributed evenly around the normal; these models are called <strong><a href="isotropy" title="wikilink">isotropic</a></strong>. If microfacets are distributed with a preference for a certain direction along the surface, the distribution is <strong><a href="Anisotropy" title="wikilink">anisotropic</a></strong>.</p>

<p>NOTE: In most equations, when it says 

<math display="inline" id="Specular_highlight:0">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mover accent="true">
     <mi>A</mi>
     <mo stretchy="false">^</mo>
    </mover>
    <mo>⋅</mo>
    <mover accent="true">
     <mi>B</mi>
     <mo stretchy="false">^</mo>
    </mover>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-⋅</ci>
    <apply>
     <ci>normal-^</ci>
     <ci>A</ci>
    </apply>
    <apply>
     <ci>normal-^</ci>
     <ci>B</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\hat{A}\cdot\hat{B})
  </annotation>
 </semantics>
</math>

 it means 

<math display="inline" id="Specular_highlight:1">
 <semantics>
  <mrow>
   <mi>max</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mover accent="true">
       <mi>A</mi>
       <mo stretchy="false">^</mo>
      </mover>
      <mo>⋅</mo>
      <mover accent="true">
       <mi>B</mi>
       <mo stretchy="false">^</mo>
      </mover>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <max></max>
    <cn type="integer">0</cn>
    <apply>
     <ci>normal-⋅</ci>
     <apply>
      <ci>normal-^</ci>
      <ci>A</ci>
     </apply>
     <apply>
      <ci>normal-^</ci>
      <ci>B</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \max(0,(\hat{A}\cdot\hat{B}))
  </annotation>
 </semantics>
</math>

</p>
<h3 id="phong-distribution">Phong distribution</h3>

<p>In the <a href="Phong_reflection_model" title="wikilink">Phong reflection model</a>, the intensity of the specular highlight is calculated as:</p>

<p>

<math display="block" id="Specular_highlight:2">
 <semantics>
  <mrow>
   <msub>
    <mi>k</mi>
    <mi>spec</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo>∥</mo>
     <mi>R</mi>
     <mo>∥</mo>
    </mrow>
    <mrow>
     <mo>∥</mo>
     <mi>V</mi>
     <mo>∥</mo>
    </mrow>
    <mrow>
     <msup>
      <mi>cos</mi>
      <mi>n</mi>
     </msup>
     <mi>β</mi>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mover accent="true">
       <mi>R</mi>
       <mo stretchy="false">^</mo>
      </mover>
      <mo>⋅</mo>
      <mover accent="true">
       <mi>V</mi>
       <mo stretchy="false">^</mo>
      </mover>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>n</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>k</ci>
      <ci>spec</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="latexml">norm</csymbol>
       <ci>R</ci>
      </apply>
      <apply>
       <csymbol cd="latexml">norm</csymbol>
       <ci>V</ci>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <cos></cos>
        <ci>n</ci>
       </apply>
       <ci>β</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <ci>normal-⋅</ci>
       <apply>
        <ci>normal-^</ci>
        <ci>R</ci>
       </apply>
       <apply>
        <ci>normal-^</ci>
        <ci>V</ci>
       </apply>
      </apply>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k_{\mathrm{spec}}=\|R\|\|V\|\cos^{n}\beta=(\hat{R}\cdot\hat{V})^{n}
  </annotation>
 </semantics>
</math>

</p>

<p>Where <em>R</em> is the mirror reflection of the light vector off the surface, and <em>V</em> is the viewpoint vector.</p>

<p>In the <a href="Blinn–Phong_shading_model" title="wikilink">Blinn–Phong shading model</a>, the intensity of a specular highlight is calculated as:</p>

<p>

<math display="block" id="Specular_highlight:3">
 <semantics>
  <mrow>
   <msub>
    <mi>k</mi>
    <mi>spec</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo>∥</mo>
     <mi>N</mi>
     <mo>∥</mo>
    </mrow>
    <mrow>
     <mo>∥</mo>
     <mi>H</mi>
     <mo>∥</mo>
    </mrow>
    <mrow>
     <msup>
      <mi>cos</mi>
      <mi>n</mi>
     </msup>
     <mi>β</mi>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mover accent="true">
       <mi>N</mi>
       <mo stretchy="false">^</mo>
      </mover>
      <mo>⋅</mo>
      <mover accent="true">
       <mi>H</mi>
       <mo stretchy="false">^</mo>
      </mover>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>n</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>k</ci>
      <ci>spec</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="latexml">norm</csymbol>
       <ci>N</ci>
      </apply>
      <apply>
       <csymbol cd="latexml">norm</csymbol>
       <ci>H</ci>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <cos></cos>
        <ci>n</ci>
       </apply>
       <ci>β</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <ci>normal-⋅</ci>
       <apply>
        <ci>normal-^</ci>
        <ci>N</ci>
       </apply>
       <apply>
        <ci>normal-^</ci>
        <ci>H</ci>
       </apply>
      </apply>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k_{\mathrm{spec}}=\|N\|\|H\|\cos^{n}\beta=(\hat{N}\cdot\hat{H})^{n}
  </annotation>
 </semantics>
</math>

</p>

<p>Where <em>N</em> is the smooth surface normal and <em>H</em> is the half-angle direction (the direction vector midway between <em>L</em>, the vector to the light, and <em>V</em>, the viewpoint vector).</p>

<p>The number <em>n</em> is called the Phong exponent, and is a user-chosen value that controls the apparent smoothness of the surface. These equations imply that the distribution of microfacet normals is an approximately <a href="Gaussian_distribution" title="wikilink">Gaussian distribution</a> (for large 

<math display="inline" id="Specular_highlight:4">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

), or approximately <a href="Pearson_distribution" title="wikilink">Pearson type II distribution</a>, of the corresponding angle.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> While this is a useful <a href="Heuristic#Computer_science" title="wikilink">heuristic</a> and produces believable results, it is not a physically based model.</p>
<dl>
<dd>Another similar formula, but only calculated differently:
</dd>
<dd>

<math display="inline" id="Specular_highlight:5">
 <semantics>
  <mrow>
   <mrow>
    <mi>k</mi>
    <mo>=</mo>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mover accent="true">
        <mi>L</mi>
        <mo stretchy="false">→</mo>
       </mover>
       <mo>⋅</mo>
       <mover accent="true">
        <mi>R</mi>
        <mo stretchy="false">→</mo>
       </mover>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>n</mi>
    </msup>
    <mo>=</mo>
    <msup>
     <mrow>
      <mo stretchy="false">[</mo>
      <mrow>
       <mover accent="true">
        <mi>L</mi>
        <mo stretchy="false">→</mo>
       </mover>
       <mo>⋅</mo>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mover accent="true">
          <mi>E</mi>
          <mo stretchy="false">→</mo>
         </mover>
         <mo>-</mo>
         <mrow>
          <mn>2</mn>
          <mover accent="true">
           <mi>N</mi>
           <mo stretchy="false">→</mo>
          </mover>
          <mrow>
           <mo stretchy="false">(</mo>
           <mrow>
            <mover accent="true">
             <mi>N</mi>
             <mo stretchy="false">→</mo>
            </mover>
            <mo>⋅</mo>
            <mover accent="true">
             <mi>E</mi>
             <mo stretchy="false">→</mo>
            </mover>
           </mrow>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">]</mo>
     </mrow>
     <mi>n</mi>
    </msup>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>k</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <ci>normal-⋅</ci>
       <apply>
        <ci>normal-→</ci>
        <ci>L</ci>
       </apply>
       <apply>
        <ci>normal-→</ci>
        <ci>R</ci>
       </apply>
      </apply>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <ci>normal-⋅</ci>
        <apply>
         <ci>normal-→</ci>
         <ci>L</ci>
        </apply>
        <apply>
         <minus></minus>
         <apply>
          <ci>normal-→</ci>
          <ci>E</ci>
         </apply>
         <apply>
          <times></times>
          <cn type="integer">2</cn>
          <apply>
           <ci>normal-→</ci>
           <ci>N</ci>
          </apply>
          <apply>
           <ci>normal-⋅</ci>
           <apply>
            <ci>normal-→</ci>
            <ci>N</ci>
           </apply>
           <apply>
            <ci>normal-→</ci>
            <ci>E</ci>
           </apply>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k=(\vec{L}\cdot\vec{R})^{n}=[\vec{L}\cdot(\vec{E}-2\vec{N}(\vec{N}\cdot\vec{E}%
))]^{n},
  </annotation>
 </semantics>
</math>


</dd>
<dd>where <strong>R</strong> is an eye reflection vector, <strong>E</strong> is an eye vector (view vector), <strong>N</strong> is surface normal vector. All vectors are normalized (

<math display="inline" id="Specular_highlight:6">
 <semantics>
  <mrow>
   <mrow>
    <mo>∥</mo>
    <mover accent="true">
     <mi>E</mi>
     <mo stretchy="false">→</mo>
    </mover>
    <mo>∥</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>∥</mo>
    <mover accent="true">
     <mi>N</mi>
     <mo stretchy="false">→</mo>
    </mover>
    <mo>∥</mo>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="latexml">norm</csymbol>
      <apply>
       <ci>normal-→</ci>
       <ci>E</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">norm</csymbol>
      <apply>
       <ci>normal-→</ci>
       <ci>N</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \|\vec{E}\|=\|\vec{N}\|=1
  </annotation>
 </semantics>
</math>

). <strong>L</strong> is a light vector. For example, 

<math display="inline" id="Specular_highlight:7">
 <semantics>
  <mrow>
   <mrow>
    <mover accent="true">
     <mi>N</mi>
     <mo stretchy="false">→</mo>
    </mover>
    <mo>=</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mn>0</mn>
     <mo>;</mo>
     <mn>1</mn>
     <mo>;</mo>
     <mn>0</mn>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
   <mo rspace="8.1pt">;</mo>
   <mrow>
    <mrow>
     <mover accent="true">
      <mi>E</mi>
      <mo stretchy="false">→</mo>
     </mover>
     <mo>=</mo>
     <mrow>
      <mo stretchy="false">{</mo>
      <mfrac>
       <msqrt>
        <mn>3</mn>
       </msqrt>
       <mn>2</mn>
      </mfrac>
      <mo rspace="5.3pt">;</mo>
      <mfrac>
       <mn>1</mn>
       <mn>2</mn>
      </mfrac>
      <mo>;</mo>
      <mn>0</mn>
      <mo stretchy="false">}</mo>
     </mrow>
    </mrow>
    <mo rspace="8.1pt">;</mo>
    <mrow>
     <mrow>
      <mover accent="true">
       <mi>L</mi>
       <mo stretchy="false">→</mo>
      </mover>
      <mo>=</mo>
      <mrow>
       <mo stretchy="false">{</mo>
       <mrow>
        <mo>-</mo>
        <mn>0.6</mn>
       </mrow>
       <mo>;</mo>
       <mn>0.8</mn>
       <mo>;</mo>
       <mn>0</mn>
       <mo stretchy="false">}</mo>
      </mrow>
     </mrow>
     <mo rspace="8.1pt">;</mo>
     <mrow>
      <mi>n</mi>
      <mo>=</mo>
      <mn>3</mn>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <ci>normal-→</ci>
      <ci>N</ci>
     </apply>
     <list>
      <cn type="integer">0</cn>
      <cn type="float">1</cn>
      <cn type="float">0</cn>
     </list>
    </apply>
    <apply>
     <csymbol cd="ambiguous">formulae-sequence</csymbol>
     <apply>
      <eq></eq>
      <apply>
       <ci>normal-→</ci>
       <ci>E</ci>
      </apply>
      <list>
       <apply>
        <divide></divide>
        <apply>
         <root></root>
         <cn type="integer">3</cn>
        </apply>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <cn type="integer">2</cn>
       </apply>
       <cn type="float">0</cn>
      </list>
     </apply>
     <apply>
      <csymbol cd="ambiguous">formulae-sequence</csymbol>
      <apply>
       <eq></eq>
       <apply>
        <ci>normal-→</ci>
        <ci>L</ci>
       </apply>
       <list>
        <apply>
         <minus></minus>
         <cn type="float">0.6</cn>
        </apply>
        <cn type="float">0.8</cn>
        <cn type="float">0</cn>
       </list>
      </apply>
      <apply>
       <eq></eq>
       <ci>n</ci>
       <cn type="integer">3</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vec{N}=\{0;\;1;\;0\};\;\;\vec{E}=\{\frac{\sqrt{3}}{2};\;\frac{1}{2};\;0\};\;%
\;\vec{L}=\{-0.6;\;0.8;\;0\};\;\;n=3
  </annotation>
 </semantics>
</math>

 then:
</dd>
<dd>

<math display="inline" id="Specular_highlight:8">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>=</mo>
   <msup>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mover accent="true">
       <mi>L</mi>
       <mo stretchy="false">→</mo>
      </mover>
      <mo>⋅</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mover accent="true">
         <mi>E</mi>
         <mo stretchy="false">→</mo>
        </mover>
        <mo>-</mo>
        <mrow>
         <mn>2</mn>
         <mover accent="true">
          <mi>N</mi>
          <mo stretchy="false">→</mo>
         </mover>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <mover accent="true">
            <mi>N</mi>
            <mo stretchy="false">→</mo>
           </mover>
           <mo>⋅</mo>
           <mover accent="true">
            <mi>E</mi>
            <mo stretchy="false">→</mo>
           </mover>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
    <mi>n</mi>
   </msup>
   <mo>=</mo>
   <msup>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mover accent="true">
       <mi>L</mi>
       <mo stretchy="false">→</mo>
      </mover>
      <mo>⋅</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mover accent="true">
         <mi>E</mi>
         <mo stretchy="false">→</mo>
        </mover>
        <mo>-</mo>
        <mrow>
         <mn>2</mn>
         <mover accent="true">
          <mi>N</mi>
          <mo stretchy="false">→</mo>
         </mover>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <mrow>
            <mn>0</mn>
            <mo>⋅</mo>
            <mfrac>
             <msqrt>
              <mn>3</mn>
             </msqrt>
             <mn>2</mn>
            </mfrac>
           </mrow>
           <mo>+</mo>
           <mrow>
            <mn>1</mn>
            <mo>⋅</mo>
            <mn>0.5</mn>
           </mrow>
           <mo>+</mo>
           <mrow>
            <mn>0</mn>
            <mo>⋅</mo>
            <mn>0</mn>
           </mrow>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
    <mn>3</mn>
   </msup>
   <mo>=</mo>
   <mi></mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>k</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <ci>normal-⋅</ci>
        <apply>
         <ci>normal-→</ci>
         <ci>L</ci>
        </apply>
        <apply>
         <minus></minus>
         <apply>
          <ci>normal-→</ci>
          <ci>E</ci>
         </apply>
         <apply>
          <times></times>
          <cn type="integer">2</cn>
          <apply>
           <ci>normal-→</ci>
           <ci>N</ci>
          </apply>
          <apply>
           <ci>normal-⋅</ci>
           <apply>
            <ci>normal-→</ci>
            <ci>N</ci>
           </apply>
           <apply>
            <ci>normal-→</ci>
            <ci>E</ci>
           </apply>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <ci>normal-⋅</ci>
        <apply>
         <ci>normal-→</ci>
         <ci>L</ci>
        </apply>
        <apply>
         <minus></minus>
         <apply>
          <ci>normal-→</ci>
          <ci>E</ci>
         </apply>
         <apply>
          <times></times>
          <cn type="integer">2</cn>
          <apply>
           <ci>normal-→</ci>
           <ci>N</ci>
          </apply>
          <apply>
           <plus></plus>
           <apply>
            <ci>normal-⋅</ci>
            <cn type="integer">0</cn>
            <apply>
             <divide></divide>
             <apply>
              <root></root>
              <cn type="integer">3</cn>
             </apply>
             <cn type="integer">2</cn>
            </apply>
           </apply>
           <apply>
            <ci>normal-⋅</ci>
            <cn type="integer">1</cn>
            <cn type="float">0.5</cn>
           </apply>
           <apply>
            <ci>normal-⋅</ci>
            <cn type="integer">0</cn>
            <cn type="integer">0</cn>
           </apply>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
      <cn type="integer">3</cn>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <csymbol cd="latexml">absent</csymbol>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k=[\vec{L}\cdot(\vec{E}-2\vec{N}(\vec{N}\cdot\vec{E}))]^{n}=[\vec{L}\cdot(\vec%
{E}-2\vec{N}(0\cdot\frac{\sqrt{3}}{2}+1\cdot 0.5+0\cdot 0))]^{3}=
  </annotation>
 </semantics>
</math>


</dd>
<dd>

<math display="inline" id="Specular_highlight:9">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>=</mo>
   <msup>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mover accent="true">
       <mi>L</mi>
       <mo stretchy="false">→</mo>
      </mover>
      <mo>⋅</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mover accent="true">
         <mi>E</mi>
         <mo stretchy="false">→</mo>
        </mover>
        <mo>-</mo>
        <mover accent="true">
         <mi>N</mi>
         <mo stretchy="false">→</mo>
        </mover>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
    <mn>3</mn>
   </msup>
   <mo>=</mo>
   <msup>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mover accent="true">
       <mi>L</mi>
       <mo stretchy="false">→</mo>
      </mover>
      <mo>⋅</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mo stretchy="false">{</mo>
        <mrow>
         <mfrac>
          <msqrt>
           <mn>3</mn>
          </msqrt>
          <mn>2</mn>
         </mfrac>
         <mo>-</mo>
         <mn>0</mn>
        </mrow>
        <mo rspace="5.3pt">;</mo>
        <mrow>
         <mfrac>
          <mn>1</mn>
          <mn>2</mn>
         </mfrac>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
        <mo>;</mo>
        <mrow>
         <mn>0</mn>
         <mo>-</mo>
         <mn>0</mn>
        </mrow>
        <mo stretchy="false">}</mo>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
    <mn>3</mn>
   </msup>
   <mo>=</mo>
   <msup>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mrow>
       <mo>-</mo>
       <mrow>
        <mn>0.6</mn>
        <mo>⋅</mo>
        <mfrac>
         <msqrt>
          <mn>3</mn>
         </msqrt>
         <mn>2</mn>
        </mfrac>
       </mrow>
      </mrow>
      <mo>+</mo>
      <mrow>
       <mn>0.8</mn>
       <mo>⋅</mo>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mo>-</mo>
         <mn>0.5</mn>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>+</mo>
      <mrow>
       <mn>0</mn>
       <mo>⋅</mo>
       <mn>0</mn>
      </mrow>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
    <mn>3</mn>
   </msup>
   <mo>=</mo>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mo>-</mo>
       <mn>0.5196</mn>
      </mrow>
      <mo>-</mo>
      <mn>0.4</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mn>3</mn>
   </msup>
   <mo>=</mo>
   <msup>
    <mn>0.9196</mn>
    <mn>3</mn>
   </msup>
   <mo>=</mo>
   <mn>0.7777.</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <csymbol cd="latexml">absent</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <ci>normal-⋅</ci>
        <apply>
         <ci>normal-→</ci>
         <ci>L</ci>
        </apply>
        <apply>
         <minus></minus>
         <apply>
          <ci>normal-→</ci>
          <ci>E</ci>
         </apply>
         <apply>
          <ci>normal-→</ci>
          <ci>N</ci>
         </apply>
        </apply>
       </apply>
      </apply>
      <cn type="integer">3</cn>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <ci>normal-⋅</ci>
        <apply>
         <ci>normal-→</ci>
         <ci>L</ci>
        </apply>
        <list>
         <apply>
          <minus></minus>
          <apply>
           <divide></divide>
           <apply>
            <root></root>
            <cn type="integer">3</cn>
           </apply>
           <cn type="integer">2</cn>
          </apply>
          <cn type="integer">0</cn>
         </apply>
         <apply>
          <minus></minus>
          <apply>
           <divide></divide>
           <cn type="integer">1</cn>
           <cn type="integer">2</cn>
          </apply>
          <cn type="integer">1</cn>
         </apply>
         <apply>
          <minus></minus>
          <cn type="float">0</cn>
          <cn type="integer">0</cn>
         </apply>
        </list>
       </apply>
      </apply>
      <cn type="integer">3</cn>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <plus></plus>
        <apply>
         <minus></minus>
         <apply>
          <ci>normal-⋅</ci>
          <cn type="float">0.6</cn>
          <apply>
           <divide></divide>
           <apply>
            <root></root>
            <cn type="integer">3</cn>
           </apply>
           <cn type="integer">2</cn>
          </apply>
         </apply>
        </apply>
        <apply>
         <ci>normal-⋅</ci>
         <cn type="float">0.8</cn>
         <apply>
          <minus></minus>
          <cn type="float">0.5</cn>
         </apply>
        </apply>
        <apply>
         <ci>normal-⋅</ci>
         <cn type="integer">0</cn>
         <cn type="integer">0</cn>
        </apply>
       </apply>
      </apply>
      <cn type="integer">3</cn>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <minus></minus>
       <apply>
        <minus></minus>
        <cn type="float">0.5196</cn>
       </apply>
       <cn type="float">0.4</cn>
      </apply>
      <cn type="integer">3</cn>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="float">0.9196</cn>
      <cn type="integer">3</cn>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="float">0.7777.</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =[\vec{L}\cdot(\vec{E}-\vec{N})]^{3}=[\vec{L}\cdot(\{\frac{\sqrt{3}}{2}-0;\;%
\frac{1}{2}-1;\;0-0\})]^{3}=[-0.6\cdot\frac{\sqrt{3}}{2}+0.8\cdot(-0.5)+0\cdot
0%
]^{3}=(-0.5196-0.4)^{3}=0.9196^{3}=0.7777.
  </annotation>
 </semantics>
</math>


</dd>
<dd>Approximate formula is this:
</dd>
<dd>

<math display="inline" id="Specular_highlight:10">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>=</mo>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mover accent="true">
       <mi>N</mi>
       <mo stretchy="false">→</mo>
      </mover>
      <mo>⋅</mo>
      <mover accent="true">
       <mi>H</mi>
       <mo stretchy="false">→</mo>
      </mover>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>n</mi>
   </msup>
   <mo>=</mo>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mover accent="true">
       <mi>N</mi>
       <mo stretchy="false">→</mo>
      </mover>
      <mo>⋅</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mover accent="true">
           <mi>L</mi>
           <mo stretchy="false">→</mo>
          </mover>
          <mo>+</mo>
          <mover accent="true">
           <mi>E</mi>
           <mo stretchy="false">→</mo>
          </mover>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
        <mo>/</mo>
        <mn>2</mn>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>n</mi>
   </msup>
   <mo>=</mo>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mover accent="true">
       <mi>N</mi>
       <mo stretchy="false">→</mo>
      </mover>
      <mo>⋅</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mo stretchy="false">{</mo>
          <mrow>
           <mrow>
            <mo>-</mo>
            <mn>0.6</mn>
           </mrow>
           <mo>+</mo>
           <mfrac>
            <msqrt>
             <mn>3</mn>
            </msqrt>
            <mn>2</mn>
           </mfrac>
          </mrow>
          <mo>;</mo>
          <mrow>
           <mn>0.8</mn>
           <mo>+</mo>
           <mn>0.5</mn>
          </mrow>
          <mo>;</mo>
          <mrow>
           <mn>0</mn>
           <mo>+</mo>
           <mn>0</mn>
          </mrow>
          <mo stretchy="false">}</mo>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
        <mo>/</mo>
        <mn>2</mn>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mn>3</mn>
   </msup>
   <mo>=</mo>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mover accent="true">
       <mi>N</mi>
       <mo stretchy="false">→</mo>
      </mover>
      <mo>⋅</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mo stretchy="false">{</mo>
          <mn>0.266</mn>
          <mo>;</mo>
          <mn>1.3</mn>
          <mo>;</mo>
          <mn>0</mn>
          <mo stretchy="false">}</mo>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
        <mo>/</mo>
        <mn>2</mn>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mn>3</mn>
   </msup>
   <mo>=</mo>
   <mi></mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>k</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <ci>normal-⋅</ci>
       <apply>
        <ci>normal-→</ci>
        <ci>N</ci>
       </apply>
       <apply>
        <ci>normal-→</ci>
        <ci>H</ci>
       </apply>
      </apply>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <ci>normal-⋅</ci>
       <apply>
        <ci>normal-→</ci>
        <ci>N</ci>
       </apply>
       <apply>
        <divide></divide>
        <apply>
         <plus></plus>
         <apply>
          <ci>normal-→</ci>
          <ci>L</ci>
         </apply>
         <apply>
          <ci>normal-→</ci>
          <ci>E</ci>
         </apply>
        </apply>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <ci>normal-⋅</ci>
       <apply>
        <ci>normal-→</ci>
        <ci>N</ci>
       </apply>
       <apply>
        <divide></divide>
        <list>
         <apply>
          <plus></plus>
          <apply>
           <minus></minus>
           <cn type="float">0.6</cn>
          </apply>
          <apply>
           <divide></divide>
           <apply>
            <root></root>
            <cn type="integer">3</cn>
           </apply>
           <cn type="integer">2</cn>
          </apply>
         </apply>
         <apply>
          <plus></plus>
          <cn type="float">0.8</cn>
          <cn type="float">0.5</cn>
         </apply>
         <apply>
          <plus></plus>
          <cn type="float">0</cn>
          <cn type="integer">0</cn>
         </apply>
        </list>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <cn type="integer">3</cn>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <ci>normal-⋅</ci>
       <apply>
        <ci>normal-→</ci>
        <ci>N</ci>
       </apply>
       <apply>
        <divide></divide>
        <list>
         <cn type="float">0.266</cn>
         <cn type="float">1.3</cn>
         <cn type="float">0</cn>
        </list>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <cn type="integer">3</cn>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <csymbol cd="latexml">absent</csymbol>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k=(\vec{N}\cdot\vec{H})^{n}=(\vec{N}\cdot((\vec{L}+\vec{E})/2))^{n}=(\vec{N}%
\cdot((\{-0.6+\frac{\sqrt{3}}{2};\;0.8+0.5;\;0+0\})/2))^{3}=(\vec{N}\cdot((\{0%
.266;\;1.3;\;0\})/2))^{3}=
  </annotation>
 </semantics>
</math>


</dd>
<dd>

<math display="inline" id="Specular_highlight:11">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>=</mo>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mover accent="true">
       <mi>N</mi>
       <mo stretchy="false">→</mo>
      </mover>
      <mo>⋅</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mo stretchy="false">{</mo>
        <mn>0.133</mn>
        <mo>;</mo>
        <mn>0.65</mn>
        <mo>;</mo>
        <mn>0</mn>
        <mo stretchy="false">}</mo>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mn>3</mn>
   </msup>
   <mo>=</mo>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mn>0</mn>
       <mo>⋅</mo>
       <mn>0.133</mn>
      </mrow>
      <mo>+</mo>
      <mrow>
       <mn>1</mn>
       <mo>⋅</mo>
       <mn>0.65</mn>
      </mrow>
      <mo>+</mo>
      <mn>0</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mn>3</mn>
   </msup>
   <mo>=</mo>
   <msup>
    <mn>0.65</mn>
    <mn>3</mn>
   </msup>
   <mo>=</mo>
   <mn>0.274625.</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <csymbol cd="latexml">absent</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <ci>normal-⋅</ci>
       <apply>
        <ci>normal-→</ci>
        <ci>N</ci>
       </apply>
       <list>
        <cn type="float">0.133</cn>
        <cn type="float">0.65</cn>
        <cn type="float">0</cn>
       </list>
      </apply>
      <cn type="integer">3</cn>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <plus></plus>
       <apply>
        <ci>normal-⋅</ci>
        <cn type="integer">0</cn>
        <cn type="float">0.133</cn>
       </apply>
       <apply>
        <ci>normal-⋅</ci>
        <cn type="integer">1</cn>
        <cn type="float">0.65</cn>
       </apply>
       <cn type="integer">0</cn>
      </apply>
      <cn type="integer">3</cn>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="float">0.65</cn>
      <cn type="integer">3</cn>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="float">0.274625.</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =(\vec{N}\cdot(\{0.133;\;0.65;\;0\}))^{3}=(0\cdot 0.133+1\cdot 0.65+0)^{3}=0.6%
5^{3}=0.274625.
  </annotation>
 </semantics>
</math>


</dd>
<dd>If vector <strong>H</strong> is normalized 

<math display="inline" id="Specular_highlight:12">
 <semantics>
  <mrow>
   <mrow>
    <mfrac>
     <mrow>
      <mover accent="true">
       <mi>H</mi>
       <mo stretchy="false">→</mo>
      </mover>
      <mrow>
       <mo stretchy="false">{</mo>
       <mn>0.133</mn>
       <mo>;</mo>
       <mn>0.65</mn>
       <mo>;</mo>
       <mn>0</mn>
       <mo stretchy="false">}</mo>
      </mrow>
     </mrow>
     <mrow>
      <mo>∥</mo>
      <mover accent="true">
       <mi>H</mi>
       <mo stretchy="false">→</mo>
      </mover>
      <mo>∥</mo>
     </mrow>
    </mfrac>
    <mo>=</mo>
    <mfrac>
     <mrow>
      <mover accent="true">
       <mi>H</mi>
       <mo stretchy="false">→</mo>
      </mover>
      <mrow>
       <mo stretchy="false">{</mo>
       <mn>0.133</mn>
       <mo>;</mo>
       <mn>0.65</mn>
       <mo>;</mo>
       <mn>0</mn>
       <mo stretchy="false">}</mo>
      </mrow>
     </mrow>
     <msqrt>
      <mrow>
       <msup>
        <mn>0.133</mn>
        <mn>2</mn>
       </msup>
       <mo>+</mo>
       <msup>
        <mn>0.65</mn>
        <mn>2</mn>
       </msup>
      </mrow>
     </msqrt>
    </mfrac>
    <mo>=</mo>
    <mfrac>
     <mrow>
      <mover accent="true">
       <mi>H</mi>
       <mo stretchy="false">→</mo>
      </mover>
      <mrow>
       <mo stretchy="false">{</mo>
       <mn>0.133</mn>
       <mo>;</mo>
       <mn>0.65</mn>
       <mo>;</mo>
       <mn>0</mn>
       <mo stretchy="false">}</mo>
      </mrow>
     </mrow>
     <mn>0.668</mn>
    </mfrac>
    <mo>=</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mn>0.20048</mn>
     <mo>;</mo>
     <mn>0.979701</mn>
     <mo>;</mo>
     <mn>0</mn>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <apply>
        <ci>normal-→</ci>
        <ci>H</ci>
       </apply>
       <list>
        <cn type="float">0.133</cn>
        <cn type="float">0.65</cn>
        <cn type="float">0</cn>
       </list>
      </apply>
      <apply>
       <csymbol cd="latexml">norm</csymbol>
       <apply>
        <ci>normal-→</ci>
        <ci>H</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <apply>
        <ci>normal-→</ci>
        <ci>H</ci>
       </apply>
       <list>
        <cn type="float">0.133</cn>
        <cn type="float">0.65</cn>
        <cn type="float">0</cn>
       </list>
      </apply>
      <apply>
       <root></root>
       <apply>
        <plus></plus>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <cn type="float">0.133</cn>
         <cn type="integer">2</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <cn type="float">0.65</cn>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <apply>
        <ci>normal-→</ci>
        <ci>H</ci>
       </apply>
       <list>
        <cn type="float">0.133</cn>
        <cn type="float">0.65</cn>
        <cn type="float">0</cn>
       </list>
      </apply>
      <cn type="float">0.668</cn>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <list>
      <cn type="float">0.20048</cn>
      <cn type="float">0.979701</cn>
      <cn type="integer">0</cn>
     </list>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{\vec{H}\{0.133;\;0.65;\;0\}}{\|\vec{H}\|}=\frac{\vec{H}\{0.133;\;0.65;\;%
0\}}{\sqrt{0.133^{2}+0.65^{2}}}=\frac{\vec{H}\{0.133;\;0.65;\;0\}}{0.668}=\{0.%
20048;0.979701;0\},
  </annotation>
 </semantics>
</math>

 then
</dd>
<dd>

<math display="inline" id="Specular_highlight:13">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>=</mo>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mover accent="true">
       <mi>N</mi>
       <mo stretchy="false">→</mo>
      </mover>
      <mo>⋅</mo>
      <mover accent="true">
       <mi>H</mi>
       <mo stretchy="false">→</mo>
      </mover>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>n</mi>
   </msup>
   <mo>=</mo>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mn>0</mn>
       <mo>⋅</mo>
       <mn>0.2</mn>
      </mrow>
      <mo>+</mo>
      <mrow>
       <mn>1</mn>
       <mo>⋅</mo>
       <mn>0.9797</mn>
      </mrow>
      <mo>+</mo>
      <mrow>
       <mn>0</mn>
       <mo>⋅</mo>
       <mn>0</mn>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mn>3</mn>
   </msup>
   <mo>=</mo>
   <msup>
    <mn>0.979701</mn>
    <mn>3</mn>
   </msup>
   <mo>=</mo>
   <mn>0.940332.</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>k</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <ci>normal-⋅</ci>
       <apply>
        <ci>normal-→</ci>
        <ci>N</ci>
       </apply>
       <apply>
        <ci>normal-→</ci>
        <ci>H</ci>
       </apply>
      </apply>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <plus></plus>
       <apply>
        <ci>normal-⋅</ci>
        <cn type="integer">0</cn>
        <cn type="float">0.2</cn>
       </apply>
       <apply>
        <ci>normal-⋅</ci>
        <cn type="integer">1</cn>
        <cn type="float">0.9797</cn>
       </apply>
       <apply>
        <ci>normal-⋅</ci>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <cn type="integer">3</cn>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="float">0.979701</cn>
      <cn type="integer">3</cn>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="float">0.940332.</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k=(\vec{N}\cdot\vec{H})^{n}=(0\cdot 0.2+1\cdot 0.9797+0\cdot 0)^{3}=0.979701^{%
3}=0.940332.
  </annotation>
 </semantics>
</math>


</dd>
</dl>
<h3 id="gaussian-distribution">Gaussian distribution</h3>

<p>A slightly better model of microfacet distribution can be created using a <a href="Gaussian_distribution" title="wikilink">Gaussian distribution</a>. The usual function calculates specular highlight intensity as:</p>

<p>

<math display="block" id="Specular_highlight:14">
 <semantics>
  <mrow>
   <msub>
    <mi>k</mi>
    <mi>spec</mi>
   </msub>
   <mo>=</mo>
   <msup>
    <mi>e</mi>
    <mrow>
     <mo>-</mo>
     <msup>
      <mrow>
       <mo>(</mo>
       <mfrac>
        <mrow>
         <mi mathvariant="normal">∠</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>N</mi>
          <mo>,</mo>
          <mi>H</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mi>m</mi>
       </mfrac>
       <mo>)</mo>
      </mrow>
      <mn>2</mn>
     </msup>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>k</ci>
     <ci>spec</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>e</ci>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <divide></divide>
        <apply>
         <times></times>
         <ci>normal-∠</ci>
         <interval closure="open">
          <ci>N</ci>
          <ci>H</ci>
         </interval>
        </apply>
        <ci>m</ci>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k_{\mathrm{spec}}=e^{-\left(\frac{\angle(N,H)}{m}\right)^{2}}
  </annotation>
 </semantics>
</math>

</p>

<p>where <em>m</em> is a constant between 0 and 1 that controls the apparent smoothness of the surface.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>
<h3 id="beckmann-distribution">Beckmann distribution</h3>

<p>A physically based model of microfacet distribution is the Beckmann distribution:<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>

<p>

<math display="block" id="Specular_highlight:15">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>k</mi>
     <mi>spec</mi>
    </msub>
    <mo>=</mo>
    <mfrac>
     <mrow>
      <mi>exp</mi>
      <mrow>
       <mo>(</mo>
       <mrow>
        <mo>-</mo>
        <mrow>
         <mrow>
          <msup>
           <mi>tan</mi>
           <mn>2</mn>
          </msup>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>α</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo>/</mo>
         <msup>
          <mi>m</mi>
          <mn>2</mn>
         </msup>
        </mrow>
       </mrow>
       <mo>)</mo>
      </mrow>
     </mrow>
     <mrow>
      <mi>π</mi>
      <msup>
       <mi>m</mi>
       <mn>2</mn>
      </msup>
      <mrow>
       <msup>
        <mi>cos</mi>
        <mn>4</mn>
       </msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>α</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </mfrac>
   </mrow>
   <mo rspace="5.8pt">,</mo>
   <mrow>
    <mi>α</mi>
    <mo>=</mo>
    <mrow>
     <mi>arccos</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>N</mi>
       <mo>⋅</mo>
       <mi>H</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>k</ci>
      <ci>spec</ci>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <exp></exp>
       <apply>
        <minus></minus>
        <apply>
         <divide></divide>
         <apply>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <tan></tan>
           <cn type="integer">2</cn>
          </apply>
          <ci>α</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>m</ci>
          <cn type="integer">2</cn>
         </apply>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>π</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>m</ci>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <cos></cos>
         <cn type="integer">4</cn>
        </apply>
        <ci>α</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <ci>α</ci>
     <apply>
      <arccos></arccos>
      <apply>
       <ci>normal-⋅</ci>
       <ci>N</ci>
       <ci>H</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k_{\mathrm{spec}}=\frac{\exp{\left(-\tan^{2}(\alpha)/m^{2}\right)}}{\pi m^{2}%
\cos^{4}(\alpha)},~{}\alpha=\arccos(N\cdot H)
  </annotation>
 </semantics>
</math>

</p>

<p>where <em>m</em> is the <a href="Root_mean_square" title="wikilink">rms</a> slope of the surface microfacets (the roughness of the material).<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> Compared to the empirical models above, this function "gives the absolute magnitude of the reflectance without introducing arbitrary constants; the disadvantage is that it requires more computation".<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> However, this model can be simplified since 

<math display="inline" id="Specular_highlight:16">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msup>
      <mi>tan</mi>
      <mn>2</mn>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>α</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>/</mo>
    <msup>
     <mi>m</mi>
     <mn>2</mn>
    </msup>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mn>1</mn>
     <mo>-</mo>
     <mrow>
      <msup>
       <mi>cos</mi>
       <mn>2</mn>
      </msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>α</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mrow>
     <mrow>
      <msup>
       <mi>cos</mi>
       <mn>2</mn>
      </msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>α</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <msup>
      <mi>m</mi>
      <mn>2</mn>
     </msup>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <divide></divide>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <tan></tan>
       <cn type="integer">2</cn>
      </apply>
      <ci>α</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>m</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <cos></cos>
        <cn type="integer">2</cn>
       </apply>
       <ci>α</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <cos></cos>
        <cn type="integer">2</cn>
       </apply>
       <ci>α</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>m</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tan^{2}(\alpha)/m^{2}=\frac{1-\cos^{2}(\alpha)}{\cos^{2}(\alpha)m^{2}}
  </annotation>
 </semantics>
</math>

. Also note that the product of 

<math display="inline" id="Specular_highlight:17">
 <semantics>
  <mrow>
   <mi>cos</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>α</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <cos></cos>
    <ci>α</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \cos(\alpha)
  </annotation>
 </semantics>
</math>

 and a surface distribution function is normalized over the half-sphere which is obeyed by this function.</p>
<h3 id="heidrichseidel-anisotropic-distribution">Heidrich–Seidel anisotropic distribution</h3>

<p>The Heidrich–Seidel.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> distribution is a simple anisotropic distribution, based on the Phong model. It can be used to model surfaces that have small parallel grooves or fibers, such as <a href="brushed_metal" title="wikilink">brushed metal</a>, satin, and hair.</p>
<h4 id="parameters">Parameters</h4>

<p>Input parameters:</p>

<p><em><code>D</code></em><code> - Thread direction ( In original papers this appear as </code><em><code>T</code></em><code> )</code><br/>
<code> </code><em><code>s</code></em><code> - Shininess exponent. Values ere between 0 and infinity </code><br/>
<code> </code><em><code>N</code></em><code> - real surface normal</code><br/>
<code> </code><em><code>L</code></em><code> - vector from point to light</code><br/>
<code> </code><em><code>V</code></em><code> - Vector from point to viewer</code><br/>
<code> </code><em><code>T</code></em><code> - Thread direction based on real surface normal.</code><br/>
<code> </code><em><code>P</code></em><code> - Projection of vector L on to plane with normal T ( in original paper this appear as </code><em><code>N</code></em><code> ).</code><br/>
<code> </code><em><code>R</code></em><code> - Reflected incoming light ray against </code><em><code>T</code></em><code>. Incoming light ray is equal to negative </code><em><code>L</code></em><code>.</code></p>

<p>All vectors are unit.</p>
<h4 id="conditions">Conditions</h4>

<p>If some of the conditions are not satisfied from the list color is zero</p>
<ul>
<li>

<math display="inline" id="Specular_highlight:18">
 <semantics>
  <mrow>
   <mn>0</mn>
   <mo><</mo>
   <mrow>
    <mi>N</mi>
    <mo>⋅</mo>
    <mi>V</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <cn type="integer">0</cn>
    <apply>
     <ci>normal-⋅</ci>
     <ci>N</ci>
     <ci>V</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0<N\cdot V
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="Specular_highlight:19">
 <semantics>
  <mrow>
   <mn>0</mn>
   <mo><</mo>
   <mrow>
    <mi>P</mi>
    <mo>⋅</mo>
    <mi>V</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <cn type="integer">0</cn>
    <apply>
     <ci>normal-⋅</ci>
     <ci>P</ci>
     <ci>V</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0<P\cdot V
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="Specular_highlight:20">
 <semantics>
  <mrow>
   <mn>0</mn>
   <mo><</mo>
   <mrow>
    <mi>R</mi>
    <mo>⋅</mo>
    <mi>V</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <cn type="integer">0</cn>
    <apply>
     <ci>normal-⋅</ci>
     <ci>R</ci>
     <ci>V</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0<R\cdot V
  </annotation>
 </semantics>
</math>

</li>
</ul>

<p>Note: Thins list is not optimized.</p>
<h4 id="formula">Formula</h4>

<p>First we need to correct original direction of fiber <em>D</em> to be perpendicular to real surface normal <em>N</em>. This can be done by projection fiber direction on to plane with normal <em>N</em>:</p>

<p>

<math display="block" id="Specular_highlight:21">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mi>D</mi>
     <mo>+</mo>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mo>-</mo>
        <mrow>
         <mi>D</mi>
         <mo>⋅</mo>
         <mi>N</mi>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>*</mo>
      <mi>N</mi>
     </mrow>
    </mrow>
    <mrow>
     <mo>∥</mo>
     <mrow>
      <mi>D</mi>
      <mo>+</mo>
      <mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mo>-</mo>
         <mrow>
          <mi>D</mi>
          <mo>⋅</mo>
          <mi>T</mi>
         </mrow>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mo>*</mo>
       <mi>N</mi>
      </mrow>
     </mrow>
     <mo>∥</mo>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>T</ci>
    <apply>
     <divide></divide>
     <apply>
      <plus></plus>
      <ci>D</ci>
      <apply>
       <times></times>
       <apply>
        <minus></minus>
        <apply>
         <ci>normal-⋅</ci>
         <ci>D</ci>
         <ci>N</ci>
        </apply>
       </apply>
       <ci>N</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">norm</csymbol>
      <apply>
       <plus></plus>
       <ci>D</ci>
       <apply>
        <times></times>
        <apply>
         <minus></minus>
         <apply>
          <ci>normal-⋅</ci>
          <ci>D</ci>
          <ci>T</ci>
         </apply>
        </apply>
        <ci>N</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T=\frac{D+(-D\cdot N)*N}{\|D+(-D\cdot T)*N\|}
  </annotation>
 </semantics>
</math>

</p>

<p>It is expected that fiber is cylindrical. Note the fact that normal of fiber depends of light position. Normal of fiber at given point is:</p>

<p>

<math display="block" id="Specular_highlight:22">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mi>L</mi>
     <mo>+</mo>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mo>-</mo>
        <mrow>
         <mi>L</mi>
         <mo>⋅</mo>
         <mi>T</mi>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>*</mo>
      <mi>T</mi>
     </mrow>
    </mrow>
    <mrow>
     <mo>∥</mo>
     <mrow>
      <mi>L</mi>
      <mo>+</mo>
      <mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mo>-</mo>
         <mrow>
          <mi>L</mi>
          <mo>⋅</mo>
          <mi>T</mi>
         </mrow>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mo>*</mo>
       <mi>T</mi>
      </mrow>
     </mrow>
     <mo>∥</mo>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>P</ci>
    <apply>
     <divide></divide>
     <apply>
      <plus></plus>
      <ci>L</ci>
      <apply>
       <times></times>
       <apply>
        <minus></minus>
        <apply>
         <ci>normal-⋅</ci>
         <ci>L</ci>
         <ci>T</ci>
        </apply>
       </apply>
       <ci>T</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">norm</csymbol>
      <apply>
       <plus></plus>
       <ci>L</ci>
       <apply>
        <times></times>
        <apply>
         <minus></minus>
         <apply>
          <ci>normal-⋅</ci>
          <ci>L</ci>
          <ci>T</ci>
         </apply>
        </apply>
        <ci>T</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P=\frac{L+(-L\cdot T)*T}{\|L+(-L\cdot T)*T\|}
  </annotation>
 </semantics>
</math>

</p>

<p>Reflected ray needed for specular calculation:</p>

<p>

<math display="block" id="Specular_highlight:23">
 <semantics>
  <mrow>
   <mi>R</mi>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mrow>
      <mo>-</mo>
      <mi>L</mi>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mn>2</mn>
      <mo>*</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>L</mi>
        <mo>⋅</mo>
        <mi>T</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>*</mo>
      <mi>T</mi>
     </mrow>
    </mrow>
    <mrow>
     <mo>∥</mo>
     <mrow>
      <mrow>
       <mo>-</mo>
       <mi>L</mi>
      </mrow>
      <mo>+</mo>
      <mrow>
       <mn>2</mn>
       <mo>*</mo>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>L</mi>
         <mo>⋅</mo>
         <mi>T</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mo>*</mo>
       <mi>T</mi>
      </mrow>
     </mrow>
     <mo>∥</mo>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>R</ci>
    <apply>
     <divide></divide>
     <apply>
      <plus></plus>
      <apply>
       <minus></minus>
       <ci>L</ci>
      </apply>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <apply>
        <ci>normal-⋅</ci>
        <ci>L</ci>
        <ci>T</ci>
       </apply>
       <ci>T</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">norm</csymbol>
      <apply>
       <plus></plus>
       <apply>
        <minus></minus>
        <ci>L</ci>
       </apply>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <apply>
         <ci>normal-⋅</ci>
         <ci>L</ci>
         <ci>T</ci>
        </apply>
        <ci>T</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R=\frac{-L+2*(L\cdot T)*T}{\|-L+2*(L\cdot T)*T\|}
  </annotation>
 </semantics>
</math>

</p>
<h5 id="final-calculation">Final calculation</h5>

<p>

<math display="block" id="Specular_highlight:24">
 <semantics>
  <mrow>
   <msub>
    <mi>k</mi>
    <mi>diff</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mi>L</mi>
    <mo>⋅</mo>
    <mi>P</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>k</ci>
     <ci>diff</ci>
    </apply>
    <apply>
     <ci>normal-⋅</ci>
     <ci>L</ci>
     <ci>P</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k_{\mathrm{diff}}=L\cdot P
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Specular_highlight:25">
 <semantics>
  <mrow>
   <msub>
    <mi>k</mi>
    <mi>spec</mi>
   </msub>
   <mo>=</mo>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>V</mi>
      <mo>⋅</mo>
      <mi>R</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>s</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>k</ci>
     <ci>spec</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <ci>normal-⋅</ci>
      <ci>V</ci>
      <ci>R</ci>
     </apply>
     <ci>s</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k_{\mathrm{spec}}=(V\cdot R)^{s}
  </annotation>
 </semantics>
</math>

</p>
<h4 id="optimization">Optimization</h4>

<p>Calculation of <em>R</em> and <em>P</em> are expensive operation. To avoid their calculation original formula can be rewritten in next form:</p>
<h5 id="diffuse">Diffuse</h5>

<p>

<math display="block" id="Specular_highlight:26">
 <semantics>
  <mrow>
   <msub>
    <mi>k</mi>
    <mi>diff</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mi>L</mi>
    <mo>⋅</mo>
    <mi>P</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>L</mi>
    <mo>⋅</mo>
    <mfrac>
     <mrow>
      <mi>L</mi>
      <mo>+</mo>
      <mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mo>-</mo>
         <mrow>
          <mi>L</mi>
          <mo>⋅</mo>
          <mi>T</mi>
         </mrow>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mo>*</mo>
       <mi>T</mi>
      </mrow>
     </mrow>
     <mrow>
      <mo>∥</mo>
      <mrow>
       <mi>L</mi>
       <mo>+</mo>
       <mrow>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mo>-</mo>
          <mrow>
           <mi>L</mi>
           <mo>⋅</mo>
           <mi>T</mi>
          </mrow>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
        <mo>*</mo>
        <mi>T</mi>
       </mrow>
      </mrow>
      <mo>∥</mo>
     </mrow>
    </mfrac>
   </mrow>
   <mo>=</mo>
   <mi mathvariant="normal">…</mi>
   <mo>=</mo>
   <msqrt>
    <mrow>
     <mn>1</mn>
     <mo>-</mo>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>L</mi>
        <mo>⋅</mo>
        <mi>T</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mn>2</mn>
     </msup>
    </mrow>
   </msqrt>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>k</ci>
      <ci>diff</ci>
     </apply>
     <apply>
      <ci>normal-⋅</ci>
      <ci>L</ci>
      <ci>P</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <ci>normal-⋅</ci>
      <ci>L</ci>
      <apply>
       <divide></divide>
       <apply>
        <plus></plus>
        <ci>L</ci>
        <apply>
         <times></times>
         <apply>
          <minus></minus>
          <apply>
           <ci>normal-⋅</ci>
           <ci>L</ci>
           <ci>T</ci>
          </apply>
         </apply>
         <ci>T</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="latexml">norm</csymbol>
        <apply>
         <plus></plus>
         <ci>L</ci>
         <apply>
          <times></times>
          <apply>
           <minus></minus>
           <apply>
            <ci>normal-⋅</ci>
            <ci>L</ci>
            <ci>T</ci>
           </apply>
          </apply>
          <ci>T</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <ci>normal-…</ci>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <root></root>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <ci>normal-⋅</ci>
         <ci>L</ci>
         <ci>T</ci>
        </apply>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k_{\mathrm{diff}}=L\cdot P=L\cdot\frac{L+(-L\cdot T)*T}{\|L+(-L\cdot T)*T\|}=.%
..=\sqrt{1-(L\cdot T)^{2}}
  </annotation>
 </semantics>
</math>

</p>
<h5 id="specular">Specular</h5>

<p>

<math display="inline" id="Specular_highlight:27">
 <semantics>
  <msub>
   <mi>k</mi>
   <mi>spec</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>k</ci>
    <ci>spec</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle k_{\mathrm{spec}}
  </annotation>
 </semantics>
</math>


</p>
<h4 id="comments">Comments</h4>

<p><em>T</em> can be observed as bump normal and after that it is possible to apply other BRDF than Phong. The anisotropic 

<math display="inline" id="Specular_highlight:28">
 <semantics>
  <msub>
   <mi>k</mi>
   <mi>spec</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>k</ci>
    <ci>spec</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k_{\mathrm{spec}}
  </annotation>
 </semantics>
</math>

 should be used in conjunction with an isotropic distribution like a Phong distribution to produce the correct specular highlight</p>
<h3 id="ward-anisotropic-distribution">Ward anisotropic distribution</h3>

<p>The Ward anisotropic distribution <a href="http://radsite.lbl.gov/radiance/papers/">2</a> uses two user-controllable parameters <em>α<sub>x</sub></em> and <em>α<sub>y</sub></em> to control the anisotropy. If the two parameters are equal, then an isotropic highlight results. The specular term in the distribution is:</p>

<p>

<math display="block" id="Specular_highlight:29">
 <semantics>
  <mrow>
   <msub>
    <mi>k</mi>
    <mi>spec</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <msqrt>
      <mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>N</mi>
         <mo>⋅</mo>
         <mi>L</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>N</mi>
         <mo>⋅</mo>
         <mi>V</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </msqrt>
    </mfrac>
    <mfrac>
     <mrow>
      <mi>N</mi>
      <mo>⋅</mo>
      <mi>L</mi>
     </mrow>
     <mrow>
      <mn>4</mn>
      <mi>π</mi>
      <msub>
       <mi>α</mi>
       <mi>x</mi>
      </msub>
      <msub>
       <mi>α</mi>
       <mi>y</mi>
      </msub>
     </mrow>
    </mfrac>
    <mrow>
     <mi>exp</mi>
     <mrow>
      <mo>[</mo>
      <mrow>
       <mo>-</mo>
       <mrow>
        <mn>2</mn>
        <mfrac>
         <mrow>
          <msup>
           <mrow>
            <mo>(</mo>
            <mfrac>
             <mrow>
              <mi>H</mi>
              <mo>⋅</mo>
              <mi>X</mi>
             </mrow>
             <msub>
              <mi>α</mi>
              <mi>x</mi>
             </msub>
            </mfrac>
            <mo>)</mo>
           </mrow>
           <mn>2</mn>
          </msup>
          <mo>+</mo>
          <msup>
           <mrow>
            <mo>(</mo>
            <mfrac>
             <mrow>
              <mi>H</mi>
              <mo>⋅</mo>
              <mi>Y</mi>
             </mrow>
             <msub>
              <mi>α</mi>
              <mi>y</mi>
             </msub>
            </mfrac>
            <mo>)</mo>
           </mrow>
           <mn>2</mn>
          </msup>
         </mrow>
         <mrow>
          <mn>1</mn>
          <mo>+</mo>
          <mrow>
           <mo stretchy="false">(</mo>
           <mrow>
            <mi>H</mi>
            <mo>⋅</mo>
            <mi>N</mi>
           </mrow>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
        </mfrac>
       </mrow>
      </mrow>
      <mo>]</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>k</ci>
     <ci>spec</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <root></root>
       <apply>
        <times></times>
        <apply>
         <ci>normal-⋅</ci>
         <ci>N</ci>
         <ci>L</ci>
        </apply>
        <apply>
         <ci>normal-⋅</ci>
         <ci>N</ci>
         <ci>V</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <ci>normal-⋅</ci>
       <ci>N</ci>
       <ci>L</ci>
      </apply>
      <apply>
       <times></times>
       <cn type="integer">4</cn>
       <ci>π</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>α</ci>
        <ci>x</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>α</ci>
        <ci>y</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <exp></exp>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <apply>
         <divide></divide>
         <apply>
          <plus></plus>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <apply>
            <divide></divide>
            <apply>
             <ci>normal-⋅</ci>
             <ci>H</ci>
             <ci>X</ci>
            </apply>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <ci>α</ci>
             <ci>x</ci>
            </apply>
           </apply>
           <cn type="integer">2</cn>
          </apply>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <apply>
            <divide></divide>
            <apply>
             <ci>normal-⋅</ci>
             <ci>H</ci>
             <ci>Y</ci>
            </apply>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <ci>α</ci>
             <ci>y</ci>
            </apply>
           </apply>
           <cn type="integer">2</cn>
          </apply>
         </apply>
         <apply>
          <plus></plus>
          <cn type="integer">1</cn>
          <apply>
           <ci>normal-⋅</ci>
           <ci>H</ci>
           <ci>N</ci>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k_{\mathrm{spec}}=\frac{1}{\sqrt{(N\cdot L)(N\cdot V)}}\frac{N\cdot L}{4\pi%
\alpha_{x}\alpha_{y}}\exp\left[-2\frac{\left(\frac{H\cdot X}{\alpha_{x}}\right%
)^{2}+\left(\frac{H\cdot Y}{\alpha_{y}}\right)^{2}}{1+(H\cdot N)}\right]
  </annotation>
 </semantics>
</math>

</p>

<p>The specular term is zero if <em>N</em>·<em>L</em> R. Cook and K. Torrance. "<a href="http://inst.eecs.berkeley.edu/~cs283/sp13/lectures/cookpaper.pdf">A reflectance model for computer graphics</a>". Computer Graphics (SIGGRAPH '81 Proceedings), Vol. 15, No. 3, July 1981, pp. 301–316. uses a specular term of the form</p>

<p>

<math display="block" id="Specular_highlight:30">
 <semantics>
  <mrow>
   <msub>
    <mi>k</mi>
    <mi>spec</mi>
   </msub>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mi>D</mi>
     <mi>F</mi>
     <mi>G</mi>
    </mrow>
    <mrow>
     <mn>4</mn>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>V</mi>
       <mo>⋅</mo>
       <mi>N</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>N</mi>
       <mo>⋅</mo>
       <mi>L</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>k</ci>
     <ci>spec</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <ci>D</ci>
      <ci>F</ci>
      <ci>G</ci>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">4</cn>
      <apply>
       <ci>normal-⋅</ci>
       <ci>V</ci>
       <ci>N</ci>
      </apply>
      <apply>
       <ci>normal-⋅</ci>
       <ci>N</ci>
       <ci>L</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k_{\mathrm{spec}}=\frac{DFG}{4(V\cdot N)(N\cdot L)}
  </annotation>
 </semantics>
</math>

. Here D is the <a href="Specular_highlight#Beckmann_distribution" title="wikilink">Beckmann distribution</a> factor as above and F is the <a href="Fresnel_equations" title="wikilink">Fresnel</a> term,</p>

<p>

<math display="block" id="Specular_highlight:31">
 <semantics>
  <mrow>
   <mrow>
    <mi>F</mi>
    <mo>=</mo>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mn>1</mn>
       <mo>+</mo>
       <mrow>
        <mi>V</mi>
        <mo>⋅</mo>
        <mi>N</mi>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>λ</mi>
    </msup>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>F</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <plus></plus>
      <cn type="integer">1</cn>
      <apply>
       <ci>normal-⋅</ci>
       <ci>V</ci>
       <ci>N</ci>
      </apply>
     </apply>
     <ci>λ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F=(1+V\cdot N)^{\lambda}.
  </annotation>
 </semantics>
</math>

 For performance reasons in real-time 3D graphics <a href="Schlick's_approximation" title="wikilink">Schlick's approximation</a> is often used to approximate Fresnel term.</p>

<p>G is the geometric attenuation term, describing selfshadowing due to the microfacets, and is of the form</p>

<p>

<math display="block" id="Specular_highlight:32">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mo>=</mo>
   <mrow>
    <mi>min</mi>
    <mrow>
     <mo>(</mo>
     <mn>1</mn>
     <mo>,</mo>
     <mfrac>
      <mrow>
       <mn>2</mn>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>H</mi>
         <mo>⋅</mo>
         <mi>N</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>V</mi>
         <mo>⋅</mo>
         <mi>N</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mrow>
       <mi>V</mi>
       <mo>⋅</mo>
       <mi>H</mi>
      </mrow>
     </mfrac>
     <mo>,</mo>
     <mfrac>
      <mrow>
       <mn>2</mn>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>H</mi>
         <mo>⋅</mo>
         <mi>N</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>L</mi>
         <mo>⋅</mo>
         <mi>N</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mrow>
       <mi>V</mi>
       <mo>⋅</mo>
       <mi>H</mi>
      </mrow>
     </mfrac>
     <mo>)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>G</ci>
    <apply>
     <min></min>
     <cn type="integer">1</cn>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <apply>
        <ci>normal-⋅</ci>
        <ci>H</ci>
        <ci>N</ci>
       </apply>
       <apply>
        <ci>normal-⋅</ci>
        <ci>V</ci>
        <ci>N</ci>
       </apply>
      </apply>
      <apply>
       <ci>normal-⋅</ci>
       <ci>V</ci>
       <ci>H</ci>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <apply>
        <ci>normal-⋅</ci>
        <ci>H</ci>
        <ci>N</ci>
       </apply>
       <apply>
        <ci>normal-⋅</ci>
        <ci>L</ci>
        <ci>N</ci>
       </apply>
      </apply>
      <apply>
       <ci>normal-⋅</ci>
       <ci>V</ci>
       <ci>H</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G=\min{\left(1,\frac{2(H\cdot N)(V\cdot N)}{V\cdot H},\frac{2(H\cdot N)(L\cdot
N%
)}{V\cdot H}\right)}
  </annotation>
 </semantics>
</math>

. In these formulas V is the vector to the camera or eye, H is the half-angle vector, L is the vector to the light source and N is the normal vector, and α is the angle between H and N.</p>
<h3 id="using-multiple-distributions">Using multiple distributions</h3>

<p>If desired, different distributions (usually, using the same distribution function with different values of <em>m</em> or <em>n</em>) can be combined using a weighted average. This is useful for modelling, for example, surfaces that have small smooth and rough patches rather than uniform roughness.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="List_of_common_shading_algorithms" title="wikilink">List of common shading algorithms</a></li>
<li><a href="Specular_reflection" title="wikilink">Specular reflection</a></li>
<li><a href="Diffuse_reflection" title="wikilink">Diffuse reflection</a></li>
<li><a href="Gamma_correction" title="wikilink">Gamma correction</a></li>
<li><a href="Fresnel_equations" title="wikilink">Fresnel equations</a></li>
<li><a class="uri" href="Retroreflector" title="wikilink">Retroreflector</a></li>
<li><a href="Reflection_(physics)" title="wikilink">Reflection (physics)</a></li>
<li><a class="uri" href="Refraction" title="wikilink">Refraction</a></li>
<li><a class="uri" href="Specularity" title="wikilink">Specularity</a></li>
</ul>
<h2 id="references">References</h2>
<references>
</references>

<p>"</p>

<p><a class="uri" href="Category:Optics" title="wikilink">Category:Optics</a> <a class="uri" href="Category:Shading" title="wikilink">Category:Shading</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Richard Lyon, "Phong Shading Reformulation for Hardware Renderer Simplification", Apple Technical Report #43, Apple Computer, Inc. 1993 <a href="http://dicklyon.com/tech/Graphics/Phong_TR-Lyon.pdf">PDF</a><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="Andrew_Glassner" title="wikilink">Glassner, Andrew S.</a> (ed). An Introduction to Ray Tracing. San Diego: Academic Press Ltd, 1989. p. 148.<a href="#fnref2">↩</a></li>
<li id="fn3">Petr Beckmann, André Spizzichino, The scattering of electromagnetic waves from rough surfaces, Pergamon Press, 1963, 503 pp (Republished by Artech House, 1987, ISBN 978-0-89006-238-8).<a href="#fnref3">↩</a></li>
<li id="fn4">Foley et al. <a href="Computer_Graphics:_Principles_and_Practice" title="wikilink">Computer Graphics: Principles and Practice</a>. Menlo Park: Addison-Wesley, 1997. p. 764.<a href="#fnref4">↩</a></li>
<li id="fn5"></li>
<li id="fn6">Wolfgang Heidrich and Hans-Peter Seidel, "Efficient Rendering of Anisotropic Surfaces Using Computer Graphics Hardware", Computer Graphics Group, University of Erlangen <a href="http://www.cs.ubc.ca/~heidrich/Papers/IMDSP.98.pdf">1</a><a href="#fnref6">↩</a></li>
</ol>
</section>
</body>
</html>
