<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="240">Circular convolution</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Circular convolution</h1>
<hr>The '''circular convolution''', also known as '''cyclic convolution''',  of two aperiodic functions (i.e. [[Schwart
<p>z functions]]) occurs when one of them is <a href="convolution" title="wikilink">convolved in the normal way</a> with a <a href="periodic_summation" title="wikilink">periodic summation</a> of the other function.  That situation arises in the context of the <a href="Discrete_Fourier_transform#Circular_convolution_theorem_and_cross-correlation_theorem" title="wikilink">Circular convolution theorem</a>.  The identical operation can also be expressed in terms of the periodic summations of <u>both</u> functions, if the infinite integration interval is reduced to just one period.  That situation arises in the context of the <a href="discrete-time_Fourier_transform" title="wikilink">discrete-time Fourier transform</a> (DTFT) and is also called <strong>periodic convolution</strong>.  In particular, the DTFT of the product of two discrete sequences is the periodic convolution of the DTFTs of the individual sequences.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>

<p>Let <em>x</em> be a function with a well-defined periodic summation, <em>x</em><sub><em>T</em></sub>, where:</p>

<p>

<math display="block" id="Circular_convolution:0">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>x</mi>
      <mi>T</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo rspace="7.5pt" stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mpadded width="+5pt">
     <mover>
      <mo movablelimits="false">=</mo>
      <mi>def</mi>
     </mover>
    </mpadded>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>k</mi>
       <mo>=</mo>
       <mrow>
        <mo>-</mo>
        <mi mathvariant="normal">∞</mi>
       </mrow>
      </mrow>
      <mi mathvariant="normal">∞</mi>
     </munderover>
     <mrow>
      <mi>x</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>t</mi>
        <mo>-</mo>
        <mrow>
         <mi>k</mi>
         <mi>T</mi>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>k</mi>
       <mo>=</mo>
       <mrow>
        <mo>-</mo>
        <mi mathvariant="normal">∞</mi>
       </mrow>
      </mrow>
      <mi mathvariant="normal">∞</mi>
     </munderover>
     <mrow>
      <mi>x</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>t</mi>
        <mo>+</mo>
        <mrow>
         <mi>k</mi>
         <mi>T</mi>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <eq></eq>
      <ci>def</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>T</ci>
      </apply>
      <ci>t</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>k</ci>
         <apply>
          <minus></minus>
          <infinity></infinity>
         </apply>
        </apply>
       </apply>
       <infinity></infinity>
      </apply>
      <apply>
       <times></times>
       <ci>x</ci>
       <apply>
        <minus></minus>
        <ci>t</ci>
        <apply>
         <times></times>
         <ci>k</ci>
         <ci>T</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>k</ci>
         <apply>
          <minus></minus>
          <infinity></infinity>
         </apply>
        </apply>
       </apply>
       <infinity></infinity>
      </apply>
      <apply>
       <times></times>
       <ci>x</ci>
       <apply>
        <plus></plus>
        <ci>t</ci>
        <apply>
         <times></times>
         <ci>k</ci>
         <ci>T</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{T}(t)\ \stackrel{\mathrm{def}}{=}\ \sum_{k=-\infty}^{\infty}x(t-kT)=\sum_{k%
=-\infty}^{\infty}x(t+kT).
  </annotation>
 </semantics>
</math>

</p>

<p>If <em>h</em> is any other function for which the convolution <em>x</em><sub><em>T</em></sub> ∗ <em>h</em> exists, then the convolution <em>x</em><sub><em>T</em></sub> ∗ <em>h</em> is periodic and identical to<strong>:</strong></p>

<p>

<math display="inline" id="Circular_convolution:1">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msub>
      <mi>x</mi>
      <mi>T</mi>
     </msub>
     <mo>*</mo>
     <mi>h</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>T</ci>
     </apply>
     <ci>h</ci>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle(x_{T}*h)(t)
  </annotation>
 </semantics>
</math>


<ref>Proof<strong>:</strong></ref></p>

<p>

<math display="block" id="Circular_convolution:2">
 <semantics>
  <mrow>
   <msubsup>
    <mo largeop="true" symmetric="true">∫</mo>
    <mrow>
     <mo>-</mo>
     <mi mathvariant="normal">∞</mi>
    </mrow>
    <mi mathvariant="normal">∞</mi>
   </msubsup>
   <mrow>
    <mrow>
     <mrow>
      <mi>h</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>τ</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>⋅</mo>
     <msub>
      <mi>x</mi>
      <mi>T</mi>
     </msub>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>t</mi>
      <mo>-</mo>
      <mi>τ</mi>
     </mrow>
     <mo rspace="4.2pt" stretchy="false">)</mo>
    </mrow>
    <mi>d</mi>
    <mi>τ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <int></int>
      <apply>
       <minus></minus>
       <infinity></infinity>
      </apply>
     </apply>
     <infinity></infinity>
    </apply>
    <apply>
     <times></times>
     <apply>
      <ci>normal-⋅</ci>
      <apply>
       <times></times>
       <ci>h</ci>
       <ci>τ</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>T</ci>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <ci>t</ci>
      <ci>τ</ci>
     </apply>
     <ci>d</ci>
     <ci>τ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \int_{-\infty}^{\infty}h(\tau)\cdot x_{T}(t-\tau)\,d\tau
  </annotation>
 </semantics>
</math>

</p>
<dl>
<dd><dl>
<dd><math>
</math></dd>
</dl>
</dd>
</dl>

<p>\begin{align} &amp;= \sum_{k=-\infty}^\infty \left[\int_{t_o+kT}^{t_o+(k+1)T} h(\tau)\cdot x_T(t - \tau)\ d\tau\right] \\ &amp;\stackrel{\tau \rightarrow \tau+kT}{=}\ \sum_{k=-\infty}^\infty \left[\int_{t_o}^{t_o+T} h(\tau+kT)\cdot x_T(t - \tau -kT)\ d\tau\right] \\ &amp;= \int_{t_o}^{t_o+T} \left[\sum_{k=-\infty}^\infty h(\tau+kT)\cdot \underbrace{x_T(t - \tau-kT)}_{X_T(t - \tau), \text{ by periodicity}}\right]\ d\tau\\ &amp;= \int_{t_o}^{t_o+T} \underbrace{\left[\sum_{k=-\infty}^\infty h(\tau+kT)\right]}_{\stackrel{\mathrm{def}}{=} \ h_T(\tau)}\cdot x_T(t - \tau)\ d\tau \quad \quad \scriptstyle{(QED)} \end{align}  </p>

<p>where <em>t</em><sub>o</sub> is an arbitrary parameter and <em>h</em><sub><em>T</em></sub> is a <a href="periodic_summation" title="wikilink">periodic summation</a> of <em>h</em>.</p>

<p>The second integral is called the <strong>periodic convolution</strong><a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a><a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> of functions <em>x</em><sub><em>T</em></sub> and <em>h</em><sub><em>T</em></sub> and is sometimes normalized by 1/<em>T</em>.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> When <em>x</em><sub><em>T</em></sub> is expressed as the <a href="periodic_summation" title="wikilink">periodic summation</a> of another function, <em>x</em>, the same operation may also be referred to as a <strong>circular convolution</strong><a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a><a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> of functions <em>h</em> and <em>x</em>.</p>
<h2 id="discrete-sequences">Discrete sequences</h2>

<p>Similarly, for discrete sequences and period <strong>N</strong>, we can write the <strong>circular convolution</strong> of functions <em>h</em> and <em>x</em> as<strong>:</strong></p>

<p>

<math display="inline" id="Circular_convolution:3">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msub>
      <mi>x</mi>
      <mi>N</mi>
     </msub>
     <mo>*</mo>
     <mi>h</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>n</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>N</ci>
     </apply>
     <ci>h</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle(x_{N}*h)[n]
  </annotation>
 </semantics>
</math>


</p>

<p>For the special case that the non-zero extent of both <em>x</em> and <em>h</em> are <em>≤ N</em>, this is reducible to <a href="matrix_multiplication" title="wikilink">matrix multiplication</a> where the kernel of the integral transform is a <a href="circulant_matrix" title="wikilink">circulant matrix</a>.</p>
<h2 id="example">Example</h2>

<p> A case of great practical interest is illustrated in the figure. The duration of the <strong>x</strong> sequence is <strong>N</strong> (or less), and the duration of the <strong>h</strong> sequence is significantly less. Then many of the values of the circular convolution are identical to values of <strong>x∗h</strong>,  which is actually the desired result when the <strong>h</strong> sequence is a <a href="finite_impulse_response" title="wikilink">finite impulse response</a> (FIR) filter. Furthermore, the circular convolution is very efficient to compute, using a <a href="fast_Fourier_transform" title="wikilink">fast Fourier transform</a> (FFT) algorithm and the <a href="Discrete_Fourier_transform#Circular_convolution_theorem_and_cross-correlation_theorem" title="wikilink">circular convolution theorem</a>.</p>

<p>There are also methods for dealing with an <strong>x</strong> sequence that is longer than a practical value for <strong>N</strong>. The sequence is divided into segments (<em>blocks</em>) and processed piecewise. Then the filtered segments are carefully pieced back together. Edge effects are eliminated by <u>overlapping</u> either the input blocks or the output blocks. To help explain and compare the methods, we discuss them both in the context of an <strong>h</strong> sequence of length 201 and an FFT size of <em>N</em> = 1024.</p>

<p><strong>Overlapping input blocks</strong></p>

<p>This method uses a block size equal to the FFT size (1024). We describe it first in terms of normal or <em>linear</em> convolution. When a normal convolution is performed on each block, there are start-up and decay transients at the block edges, due to the filter <em>latency</em> (200-samples). Only 824 of the convolution outputs are unaffected by edge effects. The others are discarded, or simply not computed. That would cause gaps in the output if the input blocks are contiguous. The gaps are avoided by overlapping the input blocks by 200 samples. In a sense, 200 elements from each input block are "saved" and carried over to the next block. This method is referred to as <strong><a href="Overlap-save_method" title="wikilink">overlap-save</a></strong>,<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> although the method we describe next requires a similar "save" with the output samples.</p>

<p>When the DFT or FFT is used, we don't have the option of not computing the affected samples, but the leading and trailing edge-effects are overlapped and added because of circular convolution. Consequently, the 1024-point inverse FFT (IFFT) output contains only 200 samples of edge effects (which are discarded) and the 824 unaffected samples (which are kept). To illustrate this, the fourth frame of the figure at right depicts a block that has been periodically (or "circularly") extended, and the fifth frame depicts the individual components of a linear convolution performed on the entire sequence. The edge effects are where the contributions from the extended blocks overlap the contributions from the original block. The last frame is the composite output, and the section colored green represents the unaffected portion.</p>

<p><strong>Overlapping output blocks</strong></p>

<p>This method is known as <strong><a href="Overlap-add_method" title="wikilink">overlap-add</a></strong>.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> In our example, it uses contiguous input blocks of size 824 and pads each one with 200 zero-valued samples. Then it overlaps and adds the 1024-element output blocks. Nothing is discarded, but 200 values of each output block must be "saved" for the addition with the next block. Both methods advance only 824 samples per 1024-point IFFT, but overlap-save avoids the initial zero-padding and final addition.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Hilbert_transform#Discrete_Hilbert_transform" title="wikilink">Discrete Hilbert transform</a></li>
<li><a href="Circulant_matrix" title="wikilink">Circulant matrix</a></li>
</ul>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<ul>
<li>Rabiner, Lawrence R.; Gold, Bernard (1975). <em>Theory and application of digital signal processing</em>. Englewood Cliffs, N.J.: Prentice-Hall. pp 63–67. <a href="http://isbndb.com/d/book/theory_and_application_of_digital_signal_processing.html">ISBN 0139141014</a></li>
<li>Oppenheim, Alan V.; Schafer, Ronald W.; Buck, John A. (1999). <em>Discrete-time signal processing</em>. Upper Saddle River, N.J.: Prentice Hall. <a href="http://isbndb.com/d/book/discrete_time_signal_processing_a02.html">ISBN 0137549202</a>.</li>
<li>Priemer, Roland (July 1991). <em>Introductory Signal Processing (Advanced Series in Electrical and Computer Engineering) (v. 6)</em>. Teaneck, N.J.: World Scientific Pub Co Inc. [<a class="uri" href="http://books.google.com/books?id=QBT7nP7zTLgC&amp;printsec">http://books.google.com/books?id=QBT7nP7zTLgC&amp;printsec;</a>;=frontcover&amp;dq;=Priemer,+Roland&amp;hl;=en&amp;sa;=X&amp;ei;=J2owUZzANIb_ygGex4HAAg&amp;ved;=0CC8Q6AEwAA ISBN 9971509199].</li>
<li>Jeruchim, Michel C.; Philip Balaban, K. Sam Shanmugan (October 2000). <em>Simulation of Communication Systems: Modeling, Methodology and Techniques</em> (2nd ed.). New York: Kluwer Academic Publishers. <a href="http://isbndb.com/d/book/simulation_of_communication_systems_a01.html">ISBN 0306462672</a>.</li>
<li>Udayashankara, V. (June 2010). <em>Real Time Digital Signal Processing</em>. India: Prentice-Hall. <a href="http://isbndb.com/d/book/real_time_digital_signal_processing_a05.html">ISBN 8120340493</a>.</li>
<li>

<p>.</p></li>
</ul>

<p>"</p>

<p><a href="Category:Functional_analysis" title="wikilink">Category:Functional analysis</a> <a href="Category:Image_processing" title="wikilink">Category:Image processing</a> <a href="Category:Binary_operations" title="wikilink">Category:Binary operations</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">If a sequence, <em>x</em>[<em>n</em>], represents samples of a continuous function, <em>x</em>(<em>t</em>), with Fourier transform <em>X</em>(ƒ), its DTFT is a periodic summation of <em>X</em>(ƒ).  (see <a class="uri" href="Discrete-time_Fourier_transform#Relationship_to_sampling" title="wikilink">Discrete-time_Fourier_transform#Relationship_to_sampling</a>)<a href="#fnref1">↩</a></li>
<li id="fn2">Jeruchim 2000, pp 73-74.<a href="#fnref2">↩</a></li>
<li id="fn3">Udayashankara 2010, p 189.<a href="#fnref3">↩</a></li>
<li id="fn4">Oppenheim, pp 388-389<a href="#fnref4">↩</a></li>
<li id="fn5"></li>
<li id="fn6">Priemer 1991, pp 286-289.<a href="#fnref6">↩</a></li>
<li id="fn7">Rabiner 1975, pp 65–67.<a href="#fnref7">↩</a></li>
<li id="fn8">Rabiner 1975, pp 63–65.<a href="#fnref8">↩</a></li>
</ol>
</section>
</hr></body>
</html>
