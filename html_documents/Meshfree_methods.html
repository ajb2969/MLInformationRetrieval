<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="877">Meshfree methods</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Meshfree methods</h1>
<hr/>

<p>In the field of <a href="numerical_analysis" title="wikilink">numerical simulation methods</a>, <strong>meshfree methods</strong> are those that do not require that a mesh connect data points of the simulation domain. Meshfree methods enable the simulation of some otherwise difficult types of problems, at the cost of extra computing time and programming effort.</p>
<h2 id="motivation">Motivation</h2>

<p>Numerical methods such as the <a href="finite_difference_method" title="wikilink">finite difference method</a>, <a href="finite-volume_method" title="wikilink">finite-volume method</a>, and <a href="finite_element_method" title="wikilink">finite element method</a> were originally defined on meshes of data points. In such a mesh, each point has a fixed number of predefined neighbors, and this connectivity between neighbors can be used to define mathematical operators like the <a href="numerical_differentiation" title="wikilink">derivative</a>. These operators are then used to construct the equations to simulate—such as the <a href="Euler_equations_(fluid_dynamics)" title="wikilink">Euler equations</a> or the <a href="Navier–Stokes_equations" title="wikilink">Navier–Stokes equations</a>.</p>

<p>But in simulations where the material being simulated can move around (as in <a href="computational_fluid_dynamics" title="wikilink">computational fluid dynamics</a>) or where large <a href="Deformation_(mechanics)" title="wikilink">deformations</a> of the material can occur (as in simulations of <a href="Plasticity_(physics)" title="wikilink">plastic materials</a>), the connectivity of the mesh can be difficult to maintain without introducing error into the simulation. If the mesh becomes tangled or degenerate during simulation, the operators defined on it may no longer give correct values. The mesh may be recreated during simulation (a process called remeshing), but this can also introduce error, since all the existing data points must be mapped onto a new and different set of data points. Meshfree methods are intended to remedy these problems. Meshfree methods are also useful for:</p>
<ul>
<li>Simulations where <a href="Mesh_generation" title="wikilink">creating a useful mesh from the geometry of a complex 3D object</a> may be especially difficult or require human assistance</li>
<li>Simulations where nodes may be created or destroyed, such as in cracking simulations</li>
<li>Simulations where the problem geometry may move out of alignment with a fixed mesh, such as in bending simulations</li>
<li>Simulations containing nonlinear material behavior, discontinuities or singularities</li>
</ul>
<h2 id="example">Example</h2>

<p>In a traditional <a href="finite_difference_method" title="wikilink">finite difference</a> simulation, the domain of a one-dimensional simulation would be some function 

<math display="inline" id="Meshfree_methods:0">
 <semantics>
  <mrow>
   <mi>u</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>u</ci>
    <interval closure="open">
     <ci>x</ci>
     <ci>t</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u(x,t)
  </annotation>
 </semantics>
</math>

, represented as a mesh of data values 

<math display="inline" id="Meshfree_methods:1">
 <semantics>
  <msubsup>
   <mi>u</mi>
   <mi>i</mi>
   <mi>n</mi>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>u</ci>
     <ci>i</ci>
    </apply>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u_{i}^{n}
  </annotation>
 </semantics>
</math>

 at points 

<math display="inline" id="Meshfree_methods:2">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i}
  </annotation>
 </semantics>
</math>

, where</p>

<p>

<math display="block" id="Meshfree_methods:3">
 <semantics>
  <mrow>
   <mi>i</mi>
   <mo>=</mo>
   <mrow>
    <mn>0</mn>
    <mo>,</mo>
    <mn>1</mn>
    <mo>,</mo>
    <mn>2...</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>i</ci>
    <list>
     <cn type="integer">0</cn>
     <cn type="integer">1</cn>
     <cn type="float">2...</cn>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i=0,1,2...
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Meshfree_methods:4">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>=</mo>
   <mrow>
    <mn>0</mn>
    <mo>,</mo>
    <mn>1</mn>
    <mo>,</mo>
    <mn>2...</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>n</ci>
    <list>
     <cn type="integer">0</cn>
     <cn type="integer">1</cn>
     <cn type="float">2...</cn>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n=0,1,2...
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Meshfree_methods:5">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>x</mi>
     <mrow>
      <mi>i</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo>-</mo>
    <msub>
     <mi>x</mi>
     <mi>i</mi>
    </msub>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mpadded width="+5pt">
     <mi>h</mi>
    </mpadded>
    <mrow>
     <mo>∀</mo>
     <mi>i</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <apply>
       <plus></plus>
       <ci>i</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>i</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>h</ci>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i+1}-x_{i}=h\ \forall i
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Meshfree_methods:6">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>t</mi>
     <mrow>
      <mi>n</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo>-</mo>
    <msub>
     <mi>t</mi>
     <mi>n</mi>
    </msub>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mpadded width="+5pt">
     <mi>k</mi>
    </mpadded>
    <mrow>
     <mo>∀</mo>
     <mi>n</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>t</ci>
      <apply>
       <plus></plus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>t</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>k</ci>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t_{n+1}-t_{n}=k\ \forall n
  </annotation>
 </semantics>
</math>

 We can define the derivatives that occur in the equation being simulated using some finite difference formulae on this domain, for example</p>

<p>

<math display="block" id="Meshfree_methods:7">
 <semantics>
  <mrow>
   <mfrac>
    <mrow>
     <mo>∂</mo>
     <mi>u</mi>
    </mrow>
    <mrow>
     <mo>∂</mo>
     <mi>x</mi>
    </mrow>
   </mfrac>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <msubsup>
      <mi>u</mi>
      <mrow>
       <mi>i</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
      <mi>n</mi>
     </msubsup>
     <mo>-</mo>
     <msubsup>
      <mi>u</mi>
      <mrow>
       <mi>i</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
      <mi>n</mi>
     </msubsup>
    </mrow>
    <mrow>
     <mn>2</mn>
     <mi>h</mi>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <divide></divide>
     <apply>
      <partialdiff></partialdiff>
      <ci>u</ci>
     </apply>
     <apply>
      <partialdiff></partialdiff>
      <ci>x</ci>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>u</ci>
        <apply>
         <plus></plus>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>n</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>u</ci>
        <apply>
         <minus></minus>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>n</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <ci>h</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\partial u\over\partial x}={u_{i+1}^{n}-u_{i-1}^{n}\over 2h}
  </annotation>
 </semantics>
</math>

 and</p>

<p>

<math display="block" id="Meshfree_methods:8">
 <semantics>
  <mrow>
   <mfrac>
    <mrow>
     <mo>∂</mo>
     <mi>u</mi>
    </mrow>
    <mrow>
     <mo>∂</mo>
     <mi>t</mi>
    </mrow>
   </mfrac>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <msubsup>
      <mi>u</mi>
      <mi>i</mi>
      <mrow>
       <mi>n</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </msubsup>
     <mo>-</mo>
     <msubsup>
      <mi>u</mi>
      <mi>i</mi>
      <mi>n</mi>
     </msubsup>
    </mrow>
    <mi>k</mi>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <divide></divide>
     <apply>
      <partialdiff></partialdiff>
      <ci>u</ci>
     </apply>
     <apply>
      <partialdiff></partialdiff>
      <ci>t</ci>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>u</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <plus></plus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>u</ci>
        <ci>i</ci>
       </apply>
       <ci>n</ci>
      </apply>
     </apply>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\partial u\over\partial t}={u_{i}^{n+1}-u_{i}^{n}\over k}
  </annotation>
 </semantics>
</math>

 Then we can use these definitions of 

<math display="inline" id="Meshfree_methods:9">
 <semantics>
  <mrow>
   <mi>u</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>u</ci>
    <interval closure="open">
     <ci>x</ci>
     <ci>t</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u(x,t)
  </annotation>
 </semantics>
</math>

 and its spatial and temporal derivatives to write the equation being simulated in finite difference form, then simulate the equation with one of many <a href="finite_difference_method" title="wikilink">finite difference methods</a>.</p>

<p>In this simple example, the spatial step size 

<math display="inline" id="Meshfree_methods:10">
 <semantics>
  <mi>h</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>h</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h
  </annotation>
 </semantics>
</math>

 and the temporal step size 

<math display="inline" id="Meshfree_methods:11">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 are constant, and the left and right mesh neighbors of the data value at 

<math display="inline" id="Meshfree_methods:12">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i}
  </annotation>
 </semantics>
</math>

 are the values at 

<math display="inline" id="Meshfree_methods:13">
 <semantics>
  <msub>
   <mi>x</mi>
   <mrow>
    <mi>i</mi>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <apply>
     <minus></minus>
     <ci>i</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i-1}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Meshfree_methods:14">
 <semantics>
  <msub>
   <mi>x</mi>
   <mrow>
    <mi>i</mi>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <apply>
     <plus></plus>
     <ci>i</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i+1}
  </annotation>
 </semantics>
</math>

, respectively. But if the values can move around, or can be added to or removed from the simulation, that destroys the spacing and the simple finite difference formulae for derivatives is no longer correct.</p>

<p><a href="Smoothed-particle_hydrodynamics" title="wikilink">Smoothed-particle hydrodynamics</a> (SPH), one of the oldest meshfree methods, solves this problem by treating data points as physical particles with mass and density that can move around over time, and carry some value 

<math display="inline" id="Meshfree_methods:15">
 <semantics>
  <msub>
   <mi>u</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>u</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u_{i}
  </annotation>
 </semantics>
</math>

 with them. SPH then defines the value of 

<math display="inline" id="Meshfree_methods:16">
 <semantics>
  <mrow>
   <mi>u</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>u</ci>
    <interval closure="open">
     <ci>x</ci>
     <ci>t</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u(x,t)
  </annotation>
 </semantics>
</math>

 between the particles by</p>

<p>

<math display="block" id="Meshfree_methods:17">
 <semantics>
  <mrow>
   <mrow>
    <mi>u</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <msub>
      <mi>t</mi>
      <mi>n</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mi>i</mi>
    </munder>
    <mrow>
     <msub>
      <mi>m</mi>
      <mi>i</mi>
     </msub>
     <mfrac>
      <msubsup>
       <mi>u</mi>
       <mi>i</mi>
       <mi>n</mi>
      </msubsup>
      <msub>
       <mi>ρ</mi>
       <mi>i</mi>
      </msub>
     </mfrac>
     <mi>W</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mo stretchy="false">|</mo>
       <mrow>
        <mi>x</mi>
        <mo>-</mo>
        <msub>
         <mi>x</mi>
         <mi>i</mi>
        </msub>
       </mrow>
       <mo stretchy="false">|</mo>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>u</ci>
     <interval closure="open">
      <ci>x</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>t</ci>
       <ci>n</ci>
      </apply>
     </interval>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <ci>i</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>m</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <divide></divide>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>u</ci>
         <ci>i</ci>
        </apply>
        <ci>n</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ρ</ci>
        <ci>i</ci>
       </apply>
      </apply>
      <ci>W</ci>
      <apply>
       <abs></abs>
       <apply>
        <minus></minus>
        <ci>x</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>i</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u(x,t_{n})=\sum_{i}m_{i}\frac{u_{i}^{n}}{\rho_{i}}W(|x-x_{i}|)
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Meshfree_methods:18">
 <semantics>
  <msub>
   <mi>m</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>m</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m_{i}
  </annotation>
 </semantics>
</math>

 is the mass of particle 

<math display="inline" id="Meshfree_methods:19">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Meshfree_methods:20">
 <semantics>
  <msub>
   <mi>ρ</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ρ</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho_{i}
  </annotation>
 </semantics>
</math>

 is the density of particle 

<math display="inline" id="Meshfree_methods:21">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="Meshfree_methods:22">
 <semantics>
  <mi>W</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>W</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W
  </annotation>
 </semantics>
</math>

 is a kernel function that operates on nearby data points and is chosen for smoothness and other useful qualities. By linearity, we can write the spatial derivative as</p>

<p>

<math display="block" id="Meshfree_methods:23">
 <semantics>
  <mrow>
   <mfrac>
    <mrow>
     <mo>∂</mo>
     <mi>u</mi>
    </mrow>
    <mrow>
     <mo>∂</mo>
     <mi>x</mi>
    </mrow>
   </mfrac>
   <mo>=</mo>
   <mrow>
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mi>i</mi>
    </munder>
    <mrow>
     <msub>
      <mi>m</mi>
      <mi>i</mi>
     </msub>
     <mfrac>
      <msubsup>
       <mi>u</mi>
       <mi>i</mi>
       <mi>n</mi>
      </msubsup>
      <msub>
       <mi>ρ</mi>
       <mi>i</mi>
      </msub>
     </mfrac>
     <mfrac>
      <mrow>
       <mrow>
        <mo>∂</mo>
        <mi>W</mi>
       </mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mo stretchy="false">|</mo>
         <mrow>
          <mi>x</mi>
          <mo>-</mo>
          <msub>
           <mi>x</mi>
           <mi>i</mi>
          </msub>
         </mrow>
         <mo stretchy="false">|</mo>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mrow>
       <mo>∂</mo>
       <mi>x</mi>
      </mrow>
     </mfrac>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <divide></divide>
     <apply>
      <partialdiff></partialdiff>
      <ci>u</ci>
     </apply>
     <apply>
      <partialdiff></partialdiff>
      <ci>x</ci>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <ci>i</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>m</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <divide></divide>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>u</ci>
         <ci>i</ci>
        </apply>
        <ci>n</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ρ</ci>
        <ci>i</ci>
       </apply>
      </apply>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <apply>
         <partialdiff></partialdiff>
         <ci>W</ci>
        </apply>
        <apply>
         <abs></abs>
         <apply>
          <minus></minus>
          <ci>x</ci>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>x</ci>
           <ci>i</ci>
          </apply>
         </apply>
        </apply>
       </apply>
       <apply>
        <partialdiff></partialdiff>
        <ci>x</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\partial u\over\partial x}=\sum_{i}m_{i}\frac{u_{i}^{n}}{\rho_{i}}{\partial W%
(|x-x_{i}|)\over\partial x}
  </annotation>
 </semantics>
</math>

</p>

<p>Then we can use these definitions of 

<math display="inline" id="Meshfree_methods:24">
 <semantics>
  <mrow>
   <mi>u</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>u</ci>
    <interval closure="open">
     <ci>x</ci>
     <ci>t</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u(x,t)
  </annotation>
 </semantics>
</math>

 and its spatial derivatives to write the equation being simulated as an <a href="Differential_equation" title="wikilink">ordinary differential equation</a>, and simulate the equation with one of many <a href="Numerical_methods_for_ordinary_differential_equations" title="wikilink">numerical methods</a>. In physical terms, this means calculating the forces between the particles, then integrating these forces over time to determine their motion.</p>

<p>The advantage of SPH in this situation is that the formulae for 

<math display="inline" id="Meshfree_methods:25">
 <semantics>
  <mrow>
   <mi>u</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>u</ci>
    <interval closure="open">
     <ci>x</ci>
     <ci>t</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u(x,t)
  </annotation>
 </semantics>
</math>

 and its derivatives do not depend on any adjacency information about the particles; they can use the particles in any order, so it doesn't matter if the particles move around or even exchange places.</p>

<p>One disadvantage of SPH is that it requires extra programming to determine the nearest neighbors of a particle. Since the kernel function 

<math display="inline" id="Meshfree_methods:26">
 <semantics>
  <mi>W</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>W</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W
  </annotation>
 </semantics>
</math>

 only returns nonzero results for nearby particles within twice the "smoothing length" (because we typically choose kernel functions with <a href="Support_(mathematics)#Compact_support" title="wikilink">compact support</a>), it would be a waste of effort to calculate the summations above over every particle in a large simulation. So typically SPH simulators require some extra code to speed up this nearest neighbor calculation.</p>
<h2 id="history">History</h2>

<p>One of the earliest meshfree methods is <a href="smoothed_particle_hydrodynamics" title="wikilink">smoothed particle hydrodynamics</a>, presented in 1977.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> Over the ensuing decades, many more methods have been developed, some of which are listed below.</p>
<h2 id="list-of-methods-and-acronyms">List of methods and acronyms</h2>

<p>The following numerical methods are generally considered to fall within the general class of "meshfree" methods. Acronyms are provided in parentheses.</p>
<ul>
<li><a href="Smoothed_particle_hydrodynamics" title="wikilink">Smoothed particle hydrodynamics</a> (SPH) (1977)</li>
<li><a href="Diffuse_element_method" title="wikilink">Diffuse element method</a> (DEM) (1992)</li>
<li><a href="Dissipative_particle_dynamics" title="wikilink">Dissipative particle dynamics</a> (DPD) (1992)</li>
<li><a href="Element-free_Galerkin" title="wikilink">Element-free Galerkin</a> method (EFG / EFGM) (1994)</li>
<li>Reproducing kernel particle method (RKPM) (1995)</li>
<li><a href="Finite_pointset_method" title="wikilink">Finite pointset method</a> (FPM) (1998)</li>
<li><a class="uri" href="hp-clouds" title="wikilink">hp-clouds</a></li>
<li><a href="Natural_element_method" title="wikilink">Natural element method</a> (NEM)</li>
<li><a href="Material_point_method" title="wikilink">Material point method</a> (MPM)</li>
<li><a href="Meshless_local_Petrov_Galerkin" title="wikilink">Meshless local Petrov Galerkin</a> (MLPG)</li>
<li><a href="Moving_particle_semi-implicit" title="wikilink">Moving particle semi-implicit</a> (MPS)</li>
<li><a href="Generalized_finite_difference_method" title="wikilink">Generalized finite difference method</a> (GFDM)</li>
<li><a class="uri" href="Particle-in-cell" title="wikilink">Particle-in-cell</a> (PIC)</li>
<li><a href="Moving_particle_finite_element_method" title="wikilink">Moving particle finite element method</a> (MPFEM)</li>
<li><a href="Finite_cloud_method" title="wikilink">Finite cloud method</a> (FCM)</li>
<li><a href="Boundary_node_method" title="wikilink">Boundary node method</a> (BNM)</li>
<li><a href="Meshfree_moving_Kriging_interpolation_method" title="wikilink">Meshfree moving Kriging interpolation method</a> (MK)</li>
<li><a href="Boundary_cloud_method" title="wikilink">Boundary cloud method</a> (BCM)</li>
<li><a href="Method_of_fundamental_solution" title="wikilink">Method of fundamental solution</a>(MFS)</li>
<li><a href="Method_of_particular_solution" title="wikilink">Method of particular solution</a> (MPS)</li>
<li><a href="Method_of_finite_spheres" title="wikilink">Method of finite spheres</a> (MFS)</li>
<li><a href="Discrete_vortex_method" title="wikilink">Discrete vortex method</a> (DVM)</li>
<li><a href="Finite_mass_method" title="wikilink">Finite mass method</a> (FMM) (2000)<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></li>
<li><a href="Smoothed_point_interpolation_method" title="wikilink">Smoothed point interpolation method</a> (S-PIM) (2005).<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></li>
<li>Meshfree local <a href="radial_point_interpolation_method" title="wikilink">radial point interpolation method</a> (RPIM).<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></li>
<li>Local radial basis function collocation Method (LRBFCM)<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></li>
<li><a href="Viscous_vortex_domains_method" title="wikilink">Viscous vortex domains method</a> (VVD)</li>
<li><a href="Discrete_least_squares_meshless_method" title="wikilink">Discrete least squares meshless method</a> (DLSM) (2006)</li>
<li><a href="Repeated_replacement_method" title="wikilink">Repeated replacement method</a> (RRM) (2012)<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></li>
<li><a href="Radial_basis_integral_equation_method" title="wikilink">Radial basis integral equation method</a><a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></li>
</ul>

<p>Related methods:</p>
<ul>
<li><a href="Moving_least_squares" title="wikilink">Moving least squares</a> (MLS) – provide general approximation method for arbitrary set of nodes</li>
<li><a href="Partition_of_unity" title="wikilink">Partition of unity</a> methods (PoUM) – provide general approximation formulation used in some meshfree methods</li>
<li>Continuous blending method (enrichment and coupling of finite elements and meshless methods) – see </li>
<li><a href="Extended_finite_element_method" title="wikilink">eXtended FEM</a>, <a href="Generalized_finite_element_method" title="wikilink">Generalized FEM</a> (XFEM, GFEM) – variants of FEM (finite element method) combining some meshless aspects</li>
<li><a href="Smoothed_finite_element_method" title="wikilink">Smoothed finite element method</a> (S-FEM) (2007)</li>
<li><a href="Gradient_smoothing_method" title="wikilink">Gradient smoothing method</a> (GSM) (2008)</li>
<li>Local maximum-entropy (LME) – see </li>
<li>Space-Time Meshfree Collocation Method (STMCM) – see , </li>
</ul>
<h2 id="recent-development">Recent development</h2>

<p>One recent advance in meshfree methods aim at the development of computational tools for automation in modeling and simulations. This is enabled by the so-called weakened weak (W2) formulation based on the <a href="G_space" title="wikilink">G space</a> theory.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> The W2 formulation offers possibilities for formulate various (uniformly) "soft" models that works well with triangular meshes. Because triangular mesh can be generated automatically, it becomes much easier in re-meshing and hence automation in modeling and simulation. In addition, W2 models can be made soft enough (in uniform fashion) to produce upper bound solutions (for force-driving problems). Together with stiff models (such as the fully compatible FEM models), one can conveniently bound the solution from both sides. This allows easy error estimation for generally complicated problems, as long as a triangular mesh can be generated. Typical W2 models are the Smoothed Point Interpolation Methods (or S-PIM).<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> The S-PIM can be node-based (known as NS-PIM or LC-PIM),<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> edge-based (ES-PIM),<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> and cell-based (CS-PIM).<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> The NS-PIM was developed using the so-called SCNI technique.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> It was then discovered that NS-PIM is capable of producing upper bound solution and volumetric locking free.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a> The ES-PIM is found superior in accuracy, and CS-PIM behaves in between the NS-PIM and ES-PIM. Moreover, W2 formulations allow the use of polynomial and radial basis functions in the creation of shape functions (it accommodates the discontinuous displacement functions, as long as it is in G1 space), which opens further rooms for future developments.</p>

<p>The W2 formulation has also led to the development of combination of meshfree techniques with the well-developed FEM techniques, and one can now use triangular mesh with excellent accuracy and desired softness. A typical such a formulation is the so-called Smoothed Finite Element Method (or S-FEM) <a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a> The S-FEM is the linear version of S-PIM, but with most of the properties of the S-PIM and much simpler.</p>

<p>It is a general perception that meshfree methods are much more expensive than the FEM counterparts. The recent study has found however, the S-PIM and S-FEM can be much faster than the FEM counterparts.<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a><a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a></p>

<p>The S-PIM and S-FEM works well for solid mechanics problems. For [CFD] problems, the formulation can be simpler, via strong formulation. A Gradient Smoothing Methods (GSM) has also been developed recently for [CFD] problems, implementing the gradient smoothing idea in strong form.<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a><a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a> The GSM is similar to [FVM], but uses gradient smoothing operations exclusively in nested fashions, and is a general numerical method for PDEs.</p>

<p>Nodal integration has been proposed as a technique to use finite elements to emulate a meshfree behaviour.<a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a> However, the obstacle that must be overcome in using nodally integrated elements is that the quantities at nodal points are not continuous, and the nodes are shared among multiple elements.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Continuum_mechanics" title="wikilink">Continuum mechanics</a></li>
<li><a href="Smoothed_finite_element_method" title="wikilink">Smoothed finite element method</a><a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a></li>
<li><a href="G_space" title="wikilink">G space</a><a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a></li>
<li><a href="Weakened_weak_form" title="wikilink">Weakened weak form</a><a class="footnoteRef" href="#fn23" id="fnref23"><sup>23</sup></a></li>
<li><a href="Boundary_element_method" title="wikilink">Boundary element method</a></li>
<li><a href="Immersed_boundary_method" title="wikilink">Immersed boundary method</a></li>
<li><a href="Stencil_code" title="wikilink">Stencil code</a></li>
</ul>
<h2 id="references">References</h2>
<h2 id="further-reading">Further reading</h2>
<ul>
<li>Liu MB, Liu GR, Zong Z, AN OVERVIEW ON SMOOTHED PARTICLE HYDRODYNAMICS, INTERNATIONAL JOURNAL OF COMPUTATIONAL METHODS Vol. 5 Issue: 1, 135–188, 2008.</li>
<li>Liu, G.R., Liu, M.B. (2003). <em>Smoothed Particle Hydrodynamics, a meshfree and Particle Method</em>, World Scientific, ISBN 981-238-456-1.</li>
<li>

<p>. ISBN 0-9657001-8-6</p></li>
<li>

<p>.</p></li>
<li>Belytschko, T., Chen, J.S. (2007). <em>Meshfree and Particle Methods</em>, John Wiley and Sons Ltd. ISBN 0-470-84800-6</li>
<li>

<p>. ISBN 0-470-84699-2</p></li>
<li>Liu, G.R. 1st edn, 2002. <em>Mesh Free Methods</em>, CRC Press. ISBN 0-8493-1238-8.</li>
<li>Li, S., Liu, W.K. (2004). <em>Meshfree Particle Methods</em>, Berlin: Springer Verlag. ISBN 3-540-22256-1</li>
<li>

<p>.</p></li>
<li>

<p>ISBN 978-3-00-026744-4, also as <a href="http://netuzhylov.net/publications/publications.html">electronic ed.</a>.</p></li>
<li></li>
<li>Alhuri. Y, A. Naji, D. Ouazar and A. Taik. (2010). '' RBF Based Meshless Method for Large Scale Shallow Water Simulations: Experimental Validation'', Math. Model. Nat. Phenom, Vol. 5, No. 7, 2010, pp. 4–10.</li>
</ul>
<ul>
<li>P. L. Machado, R. M. S. de Oliveira, W. C. B. Souza, R. C. F. Araújo, M. E. L. Tostes, and C. Gonçalves. (2011). '' An Automatic Methodology for Obtaining Optimum Shape Factors for the Radial Point Interpolation Method'', Journal of Microwaves, Optoelectronics and Electromagnetic Applications, Vol. 10, No. 2, 2011, pp. 389-401.[<a class="uri" href="http://jmoe.org/download.php?file=13237150240.PDF&amp;nome">http://jmoe.org/download.php?file=13237150240.PDF&amp;nome;</a>;=Volume%2010%20-%20Number%202%20-%20An%20Automatic%20Methodology%20for%20Obtaining%20Optimum%20Shape%20Factors%20for%20the%20Radial%20Point%20Interpolation%20Method.pdf]</li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.scan-and-solve.com/">The first available commercial fully automated meshfree structural analysis solution</a></li>
<li><a href="http://www.nogrid.com/">The first available commercial meshfree CFD code</a></li>
<li><a href="http://meshfreemethods.blogspot.com/">The USACM blog on Meshfree Methods</a></li>
</ul>

<p>"</p>

<p><a href="Category:Numerical_analysis" title="wikilink">Category:Numerical analysis</a> <a href="Category:Numerical_differential_equations" title="wikilink">Category:Numerical differential equations</a> <a href="Category:Computational_fluid_dynamics" title="wikilink">Category:Computational fluid dynamics</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Gingold RA, Monaghan JJ (1977). Smoothed particle hydrodynamics – theory and application to non-spherical stars. Mon Not R Astron Soc 181:375–389<a href="#fnref1">↩</a></li>
<li id="fn2">C. Gauger, P. Leinen, H. Yserentant <a href="http://leinen.rz.uni-mannheim.de/Projekte/Finite%20Massen%20Methode/gly.pdf">The finite mass method</a>. SIAM J. Numer. Anal. 37 (2000), 176<a href="#fnref2">↩</a></li>
<li id="fn3"></li>
<li id="fn4"></li>
<li id="fn5">Sarler B, Vertnik R. Meshfree<a href="#fnref5">↩</a></li>
<li id="fn6">Walker WA (2012) <a href="http://www.plosone.org/article/info%3Adoi%2F10.1371%2Fjournal.pone.0039999">The Repeated Replacement Method: A Pure Lagrangian Meshfree Method for Computational Fluid Dynamics</a>. PLoS ONE 7(7): e39999. <a class="uri" href="doi:10.1371/journal.pone.0039999">doi:10.1371/journal.pone.0039999</a><a href="#fnref6">↩</a></li>
<li id="fn7">Ooi EH, Popov V (2012) An efficient implementation of the radial basis integral equation method. Engineering Analysis with Boundary Elements, 36: 716-726<a href="#fnref7">↩</a></li>
<li id="fn8">G.R. Liu. A G space theory and a weakened weak (W2) form for a unified formulation of compatible and incompatible methods: Part I theory and Part II applications to solid mechanics problems. International Journal for Numerical Methods in Engineering, 81: 1093–1126, 2010<a href="#fnref8">↩</a></li>
<li id="fn9">Liu, G.R. 2nd edn: 2009 <em>Mesh Free Methods</em>, CRC Press. 978-1-4200-8209-9<a href="#fnref9">↩</a></li>
<li id="fn10">Liu GR, Zhang GY, Dai KY, Wang YY, Zhong ZH, Li GY and Han X, A linearly conforming point interpolation method (LC-PIM) for 2D solid mechanics problems, International Journal of Computational Methods, 2(4): 645–665, 2005.<a href="#fnref10">↩</a></li>
<li id="fn11">G.R. Liu, G.R. Zhang. Edge-based Smoothed Point Interpolation Methods. International Journal of Computational Methods, 5(4): 621–646, 2008<a href="#fnref11">↩</a></li>
<li id="fn12">G.R. Liu, G.R. Zhang. A normed G space and weakened weak (W2) formulation of a cell-based Smoothed Point Interpolation Method. International Journal of Computational Methods, 6(1): 147–179, 2009<a href="#fnref12">↩</a></li>
<li id="fn13">Chen, J. S., Wu, C. T., Yoon, S. and You, Y. (2001). A stabilized conforming nodal integration for Galerkin mesh-free methods. Int. J. Numer. Meth. Eng. 50: 435–466.<a href="#fnref13">↩</a></li>
<li id="fn14">G. R. Liu and G. Y. Zhang. Upper bound solution to elasticity problems: A unique property of the linearly conforming point interpolation method (LC-PIM). International Journal for Numerical Methods in Engineering, 74: 1128–1161, 2008.<a href="#fnref14">↩</a></li>
<li id="fn15">Liu, G.R., 2010 <em>Smoothed Finite Element Methods</em>, CRC Press, ISBN 978-1-4398-2027-8.<a href="#fnref15">↩</a></li>
<li id="fn16"></li>
<li id="fn17"></li>
<li id="fn18">G. R. Liu, George X. Xu. A gradient smoothing method (GSM) for fluid dynamics problems. International Journal for Numerical Methods in Fluids, 58: 1101–1133, 2008.<a href="#fnref18">↩</a></li>
<li id="fn19">J. Zhang, G. R. Liu, K.Y. Lam, H. Li, G. Xu. A gradient smoothing method (GSM) based on strong form governing equation for adaptive analysis of solid mechanics problems. Finite Elements in Analysis and Design, 44: 889–909, 2008.<a href="#fnref19">↩</a></li>
<li id="fn20"><a href="#fnref20">↩</a></li>
<li id="fn21"></li>
<li id="fn22">Liu GR, ON G SPACE THEORY, INTERNATIONAL JOURNAL OF COMPUTATIONAL METHODS, Vol. 6 Issue: 2,257-289, 2009<a href="#fnref22">↩</a></li>
<li id="fn23"></li>
</ol>
</section>
</body>
</html>
