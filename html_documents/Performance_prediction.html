<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="165">Performance prediction</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Performance prediction</h1>
<hr/>

<p>In <a href="computer_science" title="wikilink">computer science</a>, <strong>performance prediction</strong> means to estimate the execution time or other performance factors (such as <a href="CPU_cache" title="wikilink">cache</a> misses) of a program on a given computer. It is being widely used for computer architects to evaluate new computer designs, for <a class="uri" href="compiler" title="wikilink">compiler</a> writers to explore new optimizations, and also for advanced developers to tune their programs.</p>

<p>There are many approaches to predict program 's performance on computers. They can be roughly divided into three major categories:</p>
<ul>
<li>simulation-based prediction</li>
<li>profile-based prediction</li>
<li>analytical modeling</li>
</ul>
<h2 id="simulation-based-prediction">Simulation-based prediction</h2>

<p>Performance data can be directly obtained from computer <a href="simulator" title="wikilink">simulators</a>, within which each instruction of the target program is actually dynamically executed given a particular input data set. Simulators can predict program's performance very accurately, but takes considerable time to handle large programs. Examples include the <a href="http://www2.warwick.ac.uk/fac/sci/dcs/research/hpsg/publications/pubs/fgcs2006.pdf">PACE</a> and <a href="http://pages.cs.wisc.edu/~wwt/">Wisconsin Wind Tunnel</a> simulators as well as the more recent <a href="http://www2.warwick.ac.uk/fac/sci/dcs/research/hpsg/publications/pubs/simutools09.pdf">WARPP</a> simulation toolkit which attempts to significantly reduce the time required for parallel system simulation.</p>

<p>Another approach, based on <a href="trace-based_simulation" title="wikilink">trace-based simulation</a> does not run every instruction, but runs a trace file which store important program events only. This approach loses some flexibility and accuracy compared to cycle-accurate simulation mentioned above but can be much faster. The generation of traces often consumes considerable amounts of storage space and can severely impact the runtime of applications if large amount of data are recorded during execution.</p>
<h2 id="profile-based-prediction">Profile-based prediction</h2>

<p>The classic approach of performance prediction treats a program as a set of <a href="basic_block" title="wikilink">basic blocks</a> connected by execution path. Thus the execution time of the whole program is the sum of execution time of each basic block multiplied by its execution frequency, as shown in the following formula:</p>

<p>

<math display="inline" id="Performance_prediction:0">
 <semantics>
  <mrow>
   <msub>
    <mi>T</mi>
    <mrow>
     <mi>p</mi>
     <mi>r</mi>
     <mi>o</mi>
     <mi>g</mi>
     <mi>r</mi>
     <mi>a</mi>
     <mi>m</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">âˆ‘</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>n</mi>
    </msubsup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>T</mi>
       <mrow>
        <mi>B</mi>
        <msub>
         <mi>B</mi>
         <mi>i</mi>
        </msub>
       </mrow>
      </msub>
      <mo>*</mo>
      <msub>
       <mi>F</mi>
       <mrow>
        <mi>B</mi>
        <msub>
         <mi>B</mi>
         <mi>i</mi>
        </msub>
       </mrow>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>T</ci>
     <apply>
      <times></times>
      <ci>p</ci>
      <ci>r</ci>
      <ci>o</ci>
      <ci>g</ci>
      <ci>r</ci>
      <ci>a</ci>
      <ci>m</ci>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>n</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>T</ci>
       <apply>
        <times></times>
        <ci>B</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>B</ci>
         <ci>i</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>F</ci>
       <apply>
        <times></times>
        <ci>B</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>B</ci>
         <ci>i</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T_{program}=\sum_{i=1}^{n}{(T_{BB_{i}}*F_{BB_{i}})}
  </annotation>
 </semantics>
</math>

</p>

<p>The execution frequencies of basic blocks are generated from a <a href="profiler_(computer_science)" title="wikilink">profiler</a>, which is why this method is called profile-based prediction. The execution time of a basic block is usually obtained from a simple instruction scheduler.</p>

<p>Classic profile-based prediction worked well for early single-issue, in-order execution processors, but fails to accurately predict the performance of modern processors. The major reason is that modern processors can issue and execute several instructions at the same time, sometimes out of the original order and cross the boundary of basic blocks.</p>

<p>"</p>

<p><a href="Category:Software_optimization" title="wikilink">Category:Software optimization</a></p>
</body>
</html>
