<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="17">Unicity distance</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Unicity distance</h1>
<hr/>

<p>In <a class="uri" href="cryptography" title="wikilink">cryptography</a>, <strong>unicity distance</strong> is the length of an original <a class="uri" href="ciphertext" title="wikilink">ciphertext</a> needed to break the cipher by reducing the number of possible <strong>spurious keys</strong> to zero in a <a href="brute_force_attack" title="wikilink">brute force attack</a>. That is, after trying every possible <a href="key_(cryptography)" title="wikilink">key</a>, there should be just one decipherment that makes sense, i.e. expected amount of ciphertext needed to determine the key completely, assuming the underlying message has redundancy.</p>

<p>Consider an attack on the ciphertext string "WNAIW" encrypted using a <a href="Vigenère_cipher" title="wikilink">Vigenère cipher</a> with a five letter key. Conceivably, this string could be deciphered into any other string — RIVER and WATER are both possibilities for certain keys. This is a general rule of <a class="uri" href="cryptanalysis" title="wikilink">cryptanalysis</a>: with no additional information it is impossible to decode this message.</p>

<p>Of course, even in this case, only a certain number of five letter keys will result in English words. Trying all possible keys we will not only get RIVER and WATER, but SXOOS and KHDOP as well. The number of "working" keys will likely be very much smaller than the set of all possible keys. The problem is knowing which of these "working" keys is the right one; the rest are spurious.</p>
<h2 id="relation-with-key-size-and-possible-plaintexts">Relation with key size and possible plaintexts</h2>

<p>In general, given particular assumptions about the size of the key and the number of possible messages, there is an average ciphertext length where there is only one key (on average) that will generate a readable message. In the example above we see only <a href="upper_case" title="wikilink">upper case</a> <a href="Latin_alphabet" title="wikilink">Roman</a> characters, so if we assume that the <a class="uri" href="plaintext" title="wikilink">plaintext</a> has this form, then there are 26 possible letters for each position in the string. Likewise if we assume five-character upper case keys, there are K=26<sup>5</sup> possible keys, of which the majority will not "work".</p>

<p>A tremendous number of possible messages, N, can be generated using even this limited set of characters: N = 26<sup>L</sup>, where L is the length of the message. However only a smaller set of them is readable <a class="uri" href="plaintext" title="wikilink">plaintext</a> due to the rules of the language, perhaps M of them, where M is likely to be very much smaller than N. Moreover M has a one-to-one relationship with the number of keys that work, so given K possible keys, only K × (M/N) of them will "work". One of these is the correct key, the rest are spurious.</p>

<p>Since M/N gets arbitrarily small as the length L of the message increases, there is eventually some L that is large enough to make the number of spurious keys equal to zero. Roughly speaking, this is the L that makes KM/N=1. This L is the unicity distance.</p>
<h2 id="relation-with-key-entropy-and-plaintext-redundancy">Relation with key entropy and plaintext redundancy</h2>

<p>The unicity distance can equivalently be defined as the minimum amount of ciphertext required to permit a computationally unlimited adversary to recover the unique encryption key.</p>

<p>The expected unicity distance can then be shown to be:</p>

<p>

<math display="block" id="Unicity_distance:0">
 <semantics>
  <mrow>
   <mi>U</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>H</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>k</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>/</mo>
    <mi>D</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>U</ci>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <ci>H</ci>
      <ci>k</ci>
     </apply>
     <ci>D</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U=H(k)/D
  </annotation>
 </semantics>
</math>

</p>

<p>where <em>U</em> is the unicity distance, <em>H</em>(<em>k</em>) is the entropy of the key space (e.g. 128 for 2<sup>128</sup> equiprobable keys, rather less if the key is a memorized pass-phrase). <em>D</em> is defined as the plaintext redundancy in bits per character.</p>

<p>Now an alphabet of 32 characters can carry 5 bits of information per character (as 32 = 2<sup>5</sup>). In general the number of bits of information per character is <mtpl></mtpl>, where <em>N</em> is the number of characters in the alphabet and <mtpl></mtpl> is the <a href="binary_logarithm" title="wikilink">binary logarithm</a>. So for English each character can convey <mtpl> 4.7}}</mtpl> bits of information.</p>

<p>However the average amount of actual information carried per character in meaningful English text is only about 1.5 bits per character. So the plain text redundancy is <em>D</em> = 4.7 − 1.5 = 3.2.</p>

<p>Basically the bigger the unicity distance the better. For a one time pad of unlimited size, given the unbounded entropy of the key space, we have 

<math display="inline" id="Unicity_distance:1">
 <semantics>
  <mrow>
   <mi>U</mi>
   <mo>=</mo>
   <mi mathvariant="normal">∞</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>U</ci>
    <infinity></infinity>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U=\infty
  </annotation>
 </semantics>
</math>

, which is consistent with the <a href="one-time_pad" title="wikilink">one-time pad</a> being theoretically unbreakable.</p>
<h3 id="unicity-distance-of-transposition-cipher">Unicity distance of transposition cipher</h3>

<p>For a simple <a href="substitution_cipher" title="wikilink">substitution cipher</a>, the number of possible keys is <mtpl> 4.0329 × 10<sup>26</sup> {{=}} 2<sup>88.4</sup>}}</mtpl>, the number of ways in which the alphabet can be permuted. Assuming all keys are equally likely, <mtpl> log<sub>2</sub>(26!) {{=}} 88.4}}</mtpl> bits. For English text 

<math display="inline" id="Unicity_distance:2">
 <semantics>
  <mrow>
   <mi>D</mi>
   <mo>=</mo>
   <mn>3.2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>D</ci>
    <cn type="float">3.2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D=3.2
  </annotation>
 </semantics>
</math>

, thus 

<math display="inline" id="Unicity_distance:3">
 <semantics>
  <mrow>
   <mi>U</mi>
   <mo>=</mo>
   <mrow>
    <mn>88.4</mn>
    <mo>/</mo>
    <mn>3.2</mn>
   </mrow>
   <mo>=</mo>
   <mn>28</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>U</ci>
     <apply>
      <divide></divide>
      <cn type="float">88.4</cn>
      <cn type="float">3.2</cn>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="integer">28</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U=88.4/3.2=28
  </annotation>
 </semantics>
</math>

.</p>

<p>So given 28 characters of ciphertext it should be theoretically possible to work out an English plaintext and hence the key.</p>
<h2 id="practical-application">Practical application</h2>

<p>Unicity distance is a useful theoretical measure, but it doesn't say much about the security of a block cipher when attacked by an adversary with real-world (limited) resources. Consider a block cipher with a unicity distance of three ciphertext blocks. Although there is clearly enough information for a computationally unbounded adversary to find the right key (simple exhaustive search), this may be computationally infeasible in practice.</p>

<p>The unicity distance can be increased by reducing the plaintext redundancy. One way to do this is to deploy data compression techniques prior to encryption, for example by removing redundant vowels while retaining readability. This is a good idea anyway, as it reduces the amount of data to be encrypted.</p>

<p>Another way to increase the unicity distance is to increase the number of possible valid sequences in the files as it is read. Since if for at least the first several blocks any bit pattern can effectively be part of a valid message then the unicity distance has not been reached. This is possible on long files when certain bijective string sorting permutations are used, such as the many variants of bijective <a href="Burrows–Wheeler_transform" title="wikilink">Burrows-Wheeler transforms</a>.</p>

<p>Ciphertexts greater than the unicity distance can be assumed to have only one meaningful decryption. Ciphertexts shorter than the unicity distance may have multiple plausible decryptions. Unicity distance is not a measure of how much ciphertext is required for cryptanalysis, but how much ciphertext is required for there to be only one reasonable solution for cryptanalysis.</p>
<h2 id="references">References</h2>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="Bruce_Schneier" title="wikilink">Bruce Schneier</a>: <a href="http://www.schneier.com/crypto-gram-9812.html#plaintext">How to Recognize Plaintext</a> (Crypto-Gram Newsletter December 15, 1998)</li>
<li><a href="http://www.practicalcryptography.com/cryptanalysis/text-characterisation/statistics/#unicity-distance">Unicity Distance computed for common ciphers</a></li>
</ul>

<p>"</p>

<p><a class="uri" href="Category:Cryptography" title="wikilink">Category:Cryptography</a> <a href="Category:Cryptographic_attacks" title="wikilink">Category:Cryptographic attacks</a> <a href="Category:Information_theory" title="wikilink">Category:Information theory</a></p>
</body>
</html>
