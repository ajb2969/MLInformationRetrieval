<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1562">Higher-order singular value decomposition</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Higher-order singular value decomposition</h1>
<hr/>

<p>In <a href="multilinear_algebra" title="wikilink">multilinear algebra</a>, there does not exist a general decomposition method for multi-way arrays (also known as <em>N-arrays</em>, <em>higher-order arrays</em>, or <em>data-tensors</em>) with all the properties of a matrix <a href="singular_value_decomposition" title="wikilink">singular value decomposition</a> (SVD). A matrix SVD simultaneously computes</p>
<dl>
<dd>(a) a rank-<em>R</em> decomposition and
</dd>
</dl>
<dl>
<dd>(b) the orthonormal row/column matrices.
</dd>
</dl>

<p>These two properties can be captured separately by two different decompositions for multi-way <a href="matrix_(mathematics)" title="wikilink">arrays</a>.</p>

<p>Property (a) is extended to higher order by a class of closely related constructions known collectively as <a href="CP_decomposition" title="wikilink">CP decomposition</a> (named after the two most popular and general variants, CANDECOMP and PARAFAC). Such decompositions represent a tensor as the sum of the n-fold outer products of rank-1 tensors, where n is the dimension of the tensor indices.</p>

<p>Property (b) is extended to higher order by a class of methods known variably as <em><a href="Tucker_decomposition" title="wikilink">Tucker3</a></em>, <em>N-mode SVD</em>, and <em>N-mode <a href="principal_component_analysis" title="wikilink">principal component analysis</a></em> (PCA). (This article will use the general term "Tucker decomposition".) These methods compute the orthonormal spaces associated with the different axes (or modes) of a tensor. The Tucker decomposition is also used in <a href="multilinear_subspace_learning" title="wikilink">multilinear subspace learning</a> as <a href="multilinear_principal_component_analysis" title="wikilink">multilinear principal component analysis</a>. This terminology was coined by P. Kroonenberg in the 1980s, but it was later called <em>multilinear SVD</em> and <em><a class="uri" href="HOSVD" title="wikilink">HOSVD</a></em> (higher-order SVD) by L. De Lathauwer.</p>

<p>Historically, much of the interest in higher-order SVDs was driven by the need to analyze empirical data, especially in <a class="uri" href="psychometrics" title="wikilink">psychometrics</a> and <a class="uri" href="chemometrics" title="wikilink">chemometrics</a>. As such, many of the methods have been independently invented several times, often with subtle variations, leading to a confusing literature. Abstract and general mathematical theorems are rare (though see Kruskal<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> with regard to the CP decomposition); instead, the methods are often designed for analyzing specific data types. The 2008 review article by Kolda and Bader<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> provides a compact summary of the history of these decompositions, and many references for further reading.</p>

<p>The concept of HOSVD was carried over to functions by Baranyi and Yam via the <a href="TP_model_transformation" title="wikilink">TP model transformation</a> <a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> .<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> This extension led to the definition of the HOSVD based canonical form of tensor product functions and Linear Parameter Varying system models <a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> and to convex hull manipulation based control optimization theory, see <a href="TP_model_transformation_in_control_theories" title="wikilink">TP model transformation in control theories</a>.</p>
<h2 id="cp-decomposition">CP decomposition</h2>
<h3 id="definition">Definition</h3>

<p>A CP decomposition of an N-way array <em>X</em>, with elements 

<math display="inline" id="Higher-order_singular_value_decomposition:0">
 <semantics>
  <msub>
   <mi>x</mi>
   <mrow>
    <msub>
     <mi>i</mi>
     <mn>1</mn>
    </msub>
    <mi mathvariant="normal">⋯</mi>
    <msub>
     <mi>i</mi>
     <mi>N</mi>
    </msub>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>i</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-⋯</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>i</ci>
      <ci>N</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i_{1}\cdots i_{N}}
  </annotation>
 </semantics>
</math>

, is</p>

<p>

<math display="block" id="Higher-order_singular_value_decomposition:1">
 <semantics>
  <mrow>
   <mi>X</mi>
   <mo>=</mo>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>r</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>R</mi>
    </munderover>
    <msup>
     <mi>D</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>r</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </msup>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>r</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>R</mi>
    </munderover>
    <mrow>
     <msup>
      <mi>a</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>r</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </msup>
     <mo>⊗</mo>
     <mi mathvariant="normal">⋯</mi>
     <mo>⊗</mo>
     <msup>
      <mi>z</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>r</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </msup>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>X</ci>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>r</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>R</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>D</ci>
       <ci>r</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>r</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>R</ci>
      </apply>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>a</ci>
        <ci>r</ci>
       </apply>
       <ci>normal-⋯</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>z</ci>
        <ci>r</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X=\sum_{r=1}^{R}D^{(r)}=\sum_{r=1}^{R}a^{(r)}\otimes\cdots\otimes z^{(r)}
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Higher-order_singular_value_decomposition:2">
 <semantics>
  <mo>⊗</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">tensor-product</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \otimes
  </annotation>
 </semantics>
</math>

 denotes the <a href="tensor_product" title="wikilink">tensor product</a>. The <em>R</em> tensors 

<math display="inline" id="Higher-order_singular_value_decomposition:3">
 <semantics>
  <msup>
   <mi>D</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>r</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>D</ci>
    <ci>r</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D^{(r)}
  </annotation>
 </semantics>
</math>

 (known as <em>simple tensors</em>, <em>rank-1 tensors</em>, <em>dyads</em>, or, in <a href="quantum_mechanics" title="wikilink">quantum mechanics</a>, <em>product states</em>) are constructed from the <em>rN</em> vectors 

<math display="inline" id="Higher-order_singular_value_decomposition:4">
 <semantics>
  <mrow>
   <msup>
    <mi>a</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>r</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </msup>
   <mo>,</mo>
   <mi mathvariant="normal">⋯</mi>
   <mo>,</mo>
   <msup>
    <mi>z</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>r</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>a</ci>
     <ci>r</ci>
    </apply>
    <ci>normal-⋯</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>z</ci>
     <ci>r</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a^{(r)},\cdots,z^{(r)}
  </annotation>
 </semantics>
</math>

. With indices, this is</p>

<p>

<math display="block" id="Higher-order_singular_value_decomposition:5">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mrow>
     <msub>
      <mi>i</mi>
      <mn>1</mn>
     </msub>
     <mi mathvariant="normal">⋯</mi>
     <msub>
      <mi>i</mi>
      <mi>N</mi>
     </msub>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>r</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>R</mi>
    </munderover>
    <mrow>
     <msubsup>
      <mi>a</mi>
      <msub>
       <mi>i</mi>
       <mn>1</mn>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>r</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </msubsup>
     <mi mathvariant="normal">⋯</mi>
     <msubsup>
      <mi>z</mi>
      <msub>
       <mi>i</mi>
       <mi>N</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>r</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </msubsup>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>i</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-⋯</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>i</ci>
       <ci>N</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>r</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>R</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>a</ci>
        <ci>r</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>normal-⋯</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>z</ci>
        <ci>r</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>i</ci>
        <ci>N</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i_{1}\cdots i_{N}}=\sum_{r=1}^{R}a^{(r)}_{i_{1}}\cdots z^{(r)}_{i_{N}}
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Higher-order_singular_value_decomposition:6">
 <semantics>
  <msubsup>
   <mi>a</mi>
   <mi>i</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>r</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>a</ci>
     <ci>r</ci>
    </apply>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a^{(r)}_{i}
  </annotation>
 </semantics>
</math>

 is the <em>i</em>-th element of the vector 

<math display="inline" id="Higher-order_singular_value_decomposition:7">
 <semantics>
  <msup>
   <mi>a</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>r</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>a</ci>
    <ci>r</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a^{(r)}
  </annotation>
 </semantics>
</math>

, etc.</p>
<h2 id="tucker-decomposition">Tucker decomposition</h2>
<h3 id="history">History</h3>

<p>In 1966, <a href="L._Tucker" title="wikilink">L. Tucker</a> proposed a decomposition method for three-way arrays (referred to as a 3-mode "<a href="tensor" title="wikilink">tensors</a>") as a multidimensional extension of <a href="factor_analysis" title="wikilink">factor analysis</a>.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> This decomposition was further developed in the 1980s by P. Kroonenberg, who coined the terms Tucker3, Tucker3ALS (an alternating least squares dimensionality reduction algorithm), 3-Mode SVD, and 3-Mode PCA.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> In the intervening years, several authors developed the decomposition for <em>N</em>-way arrays. Most recently, this work was treated in an elegant fashion and introduced to the SIAM community by L. De Lathauwer et al. who referred to the decomposition as an <em>N</em>-way SVD, multilinear SVD and HOSVD.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></p>
<h3 id="definitions">Definitions</h3>

<p>Let the SVD of a real matrix be 

<math display="inline" id="Higher-order_singular_value_decomposition:8">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>=</mo>
   <mrow>
    <mi>U</mi>
    <mi>S</mi>
    <msup>
     <mi>V</mi>
     <mi>T</mi>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>A</ci>
    <apply>
     <times></times>
     <ci>U</ci>
     <ci>S</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>V</ci>
      <ci>T</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A=USV^{T}
  </annotation>
 </semantics>
</math>

, then it can be written in an elementwise form as</p>

<p>

<math display="block" id="Higher-order_singular_value_decomposition:9">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>a</mi>
     <mrow>
      <msub>
       <mi>i</mi>
       <mn>1</mn>
      </msub>
      <mo>,</mo>
      <msub>
       <mi>i</mi>
       <mn>2</mn>
      </msub>
     </mrow>
    </msub>
    <mo>=</mo>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <msub>
       <mi>j</mi>
       <mn>1</mn>
      </msub>
     </munder>
     <mrow>
      <munder>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <msub>
        <mi>j</mi>
        <mn>2</mn>
       </msub>
      </munder>
      <mrow>
       <msub>
        <mi>s</mi>
        <mrow>
         <msub>
          <mi>j</mi>
          <mn>1</mn>
         </msub>
         <mo>,</mo>
         <msub>
          <mi>j</mi>
          <mn>2</mn>
         </msub>
        </mrow>
       </msub>
       <msub>
        <mi>u</mi>
        <mrow>
         <msub>
          <mi>i</mi>
          <mn>1</mn>
         </msub>
         <mo>,</mo>
         <msub>
          <mi>j</mi>
          <mn>1</mn>
         </msub>
        </mrow>
       </msub>
       <msub>
        <mi>v</mi>
        <mrow>
         <msub>
          <mi>i</mi>
          <mn>2</mn>
         </msub>
         <mo>,</mo>
         <msub>
          <mi>j</mi>
          <mn>2</mn>
         </msub>
        </mrow>
       </msub>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <list>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>i</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>i</ci>
       <cn type="integer">2</cn>
      </apply>
     </list>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>j</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>j</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>s</ci>
        <list>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>j</ci>
          <cn type="integer">1</cn>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>j</ci>
          <cn type="integer">2</cn>
         </apply>
        </list>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>u</ci>
        <list>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>i</ci>
          <cn type="integer">1</cn>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>j</ci>
          <cn type="integer">1</cn>
         </apply>
        </list>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>v</ci>
        <list>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>i</ci>
          <cn type="integer">2</cn>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>j</ci>
          <cn type="integer">2</cn>
         </apply>
        </list>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{i_{1},i_{2}}=\sum_{j_{1}}\sum_{j_{2}}s_{j_{1},j_{2}}u_{i_{1},j_{1}}v_{i_{2}%
,j_{2}}.
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Higher-order_singular_value_decomposition:10">
 <semantics>
  <mi>U</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>U</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Higher-order_singular_value_decomposition:11">
 <semantics>
  <mi>V</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>V</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V
  </annotation>
 </semantics>
</math>

 give, in a certain sense optimal, orthonormal basis for the column and row space, 

<math display="inline" id="Higher-order_singular_value_decomposition:12">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 is diagonal with decreasing elements. The higher-order singular value decomposition (HOSVD) can be defined by the multidimensional generalization of this concept:</p>

<p>

<math display="block" id="Higher-order_singular_value_decomposition:13">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>a</mi>
     <mrow>
      <msub>
       <mi>i</mi>
       <mn>1</mn>
      </msub>
      <mo>,</mo>
      <msub>
       <mi>i</mi>
       <mn>2</mn>
      </msub>
      <mo>,</mo>
      <mi mathvariant="normal">…</mi>
      <mo>,</mo>
      <msub>
       <mi>i</mi>
       <mi>N</mi>
      </msub>
     </mrow>
    </msub>
    <mo>=</mo>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <msub>
       <mi>j</mi>
       <mn>1</mn>
      </msub>
     </munder>
     <mrow>
      <munder>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <msub>
        <mi>j</mi>
        <mn>2</mn>
       </msub>
      </munder>
      <mrow>
       <mi mathvariant="normal">⋯</mi>
       <mrow>
        <munder>
         <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
         <msub>
          <mi>j</mi>
          <mi>N</mi>
         </msub>
        </munder>
        <mrow>
         <msub>
          <mi>s</mi>
          <mrow>
           <msub>
            <mi>j</mi>
            <mn>1</mn>
           </msub>
           <mo>,</mo>
           <msub>
            <mi>j</mi>
            <mn>2</mn>
           </msub>
           <mo>,</mo>
           <mi mathvariant="normal">…</mi>
           <mo>,</mo>
           <msub>
            <mi>j</mi>
            <mi>N</mi>
           </msub>
          </mrow>
         </msub>
         <msubsup>
          <mi>u</mi>
          <mrow>
           <msub>
            <mi>i</mi>
            <mn>1</mn>
           </msub>
           <mo>,</mo>
           <msub>
            <mi>j</mi>
            <mn>1</mn>
           </msub>
          </mrow>
          <mrow>
           <mo stretchy="false">(</mo>
           <mn>1</mn>
           <mo stretchy="false">)</mo>
          </mrow>
         </msubsup>
         <msubsup>
          <mi>u</mi>
          <mrow>
           <msub>
            <mi>i</mi>
            <mn>2</mn>
           </msub>
           <mo>,</mo>
           <msub>
            <mi>j</mi>
            <mn>2</mn>
           </msub>
          </mrow>
          <mrow>
           <mo stretchy="false">(</mo>
           <mn>2</mn>
           <mo stretchy="false">)</mo>
          </mrow>
         </msubsup>
         <mi mathvariant="normal">…</mi>
         <msubsup>
          <mi>u</mi>
          <mrow>
           <msub>
            <mi>i</mi>
            <mi>N</mi>
           </msub>
           <mo>,</mo>
           <msub>
            <mi>j</mi>
            <mi>N</mi>
           </msub>
          </mrow>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>N</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </msubsup>
        </mrow>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <list>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>i</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>i</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>i</ci>
       <ci>N</ci>
      </apply>
     </list>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>j</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>j</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>normal-⋯</ci>
       <apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>j</ci>
          <ci>N</ci>
         </apply>
        </apply>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>s</ci>
          <list>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>j</ci>
            <cn type="integer">1</cn>
           </apply>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>j</ci>
            <cn type="integer">2</cn>
           </apply>
           <ci>normal-…</ci>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>j</ci>
            <ci>N</ci>
           </apply>
          </list>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>u</ci>
           <cn type="integer">1</cn>
          </apply>
          <list>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>i</ci>
            <cn type="integer">1</cn>
           </apply>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>j</ci>
            <cn type="integer">1</cn>
           </apply>
          </list>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>u</ci>
           <cn type="integer">2</cn>
          </apply>
          <list>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>i</ci>
            <cn type="integer">2</cn>
           </apply>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>j</ci>
            <cn type="integer">2</cn>
           </apply>
          </list>
         </apply>
         <ci>normal-…</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>u</ci>
           <ci>N</ci>
          </apply>
          <list>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>i</ci>
            <ci>N</ci>
           </apply>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>j</ci>
            <ci>N</ci>
           </apply>
          </list>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{i_{1},i_{2},\dots,i_{N}}=\sum_{j_{1}}\sum_{j_{2}}\cdots\sum_{j_{N}}s_{j_{1}%
,j_{2},\dots,j_{N}}u^{(1)}_{i_{1},j_{1}}u^{(2)}_{i_{2},j_{2}}\dots u^{(N)}_{i_%
{N},j_{N}},
  </annotation>
 </semantics>
</math>

</p>

<p>where the 

<math display="inline" id="Higher-order_singular_value_decomposition:14">
 <semantics>
  <mrow>
   <msup>
    <mi>U</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </msup>
   <mo>=</mo>
   <msub>
    <mrow>
     <mo stretchy="false">[</mo>
     <msubsup>
      <mi>u</mi>
      <mrow>
       <mi>i</mi>
       <mo>,</mo>
       <mi>j</mi>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>n</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </msubsup>
     <mo stretchy="false">]</mo>
    </mrow>
    <mrow>
     <msub>
      <mi>I</mi>
      <mi>n</mi>
     </msub>
     <mo>×</mo>
     <msub>
      <mi>I</mi>
      <mi>n</mi>
     </msub>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>U</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>u</ci>
        <ci>n</ci>
       </apply>
       <list>
        <ci>i</ci>
        <ci>j</ci>
       </list>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>I</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>I</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U^{(n)}=[u^{(n)}_{i,j}]_{I_{n}\times I_{n}}
  </annotation>
 </semantics>
</math>

 matrices and the 

<math display="inline" id="Higher-order_singular_value_decomposition:15">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">𝒮</mi>
   <mo>=</mo>
   <msub>
    <mrow>
     <mo stretchy="false">[</mo>
     <msub>
      <mi>s</mi>
      <mrow>
       <msub>
        <mi>j</mi>
        <mn>1</mn>
       </msub>
       <mo>,</mo>
       <mi mathvariant="normal">…</mi>
       <mo>,</mo>
       <msub>
        <mi>j</mi>
        <mi>N</mi>
       </msub>
      </mrow>
     </msub>
     <mo stretchy="false">]</mo>
    </mrow>
    <mrow>
     <msub>
      <mi>I</mi>
      <mn>1</mn>
     </msub>
     <mo>×</mo>
     <msub>
      <mi>I</mi>
      <mn>2</mn>
     </msub>
     <mo>×</mo>
     <mi mathvariant="normal">⋯</mi>
     <mo>×</mo>
     <msub>
      <mi>I</mi>
      <mi>N</mi>
     </msub>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>𝒮</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>s</ci>
       <list>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>j</ci>
         <cn type="integer">1</cn>
        </apply>
        <ci>normal-…</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>j</ci>
         <ci>N</ci>
        </apply>
       </list>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>I</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>I</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-⋯</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>I</ci>
       <ci>N</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{S}=[s_{j_{1},\dots,j_{N}}]_{I_{1}\times I_{2}\times\cdots\times I_{N}}
  </annotation>
 </semantics>
</math>

 core tensor should satisfy certain requirements (similar ones to the matrix SVD), namely</p>
<ul>
<li>Each 

<math display="inline" id="Higher-order_singular_value_decomposition:16">
 <semantics>
  <msup>
   <mi>U</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>U</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U^{(n)}
  </annotation>
 </semantics>
</math>

 is an <a href="orthogonal_matrix" title="wikilink">orthogonal matrix</a>.</li>
<li>Two subtensors of the core tensor 

<math display="inline" id="Higher-order_singular_value_decomposition:17">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒮</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒮</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{S}
  </annotation>
 </semantics>
</math>

 are orthogonal i.e., 

<math display="inline" id="Higher-order_singular_value_decomposition:18">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <msub>
     <mi class="ltx_font_mathcaligraphic">𝒮</mi>
     <mrow>
      <msub>
       <mi>i</mi>
       <mi>n</mi>
      </msub>
      <mo>=</mo>
      <mi>p</mi>
     </mrow>
    </msub>
    <mo>,</mo>
    <msub>
     <mi class="ltx_font_mathcaligraphic">𝒮</mi>
     <mrow>
      <msub>
       <mi>i</mi>
       <mi>n</mi>
      </msub>
      <mo>=</mo>
      <mi>q</mi>
     </mrow>
    </msub>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <list>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝒮</ci>
      <apply>
       <eq></eq>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>i</ci>
        <ci>n</ci>
       </apply>
       <ci>p</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝒮</ci>
      <apply>
       <eq></eq>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>i</ci>
        <ci>n</ci>
       </apply>
       <ci>q</ci>
      </apply>
     </apply>
    </list>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle\mathcal{S}_{i_{n}=p},\mathcal{S}_{i_{n}=q}\rangle=0
  </annotation>
 </semantics>
</math>

 if 

<math display="inline" id="Higher-order_singular_value_decomposition:19">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mo>≠</mo>
   <mi>q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <neq></neq>
    <ci>p</ci>
    <ci>q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\neq q
  </annotation>
 </semantics>
</math>

.</li>
<li>The subtensors in the core tensor 

<math display="inline" id="Higher-order_singular_value_decomposition:20">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒮</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒮</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{S}
  </annotation>
 </semantics>
</math>

 are ordered according to their <a href="Frobenius_norm" title="wikilink">Frobenius norm</a>, i.e. 

<math display="inline" id="Higher-order_singular_value_decomposition:21">
 <semantics>
  <mrow>
   <mrow>
    <mo>∥</mo>
    <msub>
     <mi class="ltx_font_mathcaligraphic">𝒮</mi>
     <mrow>
      <msub>
       <mi>i</mi>
       <mi>n</mi>
      </msub>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo>∥</mo>
   </mrow>
   <mo>≥</mo>
   <mrow>
    <mo>∥</mo>
    <msub>
     <mi class="ltx_font_mathcaligraphic">𝒮</mi>
     <mrow>
      <msub>
       <mi>i</mi>
       <mi>n</mi>
      </msub>
      <mo>=</mo>
      <mn>2</mn>
     </mrow>
    </msub>
    <mo>∥</mo>
   </mrow>
   <mo>≥</mo>
   <mi mathvariant="normal">…</mi>
   <mo>≥</mo>
   <mrow>
    <mo>∥</mo>
    <msub>
     <mi class="ltx_font_mathcaligraphic">𝒮</mi>
     <mrow>
      <msub>
       <mi>i</mi>
       <mi>n</mi>
      </msub>
      <mo>=</mo>
      <msub>
       <mi>I</mi>
       <mi>n</mi>
      </msub>
     </mrow>
    </msub>
    <mo>∥</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <geq></geq>
     <apply>
      <csymbol cd="latexml">norm</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝒮</ci>
       <apply>
        <eq></eq>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>i</ci>
         <ci>n</ci>
        </apply>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">norm</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝒮</ci>
       <apply>
        <eq></eq>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>i</ci>
         <ci>n</ci>
        </apply>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <geq></geq>
     <share href="#.cmml">
     </share>
     <ci>normal-…</ci>
    </apply>
    <apply>
     <geq></geq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="latexml">norm</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝒮</ci>
       <apply>
        <eq></eq>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>i</ci>
         <ci>n</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>I</ci>
         <ci>n</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \|\mathcal{S}_{i_{n}=1}\|\geq\|\mathcal{S}_{i_{n}=2}\|\geq\dots\geq\|\mathcal{%
S}_{i_{n}=I_{n}}\|
  </annotation>
 </semantics>
</math>

 for <em>n</em> = 1, ..., <em>N</em>.</li>
</ul>

<p>Notation:</p>

<p>

<math display="block" id="Higher-order_singular_value_decomposition:22">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">𝒜</mi>
   <mo>=</mo>
   <mrow>
    <mi class="ltx_font_mathcaligraphic">𝒮</mi>
    <msubsup>
     <mo>×</mo>
     <mrow>
      <mi>n</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>N</mi>
    </msubsup>
    <msup>
     <mi>U</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>𝒜</ci>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <times></times>
       <apply>
        <eq></eq>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>N</ci>
     </apply>
     <ci>𝒮</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>U</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{A}=\mathcal{S}\times_{n=1}^{N}U^{(n)}
  </annotation>
 </semantics>
</math>

</p>
<h3 id="algorithm">Algorithm</h3>

<p>The HOSVD can be built from several SVDs, as follows:<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></p>
<ol>
<li>Given a tensor 

<math display="inline" id="Higher-order_singular_value_decomposition:23">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">𝒜</mi>
   <mo>∈</mo>
   <msup>
    <mi>ℝ</mi>
    <mrow>
     <msub>
      <mi>I</mi>
      <mn>1</mn>
     </msub>
     <mo>×</mo>
     <msub>
      <mi>I</mi>
      <mn>2</mn>
     </msub>
     <mo>×</mo>
     <mi mathvariant="normal">⋯</mi>
     <mo>×</mo>
     <msub>
      <mi>I</mi>
      <mi>N</mi>
     </msub>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>𝒜</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ℝ</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>I</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>I</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-⋯</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>I</ci>
       <ci>N</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{A}\in\mathbb{R}^{I_{1}\times I_{2}\times\cdots\times I_{N}}
  </annotation>
 </semantics>
</math>

, construct the mode-<em>k</em> flattening 

<math display="inline" id="Higher-order_singular_value_decomposition:24">
 <semantics>
  <msub>
   <mi class="ltx_font_mathcaligraphic">𝒜</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>k</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝒜</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{A}_{(k)}
  </annotation>
 </semantics>
</math>

. That is, the 

<math display="inline" id="Higher-order_singular_value_decomposition:25">
 <semantics>
  <mrow>
   <msub>
    <mi>I</mi>
    <mi>k</mi>
   </msub>
   <mo>×</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msub>
      <mo largeop="true" symmetric="true">∏</mo>
      <mrow>
       <mi>j</mi>
       <mo>≠</mo>
       <mi>k</mi>
      </mrow>
     </msub>
     <msub>
      <mi>I</mi>
      <mi>j</mi>
     </msub>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>I</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">product</csymbol>
      <apply>
       <neq></neq>
       <ci>j</ci>
       <ci>k</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>I</ci>
      <ci>j</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I_{k}\times(\prod_{j\neq k}I_{j})
  </annotation>
 </semantics>
</math>

 matrix that corresponds to 

<math display="inline" id="Higher-order_singular_value_decomposition:26">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒜</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒜</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{A}
  </annotation>
 </semantics>
</math>

.</li>
<li>Compute the <a href="singular_value_decomposition" title="wikilink">singular value decomposition</a> 

<math display="inline" id="Higher-order_singular_value_decomposition:27">
 <semantics>
  <mrow>
   <msub>
    <mi class="ltx_font_mathcaligraphic">𝒜</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>k</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>U</mi>
     <mi>k</mi>
    </msub>
    <msub>
     <mi mathvariant="normal">Σ</mi>
     <mi>k</mi>
    </msub>
    <msubsup>
     <mi>V</mi>
     <mi>k</mi>
     <mi>T</mi>
    </msubsup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝒜</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>U</ci>
      <ci>k</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-Σ</ci>
      <ci>k</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>V</ci>
       <ci>T</ci>
      </apply>
      <ci>k</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{A}_{(k)}=U_{k}\Sigma_{k}V^{T}_{k}
  </annotation>
 </semantics>
</math>

, and store the left singular vectors 

<math display="inline" id="Higher-order_singular_value_decomposition:28">
 <semantics>
  <msub>
   <mi>U</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>U</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U_{k}
  </annotation>
 </semantics>
</math>

.</li>
<li>The core tensor 

<math display="inline" id="Higher-order_singular_value_decomposition:29">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒮</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒮</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{S}
  </annotation>
 </semantics>
</math>

 is then the projection of 

<math display="inline" id="Higher-order_singular_value_decomposition:30">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒜</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒜</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{A}
  </annotation>
 </semantics>
</math>

 onto the tensor basis formed by the factor matrices 

<math display="inline" id="Higher-order_singular_value_decomposition:31">
 <semantics>
  <msubsup>
   <mrow>
    <mo stretchy="false">{</mo>
    <msub>
     <mi>U</mi>
     <mi>n</mi>
    </msub>
    <mo stretchy="false">}</mo>
   </mrow>
   <mrow>
    <mi>n</mi>
    <mo>=</mo>
    <mn>1</mn>
   </mrow>
   <mi>N</mi>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <set>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>U</ci>
       <ci>n</ci>
      </apply>
     </set>
     <apply>
      <eq></eq>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{U_{n}\}_{n=1}^{N}
  </annotation>
 </semantics>
</math>

, i.e., 

<math display="inline" id="Higher-order_singular_value_decomposition:32">
 <semantics>
  <mrow>
   <mrow>
    <mi class="ltx_font_mathcaligraphic">𝒮</mi>
    <mo>=</mo>
    <mrow>
     <mi class="ltx_font_mathcaligraphic">𝒜</mi>
     <msubsup>
      <mo>×</mo>
      <mrow>
       <mi>n</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>N</mi>
     </msubsup>
     <msubsup>
      <mi>U</mi>
      <mi>n</mi>
      <mi>T</mi>
     </msubsup>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>𝒮</ci>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <times></times>
       <apply>
        <eq></eq>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>N</ci>
     </apply>
     <ci>𝒜</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>U</ci>
       <ci>n</ci>
      </apply>
      <ci>T</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{S}=\mathcal{A}\times_{n=1}^{N}U_{n}^{T}.
  </annotation>
 </semantics>
</math>

</li>
</ol>
<h2 id="applications">Applications</h2>

<p>Main applications are extracting relevant information from multi-way arrays. Used in factor analysis, face recognition (<a class="uri" href="TensorFaces" title="wikilink">TensorFaces</a>), human motion analysis and synthesis.</p>

<p>The HOSVD has been successfully applied to signal processing and big data, e.g., in genomic signal processing.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a><a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a><a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> These applications also inspired a higher-order GSVD (HO GSVD)<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> and a tensor GSVD.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a></p>

<p>A combination of HOSVD and SVD also has been applied for real time event detection from complex data streams (multivariate data with space and time dimensions) in <a href="Disease_surveillance" title="wikilink">Disease surveillance</a>.<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a></p>

<p>It is also used in <a href="tensor_product_model_transformation" title="wikilink">tensor product model transformation</a>-based controller design.<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a><a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a> In <a href="multilinear_subspace_learning" title="wikilink">multilinear subspace learning</a>,<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a> it is modified to <a href="multilinear_principal_component_analysis" title="wikilink">multilinear principal component analysis</a><a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a> for gait recognition.</p>

<p>In machine learning, the CP-decomposition is the central ingredient in learning probabilistic latent variables models via the technique of moment-matching. For example, let us consider the multi-view model<a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a> which is a probabilistic latent variable model. In this model, we posit the generation of samples as follows: there exists a hidden random variable that is not observed directly, given which, there are several <a href="conditionally_independent" title="wikilink">conditionally independent</a> random variables known as the different "views" of the hidden variable. For simplicity, let us say we have three symmetrical views 

<math display="inline" id="Higher-order_singular_value_decomposition:33">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 of a 

<math display="inline" id="Higher-order_singular_value_decomposition:34">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

-state categorical hidden variable 

<math display="inline" id="Higher-order_singular_value_decomposition:35">
 <semantics>
  <mi>h</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>h</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h
  </annotation>
 </semantics>
</math>

. Then the empirical third moment of this latent variable model can be written as: 

<math display="inline" id="Higher-order_singular_value_decomposition:36">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mo>=</mo>
   <msubsup>
    <mo largeop="true" symmetric="true">∑</mo>
    <mrow>
     <mi>i</mi>
     <mo>=</mo>
     <mn>1</mn>
    </mrow>
    <mi>k</mi>
   </msubsup>
   <mi>P</mi>
   <mi>r</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>h</mi>
    <mo>=</mo>
    <mi>k</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi>E</mi>
   <msup>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>x</mi>
     <mo stretchy="false">|</mo>
     <mi>h</mi>
     <mo>=</mo>
     <mi>k</mi>
     <mo stretchy="false">]</mo>
    </mrow>
    <mrow>
     <mi></mi>
     <mo>⊗</mo>
     <mn>3</mn>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">T</csymbol>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <eq></eq>
       <ci>i</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>k</ci>
    </apply>
    <csymbol cd="unknown">P</csymbol>
    <csymbol cd="unknown">r</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">h</csymbol>
     <eq></eq>
     <csymbol cd="unknown">k</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">E</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-[</ci>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-|</ci>
      <csymbol cd="unknown">h</csymbol>
      <eq></eq>
      <csymbol cd="unknown">k</csymbol>
      <ci>normal-]</ci>
     </cerror>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <csymbol cd="latexml">absent</csymbol>
      <cn type="integer">3</cn>
     </apply>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T=\sum_{i=1}^{k}Pr(h=k)E[x|h=k]^{\otimes 3}
  </annotation>
 </semantics>
</math>

.</p>

<p>In applications such as <a href="topic_modeling" title="wikilink">topic modeling</a>, this can be interpreted as the co-occurrence of words in a document. Then the eigenvalues of this empirical moment tensor can be interpreted as the probability of choosing a specific topic and each column of the factor matrix 

<math display="inline" id="Higher-order_singular_value_decomposition:37">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>x</mi>
    <mo stretchy="false">|</mo>
    <mi>h</mi>
    <mo>=</mo>
    <mi>k</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">E</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">h</csymbol>
     <eq></eq>
     <csymbol cd="unknown">k</csymbol>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E[x|h=k]
  </annotation>
 </semantics>
</math>

 corresponds to probabilities of words in the vocabulary in the corresponding topic.</p>
<h2 id="references">References</h2>

<p>"</p>

<p><a href="Category:Multilinear_algebra" title="wikilink">Category:Multilinear algebra</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Kruskal, J. B. (1989). "Rank, decomposition, and uniqueness for 3-way and N-way arrays". In R. Coppi &amp; S. Bolasco (Eds.), <em>Multiway data analysis</em> (pp. 7–18). Amsterdam: Elsevier. [ <a href="http://publish.uwo.ca/~harshman/jbkrank.pdf">PDF</a> ].<a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
<li id="fn9"></li>
<li id="fn10"><a href="#fnref10">↩</a></li>
<li id="fn11"><a href="#fnref11">↩</a></li>
<li id="fn12"><a href="#fnref12">↩</a></li>
<li id="fn13"><a href="#fnref13">↩</a></li>
<li id="fn14"><a href="#fnref14">↩</a></li>
<li id="fn15"><a href="#fnref15">↩</a></li>
<li id="fn16"></li>
<li id="fn17"></li>
<li id="fn18">Haiping Lu, K.N. Plataniotis and A.N. Venetsanopoulos, "<a href="http://www.dsp.utoronto.ca/~haiping/Publication/SurveyMSL_PR2011.pdf">A Survey of Multilinear Subspace Learning for Tensor Data</a>", Pattern Recognition, Vol. 44, No. 7, pp. 1540–1551, Jul. 2011.<a href="#fnref18">↩</a></li>
<li id="fn19">H. Lu, K. N. Plataniotis, and A. N. Venetsanopoulos, "<a href="http://www.dsp.utoronto.ca/~haiping/Publication/MPCA_TNN08_rev2010.pdf">MPCA: Multilinear principal component analysis of tensor objects</a>," IEEE Trans. Neural Netw., vol. 19, no. 1, pp. 18–39, Jan. 2008.<a href="#fnref19">↩</a></li>
<li id="fn20"><a href="#fnref20">↩</a></li>
</ol>
</section>
</body>
</html>
