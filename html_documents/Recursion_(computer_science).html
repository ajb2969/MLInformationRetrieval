<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1040">Recursion (computer science)</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Recursion (computer science)</h1>
<style>
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
<style>
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
</body></html>
<body>
<hr/>

<p><strong>Recursion</strong> in <a href="computer_science" title="wikilink">computer science</a> is a method where the solution to a problem depends on solutions to smaller instances of the same problem (as opposed to <a href="Iteration#Computing" title="wikilink">iteration</a>).<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> The approach can be applied to many types of problems, and <a class="uri" href="recursion" title="wikilink">recursion</a> is one of the central ideas of computer science.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>
<blockquote>

<p>"The power of recursion evidently lies in the possibility of defining an infinite set of objects by a finite statement. In the same manner, an infinite number of computations can be described by a finite recursive program, even if this program contains no explicit repetitions."<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>
</blockquote>

<p>Most computer programming languages support recursion by allowing a <a href="function_(computer_science)" title="wikilink">function</a> to call itself within the program text. Some <a href="Functional_languages" title="wikilink">functional programming languages</a> do not define any looping constructs but rely solely on recursion to repeatedly call code. <a href="Computability_theory_(computer_science)" title="wikilink">Computability theory</a> proves that these recursive-only languages are <a href="turing_completeness" title="wikilink">Turing complete</a>; they are as computationally powerful as Turing complete imperative languages, meaning they can solve the same kinds of problems as imperative languages even without iterative control structures such as “while” and “for”.<br/>
</p>
<h2 id="recursive-functions-and-algorithms">Recursive functions and algorithms</h2>

<p>A common <a href="computer_programming" title="wikilink">computer programming</a> tactic is to divide a problem into sub-problems of the same type as the original, solve those sub-problems, and combine the results. This is often referred to as the <a href="divide-and-conquer_method" title="wikilink">divide-and-conquer method</a>; when combined with a <a href="lookup_table" title="wikilink">lookup table</a> that stores the results of solving sub-problems (to avoid solving them repeatedly and incurring extra computation time), it can be referred to as <a href="dynamic_programming" title="wikilink">dynamic programming</a> or <a class="uri" href="memoization" title="wikilink">memoization</a>.</p>

<p>A recursive function definition has one or more <em>base cases</em>, meaning input(s) for which the function produces a result <a href="Trivial_(mathematics)" title="wikilink">trivially</a> (without recurring), and one or more <em>recursive cases</em>, meaning input(s) for which the program recurs (calls itself). For example, the <a class="uri" href="factorial" title="wikilink">factorial</a> function can be defined recursively by the equations 

<math display="inline" id="Recursion_(computer_science):0">
 <semantics>
  <mrow>
   <mrow>
    <mn>0</mn>
    <mo lspace="0pt" rspace="3.5pt">!</mo>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <factorial></factorial>
     <cn type="integer">0</cn>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0!=1
  </annotation>
 </semantics>
</math>

 and, for all 

<math display="inline" id="Recursion_(computer_science):1">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>></mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <ci>n</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n>0
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Recursion_(computer_science):2">
 <semantics>
  <mrow>
   <mrow>
    <mi>n</mi>
    <mo lspace="0pt" rspace="3.5pt">!</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>n</mi>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>n</mi>
       <mi mathvariant="normal">−</mi>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo lspace="0pt" rspace="3.5pt">!</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <factorial></factorial>
     <ci>n</ci>
    </apply>
    <apply>
     <times></times>
     <ci>n</ci>
     <apply>
      <factorial></factorial>
      <apply>
       <times></times>
       <ci>n</ci>
       <ci>normal-−</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n!=n(n−1)!
  </annotation>
 </semantics>
</math>

. Neither equation by itself constitutes a complete definition; the first is the base case, and the second is the recursive case. Because the base case breaks the chain of recursion, it is sometimes also called the "terminating case".</p>

<p>The job of the recursive cases can be seen as breaking down complex inputs into simpler ones. In a properly designed recursive function, with each recursive call, the input problem must be simplified in such a way that eventually the base case must be reached. (Functions that are not intended to terminate under normal circumstances—for example, some <a href="Daemon_(computer_software)" title="wikilink">system and server processes</a>—are an exception to this.) Neglecting to write a base case, or testing for it incorrectly, can cause an <a href="infinite_loop" title="wikilink">infinite loop</a>.</p>

<p>For some functions (such as one that computes the <a href="series_(mathematics)" title="wikilink">series</a> for 

<math display="inline" id="Recursion_(computer_science):3">
 <semantics>
  <mrow>
   <mi>e</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mn>1</mn>
     <mo>/</mo>
     <mrow>
      <mn>0</mn>
      <mo lspace="0pt" rspace="3.5pt">!</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mn>1</mn>
     <mo>/</mo>
     <mrow>
      <mn>1</mn>
      <mo lspace="0pt" rspace="3.5pt">!</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mn>1</mn>
     <mo>/</mo>
     <mrow>
      <mn>2</mn>
      <mo lspace="0pt" rspace="3.5pt">!</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mn>1</mn>
     <mo>/</mo>
     <mrow>
      <mn>3</mn>
      <mo lspace="0pt" rspace="3.5pt">!</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mi mathvariant="normal">…</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>e</ci>
    <apply>
     <plus></plus>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <factorial></factorial>
       <cn type="integer">0</cn>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <factorial></factorial>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <factorial></factorial>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <factorial></factorial>
       <cn type="integer">3</cn>
      </apply>
     </apply>
     <ci>normal-…</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e=1/0!+1/1!+1/2!+1/3!+...
  </annotation>
 </semantics>
</math>

) there is not an obvious base case implied by the input data; for these one may add a <a class="uri" href="parameter" title="wikilink">parameter</a> (such as the number of terms to be added, in our series example) to provide a 'stopping criterion' that establishes the base case. Such an example is more naturally treated by co-recursion, where successive terms in the output are the partial sums; this can be converted to a recursion by using the indexing parameter to say "compute the <em>n</em>th term (<em>n</em>th partial sum)".</p>
<h2 id="recursive-data-types">Recursive data types</h2>

<p>Many <a href="computer_program" title="wikilink">computer programs</a> must process or generate an arbitrarily large quantity of <a class="uri" href="data" title="wikilink">data</a>. Recursion is one technique for representing data whose exact size the <a class="uri" href="programmer" title="wikilink">programmer</a> does not know: the programmer can specify this data with a <a href="Self_reference" title="wikilink">self-referential</a> definition. There are two types of self-referential definitions: inductive and <a href="Coinduction" title="wikilink">coinductive</a> definitions.</p>
<h3 id="inductively-defined-data">Inductively defined data</h3>

<p>An inductively defined recursive data definition is one that specifies how to construct instances of the data. For example, <a href="linked_list" title="wikilink">linked lists</a> can be defined inductively (here, using <a href="Haskell_(programming_language)" title="wikilink">Haskell</a> syntax):</p>
<dl>
<dd><div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">ListOfStrings</span> <span class="fu">=</span> <span class="dt">EmptyList</span> <span class="fu">|</span> <span class="dt">Cons</span> <span class="dt">String</span> <span class="dt">ListOfStrings</span></code></pre></div>
</dd>
</dl>

<p>The code above specifies a list of strings to be either empty, or a structure that contains a string and a list of strings. The self-reference in the definition permits the construction of lists of any (finite) number of strings.</p>

<p>Another example of inductive <a class="uri" href="definition" title="wikilink">definition</a> is the <a href="natural_numbers" title="wikilink">natural numbers</a> (or positive <a class="uri" href="integers" title="wikilink">integers</a>):</p>
<dl>
<dd><code>A natural number is either 1 or n+1, where n is a natural number.</code>
</dd>
</dl>

<p>Similarly recursive <a href="definition" title="wikilink">definitions</a> are often used to model the structure of <a href="expression_(programming)" title="wikilink">expressions</a> and <a href="statement_(programming)" title="wikilink">statements</a> in programming languages. Language designers often express grammars in a syntax such as <a href="Backus-Naur_form" title="wikilink">Backus-Naur form</a>; here is such a grammar, for a simple language of arithmetic expressions with multiplication and addition:</p>
<pre class="bnf"><code><expr> ::= <number>
          | (<expr> * <expr>)
          | (<expr> + <expr>)
</expr></expr></expr></expr></number></expr></code></pre>

<p>This says that an expression is either a number, a product of two expressions, or a sum of two expressions. By recursively referring to expressions in the second and third lines, the grammar permits arbitrarily complex arithmetic expressions such as <code>(5 * ((3 * 6) + 8))</code>, with more than one product or sum operation in a single expression.</p>
<h3 id="coinductively-defined-data-and-corecursion">Coinductively defined data and corecursion</h3>

<p>A coinductive data definition is one that specifies the operations that may be performed on a piece of data; typically, self-referential coinductive definitions are used for data structures of infinite size.</p>

<p>A coinductive definition of infinite <a href="stream_(computing)" title="wikilink">streams</a> of strings, given informally, might look like this:</p>

<p><code>A stream of strings is an object s such that:</code><br/>
<code> head(s) is a string, and</code><br/>
<code> tail(s) is a stream of strings.</code></p>

<p>This is very similar to an inductive definition of lists of strings; the difference is that this definition specifies how to access the contents of the data structure—namely, via the <a class="uri" href="accessor" title="wikilink">accessor</a> functions <code>head</code> and <code>tail</code>—and what those contents may be, whereas the inductive definition specifies how to create the structure and what it may be created from.</p>

<p><a class="uri" href="Corecursion" title="wikilink">Corecursion</a> is related to coinduction, and can be used to compute particular instances of (possibly) infinite objects. As a programming technique, it is used most often in the context of <a href="lazy_evaluation" title="wikilink">lazy</a> programming languages, and can be preferable to recursion when the desired size or precision of a program's output is unknown. In such cases the program requires both a definition for an infinitely large (or infinitely precise) result, and a mechanism for taking a finite portion of that result. The problem of computing the first n <a href="prime_numbers" title="wikilink">prime numbers</a> is one that can be solved with a corecursive program (e.g. <a href="Fold_(higher-order_function)#Examples" title="wikilink">here</a>).</p>
<h2 id="types-of-recursion">Types of recursion</h2>
<h3 id="single-recursion-and-multiple-recursion">Single recursion and multiple recursion</h3>

<p>Recursion that only contains a single self-reference is known as <strong></strong>, while recursion that contains multiple self-references is known as <strong></strong>. Standard examples of single recursion include list traversal, such as in a linear search, or computing the factorial function, while standard examples of multiple recursion include <a href="tree_traversal" title="wikilink">tree traversal</a>, such as in a depth-first search, or computing the <a href="Fibonacci_sequence" title="wikilink">Fibonacci sequence</a>.</p>

<p>Single recursion is often much more efficient than multiple recursion, and can generally be replaced by an iterative computation, running in linear time and requiring constant space. Multiple recursion, by contrast, may require exponential time and space, and is more fundamentally recursive, not being able to be replaced by iteration without an explicit stack.</p>

<p>Multiple recursion can sometimes be converted to single recursion (and, if desired, thence to iteration). For example, while computing the Fibonacci sequence naively is multiple iteration, as each value requires two previous values, it can be computed by single recursion by passing two successive values as parameters. This is more naturally framed as corecursion, building up from the initial values, tracking at each step two successive values – see <a href="Corecursion#Examples" title="wikilink">corecursion: examples</a>. A more sophisticated example is using a <a href="threaded_binary_tree" title="wikilink">threaded binary tree</a>, which allows iterative tree traversal, rather than multiple recursion.</p>
<h3 id="indirect-recursion">Indirect recursion</h3>

<p>Most basic examples of recursion, and most of the examples presented here, demonstrate <strong><em>direct</em> recursion</strong>, in which a function calls itself. <em>Indirect</em> recursion occurs when a function is called not by itself but by another function that it called (either directly or indirectly). For example, if <em>f</em> calls <em>f,</em> that is direct recursion, but if <em>f</em> calls <em>g</em> which calls <em>f,</em> then that is indirect recursion of <em>f.</em> Chains of three or more functions are possible; for example, function 1 calls function 2, function 2 calls function 3, and function 3 calls function 1 again.</p>

<p>Indirect recursion is also called <a href="mutual_recursion" title="wikilink">mutual recursion</a>, which is a more symmetric term, though this is simply a difference of emphasis, not a different notion. That is, if <em>f</em> calls <em>g</em> and then <em>g</em> calls <em>f,</em> which in turn calls <em>g</em> again, from the point of view of <em>f</em> alone, <em>f</em> is indirectly recursing, while from the point of view of <em>g</em> alone, it is indirectly recursing, while from the point of view of both, <em>f</em> and <em>g</em> are mutually recursing on each other. Similarly a set of three or more functions that call each other can be called a set of mutually recursive functions.</p>
<h3 id="anonymous-recursion">Anonymous recursion</h3>

<p>Recursion is usually done by explicitly calling a function by name. However, recursion can also be done via implicitly calling a function based on the current context, which is particularly useful for <a href="anonymous_function" title="wikilink">anonymous functions</a>, and is known as <a href="anonymous_recursion" title="wikilink">anonymous recursion</a>.</p>
<h3 id="structural-versus-generative-recursion">Structural versus generative recursion</h3>

<p>Some authors classify recursion as either "structural" or "generative". The distinction is related to where a recursive procedure gets the data that it works on, and how it processes that data:</p>
<blockquote>

<p>[Functions that consume structured data] typically decompose their arguments into their immediate structural components and then process those components. If one of the immediate components belongs to the same class of data as the input, the function is recursive. For that reason, we refer to these functions as (STRUCTURALLY) RECURSIVE FUNCTIONS.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>
</blockquote>

<p>Thus, the defining characteristic of a structurally recursive function is that the argument to each recursive call is the content of a field of the original input. Structural recursion includes nearly all tree traversals, including XML processing, binary tree creation and search, etc. By considering the algebraic structure of the natural numbers (that is, a natural number is either zero or the successor of a natural number), functions such as factorial may also be regarded as structural recursion.</p>

<p><strong></strong> is the alternative:</p>
<blockquote>

<p>Many well-known recursive algorithms generate an entirely new piece of data from the given data and recur on it. <a href="How_to_design_programs" title="wikilink">HtDP (How To Design Programs)</a> refers to this kind as generative recursion. Examples of generative recursion include: <a href="Euclidean_algorithm" title="wikilink">gcd</a>, <a class="uri" href="quicksort" title="wikilink">quicksort</a>, <a href="binary_search" title="wikilink">binary search</a>, <a class="uri" href="mergesort" title="wikilink">mergesort</a>, <a href="Newton's_method" title="wikilink">Newton's method</a>, <a href="fractal" title="wikilink">fractals</a>, and <a href="adaptive_quadrature" title="wikilink">adaptive integration</a>.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>
</blockquote>

<p>This distinction is important in <a href="Termination_analysis#Termination_proof" title="wikilink">proving termination</a> of a function.</p>
<ul>
<li>All structurally recursive functions on finite (<a href="Recursive_data_type" title="wikilink">inductively defined</a>) data structures can easily be shown to terminate, via <a href="structural_induction" title="wikilink">structural induction</a>: intuitively, each recursive call receives a smaller piece of input data, until a base case is reached.</li>
<li>Generatively recursive functions, in contrast, do not necessarily feed smaller input to their recursive calls, so proof of their termination is not necessarily as simple, and avoiding <a href="infinite_loops" title="wikilink">infinite loops</a> requires greater care. These generatively recursive functions can often be interpreted as corecursive functions – each step generates the new data, such as successive approximation in Newton's method – and terminating this corecursion requires that the data eventually satisfy some condition, which is not necessarily guaranteed.</li>
<li>In terms of <a href="loop_variant" title="wikilink">loop variants</a>, structural recursion is when there is an obvious loop variant, namely size or complexity, which starts off finite and decreases at each recursive step.</li>
<li>By contrast, generative recursion is when there is not such an obvious loop variant, and termination depends on a function, such as "error of approximation" that does not necessarily decrease to zero, and thus termination is not guaranteed without further analysis.</li>
</ul>
<h2 id="recursive-programs">Recursive programs</h2>
<h3 id="recursive-procedures">Recursive procedures</h3>
<h4 id="factorial">Factorial</h4>

<p>A classic example of a recursive procedure is the function used to calculate the <a class="uri" href="factorial" title="wikilink">factorial</a> of a <a href="natural_number" title="wikilink">natural number</a>:</p>

<p>

<math display="block" id="Recursion_(computer_science):4">
 <semantics>
  <mrow>
   <mrow>
    <mo>fact</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>{</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="left">
       <mn>1</mn>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mtext>if</mtext>
         <mi>n</mi>
        </mrow>
        <mo>=</mo>
        <mn>0</mn>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="left">
       <mrow>
        <mi>n</mi>
        <mo>⋅</mo>
        <mrow>
         <mo>fact</mo>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <mi>n</mi>
           <mo>-</mo>
           <mn>1</mn>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mtext>if</mtext>
         <mi>n</mi>
        </mrow>
        <mo>></mo>
        <mn>0</mn>
       </mrow>
      </mtd>
     </mtr>
    </mtable>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>fact</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">cases</csymbol>
     <cn type="integer">1</cn>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <mtext>if</mtext>
       <ci>n</ci>
      </apply>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <ci>normal-⋅</ci>
      <ci>n</ci>
      <apply>
       <ci>fact</ci>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <gt></gt>
      <apply>
       <times></times>
       <mtext>if</mtext>
       <ci>n</ci>
      </apply>
      <cn type="integer">0</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{fact}(n)=\begin{cases}1&\mbox{if }n=0\\
n\cdot\operatorname{fact}(n-1)&\mbox{if }n>0\\
\end{cases}
  </annotation>
 </semantics>
</math>

</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p><a class="uri" href="Pseudocode" title="wikilink">Pseudocode</a> (recursive):</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p><strong><code>function</code></strong><code> factorial is:</code><br/>
<code> </code><strong><code>input</code></strong><code>: integer </code><em><code>n</code></em><code> such that </code><em><code>n</code></em><code> &gt;= 0</code><br/>
<code> </code><strong><code>output</code></strong><code>: [</code><em><code>n</code></em><code> × (</code><em><code>n</code></em><code>-1) × (</code><em><code>n</code></em><code>-2) × … × 1]</code><br/>
<br/>
<code>     1. if </code><em><code>n</code></em><code> is 0, </code><strong><code>return</code></strong><code> 1</code><br/>
<code>    2. otherwise, </code><strong><code>return</code></strong><code> [ </code><em><code>n</code></em><code> × factorial(</code><em><code>n</code></em><code>-1) ]</code><br/>
<br/>
<code> </code><strong><code>end</code></strong><code> factorial</code></p></td>
</tr>
</tbody>
</table>

<p>The function can also be written as a <a href="recurrence_relation" title="wikilink">recurrence relation</a>:</p>

<p>

<math display="block" id="Recursion_(computer_science):5">
 <semantics>
  <mrow>
   <msub>
    <mi>b</mi>
    <mi>n</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mi>n</mi>
    <msub>
     <mi>b</mi>
     <mrow>
      <mi>n</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>b</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <times></times>
     <ci>n</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>b</ci>
      <apply>
       <minus></minus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b_{n}=nb_{n-1}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Recursion_(computer_science):6">
 <semantics>
  <mrow>
   <msub>
    <mi>b</mi>
    <mn>0</mn>
   </msub>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>b</ci>
     <cn type="integer">0</cn>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b_{0}=1
  </annotation>
 </semantics>
</math>

 This evaluation of the recurrence relation demonstrates the computation that would be performed in evaluating the pseudocode above:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>Computing the recurrence relation for n = 4:</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p><code>b</code><sub><code>4</code></sub><code>           = 4 * b</code><sub><code>3</code></sub><br/>
<code>              = 4 * (3 * b</code><sub><code>2</code></sub><code>)</code><br/>
<code>             = 4 * (3 * (2 * b</code><sub><code>1</code></sub><code>))</code><br/>
<code>             = 4 * (3 * (2 * (1 * b</code><sub><code>0</code></sub><code>)))</code><br/>
<code>             = 4 * (3 * (2 * (1 * 1)))</code><br/>
<code>             = 4 * (3 * (2 * 1))</code><br/>
<code>             = 4 * (3 * 2)</code><br/>
<code>             = 4 * 6</code><br/>
<code>             = 24</code></p></td>
</tr>
</tbody>
</table>

<p>This factorial function can also be described without using recursion by making use of the typical looping constructs found in imperative programming languages:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>Pseudocode (iterative):</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p><strong><code>function</code></strong><code> factorial is:</code><br/>
<code> </code><strong><code>input</code></strong><code>: integer </code><em><code>n</code></em><code> such that </code><em><code>n</code></em><code> &gt;= 0</code><br/>
<code> </code><strong><code>output</code></strong><code>: [</code><em><code>n</code></em><code> × (</code><em><code>n</code></em><code>-1) × (</code><em><code>n</code></em><code>-2) × … × 1]</code><br/>
<br/>
<code>     1. </code><strong><code>create</code></strong><code> new variable called </code><em><code>running_total</code></em><code> with a value of 1</code><br/>
<br/>
<code>     2. </code><strong><code>begin</code></strong><code> loop</code><br/>
<code>          1. if </code><em><code>n</code></em><code> is 0, </code><strong><code>exit</code></strong><code> loop</code><br/>
<code>          2. </code><strong><code>set</code></strong><code> </code><em><code>running_total</code></em><code> to (</code><em><code>running_total</code></em><code> × </code><em><code>n</code></em><code>)</code><br/>
<code>          3. </code><strong><code>decrement</code></strong><code> </code><em><code>n</code></em><br/>
<code>          4. </code><strong><code>repeat</code></strong><code> loop</code><br/>
<br/>
<code>     3. </code><strong><code>return</code></strong><code> </code><em><code>running_total</code></em><br/>
<br/>
<code> </code><strong><code>end</code></strong><code> factorial</code></p></td>
</tr>
</tbody>
</table>

<p>The imperative code above is equivalent to this mathematical definition using an accumulator variable <mtpl></mtpl>'':</p>

<p>

<math display="block" id="Recursion_(computer_science):7">
 <semantics>
  <mtable displaystyle="true">
   <mtr>
    <mtd columnalign="right">
     <mrow>
      <mo>fact</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>n</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mtd>
    <mtd columnalign="center">
     <mo>=</mo>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <msub>
       <mi>fact</mi>
       <mi>acc</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>n</mi>
       <mo>,</mo>
       <mn>1</mn>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="right">
     <mrow>
      <msub>
       <mi>fact</mi>
       <mi>acc</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>n</mi>
       <mo>,</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mtd>
    <mtd columnalign="center">
     <mo>=</mo>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mo>{</mo>
      <mtable displaystyle="true">
       <mtr>
        <mtd columnalign="left">
         <mi>t</mi>
        </mtd>
        <mtd columnalign="left">
         <mrow>
          <mrow>
           <mtext>if</mtext>
           <mi>n</mi>
          </mrow>
          <mo>=</mo>
          <mn>0</mn>
         </mrow>
        </mtd>
       </mtr>
       <mtr>
        <mtd columnalign="left">
         <mrow>
          <msub>
           <mi>fact</mi>
           <mi>acc</mi>
          </msub>
          <mrow>
           <mo stretchy="false">(</mo>
           <mrow>
            <mi>n</mi>
            <mo>-</mo>
            <mn>1</mn>
           </mrow>
           <mo>,</mo>
           <mrow>
            <mi>n</mi>
            <mi>t</mi>
           </mrow>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
        </mtd>
        <mtd columnalign="left">
         <mrow>
          <mrow>
           <mtext>if</mtext>
           <mi>n</mi>
          </mrow>
          <mo>></mo>
          <mn>0</mn>
         </mrow>
        </mtd>
       </mtr>
      </mtable>
     </mrow>
    </mtd>
   </mtr>
  </mtable>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <apply>
      <ci>fact</ci>
      <ci>n</ci>
     </apply>
     <eq></eq>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>fact</ci>
       <ci>acc</ci>
      </apply>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </matrixrow>
    <matrixrow>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>fact</ci>
       <ci>acc</ci>
      </apply>
      <ci>n</ci>
      <ci>t</ci>
     </apply>
     <eq></eq>
     <apply>
      <csymbol cd="latexml">cases</csymbol>
      <ci>t</ci>
      <apply>
       <eq></eq>
       <apply>
        <times></times>
        <mtext>if</mtext>
        <ci>n</ci>
       </apply>
       <cn type="integer">0</cn>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>fact</ci>
        <ci>acc</ci>
       </apply>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <times></times>
        <ci>n</ci>
        <ci>t</ci>
       </apply>
      </apply>
      <apply>
       <gt></gt>
       <apply>
        <times></times>
        <mtext>if</mtext>
        <ci>n</ci>
       </apply>
       <cn type="integer">0</cn>
      </apply>
     </apply>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{array}[]{rcl}\operatorname{fact}(n)&=&\operatorname{fact_{acc}}(n,1)\\
\operatorname{fact_{acc}}(n,t)&=&\begin{cases}t&\mbox{if }n=0\\
\operatorname{fact_{acc}}(n-1,nt)&\mbox{if }n>0\\
\end{cases}\end{array}
  </annotation>
 </semantics>
</math>

</p>

<p>The definition above translates straightforwardly to <a href="functional_programming_language" title="wikilink">functional programming languages</a> such as <a href="Scheme_(programming_language)" title="wikilink">Scheme</a>; this is an example of iteration implemented recursively.</p>
<h4 id="greatest-common-divisor">Greatest common divisor</h4>

<p>The <a href="Euclidean_algorithm" title="wikilink">Euclidean algorithm</a>, which computes the <a href="greatest_common_divisor" title="wikilink">greatest common divisor</a> of two integers, can be written recursively.</p>

<p>'' Function definition'':</p>

<p>

<math display="block" id="Recursion_(computer_science):8">
 <semantics>
  <mrow>
   <mrow>
    <mi>gcd</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>{</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="left">
       <mi>x</mi>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mtext>if</mtext>
         <mi>y</mi>
        </mrow>
        <mo>=</mo>
        <mn>0</mn>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="left">
       <mrow>
        <mi>gcd</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>y</mi>
         <mo>,</mo>
         <mrow>
          <mo>remainder</mo>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>x</mi>
           <mo>,</mo>
           <mi>y</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mtext>if</mtext>
         <mi>y</mi>
        </mrow>
        <mo>></mo>
        <mn>0</mn>
       </mrow>
      </mtd>
     </mtr>
    </mtable>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <gcd></gcd>
     <ci>x</ci>
     <ci>y</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">cases</csymbol>
     <ci>x</ci>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <mtext>if</mtext>
       <ci>y</ci>
      </apply>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <gcd></gcd>
      <ci>y</ci>
      <apply>
       <ci>remainder</ci>
       <ci>x</ci>
       <ci>y</ci>
      </apply>
     </apply>
     <apply>
      <gt></gt>
      <apply>
       <times></times>
       <mtext>if</mtext>
       <ci>y</ci>
      </apply>
      <cn type="integer">0</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gcd(x,y)=\begin{cases}x&\mbox{if }y=0\\
\gcd(y,\operatorname{remainder}(x,y))&\mbox{if }y>0\\
\end{cases}
  </annotation>
 </semantics>
</math>

</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p><a class="uri" href="Pseudocode" title="wikilink">Pseudocode</a> (recursive):</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p><strong><code>function</code></strong><code> gcd is:</code><br/>
<strong><code>input</code></strong><code>: integer </code><em><code>x</code></em><code>, integer </code><em><code>y</code></em><code> such that </code><em><code>x</code></em><code> &gt; 0 and </code><em><code>y</code></em><code> &gt;= 0</code><br/>
<br/>
<code>     1. if </code><em><code>y</code></em><code> is 0, </code><strong><code>return</code></strong><code> </code><em><code>x</code></em><br/>
<code>    2. otherwise, </code><strong><code>return</code></strong><code> [ gcd( </code><em><code>y</code></em><code>, (remainder of </code><em><code>x</code></em><code>/</code><em><code>y</code></em><code>) ) ]</code><br/>
<br/>
<code> </code><strong><code>end</code></strong><code> gcd</code></p></td>
</tr>
</tbody>
</table>

<p><a href="Recurrence_relation" title="wikilink">Recurrence relation</a> for greatest common divisor, where 

<math display="inline" id="Recursion_(computer_science):9">
 <semantics>
  <mrow>
   <mrow>
    <mi>x</mi>
    <mo lspace="0pt" rspace="3.5pt">%</mo>
   </mrow>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="latexml">percent</csymbol>
     <ci>x</ci>
    </apply>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\%y
  </annotation>
 </semantics>
</math>

 expresses the <a class="uri" href="remainder" title="wikilink">remainder</a> of 

<math display="inline" id="Recursion_(computer_science):10">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>/</mo>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <ci>x</ci>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x/y
  </annotation>
 </semantics>
</math>

:</p>

<p>

<math display="block" id="Recursion_(computer_science):11">
 <semantics>
  <mrow>
   <mrow>
    <mi>gcd</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>gcd</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>y</mi>
     <mo>,</mo>
     <mrow>
      <mrow>
       <mi>x</mi>
       <mo lspace="0pt" rspace="3.5pt">%</mo>
      </mrow>
      <mi>y</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <gcd></gcd>
     <ci>x</ci>
     <ci>y</ci>
    </apply>
    <apply>
     <gcd></gcd>
     <ci>y</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="latexml">percent</csymbol>
       <ci>x</ci>
      </apply>
      <ci>y</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gcd(x,y)=\gcd(y,x\%y)
  </annotation>
 </semantics>
</math>

 if 

<math display="inline" id="Recursion_(computer_science):12">
 <semantics>
  <mrow>
   <mi>y</mi>
   <mo>≠</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <neq></neq>
    <ci>y</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y\neq 0
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Recursion_(computer_science):13">
 <semantics>
  <mrow>
   <mrow>
    <mi>gcd</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mn>0</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>x</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <gcd></gcd>
     <ci>x</ci>
     <cn type="integer">0</cn>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gcd(x,0)=x
  </annotation>
 </semantics>
</math>

</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>Computing the recurrence relation for x = 27 and y = 9:</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p><code>gcd(27, 9)   = gcd(9, 27% 9)</code><br/>
<code>             = gcd(9, 0)</code><br/>
<code>             = 9</code></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Computing the recurrence relation for x = 111 and y = 259:</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><code>gcd(111, 259)   = gcd(259, 111% 259)</code><br/>
<code>                = gcd(259, 111)</code><br/>
<code>                = gcd(111, 259% 111)</code><br/>
<code>                = gcd(111, 37)</code><br/>
<code>                = gcd(37, 111% 37)</code><br/>
<code>                = gcd(37, 0)</code><br/>
<code>                = 37</code></p></td>
</tr>
</tbody>
</table>

<p>The recursive program above is <a class="uri" href="tail-recursive" title="wikilink">tail-recursive</a>; it is equivalent to an iterative algorithm, and the computation shown above shows the steps of evaluation that would be performed by a language that eliminates tail calls. Below is a version of the same algorithm using explicit iteration, suitable for a language that does not eliminate tail calls. By maintaining its state entirely in the variables <em>x</em> and <em>y</em> and using a looping construct, the program avoids making recursive calls and growing the call stack.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>Pseudocode (iterative):</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p><strong><code>function</code></strong><code> gcd is:</code><br/>
<code> </code><strong><code>input</code></strong><code>: integer </code><em><code>x</code></em><code>, integer </code><em><code>y</code></em><code> such that </code><em><code>x</code></em><code> &gt;= </code><em><code>y</code></em><code> and </code><em><code>y</code></em><code> &gt;= 0</code><br/>
<br/>
<code>     1. </code><strong><code>create</code></strong><code> new variable called </code><em><code>remainder</code></em><br/>
<br/>
<code>     2. </code><strong><code>begin</code></strong><code> loop</code><br/>
<code>          1. if </code><em><code>y</code></em><code> is zero, </code><strong><code>exit</code></strong><code> loop</code><br/>
<code>          2. </code><strong><code>set</code></strong><code> </code><em><code>remainder</code></em><code> to the remainder of x/y</code><br/>
<code>          3. </code><strong><code>set</code></strong><code> x to y</code><br/>
<code>          4. </code><strong><code>set</code></strong><code> y to </code><em><code>remainder</code></em><br/>
<code>          5. </code><strong><code>repeat</code></strong><code> loop</code><br/>
<br/>
<code>     3. </code><strong><code>return</code></strong><code> </code><em><code>x</code></em><br/>
<br/>
<code> </code><strong><code>end</code></strong><code> gcd</code></p></td>
</tr>
</tbody>
</table>

<p>The iterative algorithm requires a temporary variable, and even given knowledge of the Euclidean algorithm it is more difficult to understand the process by simple inspection, although the two algorithms are very similar in their steps.</p>
<h4 id="towers-of-hanoi">Towers of Hanoi</h4>

<p> </p>

<p>The Towers of Hanoi is a mathematical puzzle whose solution illustrates recursion.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a><a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> There are three pegs which can hold stacks of disks of different diameters. A larger disk may never be stacked on top of a smaller. Starting with <em>n</em> disks on one peg, they must be moved to another peg one at a time. What is the smallest number of steps to move the stack?</p>

<p><em>Function definition</em>:</p>

<p>

<math display="block" id="Recursion_(computer_science):14">
 <semantics>
  <mrow>
   <mrow>
    <mo>hanoi</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>{</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="left">
       <mn>1</mn>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mtext>if</mtext>
         <mi>n</mi>
        </mrow>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mn>2</mn>
         <mo>⋅</mo>
         <mrow>
          <mo>hanoi</mo>
          <mrow>
           <mo stretchy="false">(</mo>
           <mrow>
            <mi>n</mi>
            <mo>-</mo>
            <mn>1</mn>
           </mrow>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
        </mrow>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mtext>if</mtext>
         <mi>n</mi>
        </mrow>
        <mo>></mo>
        <mn>1</mn>
       </mrow>
      </mtd>
     </mtr>
    </mtable>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>hanoi</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">cases</csymbol>
     <cn type="integer">1</cn>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <mtext>if</mtext>
       <ci>n</ci>
      </apply>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <ci>normal-⋅</ci>
       <cn type="integer">2</cn>
       <apply>
        <ci>hanoi</ci>
        <apply>
         <minus></minus>
         <ci>n</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <gt></gt>
      <apply>
       <times></times>
       <mtext>if</mtext>
       <ci>n</ci>
      </apply>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{hanoi}(n)=\begin{cases}1&\mbox{if }n=1\\
2\cdot\operatorname{hanoi}(n-1)+1&\mbox{if }n>1\\
\end{cases}
  </annotation>
 </semantics>
</math>

</p>

<p><em>Recurrence relation for hanoi</em>:</p>

<p>

<math display="block" id="Recursion_(computer_science):15">
 <semantics>
  <mrow>
   <msub>
    <mi>h</mi>
    <mi>n</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mn>2</mn>
     <msub>
      <mi>h</mi>
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msub>
    </mrow>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>h</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>h</ci>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h_{n}=2h_{n-1}+1
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Recursion_(computer_science):16">
 <semantics>
  <mrow>
   <msub>
    <mi>h</mi>
    <mn>1</mn>
   </msub>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>h</ci>
     <cn type="integer">1</cn>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h_{1}=1
  </annotation>
 </semantics>
</math>

</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>Computing the recurrence relation for n = 4:</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p><code>hanoi(4)     = 2*hanoi(3) + 1</code><br/>
<code>             = 2*(2*hanoi(2) + 1) + 1</code><br/>
<code>             = 2*(2*(2*hanoi(1) + 1) + 1) + 1</code><br/>
<code>             = 2*(2*(2*1 + 1) + 1) + 1</code><br/>
<code>             = 2*(2*(3) + 1) + 1</code><br/>
<code>             = 2*(7) + 1</code><br/>
<code>             = 15</code></p></td>
</tr>
</tbody>
</table>

<p><br/>
 Example implementations:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p><a class="uri" href="Pseudocode" title="wikilink">Pseudocode</a> (recursive):</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p><strong><code>function</code></strong><code> hanoi is:</code><br/>
<code> </code><strong><code>input</code></strong><code>: integer </code><em><code>n</code></em><code>, such that </code><em><code>n</code></em><code> &gt;= </code><em><code>1</code></em><br/>
<br/>
<code>     1. </code><strong><code>if</code></strong><code> n is 1 </code><strong><code>then</code> <code>return</code></strong><code> 1</code><br/>
<br/>
<code>     2. </code><strong><code>return</code></strong><code> [2 * [</code><strong><code>call</code></strong><code> hanoi(n-1)] + 1]</code><br/>
<br/>
<code> </code><strong><code>end</code></strong><code> hanoi</code></p></td>
</tr>
</tbody>
</table>

<p>Although not all recursive functions have an explicit solution, the Tower of Hanoi sequence can be reduced to an explicit formula.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>An explicit formula for Towers of Hanoi:</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p><code>h</code><sub><code>1</code></sub><code> = 1   = 2</code><sup><code>1</code></sup><code> - 1</code><br/>
<code>h</code><sub><code>2</code></sub><code> = 3   = 2</code><sup><code>2</code></sup><code> - 1</code><br/>
<code>h</code><sub><code>3</code></sub><code> = 7   = 2</code><sup><code>3</code></sup><code> - 1</code><br/>
<code>h</code><sub><code>4</code></sub><code> = 15  = 2</code><sup><code>4</code></sup><code> - 1</code><br/>
<code>h</code><sub><code>5</code></sub><code> = 31  = 2</code><sup><code>5</code></sup><code> - 1</code><br/>
<code>h</code><sub><code>6</code></sub><code> = 63  = 2</code><sup><code>6</code></sup><code> - 1</code><br/>
<code>h</code><sub><code>7</code></sub><code> = 127 = 2</code><sup><code>7</code></sup><code> - 1</code><br/>
<code>In general:</code><br/>
<code>h</code><sub><code>n</code></sub><code> = 2</code><sup><code>n</code></sup><code> - 1, for all n &gt;= 1</code></p></td>
</tr>
</tbody>
</table>
<h4 id="binary-search">Binary search</h4>

<p>The <a href="binary_search" title="wikilink">binary search</a> algorithm is a method of searching a <a href="sorted_array" title="wikilink">sorted array</a> for a single element by cutting the array in half with each recursive pass. The trick is to pick a midpoint near the center of the array, compare the data at that point with the data being searched and then responding to one of three possible conditions: the data is found at the midpoint, the data at the midpoint is greater than the data being searched for, or the data at the midpoint is less than the data being searched for.</p>

<p>Recursion is used in this algorithm because with each pass a new array is created by cutting the old one in half. The binary search procedure is then called recursively, this time on the new (and smaller) array. Typically the array's size is adjusted by manipulating a beginning and ending index. The algorithm exhibits a logarithmic order of growth because it essentially divides the problem domain in half with each pass.</p>

<p>Example implementation of binary search in C:</p>
<div class="sourceCode"><pre class="sourceCode C"><code class="sourceCode c"> <span class="co">/*</span>
<span class="co">  Call binary_search with proper initial conditions.</span>

<span class="co">  INPUT:</span>
<span class="co">    data is an array of integers SORTED in ASCENDING order,</span>
<span class="co">    toFind is the integer to search for,</span>
<span class="co">    count is the total number of elements in the array</span>

<span class="co">  OUTPUT:</span>
<span class="co">    result of binary_search</span>

<span class="co"> */</span>
 <span class="dt">int</span> search(<span class="dt">int</span> *data, <span class="dt">int</span> toFind, <span class="dt">int</span> count)
 {
    <span class="co">//  Start = 0 (beginning index)</span>
    <span class="co">//  End = count - 1 (top index)</span>
    <span class="kw">return</span> binary_search(data, toFind, <span class="dv">0</span>, count<span class="dv">-1</span>);
 }

 <span class="co">/*</span>
<span class="co">   Binary Search Algorithm.</span>

<span class="co">   INPUT:</span>
<span class="co">        data is a array of integers SORTED in ASCENDING order,</span>
<span class="co">        toFind is the integer to search for,</span>
<span class="co">        start is the minimum array index,</span>
<span class="co">        end is the maximum array index</span>
<span class="co">   OUTPUT:</span>
<span class="co">        position of the integer toFind within array data,</span>
<span class="co">        -1 if not found</span>
<span class="co"> */</span>
 <span class="dt">int</span> binary_search(<span class="dt">int</span> *data, <span class="dt">int</span> toFind, <span class="dt">int</span> start, <span class="dt">int</span> end)
 {
    <span class="co">//Get the midpoint.</span>
    <span class="dt">int</span> mid = start + (end - start)/<span class="dv">2</span>;   <span class="co">//Integer division</span>

    <span class="co">//Stop condition.</span>
    <span class="kw">if</span> (start &gt; end)
       <span class="kw">return</span> -<span class="dv">1</span>;
    <span class="kw">else</span> <span class="kw">if</span> (data[mid] == toFind)        <span class="co">//Found?</span>
       <span class="kw">return</span> mid;
    <span class="kw">else</span> <span class="kw">if</span> (data[mid] &gt; toFind)         <span class="co">//Data is greater than toFind, search lower half</span>
       <span class="kw">return</span> binary_search(data, toFind, start, mid<span class="dv">-1</span>);
    <span class="kw">else</span>                                 <span class="co">//Data is less than toFind, search upper half</span>
       <span class="kw">return</span> binary_search(data, toFind, mid<span class="dv">+1</span>, end);
 }</code></pre></div>
<h3 id="recursive-data-structures-structural-recursion">Recursive data structures (structural recursion)</h3>

<p>An important application of recursion in computer science is in defining dynamic data structures such as <a href="list_(abstract_data_type)" title="wikilink">lists</a> and <a href="tree_(data_structure)" title="wikilink">trees</a>. Recursive data structures can dynamically grow to a theoretically infinite size in response to runtime requirements; in contrast, the size of a static array must be set at compile time.</p>
<blockquote>

<p>"Recursive algorithms are particularly appropriate when the underlying problem or the data to be treated are defined in recursive terms."<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></p>
</blockquote>

<p>The examples in this section illustrate what is known as "structural recursion". This term refers to the fact that the recursive procedures are acting on data that is defined recursively.</p>
<blockquote>

<p>As long as a programmer derives the template from a data definition, functions employ structural recursion. That is, the recursions in a function's body consume some immediate piece of a given compound value.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a></p>
</blockquote>
<h4 id="linked-lists">Linked lists</h4>

<p>Below is a C definition of a linked list node structure. Notice especially how the node is defined in terms of itself. The "next" element of <em>struct node</em> is a pointer to another <em>struct node</em>, effectively creating a list type.</p>
<div class="sourceCode"><pre class="sourceCode C"><code class="sourceCode c"><span class="kw">struct</span> node
{
  <span class="dt">int</span> data;           <span class="co">// some integer data</span>
  <span class="kw">struct</span> node *next;  <span class="co">// pointer to another struct node</span>
};</code></pre></div>

<p>Because the <em>struct node</em> data structure is defined recursively, procedures that operate on it can be implemented naturally as recursive procedures. The <em>list_print</em> procedure defined below walks down the list until the list is empty (i.e., the list pointer has a value of NULL). For each node it prints the data element (an integer). In the C implementation, the list remains unchanged by the <em>list_print</em> procedure.</p>
<div class="sourceCode"><pre class="sourceCode C"><code class="sourceCode c"><span class="dt">void</span> list_print(<span class="kw">struct</span> node *list)
{
    <span class="kw">if</span> (list != NULL)               <span class="co">// base case</span>
    {
       printf (<span class="st">"%d "</span>, list-&gt;data);  <span class="co">// print integer data followed by a space</span>
       list_print (list-&gt;next);     <span class="co">// recursive call on the next node</span>
    }
}</code></pre></div>
<h4 id="binary-trees">Binary trees</h4>

<p>Below is a simple definition for a binary tree node. Like the node for linked lists, it is defined in terms of itself, recursively. There are two self-referential pointers: left (pointing to the left sub-tree) and right (pointing to the right sub-tree).</p>
<div class="sourceCode"><pre class="sourceCode C"><code class="sourceCode c"><span class="kw">struct</span> node
{
  <span class="dt">int</span> data;            <span class="co">// some integer data</span>
  <span class="kw">struct</span> node *left;   <span class="co">// pointer to the left subtree</span>
  <span class="kw">struct</span> node *right;  <span class="co">// point to the right subtree</span>
};</code></pre></div>

<p>Operations on the tree can be implemented using recursion. Note that because there are two self-referencing pointers (left and right), tree operations may require two recursive calls:</p>
<div class="sourceCode"><pre class="sourceCode C"><code class="sourceCode c"><span class="co">// Test if tree_node contains i; return 1 if so, 0 if not.</span>
<span class="dt">int</span> tree_contains(<span class="kw">struct</span> node *tree_node, <span class="dt">int</span> i) {
    <span class="kw">if</span> (tree_node == NULL)
        <span class="kw">return</span> <span class="dv">0</span>;  <span class="co">// base case</span>
    <span class="kw">else</span> <span class="kw">if</span> (tree_node-&gt;data == i)
        <span class="kw">return</span> <span class="dv">1</span>;
    <span class="kw">else</span>
        <span class="kw">return</span> tree_contains(tree_node-&gt;left, i) || tree_contains(tree_node-&gt;right, i);
}</code></pre></div>

<p>At most two recursive calls will be made for any given call to <em>tree_contains</em> as defined above.</p>
<div class="sourceCode"><pre class="sourceCode C"><code class="sourceCode c"><span class="co">// Inorder traversal:</span>
<span class="dt">void</span> tree_print(<span class="kw">struct</span> node *tree_node) {
        <span class="kw">if</span> (tree_node != NULL) {                  <span class="co">// base case</span>
                tree_print(tree_node-&gt;left);      <span class="co">// go left</span>
                printf(<span class="st">"%d "</span>, tree_node-&gt;data);   <span class="co">// print the integer followed by a space</span>
                tree_print(tree_node-&gt;right);     <span class="co">// go right</span>
        }
}</code></pre></div>

<p>The above example illustrates an <a href="Tree_traversal" title="wikilink">in-order traversal</a> of the binary tree. A <a href="Binary_search_tree" title="wikilink">Binary search tree</a> is a special case of the binary tree where the data elements of each node are in order.</p>
<h4 id="filesystem-traversal">Filesystem traversal</h4>

<p>Since the number of files in a <a class="uri" href="filesystem" title="wikilink">filesystem</a> may vary, <a class="uri" href="recursion" title="wikilink">recursion</a> is the only practical way to traverse and thus enumerate its contents. Traversing a filesystem is very similar to that of <a href="tree_traversal" title="wikilink">tree traversal</a>, therefore the concepts behind tree traversal are applicable to traversing a filesystem. More specifically, the code below would be an example of a <a href="preorder_traversal" title="wikilink">preorder traversal</a> of a filesystem.</p>
<div class="sourceCode"><pre class="sourceCode Java"><code class="sourceCode java"><span class="kw">import java.io.*;</span>

<span class="kw">public</span> <span class="kw">class</span> FileSystem {

    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span> (String [] args) {
        <span class="fu">traverse</span> ();
    }

    <span class="co">/**</span>
<span class="co">     * Obtains the filesystem roots</span>
<span class="co">     * Proceeds with the recursive filesystem traversal</span>
<span class="co">     */</span>
    <span class="kw">private</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">traverse</span> () {
        File [] fs = File.<span class="fu">listRoots</span> ();
        <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; fs.<span class="fu">length</span>; i++) {
            <span class="kw">if</span> (fs[i].<span class="fu">isDirectory</span> () &amp;&amp; fs[i].<span class="fu">canRead</span> ()) {
                <span class="fu">rtraverse</span> (fs[i]);
            }
        }
    }

    <span class="co">/**</span>
<span class="co">     * Recursively traverse a given directory</span>
<span class="co">     *</span>
<span class="co">     * </span><span class="kw">@param fd </span><span class="co">indicates the starting point of traversal</span>
<span class="co">     */</span>
    <span class="kw">private</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">rtraverse</span> (File fd) {
        File [] fss = fd.<span class="fu">listFiles</span> ();

        <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; fss.<span class="fu">length</span>; i++) {
            System.<span class="fu">out</span>.<span class="fu">println</span> (fss[i]);
            <span class="kw">if</span> (fss[i].<span class="fu">isDirectory</span> () &amp;&amp; fss[i].<span class="fu">canRead</span> ()) {
                <span class="fu">rtraverse</span> (fss[i]);
            }
        }
    }

}</code></pre></div>

<p>This code blends the lines, at least somewhat, between recursion and <a class="uri" href="iteration" title="wikilink">iteration</a>. It is, essentially, a recursive implementation, which is the best way to traverse a <a class="uri" href="filesystem" title="wikilink">filesystem</a>. It is also an example of direct and indirect recursion. The method "rtraverse" is purely a direct example; the method "traverse" is the indirect, which calls "rtraverse." This example needs no "base case" scenario due to the fact that there will always be some fixed number of files or directories in a given filesystem.</p>
<h2 id="implementation-issues">Implementation issues</h2>

<p>In actual implementation, rather than a pure recursive function (single check for base case, otherwise recursive step), a number of modifications may be made, for purposes of clarity or efficiency. These include:</p>
<ul>
<li>Wrapper function (at top)</li>
<li>Short-circuiting the base case, aka "Arm's-length recursion" (at bottom)</li>
<li>Hybrid algorithm (at bottom) – switching to a different algorithm once data is small enough</li>
</ul>

<p>On the basis of elegance, wrapper functions are generally approved, while short-circuiting the base case is frowned upon, particularly in academia. Hybrid algorithms are often used for efficiency, to reduce the overhead of recursion in small cases, and arm's-length recursion is a special case of this.</p>
<h3 id="wrapper-function">Wrapper function</h3>

<p>A <a href="wrapper_function" title="wikilink">wrapper function</a> is a function that is directly called but does not recurse itself, instead calling a separate auxiliary function which actually does the recursion.</p>

<p>Wrapper functions can be used to validate parameters (so the recursive function can skip these), perform initialization (allocate memory, initialize variables), particularly for auxiliary variables such as "level of recursion" or partial computations for <a class="uri" href="memoization" title="wikilink">memoization</a>, and handle exceptions and errors. In languages that support <a href="nested_function" title="wikilink">nested functions</a>, the auxiliary function can be nested inside the wrapper function and use a shared scope. In the absence of nested functions, auxiliary functions are instead a separate function, if possible private (as they are not called directly), and information is shared with the wrapper function by using <a class="uri" href="pass-by-reference" title="wikilink">pass-by-reference</a>.</p>
<h3 id="short-circuiting-the-base-case">Short-circuiting the base case</h3>

<p>Short-circuiting the base case, also known as <strong>arm's-length recursion</strong>, consists of checking the base case <em>before</em> making a recursive call – i.e., checking if the next call will be the base case, instead of calling and then checking for the base case. Short-circuiting is particularly done for efficiency reasons, to avoid the overhead of a function call that immediately returns. Note that since the base case has already been checked for (immediately before the recursive step), it does not need to be checked for separately, but one does need to use a wrapper function for the case when the overall recursion starts with the base case itself. For example, in the factorial function, properly the base case is 0! = 1, while immediately returning 1 for 1! is a short-circuit, and may miss 0; this can be mitigated by a wrapper function.</p>

<p>Short-circuiting is primarily a concern when many base cases are encountered, such as Null pointers in a tree, which can be linear in the number of function calls, hence significant savings for <em>O</em>(<em>n</em>) algorithms; this is illustrated below for a depth-first search. Short-circuiting on a tree corresponds to considering a leaf (non-empty node with no children) as the base case, rather than considering an empty node as the base case. If there is only a single base case, such as in computing the factorial, short-circuiting provides only <em>O</em>(1) savings.</p>

<p>Conceptually, short-circuiting can be considered to either have the same base case and recursive step, only checking the base case before the recursion, or it can be considered to have a different base case (one step removed from standard base case) and a more complex recursive step, namely "check valid then recurse", as in considering leaf nodes rather than Null nodes as base cases in a tree. Because short-circuiting has a more complicated flow, compared with the clear separation of base case and recursive step in standard recursion, it is often considered poor style, particularly in academia.</p>
<h4 id="depth-first-search">Depth-first search</h4>

<p>A basic example of short-circuiting is given in <a href="depth-first_search" title="wikilink">depth-first search</a> (DFS) of a binary tree; see <a href="#Binary_trees" title="wikilink">binary trees</a> section for standard recursive discussion.</p>

<p>The standard recursive algorithm for a DFS is:</p>
<ul>
<li>base case: If current node is Null, return false</li>
<li>recursive step: otherwise, check value of current node, return true if match, otherwise recurse on children</li>
</ul>

<p>In short-circuiting, this is instead:</p>
<ul>
<li>check value of current node, return true if match,</li>
<li>otherwise, on children, if not Null, then recurse.</li>
</ul>

<p>In terms of the standard steps, this moves the base case check <em>before</em> the recursive step. Alternatively, these can be considered a different form of base case and recursive step, respectively. Note that this requires a wrapper function to handle the case when the tree itself is empty (root node is Null).</p>

<p>In the case of a <a href="perfect_binary_tree" title="wikilink">perfect binary tree</a> of height <em>h,</em> there are 2<sup><em>h</em>+1</sup>−1 nodes and 2<sup><em>h</em>+1</sup> Null pointers as children (2 for each of the 2<sup><em>h</em></sup> leaves), so short-circuiting cuts the number of function calls in half in the worst case.</p>

<p>In C, the standard recursive algorithm may be implemented as:</p>
<div class="sourceCode"><pre class="sourceCode C"><code class="sourceCode c">bool tree_contains(<span class="kw">struct</span> node *tree_node, <span class="dt">int</span> i) {
    <span class="kw">if</span> (tree_node == NULL)
        <span class="kw">return</span> false;  <span class="co">// base case</span>
    <span class="kw">else</span> <span class="kw">if</span> (tree_node-&gt;data == i)
        <span class="kw">return</span> true;
    <span class="kw">else</span>
        <span class="kw">return</span> tree_contains(tree_node-&gt;left, i) ||
               tree_contains(tree_node-&gt;right, i);
}</code></pre></div>

<p>The short-circuited algorithm may be implemented as:</p>
<div class="sourceCode"><pre class="sourceCode C"><code class="sourceCode c"><span class="co">// Wrapper function to handle empty tree</span>
bool tree_contains(<span class="kw">struct</span> node *tree_node, <span class="dt">int</span> i) {
    <span class="kw">if</span> (tree_node == NULL)
        <span class="kw">return</span> false;  <span class="co">// empty tree</span>
    <span class="kw">else</span>
        <span class="kw">return</span> tree_contains_do(tree_node, i);  <span class="co">// call auxiliary function</span>
}

<span class="co">// Assumes tree_node != NULL</span>
bool tree_contains_do(<span class="kw">struct</span> node *tree_node, <span class="dt">int</span> i) {
    <span class="kw">if</span> (tree_node-&gt;data == i)
        <span class="kw">return</span> true;  <span class="co">// found</span>
    <span class="kw">else</span>  <span class="co">// recurse</span>
        <span class="kw">return</span> (tree_node-&gt;left  &amp;&amp; tree_contains_do(tree_node-&gt;left,  i)) ||
               (tree_node-&gt;right &amp;&amp; tree_contains_do(tree_node-&gt;right, i));
}</code></pre></div>

<p>Note the use of <a href="short-circuit_evaluation" title="wikilink">short-circuit evaluation</a> of the Boolean &amp;&amp; (AND) operators, so that the recursive call is only made if the node is valid (non-Null). Note that while the first term in the AND is a pointer to a node, the second term is a bool, so the overall expression evaluates to a bool. This is a common idiom in recursive short-circuiting. This is in addition to the short-circuit evaluation of the Boolean || (OR) operator, to only check the right child if the left child fails. In fact, the entire <a href="control_flow" title="wikilink">control flow</a> of these functions can be replaced with a single Boolean expression in a return statement, but legibility suffers at no benefit to efficiency.</p>
<h3 id="hybrid-algorithm">Hybrid algorithm</h3>

<p>Recursive algorithms are often inefficient for small data, due to the overhead of repeated function calls and returns. For this reason efficient implementations of recursive algorithms often start with the recursive algorithm, but then switch to a different algorithm when the input becomes small. An important example is <a href="merge_sort" title="wikilink">merge sort</a>, which is often implemented by switching to the non-recursive <a href="insertion_sort" title="wikilink">insertion sort</a> when the data is sufficiently small, as in the <a href="tiled_merge_sort" title="wikilink">tiled merge sort</a>. Hybrid recursive algorithms can often be further refined, as in <a class="uri" href="Timsort" title="wikilink">Timsort</a>, derived from a hybrid merge sort/insertion sort.</p>
<h2 id="recursion-versus-iteration">Recursion versus iteration</h2>

<p>Recursion and iteration are equally expressive: recursion can be replaced by iteration with an explicit stack, while iteration can be replaced with tail recursion. Which approach is preferable depends on the problem under consideration and the language used. In imperative programming, iteration is preferred, particularly for simple recursion, as it avoids the overhead of function calls and call stack management, but recursion is generally used for multiple recursion. By contrast, in functional languages recursion is preferred, with tail recursion optimization leading to little overhead, and sometimes explicit iteration is not available.</p>

<p>Compare the templates to compute x<sub>n</sub> defined by x<sub>n</sub> = f(n, x<sub>n-1</sub>) from x<sub>base</sub>:</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p><code>function recursive(n)</code><br/>
<code>    if n==base</code><br/>
<code>        return x</code><sub><code>base</code></sub><br/>
<code>    else</code><br/>
<code>        return f(n, recursive(n-1)) </code></p></td>
<td style="text-align: left;">
<p>|</p>

<p><code>function iterative(n)</code><br/>
<code>    x = x</code><sub><code>base</code></sub><br/>
<code>    for i = n downto base</code><br/>
<code>        x = f(i, x)</code><br/>
<code>    return x</code></p></td>
</tr>
</tbody>
</table>

<p>For imperative language the overhead is to define the function, for functional language the overhead is to define the accumulator variable x.</p>

<p>For example, the factorial function may be implemented iteratively in C by assigning to an loop index variable and accumulator variable, rather than passing arguments and returning values by recursion:</p>
<div class="sourceCode"><pre class="sourceCode C"><code class="sourceCode c"><span class="dt">unsigned</span> <span class="dt">int</span> factorial(<span class="dt">unsigned</span> <span class="dt">int</span> n) {
  <span class="dt">unsigned</span> <span class="dt">int</span> product = <span class="dv">1</span>; <span class="co">// empty product is 1</span>
  <span class="kw">while</span> (n) {
    product *= n;
    --n;
  }
  <span class="kw">return</span> product;
}</code></pre></div>
<h3 id="expressive-power">Expressive power</h3>

<p>Most <a href="programming_language" title="wikilink">programming languages</a> in use today allow the direct specification of recursive functions and procedures. When such a function is called, the program's <a href="runtime_environment" title="wikilink">runtime environment</a> keeps track of the various instances of the function (often using a <a href="call_stack" title="wikilink">call stack</a>, although other methods may be used). Every recursive function can be transformed into an iterative function by replacing recursive calls with <a href="Control_operator#Loops" title="wikilink">iterative control constructs</a> and simulating the call stack with a <a href="stack_(data_structure)" title="wikilink">stack</a> explicitly managed by the program.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a><a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a></p>

<p>Conversely, all iterative functions and procedures that can be evaluated by a computer (see <a href="Turing_completeness" title="wikilink">Turing completeness</a>) can be expressed in terms of recursive functions; iterative control constructs such as <a href="while_loop" title="wikilink">while loops</a> and <a href="do_loop" title="wikilink">do loops</a> are routinely rewritten in recursive form in <a href="functional_language" title="wikilink">functional languages</a>.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a><a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a> However, in practice this rewriting depends on <a href="tail_call_elimination" title="wikilink">tail call elimination</a>, which is not a feature of all languages. <a href="C_(programming_language)" title="wikilink">C</a>, <a href="Java_(programming_language)" title="wikilink">Java</a>, and <a href="Python_(programming_language)" title="wikilink">Python</a> are notable mainstream languages in which all function calls, including <a href="tail_call" title="wikilink">tail calls</a>, cause stack allocation that would not occur with the use of looping constructs; in these languages, a working iterative program rewritten in recursive form may <a href="stack_overflow" title="wikilink">overflow the call stack</a>.</p>
<h3 id="performance-issues">Performance issues</h3>

<p>In languages (such as <a href="C_(programming_language)" title="wikilink">C</a> and <a href="Java_(programming_language)" title="wikilink">Java</a>) that favor iterative looping constructs, there is usually significant time and space cost associated with recursive programs, due to the overhead required to manage the stack and the relative slowness of function calls; in <a href="functional_languages" title="wikilink">functional languages</a>, a function call (particularly a <a href="tail_call" title="wikilink">tail call</a>) is typically a very fast operation, and the difference is usually less noticeable.</p>

<p>As a concrete example, the difference in performance between recursive and iterative implementations of the "factorial" example above depends highly on the compiler used. In languages where looping constructs are preferred, the iterative version may be as much as several orders of magnitude faster than the recursive one. In functional languages, the overall time difference of the two implementations may be negligible; in fact, the cost of multiplying the larger numbers first rather than the smaller numbers (which the iterative version given here happens to do) may overwhelm any time saved by choosing iteration.</p>
<h3 id="stack-space">Stack space</h3>

<p>In some programming languages, the stack space available to a thread is much less than the space available in the heap, and recursive algorithms tend to require more stack space than iterative algorithms. Consequently, these languages sometimes place a limit on the depth of recursion to avoid stack overflows; <a href="python_(programming_language)" title="wikilink">Python</a> is one such language.<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a> Note the caveat below regarding the special case of <a href="tail_recursion" title="wikilink">tail recursion</a>.</p>
<h3 id="multiply-recursive-problems">Multiply recursive problems</h3>

<p>Multiply recursive problems are inherently recursive, because of prior state they need to track. One example is <a href="tree_traversal" title="wikilink">tree traversal</a> as in <a href="depth-first_search" title="wikilink">depth-first search</a>; contrast with list traversal and linear search in a list, which is singly recursive and thus naturally iterative. Other examples include <a href="divide-and-conquer_algorithm" title="wikilink">divide-and-conquer algorithms</a> such as <a class="uri" href="Quicksort" title="wikilink">Quicksort</a>, and functions such as the <a href="Ackermann_function" title="wikilink">Ackermann function</a>. All of these algorithms can be implemented iteratively with the help of an explicit <a href="stack_(data_structure)" title="wikilink">stack</a>, but the programmer effort involved in managing the stack, and the complexity of the resulting program, arguably outweigh any advantages of the iterative solution.</p>
<h2 id="tail-recursive-functions">Tail-recursive functions</h2>

<p>Tail-recursive functions are functions in which all recursive calls are <a href="tail_call" title="wikilink">tail calls</a> and hence do not build up any deferred operations. For example, the gcd function (shown again below) is tail-recursive. In contrast, the factorial function (also below) is <strong>not</strong> tail-recursive; because its recursive call is not in tail position, it builds up deferred multiplication operations that must be performed after the final recursive call completes. With a <a class="uri" href="compiler" title="wikilink">compiler</a> or <a class="uri" href="interpreter" title="wikilink">interpreter</a> that treats tail-recursive calls as <a href="goto" title="wikilink">jumps</a> rather than function calls, a tail-recursive function such as gcd will execute using constant space. Thus the program is essentially iterative, equivalent to using imperative language control structures like the "for" and "while" loops.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p><a href="Tail_recursion" title="wikilink">Tail recursion</a>:</p></th>
<th style="text-align: left;">
<p>Augmenting recursion:</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="co">//INPUT: Integers x, y such that x &gt;= y and y &gt; 0</span>
<span class="dt">int</span> gcd(<span class="dt">int</span> x, <span class="dt">int</span> y)
{
  <span class="kw">if</span> (y == <span class="dv">0</span>)
     <span class="kw">return</span> x;
  <span class="kw">else</span>
     <span class="kw">return</span> gcd(y, x % y);
}</code></pre></div></td>
<td style="text-align: left;"><div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="co">//INPUT: n is an Integer such that n &gt;= 0</span>
<span class="dt">int</span> fact(<span class="dt">int</span> n)
{
   <span class="kw">if</span> (n == <span class="dv">0</span>)
      <span class="kw">return</span> <span class="dv">1</span>;
   <span class="kw">else</span>
      <span class="kw">return</span> n * fact(n - <span class="dv">1</span>);
}</code></pre></div></td>
</tr>
</tbody>
</table>

<p>The significance of tail recursion is that when making a tail-recursive call (or any tail call), the caller's return position need not be saved on the <a href="call_stack" title="wikilink">call stack</a>; when the recursive call returns, it will branch directly on the previously saved return position. Therefore, in languages that recognize this property of tail calls, tail recursion saves both space and time.</p>
<h2 id="order-of-execution">Order of execution</h2>

<p>In the simple case of a function calling itself only once, instructions placed before the recursive call are executed once per recursion before any of the instructions placed after the recursive call. The latter are executed repeatedly after the maximum recursion has been reached. Consider this example:</p>
<h3 id="function-1">Function 1</h3>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> recursiveFunction(<span class="dt">int</span> num) {
   printf(<span class="st">"%d</span><span class="ch">\n</span><span class="st">"</span>, num);
   <span class="kw">if</span> (num &lt; <span class="dv">4</span>)
      recursiveFunction(num + <span class="dv">1</span>);
}</code></pre></div>
<figure><b>(Figure)</b>
<figcaption>RecursiveFunction1 execution.png</figcaption>
</figure>
<h3 id="function-2-with-swapped-lines">Function 2 with swapped lines</h3>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> recursiveFunction(<span class="dt">int</span> num) {
   <span class="kw">if</span> (num &lt; <span class="dv">4</span>)
      recursiveFunction(num + <span class="dv">1</span>);
   printf(<span class="st">"%d</span><span class="ch">\n</span><span class="st">"</span>, num);
}</code></pre></div>
<figure><b>(Figure)</b>
<figcaption>RecursiveFunction2 execution.png</figcaption>
</figure>
<h2 id="time-efficiency-of-recursive-algorithms">Time-efficiency of recursive algorithms</h2>

<p>The <a href="time_complexity" title="wikilink">time efficiency</a> of recursive algorithms can be expressed in a <a href="recurrence_relation" title="wikilink">recurrence relation</a> of <a href="Big_O_notation" title="wikilink">Big O notation</a>. They can (usually) then be simplified into a single Big-Oh term.</p>
<h3 id="shortcut-rule">Shortcut rule</h3>

<p>If the time-complexity of the function is in the form</p>

<p>

<math display="inline" id="Recursion_(computer_science):17">
 <semantics>
  <mrow>
   <mrow>
    <mi>T</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <mi>a</mi>
      <mo>⋅</mo>
      <mi>T</mi>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>n</mi>
       <mo>/</mo>
       <mi>b</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>O</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msup>
       <mi>n</mi>
       <mi>k</mi>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>T</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <ci>normal-⋅</ci>
       <ci>a</ci>
       <ci>T</ci>
      </apply>
      <apply>
       <divide></divide>
       <ci>n</ci>
       <ci>b</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>O</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>n</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T(n)=a\cdot T(n/b)+O(n^{k})
  </annotation>
 </semantics>
</math>

</p>

<p>Then the Big-Oh of the time-complexity is thus:</p>
<ul>
<li>If 

<math display="inline" id="Recursion_(computer_science):18">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo>></mo>
   <msup>
    <mi>b</mi>
    <mi>k</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <ci>a</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>b</ci>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a>b^{k}
  </annotation>
 </semantics>
</math>

, then the time-complexity is 

<math display="inline" id="Recursion_(computer_science):19">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>n</mi>
     <mrow>
      <msub>
       <mi>log</mi>
       <mi>b</mi>
      </msub>
      <mi>a</mi>
     </mrow>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>n</ci>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <log></log>
       <ci>b</ci>
      </apply>
      <ci>a</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n^{\log_{b}a})
  </annotation>
 </semantics>
</math>

</li>
<li>If 

<math display="inline" id="Recursion_(computer_science):20">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo>=</mo>
   <msup>
    <mi>b</mi>
    <mi>k</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>a</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>b</ci>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a=b^{k}
  </annotation>
 </semantics>
</math>

, then the time-complexity is 

<math display="inline" id="Recursion_(computer_science):21">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msup>
      <mi>n</mi>
      <mi>k</mi>
     </msup>
     <mo>⋅</mo>
     <mrow>
      <mi>log</mi>
      <mi>n</mi>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <ci>normal-⋅</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>n</ci>
      <ci>k</ci>
     </apply>
     <apply>
      <log></log>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n^{k}\cdot\log n)
  </annotation>
 </semantics>
</math>

</li>
<li>If 

<math display="inline" id="Recursion_(computer_science):22">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo><</mo>
   <msup>
    <mi>b</mi>
    <mi>k</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <ci>a</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>b</ci>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a<b^{k}
  </annotation>
 </semantics>
</math>

, then the time-complexity is 

<math display="inline" id="Recursion_(computer_science):23">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>n</mi>
     <mi>k</mi>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>n</ci>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n^{k})
  </annotation>
 </semantics>
</math>

</li>
</ul>

<p>where 

<math display="inline" id="Recursion_(computer_science):24">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 represents the number of recursive calls at each level of recursion, 

<math display="inline" id="Recursion_(computer_science):25">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>

 represents by what factor smaller the input is for the next level of recursion (i.e. the number of pieces you divide the problem into), and 

<math display="inline" id="Recursion_(computer_science):26">
 <semantics>
  <msup>
   <mi>n</mi>
   <mi>k</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>n</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n^{k}
  </annotation>
 </semantics>
</math>

 represents the work the function does independent of any recursion (e.g. partitioning, recombining) at each level of recursion.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Ackermann_function" title="wikilink">Ackermann function</a></li>
<li><a class="uri" href="Corecursion" title="wikilink">Corecursion</a></li>
<li><a href="Functional_programming" title="wikilink">Functional programming</a></li>
<li><a href="Hierarchical_and_recursive_queries_in_SQL" title="wikilink">Hierarchical and recursive queries in SQL</a></li>
<li><a href="Kleene–Rosser_paradox" title="wikilink">Kleene–Rosser paradox</a></li>
<li><a href="McCarthy_91_function" title="wikilink">McCarthy 91 function</a></li>
<li><a class="uri" href="Memoization" title="wikilink">Memoization</a></li>
<li><a href="μ-recursive_function" title="wikilink">μ-recursive function</a></li>
<li><a href="Open_recursion" title="wikilink">Open recursion</a></li>
<li><a href="Primitive_recursive_function" title="wikilink">Primitive recursive function</a></li>
<li><a class="uri" href="Recursion" title="wikilink">Recursion</a></li>
<li><a href="Sierpiński_curve" title="wikilink">Sierpiński curve</a></li>
<li><a href="Tak_(function)" title="wikilink">Takeuchi function</a></li>
</ul>
<h2 id="notes-and-references">Notes and references</h2>
<h2 id="further-reading">Further reading</h2>
<ul>
<li></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://mitpress.mit.edu/sicp/full-text/book/book.html">Harold Abelson and Gerald Sussman: "Structure and Interpretation Of Computer Programs"</a></li>
<li><a href="http://www.ibm.com/developerworks/linux/library/l-recurs/index.html">Jonathan Bartlett: "Mastering Recursive Programming"</a></li>
<li><a href="http://www.cs.cmu.edu/~dst/LispBook/">David S. Touretzky: "Common Lisp: A Gentle Introduction to Symbolic Computation"</a></li>
<li><a href="http://www.htdp.org/2003-09-26/Book/">Matthias Felleisen: "How To Design Programs: An Introduction to Computing and Programming"</a></li>
<li><a href="http://www.cs.duke.edu/~ola/ap/recurrence.html">Owen L. Astrachan: "Big-Oh for Recursive Functions: Recurrence Relations"</a></li>
</ul>

<p>"</p>

<p><a href="Category:Theoretical_computer_science" title="wikilink">Category:Theoretical computer science</a> <a class="uri" href="Category:Recursion" title="wikilink">Category:Recursion</a> <a href="Category:Computability_theory" title="wikilink">Category:Computability theory</a> <a href="Category:Articles_with_example_pseudocode" title="wikilink">Category:Articles with example pseudocode</a> <a href="Category:Programming_idioms" title="wikilink">Category:Programming idioms</a> <a class="uri" href="Category:Subroutines" title="wikilink">Category:Subroutines</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
<li id="fn10"><a href="#fnref10">↩</a></li>
<li id="fn11">.<a href="#fnref11">↩</a></li>
<li id="fn12">.<a href="#fnref12">↩</a></li>
<li id="fn13"><a href="#fnref13">↩</a></li>
<li id="fn14"><a href="#fnref14">↩</a></li>
<li id="fn15"><a href="#fnref15">↩</a></li>
</ol>
</section>
</body>

