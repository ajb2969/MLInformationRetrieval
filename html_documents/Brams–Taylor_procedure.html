<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="66">Brams–Taylor procedure</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Brams–Taylor procedure</h1>
<hr/>

<p>The <strong>Brams–Taylor procedure</strong> (BTP) is a procedure for <a class="uri" href="envy-free" title="wikilink">envy-free</a> <a href="fair_cake-cutting" title="wikilink">fair cake-cutting</a>. It explicated the first finite procedure to produce an envy-free division of an cake among any positive integer number of players.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>
<h2 id="history">History</h2>

<p>In 1988, prior to the discovery of the BTP, <a href="Sol_Garfunkel" title="wikilink">Sol Garfunkel</a> contended that the problem solved by the theorem, namely n-person envy-free cake-cutting, was among the most important problems in 20th century mathematics.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>

<p>The BTP was discovered by <a href="Steven_Brams" title="wikilink">Steven Brams</a> and <a href="Alan_D._Taylor" title="wikilink">Alan D. Taylor</a>. It was first published in the January 1995 issue of <a href="American_Mathematical_Monthly" title="wikilink">American Mathematical Monthly</a>,<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> and later in 1996 in the authors' book..<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>

<p>Brams and Taylor hold a joint <a href="US_patent" title="wikilink">US patent</a> from 1999 related to the BTP.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>
<h2 id="description">Description</h2>

<p>The BTP divides the cake part-by-part. A typical intermediate state of the BTP is as follows:</p>
<ul>
<li>A part of the cake, say 

<math display="inline" id="Brams–Taylor_procedure:0">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

, is divided in an envy-free way among all partners.</li>
<li>The rest of the cake, say 

<math display="inline" id="Brams–Taylor_procedure:1">
 <semantics>
  <mi>Y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y
  </annotation>
 </semantics>
</math>

, remains undivided, but -</li>
<li>One partner, say Alice, has an <strong>Irrevocable Advantage</strong> (IA) over another partner, say Bob, with respect to 

<math display="inline" id="Brams–Taylor_procedure:2">
 <semantics>
  <mi>Y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y
  </annotation>
 </semantics>
</math>

. This means that, regardless of how 

<math display="inline" id="Brams–Taylor_procedure:3">
 <semantics>
  <mi>Y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y
  </annotation>
 </semantics>
</math>


 is divided, even if we give 

<math display="inline" id="Brams–Taylor_procedure:4">
 <semantics>
  <mi>Y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y
  </annotation>
 </semantics>
</math>

 entirely to Bob, Alice still doesn't envy Bob.</li>
</ul>

<p>As an example of how an IA can be generated, consider the first stage of the <a href="Selfridge–Conway_discrete_procedure" title="wikilink">Selfridge–Conway discrete procedure</a>:</p>
<ul>
<li>Alice divides the cake to 3 parts she considers equal; let's call the parts 

<math display="inline" id="Brams–Taylor_procedure:5">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>,</mo>
   <mi>B</mi>
   <mo>,</mo>
   <mi>C</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>A</ci>
    <ci>B</ci>
    <ci>C</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A,B,C
  </annotation>
 </semantics>
</math>

.</li>
<li>Bob trims the piece he considers largest (say, 

<math display="inline" id="Brams–Taylor_procedure:6">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

) to make it equal to the second-largest; let's call the trimmings 

<math display="inline" id="Brams–Taylor_procedure:7">
 <semantics>
  <mi>Y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y
  </annotation>
 </semantics>
</math>

 and the trimmed piece 

<math display="inline" id="Brams–Taylor_procedure:8">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>∖</mo>
   <mi>Y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <setdiff></setdiff>
    <ci>A</ci>
    <ci>Y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\setminus Y
  </annotation>
 </semantics>
</math>


.</li>
<li>Charlie chooses a piece out of 

<math display="inline" id="Brams–Taylor_procedure:9">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>A</mi>
     <mo>∖</mo>
     <mi>Y</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>,</mo>
   <mi>B</mi>
   <mo>,</mo>
   <mi>C</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <setdiff></setdiff>
     <ci>A</ci>
     <ci>Y</ci>
    </apply>
    <ci>B</ci>
    <ci>C</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (A\setminus Y),B,C
  </annotation>
 </semantics>
</math>

; then Bob chooses (he must take 

<math display="inline" id="Brams–Taylor_procedure:10">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi>A</mi>
    <mo>∖</mo>
    <mi>Y</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <setdiff></setdiff>
    <ci>A</ci>
    <ci>Y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (A\setminus Y)
  </annotation>
 </semantics>
</math>

 if it is available); and lastly Alice.</li>
</ul>

<p>After this stage is done, all the cake except 

<math display="inline" id="Brams–Taylor_procedure:11">
 <semantics>
  <mi>Y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y
  </annotation>
 </semantics>
</math>

 is divided in an envy-free way. Additionally, Alice now has an IA over whoever took 

<math display="inline" id="Brams–Taylor_procedure:12">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi>A</mi>
    <mo>∖</mo>
    <mi>Y</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <setdiff></setdiff>
    <ci>A</ci>
    <ci>Y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (A\setminus Y)
  </annotation>
 </semantics>
</math>

. Why? because Alice took either 

<math display="inline" id="Brams–Taylor_procedure:13">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>


 or 

<math display="inline" id="Brams–Taylor_procedure:14">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

, and both of them are equal to 

<math display="inline" id="Brams–Taylor_procedure:15">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 in her opinion. So, in Alice's opinion, whoever took 

<math display="inline" id="Brams–Taylor_procedure:16">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi>A</mi>
    <mo>∖</mo>
    <mi>Y</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <setdiff></setdiff>
    <ci>A</ci>
    <ci>Y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (A\setminus Y)
  </annotation>
 </semantics>
</math>

 can also have 

<math display="inline" id="Brams–Taylor_procedure:17">
 <semantics>
  <mi>Y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y
  </annotation>
 </semantics>
</math>

 – this will not make her envy.</p>

<p>If we want to make sure that Alice gets an IA over a specific player (e.g. Bob), then a much more complicated procedure is required. It successively divides the cake to smaller and smaller pieces, always giving Alice a piece that she values more than Bob's, so that an IA is maintained. This might take an unbounded time – depending on the exact valuations of Alice and Bob.</p>

<p>Using the IA procedure, the main BTP procedure creates IAs for all ordered pairs of partners. For example, when there are 4 partners, there are 12 ordered pairs of partners. For each such pair (X,Y), we run a sub-procedure which guarantees that partner X has an IA over partner Y. After every partner has an IA over every other partner, we can just give the remainder to an arbitrary partner and the result is an envy-free division of the entire cake.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Brams–Taylor–Zwicker_procedure" title="wikilink">Brams–Taylor–Zwicker procedure</a> – a moving-knife procedure for 4 partners, which uses a finite number of cuts.</li>
</ul>
<h2 id="references">References</h2>

<p>"</p>

<p><a href="Category:Fair_division_protocols" title="wikilink">Category:Fair division protocols</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="http://www.comap.com/product/?idx=746">More Equal than Others: Weighted Voting</a> <a href="Sol_Garfunkel" title="wikilink">Sol Garfunkel</a>. For All Practical Purposes. COMAP. 1988<a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
</ol>
</section>
</body>
</html>
