<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="85">Lebesgue constant (interpolation)</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Lebesgue constant (interpolation)</h1>
<hr/>
<dl>
<dd><em>For other uses, see: <a href="Lebesgue_constant_(disambiguation)" title="wikilink">Lebesgue constant (disambiguation)</a>.</em>
</dd>
</dl>

<p>In <a class="uri" href="mathematics" title="wikilink">mathematics</a>, the <strong>Lebesgue constants</strong> (depending on a set of nodes and of its size) give an idea of how good the <a href="interpolation" title="wikilink">interpolant</a> of a <a href="Function_(mathematics)" title="wikilink">function</a> (at the given nodes) is in comparison with the best <a class="uri" href="polynomial" title="wikilink">polynomial</a> <a class="uri" href="approximation" title="wikilink">approximation</a> of the function (the degree of the polynomials are obviously fixed). The Lebesgue constant for polynomials of degree at most 

<math display="inline" id="Lebesgue_constant_(interpolation):0">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 and for the set of 

<math display="inline" id="Lebesgue_constant_(interpolation):1">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>+</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>n</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n+1
  </annotation>
 </semantics>
</math>

 nodes 

<math display="inline" id="Lebesgue_constant_(interpolation):2">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

 is generally denoted by <mtpl></mtpl>. These constants are named after <a href="Henri_Lebesgue" title="wikilink">Henri Lebesgue</a>.</p>
<h2 id="definition">Definition</h2>

<p>We fix the interpolation nodes <em>x</em><sub>0</sub>, ..., <em>x<sub>n</sub></em> and an <a href="Interval_(mathematics)" title="wikilink">interval</a> [<em>a</em>, <em>b</em>] containing all the interpolation nodes. The process of interpolation maps the function <em>f</em> to a polynomial <em>p</em>. This defines a mapping <em>X</em> from the space <em>C</em>([<em>a</em>, <em>b</em>]) of all continuous functions on [<em>a</em>, <em>b</em>] to itself. The map <em>X</em> is linear and it is a <a href="projection_(linear_algebra)" title="wikilink">projection</a> on the subspace <mtpl></mtpl> of polynomials of degree 

<math display="inline" id="Lebesgue_constant_(interpolation):3">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>


 or less.</p>

<p>The Lebesgue constant <mtpl></mtpl> is defined as the <a href="operator_norm" title="wikilink">operator norm</a> of <em>X</em>. This definition requires us to specify a norm on <em>C</em>([<em>a</em>, <em>b</em>]). The <a href="maximum_norm" title="wikilink">maximum norm</a> is usually the most convenient.</p>
<h2 id="properties">Properties</h2>

<p>The Lebesgue constant bounds the interpolation error:</p>

<p>

<math display="block" id="Lebesgue_constant_(interpolation):4">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>∥</mo>
     <mrow>
      <mi>f</mi>
      <mo>-</mo>
      <mrow>
       <mi>X</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>f</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo>∥</mo>
    </mrow>
    <mo>≤</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <msub>
         <mi mathvariant="normal">Λ</mi>
         <mi>n</mi>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>T</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo>∥</mo>
      <mrow>
       <mi>f</mi>
       <mo>-</mo>
       <msup>
        <mi>p</mi>
        <mo>*</mo>
       </msup>
      </mrow>
      <mo>∥</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <csymbol cd="latexml">norm</csymbol>
     <apply>
      <minus></minus>
      <ci>f</ci>
      <apply>
       <times></times>
       <ci>X</ci>
       <ci>f</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>normal-Λ</ci>
        <ci>n</ci>
       </apply>
       <ci>T</ci>
      </apply>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="latexml">norm</csymbol>
      <apply>
       <minus></minus>
       <ci>f</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>p</ci>
        <times></times>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \|f-X(f)\|\leq(\Lambda_{n}(T)+1)\left\|f-p^{*}\right\|.
  </annotation>
 </semantics>
</math>

</p>

<p>We will here prove this statement with the maximum norm. Let <mtpl></mtpl> denote the best approximation of <em>f</em> among the polynomials of degree 

<math display="inline" id="Lebesgue_constant_(interpolation):5">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 or less. In other words, <mtpl></mtpl> minimizes 

<math display="inline" id="Lebesgue_constant_(interpolation):6">
 <semantics>
  <mrow>
   <mo lspace="0pt" rspace="3.5pt">!</mo>
   <mo lspace="0pt" rspace="3.5pt">!</mo>
   <mi>p</mi>
   <mi mathvariant="normal">−</mi>
   <mi>f</mi>
   <mo lspace="0pt" rspace="3.5pt">!</mo>
   <mo lspace="0pt" rspace="3.5pt">!</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <factorial></factorial>
    <factorial></factorial>
    <csymbol cd="unknown">p</csymbol>
    <csymbol cd="unknown">−</csymbol>
    <csymbol cd="unknown">f</csymbol>
    <factorial></factorial>
    <factorial></factorial>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {{!!}}p−f{{!!}}
  </annotation>
 </semantics>
</math>

 among all <em>p</em> in Π<sub><em>n</em></sub>. Then</p>

<p>

<math display="block" id="Lebesgue_constant_(interpolation):7">
 <semantics>
  <mrow>
   <mrow>
    <mo>∥</mo>
    <mrow>
     <mi>f</mi>
     <mo>-</mo>
     <mrow>
      <mi>X</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>f</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>∥</mo>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mrow>
     <mo>∥</mo>
     <mrow>
      <mi>f</mi>
      <mo>-</mo>
      <msup>
       <mi>p</mi>
       <mo>*</mo>
      </msup>
     </mrow>
     <mo>∥</mo>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mo>∥</mo>
     <mrow>
      <msup>
       <mi>p</mi>
       <mo>*</mo>
      </msup>
      <mo>-</mo>
      <mrow>
       <mi>X</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>f</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo>∥</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <csymbol cd="latexml">norm</csymbol>
     <apply>
      <minus></minus>
      <ci>f</ci>
      <apply>
       <times></times>
       <ci>X</ci>
       <ci>f</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="latexml">norm</csymbol>
      <apply>
       <minus></minus>
       <ci>f</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>p</ci>
        <times></times>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">norm</csymbol>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>p</ci>
        <times></times>
       </apply>
       <apply>
        <times></times>
        <ci>X</ci>
        <ci>f</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \|f-X(f)\|\leq\|f-p^{*}\|+\|p^{*}-X(f)\|
  </annotation>
 </semantics>
</math>

</p>

<p>by the <a href="triangle_inequality" title="wikilink">triangle inequality</a>. But <em>X</em> is a projection on Π<sub><em>n</em></sub>, so</p>
<dl>
<dd><mtpl> <em>X</em>(<em>p</em><sup>∗</sup>) − <em>X</em>( <em>f</em> ) {{=}} <em>X</em>(<em>p</em><sup>∗</sup> − <em>f</em> )}}</mtpl>.
</dd>
</dl>

<p>This finishes the proof. Note that this relation comes also as a special case of <a href="Lebesgue's_lemma" title="wikilink">Lebesgue's lemma</a>.</p>

<p>In other words, the interpolation polynomial is at most a factor <mtpl></mtpl> worse than the best possible approximation. This suggests that we look for a set of interpolation nodes with a small Lebesgue constant.</p>

<p>The Lebesgue constant can be expressed in terms of the <a href="Lagrange_polynomial" title="wikilink">Lagrange basis</a> polynomials:</p>

<p>

<math display="block" id="Lebesgue_constant_(interpolation):8">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>l</mi>
     <mi>j</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>:=</mo>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∏</mo>
     <mtable>
      <mtr>
       <mtd columnalign="center">
        <mrow>
         <mi mathsize="70%" stretchy="false">i</mi>
         <mo mathsize="70%" stretchy="false">=</mo>
         <mn mathsize="70%" stretchy="false">0</mn>
        </mrow>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mrow>
         <mi mathsize="70%" stretchy="false">j</mi>
         <mo mathsize="70%" stretchy="false">≠</mo>
         <mi mathsize="70%" stretchy="false">i</mi>
        </mrow>
       </mtd>
      </mtr>
     </mtable>
     <mi>n</mi>
    </munderover>
    <mfrac>
     <mrow>
      <mi>x</mi>
      <mo>-</mo>
      <msub>
       <mi>x</mi>
       <mi>i</mi>
      </msub>
     </mrow>
     <mrow>
      <msub>
       <mi>x</mi>
       <mi>j</mi>
      </msub>
      <mo>-</mo>
      <msub>
       <mi>x</mi>
       <mi>i</mi>
      </msub>
     </mrow>
    </mfrac>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>l</ci>
      <ci>j</ci>
     </apply>
     <ci>x</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <csymbol cd="latexml">product</csymbol>
       <matrix>
        <matrixrow>
         <apply>
          <eq></eq>
          <ci>i</ci>
          <cn type="integer">0</cn>
         </apply>
        </matrixrow>
        <matrixrow>
         <apply>
          <neq></neq>
          <ci>j</ci>
          <ci>i</ci>
         </apply>
        </matrixrow>
       </matrix>
      </apply>
      <ci>n</ci>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <minus></minus>
       <ci>x</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>i</ci>
       </apply>
      </apply>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>j</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>i</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   l_{j}(x):=\prod_{\begin{smallmatrix}i=0\\
j\neq i\end{smallmatrix}}^{n}\frac{x-x_{i}}{x_{j}-x_{i}}
  </annotation>
 </semantics>
</math>

</p>

<p>In fact, we have the Lebesgue function</p>

<p>

<math display="block" id="Lebesgue_constant_(interpolation):9">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>λ</mi>
      <mi>n</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>j</mi>
       <mo>=</mo>
       <mn>0</mn>
      </mrow>
      <mi>n</mi>
     </munderover>
     <mrow>
      <mo stretchy="false">|</mo>
      <mrow>
       <msub>
        <mi>l</mi>
        <mi>j</mi>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">|</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>λ</ci>
      <ci>n</ci>
     </apply>
     <ci>x</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>j</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <ci>n</ci>
     </apply>
     <apply>
      <abs></abs>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>l</ci>
        <ci>j</ci>
       </apply>
       <ci>x</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda_{n}(x)=\sum_{j=0}^{n}|l_{j}(x)|.
  </annotation>
 </semantics>
</math>

</p>

<p>and the Lebesgue constant (or Lebesgue number) for the grid is its maximum value</p>

<p>

<math display="block" id="Lebesgue_constant_(interpolation):10">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi mathvariant="normal">Λ</mi>
     <mi>n</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>T</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <munder>
      <mi>max</mi>
      <mrow>
       <mi>x</mi>
       <mo>∈</mo>
       <mrow>
        <mo stretchy="false">[</mo>
        <mi>a</mi>
        <mo>,</mo>
        <mi>b</mi>
        <mo stretchy="false">]</mo>
       </mrow>
      </mrow>
     </munder>
     <msub>
      <mi>λ</mi>
      <mi>n</mi>
     </msub>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-Λ</ci>
      <ci>n</ci>
     </apply>
     <ci>T</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <max></max>
       <apply>
        <in></in>
        <ci>x</ci>
        <interval closure="closed">
         <ci>a</ci>
         <ci>b</ci>
        </interval>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>λ</ci>
       <ci>n</ci>
      </apply>
     </apply>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Lambda_{n}(T)=\max_{x\in[a,b]}\lambda_{n}(x)
  </annotation>
 </semantics>
</math>

</p>

<p>Nevertheless, it is not easy to find an explicit expression for <mtpl></mtpl>.</p>
<h2 id="minimal-lebesgue-constants">Minimal Lebesgue constants</h2>

<p>In the case of equidistant nodes, the Lebesgue constant <a href="exponential_growth" title="wikilink">grows exponentially</a>. More precisely, we have the following asymptotic estimate</p>

<p>

<math display="block" id="Lebesgue_constant_(interpolation):11">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <msub>
       <mi mathvariant="normal">Λ</mi>
       <mi>n</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>T</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>∼</mo>
     <mfrac>
      <msup>
       <mn>2</mn>
       <mrow>
        <mi>n</mi>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
      </msup>
      <mrow>
       <mpadded width="+1.7pt">
        <mi>e</mi>
       </mpadded>
       <mi>n</mi>
       <mrow>
        <mi>log</mi>
        <mi>n</mi>
       </mrow>
      </mrow>
     </mfrac>
    </mrow>
    <mrow>
     <mrow>
      <mtext>as</mtext>
      <mi>n</mi>
     </mrow>
     <mo>→</mo>
     <mi mathvariant="normal">∞</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <csymbol cd="latexml">similar-to</csymbol>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>normal-Λ</ci>
       <ci>n</ci>
      </apply>
      <ci>T</ci>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">2</cn>
       <apply>
        <plus></plus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>e</ci>
       <ci>n</ci>
       <apply>
        <log></log>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <times></times>
      <mtext>as</mtext>
      <ci>n</ci>
     </apply>
     <infinity></infinity>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Lambda_{n}(T)\sim\frac{2^{n+1}}{e\,n\log n}\qquad\text{ as }n\to\infty.
  </annotation>
 </semantics>
</math>

</p>

<p>On the other hand, the Lebesgue constant grows only logarithmically if <a href="Chebyshev_nodes" title="wikilink">Chebyshev nodes</a> are used, since we have</p>

<p>

<math display="block" id="Lebesgue_constant_(interpolation):12">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mstyle displaystyle="false">
       <mfrac>
        <mn>2</mn>
        <mi>π</mi>
       </mfrac>
      </mstyle>
      <mrow>
       <mi>log</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>n</mi>
         <mo>+</mo>
         <mn>1</mn>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mi>a</mi>
    </mrow>
    <mo><</mo>
    <mrow>
     <msub>
      <mi mathvariant="normal">Λ</mi>
      <mi>n</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>T</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo><</mo>
    <mrow>
     <mrow>
      <mstyle displaystyle="false">
       <mfrac>
        <mn>2</mn>
        <mi>π</mi>
       </mfrac>
      </mstyle>
      <mrow>
       <mi>log</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>n</mi>
         <mo>+</mo>
         <mn>1</mn>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </mrow>
   <mo rspace="22.5pt">,</mo>
   <mrow>
    <mi>a</mi>
    <mo>=</mo>
    <mrow>
     <mn>0.9625</mn>
     <mi mathvariant="normal">⋯</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <and></and>
     <apply>
      <lt></lt>
      <apply>
       <plus></plus>
       <apply>
        <times></times>
        <apply>
         <divide></divide>
         <cn type="integer">2</cn>
         <ci>π</ci>
        </apply>
        <apply>
         <log></log>
         <apply>
          <plus></plus>
          <ci>n</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
       </apply>
       <ci>a</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>normal-Λ</ci>
        <ci>n</ci>
       </apply>
       <ci>T</ci>
      </apply>
     </apply>
     <apply>
      <lt></lt>
      <share href="#.cmml">
      </share>
      <apply>
       <plus></plus>
       <apply>
        <times></times>
        <apply>
         <divide></divide>
         <cn type="integer">2</cn>
         <ci>π</ci>
        </apply>
        <apply>
         <log></log>
         <apply>
          <plus></plus>
          <ci>n</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
       </apply>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <ci>a</ci>
     <apply>
      <times></times>
      <cn type="float">0.9625</cn>
      <ci>normal-⋯</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tfrac{2}{\pi}\log(n+1)+a<\Lambda_{n}(T)<\tfrac{2}{\pi}\log(n+1)+1,\qquad a=0.%
9625\cdots
  </annotation>
 </semantics>
</math>

</p>

<p>We conclude again that Chebyshev nodes are a very good choice for polynomial interpolation. However, there is an easy (linear) transformation of Chebyshev nodes that gives a better Lebesgue constant. Let <mtpl></mtpl> denote the 

<math display="inline" id="Lebesgue_constant_(interpolation):13">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>


-th Chebyshev node. Then, define</p>

<p>

<math display="block" id="Lebesgue_constant_(interpolation):14">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>s</mi>
     <mi>i</mi>
    </msub>
    <mo>=</mo>
    <mfrac>
     <msub>
      <mi>t</mi>
      <mi>i</mi>
     </msub>
     <mrow>
      <mi>cos</mi>
      <mrow>
       <mo>(</mo>
       <mfrac>
        <mi>π</mi>
        <mrow>
         <mn>2</mn>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <mi>n</mi>
           <mo>+</mo>
           <mn>1</mn>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mfrac>
       <mo>)</mo>
      </mrow>
     </mrow>
    </mfrac>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>s</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>t</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <cos></cos>
      <apply>
       <divide></divide>
       <ci>π</ci>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <apply>
         <plus></plus>
         <ci>n</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s_{i}=\frac{t_{i}}{\cos\left(\frac{\pi}{2(n+1)}\right)}.
  </annotation>
 </semantics>
</math>

</p>

<p>For such nodes:</p>

<p>

<math display="block" id="Lebesgue_constant_(interpolation):15">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi mathvariant="normal">Λ</mi>
      <mi>n</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>S</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo><</mo>
    <mrow>
     <mrow>
      <mstyle displaystyle="false">
       <mfrac>
        <mn>2</mn>
        <mi>π</mi>
       </mfrac>
      </mstyle>
      <mrow>
       <mi>log</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>n</mi>
         <mo>+</mo>
         <mn>1</mn>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mi>b</mi>
    </mrow>
   </mrow>
   <mo rspace="22.5pt">,</mo>
   <mrow>
    <mi>b</mi>
    <mo>=</mo>
    <mrow>
     <mn>0.7219</mn>
     <mi mathvariant="normal">⋯</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <lt></lt>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>normal-Λ</ci>
       <ci>n</ci>
      </apply>
      <ci>S</ci>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <cn type="integer">2</cn>
        <ci>π</ci>
       </apply>
       <apply>
        <log></log>
        <apply>
         <plus></plus>
         <ci>n</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
      <ci>b</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <ci>b</ci>
     <apply>
      <times></times>
      <cn type="float">0.7219</cn>
      <ci>normal-⋯</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Lambda_{n}(S)<\tfrac{2}{\pi}\log(n+1)+b,\qquad b=0.7219\cdots
  </annotation>
 </semantics>
</math>

</p>

<p>Those nodes are, however, not optimal (i.e. they do not minimize the Lebesgue constants) and the search for an optimal set of nodes (which has already been proved to be unique under some assumptions) is still an intriguing topic in mathematics today. However, this set of nodes is optimal for interpolation over 

<math display="inline" id="Lebesgue_constant_(interpolation):16">
 <semantics>
  <mrow>
   <msubsup>
    <mi>C</mi>
    <mi>M</mi>
    <mi>n</mi>
   </msubsup>
   <mrow>
    <mo stretchy="false">[</mo>
    <mrow>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
    <mo>,</mo>
    <mn>1</mn>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>C</ci>
      <ci>M</ci>
     </apply>
     <ci>n</ci>
    </apply>
    <interval closure="closed">
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
     <cn type="integer">1</cn>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{M}^{n}[-1,1]
  </annotation>
 </semantics>
</math>

 the set of 

<math display="inline" id="Lebesgue_constant_(interpolation):17">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 times differentiable functions whose 

<math display="inline" id="Lebesgue_constant_(interpolation):18">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>


-th derivatives are bounded in absolute values by a constant 

<math display="inline" id="Lebesgue_constant_(interpolation):19">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 as shown by N. S. Hoang. Using a <a class="uri" href="computer" title="wikilink">computer</a>, one can approximate the values of the minimal constants, here for the canonical interval 

<math display="inline" id="Lebesgue_constant_(interpolation):20">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">−</mi>
    <mn>1</mn>
   </mrow>
   <mo>,</mo>
   <mn>11</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <times></times>
     <ci>normal-−</ci>
     <cn type="integer">1</cn>
    </apply>
    <cn type="integer">11</cn>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   −1,11
  </annotation>
 </semantics>
</math>

:</p>
<dl>
<dd>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>

<math display="inline" id="Lebesgue_constant_(interpolation):21">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

</p></th>
<th style="text-align: left;">
<p>1</p></th>
<th style="text-align: left;">
<p>2</p></th>
<th style="text-align: left;">
<p>3</p></th>
<th style="text-align: left;">
<p>4</p></th>
<th style="text-align: left;">
<p>5</p></th>
<th style="text-align: left;">
<p>6</p></th>
<th style="text-align: left;">
<p>7</p></th>
<th style="text-align: left;">
<p>8</p></th>
<th style="text-align: left;">
<p>9</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>Λ<sub><em>n</em></sub>(<em>T</em>)</p></td>
<td style="text-align: left;">
<p>1.0000</p></td>
<td style="text-align: left;">
<p>1.2500</p></td>
<td style="text-align: left;">
<p>1.4229</p></td>
<td style="text-align: left;">
<p>1.5595</p></td>
<td style="text-align: left;">
<p>1.6722</p></td>
<td style="text-align: left;">
<p>1.7681</p></td>
<td style="text-align: left;">
<p>1.8516</p></td>
<td style="text-align: left;">
<p>1.9255</p></td>
<td style="text-align: left;">
<p>1.9917</p></td>
</tr>
</tbody>
</table>
</dd>
</dl>

<p>There are several sets of nodes that minimize, for fixed 

<math display="inline" id="Lebesgue_constant_(interpolation):22">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

, the Lebesgue constant. Though if we assume that we always take −1 and 1 as nodes for interpolation, then such a set is unique. To illustrate this property, we shall see what happens when <em>n</em> = 2 (i.e. we consider 3 interpolation nodes in which case the property is not trivial). One can check that each set of nodes of type 

<math display="inline" id="Lebesgue_constant_(interpolation):23">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi mathvariant="normal">−</mi>
    <mi>a</mi>
   </mrow>
   <mo>,</mo>
   <mn>0</mn>
   <mo>,</mo>
   <mi>a</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <apply>
     <times></times>
     <ci>normal-−</ci>
     <ci>a</ci>
    </apply>
    <cn type="integer">0</cn>
    <ci>a</ci>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (−a,0,a)
  </annotation>
 </semantics>
</math>


 is optimal when 

<math display="inline" id="Lebesgue_constant_(interpolation):24">
 <semantics>
  <mrow>
   <mfrac>
    <mrow>
     <mi mathvariant="normal">√</mi>
     <mn>8</mn>
    </mrow>
    <mn>3</mn>
   </mfrac>
   <mi mathvariant="normal">≤</mi>
   <mi>a</mi>
   <mi mathvariant="normal">≤</mi>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <ci>normal-√</ci>
      <cn type="integer">8</cn>
     </apply>
     <cn type="integer">3</cn>
    </apply>
    <ci>normal-≤</ci>
    <ci>a</ci>
    <ci>normal-≤</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{√8}{3}≤a≤1
  </annotation>
 </semantics>
</math>

 (we consider only nodes in [−1, 1]). If we force the set of nodes to be of the type 

<math display="inline" id="Lebesgue_constant_(interpolation):25">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi mathvariant="normal">−</mi>
    <mn>1</mn>
   </mrow>
   <mo>,</mo>
   <mi>b</mi>
   <mo>,</mo>
   <mn>1</mn>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <apply>
     <times></times>
     <ci>normal-−</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>b</ci>
    <cn type="integer">1</cn>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (−1,b,1)
  </annotation>
 </semantics>
</math>

, then <em>b</em> must equal 0 (look at the Lebesgue function, whose maximum is the Lebesgue constant).</p>

<p>If we assume that we take −1 and 1 as nodes for interpolation, then as shown by H.-J. Rack, for the case <em>n</em> = 3, the explicit values of the optimal nodes and the explicit value of the minimal Lebesgue constant are known.</p>

<p>The <a href="Padua_points" title="wikilink">Padua points</a> provide another set of nodes with slow growth (although not as slow as the Chebyshev nodes) and with the additional property of being a <a href="unisolvent_point_set" title="wikilink">unisolvent point set</a>.</p>
<h2 id="sensitivity-of-the-values-of-a-polynomial">Sensitivity of the values of a polynomial</h2>

<p>The Lebesgue constants also arise in another problem. Let <em>p</em>(<em>x</em>) be a polynomial of degree 

<math display="inline" id="Lebesgue_constant_(interpolation):26">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 expressed in the <a href="Lagrange_polynomial" title="wikilink">Lagrangian form</a> associated with the points in the vector <em>t</em> (i.e. the vector <em>u</em> of its coefficients is the vector containing the values 

<math display="inline" id="Lebesgue_constant_(interpolation):27">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>t</mi>
     <mi>i</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>p</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>t</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(t_{i})
  </annotation>
 </semantics>
</math>

). Let 

<math display="inline" id="Lebesgue_constant_(interpolation):28">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>p</mi>
    <mo stretchy="false">^</mo>
   </mover>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <ci>normal-^</ci>
     <ci>p</ci>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{p}(x)
  </annotation>
 </semantics>
</math>


 be a polynomial obtained by slightly changing the coefficients <em>u</em> of the original polynomial <em>p</em>(<em>x</em>) to 

<math display="inline" id="Lebesgue_constant_(interpolation):29">
 <semantics>
  <mover accent="true">
   <mi>u</mi>
   <mo stretchy="false">^</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-^</ci>
    <ci>u</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{u}
  </annotation>
 </semantics>
</math>

. Let us consider the inequality:</p>

<p>

<math display="block" id="Lebesgue_constant_(interpolation):30">
 <semantics>
  <mrow>
   <mfrac>
    <mrow>
     <mo>∥</mo>
     <mrow>
      <mi>p</mi>
      <mo>-</mo>
      <mover accent="true">
       <mi>p</mi>
       <mo stretchy="false">^</mo>
      </mover>
     </mrow>
     <mo>∥</mo>
    </mrow>
    <mrow>
     <mo>∥</mo>
     <mi>p</mi>
     <mo>∥</mo>
    </mrow>
   </mfrac>
   <mo>≤</mo>
   <mrow>
    <msub>
     <mi mathvariant="normal">Λ</mi>
     <mi>n</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>T</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mfrac>
     <mrow>
      <mo>∥</mo>
      <mrow>
       <mi>u</mi>
       <mo>-</mo>
       <mover accent="true">
        <mi>u</mi>
        <mo stretchy="false">^</mo>
       </mover>
      </mrow>
      <mo>∥</mo>
     </mrow>
     <mrow>
      <mo>∥</mo>
      <mi>u</mi>
      <mo>∥</mo>
     </mrow>
    </mfrac>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <divide></divide>
     <apply>
      <csymbol cd="latexml">norm</csymbol>
      <apply>
       <minus></minus>
       <ci>p</ci>
       <apply>
        <ci>normal-^</ci>
        <ci>p</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">norm</csymbol>
      <ci>p</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-Λ</ci>
      <ci>n</ci>
     </apply>
     <ci>T</ci>
     <apply>
      <divide></divide>
      <apply>
       <csymbol cd="latexml">norm</csymbol>
       <apply>
        <minus></minus>
        <ci>u</ci>
        <apply>
         <ci>normal-^</ci>
         <ci>u</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="latexml">norm</csymbol>
       <ci>u</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{\|p-\hat{p}\|}{\|p\|}\leq\Lambda_{n}(T)\frac{\|u-\hat{u}\|}{\|u\|}
  </annotation>
 </semantics>
</math>

</p>

<p>This means that the (relative) error in the values of 

<math display="inline" id="Lebesgue_constant_(interpolation):31">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>p</mi>
    <mo stretchy="false">^</mo>
   </mover>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <ci>normal-^</ci>
     <ci>p</ci>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{p}(x)
  </annotation>
 </semantics>
</math>

 will not be higher than the appropriate Lebesgue constant times the relative error in the coefficients. In this sense, the Lebesgue constant can be viewed as the relative <a href="condition_number" title="wikilink">condition number</a> of the operator mapping each coefficient vector <em>u</em> to the set of the values of the polynomial with coefficients <em>u</em> in the Lagrange form. We can actually define such an operator for each polynomial basis but its condition number is greater than the optimal Lebesgue constant for most convenient bases.</p>
<h2 id="references">References</h2>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li><a href="http://mathworld.wolfram.com/LebesgueConstants.html">Lebesgue constants</a> on <a class="uri" href="MathWorld" title="wikilink">MathWorld</a>.</li>
</ul>

<p>"</p>

<p><a class="uri" href="Category:Interpolation" title="wikilink">Category:Interpolation</a> <a class="uri" href="Category:Polynomials" title="wikilink">Category:Polynomials</a></p>
</body>
</html>
