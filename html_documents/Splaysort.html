<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="794">Splaysort</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Splaysort</h1>
<hr/>

<p>In <a href="computer_science" title="wikilink">computer science</a>, <strong>splaysort</strong> is an <a href="adaptive_sort" title="wikilink">adaptive</a> <a href="comparison_sort" title="wikilink">comparison sorting</a> <a class="uri" href="algorithm" title="wikilink">algorithm</a> based on the <a href="splay_tree" title="wikilink">splay tree</a> <a href="data_structure" title="wikilink">data structure</a>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>
<h2 id="algorithm">Algorithm</h2>

<p>The steps of the algorithm are:</p>
<ol>
<li>Initialize an empty splay tree</li>
<li>For each data item in the input order, insert it into the splay tree</li>
<li>Traverse the splay tree in <a class="uri" href="inorder" title="wikilink">inorder</a> to find the sorted order of the data</li>
</ol>

<p>Thus, the algorithm may be seen as a form of <a href="insertion_sort" title="wikilink">insertion sort</a> or <a href="tree_sort" title="wikilink">tree sort</a>, using a splay tree to speed up each insertion.</p>
<h2 id="analysis">Analysis</h2>

<p>Based on the <a href="amortized_analysis" title="wikilink">amortized analysis</a> of splay trees, the worst case running time of splaysort, on an input with <em>n</em> data items, is <em>O</em>(<em>n</em> log <em>n</em>), matching the time bounds for efficient non-adaptive algorithms such as <a class="uri" href="quicksort" title="wikilink">quicksort</a>, <a href="heap_sort" title="wikilink">heap sort</a>, and <a href="merge_sort" title="wikilink">merge sort</a>.</p>

<p>For an input sequence in which most items are placed close to their predecessor in the sorted order, or are out of order with only a small number of other items, splaysort can be faster than <em>O</em>(<em>n</em> log <em>n</em>), showing that it is an <a href="adaptive_sort" title="wikilink">adaptive sort</a>. To quantify this, let <em>d</em><sub><em>x</em></sub> be the number of positions in the input that separate <em>x</em> from its predecessor, and let <em>i</em><sub><em>x</em></sub> be the number of items that appear on one side of <em>x</em> in the input and on the other side of <em>x</em> in the output (the number of <a href="Inversion_(discrete_mathematics)" title="wikilink">inversions</a> that involve <em>x</em>). Then it follows from the dynamic finger theorem for splay trees that the total time for splaysort is bounded by</p>

<p>

<math display="block" id="Splaysort:0">
 <semantics>
  <mrow>
   <munder>
    <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
    <mi>x</mi>
   </munder>
   <mrow>
    <mi>log</mi>
    <msub>
     <mi>d</mi>
     <mi>x</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <sum></sum>
     <ci>x</ci>
    </apply>
    <apply>
     <log></log>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>d</ci>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{x}\log d_{x}
  </annotation>
 </semantics>
</math>

 and by</p>

<p>

<math display="block" id="Splaysort:1">
 <semantics>
  <mrow>
   <munder>
    <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
    <mi>x</mi>
   </munder>
   <mrow>
    <mi>log</mi>
    <msub>
     <mi>i</mi>
     <mi>x</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <sum></sum>
     <ci>x</ci>
    </apply>
    <apply>
     <log></log>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>i</ci>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{x}\log i_{x}
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>

<p>Splaysort can also be shown to be adaptive to the <a href="Entropy_(information_theory)" title="wikilink">entropy</a> of the input sequence.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>
<h2 id="experimental-results">Experimental results</h2>

<p>In experiments by , splaysort was slower than quicksort on tables of random numbers by a factor of 1.5 to 2, and slower than mergesort by smaller factors. For data consisting of larger records, again in a random order, the additional amount of data movement performed by quicksort significantly slowed it down compared to pointer-based algorithms, and the times for splaysort and mergesort were very close to each other. However, for nearly presorted input sequences (measured in terms of the number of contiguous monotone subsequences in the data, the number of inversions, the number of items that must be removed to make a sorted subsequence, or the number of non-contiguous monotone subsequences into which the input can be partitioned) splaysort became significantly more efficient than the other algorithms.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a>  compared splaysort to several other algorithms that are adaptive to the total number of inversions in the input, as well as to quicksort. They found that, on the inputs that had few enough inversions to make an adaptive algorithm faster than quicksort, splaysort was the fastest algorithm.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>
<h2 id="variations">Variations</h2>

<p>modify splaysort to be more strongly adaptive to the number of contiguous monotone subsequences in the input, and report on experiments showing that the resulting algorithm is faster on inputs that are nearly presorted according to this measure.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>
<h2 id="references">References</h2>

<p>"</p>

<p><a href="Category:Sorting_algorithms" title="wikilink">Category:Sorting algorithms</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2">.<a href="#fnref2">↩</a></li>
<li id="fn3">.<a href="#fnref3">↩</a></li>
<li id="fn4"></li>
<li id="fn5">.<a href="#fnref5">↩</a></li>
<li id="fn6">.<a href="#fnref6">↩</a></li>
</ol>
</section>
</body>
</html>
