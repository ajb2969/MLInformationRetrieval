<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1745">Kind (type theory)</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Kind (type theory)</h1>
<style>
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
<style>
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
</body></html>
<body>
<hr/>

<p>In the area of <a href="mathematical_logic" title="wikilink">mathematical logic</a> and <a href="computer_science" title="wikilink">computer science</a> known as <a href="type_theory" title="wikilink">type theory</a>, a <strong>kind</strong> is the type of a <a href="type_constructor" title="wikilink">type constructor</a> or, less commonly, the type of a <a href="higher-order_type_operator" title="wikilink">higher-order type operator</a>. A kind system is essentially a <a href="simply_typed_lambda_calculus" title="wikilink">simply typed lambda calculus</a> "one level up", endowed with a primitive type, denoted 

<math display="inline" id="Kind_(type_theory):0">
 <semantics>
  <mo>*</mo>
  <annotation-xml encoding="MathML-Content">
   <times></times>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   *
  </annotation>
 </semantics>
</math>

 and called "type", which is the kind of any <a href="data_type" title="wikilink">data type</a> which does not need any <a href="parametric_polymorphism" title="wikilink">type parameters</a>.</p>

<p>A kind is sometimes confusingly described as the "type of a <a href="data_type" title="wikilink">(data) type</a>", but it is actually more of an <a class="uri" href="arity" title="wikilink">arity</a> specifier. Syntactically, it is natural to consider polymorphic types to be type constructors, thus non-polymorphic types to be <a class="uri" href="nullary" title="wikilink">nullary</a> type constructors. But all nullary constructors, thus all monomorphic types, have the same, simplest kind; namely 

<math display="inline" id="Kind_(type_theory):1">
 <semantics>
  <mo>*</mo>
  <annotation-xml encoding="MathML-Content">
   <times></times>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   *
  </annotation>
 </semantics>
</math>

.</p>

<p>Since higher-order type operators are uncommon in <a href="programming_language" title="wikilink">programming languages</a>, in most programming practice, kinds are used to distinguish between data types and the types of constructors which are used to implement <a href="parametric_polymorphism" title="wikilink">parametric polymorphism</a>. Kinds appear, either explicitly or implicitly, in languages whose type systems account for parametric polymorphism in a programatically accessible way, such as <a href="Haskell_(programming_language)" title="wikilink">Haskell</a> and <a href="Scala_(programming_language)" title="wikilink">Scala</a>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>
<h2 id="examples">Examples</h2>
<ul>
<li>

<math display="inline" id="Kind_(type_theory):2">
 <semantics>
  <mo>*</mo>
  <annotation-xml encoding="MathML-Content">
   <times></times>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   *
  </annotation>
 </semantics>
</math>

, pronounced "type", is the kind of all <a href="data_type" title="wikilink">data types</a> seen as <a class="uri" href="nullary" title="wikilink">nullary</a> type constructors, and also called proper types in this context. This normally includes function types in <a href="functional_programming_language" title="wikilink">functional programming languages</a>.</li>
<li>

<math display="inline" id="Kind_(type_theory):3">
 <semantics>
  <mrow>
   <mo>*</mo>
   <mo>→</mo>
   <mo>*</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <times></times>
    <ci>normal-→</ci>
    <times></times>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   *\rightarrow*
  </annotation>
 </semantics>
</math>

 is the kind of a <a class="uri" href="unary" title="wikilink">unary</a> <a href="type_constructor" title="wikilink">type constructor</a>, e.g. of a <a href="list_type" title="wikilink">list type</a> constructor.</li>
<li>

<math display="inline" id="Kind_(type_theory):4">
 <semantics>
  <mrow>
   <mo>*</mo>
   <mo>→</mo>
   <mo>*</mo>
   <mo>→</mo>
   <mo>*</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <times></times>
    <ci>normal-→</ci>
    <times></times>
    <ci>normal-→</ci>
    <times></times>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   *\rightarrow*\rightarrow*
  </annotation>
 </semantics>
</math>

 is the kind of a <a href="wiktionary:binary" title="wikilink">binary</a> type constructor (via <a class="uri" href="currying" title="wikilink">currying</a>), e.g. of a <a href="pair_type" title="wikilink">pair type</a> constructor, and also that of a <a href="function_type" title="wikilink">function type</a> constructor (not to be confused with the result of its application, which itself is a function type, thus of kind 

<math display="inline" id="Kind_(type_theory):5">
 <semantics>
  <mo>*</mo>
  <annotation-xml encoding="MathML-Content">
   <times></times>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   *
  </annotation>
 </semantics>
</math>

)</li>
<li>

<math display="inline" id="Kind_(type_theory):6">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>*</mo>
    <mo>→</mo>
    <mo>*</mo>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mo>*</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <times></times>
     <ci>normal-→</ci>
     <times></times>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <times></times>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (*\rightarrow*)\rightarrow*
  </annotation>
 </semantics>
</math>

 is the kind of a higher-order type operator from unary type constructors to proper types. See Pierce (2002), chapter 32 for an application.</li>
</ul>
<h2 id="kinds-in-haskell">Kinds in Haskell</h2>

<p>(<em>Note</em>: Haskell documentation uses the same arrow for both function types and kinds.)</p>

<p><a href="Haskell_(programming_language)" title="wikilink">Haskell</a>'s kind system<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> has just two rules:</p>
<ul>
<li>

<math display="inline" id="Kind_(type_theory):7">
 <semantics>
  <mo>*</mo>
  <annotation-xml encoding="MathML-Content">
   <times></times>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   *
  </annotation>
 </semantics>
</math>

, pronounced "type" is the kind of all <a href="data_type" title="wikilink">data types</a>.</li>
<li>

<math display="inline" id="Kind_(type_theory):8">
 <semantics>
  <mrow>
   <msub>
    <mi>k</mi>
    <mn>1</mn>
   </msub>
   <mo>→</mo>
   <msub>
    <mi>k</mi>
    <mn>2</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>k</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>k</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k_{1}\rightarrow k_{2}
  </annotation>
 </semantics>
</math>

 is the kind of a <a class="uri" href="unary" title="wikilink">unary</a> <a href="type_constructor" title="wikilink">type constructor</a>, which takes a type of kind 

<math display="inline" id="Kind_(type_theory):9">
 <semantics>
  <msub>
   <mi>k</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>k</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k_{1}
  </annotation>
 </semantics>
</math>

 and produces a type of kind 

<math display="inline" id="Kind_(type_theory):10">
 <semantics>
  <msub>
   <mi>k</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>k</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k_{2}
  </annotation>
 </semantics>
</math>

.</li>
</ul>

<p>An inhabited type (as proper types are called in Haskell) is a type which has values. For instance, ignoring <a href="type_class" title="wikilink">type classes</a> which complicate the picture, <code>4</code> is a value of type <code>Int</code>, while <code>[1, 2, 3]</code> is a value of type <code>[Int]</code> (list of Ints). Therefore, <code>Int</code> and <code>[Int]</code> have kind 

<math display="inline" id="Kind_(type_theory):11">
 <semantics>
  <mo>*</mo>
  <annotation-xml encoding="MathML-Content">
   <times></times>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   *
  </annotation>
 </semantics>
</math>

, but so does any function type, for instance <code>Int -&gt; Bool</code> or even <code>Int -&gt; Int -&gt; Bool</code>.</p>

<p>A type constructor takes one or more type arguments, and produces a data type when enough arguments are supplied, i.e. it supports <a href="partial_application" title="wikilink">partial application</a> thanks to currying.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a><a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> This is how Haskell achieves parametric types. For instance, the type <code>[]</code> (list) is a type constructor - it takes a single argument to specify the type of the elements of the list. Hence, <code>[Int]</code> (list of Ints), <code>[Float]</code> (list of Floats) and even <code>[[Int]]</code> (list of lists of Ints) are valid applications of the <code>[]</code> type constructor. Therefore, <code>[]</code> is a type of kind 

<math display="inline" id="Kind_(type_theory):12">
 <semantics>
  <mrow>
   <mo>*</mo>
   <mo>→</mo>
   <mo>*</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <times></times>
    <ci>normal-→</ci>
    <times></times>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   *\rightarrow*
  </annotation>
 </semantics>
</math>

. Because <code>Int</code> has kind 

<math display="inline" id="Kind_(type_theory):13">
 <semantics>
  <mo>*</mo>
  <annotation-xml encoding="MathML-Content">
   <times></times>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   *
  </annotation>
 </semantics>
</math>

, applying it to <code>[]</code> results in <code>[Int]</code>, of kind 

<math display="inline" id="Kind_(type_theory):14">
 <semantics>
  <mo>*</mo>
  <annotation-xml encoding="MathML-Content">
   <times></times>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   *
  </annotation>
 </semantics>
</math>

. The 2-<a class="uri" href="tuple" title="wikilink">tuple</a> constructor <code>(,)</code> has kind 

<math display="inline" id="Kind_(type_theory):15">
 <semantics>
  <mrow>
   <mo>*</mo>
   <mo>→</mo>
   <mo>*</mo>
   <mo>→</mo>
   <mo>*</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <times></times>
    <ci>normal-→</ci>
    <times></times>
    <ci>normal-→</ci>
    <times></times>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   *\rightarrow*\rightarrow*
  </annotation>
 </semantics>
</math>

, the 3-tuple constructor <code>(,,)</code> has kind 

<math display="inline" id="Kind_(type_theory):16">
 <semantics>
  <mrow>
   <mo>*</mo>
   <mo>→</mo>
   <mo>*</mo>
   <mo>→</mo>
   <mo>*</mo>
   <mo>→</mo>
   <mo>*</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <times></times>
    <ci>normal-→</ci>
    <times></times>
    <ci>normal-→</ci>
    <times></times>
    <ci>normal-→</ci>
    <times></times>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   *\rightarrow*\rightarrow*\rightarrow*
  </annotation>
 </semantics>
</math>

 and so on.</p>
<h3 id="kind-inference">Kind inference</h3>

<p>Standard Haskell does not allow <a href="polymorphic_kind" title="wikilink">polymorphic kinds</a>. This is in contrast to <a href="parametric_polymorphism" title="wikilink">parametric polymorphism</a> on types, which is supported in Haskell. For instance, in the following example:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Tree</span> z  <span class="fu">=</span> <span class="dt">Leaf</span> <span class="fu">|</span> <span class="dt">Fork</span> (<span class="dt">Tree</span> z) (<span class="dt">Tree</span> z)</code></pre></div>

<p>the kind of <code>z</code> could be anything, including 

<math display="inline" id="Kind_(type_theory):17">
 <semantics>
  <mo>*</mo>
  <annotation-xml encoding="MathML-Content">
   <times></times>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   *
  </annotation>
 </semantics>
</math>

, but also 

<math display="inline" id="Kind_(type_theory):18">
 <semantics>
  <mrow>
   <mo>*</mo>
   <mo>→</mo>
   <mo>*</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <times></times>
    <ci>normal-→</ci>
    <times></times>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   *\rightarrow*
  </annotation>
 </semantics>
</math>

 etc. Haskell by default will always infer kinds to be 

<math display="inline" id="Kind_(type_theory):19">
 <semantics>
  <mo>*</mo>
  <annotation-xml encoding="MathML-Content">
   <times></times>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   *
  </annotation>
 </semantics>
</math>

, unless the type explicitly indicates otherwise (see below). Therefore the type checker will reject the following use of <code>Tree</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">FunnyTree</span> <span class="fu">=</span> <span class="dt">Tree</span> []     <span class="co">-- invalid</span></code></pre></div>

<p>because the kind of <code>[]</code>, 

<math display="inline" id="Kind_(type_theory):20">
 <semantics>
  <mrow>
   <mo>*</mo>
   <mo>→</mo>
   <mo>*</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <times></times>
    <ci>normal-→</ci>
    <times></times>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   *\rightarrow*
  </annotation>
 </semantics>
</math>

 does not match the expected kind for <code>z</code>, which is always 

<math display="inline" id="Kind_(type_theory):21">
 <semantics>
  <mo>*</mo>
  <annotation-xml encoding="MathML-Content">
   <times></times>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   *
  </annotation>
 </semantics>
</math>

.</p>

<p>Higher-order type operators are allowed however. For instance:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">App</span> unt z <span class="fu">=</span> <span class="dt">Z</span> (unt z)</code></pre></div>

<p>has kind 

<math display="inline" id="Kind_(type_theory):22">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>*</mo>
    <mo>→</mo>
    <mo>*</mo>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mo>*</mo>
   <mo>→</mo>
   <mo>*</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <times></times>
     <ci>normal-→</ci>
     <times></times>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <times></times>
    <ci>normal-→</ci>
    <times></times>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (*\rightarrow*)\rightarrow*\rightarrow*
  </annotation>
 </semantics>
</math>

, i.e. <code>unt</code> is expected to be a unary data constructor, which gets applied to its argument, which must be a type, and returns another type.</p>

<p><a href="Glasgow_Haskell_Compiler" title="wikilink">GHC</a> has the extension <code>PolyKinds</code>, which, together with <code>KindSignatures</code>, allows polymorphic kinds. For example:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Tree</span> (<span class="ot">z ::</span> k) <span class="fu">=</span> <span class="dt">Leaf</span> <span class="fu">|</span> <span class="dt">Fork</span> (<span class="dt">Tree</span> z) (<span class="dt">Tree</span> z)
<span class="kw">type</span> <span class="dt">FunnyTree</span> <span class="fu">=</span> <span class="dt">Tree</span> []     <span class="co">-- OK</span></code></pre></div>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="System_F-omega" title="wikilink">System F-omega</a></li>
<li><a href="Pure_type_system" title="wikilink">Pure type system</a></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li>

<p>, chapter 29, "Type Operators and Kinding"</p></li>
</ul>

<p>"</p>

<p><a href="Category:Type_theory" title="wikilink">Category:Type theory</a> <a href="Category:Data_types" title="wikilink">Category:Data types</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="http://adriaanm.github.com/files/higher.pdf">Generics of a Higher Kind</a><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="http://www.haskell.org/onlinereport/decls.html#sect4.1.1">Kinds - The Haskell 98 Report</a><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
</ol>
</section>
</body>

