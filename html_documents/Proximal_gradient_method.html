<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="254">Proximal gradient method</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Proximal gradient method</h1>
<hr/>

<p><strong>Proximal gradient methods</strong> are a generalized form of projection used to solve non-differentiable <a href="convex_optimization" title="wikilink">convex optimization</a> problems. Many interesting problems can be formulated as convex optimization problems of form</p>

<p>

<math display="block" id="Proximal_gradient_method:0">
 <semantics>
  <mrow>
   <msub>
    <mo>minimize</mo>
    <mrow>
     <mi>x</mi>
     <mo>∈</mo>
     <msup>
      <mi>ℝ</mi>
      <mi>N</mi>
     </msup>
    </mrow>
   </msub>
   <mrow>
    <mrow>
     <msub>
      <mi>f</mi>
      <mn>1</mn>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>f</mi>
      <mn>2</mn>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mi mathvariant="normal">⋯</mi>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>f</mi>
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>f</mi>
      <mi>n</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>minimize</ci>
     <apply>
      <in></in>
      <ci>x</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>ℝ</ci>
       <ci>N</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>f</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>x</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>f</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>x</ci>
     </apply>
     <ci>normal-⋯</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>f</ci>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>x</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>f</ci>
       <ci>n</ci>
      </apply>
      <ci>x</ci>
     </apply>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{minimize}_{x\in\mathbb{R}^{N}}\qquad f_{1}(x)+f_{2}(x)+\cdots+f_%
{n-1}(x)+f_{n}(x)
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Proximal_gradient_method:1">
 <semantics>
  <mrow>
   <msub>
    <mi>f</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>f</mi>
    <mn>2</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>f</mi>
    <mi>n</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>f</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>f</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>f</ci>
     <ci>n</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{1},f_{2},...,f_{n}
  </annotation>
 </semantics>
</math>

 are <a href="convex_functions" title="wikilink">convex functions</a> defined from 

<math display="inline" id="Proximal_gradient_method:2">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mo>:</mo>
   <mrow>
    <msup>
     <mi>ℝ</mi>
     <mi>N</mi>
    </msup>
    <mo>→</mo>
    <mi>ℝ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>f</ci>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ℝ</ci>
      <ci>N</ci>
     </apply>
     <ci>ℝ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f:\mathbb{R}^{N}\rightarrow\mathbb{R}
  </annotation>
 </semantics>
</math>

 where some of the functions are non-differentiable, this rules out our conventional smooth optimization techniques like <a href="Gradient_descent" title="wikilink">Steepest descent method</a>, <a href="conjugate_gradient_method" title="wikilink">conjugate gradient method</a> etc. There is a specific class of <a class="uri" href="algorithms" title="wikilink">algorithms</a> which can solve above optimization problem. These methods proceed by splitting, in that the functions 

<math display="inline" id="Proximal_gradient_method:3">
 <semantics>
  <mrow>
   <msub>
    <mi>f</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>f</mi>
    <mi>n</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>f</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>f</ci>
     <ci>n</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{1},...,f_{n}
  </annotation>
 </semantics>
</math>

 are used individually so as to yield an easily <a class="uri" href="implementable" title="wikilink">implementable</a> algorithm. They are called <a class="uri" href="proximal" title="wikilink">proximal</a> because each non <a href="smooth_function" title="wikilink">smooth function</a> among 

<math display="inline" id="Proximal_gradient_method:4">
 <semantics>
  <mrow>
   <msub>
    <mi>f</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>f</mi>
    <mi>n</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>f</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>f</ci>
     <ci>n</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{1},...,f_{n}
  </annotation>
 </semantics>
</math>

 is involved via its proximity operator. Iterative Shrinkage thresholding algorithm, <a href="Landweber_iteration" title="wikilink">projected Landweber</a>, projected gradient, <a href="alternating_projection" title="wikilink">alternating projections</a>, <a href="Alternating_direction_method_of_multipliers#Alternating_direction_method_of_multipliers" title="wikilink">alternating-direction method of multipliers</a>, alternating split <a href="Bregman_method" title="wikilink">Bregman</a> are special instances of proximal algorithms. Details of proximal methods are discussed in Combettes and Pesquet.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> For the theory of proximal gradient methods from the perspective of and with applications to <a href="statistical_learning_theory" title="wikilink">statistical learning theory</a>, see <a href="proximal_gradient_methods_for_learning" title="wikilink">proximal gradient methods for learning</a>.</p>
<h2 id="notations-and-terminology">Notations and terminology</h2>

<p>Let 

<math display="inline" id="Proximal_gradient_method:5">
 <semantics>
  <msup>
   <mi>ℝ</mi>
   <mi>N</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>ℝ</ci>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{R}^{N}
  </annotation>
 </semantics>
</math>

, the 

<math display="inline" id="Proximal_gradient_method:6">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

-dimensional <a href="euclidean_space" title="wikilink">euclidean space</a>, be the domain of the function 

<math display="inline" id="Proximal_gradient_method:7">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mo>:</mo>
   <mrow>
    <msup>
     <mi>ℝ</mi>
     <mi>N</mi>
    </msup>
    <mo>→</mo>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mo>-</mo>
      <mi mathvariant="normal">∞</mi>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mo>+</mo>
      <mi mathvariant="normal">∞</mi>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>f</ci>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ℝ</ci>
      <ci>N</ci>
     </apply>
     <interval closure="closed">
      <apply>
       <minus></minus>
       <infinity></infinity>
      </apply>
      <apply>
       <plus></plus>
       <infinity></infinity>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f:\mathbb{R}^{N}\rightarrow[-\infty,+\infty]
  </annotation>
 </semantics>
</math>

. Suppose 

<math display="inline" id="Proximal_gradient_method:8">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

 is the non-empty convex subset of 

<math display="inline" id="Proximal_gradient_method:9">
 <semantics>
  <msup>
   <mi>ℝ</mi>
   <mi>N</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>ℝ</ci>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{R}^{N}
  </annotation>
 </semantics>
</math>

. Then, the indicator function of 

<math display="inline" id="Proximal_gradient_method:10">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

 is defined as</p>

<p>

<math display="block" id="Proximal_gradient_method:11">
 <semantics>
  <mrow>
   <msub>
    <mi>i</mi>
    <mi>C</mi>
   </msub>
   <mo>:</mo>
   <mrow>
    <mi>x</mi>
    <mo>↦</mo>
    <mrow>
     <mo>{</mo>
     <mtable displaystyle="true">
      <mtr>
       <mtd columnalign="left">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="left">
        <mrow>
         <mrow>
          <mtext>if</mtext>
          <mi>x</mi>
         </mrow>
         <mo>∈</mo>
         <mi>C</mi>
        </mrow>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="left">
        <mrow>
         <mo>+</mo>
         <mi mathvariant="normal">∞</mi>
        </mrow>
       </mtd>
       <mtd columnalign="left">
        <mrow>
         <mrow>
          <mtext>if</mtext>
          <mi>x</mi>
         </mrow>
         <mo>∉</mo>
         <mi>C</mi>
        </mrow>
       </mtd>
      </mtr>
     </mtable>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>i</ci>
     <ci>C</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">maps-to</csymbol>
     <ci>x</ci>
     <apply>
      <csymbol cd="latexml">cases</csymbol>
      <cn type="integer">0</cn>
      <apply>
       <in></in>
       <apply>
        <times></times>
        <mtext>if</mtext>
        <ci>x</ci>
       </apply>
       <ci>C</ci>
      </apply>
      <apply>
       <plus></plus>
       <infinity></infinity>
      </apply>
      <apply>
       <notin></notin>
       <apply>
        <times></times>
        <mtext>if</mtext>
        <ci>x</ci>
       </apply>
       <ci>C</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i_{C}:x\mapsto\begin{cases}0&\text{if }x\in C\\
+\infty&\text{if }x\notin C\end{cases}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Proximal_gradient_method:12">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

-norm is defined as ( 

<math display="inline" id="Proximal_gradient_method:13">
 <semantics>
  <mrow>
   <mo>∥</mo>
   <mo>⋅</mo>
   <msub>
    <mo>∥</mo>
    <mi>p</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="latexml">parallel-to</csymbol>
    <ci>normal-⋅</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">parallel-to</csymbol>
     <ci>p</ci>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \|\cdot\|_{p}
  </annotation>
 </semantics>
</math>

 )</p>

<p>

<math display="block" id="Proximal_gradient_method:14">
 <semantics>
  <mrow>
   <msub>
    <mrow>
     <mo>∥</mo>
     <mi>x</mi>
     <mo>∥</mo>
    </mrow>
    <mi>p</mi>
   </msub>
   <mo>=</mo>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msup>
       <mrow>
        <mo stretchy="false">|</mo>
        <msub>
         <mi>x</mi>
         <mn>1</mn>
        </msub>
        <mo stretchy="false">|</mo>
       </mrow>
       <mi>p</mi>
      </msup>
      <mo>+</mo>
      <msup>
       <mrow>
        <mo stretchy="false">|</mo>
        <msub>
         <mi>x</mi>
         <mn>2</mn>
        </msub>
        <mo stretchy="false">|</mo>
       </mrow>
       <mi>p</mi>
      </msup>
      <mo>+</mo>
      <mi mathvariant="normal">⋯</mi>
      <mo>+</mo>
      <msup>
       <mrow>
        <mo stretchy="false">|</mo>
        <msub>
         <mi>x</mi>
         <mi>N</mi>
        </msub>
        <mo stretchy="false">|</mo>
       </mrow>
       <mi>p</mi>
      </msup>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mn>1</mn>
     <mo>/</mo>
     <mi>p</mi>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="latexml">norm</csymbol>
      <ci>x</ci>
     </apply>
     <ci>p</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <abs></abs>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>p</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <abs></abs>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
       <ci>p</ci>
      </apply>
      <ci>normal-⋯</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <abs></abs>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>N</ci>
        </apply>
       </apply>
       <ci>p</ci>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <ci>p</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \|x\|_{p}=(|x_{1}|^{p}+|x_{2}|^{p}+\cdots+|x_{N}|^{p})^{1/p}
  </annotation>
 </semantics>
</math>

</p>

<p>The distance from 

<math display="inline" id="Proximal_gradient_method:15">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>∈</mo>
   <msup>
    <mi>ℝ</mi>
    <mi>N</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>x</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ℝ</ci>
     <ci>N</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\in\mathbb{R}^{N}
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Proximal_gradient_method:16">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

 is defined as</p>

<p>

<math display="block" id="Proximal_gradient_method:17">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>D</mi>
     <mi>C</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munder>
     <mi>min</mi>
     <mrow>
      <mi>y</mi>
      <mo>∈</mo>
      <mi>C</mi>
     </mrow>
    </munder>
    <mrow>
     <mo>∥</mo>
     <mrow>
      <mi>x</mi>
      <mo>-</mo>
      <mi>y</mi>
     </mrow>
     <mo>∥</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>D</ci>
      <ci>C</ci>
     </apply>
     <ci>x</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <min></min>
      <apply>
       <in></in>
       <ci>y</ci>
       <ci>C</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">norm</csymbol>
      <apply>
       <minus></minus>
       <ci>x</ci>
       <ci>y</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D_{C}(x)=\min_{y\in C}\|x-y\|
  </annotation>
 </semantics>
</math>

</p>

<p>If 

<math display="inline" id="Proximal_gradient_method:18">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

 is closed and convex, the projection of 

<math display="inline" id="Proximal_gradient_method:19">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>∈</mo>
   <msup>
    <mi>ℝ</mi>
    <mi>N</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>x</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ℝ</ci>
     <ci>N</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\in\mathbb{R}^{N}
  </annotation>
 </semantics>
</math>

 onto 

<math display="inline" id="Proximal_gradient_method:20">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

 is the unique point 

<math display="inline" id="Proximal_gradient_method:21">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>P</mi>
     <mi>C</mi>
    </msub>
    <mi>x</mi>
   </mrow>
   <mo>∈</mo>
   <mi>C</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>P</ci>
      <ci>C</ci>
     </apply>
     <ci>x</ci>
    </apply>
    <ci>C</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{C}x\in C
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Proximal_gradient_method:22">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>D</mi>
     <mi>C</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msub>
    <mrow>
     <mo>∥</mo>
     <mrow>
      <mi>x</mi>
      <mo>-</mo>
      <mrow>
       <msub>
        <mi>P</mi>
        <mi>C</mi>
       </msub>
       <mi>x</mi>
      </mrow>
     </mrow>
     <mo>∥</mo>
    </mrow>
    <mn>2</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>D</ci>
      <ci>C</ci>
     </apply>
     <ci>x</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="latexml">norm</csymbol>
      <apply>
       <minus></minus>
       <ci>x</ci>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>P</ci>
         <ci>C</ci>
        </apply>
        <ci>x</ci>
       </apply>
      </apply>
     </apply>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D_{C}(x)=\|x-P_{C}x\|_{2}
  </annotation>
 </semantics>
</math>

.</p>

<p>The <a class="uri" href="subdifferential" title="wikilink">subdifferential</a> of 

<math display="inline" id="Proximal_gradient_method:23">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 is given by</p>

<p>

<math display="block" id="Proximal_gradient_method:24">
 <semantics>
  <mrow>
   <mo>∂</mo>
   <mi>f</mi>
   <mo>:</mo>
   <msup>
    <mi>ℝ</mi>
    <mi>N</mi>
   </msup>
   <mo>→</mo>
   <msup>
    <mn>2</mn>
    <msup>
     <mi>ℝ</mi>
     <mi>N</mi>
    </msup>
   </msup>
   <mo>:</mo>
   <mi>x</mi>
   <mo>↦</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mi>u</mi>
    <mo>∈</mo>
    <msup>
     <mi>ℝ</mi>
     <mi>N</mi>
    </msup>
    <mo>∣</mo>
    <mo>∀</mo>
    <mi>y</mi>
    <mo>∈</mo>
    <msup>
     <mi>ℝ</mi>
     <mi>N</mi>
    </msup>
    <mo>,</mo>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>y</mi>
      <mo>-</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi mathvariant="normal">T</mi>
    </msup>
    <mi>u</mi>
    <mo>+</mo>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>≤</mo>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>.</mo>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <partialdiff></partialdiff>
    <csymbol cd="unknown">f</csymbol>
    <ci>normal-:</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ℝ</ci>
     <ci>N</ci>
    </apply>
    <ci>normal-→</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ℝ</ci>
      <ci>N</ci>
     </apply>
    </apply>
    <ci>normal-:</ci>
    <csymbol cd="unknown">x</csymbol>
    <csymbol cd="latexml">maps-to</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-{</ci>
     <csymbol cd="unknown">u</csymbol>
     <in></in>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ℝ</ci>
      <ci>N</ci>
     </apply>
     <ci>normal-∣</ci>
     <csymbol cd="latexml">for-all</csymbol>
     <csymbol cd="unknown">y</csymbol>
     <in></in>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ℝ</ci>
      <ci>N</ci>
     </apply>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">y</csymbol>
       <minus></minus>
       <csymbol cd="unknown">x</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-T</ci>
     </apply>
     <csymbol cd="unknown">u</csymbol>
     <plus></plus>
     <csymbol cd="unknown">f</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <leq></leq>
     <csymbol cd="unknown">f</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">y</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-.</ci>
    <ci>normal-}</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \partial f:\mathbb{R}^{N}\rightarrow 2^{\mathbb{R}^{N}}:x\mapsto\{u\in\mathbb{%
R}^{N}\mid\forall y\in\mathbb{R}^{N},(y-x)^{\mathrm{T}}u+f(x)\leq f(y)).\}
  </annotation>
 </semantics>
</math>

</p>
<h2 id="projection-onto-convex-sets-pocs">Projection onto convex sets (POCS)</h2>

<p>One of the widely used convex optimization algorithms is POCS (<a href="Projections_onto_convex_sets" title="wikilink">Projection Onto Convex Sets</a>). This algorithm is employed to recover/synthesize a signal satisfying simultaneously several convex constraints. Let 

<math display="inline" id="Proximal_gradient_method:25">
 <semantics>
  <msub>
   <mi>f</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>f</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{i}
  </annotation>
 </semantics>
</math>

 be the indicator function of non-empty closed convex set 

<math display="inline" id="Proximal_gradient_method:26">
 <semantics>
  <msub>
   <mi>C</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>C</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{i}
  </annotation>
 </semantics>
</math>

 modeling a constraint. This reduces to convex feasibility problem, which require us to find a solution such that it lies in the intersection of all convex sets 

<math display="inline" id="Proximal_gradient_method:27">
 <semantics>
  <msub>
   <mi>C</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>C</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{i}
  </annotation>
 </semantics>
</math>

. In POCS method each set 

<math display="inline" id="Proximal_gradient_method:28">
 <semantics>
  <msub>
   <mi>C</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>C</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{i}
  </annotation>
 </semantics>
</math>

 is incorporated by its <a href="projection_operator" title="wikilink">projection operator</a> 

<math display="inline" id="Proximal_gradient_method:29">
 <semantics>
  <msub>
   <mi>P</mi>
   <msub>
    <mi>C</mi>
    <mi>i</mi>
   </msub>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>P</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{C_{i}}
  </annotation>
 </semantics>
</math>

. So in each <a class="uri" href="iteration" title="wikilink">iteration</a> 

<math display="inline" id="Proximal_gradient_method:30">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 is updated as</p>

<p>

<math display="block" id="Proximal_gradient_method:31">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mrow>
     <mi>k</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>P</mi>
     <msub>
      <mi>C</mi>
      <mn>1</mn>
     </msub>
    </msub>
    <msub>
     <mi>P</mi>
     <msub>
      <mi>C</mi>
      <mn>2</mn>
     </msub>
    </msub>
    <mi mathvariant="normal">⋯</mi>
    <msub>
     <mi>P</mi>
     <msub>
      <mi>C</mi>
      <mi>n</mi>
     </msub>
    </msub>
    <msub>
     <mi>x</mi>
     <mi>k</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <apply>
      <plus></plus>
      <ci>k</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>P</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>C</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>P</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>C</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <ci>normal-⋯</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>P</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>C</ci>
       <ci>n</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>k</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{k+1}=P_{C_{1}}P_{C_{2}}\cdots P_{C_{n}}x_{k}
  </annotation>
 </semantics>
</math>

</p>

<p>However beyond such problems <a href="projection_operator" title="wikilink">projection operators</a> are not appropriate and more general operators are required to tackle them. Among the various generalizations of the notion of a convex projection operator that exist, proximity operators are best suited for other purposes.</p>
<h2 id="definition">Definition</h2>

<p>Proximity operators of function 

<math display="inline" id="Proximal_gradient_method:32">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 at 

<math display="inline" id="Proximal_gradient_method:33">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 is defined as</p>

<p>For every 

<math display="inline" id="Proximal_gradient_method:34">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>∈</mo>
   <msup>
    <mi>ℝ</mi>
    <mi>N</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>x</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ℝ</ci>
     <ci>N</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\in\mathbb{R}^{N}
  </annotation>
 </semantics>
</math>

, the minimization problem</p>

<p>

<math display="block" id="Proximal_gradient_method:35">
 <semantics>
  <mrow>
   <msub>
    <mtext>minimize</mtext>
    <mrow>
     <mi>y</mi>
     <mo>∈</mo>
     <mi>C</mi>
    </mrow>
   </msub>
   <mrow>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <mn>2</mn>
     </mfrac>
     <msubsup>
      <mrow>
       <mo>∥</mo>
       <mrow>
        <mi>x</mi>
        <mo>-</mo>
        <mi>y</mi>
       </mrow>
       <mo>∥</mo>
      </mrow>
      <mn>2</mn>
      <mn>2</mn>
     </msubsup>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <mtext>minimize</mtext>
     <apply>
      <in></in>
      <ci>y</ci>
      <ci>C</ci>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>y</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <csymbol cd="latexml">norm</csymbol>
         <apply>
          <minus></minus>
          <ci>x</ci>
          <ci>y</ci>
         </apply>
        </apply>
        <cn type="integer">2</cn>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{minimize}_{y\in C}\qquad f(y)+\frac{1}{2}\left\|x-y\right\|_{2}^{2}
  </annotation>
 </semantics>
</math>

 admits a unique solution which is denoted by 

<math display="inline" id="Proximal_gradient_method:36">
 <semantics>
  <mrow>
   <msub>
    <mo>prox</mo>
    <mi>f</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>prox</ci>
     <ci>f</ci>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{prox}_{f}(x)
  </annotation>
 </semantics>
</math>

.</p>

<p>

<math display="block" id="Proximal_gradient_method:37">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mo>prox</mo>
     <mi>f</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>:</mo>
   <mrow>
    <msup>
     <mi>ℝ</mi>
     <mi>N</mi>
    </msup>
    <mo>→</mo>
    <msup>
     <mi>ℝ</mi>
     <mi>N</mi>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>prox</ci>
      <ci>f</ci>
     </apply>
     <ci>x</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ℝ</ci>
      <ci>N</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ℝ</ci>
      <ci>N</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{prox}_{f}(x):\mathbb{R}^{N}\rightarrow\mathbb{R}^{N}
  </annotation>
 </semantics>
</math>

</p>

<p>The proximity operator of 

<math display="inline" id="Proximal_gradient_method:38">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 is characterized by inclusion</p>

<p>

<math display="block" id="Proximal_gradient_method:39">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mo>=</mo>
   <msub>
    <mo>prox</mo>
    <mi>f</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>⇔</mo>
   <mi>x</mi>
   <mo>-</mo>
   <mi>p</mi>
   <mo>∈</mo>
   <mo>∂</mo>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>p</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>∀</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>p</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∈</mo>
    <msup>
     <mi>ℝ</mi>
     <mi>N</mi>
    </msup>
    <mo>×</mo>
    <msup>
     <mi>ℝ</mi>
     <mi>N</mi>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>prox</ci>
     <ci>f</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-⇔</ci>
    <csymbol cd="unknown">x</csymbol>
    <minus></minus>
    <csymbol cd="unknown">p</csymbol>
    <in></in>
    <partialdiff></partialdiff>
    <csymbol cd="unknown">f</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">p</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>italic-</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="latexml">for-all</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-,</ci>
      <csymbol cd="unknown">p</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <in></in>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ℝ</ci>
      <ci>N</ci>
     </apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ℝ</ci>
      <ci>N</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p=\operatorname{prox}_{f}(x)\Leftrightarrow x-p\in\partial f(p)\qquad(\forall(%
x,p)\in\mathbb{R}^{N}\times\mathbb{R}^{N})
  </annotation>
 </semantics>
</math>

</p>

<p>If 

<math display="inline" id="Proximal_gradient_method:40">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 is differentiable then above equation reduces to</p>

<p>

<math display="block" id="Proximal_gradient_method:41">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mo>=</mo>
   <msub>
    <mo>prox</mo>
    <mi>f</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>⇔</mo>
   <mi>x</mi>
   <mo>-</mo>
   <mi>p</mi>
   <mo>∈</mo>
   <mo>∇</mo>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>p</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>∀</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>p</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∈</mo>
    <msup>
     <mi>ℝ</mi>
     <mi>N</mi>
    </msup>
    <mo>×</mo>
    <msup>
     <mi>ℝ</mi>
     <mi>N</mi>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>prox</ci>
     <ci>f</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-⇔</ci>
    <csymbol cd="unknown">x</csymbol>
    <minus></minus>
    <csymbol cd="unknown">p</csymbol>
    <in></in>
    <ci>normal-∇</ci>
    <csymbol cd="unknown">f</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">p</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci></ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="latexml">for-all</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-,</ci>
      <csymbol cd="unknown">p</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <in></in>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ℝ</ci>
      <ci>N</ci>
     </apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ℝ</ci>
      <ci>N</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p=\operatorname{prox}_{f}(x)\Leftrightarrow x-p\in\nabla f(p)\quad(\forall(x,p%
)\in\mathbb{R}^{N}\times\mathbb{R}^{N})
  </annotation>
 </semantics>
</math>

</p>
<h2 id="examples">Examples</h2>

<p>Special instances of Proximal Gradient Methods are</p>
<ul>
<li><a href="Landweber_iteration" title="wikilink">Projected Landweber</a></li>
<li><a href="Alternating_projection" title="wikilink">Alternating projection</a></li>
<li><a href="Alternating_direction_method_of_multipliers#Alternating_direction_method_of_multipliers" title="wikilink">Alternating-direction method of multipliers</a></li>
<li>Fast Iterative Shrinkage Thresholding Algorithm (FISTA)<ref></ref></li>
</ul>

<p></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Alternating_projection" title="wikilink">Alternating projection</a></li>
<li><a href="Convex_optimization" title="wikilink">Convex optimization</a></li>
<li><a href="Frank–Wolfe_algorithm" title="wikilink">Frank–Wolfe algorithm</a></li>
<li><a href="Proximal_gradient_methods_for_learning" title="wikilink">Proximal gradient methods for learning</a></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li></li>
<li>{{ cite book</li>
</ul>

<p><code>| last1 = Combettes</code><br/>
<code>| first1 = Patrick L.</code><br/>
<code>| last2 = Pesquet</code><br/>
<code>| first2 = Jean-Christophe</code><br/>
<code>| title = Springer's Fixed-Point Algorithms for Inverse Problems in Science and Engineering</code><br/>
<code>| volume = 49</code><br/>
<code>| year = 2011</code><br/>
<code>| pages = 185–212</code></p>

<p>}}</p>
<h2 id="notes">Notes</h2>
<references>
</references>
<h2 id="external-links">External links</h2>
<ul>
<li>Stephen Boyd and Lieven Vandenberghe Book, <a href="http://www.stanford.edu/~boyd/cvxbook/"><em>Convex optimization</em></a></li>
<li><a href="http://www.stanford.edu/class/ee364a/">EE364a: Convex Optimization I</a> and <a href="http://www.stanford.edu/class/ee364b/">EE364b: Convex Optimization II</a>, Stanford course homepages</li>
<li><a href="http://www.eecs.berkeley.edu/~elghaoui/Teaching/EE227A/lecture18.pdf">EE227A: Lieven Vandenberghe Notes</a> Lecture 18</li>
</ul>

<p>"</p>

<p><a href="Category:Gradient_methods" title="wikilink">Category:Gradient methods</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
</ol>
</section>
</body>
</html>
