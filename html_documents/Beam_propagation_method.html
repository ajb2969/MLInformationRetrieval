<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1945">Beam propagation method</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Beam propagation method</h1>
<hr>The '''beam propagation method''' ('''BPM''') is an approximation technique for simul
<p>ating the propagation of <a class="uri" href="light" title="wikilink">light</a> in <a href="slowly_varying_envelope_approximation" title="wikilink">slowly varying</a> <a href="optical_waveguide" title="wikilink">optical waveguides</a>. It is essentially the same as the so-called <a href="parabolic_equation" title="wikilink">parabolic equation</a> (PE) method in underwater <a class="uri" href="acoustics" title="wikilink">acoustics</a>. Both BPM and the PE were first introduced in the 1970s. When a wave propagates along a waveguide for a large distance (larger compared with the wavelength), rigorous numerical simulation is difficult. The BPM relies on approximate differential equations which are also called the one-way models. These one-way models involve only a first order <a class="uri" href="derivative" title="wikilink">derivative</a> in the variable z (for the waveguide axis) and they can be solved as "initial" value problem. The "initial" value problem does not involve time, rather it is for the spatial variable z.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>

<p>The original BPM and PE were derived from the slowly varying envelope approximation and they are the so-called paraxial one-way models. Since then, a number of improved one-way models are introduced. They come from a one-way model involving a square root operator. They are obtained by applying rational approximations to the square root operator. After a one-way model is obtained, one still has to solve it by discretizing the variable z. However, it is possible to merge the two steps (rational approximation to the square root operator and discretization of z) into one step. Namely, one can find rational approximations to the so-called one-way propagator (the exponential of the square root operator) directly. The rational approximations are not trivial. Standard diagonal Padé approximants have trouble with the so-called evanescent modes. These evanescent modes should decay rapidly in z, but the diagonal Padé approximants will incorrectly propagate them as propagating modes along the waveguide. Modified rational approximants that can suppress the evanescent modes are now available. The accuracy of the BPM can be further improved, if you use the energy-conserving one-way model or the single-scatter one-way model.</p>
<h2 id="principles">Principles</h2>

<p>BPM is generally formulated as a solution to <a href="Helmholtz_equation" title="wikilink">Helmholtz equation</a> in a time-harmonic case, <a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> <a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>

<p>

<math display="block" id="Beam_propagation_method:0">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msup>
       <mo>∇</mo>
       <mn>2</mn>
      </msup>
      <mo>+</mo>
      <mrow>
       <msubsup>
        <mi>k</mi>
        <mn>0</mn>
        <mn>2</mn>
       </msubsup>
       <msup>
        <mi>n</mi>
        <mn>2</mn>
       </msup>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>ψ</mi>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>normal-∇</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>k</ci>
         <cn type="integer">0</cn>
        </apply>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>n</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
     <ci>ψ</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\nabla^{2}+k_{0}^{2}n^{2})\psi=0
  </annotation>
 </semantics>
</math>

 with the field written as,</p>

<p>

<math display="block" id="Beam_propagation_method:1">
 <semantics>
  <mrow>
   <mrow>
    <mi>E</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo>,</mo>
     <mi>z</mi>
     <mo>,</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>ψ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mi>exp</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mo>-</mo>
       <mrow>
        <mi>j</mi>
        <mi>ω</mi>
        <mi>t</mi>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>E</ci>
     <vector>
      <ci>x</ci>
      <ci>y</ci>
      <ci>z</ci>
      <ci>t</ci>
     </vector>
    </apply>
    <apply>
     <times></times>
     <ci>ψ</ci>
     <interval closure="open">
      <ci>x</ci>
      <ci>y</ci>
     </interval>
     <apply>
      <exp></exp>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <ci>j</ci>
        <ci>ω</ci>
        <ci>t</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E(x,y,z,t)=\psi(x,y)\exp(-j\omega t)
  </annotation>
 </semantics>
</math>

.</p>

<p>Now the spatial dependence of this field is written according to any one <a href="Transverse_mode" title="wikilink">TE or TM</a> polarizations</p>

<p>

<math display="block" id="Beam_propagation_method:2">
 <semantics>
  <mrow>
   <mrow>
    <mi>ψ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>A</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mi>exp</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mo>+</mo>
       <mrow>
        <mi>j</mi>
        <msub>
         <mi>k</mi>
         <mi>o</mi>
        </msub>
        <mi>ν</mi>
        <mi>y</mi>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>ψ</ci>
     <interval closure="open">
      <ci>x</ci>
      <ci>y</ci>
     </interval>
    </apply>
    <apply>
     <times></times>
     <ci>A</ci>
     <interval closure="open">
      <ci>x</ci>
      <ci>y</ci>
     </interval>
     <apply>
      <exp></exp>
      <apply>
       <plus></plus>
       <apply>
        <times></times>
        <ci>j</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>k</ci>
         <ci>o</ci>
        </apply>
        <ci>ν</ci>
        <ci>y</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \psi(x,y)=A(x,y)\exp(+jk_{o}\nu y)
  </annotation>
 </semantics>
</math>

, with the envelope</p>

<p>

<math display="block" id="Beam_propagation_method:3">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>A</ci>
    <interval closure="open">
     <ci>x</ci>
     <ci>y</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A(x,y)
  </annotation>
 </semantics>
</math>

 following a slowly varying approximation,</p>

<p>

<math display="block" id="Beam_propagation_method:4">
 <semantics>
  <mrow>
   <mfrac>
    <mrow>
     <msup>
      <mo>∂</mo>
      <mn>2</mn>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>A</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo>,</mo>
        <mi>y</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mrow>
     <mo>∂</mo>
     <msup>
      <mi>y</mi>
      <mn>2</mn>
     </msup>
    </mrow>
   </mfrac>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <divide></divide>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <partialdiff></partialdiff>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <times></times>
       <ci>A</ci>
       <interval closure="open">
        <ci>x</ci>
        <ci>y</ci>
       </interval>
      </apply>
     </apply>
     <apply>
      <partialdiff></partialdiff>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>y</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{\partial^{2}(A(x,y))}{\partial y^{2}}=0
  </annotation>
 </semantics>
</math>

</p>

<p>Now the solution when replaced into the Helmholtz equation follows,</p>

<p>

<math display="block" id="Beam_propagation_method:5">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>[</mo>
     <mrow>
      <mfrac>
       <msup>
        <mo>∂</mo>
        <mn>2</mn>
       </msup>
       <mrow>
        <mo>∂</mo>
        <msup>
         <mi>x</mi>
         <mn>2</mn>
        </msup>
       </mrow>
      </mfrac>
      <mo>+</mo>
      <mrow>
       <msubsup>
        <mi>k</mi>
        <mn>0</mn>
        <mn>2</mn>
       </msubsup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <msup>
          <mi>n</mi>
          <mn>2</mn>
         </msup>
         <mo>-</mo>
         <msup>
          <mi>ν</mi>
          <mn>2</mn>
         </msup>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo>]</mo>
    </mrow>
    <mi>A</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>±</mo>
    <mrow>
     <mn>2</mn>
     <mi>j</mi>
     <msub>
      <mi>k</mi>
      <mn>0</mn>
     </msub>
     <mi>ν</mi>
     <mfrac>
      <mrow>
       <mrow>
        <mo>∂</mo>
        <msub>
         <mi>A</mi>
         <mi>k</mi>
        </msub>
       </mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo>,</mo>
        <mi>y</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mrow>
       <mo>∂</mo>
       <mi>y</mi>
      </mrow>
     </mfrac>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <apply>
       <plus></plus>
       <apply>
        <divide></divide>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <partialdiff></partialdiff>
         <cn type="integer">2</cn>
        </apply>
        <apply>
         <partialdiff></partialdiff>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>x</ci>
          <cn type="integer">2</cn>
         </apply>
        </apply>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>k</ci>
          <cn type="integer">0</cn>
         </apply>
         <cn type="integer">2</cn>
        </apply>
        <apply>
         <minus></minus>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>n</ci>
          <cn type="integer">2</cn>
         </apply>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>ν</ci>
          <cn type="integer">2</cn>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
     <ci>A</ci>
     <interval closure="open">
      <ci>x</ci>
      <ci>y</ci>
     </interval>
    </apply>
    <apply>
     <csymbol cd="latexml">plus-or-minus</csymbol>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <ci>j</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>k</ci>
       <cn type="integer">0</cn>
      </apply>
      <ci>ν</ci>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <apply>
         <partialdiff></partialdiff>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>A</ci>
          <ci>k</ci>
         </apply>
        </apply>
        <interval closure="open">
         <ci>x</ci>
         <ci>y</ci>
        </interval>
       </apply>
       <apply>
        <partialdiff></partialdiff>
        <ci>y</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left[\frac{\partial^{2}}{\partial x^{2}}+k_{0}^{2}(n^{2}-\nu^{2})\right]A(x,y%
)=\pm 2jk_{0}\nu\frac{\partial A_{k}(x,y)}{\partial y}
  </annotation>
 </semantics>
</math>

</p>

<p>With the aim to calculate the field at all points of space for all times, we only need to compute the function 

<math display="inline" id="Beam_propagation_method:6">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>A</ci>
    <interval closure="open">
     <ci>x</ci>
     <ci>y</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A(x,y)
  </annotation>
 </semantics>
</math>

 for all space, and then we are able to reconstruct 

<math display="inline" id="Beam_propagation_method:7">
 <semantics>
  <mrow>
   <mi>ψ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>ψ</ci>
    <interval closure="open">
     <ci>x</ci>
     <ci>y</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \psi(x,y)
  </annotation>
 </semantics>
</math>

. Since the solution is for the time-harmonic Helmholtz equation, we only need to calculate it over one time period. We can visualize the fields along the propagation direction, or the cross section waveguide modes.</p>
<h2 id="numerical-methods">Numerical methods</h2>

<p>There are both <em>spatial domain</em> methods, and <em>frequency (spectral) domain</em> methods are available for the numerical solution of the discretized master equation. Upon discretization into a grid, (using various <a href="central_difference" title="wikilink">centralized difference</a>, <a href="Crank–Nicolson_method" title="wikilink">Crank–Nicolson method</a>, FFT-BPM etc.) and field values rearranged in a causal fashion, the field evolution is computed through iteration, along the propagation direction. The spatial domain method computes the field at the next step (in the propagation direction) by solving a linear equation, whereas the spectral domain methods use the powerful forward/inverse <a href="Fast_Fourier_Transform" title="wikilink">DFT</a> algorithms. Spectral domain methods have the advantage of stability even in the presence of nonlinearity (from refractive index or medium properties), while spatial domain methods can possibly become numerically unstable.</p>
<h2 id="applications">Applications</h2>

<p>BPM is a quick and easy method of solving for fields in integrated optical devices. It is typically used only in solving for intensity and modes within shaped (bent, tapered, terminated) waveguide structures, as opposed to scattering problems. These structures typically consist of <a class="uri" href="isotropic" title="wikilink">isotropic</a> optical materials, but the BPM has also been extended to be applicable to simulate the propagation of light in general <a class="uri" href="anisotropic" title="wikilink">anisotropic</a> materials such as <a href="liquid_crystals" title="wikilink">liquid crystals</a>. This allows one to <a href="http://www.elis.ugent.be/ELISgroups/lcd/research/bpm.php">analyze</a> e.g. the polarization rotation of light in anisotropic materials, the tunability of a directional coupler based on liquid crystals or the light diffraction in LCD pixels.</p>
<h2 id="limitations-of-bpm">Limitations of BPM</h2>

<p>The Beam Propagation Method relies on the <a href="slowly_varying_envelope_approximation" title="wikilink">slowly varying envelope approximation</a>, and is inaccurate for the modelling of discretely or fastly varying structures. It is also inaccurate for the modelling of structures in which light propages in large range of angles and for devices with high refractive-index contrast, commonly found for instance in <a href="silicon_photonics" title="wikilink">silicon photonics</a>.</p>

<p>The BPM method can be used to model bi-directional propagation, but the reflections need to be implemented iteratively which can lead to convergence issues.</p>

<p>More rigorous alternatives include <a href="Eigenmode_Expansion" title="wikilink">Eigenmode Expansion</a> and <a class="uri" href="FDTD" title="wikilink">FDTD</a>.</p>
<h2 id="implementations">Implementations</h2>

<p>There are several simulation tools that implement BPM algorithms. Popular commercial tools have been developed by <a href="http://optiwave.com/category/products/component-design/optibpm/">Optiwave Systems Inc.</a> and RSoft Design.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="http://emlab.utep.edu/ee5390cem.htm">See and listen to Lecture 16 on BPM</a></li>
<li><a href="Computational_electromagnetics" title="wikilink">Computational electromagnetics</a></li>
<li><a href="Finite-difference_time-domain_method" title="wikilink">Finite-difference time-domain method</a></li>
<li><a href="Eigenmode_expansion" title="wikilink">Eigenmode expansion</a></li>
<li><a href="Finite_element_method" title="wikilink">Finite element method</a></li>
<li><a href="Maxwell's_equations" title="wikilink">Maxwell's equations</a></li>
<li><a href="Method_of_lines" title="wikilink">Method of Lines</a></li>
<li><a class="uri" href="Light" title="wikilink">Light</a></li>
<li><a class="uri" href="Photon" title="wikilink">Photon</a></li>
<li><a href="http://emlab.utep.edu/pdfs/Poster_BPM.pdf">EM Lab Poster on the Beam Propagation Method</a></li>
</ul>
<h2 id="references">References</h2>
<references>
</references>

<p>"</p>

<p><a href="Category:Computational_science" title="wikilink">Category:Computational science</a> <a class="uri" href="Category:Electrodynamics" title="wikilink">Category:Electrodynamics</a> <a href="Category:Physical_optics" title="wikilink">Category:Physical optics</a> <a class="uri" href="Category:Electromagnetism" title="wikilink">Category:Electromagnetism</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2">Okamoto K. 2000 Fundamentals of Optical Waveguides (San Diego, CA: Academic)<a href="#fnref2">↩</a></li>
<li id="fn3">EE290F: BPM course slides, Devang Parekh, University of Berkeley, CA<a href="#fnref3">↩</a></li>
</ol>
</section>
</hr></body>
</html>
