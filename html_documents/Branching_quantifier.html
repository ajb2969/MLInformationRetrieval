<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="513">Branching quantifier</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Branching quantifier</h1>
<hr/>

<p>In <a class="uri" href="logic" title="wikilink">logic</a> a <strong>branching quantifier</strong>,<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> also called a <strong>Henkin quantifier</strong>, <strong>finite partially ordered quantifier</strong> or even <strong>nonlinear quantifier</strong>, is a partial ordering<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>

<p>

<math display="block" id="Branching_quantifier:0">
 <semantics>
  <mrow>
   <mo stretchy="false">⟨</mo>
   <mrow>
    <mi>Q</mi>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
    <mi mathvariant="normal">…</mi>
    <mi>Q</mi>
    <msub>
     <mi>x</mi>
     <mi>n</mi>
    </msub>
   </mrow>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">delimited-⟨⟩</csymbol>
    <apply>
     <times></times>
     <ci>Q</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <ci>Q</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle Qx_{1}\dots Qx_{n}\rangle
  </annotation>
 </semantics>
</math>

</p>

<p>of <a href="Quantifier_(logic)" title="wikilink">quantifiers</a> for Q∈{∀,∃}. It is a special case of <a href="generalized_quantifier" title="wikilink">generalized quantifier</a>. In <a href="classical_logic" title="wikilink">classical logic</a>, quantifier prefixes are linearly ordered such that the value of a variable <em>y<sub>m</sub></em> bound by a quantifier <em>Q<sub>m</sub></em> depends on the value of the variables</p>
<dl>
<dd>y<sub>1</sub>,...,y<sub>m-1</sub>
</dd>
</dl>

<p>bound by quantifiers</p>
<dl>
<dd>Qy<sub>1</sub>,...,Qy<sub>m-1</sub>
</dd>
</dl>

<p>preceding <em>Q<sub>m</sub></em>. In a logic with (finite) partially ordered quantification this is not in general the case.</p>

<p>Branching quantification first appeared in a 1959 conference paper of <a href="Leon_Henkin" title="wikilink">Leon Henkin</a>.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> Systems of partially ordered quantification are intermediate in strength between first-order logic and second-order logic. They are being used as a basis for <a href="Jaakko_Hintikka" title="wikilink">Hintikka's</a> and Gabriel Sandu's <a href="independence-friendly_logic" title="wikilink">independence-friendly logic</a>.</p>
<h2 id="definition-and-properties">Definition and properties</h2>

<p>The simplest Henkin quantifier 

<math display="inline" id="Branching_quantifier:1">
 <semantics>
  <msub>
   <mi>Q</mi>
   <mi>H</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>Q</ci>
    <ci>H</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q_{H}
  </annotation>
 </semantics>
</math>

 is</p>

<p>

<math display="block" id="Branching_quantifier:2">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>Q</mi>
       <mi>H</mi>
      </msub>
      <msub>
       <mi>x</mi>
       <mn>1</mn>
      </msub>
     </mrow>
     <mo>,</mo>
     <msub>
      <mi>x</mi>
      <mn>2</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>y</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>y</mi>
      <mn>2</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>ϕ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>x</mi>
      <mn>2</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>y</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>y</mi>
      <mn>2</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≡</mo>
   <mrow>
    <mrow>
     <mo>(</mo>
     <mtable displaystyle="true">
      <mtr>
       <mtd columnalign="center">
        <mrow>
         <mo>∀</mo>
         <mrow>
          <msub>
           <mi>x</mi>
           <mn>1</mn>
          </msub>
          <mrow>
           <mo>∃</mo>
           <msub>
            <mi>y</mi>
            <mn>1</mn>
           </msub>
          </mrow>
         </mrow>
        </mrow>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mrow>
         <mo>∀</mo>
         <mrow>
          <msub>
           <mi>x</mi>
           <mn>2</mn>
          </msub>
          <mrow>
           <mo>∃</mo>
           <msub>
            <mi>y</mi>
            <mn>2</mn>
           </msub>
          </mrow>
         </mrow>
        </mrow>
       </mtd>
      </mtr>
     </mtable>
     <mo>)</mo>
    </mrow>
    <mi>ϕ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>x</mi>
      <mn>2</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>y</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>y</mi>
      <mn>2</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <times></times>
     <vector>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Q</ci>
        <ci>H</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">2</cn>
      </apply>
     </vector>
     <ci>ϕ</ci>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">2</cn>
      </apply>
     </vector>
    </apply>
    <apply>
     <times></times>
     <matrix>
      <matrixrow>
       <apply>
        <csymbol cd="latexml">for-all</csymbol>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <cn type="integer">1</cn>
         </apply>
         <apply>
          <exists></exists>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>y</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
        </apply>
       </apply>
      </matrixrow>
      <matrixrow>
       <apply>
        <csymbol cd="latexml">for-all</csymbol>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <cn type="integer">2</cn>
         </apply>
         <apply>
          <exists></exists>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>y</ci>
           <cn type="integer">2</cn>
          </apply>
         </apply>
        </apply>
       </apply>
      </matrixrow>
     </matrix>
     <ci>ϕ</ci>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">2</cn>
      </apply>
     </vector>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (Q_{H}x_{1},x_{2},y_{1},y_{2})\phi(x_{1},x_{2},y_{1},y_{2})\equiv\begin{%
pmatrix}\forall x_{1}\exists y_{1}\\
\forall x_{2}\exists y_{2}\end{pmatrix}\phi(x_{1},x_{2},y_{1},y_{2})
  </annotation>
 </semantics>
</math>

.</p>

<p>It (in fact every formula with a Henkin prefix, not just the simplest one) is equivalent to its second-order <a class="uri" href="Skolemization" title="wikilink">Skolemization</a>, i.e.</p>

<p>

<math display="block" id="Branching_quantifier:3">
 <semantics>
  <mrow>
   <mo>∃</mo>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo>∃</mo>
     <mrow>
      <mi>g</mi>
      <mrow>
       <mo>∀</mo>
       <mrow>
        <msub>
         <mi>x</mi>
         <mn>1</mn>
        </msub>
        <mrow>
         <mo>∀</mo>
         <mrow>
          <msub>
           <mi>x</mi>
           <mn>2</mn>
          </msub>
          <mi>ϕ</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <msub>
            <mi>x</mi>
            <mn>1</mn>
           </msub>
           <mo>,</mo>
           <msub>
            <mi>x</mi>
            <mn>2</mn>
           </msub>
           <mo>,</mo>
           <mrow>
            <mi>f</mi>
            <mrow>
             <mo stretchy="false">(</mo>
             <msub>
              <mi>x</mi>
              <mn>1</mn>
             </msub>
             <mo stretchy="false">)</mo>
            </mrow>
           </mrow>
           <mo>,</mo>
           <mrow>
            <mi>g</mi>
            <mrow>
             <mo stretchy="false">(</mo>
             <msub>
              <mi>x</mi>
              <mn>2</mn>
             </msub>
             <mo stretchy="false">)</mo>
            </mrow>
           </mrow>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
        </mrow>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <exists></exists>
    <apply>
     <times></times>
     <ci>f</ci>
     <apply>
      <exists></exists>
      <apply>
       <times></times>
       <ci>g</ci>
       <apply>
        <csymbol cd="latexml">for-all</csymbol>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <cn type="integer">1</cn>
         </apply>
         <apply>
          <csymbol cd="latexml">for-all</csymbol>
          <apply>
           <times></times>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>x</ci>
            <cn type="integer">2</cn>
           </apply>
           <ci>ϕ</ci>
           <vector>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <ci>x</ci>
             <cn type="integer">1</cn>
            </apply>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <ci>x</ci>
             <cn type="integer">2</cn>
            </apply>
            <apply>
             <times></times>
             <ci>f</ci>
             <apply>
              <csymbol cd="ambiguous">subscript</csymbol>
              <ci>x</ci>
              <cn type="integer">1</cn>
             </apply>
            </apply>
            <apply>
             <times></times>
             <ci>g</ci>
             <apply>
              <csymbol cd="ambiguous">subscript</csymbol>
              <ci>x</ci>
              <cn type="integer">2</cn>
             </apply>
            </apply>
           </vector>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \exists f\exists g\forall x_{1}\forall x_{2}\phi(x_{1},x_{2},f(x_{1}),g(x_{2}))
  </annotation>
 </semantics>
</math>

.</p>

<p>It is also powerful enough to define the quantifier 

<math display="inline" id="Branching_quantifier:4">
 <semantics>
  <msub>
   <mi>Q</mi>
   <mrow>
    <mi></mi>
    <mo>≥</mo>
    <mi>ℕ</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>Q</ci>
    <apply>
     <geq></geq>
     <csymbol cd="latexml">absent</csymbol>
     <ci>ℕ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q_{\geq\mathbb{N}}
  </annotation>
 </semantics>
</math>

 (i.e. "there are infinitely many") defined as</p>

<p>

<math display="block" id="Branching_quantifier:5">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>Q</mi>
     <mrow>
      <mi></mi>
      <mo>≥</mo>
      <mi>ℕ</mi>
     </mrow>
    </msub>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi>ϕ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>≡</mo>
   <mo>∃</mo>
   <mi>a</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>Q</mi>
     <mi>H</mi>
    </msub>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>x</mi>
     <mn>2</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>y</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>y</mi>
     <mn>2</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>ϕ</mi>
    <mi>a</mi>
    <mo>∧</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo>=</mo>
     <msub>
      <mi>x</mi>
      <mn>2</mn>
     </msub>
     <mo>↔</mo>
     <msub>
      <mi>y</mi>
      <mn>1</mn>
     </msub>
     <mo>=</mo>
     <msub>
      <mi>y</mi>
      <mn>2</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∧</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>ϕ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mn>1</mn>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>→</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>ϕ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>y</mi>
        <mn>1</mn>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>∧</mo>
      <msub>
       <mi>y</mi>
       <mn>1</mn>
      </msub>
      <mo>≠</mo>
      <mi>a</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Q</ci>
      <apply>
       <geq></geq>
       <csymbol cd="latexml">absent</csymbol>
       <ci>ℕ</ci>
      </apply>
     </apply>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">ϕ</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <equivalent></equivalent>
    <exists></exists>
    <csymbol cd="unknown">a</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Q</ci>
      <ci>H</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">ϕ</csymbol>
     <csymbol cd="unknown">a</csymbol>
     <and></and>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <eq></eq>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-↔</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">1</cn>
      </apply>
      <eq></eq>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-)</ci>
     </cerror>
     <and></and>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">ϕ</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-→</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">ϕ</csymbol>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>y</ci>
         <cn type="integer">1</cn>
        </apply>
        <ci>normal-)</ci>
       </cerror>
       <and></and>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <cn type="integer">1</cn>
       </apply>
       <neq></neq>
       <csymbol cd="unknown">a</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (Q_{\geq\mathbb{N}}x)\phi(x)\equiv\exists a(Q_{H}x_{1},x_{2},y_{1},y_{2})[\phi
a%
\land(x_{1}=x_{2}\leftrightarrow y_{1}=y_{2})\land(\phi(x_{1})\rightarrow(\phi%
(y_{1})\land y_{1}\neq a))]
  </annotation>
 </semantics>
</math>

.</p>

<p>Several things follow from this, including the nonaxiomatizability of first-order logic with 

<math display="inline" id="Branching_quantifier:6">
 <semantics>
  <msub>
   <mi>Q</mi>
   <mi>H</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>Q</ci>
    <ci>H</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q_{H}
  </annotation>
 </semantics>
</math>

 (first observed by <a class="uri" href="Ehrenfeucht" title="wikilink">Ehrenfeucht</a>), and its equivalence to the 

<math display="inline" id="Branching_quantifier:7">
 <semantics>
  <msubsup>
   <mi mathvariant="normal">Σ</mi>
   <mn>1</mn>
   <mn>1</mn>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-Σ</ci>
     <cn type="integer">1</cn>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma_{1}^{1}
  </annotation>
 </semantics>
</math>

-fragment of <a href="second-order_logic" title="wikilink">second-order logic</a> (<a href="existential_second-order_logic" title="wikilink">existential second-order logic</a>)—the latter result published independently in 1970 by <a href="Herbert_Enderton" title="wikilink">Herbert Enderton</a><a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> and W. Walkoe.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>

<p>The following quantifiers are also definable by 

<math display="inline" id="Branching_quantifier:8">
 <semantics>
  <msub>
   <mi>Q</mi>
   <mi>H</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>Q</ci>
    <ci>H</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q_{H}
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>
<ul>
<li>Rescher: "The number of φs is less than or equal to the number of ψs"</li>
</ul>

<p>

<math display="block" id="Branching_quantifier:9">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>Q</mi>
     <mi>L</mi>
    </msub>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>ϕ</mi>
    <mi>x</mi>
    <mo>,</mo>
    <mi>ψ</mi>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>≡</mo>
   <mi>C</mi>
   <mi>a</mi>
   <mi>r</mi>
   <mi>d</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mi>x</mi>
     <mo>:</mo>
     <mi>ϕ</mi>
     <mi>x</mi>
     <mo stretchy="false">}</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>≤</mo>
   <mi>C</mi>
   <mi>a</mi>
   <mi>r</mi>
   <mi>d</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mi>x</mi>
     <mo>:</mo>
     <mi>ψ</mi>
     <mi>x</mi>
     <mo stretchy="false">}</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>≡</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>Q</mi>
     <mi>H</mi>
    </msub>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
    <msub>
     <mi>x</mi>
     <mn>2</mn>
    </msub>
    <msub>
     <mi>y</mi>
     <mn>1</mn>
    </msub>
    <msub>
     <mi>y</mi>
     <mn>2</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo>=</mo>
     <msub>
      <mi>x</mi>
      <mn>2</mn>
     </msub>
     <mo>↔</mo>
     <msub>
      <mi>y</mi>
      <mn>1</mn>
     </msub>
     <mo>=</mo>
     <msub>
      <mi>y</mi>
      <mn>2</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∧</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>ϕ</mi>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo>→</mo>
     <mi>ψ</mi>
     <msub>
      <mi>y</mi>
      <mn>1</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Q</ci>
      <ci>L</ci>
     </apply>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">ϕ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">ψ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <equivalent></equivalent>
    <csymbol cd="unknown">C</csymbol>
    <csymbol cd="unknown">a</csymbol>
    <csymbol cd="unknown">r</csymbol>
    <csymbol cd="unknown">d</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-{</ci>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-:</ci>
      <csymbol cd="unknown">ϕ</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-}</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <leq></leq>
    <csymbol cd="unknown">C</csymbol>
    <csymbol cd="unknown">a</csymbol>
    <csymbol cd="unknown">r</csymbol>
    <csymbol cd="unknown">d</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-{</ci>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-:</ci>
      <csymbol cd="unknown">ψ</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-}</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <equivalent></equivalent>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Q</ci>
      <ci>H</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <eq></eq>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-↔</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">1</cn>
      </apply>
      <eq></eq>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-)</ci>
     </cerror>
     <and></and>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">ϕ</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-→</ci>
      <csymbol cd="unknown">ψ</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (Q_{L}x)(\phi x,\psi x)\equiv Card(\{x\colon\phi x\})\leq Card(\{x\colon\psi x%
\})\equiv(Q_{H}x_{1}x_{2}y_{1}y_{2})[(x_{1}=x_{2}\leftrightarrow y_{1}=y_{2})%
\land(\phi x_{1}\rightarrow\psi y_{1})]
  </annotation>
 </semantics>
</math>

</p>
<ul>
<li>Härtig: "The φs are equinumerous with the ψs"</li>
</ul>

<p>

<math display="block" id="Branching_quantifier:10">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>Q</mi>
       <mi>I</mi>
      </msub>
      <mi>x</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>ϕ</mi>
      <mi>x</mi>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mi>ψ</mi>
      <mi>x</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≡</mo>
   <mrow>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>Q</mi>
        <mi>L</mi>
       </msub>
       <mi>x</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>ϕ</mi>
       <mi>x</mi>
      </mrow>
      <mo>,</mo>
      <mrow>
       <mi>ψ</mi>
       <mi>x</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>∧</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>Q</mi>
        <mi>L</mi>
       </msub>
       <mi>x</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>ψ</mi>
       <mi>x</mi>
      </mrow>
      <mo>,</mo>
      <mrow>
       <mi>ϕ</mi>
       <mi>x</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <times></times>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Q</ci>
       <ci>I</ci>
      </apply>
      <ci>x</ci>
     </apply>
     <interval closure="open">
      <apply>
       <times></times>
       <ci>ϕ</ci>
       <ci>x</ci>
      </apply>
      <apply>
       <times></times>
       <ci>ψ</ci>
       <ci>x</ci>
      </apply>
     </interval>
    </apply>
    <apply>
     <and></and>
     <apply>
      <times></times>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Q</ci>
        <ci>L</ci>
       </apply>
       <ci>x</ci>
      </apply>
      <interval closure="open">
       <apply>
        <times></times>
        <ci>ϕ</ci>
        <ci>x</ci>
       </apply>
       <apply>
        <times></times>
        <ci>ψ</ci>
        <ci>x</ci>
       </apply>
      </interval>
     </apply>
     <apply>
      <times></times>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Q</ci>
        <ci>L</ci>
       </apply>
       <ci>x</ci>
      </apply>
      <interval closure="open">
       <apply>
        <times></times>
        <ci>ψ</ci>
        <ci>x</ci>
       </apply>
       <apply>
        <times></times>
        <ci>ϕ</ci>
        <ci>x</ci>
       </apply>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (Q_{I}x)(\phi x,\psi x)\equiv(Q_{L}x)(\phi x,\psi x)\land(Q_{L}x)(\psi x,\phi x)
  </annotation>
 </semantics>
</math>

</p>
<ul>
<li>Chang: "The number of φs is equinumerous with the domain of the model"</li>
</ul>

<p>

<math display="block" id="Branching_quantifier:11">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>Q</mi>
     <mi>C</mi>
    </msub>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>ϕ</mi>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>≡</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>Q</mi>
     <mi>L</mi>
    </msub>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>=</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>ϕ</mi>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Q</ci>
      <ci>C</ci>
     </apply>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">ϕ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <equivalent></equivalent>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Q</ci>
      <ci>L</ci>
     </apply>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <eq></eq>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">ϕ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (Q_{C}x)(\phi x)\equiv(Q_{L}x)(x=x,\phi x)
  </annotation>
 </semantics>
</math>

</p>

<p>The Henkin quantifier 

<math display="inline" id="Branching_quantifier:12">
 <semantics>
  <msub>
   <mi>Q</mi>
   <mi>H</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>Q</ci>
    <ci>H</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q_{H}
  </annotation>
 </semantics>
</math>

 can itself be expressed as a type (4) <a href="Lindström_quantifier" title="wikilink">Lindström quantifier</a>.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>
<h2 id="relation-to-natural-languages">Relation to natural languages</h2>

<p>Hintikka in a 1973 paper<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> advanced the hypothesis that some sentences in natural languages are best understood in terms of branching quantifiers, for example: "some relative of each villager and some relative of each townsman hate each other" is supposed to be interpreted, according to Hintikka, as:<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a><a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a></p>

<p>

<math display="block" id="Branching_quantifier:13">
 <semantics>
  <mrow>
   <mrow>
    <mo>(</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <mo>∀</mo>
        <mrow>
         <msub>
          <mi>x</mi>
          <mn>1</mn>
         </msub>
         <mrow>
          <mo>∃</mo>
          <msub>
           <mi>y</mi>
           <mn>1</mn>
          </msub>
         </mrow>
        </mrow>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <mo>∀</mo>
        <mrow>
         <msub>
          <mi>x</mi>
          <mn>2</mn>
         </msub>
         <mrow>
          <mo>∃</mo>
          <msub>
           <mi>y</mi>
           <mn>2</mn>
          </msub>
         </mrow>
        </mrow>
       </mrow>
      </mtd>
     </mtr>
    </mtable>
    <mo>)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>V</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mn>1</mn>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>∧</mo>
     <mi>T</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mn>2</mn>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>→</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>R</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mn>1</mn>
      </msub>
      <mo>,</mo>
      <msub>
       <mi>y</mi>
       <mn>1</mn>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>∧</mo>
     <mi>R</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mn>2</mn>
      </msub>
      <mo>,</mo>
      <msub>
       <mi>y</mi>
       <mn>2</mn>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>∧</mo>
     <mi>H</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>y</mi>
       <mn>1</mn>
      </msub>
      <mo>,</mo>
      <msub>
       <mi>y</mi>
       <mn>2</mn>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>∧</mo>
     <mi>H</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>y</mi>
       <mn>2</mn>
      </msub>
      <mo>,</mo>
      <msub>
       <mi>y</mi>
       <mn>1</mn>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <matrix>
     <matrixrow>
      <apply>
       <csymbol cd="latexml">for-all</csymbol>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <cn type="integer">1</cn>
        </apply>
        <apply>
         <exists></exists>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>y</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
       </apply>
      </apply>
     </matrixrow>
     <matrixrow>
      <apply>
       <csymbol cd="latexml">for-all</csymbol>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <cn type="integer">2</cn>
        </apply>
        <apply>
         <exists></exists>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>y</ci>
          <cn type="integer">2</cn>
         </apply>
        </apply>
       </apply>
      </apply>
     </matrixrow>
    </matrix>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">V</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>normal-)</ci>
      </cerror>
      <and></and>
      <csymbol cd="unknown">T</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <cn type="integer">2</cn>
       </apply>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-→</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">R</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>normal-,</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>normal-)</ci>
      </cerror>
      <and></and>
      <csymbol cd="unknown">R</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <cn type="integer">2</cn>
       </apply>
       <ci>normal-,</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <cn type="integer">2</cn>
       </apply>
       <ci>normal-)</ci>
      </cerror>
      <and></and>
      <csymbol cd="unknown">H</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>normal-,</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <cn type="integer">2</cn>
       </apply>
       <ci>normal-)</ci>
      </cerror>
      <and></and>
      <csymbol cd="unknown">H</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <cn type="integer">2</cn>
       </apply>
       <ci>normal-,</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{pmatrix}\forall x_{1}\exists y_{1}\\
\forall x_{2}\exists y_{2}\end{pmatrix}[(V(x_{1})\wedge T(x_{2}))\rightarrow(R%
(x_{1},y_{1})\wedge R(x_{2},y_{2})\wedge H(y_{1},y_{2})\wedge H(y_{2},y_{1}))]
  </annotation>
 </semantics>
</math>

.</p>

<p>which is known to have no first-order logic equivalent.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a></p>

<p>The idea of branching is not necessarily restricted to using the classical quantifiers as leaves. In a 1979 paper,<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> <a href="Jon_Barwise" title="wikilink">Jon Barwise</a> proposed variations of Hintikka sentences (as the above is sometimes called) in which the inner quantifiers are themselves <a href="generalized_quantifiers" title="wikilink">generalized quantifiers</a>, for example: "Most villagers and most townsmen hate each other."<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> Observing that 

<math display="inline" id="Branching_quantifier:14">
 <semantics>
  <msubsup>
   <mi mathvariant="normal">Σ</mi>
   <mn>1</mn>
   <mn>1</mn>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-Σ</ci>
     <cn type="integer">1</cn>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma_{1}^{1}
  </annotation>
 </semantics>
</math>

 is not closed under negation, Barwise also proposed a practical test to determine whether natural language sentences really involve branching quantifiers, namely to test whether their natural-language negation involves universal quantification over a set variable (a 

<math display="inline" id="Branching_quantifier:15">
 <semantics>
  <msubsup>
   <mi mathvariant="normal">Π</mi>
   <mn>1</mn>
   <mn>1</mn>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-Π</ci>
     <cn type="integer">1</cn>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Pi_{1}^{1}
  </annotation>
 </semantics>
</math>

 sentence).<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a></p>

<p>Hintikka's proposal was met with skepticism by a number of logicians because some first-order sentences like the one below appear to capture well enough the natural language Hintikka sentence.</p>

<p>

<math display="block" id="Branching_quantifier:16">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mrow>
     <mo>∀</mo>
     <mrow>
      <msub>
       <mi>x</mi>
       <mn>1</mn>
      </msub>
      <mrow>
       <mo>∃</mo>
       <mrow>
        <msub>
         <mi>y</mi>
         <mn>1</mn>
        </msub>
        <mrow>
         <mo>∀</mo>
         <mrow>
          <msub>
           <mi>x</mi>
           <mn>2</mn>
          </msub>
          <mrow>
           <mo>∃</mo>
           <mrow>
            <mpadded width="+1.7pt">
             <msub>
              <mi>y</mi>
              <mn>2</mn>
             </msub>
            </mpadded>
            <mi>ϕ</mi>
            <mrow>
             <mo stretchy="false">(</mo>
             <msub>
              <mi>x</mi>
              <mn>1</mn>
             </msub>
             <mo>,</mo>
             <msub>
              <mi>x</mi>
              <mn>2</mn>
             </msub>
             <mo>,</mo>
             <msub>
              <mi>y</mi>
              <mn>1</mn>
             </msub>
             <mo>,</mo>
             <msub>
              <mi>y</mi>
              <mn>2</mn>
             </msub>
             <mo stretchy="false">)</mo>
            </mrow>
           </mrow>
          </mrow>
         </mrow>
        </mrow>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>∧</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mrow>
     <mo>∀</mo>
     <mrow>
      <msub>
       <mi>x</mi>
       <mn>2</mn>
      </msub>
      <mrow>
       <mo>∃</mo>
       <mrow>
        <msub>
         <mi>y</mi>
         <mn>2</mn>
        </msub>
        <mrow>
         <mo>∀</mo>
         <mrow>
          <msub>
           <mi>x</mi>
           <mn>1</mn>
          </msub>
          <mrow>
           <mo>∃</mo>
           <mrow>
            <mpadded width="+1.7pt">
             <msub>
              <mi>y</mi>
              <mn>1</mn>
             </msub>
            </mpadded>
            <mi>ϕ</mi>
            <mrow>
             <mo stretchy="false">(</mo>
             <msub>
              <mi>x</mi>
              <mn>1</mn>
             </msub>
             <mo>,</mo>
             <msub>
              <mi>x</mi>
              <mn>2</mn>
             </msub>
             <mo>,</mo>
             <msub>
              <mi>y</mi>
              <mn>1</mn>
             </msub>
             <mo>,</mo>
             <msub>
              <mi>y</mi>
              <mn>2</mn>
             </msub>
             <mo stretchy="false">)</mo>
            </mrow>
           </mrow>
          </mrow>
         </mrow>
        </mrow>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <exists></exists>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>y</ci>
          <cn type="integer">1</cn>
         </apply>
         <apply>
          <csymbol cd="latexml">for-all</csymbol>
          <apply>
           <times></times>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>x</ci>
            <cn type="integer">2</cn>
           </apply>
           <apply>
            <exists></exists>
            <apply>
             <times></times>
             <apply>
              <csymbol cd="ambiguous">subscript</csymbol>
              <ci>y</ci>
              <cn type="integer">2</cn>
             </apply>
             <ci>ϕ</ci>
             <vector>
              <apply>
               <csymbol cd="ambiguous">subscript</csymbol>
               <ci>x</ci>
               <cn type="integer">1</cn>
              </apply>
              <apply>
               <csymbol cd="ambiguous">subscript</csymbol>
               <ci>x</ci>
               <cn type="integer">2</cn>
              </apply>
              <apply>
               <csymbol cd="ambiguous">subscript</csymbol>
               <ci>y</ci>
               <cn type="integer">1</cn>
              </apply>
              <apply>
               <csymbol cd="ambiguous">subscript</csymbol>
               <ci>y</ci>
               <cn type="integer">2</cn>
              </apply>
             </vector>
            </apply>
           </apply>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <exists></exists>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>y</ci>
          <cn type="integer">2</cn>
         </apply>
         <apply>
          <csymbol cd="latexml">for-all</csymbol>
          <apply>
           <times></times>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>x</ci>
            <cn type="integer">1</cn>
           </apply>
           <apply>
            <exists></exists>
            <apply>
             <times></times>
             <apply>
              <csymbol cd="ambiguous">subscript</csymbol>
              <ci>y</ci>
              <cn type="integer">1</cn>
             </apply>
             <ci>ϕ</ci>
             <vector>
              <apply>
               <csymbol cd="ambiguous">subscript</csymbol>
               <ci>x</ci>
               <cn type="integer">1</cn>
              </apply>
              <apply>
               <csymbol cd="ambiguous">subscript</csymbol>
               <ci>x</ci>
               <cn type="integer">2</cn>
              </apply>
              <apply>
               <csymbol cd="ambiguous">subscript</csymbol>
               <ci>y</ci>
               <cn type="integer">1</cn>
              </apply>
              <apply>
               <csymbol cd="ambiguous">subscript</csymbol>
               <ci>y</ci>
               <cn type="integer">2</cn>
              </apply>
             </vector>
            </apply>
           </apply>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [\forall x_{1}\exists y_{1}\forall x_{2}\exists y_{2}\,\phi(x_{1},x_{2},y_{1},%
y_{2})]\wedge[\forall x_{2}\exists y_{2}\forall x_{1}\exists y_{1}\,\phi(x_{1}%
,x_{2},y_{1},y_{2})]
  </annotation>
 </semantics>
</math>

 where</p>

<p>

<math display="block" id="Branching_quantifier:17">
 <semantics>
  <mrow>
   <mi>ϕ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>x</mi>
     <mn>2</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>y</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>y</mi>
     <mn>2</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>ϕ</ci>
    <vector>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <cn type="integer">2</cn>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi(x_{1},x_{2},y_{1},y_{2})
  </annotation>
 </semantics>
</math>

 denotes 

<math display="inline" id="Branching_quantifier:18">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mrow>
      <mi>V</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>x</mi>
        <mn>1</mn>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>∧</mo>
     <mrow>
      <mi>T</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>x</mi>
        <mn>2</mn>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mrow>
      <mi>R</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>x</mi>
        <mn>1</mn>
       </msub>
       <mo>,</mo>
       <msub>
        <mi>y</mi>
        <mn>1</mn>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>∧</mo>
     <mrow>
      <mi>R</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>x</mi>
        <mn>2</mn>
       </msub>
       <mo>,</mo>
       <msub>
        <mi>y</mi>
        <mn>2</mn>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>∧</mo>
     <mrow>
      <mi>H</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>y</mi>
        <mn>1</mn>
       </msub>
       <mo>,</mo>
       <msub>
        <mi>y</mi>
        <mn>2</mn>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>∧</mo>
     <mrow>
      <mi>H</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>y</mi>
        <mn>2</mn>
       </msub>
       <mo>,</mo>
       <msub>
        <mi>y</mi>
        <mn>1</mn>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <and></and>
     <apply>
      <times></times>
      <ci>V</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>T</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <and></and>
     <apply>
      <times></times>
      <ci>R</ci>
      <interval closure="open">
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <cn type="integer">1</cn>
       </apply>
      </interval>
     </apply>
     <apply>
      <times></times>
      <ci>R</ci>
      <interval closure="open">
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <cn type="integer">2</cn>
       </apply>
      </interval>
     </apply>
     <apply>
      <times></times>
      <ci>H</ci>
      <interval closure="open">
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <cn type="integer">2</cn>
       </apply>
      </interval>
     </apply>
     <apply>
      <times></times>
      <ci>H</ci>
      <interval closure="open">
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <cn type="integer">1</cn>
       </apply>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (V(x_{1})\wedge T(x_{2}))\rightarrow(R(x_{1},y_{1})\wedge R(x_{2},y_{2})\wedge
H%
(y_{1},y_{2})\wedge H(y_{2},y_{1}))
  </annotation>
 </semantics>
</math>

</p>

<p>Although much purely theoretical debate followed, it wasn't until 2009 that some empirical tests with students trained in logic found that they are more likely to assign models matching the "bidirectional" first-order sentence rather than branching-quantifier sentence to several natural-language constructs derived from the Hintikka sentence. For instance students were shown undirected <a href="bipartite_graph" title="wikilink">bipartite graphs</a>—with squares and circles as vertices—and asked to say whether sentences like "more than 3 circles and more than 3 squares are connected by lines" were correctly describing the diagrams.<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Game_semantics" title="wikilink">Game semantics</a></li>
<li><a href="Dependence_logic" title="wikilink">Dependence logic</a></li>
<li><a href="Independence-friendly_logic" title="wikilink">Independence-friendly logic</a> (IF logic)</li>
<li><a href="Mostowski_quantifier" title="wikilink">Mostowski quantifier</a></li>
<li><a href="Lindström_quantifier" title="wikilink">Lindström quantifier</a></li>
<li><a class="uri" href="Nonfirstorderizability" title="wikilink">Nonfirstorderizability</a></li>
</ul>
<h2 id="references">References</h2>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://planetmath.org/encyclopedia/Branching.html">Game-theoretical quantifier</a> at PlanetMath.</li>
</ul>

<p>"</p>

<p><a class="uri" href="Category:Quantification" title="wikilink">Category:Quantification</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3">Henkin, L. "Some Remarks on Infinitely Long Formulas". <em>Infinitistic Methods: Proceedings of the Symposium on Foundations of Mathematics, Warsaw, 2–9 September 1959</em>, Panstwowe Wydawnictwo Naukowe and Pergamon Press, Warsaw, 1961, pp. 167-183. <a href="#fnref3">↩</a></li>
<li id="fn4">Jaakko Hintikka and Gabriel Sandu, "Game-theoretical semantics", in <em>Handbook of logic and language</em>, ed. J. van Benthem and A. ter Meulen, Elsevier 2011 (2nd ed.) citing Enderton, H.B., 1970. Finite ordered quantifiers. Z. Math. Logik Grundlag. Math. 16, 393–397 .<a href="#fnref4">↩</a></li>
<li id="fn5"> citing W. Walkoe, Finite ordered quantification, J. Symbolic Logic 35 (1970) 535-555. <a href="#fnref5">↩</a></li>
<li id="fn6"></li>
<li id="fn7"></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
<li id="fn10"><a href="#fnref10">↩</a></li>
<li id="fn11"></li>
<li id="fn12"><a href="#fnref12">↩</a></li>
<li id="fn13"></li>
<li id="fn14"><a href="#fnref14">↩</a></li>
<li id="fn15"></li>
</ol>
</section>
</body>
</html>
