<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="47">Descriptive complexity theory</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Descriptive complexity theory</h1>
<hr/>

<p>__NOTOC__ <strong>Descriptive complexity</strong> is a branch of <a href="computational_complexity_theory" title="wikilink">computational complexity theory</a> and of <a href="finite_model_theory" title="wikilink">finite model theory</a> that characterizes <a href="complexity_class" title="wikilink">complexity classes</a> by the type of <a class="uri" href="logic" title="wikilink">logic</a> needed to express the languages in them. For example, <a href="PH_(complexity)" title="wikilink">PH</a>, the union of all complexity classes in the polynomial hierarchy, is precisely the class of languages expressible by statements of <a href="second-order_logic" title="wikilink">second-order logic</a>. This connection between complexity and the logic of finite structures allows results to be transferred easily from one area to the other, facilitating new proof methods and providing additional evidence that the main complexity classes are somehow "natural" and not tied to the specific <a href="abstract_machine" title="wikilink">abstract machines</a> used to define them.</p>

<p>Specifically, each <a href="logical_system" title="wikilink">logical system</a> produces a set of <a href="query_(complexity)" title="wikilink">queries</a> expressible in it. The queries – when restricted to finite structures – correspond to the <a href="computational_problem" title="wikilink">computational problems</a> of traditional complexity theory.</p>

<p>The first main result of descriptive complexity was <a href="Fagin's_theorem" title="wikilink">Fagin's theorem</a>, shown by <a href="Ronald_Fagin" title="wikilink">Ronald Fagin</a> in 1974. It established that <a href="NP_(complexity)" title="wikilink">NP</a> is precisely the set of languages expressible by sentences of existential <a href="second-order_logic" title="wikilink">second-order logic</a>; that is, second order logic excluding universal quantification over relations, functions, and subsets. Many other classes were later characterized in such a manner, most of them by <a href="Neil_Immerman" title="wikilink">Neil Immerman</a>:</p>
<ul>
<li><a href="First-order_logic" title="wikilink">First-order logic</a> defines the class <a href="FO_(complexity)" title="wikilink">FO</a>, corresponding to <a href="AC0" title="wikilink">AC<sup>0</sup></a>, the languages recognized by polynomial-size circuits of bounded depth, which equals the languages recognized by a <a href="concurrent_random_access_machine" title="wikilink">concurrent random access machine</a> in constant time.</li>
<li>First-order logic with a commutative, <a href="transitive_closure" title="wikilink">transitive closure</a> operator added yields <a href="SL_(complexity)" title="wikilink">SL</a>, which equals <a href="L_(complexity)" title="wikilink">L</a>, problems solvable in logarithmic space.</li>
<li>First-order logic with a <a href="transitive_closure" title="wikilink">transitive closure</a> operator yields <a href="NL_(complexity)" title="wikilink">NL</a>, the problems solvable in nondeterministic logarithmic space.</li>
<li>In the presence of linear order, first-order logic with a <a href="least_fixed_point" title="wikilink">least fixed point</a> operator gives <a href="P_(complexity)" title="wikilink">P</a>, the problems solvable in deterministic polynomial time.</li>
<li>Existential second-order logic yields <a href="NP_(complexity)" title="wikilink">NP</a>, as mentioned above.</li>
<li>Universal second-order logic (excluding existential second-order quantification) yields co-NP.</li>
<li><a href="SO_(complexity)" title="wikilink">Second-order</a> logic corresponds to <a href="PH_(complexity)" title="wikilink">PH</a>.</li>
<li>Second-order logic with a <a href="transitive_closure" title="wikilink">transitive closure</a> (commutative or not) yields <a class="uri" href="PSPACE" title="wikilink">PSPACE</a>, the problems solvable in polynomial space.</li>
<li>Second-order logic with a <a href="least_fixed_point" title="wikilink">least fixed point</a> operator gives <a class="uri" href="EXPTIME" title="wikilink">EXPTIME</a>, the problems solvable in exponential time.</li>
<li>

<math display="inline" id="Descriptive_complexity_theory:0">
 <semantics>
  <merror class="ltx_ERROR undefined undefined">
   <mtext>\exist</mtext>
  </merror>
  <annotation-xml encoding="MathML-Content">
   <mtext>\exist</mtext>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \exist
  </annotation>
 </semantics>
</math>

<a href="HO_(complexity)" title="wikilink">HO</a>

<math display="inline" id="Descriptive_complexity_theory:1">
 <semantics>
  <msup>
   <mi></mi>
   <mi>i</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {}^{i}
  </annotation>
 </semantics>
</math>

, logic with existential quantifier of order 

<math display="inline" id="Descriptive_complexity_theory:2">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

 followed by a formula of order 

<math display="inline" id="Descriptive_complexity_theory:3">
 <semantics>
  <mrow>
   <mi>i</mi>
   <mo>-</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>i</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i-1
  </annotation>
 </semantics>
</math>


 is equal to <a class="uri" href="NTIME" title="wikilink">NTIME</a>(

<math display="inline" id="Descriptive_complexity_theory:4">
 <semantics>
  <mrow>
   <msubsup>
    <mi>exp</mi>
    <mn>2</mn>
    <mrow>
     <mi>i</mi>
     <mo>-</mo>
     <mn>2</mn>
    </mrow>
   </msubsup>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>n</mi>
     <mrow>
      <mi>O</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mn>1</mn>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <exp></exp>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <minus></minus>
      <ci>i</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>n</ci>
     <apply>
      <times></times>
      <ci>O</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \exp_{2}^{i-2}(n^{O(1)})
  </annotation>
 </semantics>
</math>

)<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></li>
<li><a href="HO_(complexity)" title="wikilink">HO</a>

<math display="inline" id="Descriptive_complexity_theory:5">
 <semantics>
  <mmultiscripts>
   <mi></mi>
   <mi>j</mi>
   <none></none>
   <mprescripts></mprescripts>
   <none></none>
   <mi>i</mi>
  </mmultiscripts>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <csymbol cd="latexml">absent</csymbol>
     <ci>i</ci>
    </apply>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {}^{i}_{j}
  </annotation>
 </semantics>
</math>

=<a class="uri" href="NTIME" title="wikilink">NTIME</a>(

<math display="inline" id="Descriptive_complexity_theory:6">
 <semantics>
  <mrow>
   <msubsup>
    <mi>exp</mi>
    <mn>2</mn>
    <mrow>
     <mi>i</mi>
     <mo>-</mo>
     <mn>2</mn>
    </mrow>
   </msubsup>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>n</mi>
     <mrow>
      <mi>O</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mn>1</mn>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo stretchy="false">)</mo>
   <msup>
    <mi></mi>
    <msubsup>
     <mi mathvariant="normal">Σ</mi>
     <mi>j</mi>
     <mi mathvariant="normal">P</mi>
    </msubsup>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <exp></exp>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <minus></minus>
      <ci>i</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>n</ci>
      <apply>
       <times></times>
       <ci>O</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-)</ci>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>normal-Σ</ci>
       <ci>j</ci>
      </apply>
      <ci>normal-P</ci>
     </apply>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \exp_{2}^{i-2}(n^{O(1)}))^{\Sigma_{j}^{\rm P}}
  </annotation>
 </semantics>
</math>

</li>
<li><a href="HO_(complexity)" title="wikilink">HO</a> is equal to <a class="uri" href="ELEMENTARY" title="wikilink">ELEMENTARY</a></li>
</ul>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="SO_(complexity)" title="wikilink">SO (complexity)</a></li>
<li><a href="FO_(complexity)" title="wikilink">FO (complexity)</a></li>
<li><a href="Spectrum_of_a_sentence" title="wikilink">Spectrum of a sentence</a></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li><a href="Ronald_Fagin" title="wikilink">Ronald Fagin</a>, <a href="http://www.almaden.ibm.com/cs/people/fagin/genspec.pdf">Generalized First-Order Spectra and Polynomial-Time Recognizable Sets</a>. <em>Complexity of Computation</em>, ed. R. Karp, SIAM-AMS Proceedings 7, pp. 27–41. 1974.</li>
<li>Ronald Fagin, <a href="http://www.almaden.ibm.com/cs/people/fagin/tcs93.pdf">Finite model theory-a personal perspective</a>. Theoretical Computer Science 116, 1993, pp. 3–31.</li>
<li>Neil Immerman. <a href="http://www.cs.umass.edu/~immerman/pub/capture.pdf">Languages Which Capture Complexity Classes</a>. <em>15th ACM STOC Symposium</em>, pp. 347–354. 1983.</li>
<li>

<p>.</p></li>
</ul>
<h2 id="further-reading">Further reading</h2>
<ul>
<li>Shawn Hedman, <em>A first course in logic: an introduction to model theory, proof theory, computability, and complexity</em>, Oxford University Press, 2004, ISBN 0-19-852981-3, section 10.3 is a suitable introduction for undergraduates</li>
<li></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.cs.umass.edu/~immerman/descriptive_complexity.html">Neil Immerman's descriptive complexity page</a>, including a diagram</li>
</ul>

<p>"</p>

<p><a href="Category:Descriptive_complexity" title="wikilink"> </a> <a href="Category:Computational_complexity_theory" title="wikilink">Category:Computational complexity theory</a> <a href="Category:Finite_model_theory" title="wikilink">Category:Finite model theory</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
</ol>
</section>
</body>
</html>
