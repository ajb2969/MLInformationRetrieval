<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1596">Noisy-storage model</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Noisy-storage model</h1>
<hr/>

<p>The <strong>noisy-storage model</strong><a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> refers to a cryptographic model employed in <a href="quantum_cryptography" title="wikilink">quantum cryptography</a>. It assumes that the quantum memory device of an attacker (<a href="Adversary_(cryptography)" title="wikilink">adversary</a>) trying to break the protocol is imperfect (noisy). The main goal of this model is to enable the secure implementation of two-party cryptographic primitives, such as <a href="bit_commitment" title="wikilink">bit commitment</a>, <a href="oblivious_transfer" title="wikilink">oblivious transfer</a> and <a href="Smart_Card#Applications" title="wikilink">secure identification</a>.</p>
<h2 id="motivation">Motivation</h2>

<p>Quantum communication has proven to be extremely useful when it comes to distributing encryption keys. It allows two distant parties Alice and Bob to expand a small initial <a href="secret_key" title="wikilink">secret key</a> into an arbitrarily long secret key by sending <a class="uri" href="qubits" title="wikilink">qubits</a> (quantum bits) to each other. Most importantly, it can be shown that any <a class="uri" href="eavesdropper" title="wikilink">eavesdropper</a> trying to listen into their communication cannot intercept any information about the long key. This is known as <a href="quantum_key_distribution" title="wikilink">quantum key distribution</a> (QKD).</p>

<p>Yet, it has been shown that even quantum communication does not allow the secure implementation of many other two-party cryptographic tasks.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a><a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a><a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a><a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> These all form instances of <a href="secure_function_evaluation" title="wikilink">secure function evaluation</a>. An example is <a href="oblivious_transfer" title="wikilink">oblivious transfer</a>. What sets these tasks apart from key distribution is that they aim to solve problems between two parties, Alice and Bob, who do <em>not</em> trust each other. That is, there is no outside party like an <a class="uri" href="eavesdropper" title="wikilink">eavesdropper</a>, only Alice and Bob. Intuitively, it is this lack of trust that makes the problem hard. Unlike in <a href="quantum_key_distribution" title="wikilink">quantum key distribution</a>, Alice and Bob cannot collaborate to try and detect any eavesdropping activity. Instead, each party has to fend for himself.</p>

<p>Since tasks like <a href="Smart_Card#Applications" title="wikilink">secure identification</a> are of practical interest, one is willing to make assumptions on how powerful the <a href="Adversary_(cryptography)" title="wikilink">adversary</a> can be. Security then holds as long as these assumptions are satisfied. In classical cryptography, i.e., without the use of quantum tools, most of these are <a href="Computational_hardness_assumption" title="wikilink">computational assumptions</a>. Such assumptions consists of two parts. First, one assumes that a particular problem is difficult to solve. For example, one might assume that it is hard to <a href="Integer_factorization" title="wikilink">factor</a> a large <a class="uri" href="integer" title="wikilink">integer</a> into its <a class="uri" href="prime" title="wikilink">prime</a> factors (e.g. 15=5x3). Second, one assumes that the adversary has a limited amount of computing power, namely less than what is (thought to be) required to solve the chosen problem.</p>
<h3 id="bounded-storage">Bounded storage</h3>

<p>In <a href="information_theoretic_security" title="wikilink">information theoretic cryptography</a> physical assumptions appear, which do not rely on any hardness assumptions, but merely assume a limit on some other resource. In classical cryptography, the <strong>bounded-storage model</strong> introduced by <a href="Ueli_Maurer_(cryptographer)" title="wikilink">Ueli Maurer</a> assumes that the <a href="Adversary_(cryptography)" title="wikilink">adversary</a> can only store a certain number of classical bits.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a><a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> Protocols are known that do (in principle) allow the secure implementation of any cryptographic task as long as the adversary's storage is small. Very intuitively, security becomes possible under this assumption since the adversary has to make a choice which information to keep. That is, the protocol effectively overflows his memory device leading to an inevitable lack on information for the adversary. It was later discovered that any classical <a href="Protocol_(object-oriented_programming)" title="wikilink">protocol</a> which requires the honest parties to store 

<math display="inline" id="Noisy-storage_model:0">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 bits in order to execute it successfully can be broken by an adversary that can store more than about 

<math display="inline" id="Noisy-storage_model:1">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>n</mi>
     <mn>2</mn>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>n</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n^{2})
  </annotation>
 </semantics>
</math>

 bits.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> That is, the gap between what is required to execute the protocol, and what is required to break the security is relatively small.</p>
<h3 id="bounded-quantum-storage">Bounded quantum storage</h3>

<p>This gap changes dramatically when using <a href="quantum_communication" title="wikilink">quantum communication</a><a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> . That is, Alice and Bob can send <a href="qubit" title="wikilink">qubits</a> to each other as part of the protocol. Likewise, one now assumes that the adversary's quantum storage is limited to a certain number of qubits. There is no restriction on how many classical bits the adversary can store. This is known as the <strong>bounded-<em>quantum</em>-storage model</strong>.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a><a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> It was shown that there exist quantum protocols in which the honest parties need <em>no</em> quantum storage at all to execute them, but are nevertheless secure as long as Alice transmits more than twice the number of qubits than the adversary can store.</p>
<h3 id="noisy-storage">Noisy storage</h3>

<p>More generally, security is possible as long as the amount of information that the adversary can store in his memory device is limited. This intuition is captured by the <strong>noisy-storage model</strong>,<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> which includes the bounded-quantum-storage model as a special case.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> Such a limitation can, for example, come about if the memory device is extremely large, but very imperfect. In <a href="information_theory" title="wikilink">information theory</a> such an imperfect memory device is also called a <a href="noisy_channel" title="wikilink">noisy channel</a>. The motivation for this more general model is threefold. First, it allows one to make statements about much more general memory devices that the adversary may have available. Second, security statements could be made when the signals transmitted, or the storage device itself, uses <a href="Quantum_key_distribution" title="wikilink">continuous variables</a> whose dimension is infinite and thus cannot be captured by a bounded storage assumption without additional constraints. Third, even if the dimension of the signals itself is small, the noisy-storage analysis allows security beyond the regime where bounded-storage itself can make any security statement. For example, if the storage channel is entanglement breaking, security is possible even if the storage device is arbitrarily large (i.e., not bounded in any way).</p>
<h2 id="assumption">Assumption</h2>

<p>The assumption of the noisy-storage model is that during waiting times 

<math display="inline" id="Noisy-storage_model:2">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Î”</mi>
   <mi>t</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Î”</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta t
  </annotation>
 </semantics>
</math>

 introduced into the protocol, the <a href="Adversary_(cryptography)" title="wikilink">adversary</a> can only store <a href="quantum_information" title="wikilink">quantum information</a> in his noisy memory device.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a> Such a device is simply a <a href="quantum_channel" title="wikilink">quantum channel</a> 

<math display="inline" id="Noisy-storage_model:3">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">â„±</mi>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mi class="ltx_font_mathcaligraphic">ğ’®</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi class="ltx_font_mathcaligraphic">â„‹</mi>
       <mi>in</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>â†’</mo>
    <mrow>
     <mi class="ltx_font_mathcaligraphic">ğ’®</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi class="ltx_font_mathcaligraphic">â„‹</mi>
       <mi>out</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>â„±</ci>
    <apply>
     <ci>normal-â†’</ci>
     <apply>
      <times></times>
      <ci>ğ’®</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>â„‹</ci>
       <ci>in</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>ğ’®</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>â„‹</ci>
       <ci>out</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{F}:\mathcal{S}(\mathcal{H}_{\rm in})\rightarrow\mathcal{S}(\mathcal{H%
}_{\rm out})
  </annotation>
 </semantics>
</math>


 that takes input <a href="quantum_state" title="wikilink">states</a> 

<math display="inline" id="Noisy-storage_model:4">
 <semantics>
  <mrow>
   <msub>
    <mi>Ï</mi>
    <mi>in</mi>
   </msub>
   <mo>âˆˆ</mo>
   <mrow>
    <mi class="ltx_font_mathcaligraphic">ğ’®</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi class="ltx_font_mathcaligraphic">â„‹</mi>
      <mi>in</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Ï</ci>
     <ci>in</ci>
    </apply>
    <apply>
     <times></times>
     <ci>ğ’®</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>â„‹</ci>
      <ci>in</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho_{\rm in}\in\mathcal{S}(\mathcal{H}_{\rm in})
  </annotation>
 </semantics>
</math>

 to some noisy output states 

<math display="inline" id="Noisy-storage_model:5">
 <semantics>
  <mrow>
   <msub>
    <mi>Ï</mi>
    <mi>out</mi>
   </msub>
   <mo>âˆˆ</mo>
   <mrow>
    <mi class="ltx_font_mathcaligraphic">ğ’®</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi class="ltx_font_mathcaligraphic">â„‹</mi>
      <mi>out</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Ï</ci>
     <ci>out</ci>
    </apply>
    <apply>
     <times></times>
     <ci>ğ’®</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>â„‹</ci>
      <ci>out</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho_{\rm out}\in\mathcal{S}(\mathcal{H}_{\rm out})
  </annotation>
 </semantics>
</math>

. Otherwise, the adversary is all powerful. For example, he can store an unlimited amount of classical information and perform any computation instantaneously.</p>

<p> The latter assumption also implies that he can perform any form of <a href="Error-correcting" title="wikilink">error correcting encoding</a> before and after using the noisy memory device, even if it is computationally very difficult to do (i.e., it requires a long time). In this context, this is generally referred to as an encoding attack 

<math display="inline" id="Noisy-storage_model:6">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">â„°</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>â„°</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{E}
  </annotation>
 </semantics>
</math>

 and a decoding attack 

<math display="inline" id="Noisy-storage_model:7">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ğ’Ÿ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ğ’Ÿ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{D}
  </annotation>
 </semantics>
</math>

. Since the adversary's classical memory can be arbitrarily large, the encoding 

<math display="inline" id="Noisy-storage_model:8">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">â„°</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>â„°</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{E}
  </annotation>
 </semantics>
</math>


 may not only generate some <a href="quantum_state" title="wikilink">quantum state</a> as input to the storage device 

<math display="inline" id="Noisy-storage_model:9">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">â„±</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>â„±</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{F}
  </annotation>
 </semantics>
</math>

 but also output classical information. The adversary's decoding attack 

<math display="inline" id="Noisy-storage_model:10">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ğ’Ÿ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ğ’Ÿ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{D}
  </annotation>
 </semantics>
</math>

 can make use of this extra classical information, as well as any additional information that the adversary may gain after the waiting time has passed.</p>

<p>In practise, one often considers storage devices that consist of 

<math display="inline" id="Noisy-storage_model:11">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

 memory cells, each of which is subject to noise. In information-theoretic terms, this means that the device has the form 

<math display="inline" id="Noisy-storage_model:12">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">â„±</mi>
   <mo>=</mo>
   <msup>
    <mi class="ltx_font_mathcaligraphic">ğ’©</mi>
    <mrow>
     <mi></mi>
     <mo>âŠ—</mo>
     <mi>N</mi>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>â„±</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ğ’©</ci>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <csymbol cd="latexml">absent</csymbol>
      <ci>N</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{F}=\mathcal{N}^{\otimes N}
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Noisy-storage_model:13">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">ğ’©</mi>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mi>S</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msup>
       <merror class="ltx_ERROR undefined undefined">
        <mtext>\Complex</mtext>
       </merror>
       <mi>d</mi>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>â†’</mo>
    <mrow>
     <mi>S</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msup>
       <merror class="ltx_ERROR undefined undefined">
        <mtext>\Complex</mtext>
       </merror>
       <mi>d</mi>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>ğ’©</ci>
    <apply>
     <ci>normal-â†’</ci>
     <apply>
      <times></times>
      <ci>S</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <mtext>\Complex</mtext>
       <ci>d</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>S</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <mtext>\Complex</mtext>
       <ci>d</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{N}:S(\Complex^{d})\rightarrow S(\Complex^{d})
  </annotation>
 </semantics>
</math>


 is a noisy <a href="quantum_channel" title="wikilink">quantum channel</a> acting on a memory cell of dimension 

<math display="inline" id="Noisy-storage_model:14">
 <semantics>
  <mi>d</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>d</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d
  </annotation>
 </semantics>
</math>

.</p>
<h3 id="examples">Examples</h3>
<ul>
<li>The storage device consists of 

<math display="inline" id="Noisy-storage_model:15">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

 <a href="qubit" title="wikilink">qubits</a>, each of which is subject to <a href="Quantum_depolarizing_channel" title="wikilink">depolarizing noise</a>. That is, 

<math display="inline" id="Noisy-storage_model:16">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">â„±</mi>
   <mo>=</mo>
   <msup>
    <mi class="ltx_font_mathcaligraphic">ğ’©</mi>
    <mrow>
     <mi></mi>
     <mo>âŠ—</mo>
     <mi>N</mi>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>â„±</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ğ’©</ci>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <csymbol cd="latexml">absent</csymbol>
      <ci>N</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{F}=\mathcal{N}^{\otimes N}
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Noisy-storage_model:17">
 <semantics>
  <mrow>
   <mrow>
    <mi class="ltx_font_mathcaligraphic">ğ’©</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>Ï</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>Î»</mi>
     <mi>Ï</mi>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mn>1</mn>
        <mo>-</mo>
        <mi>Î»</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>ğ—‚ğ–½</mi>
     </mrow>
     <mo>/</mo>
     <mn>2</mn>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>ğ’©</ci>
     <ci>Ï</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>Î»</ci>
      <ci>Ï</ci>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
        <ci>Î»</ci>
       </apply>
       <ci>ğ—‚ğ–½</ci>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{N}(\rho)=\lambda\rho+(1-\lambda)\mathsf{id}/2
  </annotation>
 </semantics>
</math>

 is the 2-dimensional <a href="Quantum_depolarizing_channel" title="wikilink">depolarizing channel</a>.</li>
</ul>
<ul>
<li>The storage device consists of 

<math display="inline" id="Noisy-storage_model:18">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>


 <a href="qubit" title="wikilink">qubits</a>, which are noise-free. This corresponds to the special case of <strong>bounded-quantum-storage</strong>. That is, 

<math display="inline" id="Noisy-storage_model:19">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">â„±</mi>
   <mo>=</mo>
   <msup>
    <mi>ğ—‚ğ–½</mi>
    <mrow>
     <mi></mi>
     <mo>âŠ—</mo>
     <mi>N</mi>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>â„±</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ğ—‚ğ–½</ci>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <csymbol cd="latexml">absent</csymbol>
      <ci>N</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{F}=\mathsf{id}^{\otimes N}
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Noisy-storage_model:20">
 <semantics>
  <mi>ğ—‚ğ–½</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ğ—‚ğ–½</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathsf{id}
  </annotation>
 </semantics>
</math>

 is the <a href="identity_channel" title="wikilink">identity channel</a>.</li>
</ul>
<h2 id="protocols">Protocols</h2>

<p>Most protocols proceed in two steps. First, Alice and Bob exchange 

<math display="inline" id="Noisy-storage_model:21">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 <a href="qubit" title="wikilink">qubits</a> encoded in two or three <a href="mutually_unbiased_bases" title="wikilink">mutually unbiased bases</a>. These are the same encodings which are used in the <a class="uri" href="BB84" title="wikilink">BB84</a> or six-state protocols of <a href="quantum_key_distribution" title="wikilink">quantum key distribution</a>. Typically, this takes the form of Alice sending such qubits to Bob, and Bob measuring them immediately on arrival. This has the advantage that Alice and Bob need no quantum storage to execute the protocol. It is furthermore experimentally relatively easy to create such <a class="uri" href="qubits" title="wikilink">qubits</a>, making it possible to implement such protocols using currently available technology.<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a></p>

<p>The second step is to perform classical post-processing of the measurement data obtained in step one. Techniques used depend on the protocol in question and include <a href="privacy_amplification" title="wikilink">privacy amplification</a>, <a href="error-correcting_codes" title="wikilink">error-correcting codes</a>, min-entropy sampling, and interactive hashing.</p>
<h3 id="general">General</h3>

<p>To demonstrate that all <a href="secure_function_evaluation" title="wikilink">two-party cryptographic tasks</a> can be implemented securely, a common approach is to show that a simple cryptographic primitive can be implemented that is known to be <em>universal</em> for <a href="secure_function_evaluation" title="wikilink">secure function evaluation</a>. That is, once one manages to build a protocol for such a cryptographic primitive all other tasks can be implemented by using this primitive as a basic building block. One such primitive is <a href="oblivious_transfer" title="wikilink">oblivious transfer</a>. In turn, <a href="oblivious_transfer" title="wikilink">oblivious transfer</a> can be constructed from an even simpler building block known as <a href="weak_string_erasure" title="wikilink">weak string erasure</a> in combination with cryptographic techniques such as <a href="privacy_amplification" title="wikilink">privacy amplification</a>.</p>

<p>All protocols proposed to date allow one of the parties (Alice) to have even an unlimited amount of noise-free quantum memory. I.e., the noisy-storage assumption is applied to only one of the parties (Bob). For storage devices of the form 

<math display="inline" id="Noisy-storage_model:22">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">â„±</mi>
   <mo>=</mo>
   <msup>
    <mi class="ltx_font_mathcaligraphic">ğ’©</mi>
    <mrow>
     <mi></mi>
     <mo>âŠ—</mo>
     <mi>N</mi>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>â„±</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ğ’©</ci>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <csymbol cd="latexml">absent</csymbol>
      <ci>N</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{F}=\mathcal{N}^{\otimes N}
  </annotation>
 </semantics>
</math>

 it is known that any <a href="secure_function_evaluation" title="wikilink">two-party cryptographic task</a> can be implemented securely by means of <a href="weak_string_erasure" title="wikilink">weak string erasure</a> and <a href="oblivious_transfer" title="wikilink">oblivious transfer</a> whenever any of the following conditions hold.</p>
<ul>
<li>For bounded-quantum-storage (i.e., 

<math display="inline" id="Noisy-storage_model:23">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">ğ’©</mi>
   <mo>=</mo>
   <mi>ğ—‚ğ–½</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>ğ’©</ci>
    <ci>ğ—‚ğ–½</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{N}=\mathsf{id}
  </annotation>
 </semantics>
</math>


), security can be achieved using a protocol in which Alice sends 

<math display="inline" id="Noisy-storage_model:24">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>></mo>
   <mrow>
    <mn>2</mn>
    <mi>N</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <ci>n</ci>
    <apply>
     <times></times>
     <cn type="integer">2</cn>
     <ci>N</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n>2N
  </annotation>
 </semantics>
</math>

 <a class="uri" href="BB84" title="wikilink">BB84</a> encoded <a href="qubit" title="wikilink">qubits</a>.<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a> That is, security can be achieved when Alice sends more than twice the number of qubits than Bob can store. One can also look at this from Bob's perspective and say that security can be achieved when Bob can store strictly less than half of the qubits that Alice sent, i.e., 

<math display="inline" id="Noisy-storage_model:25">
 <semantics>
  <mrow>
   <mi>N</mi>
   <mo><</mo>
   <mrow>
    <mi>n</mi>
    <mo>/</mo>
    <mn>2</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <ci>N</ci>
    <apply>
     <divide></divide>
     <ci>n</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N<n/2
  </annotation>
 </semantics>
</math>

.</li>
</ul>
<ul>
<li>For bounded-quantum-storage using higher-dimensional memory cells (i.e., each cell is not a <a class="uri" href="qubit" title="wikilink">qubit</a>, but a <a href="Qudit#Variations_of_the_qubit" title="wikilink">qudit</a>), security can be achieved in a protocol in which Alice sends 

<math display="inline" id="Noisy-storage_model:26">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 higher-dimensional qudits encoded one of the possible <a href="mutually_unbiased_bases" title="wikilink">mutually unbiased bases</a>. In the limit of large dimensions, security can be achieved whenever 

<math display="inline" id="Noisy-storage_model:27">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>âª†</mo>
   <mi>N</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">greater-than-or-approximately-equals</csymbol>
    <ci>n</ci>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n\gtrapprox N
  </annotation>
 </semantics>
</math>

. That is, security can always be achieved as long as Bob cannot store any constant fraction of the transmitted signals.<ref name="limits"></ref></li>
</ul>

<p> This is optimal for the protocols considered since for 

<math display="inline" id="Noisy-storage_model:28">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>=</mo>
   <mi>N</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>n</ci>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n=N
  </annotation>
 </semantics>
</math>


 a dishonest Bob can store all qudits sent by Alice. It is not known whether the same is possible using merely <a class="uri" href="BB84" title="wikilink">BB84</a> encoded qubits.</p>
<ul>
<li>For noisy-storage and devices of the form 

<math display="inline" id="Noisy-storage_model:29">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">â„±</mi>
   <mo>=</mo>
   <msup>
    <mi class="ltx_font_mathcaligraphic">ğ’©</mi>
    <mrow>
     <mi></mi>
     <mo>âŠ—</mo>
     <mi>N</mi>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>â„±</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ğ’©</ci>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <csymbol cd="latexml">absent</csymbol>
      <ci>N</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{F}=\mathcal{N}^{\otimes N}
  </annotation>
 </semantics>
</math>

 security can be achieved using a protocol in which Alice sends 

<math display="inline" id="Noisy-storage_model:30">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 <a class="uri" href="BB84" title="wikilink">BB84</a> encoded <a class="uri" href="qubits" title="wikilink">qubits</a> if</li>
</ul>

<p>:* 

<math display="inline" id="Noisy-storage_model:31">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>></mo>
   <mrow>
    <mrow>
     <mn>2</mn>
     <mo>â‹…</mo>
     <mi>N</mi>
     <mo>â‹…</mo>
     <mi>C</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi class="ltx_font_mathcaligraphic">ğ’©</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <ci>n</ci>
    <apply>
     <times></times>
     <apply>
      <ci>normal-â‹…</ci>
      <cn type="integer">2</cn>
      <ci>N</ci>
      <ci>C</ci>
     </apply>
     <ci>ğ’©</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n>2\cdot N\cdot C(\mathcal{N})
  </annotation>
 </semantics>
</math>

,<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a> where 

<math display="inline" id="Noisy-storage_model:32">
 <semantics>
  <mrow>
   <mi>C</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi class="ltx_font_mathcaligraphic">ğ’©</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>C</ci>
    <ci>ğ’©</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C(\mathcal{N})
  </annotation>
 </semantics>
</math>

 is the <a href="classical_capacity" title="wikilink">classical capacity</a> of the <a href="quantum_channel" title="wikilink">quantum channel</a> 

<math display="inline" id="Noisy-storage_model:33">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ğ’©</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ğ’©</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{N}
  </annotation>
 </semantics>
</math>


, and 

<math display="inline" id="Noisy-storage_model:34">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ğ’©</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ğ’©</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{N}
  </annotation>
 </semantics>
</math>

 obeys the so-called <em>strong converse property</em>,<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a> or, if</p>

<p>:* 

<math display="inline" id="Noisy-storage_model:35">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>></mo>
   <mrow>
    <mrow>
     <mn>2</mn>
     <mo>â‹…</mo>
     <mi>N</mi>
     <mo>â‹…</mo>
     <msub>
      <mi>E</mi>
      <mi>C</mi>
     </msub>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi class="ltx_font_mathcaligraphic">ğ’©</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <ci>n</ci>
    <apply>
     <times></times>
     <apply>
      <ci>normal-â‹…</ci>
      <cn type="integer">2</cn>
      <ci>N</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>E</ci>
       <ci>C</ci>
      </apply>
     </apply>
     <ci>ğ’©</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n>2\cdot N\cdot E_{C}(\mathcal{N})
  </annotation>
 </semantics>
</math>

,<a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a> where 

<math display="inline" id="Noisy-storage_model:36">
 <semantics>
  <mrow>
   <msub>
    <mi>E</mi>
    <mi>C</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi class="ltx_font_mathcaligraphic">ğ’©</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>E</ci>
     <ci>C</ci>
    </apply>
    <ci>ğ’©</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E_{C}(\mathcal{N})
  </annotation>
 </semantics>
</math>

 is the <a href="entanglement_cost" title="wikilink">entanglement cost</a> of the <a href="quantum_channel" title="wikilink">quantum channel</a> 

<math display="inline" id="Noisy-storage_model:37">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ğ’©</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ğ’©</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{N}
  </annotation>
 </semantics>
</math>

. This is generally much better than the condition on the <a href="classical_capacity" title="wikilink">classical capacity</a>, however it is harder to evaluate 

<math display="inline" id="Noisy-storage_model:38">
 <semantics>
  <mrow>
   <msub>
    <mi>E</mi>
    <mi>C</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi class="ltx_font_mathcaligraphic">ğ’©</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>E</ci>
     <ci>C</ci>
    </apply>
    <ci>ğ’©</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E_{C}(\mathcal{N})
  </annotation>
 </semantics>
</math>


.</p>
<ul>
<li>For noisy-storage and devices of the form 

<math display="inline" id="Noisy-storage_model:39">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">â„±</mi>
   <mo>=</mo>
   <msup>
    <mi class="ltx_font_mathcaligraphic">ğ’©</mi>
    <mrow>
     <mi></mi>
     <mo>âŠ—</mo>
     <mi>N</mi>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>â„±</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ğ’©</ci>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <csymbol cd="latexml">absent</csymbol>
      <ci>N</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{F}=\mathcal{N}^{\otimes N}
  </annotation>
 </semantics>
</math>

 security can be achieved using a protocol in which Alice sends 

<math display="inline" id="Noisy-storage_model:40">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 <a href="qubit" title="wikilink">qubits</a> encoded in one of the three <a href="mutually_unbiased_bases" title="wikilink">mutually unbiased bases</a> per qubit, if</li>
</ul>

<p>:* 

<math display="inline" id="Noisy-storage_model:41">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>></mo>
   <mrow>
    <mi>Q</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi class="ltx_font_mathcaligraphic">ğ’©</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>N</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <ci>n</ci>
    <apply>
     <times></times>
     <ci>Q</ci>
     <ci>ğ’©</ci>
     <ci>N</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n>Q(\mathcal{N})N
  </annotation>
 </semantics>
</math>

,<a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a> where 

<math display="inline" id="Noisy-storage_model:42">
 <semantics>
  <mi>Q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q
  </annotation>
 </semantics>
</math>

 is the <a href="quantum_capacity" title="wikilink">quantum capacity</a> of 

<math display="inline" id="Noisy-storage_model:43">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ğ’©</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ğ’©</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{N}
  </annotation>
 </semantics>
</math>


, and the strong converse parameter of 

<math display="inline" id="Noisy-storage_model:44">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ğ’©</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ğ’©</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{N}
  </annotation>
 </semantics>
</math>

 is not too small.</p>

<p>The three <a href="mutually_unbiased_bases" title="wikilink">mutually unbiased bases</a> are the same encodings as in the six-state protocol of <a href="quantum_key_distribution" title="wikilink">quantum key distribution</a>. The last condition does form the best known condition for most channels, yet the <a href="quantum_capacity" title="wikilink">quantum capacity</a> as well as the strong converse parameter are generally not easy to determine.</p>
<h3 id="specific-tasks">Specific tasks</h3>

<p>Using such basic primitives as building blocks is not always the most efficient way to solve a cryptographic task. Specialized protocols targeted to solve specific problems are generally more efficient. Examples of known protocols are</p>
<ul>
<li><a href="Bit_commitment" title="wikilink">Bit commitment</a> in the noisy-storage model,<a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a><a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a> and in the case of bounded-quantum-storage<a class="footnoteRef" href="#fn23" id="fnref23"><sup>23</sup></a></li>
</ul>
<ul>
<li><a href="Oblivious_transfer" title="wikilink">Oblivious transfer</a> in the noisy-storage model,<a class="footnoteRef" href="#fn24" id="fnref24"><sup>24</sup></a> and in the case of bounded-quantum-storage<a class="footnoteRef" href="#fn25" id="fnref25"><sup>25</sup></a><a class="footnoteRef" href="#fn26" id="fnref26"><sup>26</sup></a></li>
</ul>
<ul>
<li><a href="Smart_Card#Applications" title="wikilink">Secure identification</a> in the bounded-quantum-storage model<ref name="secureid"></ref></li>
</ul>

<p><a class="footnoteRef" href="#fn27" id="fnref27"><sup>27</sup></a></p>
<h2 id="noisy-storage-and-qkd">Noisy-storage and QKD</h2>

<p>The assumption of bounded-quantum-storage has also been applied outside the realm of <a href="secure_function_evaluation" title="wikilink">secure function evaluation</a>. In particular, it has been shown that if the eavesdropper in <a href="quantum_key_distribution" title="wikilink">quantum key distribution</a> is memory bounded, higher bit error rates can be tolerated in an experimental implementation.<a class="footnoteRef" href="#fn28" id="fnref28"><sup>28</sup></a></p>
<h2 id="references">References</h2>

<p>"</p>

<p><a href="Category:Quantum_cryptography" title="wikilink">Category:Quantum cryptography</a> <a class="uri" href="Category:Cryptography" title="wikilink">Category:Cryptography</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">â†©</a></li>
<li id="fn2"><a href="#fnref2">â†©</a></li>
<li id="fn3"><a href="#fnref3">â†©</a></li>
<li id="fn4"><a href="#fnref4">â†©</a></li>
<li id="fn5"><a href="#fnref5">â†©</a></li>
<li id="fn6"><a href="#fnref6">â†©</a></li>
<li id="fn7"><a href="#fnref7">â†©</a></li>
<li id="fn8"><a href="#fnref8">â†©</a></li>
<li id="fn9"><a href="#fnref9">â†©</a></li>
<li id="fn10"></li>
<li id="fn11"><a href="#fnref11">â†©</a></li>
<li id="fn12"></li>
<li id="fn13"><a href="#fnref13">â†©</a></li>
<li id="fn14"></li>
<li id="fn15"><a href="#fnref15">â†©</a></li>
<li id="fn16"></li>
<li id="fn17"></li>
<li id="fn18"><a href="#fnref18">â†©</a></li>
<li id="fn19"><a href="#fnref19">â†©</a></li>
<li id="fn20"><a href="#fnref20">â†©</a></li>
<li id="fn21"></li>
<li id="fn22"></li>
<li id="fn23"></li>
<li id="fn24"></li>
<li id="fn25"></li>
<li id="fn26"></li>
<li id="fn27"><a href="#fnref27">â†©</a></li>
<li id="fn28"></li>
</ol>
</section>
</body>
</html>
