<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1618">Simple rational approximation</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Simple rational approximation</h1>
<hr/>

<p><strong>Simple rational approximation (SRA)</strong> is a subset of <a href="Interpolation" title="wikilink">interpolating</a> methods using <a href="rational_function" title="wikilink">rational functions</a>. Especially, SRA interpolates a given function with a specific rational function whose <a href="pole_(complex_analysis)" title="wikilink">poles</a> and <a href="root_of_a_function" title="wikilink">zeros</a> are simple, which means that there is no multiplicity in poles and zeros. Sometimes, it only implies simple poles.</p>

<p>The main application of SRA lies in finding the <a href="root_of_a_function" title="wikilink">zeros</a> of <a href="secular_function" title="wikilink">secular functions</a>. A <a href="divide-and-conquer_algorithm" title="wikilink">divide-and-conquer algorithm</a> to find the <a class="uri" href="eigenvalues" title="wikilink">eigenvalues</a> and <a class="uri" href="eigenvectors" title="wikilink">eigenvectors</a> for various kinds of <a href="Matrix_(mathematics)" title="wikilink">matrices</a> is well known in <a href="numerical_analysis" title="wikilink">numerical analysis</a>. In a strict sense, SRA implies a specific <a class="uri" href="interpolation" title="wikilink">interpolation</a> using simple rational functions as a part of the divide-and-conquer algorithm. Since such secular functions consist of a series of rational functions with simple poles, SRA is the best candidate to interpolate the zeros of the secular function. Moreover, based on previous researches, a simple zero that lies between two adjacent poles can be considerably well interpolated by using a two-dominant-pole rational function as an approximating function.</p>
<h2 id="one-point-third-order-iterative-method-halleys-formula">One-point third-order iterative method: Halley's formula</h2>

<p>The origin of the interpolation with rational functions can be found in the previous work done by <a href="Edmond_Halley" title="wikilink">Edmond Halley</a>. <a href="Halley's_method" title="wikilink">Halley's formula</a> is known as one-point third-order iterative method to solve 

<math display="inline" id="Simple_rational_approximation:0">
 <semantics>
  <mrow>
   <mrow>
    <mpadded lspace="1.7pt" width="+1.7pt">
     <mi>f</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>x</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \,f(x)=0
  </annotation>
 </semantics>
</math>


 by means of approximating a rational function defined by</p>

<p>

<math display="block" id="Simple_rational_approximation:1">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>h</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>z</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mfrac>
      <mi>a</mi>
      <mrow>
       <mi>z</mi>
       <mo>+</mo>
       <mi>b</mi>
      </mrow>
     </mfrac>
     <mo>+</mo>
     <mi>c</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>h</ci>
     <ci>z</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <divide></divide>
      <ci>a</ci>
      <apply>
       <plus></plus>
       <ci>z</ci>
       <ci>b</ci>
      </apply>
     </apply>
     <ci>c</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h(z)=\frac{a}{z+b}+c.
  </annotation>
 </semantics>
</math>

 We can determine a, b, and c so that</p>

<p>

<math display="block" id="Simple_rational_approximation:2">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msup>
      <mi>h</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>i</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msup>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>i</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo rspace="22.5pt">,</mo>
   <mrow>
    <mi>i</mi>
    <mo>=</mo>
    <mrow>
     <mn>0</mn>
     <mo>,</mo>
     <mn>1</mn>
     <mo>,</mo>
     <mn>2.</mn>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>h</ci>
       <ci>i</ci>
      </apply>
      <ci>x</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>f</ci>
       <ci>i</ci>
      </apply>
      <ci>x</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <ci>i</ci>
     <list>
      <cn type="integer">0</cn>
      <cn type="integer">1</cn>
      <cn type="float">2.</cn>
     </list>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h^{(i)}(x)=f^{(i)}(x),\qquad i=0,1,2.
  </annotation>
 </semantics>
</math>

 Then solving 

<math display="inline" id="Simple_rational_approximation:3">
 <semantics>
  <mrow>
   <mrow>
    <mpadded lspace="1.7pt" width="+1.7pt">
     <mi>h</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>h</ci>
     <ci>z</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \,h(z)=0
  </annotation>
 </semantics>
</math>

 yields the iteration</p>

<p>

<math display="block" id="Simple_rational_approximation:4">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>x</mi>
     <mrow>
      <mi>n</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>x</mi>
      <mi>n</mi>
     </msub>
     <mo>-</mo>
     <mrow>
      <mfrac>
       <mrow>
        <mi>f</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>x</mi>
          <mi>n</mi>
         </msub>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mrow>
        <msup>
         <mi>f</mi>
         <mo>′</mo>
        </msup>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>x</mi>
          <mi>n</mi>
         </msub>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mfrac>
      <mrow>
       <mo>(</mo>
       <mfrac>
        <mn>1</mn>
        <mrow>
         <mn>1</mn>
         <mo>-</mo>
         <mfrac>
          <mrow>
           <mi>f</mi>
           <mrow>
            <mo stretchy="false">(</mo>
            <msub>
             <mi>x</mi>
             <mi>n</mi>
            </msub>
            <mo stretchy="false">)</mo>
           </mrow>
           <msup>
            <mi>f</mi>
            <mi>′′</mi>
           </msup>
           <mrow>
            <mo stretchy="false">(</mo>
            <msub>
             <mi>x</mi>
             <mi>n</mi>
            </msub>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
          <mrow>
           <mn>2</mn>
           <msup>
            <mrow>
             <mo stretchy="false">(</mo>
             <mrow>
              <msup>
               <mi>f</mi>
               <mo>′</mo>
              </msup>
              <mrow>
               <mo stretchy="false">(</mo>
               <msub>
                <mi>x</mi>
                <mi>n</mi>
               </msub>
               <mo stretchy="false">)</mo>
              </mrow>
             </mrow>
             <mo stretchy="false">)</mo>
            </mrow>
            <mn>2</mn>
           </msup>
          </mrow>
         </mfrac>
        </mrow>
       </mfrac>
       <mo>)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <apply>
      <plus></plus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <ci>f</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>n</ci>
        </apply>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>f</ci>
         <ci>normal-′</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>n</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
        <apply>
         <divide></divide>
         <apply>
          <times></times>
          <ci>f</ci>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>x</ci>
           <ci>n</ci>
          </apply>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>f</ci>
           <ci>′′</ci>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>x</ci>
           <ci>n</ci>
          </apply>
         </apply>
         <apply>
          <times></times>
          <cn type="integer">2</cn>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <apply>
            <times></times>
            <apply>
             <csymbol cd="ambiguous">superscript</csymbol>
             <ci>f</ci>
             <ci>normal-′</ci>
            </apply>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <ci>x</ci>
             <ci>n</ci>
            </apply>
           </apply>
           <cn type="integer">2</cn>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{n+1}=x_{n}-\frac{f(x_{n})}{f^{\prime}(x_{n})}\left({\frac{1}{1-\frac{f(x_{n%
})f^{\prime\prime}(x_{n})}{2(f^{\prime}(x_{n}))^{2}}}}\right).
  </annotation>
 </semantics>
</math>

 This is referred to as Halley's formula. This <em>geometrical interpretation</em> 

<math display="inline" id="Simple_rational_approximation:5">
 <semantics>
  <mrow>
   <mi>h</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>z</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>h</ci>
    <ci>z</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h(z)
  </annotation>
 </semantics>
</math>


 was derived by Gander(1978), where the equivalent iteration also was derived by applying Newton's method to</p>

<p>

<math display="block" id="Simple_rational_approximation:6">
 <semantics>
  <mrow>
   <mrow>
    <mi>g</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <msqrt>
     <mrow>
      <msup>
       <mi>f</mi>
       <mo>′</mo>
      </msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </msqrt>
   </mfrac>
   <mo>=</mo>
   <mn>0.</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>g</ci>
      <ci>x</ci>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <ci>f</ci>
       <ci>x</ci>
      </apply>
      <apply>
       <root></root>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>f</ci>
         <ci>normal-′</ci>
        </apply>
        <ci>x</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="float">0.</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g(x)=\frac{f(x)}{\sqrt{f^{\prime}(x)}}=0.
  </annotation>
 </semantics>
</math>

 We call this <em>algebraic interpretation</em> 

<math display="inline" id="Simple_rational_approximation:7">
 <semantics>
  <mrow>
   <mi>g</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>g</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g(x)
  </annotation>
 </semantics>
</math>

 of Halley's formula.</p>
<h2 id="one-point-second-order-iterative-method-simple-rational-approximation">One-point second-order iterative method: Simple rational approximation</h2>

<p>Similarly, we can derive a variation of Halley's formula based on a one-point <em>second-order</em> iterative method to solve 

<math display="inline" id="Simple_rational_approximation:8">
 <semantics>
  <mrow>
   <mrow>
    <mpadded lspace="1.7pt" width="+1.7pt">
     <mi>f</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>α</mi>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi></mi>
      <mo>≠</mo>
      <mn>0</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <ci>α</ci>
     <apply>
      <neq></neq>
      <csymbol cd="latexml">absent</csymbol>
      <cn type="integer">0</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \,f(x)=\alpha(\neq 0)
  </annotation>
 </semantics>
</math>

 using simple rational approximation by</p>

<p>

<math display="block" id="Simple_rational_approximation:9">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>h</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>z</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mfrac>
     <mi>a</mi>
     <mrow>
      <mi>z</mi>
      <mo>+</mo>
      <mi>b</mi>
     </mrow>
    </mfrac>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>h</ci>
     <ci>z</ci>
    </apply>
    <apply>
     <divide></divide>
     <ci>a</ci>
     <apply>
      <plus></plus>
      <ci>z</ci>
      <ci>b</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h(z)=\frac{a}{z+b}.
  </annotation>
 </semantics>
</math>

 Then we need to evaluate</p>

<p>

<math display="block" id="Simple_rational_approximation:10">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msup>
      <mi>h</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>i</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msup>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>i</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo rspace="22.5pt">,</mo>
   <mrow>
    <mi>i</mi>
    <mo>=</mo>
    <mrow>
     <mn>0</mn>
     <mo>,</mo>
     <mn>1.</mn>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>h</ci>
       <ci>i</ci>
      </apply>
      <ci>x</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>f</ci>
       <ci>i</ci>
      </apply>
      <ci>x</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <ci>i</ci>
     <list>
      <cn type="integer">0</cn>
      <cn type="float">1.</cn>
     </list>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h^{(i)}(x)=f^{(i)}(x),\qquad i=0,1.
  </annotation>
 </semantics>
</math>

 Thus we have</p>

<p>

<math display="block" id="Simple_rational_approximation:11">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>x</mi>
     <mrow>
      <mi>n</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>x</mi>
      <mi>n</mi>
     </msub>
     <mo>-</mo>
     <mrow>
      <mfrac>
       <mrow>
        <mrow>
         <mi>f</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <msub>
           <mi>x</mi>
           <mi>n</mi>
          </msub>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>-</mo>
        <mi>α</mi>
       </mrow>
       <mrow>
        <msup>
         <mi>f</mi>
         <mo>′</mo>
        </msup>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>x</mi>
          <mi>n</mi>
         </msub>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mfrac>
      <mrow>
       <mo>(</mo>
       <mfrac>
        <mrow>
         <mi>f</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <msub>
           <mi>x</mi>
           <mi>n</mi>
          </msub>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mi>α</mi>
       </mfrac>
       <mo>)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <apply>
      <plus></plus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <ci>f</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <ci>n</ci>
         </apply>
        </apply>
        <ci>α</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>f</ci>
         <ci>normal-′</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>n</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <ci>f</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>n</ci>
        </apply>
       </apply>
       <ci>α</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{n+1}=x_{n}-\frac{f(x_{n})-\alpha}{f^{\prime}(x_{n})}\left(\frac{f(x_{n})}{%
\alpha}\right).
  </annotation>
 </semantics>
</math>

 The algebraic interpretation of this iteration is obtained by solving</p>

<p>

<math display="block" id="Simple_rational_approximation:12">
 <semantics>
  <mrow>
   <mrow>
    <mi>g</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mo>-</mo>
    <mfrac>
     <mi>α</mi>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mfrac>
   </mrow>
   <mo>=</mo>
   <mn>0.</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>g</ci>
      <ci>x</ci>
     </apply>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
      <apply>
       <divide></divide>
       <ci>α</ci>
       <apply>
        <times></times>
        <ci>f</ci>
        <ci>x</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="float">0.</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g(x)=1-\frac{\alpha}{{f(x)}}=0.
  </annotation>
 </semantics>
</math>

 This one-point second-order method is known to show a locally quadratic convergence if the root of equation is simple. SRA strictly implies this one-point second-order interpolation by a simple rational function.</p>

<p>We can notice that even third order method is a variation of Newton's method. We see the Newton's steps are multiplied by some factors. These factors are called the <em>convergence factors</em> of the variations, which are useful for analyzing the rate of convergence. See Gander(1978).</p>
<h2 id="references">References</h2>
<ul>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
</ul>

<p>"</p>

<p><a class="uri" href="Category:Interpolation" title="wikilink">Category:Interpolation</a></p>
</body>
</html>
