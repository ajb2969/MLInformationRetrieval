<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="362">Push–relabel maximum flow algorithm</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Push–relabel maximum flow algorithm</h1>
<style>
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
<style>
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
</body></html>
<body>
<hr/>

<p>In <a href="mathematical_optimization" title="wikilink">mathematical optimization</a>, the <strong>push–relabel algorithm</strong> (alternatively, <strong>preflow–push algorithm</strong>) is an algorithm for computing <a href="maximum_flow" title="wikilink">maximum flows</a>. The name "push–relabel" comes from the two basic operations used in the algorithm. Throughout its execution, the algorithm maintains a "preflow" and gradually converts it into a maximum flow by moving flow locally between neighboring vertices using <em>push</em> operations under the guidance of an admissible network maintained by <em>relabel</em> operations. In comparison, the <a href="Ford–Fulkerson_algorithm" title="wikilink">Ford–Fulkerson algorithm</a> performs global augmentations that send flow following paths from the source all the way to the sink.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>

<p>The push–relabel algorithm is considered one of the most efficient maximum flow algorithms. The generic algorithm has a <a href="strongly_polynomial" title="wikilink">strongly polynomial</a> <mtpl></mtpl> time complexity, which is asymptotically more efficient than the <mtpl></mtpl> <a href="Edmonds–Karp_algorithm" title="wikilink">Edmonds–Karp algorithm</a>.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> Specific variants of the algorithms achieve even lower time complexities. The variant based on the highest label vertex selection rule has <mtpl></mtpl> time complexity and is generally regarded as the benchmark for maximum flow algorithms.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a><a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> Subcubic <mtpl></mtpl> time complexity can be achieved using <a href="Link-cut_tree" title="wikilink">dynamic trees</a>, although in practice it is less efficient.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>

<p>The push–relabel algorithm has been extended to compute <a href="minimum_cost_flow" title="wikilink">minimum cost flows</a>.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> The idea of distance labels has led to a more efficient augmenting path algorithm, which in turn can be incorporated back into the push–relabel algorithm to create a variant with even higher empirical performance.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a><a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></p>
<h2 id="history">History</h2>

<p>The concept of a preflow was originally designed by Alexander V. Karzanov and was published in 1974 in Soviet Mathematical Dokladi 15. This preflow algorithm also used a push operation; however, it used distances in the auxiliary network to determine where to push the flow instead of a labeling system.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a><a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a></p>

<p>The push-relabel algorithm was designed by <a href="Andrew_V._Goldberg" title="wikilink">Andrew V. Goldberg</a> and <a href="Robert_Tarjan" title="wikilink">Robert Tarjan</a>. The algorithm was initially present in November 1986 in STOC '86: Proceedings of the eighteenth annual ACM symposium on Theory of computing, and then officially in October 1988 as an article in the Journal of the ACM. Both papers detail a generic form of the algorithm terminating in <mtpl></mtpl> along with a <mtpl></mtpl> sequential implementation, a <mtpl></mtpl> implementation using dynamic trees, and parallel/distributed implementation.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a><a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a></p>
<h2 id="concepts">Concepts</h2>
<h3 id="definitions-and-notations">Definitions and notations</h3>

<p>Consider a flow network 

<math display="inline" id="Push–relabel_maximum_flow_algorithm:0">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>V</mi>
    <mo>,</mo>
    <mi>E</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>G</ci>
    <interval closure="open">
     <ci>V</ci>
     <ci>E</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G=(V,E)
  </annotation>
 </semantics>
</math>

 with a pair of distinct vertices 

<math display="inline" id="Push–relabel_maximum_flow_algorithm:1">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Push–relabel_maximum_flow_algorithm:2">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 designated as the source and the sink, respectively. The 

<math display="inline" id="Push–relabel_maximum_flow_algorithm:3">
 <semantics>
  <mrow>
   <mrow>
    <mi>c</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>u</mi>
     <mo>,</mo>
     <mi>v</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≥</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <times></times>
     <ci>c</ci>
     <interval closure="open">
      <ci>u</ci>
      <ci>v</ci>
     </interval>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c(u,v)\geq 0
  </annotation>
 </semantics>
</math>

 relation denotes the capacity of each edge 

<math display="inline" id="Push–relabel_maximum_flow_algorithm:4">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>u</mi>
    <mo>,</mo>
    <mi>v</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∈</mo>
   <mi>E</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <interval closure="open">
     <ci>u</ci>
     <ci>v</ci>
    </interval>
    <ci>E</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (u,v)\in E
  </annotation>
 </semantics>
</math>

. If 

<math display="inline" id="Push–relabel_maximum_flow_algorithm:5">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>u</mi>
    <mo>,</mo>
    <mi>v</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∉</mo>
   <mi>E</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <notin></notin>
    <interval closure="open">
     <ci>u</ci>
     <ci>v</ci>
    </interval>
    <ci>E</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (u,v)\notin E
  </annotation>
 </semantics>
</math>

, then we assume that 

<math display="inline" id="Push–relabel_maximum_flow_algorithm:6">
 <semantics>
  <mrow>
   <mrow>
    <mi>c</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>u</mi>
     <mo>,</mo>
     <mi>v</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>c</ci>
     <interval closure="open">
      <ci>u</ci>
      <ci>v</ci>
     </interval>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c(u,v)=0
  </annotation>
 </semantics>
</math>

. A flow on 

<math display="inline" id="Push–relabel_maximum_flow_algorithm:7">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

 is a function <a href="real_number" title="wikilink">real</a> <a href="function_(mathematics)" title="wikilink">function</a> 

<math display="inline" id="Push–relabel_maximum_flow_algorithm:8">
 <semantics>
  <mrow>
   <mpadded lspace="5pt" width="+5pt">
    <mi>f</mi>
   </mpadded>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mi>V</mi>
     <mo>×</mo>
     <mi>V</mi>
    </mrow>
    <mo>→</mo>
    <mi>ℝ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>f</ci>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <times></times>
      <ci>V</ci>
      <ci>V</ci>
     </apply>
     <ci>ℝ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ f:V\times V\rightarrow\mathbb{R}
  </annotation>
 </semantics>
</math>

 satisfying the following conditions:</p>
<dl>
<dd>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p><strong>Capacity constraints</strong>:</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Push–relabel_maximum_flow_algorithm:9">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mpadded lspace="5pt" width="+5pt">
      <mi>f</mi>
     </mpadded>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>u</mi>
      <mo>,</mo>
      <mi>v</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>≤</mo>
    <mrow>
     <mrow>
      <mi>c</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>u</mi>
       <mo>,</mo>
       <mi>v</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo rspace="12.5pt">,</mo>
     <mrow>
      <mo>∀</mo>
      <mi>u</mi>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>v</mi>
    <mo>∈</mo>
    <mi>V</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <leq></leq>
     <apply>
      <times></times>
      <ci>f</ci>
      <interval closure="open">
       <ci>u</ci>
       <ci>v</ci>
      </interval>
     </apply>
     <list>
      <apply>
       <times></times>
       <ci>c</ci>
       <interval closure="open">
        <ci>u</ci>
        <ci>v</ci>
       </interval>
      </apply>
      <apply>
       <csymbol cd="latexml">for-all</csymbol>
       <ci>u</ci>
      </apply>
     </list>
    </apply>
    <apply>
     <in></in>
     <ci>v</ci>
     <ci>V</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ f(u,v)\leq c(u,v),\quad\forall u,v\in V
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><strong>Skew symmetry</strong>:</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Push–relabel_maximum_flow_algorithm:10">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mpadded lspace="5pt" width="+5pt">
      <mi>f</mi>
     </mpadded>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>u</mi>
      <mo>,</mo>
      <mi>v</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mo>-</mo>
      <mrow>
       <mi>f</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>v</mi>
        <mo>,</mo>
        <mi>u</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo rspace="12.5pt">,</mo>
     <mrow>
      <mo>∀</mo>
      <mi>u</mi>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>v</mi>
    <mo>∈</mo>
    <mi>V</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>f</ci>
      <interval closure="open">
       <ci>u</ci>
       <ci>v</ci>
      </interval>
     </apply>
     <list>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <ci>f</ci>
        <interval closure="open">
         <ci>v</ci>
         <ci>u</ci>
        </interval>
       </apply>
      </apply>
      <apply>
       <csymbol cd="latexml">for-all</csymbol>
       <ci>u</ci>
      </apply>
     </list>
    </apply>
    <apply>
     <in></in>
     <ci>v</ci>
     <ci>V</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ f(u,v)=-f(v,u),\quad\forall u,v\in V
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><strong>Flow conservation</strong>:</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Push–relabel_maximum_flow_algorithm:11">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mo largeop="true" lspace="7.5pt" symmetric="true">∑</mo>
      <mrow>
       <mi>v</mi>
       <mo>∈</mo>
       <mi>V</mi>
      </mrow>
     </msub>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>u</mi>
       <mo>,</mo>
       <mi>v</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mn>0</mn>
   </mrow>
   <mo rspace="12.5pt">,</mo>
   <mrow>
    <mrow>
     <mo>∀</mo>
     <mi>u</mi>
    </mrow>
    <mo>∈</mo>
    <mrow>
     <mi>V</mi>
     <mo>-</mo>
     <mrow>
      <mo stretchy="false">{</mo>
      <mi>s</mi>
      <mo>,</mo>
      <mi>t</mi>
      <mo stretchy="false">}</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <in></in>
        <ci>v</ci>
        <ci>V</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>f</ci>
       <interval closure="open">
        <ci>u</ci>
        <ci>v</ci>
       </interval>
      </apply>
     </apply>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <in></in>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <ci>u</ci>
     </apply>
     <apply>
      <minus></minus>
      <ci>V</ci>
      <set>
       <ci>s</ci>
       <ci>t</ci>
      </set>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ \sum_{v\in V}f(u,v)=0,\quad\forall u\in V-\{s,t\}
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
</tbody>
</table>
</dd>
</dl>

<p>The push–relabel algorithm introduces the concept of <em>preflows</em>. A preflow is a function with a definition almost identical to that of a flow except that it relaxes the flow conservation condition. Instead of requiring strict flow balance at vertices other than <em>s</em> and <em>t</em>, it allows them to carry positive excesses. This means that in a preflow the total flow into a vertex can exceed the flow out of the vertex. Put symbolically:</p>
<dl>
<dd>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p><strong>Non-Negative constraint</strong>:</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Push–relabel_maximum_flow_algorithm:12">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <munder>
      <mo largeop="true" lspace="7.5pt" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>u</mi>
       <mo>∈</mo>
       <mi>V</mi>
      </mrow>
     </munder>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>u</mi>
       <mo>,</mo>
       <mi>v</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>≥</mo>
    <mn>0</mn>
   </mrow>
   <mo rspace="12.5pt">,</mo>
   <mrow>
    <mrow>
     <mo>∀</mo>
     <mi>v</mi>
    </mrow>
    <mo>∈</mo>
    <mrow>
     <mi>V</mi>
     <mo>-</mo>
     <mrow>
      <mo stretchy="false">{</mo>
      <mi>s</mi>
      <mo stretchy="false">}</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <geq></geq>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <in></in>
        <ci>u</ci>
        <ci>V</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>f</ci>
       <interval closure="open">
        <ci>u</ci>
        <ci>v</ci>
       </interval>
      </apply>
     </apply>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <in></in>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <ci>v</ci>
     </apply>
     <apply>
      <minus></minus>
      <ci>V</ci>
      <set>
       <ci>s</ci>
      </set>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ \sum\limits_{u\in V}f(u,v)\geq 0,\quad\forall v\in V-\{s\}
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><strong>Flow Excess</strong>:</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Push–relabel_maximum_flow_algorithm:13">
 <semantics>
  <mrow>
   <mrow>
    <mi>e</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>v</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>{</mo>
    <mtable>
     <mtr>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mrow>
          <munder>
           <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
           <mrow>
            <mi>u</mi>
            <mo>∈</mo>
            <mi>V</mi>
           </mrow>
          </munder>
          <mrow>
           <mi>f</mi>
           <mrow>
            <mo stretchy="false">(</mo>
            <mi>u</mi>
            <mo>,</mo>
            <mi>v</mi>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
         </mrow>
         <mo rspace="12.5pt">,</mo>
         <mrow>
          <mo>∀</mo>
          <mi>v</mi>
         </mrow>
        </mrow>
        <mo>∈</mo>
        <mrow>
         <mi>V</mi>
         <mo>-</mo>
         <mrow>
          <mo stretchy="false">{</mo>
          <mi>s</mi>
          <mo stretchy="false">}</mo>
         </mrow>
        </mrow>
       </mrow>
      </mtd>
      <mtd></mtd>
     </mtr>
     <mtr>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mi mathvariant="normal">∞</mi>
         <mo rspace="12.5pt">,</mo>
         <mi>v</mi>
        </mrow>
        <mo>=</mo>
        <mi>s</mi>
       </mrow>
      </mtd>
      <mtd></mtd>
     </mtr>
    </mtable>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>e</ci>
     <ci>v</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">cases</csymbol>
     <apply>
      <in></in>
      <list>
       <apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <in></in>
          <ci>u</ci>
          <ci>V</ci>
         </apply>
        </apply>
        <apply>
         <times></times>
         <ci>f</ci>
         <interval closure="open">
          <ci>u</ci>
          <ci>v</ci>
         </interval>
        </apply>
       </apply>
       <apply>
        <csymbol cd="latexml">for-all</csymbol>
        <ci>v</ci>
       </apply>
      </list>
      <apply>
       <minus></minus>
       <ci>V</ci>
       <set>
        <ci>s</ci>
       </set>
      </apply>
     </apply>
     <mtext>otherwise</mtext>
     <apply>
      <eq></eq>
      <list>
       <infinity></infinity>
       <ci>v</ci>
      </list>
      <ci>s</ci>
     </apply>
     <mtext>otherwise</mtext>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e(v)=\begin{cases}\sum\limits_{u\in V}f(u,v),\quad\forall v\in V-\{s\}\\
\infty,\quad v=s\end{cases}
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
</tbody>
</table>
</dd>
</dl>

<p>A vertex 

<math display="inline" id="Push–relabel_maximum_flow_algorithm:14">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>

 is called <em>active</em> if 

<math display="inline" id="Push–relabel_maximum_flow_algorithm:15">
 <semantics>
  <mrow>
   <mrow>
    <mi>e</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>v</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>></mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <apply>
     <times></times>
     <ci>e</ci>
     <ci>v</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e(v)>0
  </annotation>
 </semantics>
</math>

 for 

<math display="inline" id="Push–relabel_maximum_flow_algorithm:16">
 <semantics>
  <mrow>
   <mi>v</mi>
   <mo>∈</mo>
   <mrow>
    <mi>V</mi>
    <mo>-</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mi>s</mi>
     <mo>,</mo>
     <mi>t</mi>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>v</ci>
    <apply>
     <minus></minus>
     <ci>V</ci>
     <set>
      <ci>s</ci>
      <ci>t</ci>
     </set>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v\in V-\{s,t\}
  </annotation>
 </semantics>
</math>

.</p>

<p>For each 

<math display="inline" id="Push–relabel_maximum_flow_algorithm:17">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>u</mi>
    <mo>,</mo>
    <mi>v</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∈</mo>
   <mrow>
    <mi>V</mi>
    <mo>×</mo>
    <mi>V</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <interval closure="open">
     <ci>u</ci>
     <ci>v</ci>
    </interval>
    <apply>
     <times></times>
     <ci>V</ci>
     <ci>V</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (u,v)\in V\times V
  </annotation>
 </semantics>
</math>

, denote its <em>residual capacity</em> by 

<math display="inline" id="Push–relabel_maximum_flow_algorithm:18">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>c</mi>
     <mi>f</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>u</mi>
     <mo>,</mo>
     <mi>v</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>c</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>u</mi>
      <mo>,</mo>
      <mi>v</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>u</mi>
      <mo>,</mo>
      <mi>v</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>c</ci>
      <ci>f</ci>
     </apply>
     <interval closure="open">
      <ci>u</ci>
      <ci>v</ci>
     </interval>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>c</ci>
      <interval closure="open">
       <ci>u</ci>
       <ci>v</ci>
      </interval>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <interval closure="open">
       <ci>u</ci>
       <ci>v</ci>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{f}(u,v)=c(u,v)-f(u,v)
  </annotation>
 </semantics>
</math>

. The residual network of 

<math display="inline" id="Push–relabel_maximum_flow_algorithm:19">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

 with respect to a preflow 

<math display="inline" id="Push–relabel_maximum_flow_algorithm:20">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 is defined as 

<math display="inline" id="Push–relabel_maximum_flow_algorithm:21">
 <semantics>
  <mrow>
   <msub>
    <mi>G</mi>
    <mi>f</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>V</mi>
    <mo>,</mo>
    <msub>
     <mi>E</mi>
     <mi>f</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>G</ci>
     <ci>f</ci>
    </apply>
    <interval closure="open">
     <ci>V</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>E</ci>
      <ci>f</ci>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G_{f}(V,E_{f})
  </annotation>
 </semantics>
</math>

 where the residual edges are defined as 

<math display="inline" id="Push–relabel_maximum_flow_algorithm:22">
 <semantics>
  <mrow>
   <msub>
    <mi>E</mi>
    <mi>f</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>u</mi>
      <mo>,</mo>
      <mi>v</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo fence="true" stretchy="false">|</mo>
      <mrow>
       <mrow>
        <mi>u</mi>
        <mo>,</mo>
        <mi>v</mi>
       </mrow>
       <mo>∈</mo>
       <mrow>
        <mi>V</mi>
        <mi mathvariant="italic">and</mi>
        <msub>
         <mi>c</mi>
         <mi>f</mi>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>u</mi>
         <mo>,</mo>
         <mi>v</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
      <mo>></mo>
     </mrow>
     <mn>0</mn>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>E</ci>
     <ci>f</ci>
    </apply>
    <set>
     <apply>
      <times></times>
      <interval closure="open">
       <ci>u</ci>
       <ci>v</ci>
      </interval>
      <apply>
       <csymbol cd="latexml">ket</csymbol>
       <apply>
        <in></in>
        <list>
         <ci>u</ci>
         <ci>v</ci>
        </list>
        <apply>
         <times></times>
         <ci>V</ci>
         <ci>italic- and</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>c</ci>
          <ci>f</ci>
         </apply>
         <interval closure="open">
          <ci>u</ci>
          <ci>v</ci>
         </interval>
        </apply>
       </apply>
      </apply>
      <cn type="integer">0</cn>
     </apply>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E_{f}=\{(u,v)|u,v\in V\and c_{f}(u,v)>0\}
  </annotation>
 </semantics>
</math>

. If there is no path from any active vertex to <em>t</em> in 

<math display="inline" id="Push–relabel_maximum_flow_algorithm:23">
 <semantics>
  <msub>
   <mi>G</mi>
   <mi>f</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>G</ci>
    <ci>f</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G_{f}
  </annotation>
 </semantics>
</math>

, then preflow is called <em>maximum</em>. In a maximum preflow, 

<math display="inline" id="Push–relabel_maximum_flow_algorithm:24">
 <semantics>
  <mrow>
   <mi>e</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>e</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e(t)
  </annotation>
 </semantics>
</math>

 is equal to the value of a maximum flow; if 

<math display="inline" id="Push–relabel_maximum_flow_algorithm:25">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

 is the set of vertices from which <em>t</em> is reachable in 

<math display="inline" id="Push–relabel_maximum_flow_algorithm:26">
 <semantics>
  <msub>
   <mi>G</mi>
   <mi>f</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>G</ci>
    <ci>f</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G_{f}
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="Push–relabel_maximum_flow_algorithm:27">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>=</mo>
   <mrow>
    <mi>V</mi>
    <mo>\</mo>
    <mi>T</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>S</ci>
    <apply>
     <ci>normal-\</ci>
     <ci>V</ci>
     <ci>T</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S=V\backslash T
  </annotation>
 </semantics>
</math>

, then 

<math display="inline" id="Push–relabel_maximum_flow_algorithm:28">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>S</mi>
   <mo>,</mo>
   <mi>T</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>S</ci>
    <ci>T</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (S,T)
  </annotation>
 </semantics>
</math>

 is a <a href="Max-flow_min-cut_theorem" title="wikilink">minimum <em>s</em>-<em>t</em> cut</a>.</p>

<p>The push–relabel algorithm uses a nonnegative integer <em>valid labeling</em> function which makes use of <em>distance labels</em>, or <em>heights</em>, on vertices to determine which vertex pair should be selected for the push operation. This labeling function is denoted by 

<math display="inline" id="Push–relabel_maximum_flow_algorithm:29">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>h</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>v</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>,</mo>
    <mi>v</mi>
   </mrow>
   <mo>∈</mo>
   <mi>V</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <list>
     <apply>
      <times></times>
      <ci>h</ci>
      <ci>v</ci>
     </apply>
     <ci>v</ci>
    </list>
    <ci>V</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h(v),v\in V
  </annotation>
 </semantics>
</math>

. This function must satisfy the following conditions in order to be considered valid:</p>
<dl>
<dd>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p><strong>Valid labeling</strong>:</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Push–relabel_maximum_flow_algorithm:30">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>h</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>u</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>≤</mo>
    <mrow>
     <mrow>
      <mi>h</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>v</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </mrow>
   <mo rspace="12.5pt">,</mo>
   <mrow>
    <mrow>
     <mo>∀</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>u</mi>
      <mo>,</mo>
      <mi>v</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>∈</mo>
    <msub>
     <mi>E</mi>
     <mi>f</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <leq></leq>
     <apply>
      <times></times>
      <ci>h</ci>
      <ci>u</ci>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>h</ci>
       <ci>v</ci>
      </apply>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <in></in>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <interval closure="open">
       <ci>u</ci>
       <ci>v</ci>
      </interval>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>E</ci>
      <ci>f</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h(u)\leq h(v)+1,\quad\forall(u,v)\in E_{f}
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><strong>Source condition</strong>:</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Push–relabel_maximum_flow_algorithm:31">
 <semantics>
  <mrow>
   <mrow>
    <mi>h</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>s</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">|</mo>
    <mi>V</mi>
    <mo stretchy="false">|</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>h</ci>
     <ci>s</ci>
    </apply>
    <apply>
     <abs></abs>
     <ci>V</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h(s)=|V|
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><strong>Sink conservation</strong>:</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Push–relabel_maximum_flow_algorithm:32">
 <semantics>
  <mrow>
   <mrow>
    <mi>h</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>h</ci>
     <ci>t</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h(t)=0
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
</tbody>
</table>
</dd>
</dl>

<p>In the algorithm, the height values of <em>s</em> and <em>t</em> are fixed. 

<math display="inline" id="Push–relabel_maximum_flow_algorithm:33">
 <semantics>
  <mrow>
   <mi>h</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>u</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>h</ci>
    <ci>u</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h(u)
  </annotation>
 </semantics>
</math>

 is a lower bound of the unweighted distance from <em>u</em> to <em>t</em> in 

<math display="inline" id="Push–relabel_maximum_flow_algorithm:34">
 <semantics>
  <msub>
   <mi>G</mi>
   <mi>f</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>G</ci>
    <ci>f</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G_{f}
  </annotation>
 </semantics>
</math>

 if <em>t</em> is reachable from <em>u</em>. If <em>u</em> has been disconnected from <em>t</em>, then 

<math display="inline" id="Push–relabel_maximum_flow_algorithm:35">
 <semantics>
  <mrow>
   <mrow>
    <mi>h</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>u</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>-</mo>
   <mrow>
    <mo stretchy="false">|</mo>
    <mi>V</mi>
    <mo stretchy="false">|</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <apply>
     <times></times>
     <ci>h</ci>
     <ci>u</ci>
    </apply>
    <apply>
     <abs></abs>
     <ci>V</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h(u)-|V|
  </annotation>
 </semantics>
</math>

 is a lower bound of the unweighted distance from <em>u</em> to <em>s</em>. As a result, if a valid height function exists, there are no <em>s</em>-<em>t</em> paths in 

<math display="inline" id="Push–relabel_maximum_flow_algorithm:36">
 <semantics>
  <msub>
   <mi>G</mi>
   <mi>f</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>G</ci>
    <ci>f</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G_{f}
  </annotation>
 </semantics>
</math>

 because no such paths can be longer than 

<math display="inline" id="Push–relabel_maximum_flow_algorithm:37">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">|</mo>
    <mi>V</mi>
    <mo stretchy="false">|</mo>
   </mrow>
   <mo>-</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <apply>
     <abs></abs>
     <ci>V</ci>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |V|-1
  </annotation>
 </semantics>
</math>

.</p>

<p>An edge 

<math display="inline" id="Push–relabel_maximum_flow_algorithm:38">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>u</mi>
    <mo>,</mo>
    <mi>v</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∈</mo>
   <msub>
    <mi>E</mi>
    <mi>f</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <interval closure="open">
     <ci>u</ci>
     <ci>v</ci>
    </interval>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>E</ci>
     <ci>f</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (u,v)\in E_{f}
  </annotation>
 </semantics>
</math>

 is called <em>admissible</em> if 

<math display="inline" id="Push–relabel_maximum_flow_algorithm:39">
 <semantics>
  <mrow>
   <mrow>
    <mi>h</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>u</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>h</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>v</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>h</ci>
     <ci>u</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>h</ci>
      <ci>v</ci>
     </apply>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h(u)=h(v)+1
  </annotation>
 </semantics>
</math>

. The network 

<math display="inline" id="Push–relabel_maximum_flow_algorithm:40">
 <semantics>
  <mrow>
   <msub>
    <mover accent="true">
     <mi>G</mi>
     <mo stretchy="false">~</mo>
    </mover>
    <mi>f</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>V</mi>
    <mo>,</mo>
    <msub>
     <mover accent="true">
      <mi>E</mi>
      <mo stretchy="false">~</mo>
     </mover>
     <mi>f</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <ci>normal-~</ci>
      <ci>G</ci>
     </apply>
     <ci>f</ci>
    </apply>
    <interval closure="open">
     <ci>V</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <ci>normal-~</ci>
       <ci>E</ci>
      </apply>
      <ci>f</ci>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tilde{G}_{f}(V,\tilde{E}_{f})
  </annotation>
 </semantics>
</math>

 when 

<math display="inline" id="Push–relabel_maximum_flow_algorithm:41">
 <semantics>
  <mrow>
   <msub>
    <mover accent="true">
     <mi>E</mi>
     <mo stretchy="false">~</mo>
    </mover>
    <mi>f</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>u</mi>
     <mo>,</mo>
     <mi>v</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">|</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>u</mi>
      <mo>,</mo>
      <mi>v</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>∈</mo>
     <mrow>
      <msub>
       <mi>E</mi>
       <mi>f</mi>
      </msub>
      <mi mathvariant="italic">and</mi>
      <mi>h</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>u</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>=</mo>
     <mrow>
      <mrow>
       <mi>h</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>v</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <ci>normal-~</ci>
      <ci>E</ci>
     </apply>
     <ci>f</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <interval closure="open">
      <ci>u</ci>
      <ci>v</ci>
     </interval>
     <apply>
      <and></and>
      <apply>
       <in></in>
       <interval closure="open">
        <ci>u</ci>
        <ci>v</ci>
       </interval>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>E</ci>
         <ci>f</ci>
        </apply>
        <ci>italic- and</ci>
        <ci>h</ci>
        <ci>u</ci>
       </apply>
      </apply>
      <apply>
       <eq></eq>
       <share href="#.cmml">
       </share>
       <apply>
        <plus></plus>
        <apply>
         <times></times>
         <ci>h</ci>
         <ci>v</ci>
        </apply>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tilde{E}_{f}=\{(u,v)|(u,v)\in E_{f}\and h(u)=h(v)+1\}
  </annotation>
 </semantics>
</math>

 is called the <em>admissible network</em>. The admissible network is acyclic.</p>
<h3 id="operations">Operations</h3>
<h4 id="initialization">Initialization</h4>

<p>The algorithm starts by creating a residual graph, initializing the preflow values to zero and performing a set of saturating push operations on residual edges exiting the source, }. Similarly, the label heights are initialized such that the height at the source is in the number of vertices in the graph, , and all other vertices are given a height of zero. Once the initialization is complete, the algorithm repeatedly performs either the push or relabel operations against active vertices until no applicable operation can be performed.</p>
<h4 id="push">Push</h4>

<p>The push operation applies on an admissible out-edge  of an active vertex <em>u</em> in <mtpl></mtpl>. It moves 

<math display="inline" id="Push–relabel_maximum_flow_algorithm:42">
 <semantics>
  <mrow>
   <mi>min</mi>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mi>e</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>u</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>,</mo>
    <mrow>
     <msub>
      <mi>c</mi>
      <mi>f</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>u</mi>
      <mo>,</mo>
      <mi>v</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <min></min>
    <apply>
     <times></times>
     <ci>e</ci>
     <ci>u</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>c</ci>
      <ci>f</ci>
     </apply>
     <interval closure="open">
      <ci>u</ci>
      <ci>v</ci>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \min\{e(u),c_{f}(u,v)\}
  </annotation>
 </semantics>
</math>

 units of flow from <em>u</em> to <em>v</em>.</p>

<p><code>push(u, v):</code><br/>
<code>    assert e[u] &gt; 0 and h[u] == h[v] + 1</code><br/>
<code>    Δ = min(e[u], c[u][v] - f[u][v])</code><br/>
<code>    f[u][v] += Δ</code><br/>
<code>    f[v][u] -= Δ</code><br/>
<code>    e[u] -= Δ</code><br/>
<code>    e[v] += Δ</code></p>

<p>A push operation that causes  to reach  is called a <em>saturating</em> push since it uses up all the available capacity of the residual edge. Otherwise, all of the excess at the vertex is pushed across the residual edge. This is called an <em>unsaturating</em> or <em>non-saturating</em> push.</p>
<h4 id="relabel">Relabel</h4>

<p>The relabel operation applies on an active vertex <em>u</em> without any admissible out-edges in <mtpl></mtpl>. It modifies  to the minimum value such that an admissible out-edge is created. Note that this always increases  and never creates a steep edge, which is an edge  such that <mtpl></mtpl>, and .</p>

<p><code>relabel(u):</code><br/>
<code>    assert e[u] &gt; 0 and h[u] </code><code>, where </code><code>; it may also remove the edge </code><code> from </code><mtpl></mtpl><code>, where it effectively removes the constraint </code><code>.</code></p>

<p>To see that a relabel operation on vertex <em>u</em> preserves the validity of , notice that this is trivially guaranteed by definition for the out-edges of <em>u</em> in <mtpl></mtpl>. For the in-edges of <em>u</em> in the <mtpl></mtpl>, the increased  can only satisfy the constraints less tightly, not violate them.</p>
<h2 id="the-generic-pushrelabel-algorithm">The generic push–relabel algorithm</h2>
<h3 id="description">Description</h3>

<p>The following algorithm is a generic version of the push–relabel algorithm. It is used as a proof of concept and does not contain implementation details on how to select an active vertex for the push and relabel operations. This generic version of the algorithm will terminate in <mtpl></mtpl>.</p>

<p>Since , , and there are no paths longer than  in <mtpl></mtpl>, in order for  to satisfy the valid labeling condition, <em>s</em> must be disconnected from <em>t</em>. At initialization, the algorithm fulfills this requirement by creating a preflow <em>f</em> that saturates all out-edges of <em>s</em>, after which  is trivially valid for all }. After initialization, the algorithm repeatedly executes an applicable push or relabel operation until no such operations apply, at which point the preflow has been converted into a maximum flow.</p>

<p><code>generic-push-relabel(G(V, E), s, t):</code><br/>
<code>    create a preflow f that saturates all out-edges of s</code><br/>
<code>    let h[s] = |V|</code><br/>
<code>    let h[v] = 0 ∀v ∈ V \ {s}</code><br/>
<code>    while there is an applicable push or relabel operation</code><br/>
<code>        execute the operation</code></p>
<h3 id="correctness">Correctness</h3>

<p>The algorithm maintains the condition that <em>h</em> is a valid labeling during its execution. This can be proven true by examining the effects of the push and relabel operations on the label function <em>h</em>. The relabel operation increases the label value by the associated minimum plus one which will always satisfy the  constraint. The push operation can send flow from <em>u</em> to <em>v</em> if . This may add  to <mtpl></mtpl> and may delete  from <mtpl></mtpl>. The addition of  to <mtpl></mtpl> will not affect the valid labeling since . The deletion of  from <mtpl></mtpl> removes corresponding constraint since the valid labeling property  only applies to residual edges in <mtpl></mtpl>.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a></p>

<p>If a preflow <em>f</em> and a valid labeling <em>h</em> for <em>f</em> exists then there is no augmenting path from <em>s</em> to <em>t</em> in the residual graph <mtpl></mtpl>. This can be proven by contradiction based on inequalities which arise in the labeling function when supposing that an augmenting path does exist. If the algorithm terminates, then all vertices in } are not active. This means all } have no excess flow, and with no excess the preflow <em>f</em> obeys the flow conservation constraint and can be considered a normal flow. This flow is the maximum flow according to the <a href="max-flow_min-cut_theorem" title="wikilink">max-flow min-cut theorem</a> since there is no augmenting path from <em>s</em> to <em>t</em>.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a></p>

<p>Therefore, the algorithm will return the maximum flow upon termination.</p>
<h3 id="time-complexity">Time complexity</h3>

<p>In order to bind the time complexity of the algorithm, we must analyze the number of push and relabel operations which occur within the main loop. The numbers of relabel, saturating push and nonsaturating push operations are analyzed separately.</p>

<p>In the algorithm, the relabel operation can be performed at most <mtpl><em>V</em>{{!}} - 1)({{!}}<em>V</em>{{!}} - 2) 2}}</mtpl> times. This is because the labeling  value for any vertex <em>u</em> can never decrease, and the maximum label value is at most  for all vertices. This means the relabel operation could potentially be performed  times for all vertices } (i.e. ). This results in a bound of <mtpl></mtpl> for the relabel operation.</p>

<p>Each saturating push on an admissible edge  removes the edge from <mtpl></mtpl>. For the edge to be reinserted into <mtpl></mtpl> for another saturating push, <em>v</em> must be first relabeled, followed by a push on edge , then <em>u</em> must be relabeled. In the process,  increases by at least two. Therefore, there are  saturating pushes on , and the total number of saturating pushes is at most . This results in a time bound of  for the saturating push operations.</p>

<p>Bounding the number of nonsaturating pushes can be achieved via a <a href="Potential_method" title="wikilink">potential argument</a>. We use the potential function <mtpl> ∑<sub>[<em>u</em> ∈ <em>V</em> ∧ <em>e</em>(<em>u</em>) &gt; 0]</sub> <em>h</em>(<em>u</em>)}}</mtpl> (i.e. Φ is the sum of the heights of all active vertices). It is obvious that Φ is  initially and stays nonnegative throughout the execution of the algorithm. Both relabels and saturating pushes can increase Φ. However, the value of Φ must be equal 0 at termination since there cannot be any remaining active vertices at the end of the algorithm's execution. This means that over the execution of the algorithm, the nonsaturating pushes must make up the difference of the relabel and saturating push operations in order for Φ to terminate with a value of 0.</p>

<p>The relabel operation can increase Φ by at most . A saturating push on  activates <em>v</em> if it was inactive before the push, increasing Φ by at most . Hence, the total contribution of all saturating pushes operations to Φ is at most . A nonsaturating push on  always deactivates <em>u</em>, but it can also activate <em>v</em> as in a saturating push. As a result, it decreases Φ by at least . Since relabels and saturating pushes increase Φ, the total number of nonsaturating pushes must make up the difference of <mtpl><em>V</em>{{!}} - 1)({{!}}<em>V</em>{{!}} - 2) + (2{{!}}<em>V</em>{{!}} - 1)(2{{!}}<em>V</em>{{!}}{{!}}<em>E</em>{{!}}) ≤ 4{{!}}<em>V</em>{{!}}<sup>2</sup>{{!}}<em>E</em>{{!}}}}</mtpl>. This results in a time bound of <mtpl></mtpl> for the nonsaturating push operations.</p>

<p>In sum, the algorithm executes <mtpl></mtpl> relabels,  saturating pushes and <mtpl></mtpl> nonsaturating pushes. Data structures can be designed to pick and execute an applicable operation in  time. Therefore, the time complexity of the algorithm is <mtpl></mtpl>.<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a><a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a></p>
<h3 id="example">Example</h3>

<p>The following is a sample execution of the generic push-relabel algorithm, as defined above, on the following simple network flow graph diagram.</p>

<p>In the example, the  and  values denote the height and excess, respectively, of the vertex during the execution of the algorithm. Each residual graph in the example only contains the residual edges with a capacity larger than zero. Each residual graph may contain multiple iterations of the  loop.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>Algorithm Operation(s)</p></th>
<th style="text-align: left;">
<p>Residual Graph</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>Initialize the residual graph by setting the preflow to values 0 and initializing the labeling.</p></td>
<td style="text-align: left;"><figure><b>(Figure)</b>
<figcaption>Step 1|350px</figcaption>
</figure></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Initial saturating push is performed across all preflow edges out of the source, .</p></td>
<td style="text-align: left;"><figure><b>(Figure)</b>
<figcaption>Step 2|350px</figcaption>
</figure></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>Vertex  is relabeled in order to push its excess flow towards the sink, . The excess at  is then pushed to  then  in two subsequent saturating pushes; which still leaves  with some excess.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><figure><b>(Figure)</b>
<figcaption>Step 3|350px</figcaption>
</figure></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>Once again,  is relabeled in order to push its excess along its last remaining positive residual (i.e. push the excess back to ). The vertex  is then removed from the set of active vertices.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><figure><b>(Figure)</b>
<figcaption>Step 4|350px</figcaption>
</figure></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>Relabel  then push its excess to  and .</p></td>
<td style="text-align: left;"><figure><b>(Figure)</b>
<figcaption>Step 5|350px</figcaption>
</figure></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Relabel  then push its excess to .</p></td>
<td style="text-align: left;"><figure><b>(Figure)</b>
<figcaption>Step 6|350px</figcaption>
</figure></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>Relabel  then push its excess to .</p></td>
<td style="text-align: left;"><figure><b>(Figure)</b>
<figcaption>Step 7|350px</figcaption>
</figure></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>This leaves the vertex  as the only remaining active vertex, but it cannot push its excess flow towards the sink. Relabel  then push its excess towards the source, , via the vertex .</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><figure><b>(Figure)</b>
<figcaption>Step 8|350px</figcaption>
</figure></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Push the last bit of excess at  back to the source, . There are no remaining active vertices. The algorithm terminates and returns the maximum flow of the graph (as seen above).</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><figure><b>(Figure)</b>
<figcaption>Step 9|350px</figcaption>
</figure></td>
</tr>
</tbody>
</table>

<p>The example (but with initial flow of 0) can be run <a href="http://www.adrian-haarbach.de/push-relabel.html?graph=6">here</a> interactively.</p>
<h2 id="practical-implementations">Practical implementations</h2>

<p>While the generic push–relabel algorithm has <mtpl></mtpl> time complexity, efficient implementations achieve <mtpl></mtpl> or lower time complexity by enforcing appropriate rules in selecting applicable push and relabel operations. The empirical performance can be further improved by heuristics.</p>
<h3 id="current-edge-data-structure-and-discharge-operation">"Current-edge" data structure and discharge operation</h3>

<p>The "current-edge" data structure is a mechanism for visiting the in- and out-neighbors of a vertex in the flow network in a static circular order. If a singly linked list of neighbors is created for a vertex, the data structure can be as simple as a pointer into the list that steps through the list and rewinds to the head when it runs off the end.</p>

<p>Based on the "current-edge" data structure, the discharge operation can be defined. A discharge operation applies on an active node and repeatedly pushes flow from the node until it becomes inactive, relabeling it as necessary to create admissible edges in the process.</p>

<p><code>discharge(u):</code><br/>
<code>    while e[u] &gt; 0</code><br/>
<code>        if current-edge[u] has run off the end of neighbors[u]</code><br/>
<code>            relabel(u)</code><br/>
<code>            rewind current-edge[u]</code><br/>
<code>        else</code><br/>
<code>            let (u, v) = current-edge[u]</code><br/>
<code>            if (u, v) is admissible</code><br/>
<code>                push(u, v)</code><br/>
<code>            else</code><br/>
<code>                let current-edge[u] point to the next neighbor of u</code></p>
<h3 id="active-vertex-selection-rules">Active vertex selection rules</h3>

<p>Definition of the discharge operation reduces the push–relabel algorithm to repeatedly selecting an active node to discharge. Depending on the selection rule, the algorithm exhibits different time complexities. For the sake of brevity, we ignore <em>s</em> and <em>t</em> when referring to the vertices in the following discussion.</p>
<h4 id="fifo-selection-rule">FIFO selection rule</h4>

<p>The <a href="FIFO_(computing_and_electronics)" title="wikilink">FIFO</a> push–relabel algorithm<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a> organizes the active vertices into a queue. The initial active nodes can be inserted in arbitrary order. The algorithm always removes the vertex at the front of the queue for discharging. Whenever an inactive vertex becomes active, it is appended to the back of the queue.</p>

<p>The algorithm has <mtpl></mtpl> time complexity.</p>
<h4 id="relabel-to-front-selection-rule">Relabel-to-front selection rule</h4>

<p>The relabel-to-front push–relabel algorithm<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a> organizes all vertices into a linked list and maintains the invariant that the list is <a href="Topological_sorting" title="wikilink">topologically sorted</a> with respect to the admissible network. The algorithm scans the list from front to back and performs a discharge operation on the current vertex if it is active. If the node is relabeled, it is moved to the front of the list, and the scan is restarted from the front.</p>

<p>The algorithm also has <mtpl></mtpl> time complexity.</p>
<h4 id="highest-label-selection-rule">Highest label selection rule</h4>

<p>The highest-label push–relabel algorithm<a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a> organizes all vertices into buckets indexed by their heights. The algorithm always selects an active vertex with the largest height to discharge.</p>

<p>The algorithm has <mtpl></mtpl> time complexity. If the lowest-label selection rule is used instead, the time complexity becomes <mtpl></mtpl>.<a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a></p>
<h3 id="implementation-techniques">Implementation techniques</h3>

<p>Although in the description of the generic push–relabel algorithm above,  is set to zero for each vertex <em>u</em> other than <em>s</em> and <em>t</em> at the beginning, it is preferable to perform a backward <a href="breadth-first_search" title="wikilink">breadth-first search</a> from <em>t</em> to compute the exact heights.<a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a></p>

<p>The algorithm is typically separated into two phases. Phase one computes a maximum preflow by discharging only active vertices whose heights are below <em>n</em>. Phase two converts the maximum preflow into a maximum flow by returning excess flow that cannot reach <em>t</em> to <em>s</em>. It can be shown that phase two has  time complexity regardless of the order of push and relabel operations and is therefore dominated by phase one. Alternatively, it can be implemented using flow decomposition.<a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a></p>

<p>Heuristics are crucial to improving the empirical performance of the algorithm.<a class="footnoteRef" href="#fn23" id="fnref23"><sup>23</sup></a> Two commonly used heuristics are the gap heuristic and the global relabeling heuristic.<a class="footnoteRef" href="#fn24" id="fnref24"><sup>24</sup></a><a class="footnoteRef" href="#fn25" id="fnref25"><sup>25</sup></a> The gap heuristic detects gaps in the height function. If there is a height  for which there is no vertex <em>u</em> such that , then any vertex <em>u</em> with  has been disconnected from <em>t</em> and can be relabeled to  immediately. The global relabeling heuristic periodically performs backward breadth-first search from <em>t</em> in <mtpl></mtpl> to compute the exact heights of the vertices. Both heuristics skip unhelpful relabel operations, which are a bottleneck of the algorithm and contribute to the ineffectiveness of dynamic trees.<a class="footnoteRef" href="#fn26" id="fnref26"><sup>26</sup></a></p>
<h2 id="sample-implementations">Sample implementations</h2>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="ot">#include <stdlib.h></stdlib.h></span>
<span class="ot">#include <stdio.h></stdio.h></span>

<span class="ot">#define NODES 6</span>
<span class="ot">#define MIN(X,Y) ((X) &lt; (Y) ? (X) : (Y))</span>
<span class="ot">#define INFINITE 10000000</span>

<span class="dt">void</span> push(<span class="dt">const</span> <span class="dt">int</span> * <span class="dt">const</span> * C, <span class="dt">int</span> ** F, <span class="dt">int</span> *excess, <span class="dt">int</span> u, <span class="dt">int</span> v) {
  <span class="dt">int</span> send = MIN(excess[u], C[u][v] - F[u][v]);
  F[u][v] += send;
  F[v][u] -= send;
  excess[u] -= send;
  excess[v] += send;
}

<span class="dt">void</span> relabel(<span class="dt">const</span> <span class="dt">int</span> * <span class="dt">const</span> * C, <span class="dt">const</span> <span class="dt">int</span> * <span class="dt">const</span> * F, <span class="dt">int</span> *height, <span class="dt">int</span> u) {
  <span class="dt">int</span> v;
  <span class="dt">int</span> min_height = INFINITE;
  <span class="kw">for</span> (v = <span class="dv">0</span>; v &lt; NODES; v++) {
    <span class="kw">if</span> (C[u][v] - F[u][v] &gt; <span class="dv">0</span>) {
      min_height = MIN(min_height, height[v]);
      height[u] = min_height + <span class="dv">1</span>;
    }
  }
};

<span class="dt">void</span> discharge(<span class="dt">const</span> <span class="dt">int</span> * <span class="dt">const</span> * C, <span class="dt">int</span> ** F, <span class="dt">int</span> *excess, <span class="dt">int</span> *height, <span class="dt">int</span> *seen, <span class="dt">int</span> u) {
  <span class="kw">while</span> (excess[u] &gt; <span class="dv">0</span>) {
    <span class="kw">if</span> (seen[u] &lt; NODES) {
      <span class="dt">int</span> v = seen[u];
      <span class="kw">if</span> ((C[u][v] - F[u][v] &gt; <span class="dv">0</span>) &amp;&amp; (height[u] &gt; height[v])){
    push(C, F, excess, u, v);
      }
      <span class="kw">else</span>
    seen[u] += <span class="dv">1</span>;
    } <span class="kw">else</span> {
      relabel(C, F, height, u);
      seen[u] = <span class="dv">0</span>;
    }
  }
}

<span class="dt">void</span> moveToFront(<span class="dt">int</span> i, <span class="dt">int</span> *A) {
  <span class="dt">int</span> temp = A[i];
  <span class="dt">int</span> n;
  <span class="kw">for</span> (n = i; n &gt; <span class="dv">0</span>; n--){
    A[n] = A[n<span class="dv">-1</span>];
  }
  A[<span class="dv">0</span>] = temp;
}

<span class="dt">int</span> pushRelabel(<span class="dt">const</span> <span class="dt">int</span> * <span class="dt">const</span> * C, <span class="dt">int</span> ** F, <span class="dt">int</span> source, <span class="dt">int</span> sink) {
  <span class="dt">int</span> *excess, *height, *list, *seen, i, p;

  excess = (<span class="dt">int</span> *) calloc(NODES, <span class="kw">sizeof</span>(<span class="dt">int</span>));
  height = (<span class="dt">int</span> *) calloc(NODES, <span class="kw">sizeof</span>(<span class="dt">int</span>));
  seen = (<span class="dt">int</span> *) calloc(NODES, <span class="kw">sizeof</span>(<span class="dt">int</span>));

  list = (<span class="dt">int</span> *) calloc((NODES<span class="dv">-2</span>), <span class="kw">sizeof</span>(<span class="dt">int</span>));

  <span class="kw">for</span> (i = <span class="dv">0</span>, p = <span class="dv">0</span>; i &lt; NODES; i++){
    <span class="kw">if</span>((i != source) &amp;&amp; (i != sink)) {
      list[p] = i;
      p++;
    }
  }

  height[source] = NODES;
  excess[source] = INFINITE;
  <span class="kw">for</span> (i = <span class="dv">0</span>; i &lt; NODES; i++)
    push(C, F, excess, source, i);

  p = <span class="dv">0</span>;
  <span class="kw">while</span> (p &lt; NODES - <span class="dv">2</span>) {
    <span class="dt">int</span> u = list[p];
    <span class="dt">int</span> old_height = height[u];
    discharge(C, F, excess, height, seen, u);
    <span class="kw">if</span> (height[u] &gt; old_height) {
      moveToFront(p,list);
      p=<span class="dv">0</span>;
    }
    <span class="kw">else</span>
      p += <span class="dv">1</span>;
  }
  <span class="dt">int</span> maxflow = <span class="dv">0</span>;
  <span class="kw">for</span> (i = <span class="dv">0</span>; i &lt; NODES; i++)
    maxflow += F[source][i];

  free(list);

  free(seen);
  free(height);
  free(excess);

  <span class="kw">return</span> maxflow;
}

<span class="dt">void</span> printMatrix(<span class="dt">const</span> <span class="dt">int</span> * <span class="dt">const</span> * M) {
  <span class="dt">int</span> i,j;
  <span class="kw">for</span> (i = <span class="dv">0</span>; i &lt; NODES; i++) {
    <span class="kw">for</span> (j = <span class="dv">0</span>; j &lt; NODES; j++)
      printf(<span class="st">"%d</span><span class="ch">\t</span><span class="st">"</span>,M[i][j]);
    printf(<span class="st">"</span><span class="ch">\n</span><span class="st">"</span>);
  }
}

<span class="dt">int</span> main(<span class="dt">void</span>) {
  <span class="dt">int</span> **flow, **capacities, i;
  flow = (<span class="dt">int</span> **) calloc(NODES, <span class="kw">sizeof</span>(<span class="dt">int</span>*));
  capacities = (<span class="dt">int</span> **) calloc(NODES, <span class="kw">sizeof</span>(<span class="dt">int</span>*));
  <span class="kw">for</span> (i = <span class="dv">0</span>; i &lt; NODES; i++) {
    flow[i] = (<span class="dt">int</span> *) calloc(NODES, <span class="kw">sizeof</span>(<span class="dt">int</span>));
    capacities[i] = (<span class="dt">int</span> *) calloc(NODES, <span class="kw">sizeof</span>(<span class="dt">int</span>));
  }

  <span class="co">//Sample graph</span>
  capacities[<span class="dv">0</span>][<span class="dv">1</span>] = <span class="dv">2</span>;
  capacities[<span class="dv">0</span>][<span class="dv">2</span>] = <span class="dv">9</span>;
  capacities[<span class="dv">1</span>][<span class="dv">2</span>] = <span class="dv">1</span>;
  capacities[<span class="dv">1</span>][<span class="dv">3</span>] = <span class="dv">0</span>;
  capacities[<span class="dv">1</span>][<span class="dv">4</span>] = <span class="dv">0</span>;
  capacities[<span class="dv">2</span>][<span class="dv">4</span>] = <span class="dv">7</span>;
  capacities[<span class="dv">3</span>][<span class="dv">5</span>] = <span class="dv">7</span>;
  capacities[<span class="dv">4</span>][<span class="dv">5</span>] = <span class="dv">4</span>;

  printf(<span class="st">"Capacity:</span><span class="ch">\n</span><span class="st">"</span>);
  printMatrix(capacities);

  printf(<span class="st">"Max Flow:</span><span class="ch">\n</span><span class="st">%d</span><span class="ch">\n</span><span class="st">"</span>, pushRelabel(capacities, flow, <span class="dv">0</span>, <span class="dv">5</span>));

  printf(<span class="st">"Flows:</span><span class="ch">\n</span><span class="st">"</span>);
  printMatrix(flow);

  <span class="kw">return</span> <span class="dv">0</span>;
}
</code></pre></div></body>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">  <span class="kw">def</span> relabel_to_front(C, source, sink):
     n <span class="op">=</span> <span class="bu">len</span>(C) <span class="co"># C is the capacity matrix</span>
     F <span class="op">=</span> [[<span class="dv">0</span>] <span class="op">*</span> n <span class="cf">for</span> _ <span class="op">in</span> <span class="bu">xrange</span>(n)]
     <span class="co"># residual capacity from u to v is C[u][v] - F[u][v]</span>

     height <span class="op">=</span> [<span class="dv">0</span>] <span class="op">*</span> n <span class="co"># height of node</span>
     excess <span class="op">=</span> [<span class="dv">0</span>] <span class="op">*</span> n <span class="co"># flow into node minus flow from node</span>
     seen   <span class="op">=</span> [<span class="dv">0</span>] <span class="op">*</span> n <span class="co"># neighbours seen since last relabel</span>
     <span class="co"># node "queue"</span>
     nodelist <span class="op">=</span> [i <span class="cf">for</span> i <span class="op">in</span> <span class="bu">xrange</span>(n) <span class="cf">if</span> i <span class="op">!=</span> source <span class="op">and</span> i <span class="op">!=</span> sink]

     <span class="kw">def</span> push(u, v):
         send <span class="op">=</span> <span class="bu">min</span>(excess[u], C[u][v] <span class="op">-</span> F[u][v])
         F[u][v] <span class="op">+=</span> send
         F[v][u] <span class="op">-=</span> send
         excess[u] <span class="op">-=</span> send
         excess[v] <span class="op">+=</span> send

     <span class="kw">def</span> relabel(u):
         <span class="co"># find smallest new height making a push possible,</span>
         <span class="co"># if such a push is possible at all</span>
         min_height <span class="op">=</span> ∞
         <span class="cf">for</span> v <span class="op">in</span> <span class="bu">xrange</span>(n):
             <span class="cf">if</span> C[u][v] <span class="op">-</span> F[u][v] <span class="op">&gt;</span> <span class="dv">0</span>:
                 min_height <span class="op">=</span> <span class="bu">min</span>(min_height, height[v])
                 height[u] <span class="op">=</span> min_height <span class="op">+</span> <span class="dv">1</span>

     <span class="kw">def</span> discharge(u):
         <span class="cf">while</span> excess[u] <span class="op">&gt;</span> <span class="dv">0</span>:
             <span class="cf">if</span> seen[u] <span class="op">&lt;</span> n: <span class="co"># check next neighbour</span>
                 v <span class="op">=</span> seen[u]
                 <span class="cf">if</span> C[u][v] <span class="op">-</span> F[u][v] <span class="op">&gt;</span> <span class="dv">0</span> <span class="op">and</span> height[u] <span class="op">&gt;</span> height[v]:
                     push(u, v)
                 <span class="cf">else</span>:
                     seen[u] <span class="op">+=</span> <span class="dv">1</span>
             <span class="cf">else</span>: <span class="co"># we have checked all neighbours. must relabel</span>
                 relabel(u)
                 seen[u] <span class="op">=</span> <span class="dv">0</span>

     height[source] <span class="op">=</span> n   <span class="co"># longest path from source to sink is less than n long</span>
     excess[source] <span class="op">=</span> Inf <span class="co"># send as much flow as possible to neighbours of source</span>
     <span class="cf">for</span> v <span class="op">in</span> <span class="bu">xrange</span>(n):
         push(source, v)

     p <span class="op">=</span> <span class="dv">0</span>
     <span class="cf">while</span> p <span class="op">&lt;</span> <span class="bu">len</span>(nodelist):
         u <span class="op">=</span> nodelist[p]
         old_height <span class="op">=</span> height[u]
         discharge(u)
         <span class="cf">if</span> height[u] <span class="op">&gt;</span> old_height:
             nodelist.insert(<span class="dv">0</span>, nodelist.pop(p)) <span class="co"># move to front of list</span>
             p <span class="op">=</span> <span class="dv">0</span> <span class="co"># start from front of list</span>
         <span class="cf">else</span>:
             p <span class="op">+=</span> <span class="dv">1</span>

     <span class="cf">return</span> <span class="bu">sum</span>(F[source])</code></pre></div>
<h2 id="references">References</h2>

<p>"</p>

<p><a href="Category:Network_flow" title="wikilink">Category:Network flow</a> <a href="Category:Graph_algorithms" title="wikilink">Category:Graph algorithms</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"></li>
<li id="fn2"></li>
<li id="fn3"></li>
<li id="fn4"></li>
<li id="fn5"></li>
<li id="fn6"></li>
<li id="fn7"></li>
<li id="fn8"></li>
<li id="fn9"></li>
<li id="fn10"></li>
<li id="fn11"></li>
<li id="fn12"></li>
<li id="fn13"></li>
<li id="fn14"></li>
<li id="fn15"></li>
<li id="fn16"></li>
<li id="fn17"></li>
<li id="fn18"></li>
<li id="fn19"></li>
<li id="fn20"></li>
<li id="fn21"></li>
<li id="fn22"></li>
<li id="fn23"></li>
<li id="fn24"></li>
<li id="fn25"></li>
<li id="fn26"></li>
</ol>
</section>


