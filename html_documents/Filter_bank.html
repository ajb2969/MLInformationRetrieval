<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="642">Filter bank</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Filter bank</h1>
<hr/>

<p>In <a href="signal_processing" title="wikilink">signal processing</a>, a <strong>filter bank</strong> is an array of <a href="bandpass_filter" title="wikilink">band-pass</a> <a href="filter_(signal_processing)" title="wikilink">filters</a> that separates the input signal into multiple components, each one carrying a single <a class="uri" href="frequency" title="wikilink">frequency</a> <a href="Sub-band_coding" title="wikilink">sub-band</a> of the original signal. One application of a filter bank is a <a href="graphic_equalizer" title="wikilink">graphic equalizer</a>, which can attenuate the components differently and recombine them into a modified version of the original signal. The process of decomposition performed by the filter bank is called <em>analysis</em> (meaning analysis of the signal in terms of its components in each sub-band); the output of analysis is referred to as a subband signal with as many subbands as there are filters in the filter bank. The reconstruction process is called <em>synthesis</em>, meaning reconstitution of a complete signal resulting from the filtering process.</p>

<p>In <a href="digital_signal_processing" title="wikilink">digital signal processing</a>, the term <strong>filter bank</strong> is also commonly applied to a bank of receivers. The difference is that receivers also <a href="Digital_down_converter" title="wikilink">down-convert</a> the subbands to a low center frequency that can be re-sampled at a reduced rate. The same result can sometimes be achieved by <a class="uri" href="undersampling" title="wikilink">undersampling</a> the bandpass subbands.</p>

<p>Another application of filter banks is <a href="Signalling_(telecommunication)" title="wikilink">signal</a> compression, when some frequencies are more important than others. After decomposition, the important frequencies can be coded with a fine resolution. Small differences at these frequencies are significant and a <a href="coding_theory" title="wikilink">coding</a> scheme that preserves these differences must be used. On the other hand, less important frequencies do not have to be exact. A coarser coding scheme can be used, even though some of the finer (but less important) details will be lost in the coding.</p>

<p>The <a class="uri" href="vocoder" title="wikilink">vocoder</a> uses a filter bank to determine the amplitude information of the subbands of a modulator signal (such as a voice) and uses them to control the amplitude of the subbands of a carrier signal (such as the output of a guitar or synthesizer), thus imposing the dynamic characteristics of the modulator on the carrier.</p>
<h2 id="fft-filter-banks">FFT filter banks</h2>

<p>A bank of receivers can be created by performing a sequence of <a href="Fast_Fourier_transform" title="wikilink">FFTs</a> on overlapping <em>segments</em> of the input data stream. A weighting function (aka <a href="window_function" title="wikilink">window function</a>) is applied to each segment to control the shape of the <a href="frequency_response" title="wikilink">frequency responses</a> of the filters. The wider the shape, the more points the FFT will have to generate in order to satisfy the <a href="Nyquist_rate" title="wikilink">Nyquist sampling criteria</a>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> For a fixed segment length, the amount of overlap determines how often the FFTs are done (and vice versa). Also, the wider the shape of the filters, the fewer filters that are needed to span the input bandwidth. Eliminating unnecessary filters (i.e. decimation in frequency) is efficiently done by treating each weighted segment as a sequence of smaller <em>blocks</em>, and the FFT is performed on only the sum of the blocks. This has been referred to as <em>multi-block windowing</em> and <em>weighted pre-sum FFT</em> (see <a href="Discrete-time_Fourier_transform#Sampling_the_DTFT" title="wikilink">Sampling the DTFT</a>).</p>

<p>A special case occurs when, by design, the length of the blocks is an integer multiple of the interval between FFTs. Then the FFT filter bank can be described in terms of one or more polyphase filter structures where the phases are recombined by an FFT instead of a simple summation. The number of blocks per segment is the impulse response length (or <em>depth</em>) of each filter. The computational efficiencies of the FFT and polyphase structures, on a general purpose processor, are identical.</p>

<p>Synthesis (i.e. recombining the outputs of multiple receivers) is basically a matter of <a class="uri" href="upsampling" title="wikilink">upsampling</a> each one at a rate commensurate with the total bandwidth to be created, translating each channel to its new center frequency, and summing the streams of samples. In that context, the interpolation filter associated with upsampling is called <em>synthesis filter</em>. The net frequency response of each channel is the product of the synthesis filter with the frequency response of the filter bank (<em>analysis filter</em>). Ideally, the frequency responses of adjacent channels sum to a constant value at every frequency between the channel centers. That condition is known as <em>perfect reconstruction</em>.</p>
<h2 id="filter-banks-as-time-frequency-distributions">Filter banks as time-frequency distributions</h2>

<p>In time-frequency signal processing, a filter bank is a special quadratic time-frequency distribution (TFD) that represents the signal in a joint time-frequency domain. It is related to the <a href="Wigner-Ville_distribution" title="wikilink">Wigner-Ville distribution</a> by a two-dimensional filtering that defines the class of <a href="Bilinear_time-frequency_distribution" title="wikilink">quadratic (or bilinear) time-frequency distributions</a>.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> The filter bank and the spectrogram are the two simplest ways of producing a quadratic TFD; they are in essence similar as one (the spectrogram) is obtained by dividing the time-domain in slices and then taking a fourier transform, while the other (the filter bank) is obtained by dividing the frequency domain in slices forming bandpass filters that are excited by the signal under analysis.</p>
<h2 id="multirate-filter-bank">Multirate Filter Bank</h2>

<p>Multirate filter bank divides a signal into a number of subbands, which can be analysed at different rates corresponding to the bandwidth of the frequency bands.<br/>
One important fact in multirate filtering is that the signal should be filtered before decimation, otherwise aliasing and frequency folding would occur. </p>
<h2 id="multirate-filter-designs">Multirate Filter Designs</h2>

<p>Multirate filter design makes use of properties of decimation and interpolation (or expansion) in the design implementation of the filter. Decimation or downsampling by a factor of 

<math display="inline" id="Filter_bank:0">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 essentially means keeping every 

<math display="inline" id="Filter_bank:1">
 <semantics>
  <msup>
   <mi>M</mi>
   <mrow>
    <mi>t</mi>
    <mi>h</mi>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>M</ci>
    <apply>
     <times></times>
     <ci>t</ci>
     <ci>h</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M^{th}
  </annotation>
 </semantics>
</math>

 sample of a given sequence.</p>
<h3 id="decimation-interpolation-and-modulation">Decimation, Interpolation, and Modulation</h3>

<p>Generally speaking, using decimation is very common in multirate filter designs. In the second step, after using decimation, interpolation will be used to restore the sampling rate. The advantage of using decimators and interpolator is that they can reduce the computations when resulting in a lower sampling rate.</p>

<p>Decimation by a factor of 

<math display="inline" id="Filter_bank:2">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 can be mathematically defined as:<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> 

<math display="inline" id="Filter_bank:3">
 <semantics>
  <mrow>
   <mi>x</mi>
   <msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mi></mi>
     <mo>↓</mo>
     <mi>M</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mi>x</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>M</mi>
    <mo>.</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">n</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <apply>
      <ci>normal-↓</ci>
      <csymbol cd="latexml">absent</csymbol>
      <ci>M</ci>
     </apply>
    </apply>
    <eq></eq>
    <csymbol cd="unknown">x</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">M</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">n</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {x(n)}_{\downarrow{}M}=x(M.n)
  </annotation>
 </semantics>
</math>

 or equivalently, 

<math display="inline" id="Filter_bank:4">
 <semantics>
  <mrow>
   <mrow>
    <mi>X</mi>
    <msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>z</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mi></mi>
      <mo>↓</mo>
      <mi>M</mi>
     </mrow>
    </msub>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mi>M</mi>
    </mfrac>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <mi>m</mi>
       <mo>=</mo>
       <mn>0</mn>
      </mrow>
      <mrow>
       <mi>M</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msubsup>
     <mrow>
      <mi>X</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msup>
        <mi>z</mi>
        <mfrac>
         <mn>1</mn>
         <mi>M</mi>
        </mfrac>
       </msup>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>X</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>z</ci>
      <apply>
       <ci>normal-↓</ci>
       <csymbol cd="latexml">absent</csymbol>
       <ci>M</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <ci>M</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>m</ci>
         <cn type="integer">0</cn>
        </apply>
       </apply>
       <apply>
        <minus></minus>
        <ci>M</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>X</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>z</ci>
        <apply>
         <divide></divide>
         <cn type="integer">1</cn>
         <ci>M</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X(z)_{\downarrow M}=\frac{1}{M}\sum_{m=0}^{M-1}X(z^{\frac{1}{M}})
  </annotation>
 </semantics>
</math>

.</p>

<p>Expansion or upsampling by a factor of M means that we insert M-1 zeros between each sample of a given signal or a sequence. The expansion by a factor of M can be mathematically explained as: 

<math display="inline" id="Filter_bank:5">
 <semantics>
  <mrow>
   <mrow>
    <mi>x</mi>
    <msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mi></mi>
      <mo>↑</mo>
      <mi>M</mi>
     </mrow>
    </msub>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>{</mo>
    <mtable>
     <mtr>
      <mtd columnalign="left">
       <mtable>
        <mtr>
         <mtd columnalign="center">
          <mrow>
           <mi>x</mi>
           <mrow>
            <mo stretchy="false">(</mo>
            <mfrac>
             <mi>n</mi>
             <mi>M</mi>
            </mfrac>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
         </mtd>
        </mtr>
        <mtr>
         <mtd columnalign="center">
          <mi></mi>
         </mtd>
        </mtr>
       </mtable>
      </mtd>
      <mtd columnalign="left">
       <mtable>
        <mtr>
         <mtd columnalign="center">
          <mfrac>
           <mi>n</mi>
           <mi>M</mi>
          </mfrac>
         </mtd>
        </mtr>
        <mtr>
         <mtd columnalign="center">
          <mrow>
           <mi>o</mi>
           <mi>t</mi>
           <mi>h</mi>
           <mi>e</mi>
           <mi>r</mi>
           <mi>w</mi>
           <mi>i</mi>
           <mi>s</mi>
           <mi>e</mi>
          </mrow>
         </mtd>
        </mtr>
       </mtable>
      </mtd>
     </mtr>
    </mtable>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>x</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>n</ci>
      <apply>
       <ci>normal-↑</ci>
       <csymbol cd="latexml">absent</csymbol>
       <ci>M</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">cases</csymbol>
     <matrix>
      <matrixrow>
       <apply>
        <times></times>
        <ci>x</ci>
        <apply>
         <divide></divide>
         <ci>n</ci>
         <ci>M</ci>
        </apply>
       </apply>
      </matrixrow>
      <matrixrow>
       <csymbol cd="latexml">absent</csymbol>
      </matrixrow>
     </matrix>
     <matrix>
      <matrixrow>
       <apply>
        <divide></divide>
        <ci>n</ci>
        <ci>M</ci>
       </apply>
      </matrixrow>
      <matrixrow>
       <apply>
        <times></times>
        <ci>o</ci>
        <ci>t</ci>
        <ci>h</ci>
        <ci>e</ci>
        <ci>r</ci>
        <ci>w</ci>
        <ci>i</ci>
        <ci>s</ci>
        <ci>e</ci>
       </apply>
      </matrixrow>
     </matrix>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x(n)_{\uparrow M}=\begin{cases}\begin{array}[]{c}x(\frac{n}{M})\\
\par
\end{array}&\begin{array}[]{c}\frac{n}{M}\\
otherwise\end{array}\end{cases}
  </annotation>
 </semantics>
</math>

<br/>
 or equivalently, 

<math display="inline" id="Filter_bank:6">
 <semantics>
  <mrow>
   <mrow>
    <mi>X</mi>
    <msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>z</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mi></mi>
      <mo>↑</mo>
      <mi>M</mi>
     </mrow>
    </msub>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>X</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>z</mi>
      <mi>M</mi>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>X</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>z</ci>
      <apply>
       <ci>normal-↑</ci>
       <csymbol cd="latexml">absent</csymbol>
       <ci>M</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>X</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>z</ci>
      <ci>M</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {X(z)}_{\uparrow{}M}=X(z^{M})
  </annotation>
 </semantics>
</math>

.</p>

<p>Modulation is needed for different kinds of filter designs. For instance, in many communication applications we need to modulate the signal to baseband. After using lowpass filtering for the baseband signal, we use modulation and change the baseband signal to the center frequency of the bandpass filter. Here we provide two examples of designing multirate narrow lowpass and narrow bandpass filters.</p>
<h3 id="narrow-lowpass-filter">Narrow lowpass filter</h3>

<p>We can define a narrow lowpass filter as a <a href="lowpass_filter" title="wikilink">lowpass filter</a> with a narrow passband. In order to create a multirate narrow lowpass FIR filter, we need to replace the time invariant FIR filter with a lowpass antialiasing filter and use a decimator along with an interpolator and lowpass anti-imaging filter</p>

<p>In this the resulting way multirate system would be a time varying linear phase filter via the decimator and interpolator. This process explained in block diagram form where Figure 2 (a) is replaced by Figure 2(b). </p>

<p>The lowpass filter consists of two polyphase filters, one for the decimator and one for the interpolator.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>

<p>A filter bank divides the input signal 

<math display="inline" id="Filter_bank:7">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mrow>
    <mo>(</mo>
    <mi>n</mi>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>x</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\left(n\right)
  </annotation>
 </semantics>
</math>

 into a set of signals 

<math display="inline" id="Filter_bank:8">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mrow>
    <msub>
     <mi>x</mi>
     <mn>2</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mrow>
    <msub>
     <mi>x</mi>
     <mn>3</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>n</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>n</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">3</cn>
     </apply>
     <ci>n</ci>
    </apply>
    <ci>normal-…</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1}(n),x_{2}(n),x_{3}(n),...
  </annotation>
 </semantics>
</math>

. In this way each of the generated signals corresponds to a different region in the spectrum of 

<math display="inline" id="Filter_bank:9">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mrow>
    <mo>(</mo>
    <mi>n</mi>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>x</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\left(n\right)
  </annotation>
 </semantics>
</math>

. In this process it can be possible for the regions overlap (or not, based on application). Figure 4 shows an example of a three-band filter bank. The generated signals 

<math display="inline" id="Filter_bank:10">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mrow>
    <msub>
     <mi>x</mi>
     <mn>2</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mrow>
    <msub>
     <mi>x</mi>
     <mn>3</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>n</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>n</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">3</cn>
     </apply>
     <ci>n</ci>
    </apply>
    <ci>normal-…</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1}(n),x_{2}(n),x_{3}(n),...
  </annotation>
 </semantics>
</math>

 can be generated via a collection of set of bandpass filters with bandwidths 

<math display="inline" id="Filter_bank:11">
 <semantics>
  <mrow>
   <mrow>
    <mi>B</mi>
    <msub>
     <mi>W</mi>
     <mn>1</mn>
    </msub>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>B</mi>
    <msub>
     <mi>W</mi>
     <mn>2</mn>
    </msub>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>B</mi>
    <msub>
     <mi>W</mi>
     <mn>3</mn>
    </msub>
   </mrow>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <times></times>
     <ci>B</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>W</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>B</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>W</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>B</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>W</ci>
      <cn type="integer">3</cn>
     </apply>
    </apply>
    <ci>normal-…</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   BW_{1},BW_{2},BW_{3},...
  </annotation>
 </semantics>
</math>

 and center frequencies 

<math display="inline" id="Filter_bank:12">
 <semantics>
  <mrow>
   <msub>
    <mi>f</mi>
    <mrow>
     <mi>c</mi>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>f</mi>
    <mrow>
     <mi>c</mi>
     <mn>2</mn>
    </mrow>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>f</mi>
    <mrow>
     <mi>c</mi>
     <mn>3</mn>
    </mrow>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>f</ci>
     <apply>
      <times></times>
      <ci>c</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>f</ci>
     <apply>
      <times></times>
      <ci>c</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>f</ci>
     <apply>
      <times></times>
      <ci>c</ci>
      <cn type="integer">3</cn>
     </apply>
    </apply>
    <ci>normal-…</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{c1},f_{c2},f_{c3},...
  </annotation>
 </semantics>
</math>

(respectively). </p>

<p>A multirate filter bank use a single input signal and then produces multiple outputs of the signal by filtering and subsampling. In order to split the input signal into two or more signals (see Figure 5) an analysis-synthesis system can be used . In figure 5, only 4 sub-signals are used.</p>

<p>The signal would split with the help of four filters 

<math display="inline" id="Filter_bank:13">
 <semantics>
  <mrow>
   <msub>
    <mi>H</mi>
    <mi>k</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>z</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>H</ci>
     <ci>k</ci>
    </apply>
    <ci>z</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{k}(z)
  </annotation>
 </semantics>
</math>

 for k =0,1,2,3 into 4 bands of the same bandwidths (In the analysis bank) and then each sub-signal is decimated by a factor of 4. In each band by dividing the signal in each band, we would have different signal characteristics.</p>
<figure><b>(Figure)</b>
<figcaption>Analysis/Synthesis Filter Bank</figcaption>
</figure>

<p>In synthesis section the filter will reconstruct the original signal: First, upsampling the 4 sub-signals at the output of the processing unit by a factor of 4 and then filtere by 4 synthesis filters 

<math display="inline" id="Filter_bank:14">
 <semantics>
  <mrow>
   <msub>
    <mi>F</mi>
    <mi>k</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>z</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>F</ci>
     <ci>k</ci>
    </apply>
    <ci>z</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F_{k}(z)
  </annotation>
 </semantics>
</math>

 for k = 0,1,2,3. Finally, the outputs of these four filters are added.</p>
<h2 id="multidimensional-filter-banks">Multidimensional Filter Banks</h2>

<p><a href="Multidimensional_Filter_Design" title="wikilink">Multidimensional Filtering</a>, <a class="uri" href="downsampling" title="wikilink">downsampling</a>, and <a class="uri" href="upsampling" title="wikilink">upsampling</a> are the main parts of <a href="multirate_systems" title="wikilink">multirate systems</a> and filter banks.</p>

<p>A complete filter bank consist of the analysis and synthesis side. The analysis filter bank divides an input signal to different subbands with different frequency spectrums. The synthesis part reassembles the different subband signals and generates a reconstruction signal. For example, in Figure 6, the input divides into four directional sub bands that each of them covers one of the wedge-shaped frequency regions. The synthesis part is dual to the analysis part. </p>

<p>It is important to analyze filter banks from a frequency domain perspective in terms of subband decomposition and reconstruction. However, equally important is <a href="Hilbert_Spaces_and_Fourier_analysis" title="wikilink">hilbert space</a> interpretation of filter banks, which plays a key role in geometrical signal representations. For generic K-channel filter bank, with analysis filters 

<math display="inline" id="Filter_bank:15">
 <semantics>
  <msubsup>
   <mrow>
    <mo>{</mo>
    <mrow>
     <msub>
      <mi>h</mi>
      <mi>k</mi>
     </msub>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>n</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo>}</mo>
   </mrow>
   <mrow>
    <mi>k</mi>
    <mo>=</mo>
    <mn>1</mn>
   </mrow>
   <mi>K</mi>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <set>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>h</ci>
        <ci>k</ci>
       </apply>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <ci>n</ci>
       </apply>
      </apply>
     </set>
     <apply>
      <eq></eq>
      <ci>k</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <ci>K</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left\{h_{k}[n]\right\}_{k=1}^{K}
  </annotation>
 </semantics>
</math>

, synthesis filters 

<math display="inline" id="Filter_bank:16">
 <semantics>
  <msubsup>
   <mrow>
    <mo>{</mo>
    <mrow>
     <msub>
      <mi>g</mi>
      <mi>k</mi>
     </msub>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>n</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo>}</mo>
   </mrow>
   <mrow>
    <mi>k</mi>
    <mo>=</mo>
    <mn>1</mn>
   </mrow>
   <mi>K</mi>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <set>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>g</ci>
        <ci>k</ci>
       </apply>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <ci>n</ci>
       </apply>
      </apply>
     </set>
     <apply>
      <eq></eq>
      <ci>k</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <ci>K</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left\{g_{k}[n]\right\}_{k=1}^{K}
  </annotation>
 </semantics>
</math>

, and sampling matrices 

<math display="inline" id="Filter_bank:17">
 <semantics>
  <msubsup>
   <mrow>
    <mo>{</mo>
    <mrow>
     <msub>
      <mi>M</mi>
      <mi>k</mi>
     </msub>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>n</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo>}</mo>
   </mrow>
   <mrow>
    <mi>k</mi>
    <mo>=</mo>
    <mn>1</mn>
   </mrow>
   <mi>K</mi>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <set>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>M</ci>
        <ci>k</ci>
       </apply>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <ci>n</ci>
       </apply>
      </apply>
     </set>
     <apply>
      <eq></eq>
      <ci>k</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <ci>K</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left\{M_{k}[n]\right\}_{k=1}^{K}
  </annotation>
 </semantics>
</math>

. In the analysis side, we can define vectors in <em>

<math display="inline" id="Filter_bank:18">
 <semantics>
  <mrow>
   <msup>
    <mi>l</mi>
    <mn>2</mn>
   </msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>Z</mi>
     <mi>d</mi>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>l</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>Z</ci>
     <ci>d</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   l^{2}(Z^{d})
  </annotation>
 </semantics>
</math>

</em> as<br/>


<math display="inline" id="Filter_bank:19">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>φ</mi>
     <mrow>
      <mi>k</mi>
      <mo>,</mo>
      <mi>m</mi>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>n</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mover>
    <mo movablelimits="false">=</mo>
    <mrow>
     <mi>d</mi>
     <mi>e</mi>
     <mi>f</mi>
    </mrow>
   </mover>
   <mrow>
    <msubsup>
     <mi>h</mi>
     <mi>k</mi>
     <mo>*</mo>
    </msubsup>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mrow>
       <msub>
        <mi>M</mi>
        <mi>k</mi>
       </msub>
       <mi>m</mi>
      </mrow>
      <mo>-</mo>
      <mi>n</mi>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <eq></eq>
     <apply>
      <times></times>
      <ci>d</ci>
      <ci>e</ci>
      <ci>f</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>φ</ci>
      <list>
       <ci>k</ci>
       <ci>m</ci>
      </list>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>h</ci>
       <ci>k</ci>
      </apply>
      <times></times>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>M</ci>
         <ci>k</ci>
        </apply>
        <ci>m</ci>
       </apply>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varphi_{k,m}[n]\stackrel{def}{=}h_{k}^{*}[M_{k}m-n]
  </annotation>
 </semantics>
</math>

, each index by two parameters

<math display="block" id="Filter_bank:20">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>≤</mo>
   <mi>k</mi>
   <mo>≤</mo>
   <mi>K</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <cn type="integer">1</cn>
     <ci>k</ci>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <ci>K</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1\leq k\leq K
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Filter_bank:21">
 <semantics>
  <mrow>
   <mi>m</mi>
   <mo>∈</mo>
   <msup>
    <mi>Z</mi>
    <mn>2</mn>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>m</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>Z</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m\in Z^{2}
  </annotation>
 </semantics>
</math>

.<br/>
Similarly, for the synthesis filters 

<math display="inline" id="Filter_bank:22">
 <semantics>
  <mrow>
   <msub>
    <mi>g</mi>
    <mi>k</mi>
   </msub>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>n</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>g</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g_{k}[n]
  </annotation>
 </semantics>
</math>

 we can define 

<math display="inline" id="Filter_bank:23">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>ψ</mi>
     <mrow>
      <mi>k</mi>
      <mo>,</mo>
      <mi>m</mi>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>n</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mover>
    <mo movablelimits="false">=</mo>
    <mrow>
     <mi>d</mi>
     <mi>e</mi>
     <mi>f</mi>
    </mrow>
   </mover>
   <mrow>
    <msubsup>
     <mi>h</mi>
     <mi>k</mi>
     <mo>*</mo>
    </msubsup>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mrow>
       <msub>
        <mi>M</mi>
        <mi>k</mi>
       </msub>
       <mi>m</mi>
      </mrow>
      <mo>-</mo>
      <mi>n</mi>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <eq></eq>
     <apply>
      <times></times>
      <ci>d</ci>
      <ci>e</ci>
      <ci>f</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ψ</ci>
      <list>
       <ci>k</ci>
       <ci>m</ci>
      </list>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>h</ci>
       <ci>k</ci>
      </apply>
      <times></times>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>M</ci>
         <ci>k</ci>
        </apply>
        <ci>m</ci>
       </apply>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \psi_{k,m}[n]\stackrel{def}{=}h_{k}^{*}[M_{k}m-n]
  </annotation>
 </semantics>
</math>

.</p>

<p>Considering the definition of analysis/synthesis sides we can verify that <a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> 

<math display="inline" id="Filter_bank:24">
 <semantics>
  <mrow>
   <mrow>
    <mover accent="true">
     <mi>x</mi>
     <mo stretchy="false">^</mo>
    </mover>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>n</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mo largeop="true" symmetric="true">∑</mo>
     <mrow>
      <mrow>
       <mn>1</mn>
       <mo>≤</mo>
       <mi>k</mi>
       <mo>≤</mo>
       <mi>K</mi>
      </mrow>
      <mo>,</mo>
      <mrow>
       <mi>m</mi>
       <mo>∈</mo>
       <msup>
        <mi>Z</mi>
        <mn>2</mn>
       </msup>
      </mrow>
     </mrow>
    </msub>
    <mrow>
     <msub>
      <mi>c</mi>
      <mi>k</mi>
     </msub>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>m</mi>
      <mo stretchy="false">]</mo>
     </mrow>
     <msub>
      <mi>ψ</mi>
      <mrow>
       <mi>k</mi>
       <mo>,</mo>
       <mi>m</mi>
      </mrow>
     </msub>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>n</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <ci>normal-^</ci>
      <ci>x</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <csymbol cd="ambiguous">formulae-sequence</csymbol>
       <apply>
        <and></and>
        <apply>
         <leq></leq>
         <cn type="integer">1</cn>
         <ci>k</ci>
        </apply>
        <apply>
         <leq></leq>
         <share href="#.cmml">
         </share>
         <ci>K</ci>
        </apply>
       </apply>
       <apply>
        <in></in>
        <ci>m</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>Z</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>c</ci>
       <ci>k</ci>
      </apply>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <ci>m</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ψ</ci>
       <list>
        <ci>k</ci>
        <ci>m</ci>
       </list>
      </apply>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{x}[n]=\sum_{1\leq k\leq K,m\in Z^{2}}c_{k}[m]\psi_{k,m}[n]
  </annotation>
 </semantics>
</math>

<br/>
and for reconstruction part 

<math display="inline" id="Filter_bank:25">
 <semantics>
  <mrow>
   <mrow>
    <mi>x</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>n</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mover accent="true">
    <mrow>
     <mi>x</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>n</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">^</mo>
   </mover>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>x</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-^</ci>
     <apply>
      <times></times>
      <ci>x</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x[n]=\hat{x[n]}
  </annotation>
 </semantics>
</math>

.<br/>
In other words, the analysis filter bank calculate the inner product of the input signal and the vector from analysis set. Moreover, the reconstructed signal in the combination of the vectors from the synthesis set, and the combination coefficients of the computed inner products, meaning that 

<math display="inline" id="Filter_bank:26">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>n</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>x</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x[n]
  </annotation>
 </semantics>
</math>

</p>

<p>If there is no loss in the decomposition and the subsequent reconstruction, the filter bank is called <em>perfect reconstruction</em>. (in that case we would have 

<math display="inline" id="Filter_bank:27">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>y</mi>
     <mi>j</mi>
    </msub>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>n</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <ci>j</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{j}[n],
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>

<p>Figure shows a general multidimensional filter bank with N channels and a common sampling matrix M. The analysis part transforms the input signal 

<math display="inline" id="Filter_bank:28">
 <semantics>
  <mrow>
   <mi>j</mi>
   <mo>=</mo>
   <mrow>
    <mn>0</mn>
    <mo>,</mo>
    <mn>1</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mrow>
     <mi>N</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>j</ci>
    <list>
     <cn type="integer">0</cn>
     <cn type="integer">1</cn>
     <ci>normal-…</ci>
     <apply>
      <minus></minus>
      <ci>N</ci>
      <cn type="integer">1</cn>
     </apply>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   j=0,1,...,N-1
  </annotation>
 </semantics>
</math>

 into N filtered and downsampled outputs 

<math display="inline" id="Filter_bank:29">
 <semantics>
  <mrow>
   <msub>
    <mi>y</mi>
    <mi>j</mi>
   </msub>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>n</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <ci>j</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{j}[n]
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Filter_bank:30">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>n</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>x</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x[n]
  </annotation>
 </semantics>
</math>

. The synthesis part recovers the original signal from 

<math display="inline" id="Filter_bank:31">
 <semantics>
  <mrow>
   <mrow>
    <mi>x</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mover>
    <mo movablelimits="false">=</mo>
    <mrow>
     <mi>d</mi>
     <mi>e</mi>
     <mi>f</mi>
    </mrow>
   </mover>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>X</mi>
       <mn>0</mn>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>z</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <mrow>
      <msub>
       <mi>X</mi>
       <mrow>
        <mrow>
         <mo stretchy="false">|</mo>
         <mi>M</mi>
         <mo stretchy="false">|</mo>
        </mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>z</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>T</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <eq></eq>
     <apply>
      <times></times>
      <ci>d</ci>
      <ci>e</ci>
      <ci>f</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>x</ci>
     <ci>z</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <vector>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>X</ci>
        <cn type="integer">0</cn>
       </apply>
       <ci>z</ci>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>X</ci>
        <apply>
         <minus></minus>
         <apply>
          <abs></abs>
          <ci>M</ci>
         </apply>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>z</ci>
      </apply>
     </vector>
     <ci>T</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x(z)\stackrel{def}{=}(X_{0}(z),...,X_{|M|-1}(z))^{T}
  </annotation>
 </semantics>
</math>

 by upsampling and filtering. This kind of set up is used in many applications such as <a href="subband_coding" title="wikilink">subband coding</a>, multichannel acquisition, and <a href="wavelet_transforms" title="wikilink">discrete wavelet transforms</a>.</p>
<h3 id="perfect-reconstruction-filter-banks">Perfect Reconstruction Filter Banks</h3>

<p>We can use polyphase representation, so input signal 

<math display="inline" id="Filter_bank:32">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>y</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>z</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mover>
     <mo movablelimits="false">=</mo>
     <mrow>
      <mi>d</mi>
      <mi>e</mi>
      <mi>f</mi>
     </mrow>
    </mover>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>Y</mi>
        <mn>0</mn>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>z</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>,</mo>
      <mi mathvariant="normal">…</mi>
      <mo>,</mo>
      <mrow>
       <msub>
        <mi>Y</mi>
        <mrow>
         <mrow>
          <mo stretchy="false">|</mo>
          <mi>N</mi>
          <mo stretchy="false">|</mo>
         </mrow>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>z</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>T</mi>
    </msup>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <eq></eq>
     <apply>
      <times></times>
      <ci>d</ci>
      <ci>e</ci>
      <ci>f</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>y</ci>
     <ci>z</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <vector>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Y</ci>
        <cn type="integer">0</cn>
       </apply>
       <ci>z</ci>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Y</ci>
        <apply>
         <minus></minus>
         <apply>
          <abs></abs>
          <ci>N</ci>
         </apply>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>z</ci>
      </apply>
     </vector>
     <ci>T</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y(z)\stackrel{def}{=}(Y_{0}(z),...,Y_{|N|-1}(z))^{T}.
  </annotation>
 </semantics>
</math>

 can be represented by a vector of its polyphase components 

<math display="inline" id="Filter_bank:33">
 <semantics>
  <mrow>
   <mrow>
    <mi>y</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>H</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>x</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>y</ci>
     <ci>z</ci>
    </apply>
    <apply>
     <times></times>
     <ci>H</ci>
     <ci>z</ci>
     <ci>x</ci>
     <ci>z</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y(z)=H(z)x(z)
  </annotation>
 </semantics>
</math>

. Denote 

<math display="inline" id="Filter_bank:34">
 <semantics>
  <mrow>
   <msub>
    <mi>H</mi>
    <mrow>
     <mi>i</mi>
     <mo>,</mo>
     <mi>j</mi>
    </mrow>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>z</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>H</ci>
     <list>
      <ci>i</ci>
      <ci>j</ci>
     </list>
    </apply>
    <ci>z</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{i,j}(z)
  </annotation>
 </semantics>
</math>

<br/>
So we would have 

<math display="inline" id="Filter_bank:35">
 <semantics>
  <mrow>
   <msub>
    <mi>H</mi>
    <mi>i</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>z</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>H</ci>
     <ci>i</ci>
    </apply>
    <ci>z</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{i}(z)
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Filter_bank:36">
 <semantics>
  <mrow>
   <mrow>
    <mover accent="true">
     <mi>x</mi>
     <mo stretchy="false">^</mo>
    </mover>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>G</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>y</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <ci>normal-^</ci>
      <ci>x</ci>
     </apply>
     <ci>z</ci>
    </apply>
    <apply>
     <times></times>
     <ci>G</ci>
     <ci>z</ci>
     <ci>y</ci>
     <ci>z</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{x}(z)=G(z)y(z)
  </annotation>
 </semantics>
</math>

 denotes the jth polyphase component of the filter 

<math display="inline" id="Filter_bank:37">
 <semantics>
  <mrow>
   <mrow>
    <mover accent="true">
     <mi>x</mi>
     <mo stretchy="false">^</mo>
    </mover>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mover>
    <mo movablelimits="false">=</mo>
    <mrow>
     <mi>d</mi>
     <mi>e</mi>
     <mi>f</mi>
    </mrow>
   </mover>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mover accent="true">
        <mi>X</mi>
        <mo stretchy="false">^</mo>
       </mover>
       <mn>0</mn>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>z</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <mrow>
      <msub>
       <mover accent="true">
        <mi>X</mi>
        <mo stretchy="false">^</mo>
       </mover>
       <mrow>
        <mrow>
         <mo stretchy="false">|</mo>
         <mi>M</mi>
         <mo stretchy="false">|</mo>
        </mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>z</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>T</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <eq></eq>
     <apply>
      <times></times>
      <ci>d</ci>
      <ci>e</ci>
      <ci>f</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <ci>normal-^</ci>
      <ci>x</ci>
     </apply>
     <ci>z</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <vector>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <ci>normal-^</ci>
         <ci>X</ci>
        </apply>
        <cn type="integer">0</cn>
       </apply>
       <ci>z</ci>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <ci>normal-^</ci>
         <ci>X</ci>
        </apply>
        <apply>
         <minus></minus>
         <apply>
          <abs></abs>
          <ci>M</ci>
         </apply>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>z</ci>
      </apply>
     </vector>
     <ci>T</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{x}(z)\stackrel{def}{=}(\hat{X}_{0}(z),...,\hat{X}_{|M|-1}(z))^{T}
  </annotation>
 </semantics>
</math>

.<br/>
Similarly, for the output signal we would have 

<math display="inline" id="Filter_bank:38">
 <semantics>
  <mrow>
   <msub>
    <mi>G</mi>
    <mrow>
     <mi>i</mi>
     <mo>,</mo>
     <mi>j</mi>
    </mrow>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>z</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>G</ci>
     <list>
      <ci>i</ci>
      <ci>j</ci>
     </list>
    </apply>
    <ci>z</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G_{i,j}(z)
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Filter_bank:39">
 <semantics>
  <mrow>
   <mrow>
    <mi>x</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mover accent="true">
     <mi>x</mi>
     <mo stretchy="false">^</mo>
    </mover>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>x</ci>
     <ci>z</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <ci>normal-^</ci>
      <ci>x</ci>
     </apply>
     <ci>z</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x(z)=\hat{x}(z)
  </annotation>
 </semantics>
</math>

. Also G is a matrix where 

<math display="inline" id="Filter_bank:40">
 <semantics>
  <mrow>
   <msub>
    <mi>I</mi>
    <mrow>
     <mo stretchy="false">|</mo>
     <mi>M</mi>
     <mo stretchy="false">|</mo>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <mi>G</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>H</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>I</ci>
     <apply>
      <abs></abs>
      <ci>M</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>G</ci>
     <ci>z</ci>
     <ci>H</ci>
     <ci>z</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I_{|M|}=G(z)H(z)
  </annotation>
 </semantics>
</math>

 denotes ith polyphase component of the jth synthesis filter Gj(z).<br/>
The filter bank has perfect reconstruction if 

<math display="inline" id="Filter_bank:41">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <msub>
    <mi>H</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>H</mi>
    <mi>N</mi>
   </msub>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>H</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>H</ci>
     <ci>N</ci>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{H_{1},...,H_{N}\}
  </annotation>
 </semantics>
</math>

 for any input, or equivalently 

<math display="inline" id="Filter_bank:42">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <msub>
    <mi>G</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>G</mi>
    <mi>N</mi>
   </msub>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>G</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>G</ci>
     <ci>N</ci>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{G_{1},...,G_{N}\}
  </annotation>
 </semantics>
</math>

 which means that G(z) is a left inverse of H(z).</p>
<h2 id="multidimensional-filter-design">Multidimensional Filter Design</h2>

<p>1-D filter banks have been well developed until today. However, many signals, such as image, video, 3D sound, radar, sonar, are multidimensional, and require the design of multidimensional filter banks.</p>

<p>With the fast development of communication technology, signal processing system needs more room to store data during the processing, transmission and reception. In order to reduce the data to be processed, save storage and lower the complexity, multirate sampling techniques were introduced to achieve these goals. Filter banks can be used in various areas, such as image coding, voice coding, radar and so on.</p>

<p>Many 1D filter issues were well studied and researchers proposed many 1D filter bank design approaches. But there are still many multidimensional filter bank design problems that need to be solved.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> Some methods may not well reconstruct the signal, some methods are complex and hard to implement.  Compared to a 1D filter bank, an MD filter bank depends highly on sampling patterns. Generally, we cannot get a multidimensional filter bank just from the extension of the 1D case since when the number of variables change, the nature of the problem will change a lot.</p>

<p> A filter bank consists of an analysis stage and a synthesis stage. Each stage consists of a set of filters in parallel. The filter bank design is the design of the filters in the analysis and synthesis stages. The analysis filters divide the signal into overlapping or non-overlapping subbands depending on the application requirements. The synthesis filters should be designed to reconstruct the input signal back from the subbands when the outputs of these filters are combined together. Processing is typically performed after the analysis stage. These filter banks can be designed as <a href="Infinite_impulse_response" title="wikilink">Infinite impulse response</a> (IIR) or <a href="Finite_impulse_response" title="wikilink">Finite impulse response</a> (FIR). In order to reduce the data rate, downsampling and upsampling are performed in the analysis and synthesis stages, respectively.</p>
<h3 id="existing-approaches">Existing Approaches</h3>

<p>Below are several approaches on the design of multidimensional filter banks. For more details, please check the <strong>ORIGINAL</strong> references.</p>
<h3 id="channel-multidimensional-perfect-reconstruction-pr-filter-banks">2-Channel Multidimensional perfect reconstruction (PR) filter banks:<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></h3>

<p>In real life, we always want to reconstruct the divided signal back to the original one, which makes PR filter banks very important. Let H(<strong>z</strong>) be the transfer function of a filter. The size of the filter is defined as the order of corresponding polynomial in every dimension. The symmetry or anti-symmetry of a polynomial determines the linear phase property of the corresponding filter and is related to its size. Like the 1D case, the aliasing term A(z) and transfer function T(z) for a 2 channel filter bank are:</p>

<p>A(<strong>z</strong>)=1/2(H<sub>0</sub>(-<strong>z</strong>) F<sub>0</sub> (<strong>z</strong>)+H<sub>1</sub> (-<strong>z</strong>) F<sub>1</sub> (<strong>z</strong>)); T(<strong>z</strong>)=1/2(H<sub>0</sub> (<strong>z</strong>) F<sub>0</sub> (<strong>z</strong>)+H<sub>1</sub> (<strong>z</strong>) F<sub>1</sub> (<strong>z</strong>)), where H<sub>0</sub> and H<sub>1</sub> are decomposition filters, and F<sub>0</sub> and F<sub>1</sub> are reconstruction filters.</p>

<p>The input signal can be perfectly reconstructed if the alias term is cancelled and T(<strong>z</strong>) equal to a monomial. So the necessary condition is that T'(<strong>z</strong>) is generally symmetric and of an odd-by-odd size. Linear phase PR filters are very useful for image processing. This 2-Channel filter bank is relatively easy to implement. But 2 channels sometimes are not enough for use. 2-channel filter banks can be cascaded to generate multi-channel filter banks.</p>
<figure><b>(Figure)</b>
<figcaption>Multidimensional Analysis Filter Banks</figcaption>
</figure>
<h3 id="multidimensional-directional-filter-banks-and-surfacelets">Multidimensional Directional Filter Banks and Surfacelets:<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></h3>

<p>M-dimensional directional filter banks (MDFB) are a family of filter banks that can achieve the directional decomposition of arbitrary M-dimensional signals with a simple and efficient tree-structured construction. It has many distinctive properties like: directional decomposition, efficient tree construction, angular resolution and perfect reconstruction. In the general M-dimensional case, the ideal frequency supports of the MDFB are hypercube-based hyperpyramids. The first level of decomposition for MDFB is achieved by an N-channel undecimated filter bank, whose component filters are M-D “hourglass”-shaped filter aligned with the w<sub>1</sub>,…,w<sub>M</sub> respectively axes. After that, the input signal is further decomposed by a series of 2-D iteratively resampled checkerboard filter banks <em>IRC</em><sub><em>li</em></sub><sup>(<em>Li</em>)</sup>(i=2,3,...,M), where <em>IRC</em><sub><em>li</em></sub><sup>(<em>Li</em>)</sup>operates on 2-D slices of the input signal represented by the dimension pair (n<sub>1</sub>,n<sub>i</sub>) and superscript (Li) means the levels of decomposition for the ith level filter bank. Note that, starting from the second level, we attach an IRC filter bank to each output channel from the previous level, and hence the entire filter has a total of 2<sup>(<em>L</em><sub>1</sub>+...+<em>L</em><sub>N</sub>)</sup> output channels.</p>
<h3 id="multidimensional-oversampled-filter-banks">Multidimensional Oversampled Filter Banks:<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a></h3>
<figure><b>(Figure)</b>
<figcaption>Multidimensional Synthesis Filter Banks</figcaption>
</figure>

<p>Oversampled filter banks are multirate filter banks where the number of output samples at the analysis stage is larger than the number of input samples. It is proposed for robust applications. One particular class of oversampled filter banks is nonsubsampled filter banks without downsampling or upsampling. The perfect reconstruction condition for an oversampled filter bank can be stated as a matrix inverse problem in the polyphase domain.</p>

<p>For IIR oversampled filter bank, perfect reconstruction have been studied in Wolovich<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> and Kailath.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> in the context of control theory. While for FIR oversampled filter bank we have to use different strategy for 1-D and M-D. FIR filter are more popular since it is easier to implement. For 1-D oversampled FIR filter banks, the Euclidean algorithm plays a key role in the matrix inverse problem.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> However, the Euclidean algorithm fails for multidimensional (MD) filters. For MD filter, we can convert the FIR representation into a polynomial representation.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a> And then use <a href="Algebraic_geometry" title="wikilink">Algebraic geometry</a> and Gröbner bases to get the framework and the reconstruction condition of the multidimensional oversampled filter banks.<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a></p>
<h3 id="multidimentional-nonsubsampled-fir-filter-banks">Multidimentional Nonsubsampled FIR Filter Banks:<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a></h3>

<p>Nonsubsampled filter banks are particular oversampled filter banks without downsampling or upsampling. The perfect reconstruction condition for nonsubsampled FIR filter banks leads to a vector inverse problem: the analysis filters 

<math display="inline" id="Filter_bank:43">
 <semantics>
  <mrow>
   <mi>H</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>z</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>H</ci>
    <ci>z</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H(z)
  </annotation>
 </semantics>
</math>

 are given and FIR, and the goal is to find a set of FIR synthesis filters 

<math display="inline" id="Filter_bank:44">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>z</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>G</ci>
    <ci>z</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G(z)
  </annotation>
 </semantics>
</math>

 satisfying.</p>
<h3 id="using-gröbner-basis">Using <a href="Gröbner_Basis" title="wikilink">Gröbner Basis</a>:<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a></h3>
<figure><b>(Figure)</b>
<figcaption>Multidimensional M_channel Filter Banks</figcaption>
</figure>

<p>As multidimensional filter banks can be represented by multivariate rational matrices, this method is a very effective tool that can be used to deal with the multidimensional filter banks.</p>

<p>In Charo,<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a> a multivariate polynomial matrix-factorization algorithm is introduced and discussed. The most common problem is the multidimensional filter banks for perfect reconstruction. This paper talks about the method to achieve this goal that satisfies the constrained condition of linear phase.</p>

<p>According to the description of the paper, some new results in factorization are discussed and being applied to issues of multidimensional linear phase perfect reconstruction finite-impulse response filter banks. The basic concept of Gröbner Bases is given in Adams.<a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a></p>

<p>This approach based on multivariate matrix factorization can be used in different areas. The algorithmic theory of polynomial ideals and modules can be modified to address problems in processing, compression, transmission, and decoding of multidimensional signals.</p>

<p>The general multidimensional filter bank (Figure 7) can be represented by a pair of analysis and synthesis polyphase matrices 

<math display="inline" id="Filter_bank:45">
 <semantics>
  <mrow>
   <mi>N</mi>
   <mo>×</mo>
   <mi>M</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>N</ci>
    <ci>M</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N\times M
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Filter_bank:46">
 <semantics>
  <mrow>
   <mi>M</mi>
   <mo>×</mo>
   <mi>N</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>M</ci>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M\times N
  </annotation>
 </semantics>
</math>

 of size 

<math display="inline" id="Filter_bank:47">
 <semantics>
  <mrow>
   <mi>M</mi>
   <mover>
    <mo movablelimits="false">=</mo>
    <mrow>
     <mi>d</mi>
     <mi>e</mi>
     <mi>f</mi>
    </mrow>
   </mover>
   <mrow>
    <mo stretchy="false">|</mo>
    <mi>M</mi>
    <mo stretchy="false">|</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <eq></eq>
     <apply>
      <times></times>
      <ci>d</ci>
      <ci>e</ci>
      <ci>f</ci>
     </apply>
    </apply>
    <ci>M</ci>
    <apply>
     <abs></abs>
     <ci>M</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M\stackrel{def}{=}|M|
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Filter_bank:48">
 <semantics>
  <mrow>
   <mi>H</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>z</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>H</ci>
    <ci>z</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H(z)
  </annotation>
 </semantics>
</math>

, where N is the number of channels and 

<math display="inline" id="Filter_bank:49">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>z</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>G</ci>
    <ci>z</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G(z)
  </annotation>
 </semantics>
</math>

 is the absolute value of the determinant of the sampling matrix. Also 

<math display="inline" id="Filter_bank:50">
 <semantics>
  <mrow>
   <mrow>
    <mi>F</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mo largeop="true" symmetric="true">∑</mo>
     <mrow>
      <mi>k</mi>
      <mo>∈</mo>
      <msup>
       <mi>Z</mi>
       <mi>d</mi>
      </msup>
     </mrow>
    </msub>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>k</mi>
      <mo stretchy="false">]</mo>
     </mrow>
     <msup>
      <mi>z</mi>
      <mi>k</mi>
     </msup>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mo largeop="true" symmetric="true">∑</mo>
     <mrow>
      <mi>k</mi>
      <mo>∈</mo>
      <msup>
       <mi>Z</mi>
       <mi>d</mi>
      </msup>
     </mrow>
    </msub>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <msub>
       <mi>k</mi>
       <mn>1</mn>
      </msub>
      <mo>,</mo>
      <mi mathvariant="normal">…</mi>
      <mo>,</mo>
      <msub>
       <mi>k</mi>
       <mi>d</mi>
      </msub>
      <mo stretchy="false">]</mo>
     </mrow>
     <msubsup>
      <mi>z</mi>
      <mn>1</mn>
      <msub>
       <mi>k</mi>
       <mn>1</mn>
      </msub>
     </msubsup>
     <mi mathvariant="normal">…</mi>
     <msubsup>
      <mi>z</mi>
      <mi>d</mi>
      <msub>
       <mi>k</mi>
       <mi>d</mi>
      </msub>
     </msubsup>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>F</ci>
      <ci>z</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <in></in>
        <ci>k</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>Z</ci>
         <ci>d</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>f</ci>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <ci>k</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>z</ci>
        <ci>k</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <in></in>
        <ci>k</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>Z</ci>
         <ci>d</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>f</ci>
       <list>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>k</ci>
         <cn type="integer">1</cn>
        </apply>
        <ci>normal-…</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>k</ci>
         <ci>d</ci>
        </apply>
       </list>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>z</ci>
         <cn type="integer">1</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>k</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>normal-…</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>z</ci>
         <ci>d</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>k</ci>
         <ci>d</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F(z)=\sum_{k\in Z^{d}}f[k]z^{k}=\sum_{k\in Z^{d}}f[k_{1},...,k_{d}]z_{1}^{k_{1%
}}...z_{d}^{k_{d}}
  </annotation>
 </semantics>
</math>

 and 

<math display="block" id="Filter_bank:51">
 <semantics>
  <mrow>
   <mrow>
    <mi>G</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>H</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msub>
    <mi>I</mi>
    <mrow>
     <mo stretchy="false">|</mo>
     <mi>M</mi>
     <mo stretchy="false">|</mo>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>G</ci>
     <ci>z</ci>
     <ci>H</ci>
     <ci>z</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>I</ci>
     <apply>
      <abs></abs>
      <ci>M</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G(z)H(z)=I_{|M|}
  </annotation>
 </semantics>
</math>

 are the z-transform of the polyphase components of the analysis and synthesis filters. Therefore, they are <em>multivariate Laurent polynomials</em>, which have the general form:<br/>


<math display="inline" id="Filter_bank:52">
 <semantics>
  <mrow>
   <mrow>
    <mi>G</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>H</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msub>
    <mi>I</mi>
    <mrow>
     <mo stretchy="false">|</mo>
     <mi>M</mi>
     <mo stretchy="false">|</mo>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>G</ci>
     <ci>z</ci>
     <ci>H</ci>
     <ci>z</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>I</ci>
     <apply>
      <abs></abs>
      <ci>M</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G(z)H(z)=I_{|M|}
  </annotation>
 </semantics>
</math>

. Laurent polynomial matrix equation need to be solve to design perfect reconstruction filter banks

<math display="inline" id="Filter_bank:53">
 <semantics>
  <mrow>
   <mrow>
    <mi>M</mi>
    <mi>o</mi>
    <mi>d</mi>
    <mi>u</mi>
    <mi>l</mi>
    <mi>e</mi>
    <mrow>
     <mo>{</mo>
     <mrow>
      <msub>
       <mi>h</mi>
       <mn>1</mn>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>z</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <mrow>
      <msub>
       <mi>h</mi>
       <mi>N</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>z</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>}</mo>
    </mrow>
   </mrow>
   <mover>
    <mo movablelimits="false">=</mo>
    <mrow>
     <mi>d</mi>
     <mi>e</mi>
     <mi>f</mi>
    </mrow>
   </mover>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mrow>
      <msub>
       <mi>c</mi>
       <mn>1</mn>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>z</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <msub>
       <mi>h</mi>
       <mn>1</mn>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>z</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mi mathvariant="normal">…</mi>
     <mo>+</mo>
     <mrow>
      <msub>
       <mi>c</mi>
       <mi>N</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>z</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <msub>
       <mi>h</mi>
       <mi>N</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>z</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <eq></eq>
     <apply>
      <times></times>
      <ci>d</ci>
      <ci>e</ci>
      <ci>f</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>M</ci>
     <ci>o</ci>
     <ci>d</ci>
     <ci>u</ci>
     <ci>l</ci>
     <ci>e</ci>
     <set>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>h</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>z</ci>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>h</ci>
        <ci>N</ci>
       </apply>
       <ci>z</ci>
      </apply>
     </set>
    </apply>
    <set>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>c</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>z</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>h</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>z</ci>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>c</ci>
        <ci>N</ci>
       </apply>
       <ci>z</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>h</ci>
        <ci>N</ci>
       </apply>
       <ci>z</ci>
      </apply>
     </apply>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Module\left\{h_{1}(z),...,h_{N}(z)\right\}\stackrel{def}{=}\{c_{1}(z)h_{1}(z)+%
...+c_{N}(z)h_{N}(z)\}
  </annotation>
 </semantics>
</math>

.<br/>
In the multidimentonal case with multivariate polynomials we need to use the theory and algorithms of <em>Grobner bases</em>(developed by Buchberger)<a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a></p>

<p>"Grobner bases" can be used to characterizing perfect reconstruction multidimensional filter banks, but it first need to extend from polynomial matrices to <a href="Laurent_polynomial" title="wikilink">Laurent polynomial</a> matrices.<a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a><a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a></p>

<p>The Grobner basis computation can be considered equivalently as Gaussian elimination for solving the polynomial matrix equation 

<math display="inline" id="Filter_bank:54">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>:</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>c</mi>
      <mn>1</mn>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>z</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mrow>
     <msub>
      <mi>c</mi>
      <mi>N</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>z</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <csymbol cd="latexml">absent</csymbol>
    <list>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>c</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>z</ci>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>c</ci>
       <ci>N</ci>
      </apply>
      <ci>z</ci>
     </apply>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   :c_{1}(z),...,c_{N}(z)
  </annotation>
 </semantics>
</math>

. If we have set of polynomial vectors 

<math display="inline" id="Filter_bank:55">
 <semantics>
  <mrow>
   <mo>{</mo>
   <mrow>
    <msub>
     <mi>b</mi>
     <mn>1</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <mrow>
    <msub>
     <mi>b</mi>
     <mi>N</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>b</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>z</ci>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>b</ci>
      <ci>N</ci>
     </apply>
     <ci>z</ci>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left\{b_{1}(z),...,b_{N}(z)\right\}
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Filter_bank:56">
 <semantics>
  <mrow>
   <mo>{</mo>
   <mrow>
    <msub>
     <mi>h</mi>
     <mn>1</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <mrow>
    <msub>
     <mi>h</mi>
     <mi>N</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>h</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>z</ci>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>h</ci>
      <ci>N</ci>
     </apply>
     <ci>z</ci>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left\{h_{1}(z),...,h_{N}(z)\right\}
  </annotation>
 </semantics>
</math>

 are polynomials.<br/>
The Module is analogous to the <em>span</em> of a set of vectors in linear algebra. The theory of Grobner bases implies that the Module has a unique reduced Grobner basis for a given order of power products in polynomials.</p>

<p>If we define the Grobner basis as 

<math display="inline" id="Filter_bank:57">
 <semantics>
  <mrow>
   <msub>
    <mi>b</mi>
    <mi>i</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>z</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>b</ci>
     <ci>i</ci>
    </apply>
    <ci>z</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b_{i}(z)
  </annotation>
 </semantics>
</math>

, it can be obtained from 

<math display="inline" id="Filter_bank:58">
 <semantics>
  <mrow>
   <msub>
    <mi>h</mi>
    <mi>j</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>z</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>h</ci>
     <ci>j</ci>
    </apply>
    <ci>z</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h_{j}(z)
  </annotation>
 </semantics>
</math>

 by a finite sequence of reduction (division) steps.</p>

<p>Using reverse engineering, we can compute the basis vectors 

<math display="inline" id="Filter_bank:59">
 <semantics>
  <mrow>
   <mi>K</mi>
   <mo>×</mo>
   <mi>N</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>K</ci>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K\times N
  </annotation>
 </semantics>
</math>

 in terms of the original vectors 

<math display="inline" id="Filter_bank:60">
 <semantics>
  <mrow>
   <msub>
    <mi>W</mi>
    <mrow>
     <mi>i</mi>
     <mi>j</mi>
    </mrow>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>z</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>W</ci>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>j</ci>
     </apply>
    </apply>
    <ci>z</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W_{ij}(z)
  </annotation>
 </semantics>
</math>

 through a 

<math display="inline" id="Filter_bank:61">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>b</mi>
      <mi>i</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>z</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <mi>j</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>N</mi>
     </msubsup>
     <mrow>
      <msub>
       <mi>W</mi>
       <mrow>
        <mi>i</mi>
        <mi>j</mi>
       </mrow>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>z</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <msub>
       <mi>h</mi>
       <mi>j</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>z</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>i</mi>
    <mo>=</mo>
    <mrow>
     <mn>1</mn>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <mi>K</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <ci>i</ci>
      </apply>
      <ci>z</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>j</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>N</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>W</ci>
        <apply>
         <times></times>
         <ci>i</ci>
         <ci>j</ci>
        </apply>
       </apply>
       <ci>z</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>h</ci>
        <ci>j</ci>
       </apply>
       <ci>z</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <ci>i</ci>
     <list>
      <cn type="integer">1</cn>
      <ci>normal-…</ci>
      <ci>K</ci>
     </list>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b_{i}(z)=\sum_{j=1}^{N}W_{ij}(z)h_{j}(z),i=1,...,K
  </annotation>
 </semantics>
</math>

 transformation matrix 

<math display="inline" id="Filter_bank:62">
 <semantics>
  <mrow>
   <msub>
    <mi>D</mi>
    <mn>1</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo>[</mo>
    <mtable>
     <mtr>
      <mtd columnalign="center">
       <mn>2</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>1</mn>
      </mtd>
     </mtr>
    </mtable>
    <mo>]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>D</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <matrix>
      <matrixrow>
       <cn type="integer">2</cn>
       <cn type="integer">0</cn>
      </matrixrow>
      <matrixrow>
       <cn type="integer">0</cn>
       <cn type="integer">1</cn>
      </matrixrow>
     </matrix>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D_{1}=\left[\begin{array}[]{cc}2&0\\
0&1\end{array}\right]
  </annotation>
 </semantics>
</math>

 as<br/>


<math display="inline" id="Filter_bank:63">
 <semantics>
  <mrow>
   <msub>
    <mi>H</mi>
    <mn>0</mn>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>ξ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>H</ci>
     <cn type="integer">0</cn>
    </apply>
    <ci>ξ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{0}(\xi)
  </annotation>
 </semantics>
</math>

</p>
<h3 id="mapping-based-multidimensional-filter-banks">Mapping-Based Multidimensional Filter Banks</h3>

<p>Designing filters with good frequency responses is challenging via Grobner bases approach.<br/>
Mapping based design in popularly used to design nonseparable multidimensional filter banks with good frequency responses.<a class="footnoteRef" href="#fn23" id="fnref23"><sup>23</sup></a><a class="footnoteRef" href="#fn24" id="fnref24"><sup>24</sup></a></p>

<p>The mapping approaches have certain restrictions on the kind of filters; However, It brings many important advantages, such as efficient implementation via lifting/ladder structures. Here we provide an example of two-channel filter banks in 2D with sampling matrix<br/>


<math display="inline" id="Filter_bank:64">
 <semantics>
  <mrow>
   <msub>
    <mi>G</mi>
    <mn>0</mn>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>ξ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>G</ci>
     <cn type="integer">0</cn>
    </apply>
    <ci>ξ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G_{0}(\xi)
  </annotation>
 </semantics>
</math>

 We would have several possible choices of ideal frequency responses of the channel filter 

<math display="inline" id="Filter_bank:65">
 <semantics>
  <mrow>
   <msub>
    <mi>H</mi>
    <mn>1</mn>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>ξ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>H</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>ξ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{1}(\xi)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Filter_bank:66">
 <semantics>
  <mrow>
   <msub>
    <mi>G</mi>
    <mn>1</mn>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>ξ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>G</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>ξ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G_{1}(\xi)
  </annotation>
 </semantics>
</math>

. (Note that the other two filters 

<math display="inline" id="Filter_bank:67">
 <semantics>
  <msub>
   <mi>D</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>D</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D_{1}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Filter_bank:68">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>H</mi>
      <mn>0</mn>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>z</mi>
       <mn>1</mn>
      </msub>
      <mo>,</mo>
      <msub>
       <mi>z</mi>
       <mn>2</mn>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
     <msub>
      <mi>G</mi>
      <mn>0</mn>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>z</mi>
       <mn>1</mn>
      </msub>
      <mo>,</mo>
      <msub>
       <mi>z</mi>
       <mn>2</mn>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>H</mi>
      <mn>0</mn>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mo>-</mo>
       <msub>
        <mi>z</mi>
        <mn>1</mn>
       </msub>
      </mrow>
      <mo>,</mo>
      <msub>
       <mi>z</mi>
       <mn>2</mn>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
     <msub>
      <mi>G</mi>
      <mn>0</mn>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mo>-</mo>
       <msub>
        <mi>z</mi>
        <mn>1</mn>
       </msub>
      </mrow>
      <mo>,</mo>
      <msub>
       <mi>z</mi>
       <mn>2</mn>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>H</ci>
       <cn type="integer">0</cn>
      </apply>
      <interval closure="open">
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>z</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>z</ci>
        <cn type="integer">2</cn>
       </apply>
      </interval>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>G</ci>
       <cn type="integer">0</cn>
      </apply>
      <interval closure="open">
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>z</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>z</ci>
        <cn type="integer">2</cn>
       </apply>
      </interval>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>H</ci>
       <cn type="integer">0</cn>
      </apply>
      <interval closure="open">
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>z</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>z</ci>
        <cn type="integer">2</cn>
       </apply>
      </interval>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>G</ci>
       <cn type="integer">0</cn>
      </apply>
      <interval closure="open">
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>z</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>z</ci>
        <cn type="integer">2</cn>
       </apply>
      </interval>
     </apply>
    </apply>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{0}(z_{1},z_{2})G_{0}(z_{1},z_{2})+H_{0}(-z_{1},z_{2})G_{0}(-z_{1},z_{2})=2
  </annotation>
 </semantics>
</math>

 are supported on complementary regions.)<br/>
All the frequency regions in Figure can be critically sampled by the rectangular lattice spanned by 

<math display="block" id="Filter_bank:69">
 <semantics>
  <mrow>
   <mrow>
    <mi>H</mi>
    <msup>
     <mi>H</mi>
     <mi>T</mi>
    </msup>
   </mrow>
   <mo>=</mo>
   <msub>
    <mi>I</mi>
    <mi>n</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>H</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>H</ci>
      <ci>T</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>I</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   HH^{T}=I_{n}
  </annotation>
 </semantics>
</math>

. <br/>
So imagine the filter bank achieves perfect reconstruction with FIR filters. Then from the polyphase domain characterization it follows that the filters H1(z) and G1(z) are completely specified by H0(z) and G0(z), respectively. Therefore, we need to design H0(x) and G0(z) which have desired frequency responses and satisfy the polyphase-domain conditions. 

<math display="inline" id="Filter_bank:70">
 <semantics>
  <msup>
   <mn>2</mn>
   <mi>l</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <ci>l</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{l}
  </annotation>
 </semantics>
</math>

<br/>
There are different mapping technique that can be used to get above result.<a class="footnoteRef" href="#fn25" id="fnref25"><sup>25</sup></a></p>
<h3 id="filter-banks-design-in-the-frequency-domain">Filter Banks Design in the Frequency Domain</h3>

<p>If we do not want perfect reconstruction filter banks using FIR filters, the design problem can be simplified by working in frequency domain instead of using FIR filters.<a class="footnoteRef" href="#fn26" id="fnref26"><sup>26</sup></a><a class="footnoteRef" href="#fn27" id="fnref27"><sup>27</sup></a><br/>
Note that the frequency domain method is not limited to the design of nonsubsampled filter banks (read <a class="footnoteRef" href="#fn28" id="fnref28"><sup>28</sup></a>).</p>
<h3 id="direct-frequency-domain-optimization">Direct Frequency-Domain Optimization:<a class="footnoteRef" href="#fn29" id="fnref29"><sup>29</sup></a></h3>

<p>Many of the existing methods for designing 2-channel filter banks are based on transformation of variable technique. For example, McClellan transform can be used to design 1-D 2-channel filter banks. Though the 2-D filter banks have many similar properties with the 1-D prototype, but it is difficult to extend to more than 2-channel cases.</p>

<p>In Nguyen,<a class="footnoteRef" href="#fn30" id="fnref30"><sup>30</sup></a> the authors talk about the design of multidimensional filter banks by direct optimization in the frequency domain. The method proposed here is mainly focused on the M-channel 2D filter banks design. The method is flexible towards frequency support configurations. 2D filter banks designed by optimization in the frequency domain has been used in Wei<a class="footnoteRef" href="#fn31" id="fnref31"><sup>31</sup></a> and Lu.<a class="footnoteRef" href="#fn32" id="fnref32"><sup>32</sup></a> In Nguyen's paper,<a class="footnoteRef" href="#fn33" id="fnref33"><sup>33</sup></a> the proposed method is not limited to two-channel 2D filter banks design; the approach is generalized to M-channel filter banks with any critical subsampling matrix. According to the implementation in the paper, it can be used to achieve up to 8-channel 2D filter banks design.</p>

<p><strong>(6)</strong>Reverse Jacket Matrix<a class="footnoteRef" href="#fn34" id="fnref34"><sup>34</sup></a></p>

<p>In Lee's 1999 paper,<a class="footnoteRef" href="#fn35" id="fnref35"><sup>35</sup></a> the authors talk about the multidimensional filter bank design using Reverse <a href="Jacket_matrix" title="wikilink">Jacket matrix</a>. According to Wiki article, let <em>H</em> be a <a href="Hadamard_matrix" title="wikilink">Hadamard matrix</a> of order <em>n</em>, the transpose of <em>H</em> is closely related to its inverse. The correct formula is<span class="LaTeX">$$HH^T=I_n$$</span>, where I<sub>n</sub> is the n×n identity matrix and <em>H<sup>T</sup></em> is the transpose of <em>H</em>. In the 1999 paper,<a class="footnoteRef" href="#fn36" id="fnref36"><sup>36</sup></a> the authors generalize the Reverse Jacket matrix [RJ]<sub>N</sub> using Hadamard matrices and Weighted Hadamard matrices.<a class="footnoteRef" href="#fn37" id="fnref37"><sup>37</sup></a><a class="footnoteRef" href="#fn38" id="fnref38"><sup>38</sup></a></p>

<p>In this paper, the authors proposed that the FIR filter with 128 tap is used as a basic filter and decimation factor is computed for RJ matrices. They did simulations based on different parameters and achieve a good quality performances in low decimation factor.</p>
<h2 id="directional-filter-banks">Directional Filter Banks</h2>

<p>Bamberger and Smith proposed a 2D directional filter bank (DFB).<a class="footnoteRef" href="#fn39" id="fnref39"><sup>39</sup></a> The DFB is efficiently implemented via an <em>l</em>-level tree-structured decomposition that leads to <span class="LaTeX">$2^{l}$</span> subbands with wedge-shaped frequency partition (see Figure ). The original construction of the DFB involves modulating the input signal and using diamond-shaped filters. Moreover, in order to obtain the desired frequency partition, a complicated tree expanding rule has to be followed.<a class="footnoteRef" href="#fn40" id="fnref40"><sup>40</sup></a> As a result, the frequency regions for the resulting subbands do not follow a simple ordering as shown in Figure 9 based on the channel indices.</p>

<p>The first advantage of DFB is that not only it is not a redundant transform but also it offers perfect reconstruction. Another advantage of DFB is its directional-selectivity and efficient structure. This advantage makes DFB an appropriate approach for many signal and image processing usage. (e.g., Laplacian pyramid, constructed the contourlets,<a class="footnoteRef" href="#fn41" id="fnref41"><sup>41</sup></a> sparse image representation, medical imageing<a class="footnoteRef" href="#fn42" id="fnref42"><sup>42</sup></a> etc.).</p>

<p>Directional Filter Banks can be develop to higher dimensions. It can be use in 3-D to achieve the frequency sectioning.</p>
<h2 id="conclusion-and-application">Conclusion and Application</h2>

<p>Filter banks play an important roles in different aspects of signal processing these days. They have different usage in many areas, such as signal and image compression, and processing. The main usage of using <a href="filter_banks" title="wikilink">filter banks</a> is that in this way we can divide the signal or system to several separate frequency domains. Depending on our purpose we can choose different methods to design the filters. In this page we provide information regarding filter banks, multidimensional filter banks and different methods to design multidimensional filters. Also we talked about NDFB, which is built upon an efficient tree-structured construction, which leads to a low redundancy ratio and refinable angular resolution. By combining the NDFB with a new multiscale pyramid, we can constructed the surfacelet transform, which has potentials in efficiently capturing and representing surface-like singularities in multidimensional signals. AS mentioned above NDFB and surfacelet transform have applications in various areas that involve the processing of multidimensional volumetric data, including video processing, seismic image processing, and medical image analysis. Some other advantages of NDFB can be addressed as follow: <strong>Directional decomposition</strong>, <strong>Construction</strong>, <strong>Angular resolution</strong>, <strong>Perfect reconstruction</strong>, and <strong>Small redundancy</strong>.</p>
<h2 id="notes">Notes</h2>
<h3 id="citations">Citations</h3>
<h3 id="further-reading">Further reading</h3>
<ul>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Digital_signal_processing" title="wikilink">Category:Digital signal processing</a> <a href="Category:Linear_filters" title="wikilink">Category:Linear filters</a> <a class="uri" href="Category:Wavelets" title="wikilink">Category:Wavelets</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">The term <em>filter</em> implies that it preserves the information within its passband, and suppresses the information (or noise) outside the passband. When the FFT rate is not sufficient for that, the design is typically called <em>spectrum analyzer</em>. And in that case, it is not necessary for the segments to overlap.<a href="#fnref1">↩</a></li>
<li id="fn2">B. Boashash, editor, “Time-Frequency Signal Analysis and Processing – A Comprehensive Reference”, Elsevier Science, Oxford, 2003; ISBN 0-08-044335-4<a href="#fnref2">↩</a></li>
<li id="fn3">Mitra, Sanjit Kumar, and Yonghong Kuo. Digital signal processing: a computer-based approach. New York: McGraw-Hill, 2006.<a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7">Chen, Tsuhan, and P. P. Vaidyanathan. "Considerations in multidimensional filter bank design" IEEE International Symposium on Circuits and Systems, pp. 643–646., May, 1993.<a href="#fnref7">↩</a></li>
<li id="fn8">Zhang, Lei, and Anamitra Makur. "Multidimensional perfect reconstruction filter banks: an approach of algebraic geometry." Multidimensional Systems and Signal Processing. Volume 20 Issue 1, pp. 3–24. Mar. 2009<a href="#fnref8">↩</a></li>
<li id="fn9">Lu, Yue M., and Minh N. Do. "Multidimensional directional filter banks and surfacelets", IEEE Transactions on Image Processing. Volume 16 Issue 4, pp. 918–931. April, 2007<a href="#fnref9">↩</a></li>
<li id="fn10">J. Zhou and M. N. Do, “Multidimensional oversampled ﬁlter banks” in Proc. SPIE Conf. Wavelet Applications Signal Image Processing XI, San Diego, CA, pp. 591424–1-591424-12, July 2005<a href="#fnref10">↩</a></li>
<li id="fn11">Wolovich, William A. Linear multivariable systems. New York: Springer-Verlag, 1974.<a href="#fnref11">↩</a></li>
<li id="fn12">Kailath, Thomas. Linear systems. Vol. 1. Englewood Cliffs, NJ: Prentice-Hall, 1980.<a href="#fnref12">↩</a></li>
<li id="fn13">Cvetkovic, Zoran, and Martin Vetterli. "Oversampled filter banks" IEEE Transactions on Signal Processing, Vol.46 Issue 5, pp. 1245–1255. May, 1998.<a href="#fnref13">↩</a></li>
<li id="fn14"></li>
<li id="fn15"></li>
<li id="fn16"></li>
<li id="fn17">Charoenlarpnopparut, Chalie, and N. K. Bose. "Multidimensional FIR filter bank design using Grobner bases" IEEE Transactions on Circuits and Systems II: Analog and Digital Signal Processing, Volume 46 Issue 12, pp. 1475–1486, Dec, 1999<a href="#fnref17">↩</a></li>
<li id="fn18"></li>
<li id="fn19">Adams, William W., and Philippe Loustaunau. "An introduction to Gröbner bases, volume 3 of Graduate Studies in Mathematics" American Mathematical Society, Providence, RI 24(47), 1994.<a href="#fnref19">↩</a></li>
<li id="fn20"><a href="#fnref20">↩</a></li>
<li id="fn21"><a href="#fnref21">↩</a></li>
<li id="fn22"><a href="#fnref22">↩</a></li>
<li id="fn23"><a href="#fnref23">↩</a></li>
<li id="fn24"><a href="#fnref24">↩</a></li>
<li id="fn25">Tay, David BH, and Nick G. Kingsbury. "Flexible design of multidimensional perfect reconstruction FIR 2-band filters using transformations of variables." Image Processing, IEEE Transactions on 2, no. 4 (1993): 466-480.<a href="#fnref25">↩</a></li>
<li id="fn26">Laligant, Olivier, and Frederic Truchetet. "Discrete wavelet transform implementation in Fourier domain for multidimensional signal." Journal of Electronic Imaging 11.3 (2002): 338-346.<a href="#fnref26">↩</a></li>
<li id="fn27">Woiselle, Arnaud, J-L. Starck, and J. Fadili. "3D curvelet transforms and astronomical data restoration." Applied and Computational Harmonic Analysis 28.2 (2010): 171-188.<a href="#fnref27">↩</a></li>
<li id="fn28">Feilner, Manuela, Dimitri Van De Ville, and Michael Unser. "An orthogonal family of quincunx wavelets with continuously adjustable order." Image Processing, IEEE Transactions on 14.4 (2005): 499-510.<a href="#fnref28">↩</a></li>
<li id="fn29">Nguyen, Truong T., and Soontorn Oraintara. "Multidimensional filter banks design by direct optimization" IEEE International Symposium onCircuits and Systems, pp. 1090–1093. May, 2005.<a href="#fnref29">↩</a></li>
<li id="fn30"></li>
<li id="fn31">D. Wei and S. Guo, "A new approach to the design of multidimensional nonseparable two-channel orthonormal filterbanks and wavelets", IEEE Signal Processing Letters, vol. 7, no. 11, pp. 327–330, Nov 2000.<a href="#fnref31">↩</a></li>
<li id="fn32">W.-S. Lu, A. Antoniou, and H. Xu, "A direct method for the design of 2-D nonseparable diamond-shaped filter banks", IEEE Transaction on Circuits and Systems II, vol. 45, no. 8, pp. 1146–1150, Aug 1998.<a href="#fnref32">↩</a></li>
<li id="fn33"></li>
<li id="fn34">Lee, Moon Ho, and Ju Yong Park. "The design of multidimensional filter bank using Reverse Jacket matrix", TENCON 99. Proceedings of the IEEE Region 10 Conference. Vol.1 pp. 637–641, Conference in 1999.<a href="#fnref34">↩</a></li>
<li id="fn35"></li>
<li id="fn36"></li>
<li id="fn37">Lee, Seung-Rae, and Moon Ho Lee. "On the Reverse Jacket matrix for weighted Hadamard transform." IEEE Transactions on Circuits and Systems II: Analog and Digital Signal Processing, Vol. 45 Issue 3, pp. 436–441. Mar, 1998.<a href="#fnref37">↩</a></li>
<li id="fn38">Moon Ho Lee, “A New Reverse Jacket Matrix and Its Fast Algorithm”, Accepted IEEE Trans. on CAS-II, pp. 39–47, Jan,2000.<a href="#fnref38">↩</a></li>
<li id="fn39">Bamberger, Roberto H., and Mark JT Smith. "A filter bank for the directional decomposition of images: Theory and design." IEEE Transactions, Signal Processing 40.4 (1992): 882-893.<a href="#fnref39">↩</a></li>
<li id="fn40"><a href="#fnref40">↩</a></li>
<li id="fn41">Do, Minh N., and Martin Vetterli. "The contourlet transform: an efficient directional multiresolution image representation." Image Processing, IEEE Transactions on 14.12 (2005): 2091-2106.<a href="#fnref41">↩</a></li>
<li id="fn42">Truc, Phan TH, et al. "Vessel enhancement filter using directional filter bank." Computer Vision and Image Understanding 113.1 (2009): 101-112.<a href="#fnref42">↩</a></li>
</ol>
</section>
</body>
</html>
