<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="210">Constructible universe</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Constructible universe</h1>
<hr/>

<p>In <a class="uri" href="mathematics" title="wikilink">mathematics</a>, in <a href="set_theory" title="wikilink">set theory</a>, the <strong>constructible universe</strong> (or <strong>Gödel's constructible universe</strong>), denoted <strong>L</strong>, is a particular <a href="Class_(set_theory)" title="wikilink">class</a> of <a href="Set_(mathematics)" title="wikilink">sets</a> that can be described entirely in terms of simpler sets. It was introduced by <a href="Kurt_Gödel" title="wikilink">Kurt Gödel</a> in his 1938 paper "The Consistency of the Axiom of Choice and of the Generalized Continuum-Hypothesis".<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> In this, he proved that the constructible universe is an <a href="inner_model" title="wikilink">inner model</a> of <a href="Zermelo–Fraenkel_set_theory" title="wikilink">ZF</a> set theory, and also that the <a href="axiom_of_choice" title="wikilink">axiom of choice</a> and the <a href="Continuum_hypothesis#The_generalized_continuum_hypothesis" title="wikilink">generalized continuum hypothesis</a> are true in the constructible universe. This shows that both propositions are <a class="uri" href="consistent" title="wikilink">consistent</a> with the basic <a href="axiom" title="wikilink">axioms</a> of set theory, if ZF itself is consistent. Since many other theorems only hold in systems in which one or both of the propositions is true, their consistency is an important result.</p>
<h2 id="what-is-l">What is L?</h2>

<p>L can be thought of as being built in "stages" resembling the <a href="von_Neumann_universe" title="wikilink">von Neumann universe</a>, V. The stages are indexed by <a href="ordinal_number" title="wikilink">ordinals</a>. In von Neumann's universe, at a <a href="successor_ordinal" title="wikilink">successor</a> stage, one takes V<sub>α+1</sub> to be the set of <em>all</em> subsets of the previous stage, V<sub>α</sub>. By contrast, in Gödel's constructible universe L, one uses <em>only</em> those subsets of the previous stage that are:</p>
<ul>
<li>definable by a <a href="Formula_(mathematical_logic)" title="wikilink">formula</a> in the <a href="formal_language" title="wikilink">formal language</a> of set theory</li>
<li>with <a class="uri" href="parameters" title="wikilink">parameters</a> from the previous stage and</li>
<li>with the <a href="Quantifier_(logic)" title="wikilink">quantifiers</a> interpreted to range over the previous stage.</li>
</ul>

<p>By limiting oneself to sets defined only in terms of what has already been constructed, one ensures that the resulting sets will be constructed in a way that is independent of the peculiarities of the surrounding model of set theory and contained in any such model.</p>

<p>Define</p>

<p>

<math display="block" id="Constructible_universe:0">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>Def</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>X</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>:=</mo>
    <mrow>
     <mo maxsize="160%" minsize="160%">{</mo>
     <mrow>
      <mo stretchy="false">{</mo>
      <mi>y</mi>
      <mo>∣</mo>
      <mrow>
       <mi>y</mi>
       <mo>∈</mo>
       <mrow>
        <mi>X</mi>
        <mtext>and</mtext>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>X</mi>
         <mo>,</mo>
         <mo>∈</mo>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>⊧</mo>
       <mrow>
        <mi mathvariant="normal">Φ</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>y</mi>
         <mo>,</mo>
         <msub>
          <mi>z</mi>
          <mn>1</mn>
         </msub>
         <mo>,</mo>
         <mi mathvariant="normal">…</mi>
         <mo>,</mo>
         <msub>
          <mi>z</mi>
          <mi>n</mi>
         </msub>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
      <mo rspace="5.8pt" stretchy="false">}</mo>
     </mrow>
     <mo mathsize="160%" rspace="5.8pt" stretchy="false">|</mo>
     <mrow>
      <mrow>
       <mrow>
        <mi mathvariant="normal">Φ</mi>
        <mtext>is a first-order formula and</mtext>
        <msub>
         <mi>z</mi>
         <mn>1</mn>
        </msub>
       </mrow>
       <mo>,</mo>
       <mi mathvariant="normal">…</mi>
       <mo>,</mo>
       <msub>
        <mi>z</mi>
        <mi>n</mi>
       </msub>
      </mrow>
      <mo>∈</mo>
      <mi>X</mi>
     </mrow>
     <mo maxsize="160%" minsize="160%">}</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <apply>
     <ci>Def</ci>
     <ci>X</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <apply>
      <csymbol cd="latexml">conditional-set</csymbol>
      <ci>y</ci>
      <apply>
       <and></and>
       <apply>
        <in></in>
        <ci>y</ci>
        <apply>
         <times></times>
         <ci>X</ci>
         <mtext>and</mtext>
         <interval closure="open">
          <ci>X</ci>
          <in></in>
         </interval>
        </apply>
       </apply>
       <apply>
        <csymbol cd="latexml">models</csymbol>
        <share href="#.cmml">
        </share>
        <apply>
         <times></times>
         <ci>normal-Φ</ci>
         <vector>
          <ci>y</ci>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>z</ci>
           <cn type="integer">1</cn>
          </apply>
          <ci>normal-…</ci>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>z</ci>
           <ci>n</ci>
          </apply>
         </vector>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <in></in>
      <list>
       <apply>
        <times></times>
        <ci>normal-Φ</ci>
        <mtext>is a first-order formula and</mtext>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>z</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>normal-…</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>z</ci>
        <ci>n</ci>
       </apply>
      </list>
      <ci>X</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{Def}(X):=\Bigl\{\{y\mid y\in X\text{ and }(X,\in)\models\Phi(y,z%
_{1},\ldots,z_{n})\}~{}\Big|~{}\Phi\text{ is a first-order formula and }z_{1},%
\ldots,z_{n}\in X\Bigr\}.
  </annotation>
 </semantics>
</math>

</p>

<p>L is defined by <a href="transfinite_recursion" title="wikilink">transfinite recursion</a> as follows:</p>
<ul>
<li>

<math display="inline" id="Constructible_universe:1">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>L</mi>
     <mn>0</mn>
    </msub>
    <mo>:=</mo>
    <mi mathvariant="normal">∅</mi>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>L</ci>
     <cn type="integer">0</cn>
    </apply>
    <emptyset></emptyset>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L_{0}:=\varnothing.
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="Constructible_universe:2">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>L</mi>
     <mrow>
      <mi>α</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo>:=</mo>
    <mrow>
     <mo>Def</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>L</mi>
       <mi>α</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>L</ci>
     <apply>
      <plus></plus>
      <ci>α</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <ci>Def</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>L</ci>
      <ci>α</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L_{\alpha+1}:=\operatorname{Def}(L_{\alpha}).
  </annotation>
 </semantics>
</math>

</li>
<li>If 

<math display="inline" id="Constructible_universe:3">
 <semantics>
  <mi>λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda
  </annotation>
 </semantics>
</math>

 is a <a href="limit_ordinal" title="wikilink">limit ordinal</a>, then 

<math display="inline" id="Constructible_universe:4">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>L</mi>
     <mi>λ</mi>
    </msub>
    <mo>:=</mo>
    <mrow>
     <msub>
      <mo largeop="true" mathsize="160%" stretchy="false" symmetric="true">⋃</mo>
      <mrow>
       <mi>α</mi>
       <mo><</mo>
       <mi>λ</mi>
      </mrow>
     </msub>
     <msub>
      <mi>L</mi>
      <mi>α</mi>
     </msub>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>L</ci>
     <ci>λ</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <union></union>
      <apply>
       <lt></lt>
       <ci>α</ci>
       <ci>λ</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>L</ci>
      <ci>α</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L_{\lambda}:=\bigcup_{\alpha<\lambda}L_{\alpha}.
  </annotation>
 </semantics>
</math>

 Here α&lt;λ means α <a href="ordinal_number#Successor_and_limit_ordinals" title="wikilink">precedes</a> λ.</li>
<li>

<math display="inline" id="Constructible_universe:5">
 <semantics>
  <mrow>
   <mrow>
    <mi>L</mi>
    <mo>:=</mo>
    <mrow>
     <msub>
      <mo largeop="true" mathsize="160%" stretchy="false" symmetric="true">⋃</mo>
      <mrow>
       <mi>α</mi>
       <mo>∈</mo>
       <mi>𝐎𝐫𝐝</mi>
      </mrow>
     </msub>
     <msub>
      <mi>L</mi>
      <mi>α</mi>
     </msub>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <ci>L</ci>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <union></union>
      <apply>
       <in></in>
       <ci>α</ci>
       <ci>𝐎𝐫𝐝</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>L</ci>
      <ci>α</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L:=\bigcup_{\alpha\in\mathbf{Ord}}L_{\alpha}.
  </annotation>
 </semantics>
</math>

 Here <strong>Ord</strong> denotes the <a href="class_(set_theory)" title="wikilink">class</a> of all ordinals.</li>
</ul>

<p>If z is an element of L<sub>α</sub>, then z = {y | y ∈ L<sub>α</sub> and y ∈ z} ∈ Def (L<sub>α</sub>) = L<sub>α+1</sub>. So L<sub>α</sub> is a subset of L<sub>α+1</sub>, which is a subset of the <a href="power_set" title="wikilink">power set</a> of L<sub>α</sub>. Consequently, this is a tower of nested <a href="transitive_set" title="wikilink">transitive sets</a>. But L itself is a <a href="Class_(set_theory)" title="wikilink">proper class</a>.</p>

<p>The elements of L are called "constructible" sets; and L itself is the "constructible universe". The "<a href="axiom_of_constructibility" title="wikilink">axiom of constructibility</a>", aka "V=L", says that every set (of V) is constructible, i.e. in L.</p>
<h2 id="additional-facts-about-the-sets-lα">Additional facts about the sets L<sub>α</sub></h2>

<p>An equivalent definition for L<sub>α</sub> is:</p>
<dl>
<dd><dl>
<dd>For any ordinal α, 

<math display="inline" id="Constructible_universe:6">
 <semantics>
  <mrow>
   <msub>
    <mi>L</mi>
    <mi>α</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mo largeop="true" mathsize="160%" stretchy="false" symmetric="true">⋃</mo>
     <mrow>
      <mi>β</mi>
      <mo><</mo>
      <mi>α</mi>
     </mrow>
    </msub>
    <mrow>
     <mo>Def</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>L</mi>
       <mi>β</mi>
      </msub>
      <mo rspace="0.8pt" stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>L</ci>
     <ci>α</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <union></union>
      <apply>
       <lt></lt>
       <ci>β</ci>
       <ci>α</ci>
      </apply>
     </apply>
     <apply>
      <ci>Def</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>L</ci>
       <ci>β</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L_{\alpha}=\bigcup_{\beta<\alpha}\operatorname{Def}(L_{\beta})\!
  </annotation>
 </semantics>
</math>

.
</dd>
</dl>
</dd>
</dl>

<p>For any finite ordinal n, the sets L<sub>n</sub> and V<sub>n</sub> are the same (whether V equals L or not), and thus L<sub>ω</sub> = V<sub>ω</sub>: their elements are exactly the <a href="hereditarily_finite_set" title="wikilink">hereditarily finite sets</a>. Equality beyond this point does not hold. Even in models of <a href="Zermelo–Fraenkel_set_theory" title="wikilink">ZFC</a> in which V equals L, L<sub>ω+1</sub> is a proper subset of V<sub>ω+1</sub>, and thereafter L<sub>α+1</sub> is a proper subset of the power set of L<sub>α</sub> for all α &gt; ω. On the other hand, V equals L does imply that V<sub>α</sub> equals L<sub>α</sub> if α = ω<sub>α</sub>, for example if α is inaccessible. More generally, V equals L implies <a href="Hereditarily_countable_set" title="wikilink">H<sub>α</sub></a> equals L<sub>α</sub> for all infinite cardinals α.</p>

<p>If α is an infinite ordinal then there is a bijection between L<sub>α</sub> and α, and the bijection is constructible. So these sets are <a class="uri" href="equinumerous" title="wikilink">equinumerous</a> in any model of set theory that includes them.</p>

<p>As defined above, Def(<em>X</em>) is the set of subsets of <em>X</em> defined by Δ<sub>0</sub> formulas (that is, formulas of set theory containing only <a href="bounded_quantifiers" title="wikilink">bounded quantifiers</a>) that use as parameters only <em>X</em> and its elements.</p>

<p>An alternate definition, due to Gödel, characterizes each L<sub>α+1</sub> as the intersection of the power set of L<sub>α</sub> with the closure of 

<math display="inline" id="Constructible_universe:7">
 <semantics>
  <mrow>
   <msub>
    <mi>L</mi>
    <mi>α</mi>
   </msub>
   <mo>∪</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <msub>
     <mi>L</mi>
     <mi>α</mi>
    </msub>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <union></union>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>L</ci>
     <ci>α</ci>
    </apply>
    <set>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>L</ci>
      <ci>α</ci>
     </apply>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L_{\alpha}\cup\{L_{\alpha}\}
  </annotation>
 </semantics>
</math>

 under a collection of nine explicit functions. This definition makes no reference to definability.</p>

<p>All <a href="arithmetical_hierarchy" title="wikilink">arithmetical</a> subsets of ω and relations on ω belong to L<sub>ω+1</sub> (because the arithmetic definition gives one in L<sub>ω+1</sub>). Conversely, any subset of ω belonging to L<sub>ω+1</sub> is arithmetical (because elements of L<sub>ω</sub> can be coded by natural numbers in such a way that ∈ is definable, i.e., arithmetic). On the other hand, L<sub>ω+2</sub> already contains certain non-arithmetical subsets of ω, such as the set of (natural numbers coding) true arithmetical statements (this can be defined from L<sub>ω+1</sub> so it is in L<sub>ω+2</sub>).</p>

<p>All <a href="hyperarithmetical_hierarchy" title="wikilink">hyperarithmetical</a> subsets of ω and relations on ω belong to 

<math display="inline" id="Constructible_universe:8">
 <semantics>
  <msub>
   <mi>L</mi>
   <msubsup>
    <mi>ω</mi>
    <mn>1</mn>
    <mi>CK</mi>
   </msubsup>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>L</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ω</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>CK</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L_{\omega_{1}^{\mathrm{CK}}}
  </annotation>
 </semantics>
</math>

 (where 

<math display="inline" id="Constructible_universe:9">
 <semantics>
  <msubsup>
   <mi>ω</mi>
   <mn>1</mn>
   <mi>CK</mi>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ω</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>CK</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \omega_{1}^{\mathrm{CK}}
  </annotation>
 </semantics>
</math>

 stands for the <a href="Church-Kleene_ordinal" title="wikilink">Church-Kleene ordinal</a>), and conversely any subset of ω that belongs to 

<math display="inline" id="Constructible_universe:10">
 <semantics>
  <msub>
   <mi>L</mi>
   <msubsup>
    <mi>ω</mi>
    <mn>1</mn>
    <mi>CK</mi>
   </msubsup>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>L</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ω</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>CK</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L_{\omega_{1}^{\mathrm{CK}}}
  </annotation>
 </semantics>
</math>

 is hyperarithmetical.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>
<h2 id="l-is-a-standard-inner-model-of-zfc">L is a standard inner model of ZFC</h2>

<p>L is a standard model, i.e. it is a <a href="transitive_class" title="wikilink">transitive class</a> and it uses the real element relationship, so it is <a href="Well-founded_relation" title="wikilink">well-founded</a>. L is an inner model, i.e. it contains all the ordinal numbers of V and it has no "extra" sets beyond those in V, but it might be a proper subclass of V. L is a model of <a href="Zermelo–Fraenkel_set_theory" title="wikilink">ZFC</a>, which means that it satisfies the following <a href="axiom" title="wikilink">axioms</a>:</p>
<ul>
<li><a href="Axiom_of_regularity" title="wikilink">Axiom of regularity</a>: Every non-empty set x contains some element y such that x and y are disjoint sets.</li>
</ul>
<dl>
<dd>(L,∈) is a substructure of (V,∈), which is well founded, so L is well founded. In particular, if x∈L, then by the transitivity of L, y∈L. If we use this same y as in V, then it is still disjoint from x because we are using the same element relation and no new sets were added.
</dd>
</dl>
<ul>
<li><a href="Axiom_of_extensionality" title="wikilink">Axiom of extensionality</a>: Two sets are the same if and only if they have the same elements.</li>
</ul>
<dl>
<dd>If x and y are in L and they have the same elements in L, then by L's transitivity, they have the same elements (in V). So they are equal (in V and thus in L).
</dd>
</dl>
<ul>
<li><a href="Axiom_of_empty_set" title="wikilink">Axiom of empty set</a>: {} is a set.</li>
</ul>
<dl>
<dd>{} = L<sub>0</sub> = {y | y∈L<sub>0</sub> and y=y} ∈ L<sub>1</sub>. So {} ∈ L. Since the element relation is the same and no new elements were added, this is the empty set of L.
</dd>
</dl>
<ul>
<li><a href="Axiom_of_pairing" title="wikilink">Axiom of pairing</a>: If x, y are sets, then {x,y} is a set.</li>
</ul>
<dl>
<dd>If x∈L and y∈L, then there is some ordinal α such that x∈L<sub>α</sub> and y∈L<sub>α</sub>. Then {x,y} = {s | s∈L<sub>α</sub> and (s=x or s=y)} ∈ L<sub>α+1</sub>. Thus {x,y} ∈ L and it has the same meaning for L as for V.
</dd>
</dl>
<ul>
<li><a href="Axiom_of_union" title="wikilink">Axiom of union</a>: For any set x there is a set y whose elements are precisely the elements of the elements of x.</li>
</ul>
<dl>
<dd>If x ∈ L<sub>α</sub>, then its elements are in L<sub>α</sub> and their elements are also in L<sub>α</sub>. So y is a subset of L<sub>α</sub>. y = {s | s∈L<sub>α</sub> and there exists z∈x such that s∈z} ∈ L<sub>α+1</sub>. Thus y ∈ L.
</dd>
</dl>
<ul>
<li><a href="Axiom_of_infinity" title="wikilink">Axiom of infinity</a>: There exists a set x such that {} is in x and whenever y is in x, so is the union y U {y}.</li>
</ul>
<dl>
<dd>From <a href="transfinite_induction" title="wikilink">transfinite induction</a>, we get that each ordinal α ∈ L<sub>α+1</sub>. In particular, ω ∈ L<sub>ω+1</sub> and thus ω ∈ L.
</dd>
</dl>
<ul>
<li><a href="Axiom_of_separation" title="wikilink">Axiom of separation</a>: Given any set S and any proposition P(x,z<sub>1</sub>,...,z<sub>n</sub>), {x|x∈S and P(x,z<sub>1</sub>,...,z<sub>n</sub>)} is a set.</li>
</ul>
<dl>
<dd>By induction on subformulas of P, one can show that there is an α such that L<sub>α</sub> contains S and z<sub>1</sub>,...,z<sub>n</sub> and (P is true in L<sub>α</sub> if and only if P is true in L (this is called the "<a href="reflection_principle" title="wikilink">reflection principle</a>")). So {x | x∈S and P(x,z<sub>1</sub>,...,z<sub>n</sub>) holds in L} = {x | x∈L<sub>α</sub> and x∈S and P(x,z<sub>1</sub>,...,z<sub>n</sub>) holds in L<sub>α</sub>} ∈ L<sub>α+1</sub>. Thus the subset is in L.
</dd>
</dl>
<ul>
<li><a href="Axiom_of_replacement" title="wikilink">Axiom of replacement</a>: Given any set S and any mapping (formally defined as a proposition P(x,y) where P(x,y) and P(x,z) implies y = z), {y | there exists x∈S such that P(x,y)} is a set.</li>
</ul>
<dl>
<dd>Let Q(x,y) be the formula that relativizes P to L, i.e. all quantifiers in P are restricted to L. Q is a much more complex formula than P, but it is still a finite formula, and since P was a mapping over L, Q must be a mapping over V; thus we can apply replacement in V to Q. So {y | y∈L and there exists x∈S such that P(x,y) holds in L} = {y | there exists x∈S such that Q(x,y)} is a set in V and a subclass of L. Again using the axiom of replacement in V, we can show that there must be an α such that this set is a subset of L<sub>α</sub> ∈ L<sub>α+1</sub>. Then one can use the axiom of separation in L to finish showing that it is an element of L.
</dd>
</dl>
<ul>
<li><a href="Axiom_of_power_set" title="wikilink">Axiom of power set</a>: For any set x there exists a set y, such that the elements of y are precisely the subsets of x.</li>
</ul>
<dl>
<dd>In general, some subsets of a set in L will not be in L. So the whole power set of a set in L will usually not be in L. What we need here is to show that the intersection of the power set with L <em>is</em> in L. Use replacement in V to show that there is an α such that the intersection is a subset of L<sub>α</sub>. Then the intersection is {z | z∈L<sub>α</sub> and z is a subset of x} ∈ L<sub>α+1</sub>. Thus the required set is in L.
</dd>
</dl>
<ul>
<li><a href="Axiom_of_choice" title="wikilink">Axiom of choice</a>: Given a set x of mutually disjoint nonempty sets, there is a set y (a choice set for x) containing exactly one element from each member of x.</li>
</ul>
<dl>
<dd>One can show that there is a definable well-ordering of L which definition works the same way in L itself. So one chooses the least element of each member of x to form y using the axioms of union and separation in L.
</dd>
</dl>

<p>Notice that the proof that L is a model of ZFC only requires that V be a model of ZF, i.e. we do NOT assume that the axiom of choice holds in V.</p>
<h2 id="l-is-absolute-and-minimal">L is absolute and minimal</h2>

<p>If W is any standard model of ZF sharing the same ordinals as V, then the L defined in W is the same as the L defined in V. In particular, L<sub>α</sub> is the same in W and V, for any ordinal α. And the same formulas and parameters in Def (L<sub>α</sub>) produce the same constructible sets in L<sub>α+1</sub>.</p>

<p>Furthermore, since L is a subclass of V and, similarly, L is a subclass of W, L is the smallest class containing all the ordinals that is a standard model of ZF. Indeed, L is the intersection of all such classes.</p>

<p>If there is a <em>set</em> W in V that is a <a href="inner_model" title="wikilink">standard model</a> of ZF, and the ordinal κ is the set of ordinals that occur in W, then L<sub>κ</sub> is the L of W. If there is a set that is a standard model of ZF, then the smallest such set is such a L<sub>κ</sub>. This set is called the <strong><a href="minimal_model_(set_theory)" title="wikilink">minimal model</a></strong> of ZFC. Using the downward <a href="Löwenheim–Skolem_theorem" title="wikilink">Löwenheim–Skolem theorem</a>, one can show that the minimal model (if it exists) is a countable set.</p>

<p>Of course, any consistent theory must have a model, so even within the minimal model of set theory there are sets that are models of ZF (assuming ZF is consistent). However, those set models are non-standard. In particular, they do not use the normal element relation and they are not well founded.</p>

<p>Because both the L of L and the V of L are the real L and both the L of L<sub>κ</sub> and the V of L<sub>κ</sub> are the real L<sub>κ</sub>, we get that V=L is true in L and in any L<sub>κ</sub> that is a model of ZF. However, V=L does not hold in any other standard model of ZF.</p>
<h3 id="l-and-large-cardinals">L and large cardinals</h3>

<p>Since On⊂L⊆V, properties of ordinals that depend on the absence of a function or other structure (i.e. Π<sub>1</sub><sup>ZF</sup> formulas) are preserved when going down from V to L. Hence <a href="initial_ordinal" title="wikilink">initial ordinals</a> of cardinals remain initial in L. <a href="Regular_ordinal" title="wikilink">Regular ordinals</a> remain regular in L. Weak <a href="limit_cardinal" title="wikilink">limit cardinals</a> become strong limit cardinals in L because the <a href="generalized_continuum_hypothesis" title="wikilink">generalized continuum hypothesis</a> holds in L. Weakly <a href="inaccessible_cardinal" title="wikilink">inaccessible cardinals</a> become strongly inaccessible. Weakly <a href="Mahlo_cardinal" title="wikilink">Mahlo cardinals</a> become strongly Mahlo. And more generally, any <a href="large_cardinal" title="wikilink">large cardinal</a> property weaker than <a href="Zero_sharp" title="wikilink">0<sup>#</sup></a> (see the <a href="list_of_large_cardinal_properties" title="wikilink">list of large cardinal properties</a>) will be retained in L.</p>

<p>However, 0<sup>#</sup> is false in L even if true in V. So all the large cardinals whose existence implies 0<sup>#</sup> cease to have those large cardinal properties, but retain the properties weaker than 0<sup>#</sup> which they also possess. For example, <a href="measurable_cardinal" title="wikilink">measurable cardinals</a> cease to be measurable but remain Mahlo in L.</p>

<p>Interestingly, if 0<sup>#</sup> holds in V, then there is a <a href="Club_set" title="wikilink">closed unbounded class</a> of ordinals that are <a class="uri" href="indiscernible" title="wikilink">indiscernible</a> in L. While some of these are not even initial ordinals in V, they have all the large cardinal properties weaker than 0<sup>#</sup> in L. Furthermore, any strictly increasing class function from the class of <a class="uri" href="indiscernibles" title="wikilink">indiscernibles</a> to itself can be extended in a unique way to an <a href="elementary_embedding" title="wikilink">elementary embedding</a> of L into L. This gives L a nice structure of repeating segments.</p>
<h2 id="l-can-be-well-ordered">L can be well-ordered</h2>

<p>There are various ways of well-ordering L. Some of these involve the "fine structure" of L, which was first described by Ronald Bjorn Jensen in his 1972 paper entitled "The fine structure of the constructible hierarchy". Instead of explaining the fine structure, we will give an outline of how L could be well-ordered using only the definition given above.</p>

<p>Suppose x and y are two different sets in L and we wish to determine whether x<y or="" x="">y. If x first appears in L<sub>α+1</sub> and y first appears in L<sub>β+1</sub> and β is different from α, then let x<y and="" henceforth,="" if="" l<sub="" only="" remember="" suppose="" that="" we="" y="" αα+1<=""></y></y></p>

<p>= Def (L<sub>α</sub>), which uses formulas with parameters from L<sub>α</sub> to define the sets x and y. If one discounts (for the moment) the parameters, the formulas can be given a standard <a href="Gödel_numbering" title="wikilink">Gödel numbering</a> by the natural numbers. If Φ is the formula with the smallest Gödel number that can be used to define x, and Ψ is the formula with the smallest Gödel number that can be used to define y, and Ψ is different from Φ, then let x<y and="" from="" gödel="" henceforth,="" if="" in="" l<sub="" n="" numbering.="" only="" parameters="" suppose="" that="" the="" uses="" we="" z<sub="" φ="" φα.="">1</y></p></body></html>,...,z<sub>n</sub> is the sequence of parameters that can be used with Φ to define x, and w<sub>1</sub>,...,w<sub>n</sub> does the same for y. Then let x<y and="" either="" if="" only="" z<sub="">n<w>n</w> or (z<sub>n</sub>=w<sub>n</sub> and z<sub>n-1</sub><w>n-1</w>) or (z<sub>n</sub>=w<sub>n</sub> and z<sub>n-1</sub>=w<sub>n-1</sub> and z<sub>n-2</sub><w>n-2</w>) or etc.. This is called the reverse-<a href="lexicographic_ordering" title="wikilink">lexicographic ordering</a>; if there are multiple sequences of parameters that define one of the sets, we choose the least one under this ordering. It being understood that each parameter's possible values are ordered according to the restriction of the ordering of L to L<sub>α</sub>, so this definition involves transfinite recursion on α.</y>

<p>The well-ordering of the values of single parameters is provided by the inductive hypothesis of the transfinite induction. The values of n-tuples of parameters are well-ordered by the product ordering. The formulas with parameters are well-ordered by the ordered sum (by Gödel numbers) of well-orderings. And L is well-ordered by the ordered sum (indexed by α) of the orderings on L<sub>α+1</sub>.</p>

<p>Notice that this well-ordering can be defined within L itself by a formula of set theory with no parameters, only the free-variables x and y. And this formula gives the same <a href="truth_value" title="wikilink">truth value</a> regardless of whether it is evaluated in L, V, or W (some other standard model of ZF with the same ordinals) and we will suppose that the formula is false if either x or y is not in L.</p>

<p>It is well known that the axiom of choice is equivalent to the ability to well-order every set. Being able to well-order the proper class V (as we have done here with L) is equivalent to the <a href="axiom_of_global_choice" title="wikilink">axiom of global choice</a>, which is more powerful than the ordinary <a href="axiom_of_choice" title="wikilink">axiom of choice</a> because it also covers proper classes of non-empty sets.</p>
<h2 id="l-has-a-reflection-principle">L has a reflection principle</h2>

<p>Proving that the <a href="axiom_of_separation" title="wikilink">axiom of separation</a>, <a href="axiom_of_replacement" title="wikilink">axiom of replacement</a>, and <a href="axiom_of_choice" title="wikilink">axiom of choice</a> hold in L requires (at least as shown above) the use of a <a href="reflection_principle" title="wikilink">reflection principle</a> for L. Here we describe such a principle.</p>

<p>By mathematical induction on nα such that for any sentence P(z<sub>1</sub>,...,z<sub>k</sub>) with z<sub>1</sub>,...,z<sub>k</sub> in L<sub>β</sub> and containing fewer than n symbols (counting a constant symbol for an element of L<sub>β</sub> as one symbol) we get that P(z<sub>1</sub>,...,z<sub>k</sub>) holds in L<sub>β</sub> if and only if it holds in L.</p>
<h2 id="the-generalized-continuum-hypothesis-holds-in-l">The generalized continuum hypothesis holds in L</h2>

<p>Let 

<math display="inline" id="Constructible_universe:11">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>∈</mo>
   <msub>
    <mi>L</mi>
    <mi>α</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>S</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>L</ci>
     <ci>α</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S\in L_{\alpha}
  </annotation>
 </semantics>
</math>

, and let <em>T</em> be any constructible subset of <em>S</em>. Then there is some β with 

<math display="inline" id="Constructible_universe:12">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mo>∈</mo>
   <msub>
    <mi>L</mi>
    <mrow>
     <mi>β</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>T</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>L</ci>
     <apply>
      <plus></plus>
      <ci>β</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T\in L_{\beta+1}
  </annotation>
 </semantics>
</math>

, so 

<math display="inline" id="Constructible_universe:13">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mi>x</mi>
     <mo>∈</mo>
     <msub>
      <mi>L</mi>
      <mi>β</mi>
     </msub>
    </mrow>
    <mo>:</mo>
    <mrow>
     <mi>x</mi>
     <mo>∈</mo>
     <mrow>
      <mi>S</mi>
      <mo>∧</mo>
      <mrow>
       <mi mathvariant="normal">Φ</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo>,</mo>
        <msub>
         <mi>z</mi>
         <mi>i</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mi>x</mi>
     <mo>∈</mo>
     <mi>S</mi>
    </mrow>
    <mo>:</mo>
    <mrow>
     <mi mathvariant="normal">Φ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>,</mo>
      <msub>
       <mi>z</mi>
       <mi>i</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>T</ci>
     <apply>
      <csymbol cd="latexml">conditional-set</csymbol>
      <apply>
       <in></in>
       <ci>x</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>L</ci>
        <ci>β</ci>
       </apply>
      </apply>
      <apply>
       <in></in>
       <ci>x</ci>
       <apply>
        <and></and>
        <ci>S</ci>
        <apply>
         <times></times>
         <ci>normal-Φ</ci>
         <interval closure="open">
          <ci>x</ci>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>z</ci>
           <ci>i</ci>
          </apply>
         </interval>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="latexml">conditional-set</csymbol>
      <apply>
       <in></in>
       <ci>x</ci>
       <ci>S</ci>
      </apply>
      <apply>
       <times></times>
       <ci>normal-Φ</ci>
       <interval closure="open">
        <ci>x</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>z</ci>
         <ci>i</ci>
        </apply>
       </interval>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T=\{x\in L_{\beta}:x\in S\wedge\Phi(x,z_{i})\}=\{x\in S:\Phi(x,z_{i})\}
  </annotation>
 </semantics>
</math>

, for some formula Φ and some 

<math display="inline" id="Constructible_universe:14">
 <semantics>
  <msub>
   <mi>z</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>z</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z_{i}
  </annotation>
 </semantics>
</math>

 drawn from 

<math display="inline" id="Constructible_universe:15">
 <semantics>
  <msub>
   <mi>L</mi>
   <mi>β</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>L</ci>
    <ci>β</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L_{\beta}
  </annotation>
 </semantics>
</math>

. By the downward <a href="Löwenheim–Skolem_theorem" title="wikilink">Löwenheim–Skolem theorem</a>, there must be some transitive set <em>K</em> containing 

<math display="inline" id="Constructible_universe:16">
 <semantics>
  <msub>
   <mi>L</mi>
   <mi>α</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>L</ci>
    <ci>α</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L_{\alpha}
  </annotation>
 </semantics>
</math>

 and some 

<math display="inline" id="Constructible_universe:17">
 <semantics>
  <msub>
   <mi>w</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>w</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w_{i}
  </annotation>
 </semantics>
</math>

, and having the same first-order theory as 

<math display="inline" id="Constructible_universe:18">
 <semantics>
  <msub>
   <mi>L</mi>
   <mi>β</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>L</ci>
    <ci>β</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L_{\beta}
  </annotation>
 </semantics>
</math>

 with the 

<math display="inline" id="Constructible_universe:19">
 <semantics>
  <msub>
   <mi>w</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>w</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w_{i}
  </annotation>
 </semantics>
</math>

 substituted for the 

<math display="inline" id="Constructible_universe:20">
 <semantics>
  <msub>
   <mi>z</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>z</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z_{i}
  </annotation>
 </semantics>
</math>

; and this <em>K</em> will have the same cardinal as 

<math display="inline" id="Constructible_universe:21">
 <semantics>
  <msub>
   <mi>L</mi>
   <mi>α</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>L</ci>
    <ci>α</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L_{\alpha}
  </annotation>
 </semantics>
</math>

. Since 

<math display="inline" id="Constructible_universe:22">
 <semantics>
  <mrow>
   <mi>V</mi>
   <mo>=</mo>
   <mi>L</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>V</ci>
    <ci>L</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V=L
  </annotation>
 </semantics>
</math>

 is true in 

<math display="inline" id="Constructible_universe:23">
 <semantics>
  <msub>
   <mi>L</mi>
   <mi>β</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>L</ci>
    <ci>β</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L_{\beta}
  </annotation>
 </semantics>
</math>

, it is also true in <em>K</em>, so 

<math display="inline" id="Constructible_universe:24">
 <semantics>
  <mrow>
   <mi>K</mi>
   <mo>=</mo>
   <msub>
    <mi>L</mi>
    <mi>γ</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>K</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>L</ci>
     <ci>γ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K=L_{\gamma}
  </annotation>
 </semantics>
</math>

 for some γ having the same cardinal as α. And 

<math display="inline" id="Constructible_universe:25">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mi>x</mi>
     <mo>∈</mo>
     <msub>
      <mi>L</mi>
      <mi>β</mi>
     </msub>
    </mrow>
    <mo>:</mo>
    <mrow>
     <mi>x</mi>
     <mo>∈</mo>
     <mrow>
      <mi>S</mi>
      <mo>∧</mo>
      <mrow>
       <mi mathvariant="normal">Φ</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo>,</mo>
        <msub>
         <mi>z</mi>
         <mi>i</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mi>x</mi>
     <mo>∈</mo>
     <msub>
      <mi>L</mi>
      <mi>γ</mi>
     </msub>
    </mrow>
    <mo>:</mo>
    <mrow>
     <mi>x</mi>
     <mo>∈</mo>
     <mrow>
      <mi>S</mi>
      <mo>∧</mo>
      <mrow>
       <mi mathvariant="normal">Φ</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo>,</mo>
        <msub>
         <mi>w</mi>
         <mi>i</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>T</ci>
     <apply>
      <csymbol cd="latexml">conditional-set</csymbol>
      <apply>
       <in></in>
       <ci>x</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>L</ci>
        <ci>β</ci>
       </apply>
      </apply>
      <apply>
       <in></in>
       <ci>x</ci>
       <apply>
        <and></and>
        <ci>S</ci>
        <apply>
         <times></times>
         <ci>normal-Φ</ci>
         <interval closure="open">
          <ci>x</ci>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>z</ci>
           <ci>i</ci>
          </apply>
         </interval>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="latexml">conditional-set</csymbol>
      <apply>
       <in></in>
       <ci>x</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>L</ci>
        <ci>γ</ci>
       </apply>
      </apply>
      <apply>
       <in></in>
       <ci>x</ci>
       <apply>
        <and></and>
        <ci>S</ci>
        <apply>
         <times></times>
         <ci>normal-Φ</ci>
         <interval closure="open">
          <ci>x</ci>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>w</ci>
           <ci>i</ci>
          </apply>
         </interval>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T=\{x\in L_{\beta}:x\in S\wedge\Phi(x,z_{i})\}=\{x\in L_{\gamma}:x\in S\wedge%
\Phi(x,w_{i})\}
  </annotation>
 </semantics>
</math>

 because 

<math display="inline" id="Constructible_universe:26">
 <semantics>
  <msub>
   <mi>L</mi>
   <mi>β</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>L</ci>
    <ci>β</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L_{\beta}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Constructible_universe:27">
 <semantics>
  <msub>
   <mi>L</mi>
   <mi>γ</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>L</ci>
    <ci>γ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L_{\gamma}
  </annotation>
 </semantics>
</math>

 have the same theory. So <em>T</em> is in fact in 

<math display="inline" id="Constructible_universe:28">
 <semantics>
  <msub>
   <mi>L</mi>
   <mrow>
    <mi>γ</mi>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>L</ci>
    <apply>
     <plus></plus>
     <ci>γ</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L_{\gamma+1}
  </annotation>
 </semantics>
</math>

.</p>

<p>So all the constructible subsets of an infinite set <em>S</em> have ranks with (at most) the same cardinal κ as the rank of <em>S</em>; it follows that if α is the initial ordinal for κ<sup>+</sup>, then 

<math display="inline" id="Constructible_universe:29">
 <semantics>
  <mrow>
   <mrow>
    <mi>L</mi>
    <mo>∩</mo>
    <mrow>
     <mi class="ltx_font_mathcaligraphic">𝒫</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>S</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>⊆</mo>
   <msub>
    <mi>L</mi>
    <mrow>
     <mi>α</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <apply>
     <intersect></intersect>
     <ci>L</ci>
     <apply>
      <times></times>
      <ci>𝒫</ci>
      <ci>S</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>L</ci>
     <apply>
      <plus></plus>
      <ci>α</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L\cap\mathcal{P}(S)\subseteq L_{\alpha+1}
  </annotation>
 </semantics>
</math>

 serves as the "powerset" of <em>S</em> within <em>L</em>. And this in turn means that the "power set" of <em>S</em> has cardinal at most ||α||. Assuming <em>S</em> itself has cardinal κ, the "power set" must then have cardinal exactly κ<sup>+</sup>. But this is precisely the <a href="generalized_continuum_hypothesis" title="wikilink">generalized continuum hypothesis</a> relativized to <em>L</em>.</p>
<h2 id="constructible-sets-are-definable-from-the-ordinals">Constructible sets are definable from the ordinals</h2>

<p>There is a formula of set theory that expresses the idea that X=L<sub>α</sub>. It has only free variables for X and α. Using this we can expand the definition of each constructible set. If s∈L<sub>α+1</sub>, then s = {y|y∈L<sub>α</sub> and Φ(y,z<sub>1</sub>,...,z<sub>n</sub>) holds in (L<sub>α</sub>,∈)} for some formula Φ and some z<sub>1</sub>,...,z<sub>n</sub> in L<sub>α</sub>. This is equivalent to saying that: for all y, y∈s if and only if [there exists X such that X=L<sub>α</sub> and y∈X and Ψ(X,y,z<sub>1</sub>,...,z<sub>n</sub>)] where Ψ(X,...) is the result of restricting each quantifier in Φ(...) to X. Notice that each z<sub>k</sub>∈L<sub>β+1</sub> for some β&lt;α. Combine formulas for the z's with the formula for s and apply existential quantifiers over the z's outside and one gets a formula that defines the constructible set s using only the ordinals α that appear in expressions like X=L<sub>α</sub> as parameters.</p>

<p>Example: The set {5,ω} is constructible. It is the unique set, s, that satisfies the formula:<br/>


<math display="inline" id="Constructible_universe:30">
 <semantics>
  <mrow>
   <mo>∀</mo>
   <mi>y</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>y</mi>
    <mo>∈</mo>
    <mi>s</mi>
    <mo>⇔</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>y</mi>
     <mo>∈</mo>
     <msub>
      <mi>L</mi>
      <mrow>
       <mi>ω</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </msub>
     <mi mathvariant="italic">and</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mo>∀</mo>
      <mi>a</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>a</mi>
       <mo>∈</mo>
       <mi>y</mi>
       <mo>⇔</mo>
       <mi>a</mi>
       <mo>∈</mo>
       <msub>
        <mi>L</mi>
        <mn>5</mn>
       </msub>
       <mi mathvariant="italic">and</mi>
       <mi>O</mi>
       <mi>r</mi>
       <mi>d</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>a</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>∀</mo>
      <mi>b</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>b</mi>
       <mo>∈</mo>
       <mi>y</mi>
       <mo>⇔</mo>
       <mi>b</mi>
       <mo>∈</mo>
       <msub>
        <mi>L</mi>
        <mi>ω</mi>
       </msub>
       <mi mathvariant="italic">and</mi>
       <mi>O</mi>
       <mi>r</mi>
       <mi>d</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>b</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">y</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">y</csymbol>
     <in></in>
     <csymbol cd="unknown">s</csymbol>
     <csymbol cd="latexml">iff</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">y</csymbol>
      <in></in>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>L</ci>
       <apply>
        <plus></plus>
        <ci>ω</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <csymbol cd="unknown">and</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="latexml">for-all</csymbol>
       <csymbol cd="unknown">a</csymbol>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <csymbol cd="unknown">a</csymbol>
        <in></in>
        <csymbol cd="unknown">y</csymbol>
        <csymbol cd="latexml">iff</csymbol>
        <csymbol cd="unknown">a</csymbol>
        <in></in>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>L</ci>
         <cn type="integer">5</cn>
        </apply>
        <csymbol cd="unknown">and</csymbol>
        <csymbol cd="unknown">O</csymbol>
        <csymbol cd="unknown">r</csymbol>
        <csymbol cd="unknown">d</csymbol>
        <cerror>
         <csymbol cd="ambiguous">fragments</csymbol>
         <ci>normal-(</ci>
         <csymbol cd="unknown">a</csymbol>
         <ci>normal-)</ci>
        </cerror>
        <ci>normal-)</ci>
       </cerror>
       <csymbol cd="latexml">for-all</csymbol>
       <csymbol cd="unknown">b</csymbol>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <csymbol cd="unknown">b</csymbol>
        <in></in>
        <csymbol cd="unknown">y</csymbol>
        <csymbol cd="latexml">iff</csymbol>
        <csymbol cd="unknown">b</csymbol>
        <in></in>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>L</ci>
         <ci>ω</ci>
        </apply>
        <csymbol cd="unknown">and</csymbol>
        <csymbol cd="unknown">O</csymbol>
        <csymbol cd="unknown">r</csymbol>
        <csymbol cd="unknown">d</csymbol>
        <cerror>
         <csymbol cd="ambiguous">fragments</csymbol>
         <ci>normal-(</ci>
         <csymbol cd="unknown">b</csymbol>
         <ci>normal-)</ci>
        </cerror>
        <ci>normal-)</ci>
       </cerror>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall y(y\in s\iff(y\in L_{\omega+1}\and(\forall a(a\in y\iff a\in L_{5}\and
Ord%
(a))\forall b(b\in y\iff b\in L_{\omega}\and Ord(b)))))
  </annotation>
 </semantics>
</math>

,<br/>
where 

<math display="inline" id="Constructible_universe:31">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mi>r</mi>
   <mi>d</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>a</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <ci>r</ci>
    <ci>d</ci>
    <ci>a</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Ord(a)
  </annotation>
 </semantics>
</math>

 is short for:<br/>


<math display="inline" id="Constructible_universe:32">
 <semantics>
  <mrow>
   <mo>∀</mo>
   <mi>c</mi>
   <mo>∈</mo>
   <mi>a</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>∀</mo>
    <mi>d</mi>
    <mo>∈</mo>
    <mi>c</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>d</mi>
     <mo>∈</mo>
     <mi>a</mi>
     <mi mathvariant="italic">and</mi>
     <mo>∀</mo>
     <mi>e</mi>
     <mo>∈</mo>
     <mi>d</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>e</mi>
      <mo>∈</mo>
      <mi>c</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">c</csymbol>
    <in></in>
    <csymbol cd="unknown">a</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="latexml">for-all</csymbol>
     <csymbol cd="unknown">d</csymbol>
     <in></in>
     <csymbol cd="unknown">c</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">d</csymbol>
      <in></in>
      <csymbol cd="unknown">a</csymbol>
      <csymbol cd="unknown">and</csymbol>
      <csymbol cd="latexml">for-all</csymbol>
      <csymbol cd="unknown">e</csymbol>
      <in></in>
      <csymbol cd="unknown">d</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">e</csymbol>
       <in></in>
       <csymbol cd="unknown">c</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-.</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall c\in a(\forall d\in c(d\in a\and\forall e\in d(e\in c))).
  </annotation>
 </semantics>
</math>

<br/>
Actually, even this complex formula has been simplified from what the instructions given in the first paragraph would yield. But the point remains, there is a formula of set theory that is true only for the desired constructible set s and that contains parameters only for ordinals.</p>
<h2 id="relative-constructibility">Relative constructibility</h2>

<p>Sometimes it is desirable to find a model of set theory that is narrow like L, but that includes or is influenced by a set that is not constructible. This gives rise to the concept of relative constructibility, of which there are two flavors, denoted L(A) and L[A].</p>

<p>The class L(A) for a non-constructible set A is the intersection of all classes that are standard models of set theory and contain A and all the ordinals.</p>

<p>L(A) is defined by <a href="transfinite_recursion" title="wikilink">transfinite recursion</a> as follows:</p>
<ul>
<li>L<sub>0</sub>(A) = the smallest transitive set containing A as an element, i.e. the <a href="Transitive_closure_(set)" title="wikilink">transitive closure</a> of {A}.</li>
<li>L<sub>α+1</sub>(A) = Def (L<sub>α</sub>(A))</li>
<li>If λ is a limit ordinal, then 

<math display="inline" id="Constructible_universe:33">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>L</mi>
     <mi>λ</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>A</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mo largeop="true" mathsize="160%" stretchy="false" symmetric="true">⋃</mo>
     <mrow>
      <mi>α</mi>
      <mo><</mo>
      <mi>λ</mi>
     </mrow>
    </msub>
    <mrow>
     <msub>
      <mi>L</mi>
      <mi>α</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>A</mi>
      <mo rspace="0.8pt" stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>L</ci>
      <ci>λ</ci>
     </apply>
     <ci>A</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <union></union>
      <apply>
       <lt></lt>
       <ci>α</ci>
       <ci>λ</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>L</ci>
       <ci>α</ci>
      </apply>
      <ci>A</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L_{\lambda}(A)=\bigcup_{\alpha<\lambda}L_{\alpha}(A)\!
  </annotation>
 </semantics>
</math>

.</li>
<li>

<math display="inline" id="Constructible_universe:34">
 <semantics>
  <mrow>
   <mrow>
    <mi>L</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>A</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mo largeop="true" mathsize="160%" stretchy="false" symmetric="true">⋃</mo>
     <mi>α</mi>
    </msub>
    <mrow>
     <msub>
      <mi>L</mi>
      <mi>α</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>A</mi>
      <mo rspace="0.8pt" stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>L</ci>
     <ci>A</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <union></union>
      <ci>α</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>L</ci>
       <ci>α</ci>
      </apply>
      <ci>A</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L(A)=\bigcup_{\alpha}L_{\alpha}(A)\!
  </annotation>
 </semantics>
</math>

.</li>
</ul>

<p>If L(A) contains a well-ordering of the transitive closure of {A}, then this can be extended to a well-ordering of L(A). Otherwise, the axiom of choice will fail in L(A).</p>

<p>A common example is L(<strong>R</strong>), the smallest model that contains all the real numbers, which is used extensively in modern <a href="descriptive_set_theory" title="wikilink">descriptive set theory</a>.</p>

<p>The class L[A] is the class of sets whose construction is influenced by A, where A may be a (presumably non-constructible) set or a proper class. The definition of this class uses Def<sub>A</sub> (X), which is the same as Def (X) except instead of evaluating the truth of formulas Φ in the model (X,∈), one uses the model (X,∈,A) where A is a unary predicate. The intended interpretation of A(y) is y∈A. Then the definition of L[A] is exactly that of L only with Def replaced by Def<sub>A</sub>.</p>

<p>L[A] is always a model of the axiom of choice. Even if A is a set, A is not necessarily itself a member of L[A], although it always is if A is a set of ordinals.</p>

<p>It is essential to remember that the sets in L(A) or L[A] are usually not actually constructible and that the properties of these models may be quite different from the properties of L itself.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Axiom_of_constructibility" title="wikilink">Axiom of constructibility</a></li>
<li><a href="Statements_true_in_L" title="wikilink">Statements true in L</a></li>
<li><a href="Reflection_principle" title="wikilink">Reflection principle</a></li>
<li><a href="Axiomatic_set_theory" title="wikilink">Axiomatic set theory</a></li>
<li><a href="Transitive_set" title="wikilink">Transitive set</a></li>
<li><a class="uri" href="L(R)" title="wikilink">L(R)</a></li>
<li><a href="Ordinal_definable" title="wikilink">Ordinal definable</a></li>
</ul>
<h2 id="notes">Notes</h2>
<references>
</references>
<h2 id="references">References</h2>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Constructible_universe" title="wikilink"> </a> <a href="Category:Works_by_Kurt_Gödel" title="wikilink">Category:Works by Kurt Gödel</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Gödel, 1938<a href="#fnref1">↩</a></li>
<li id="fn2">Barwise 1975, page 60 (comment following proof of theorem 5.9)<a href="#fnref2">↩</a></li>
</ol>
</section>


