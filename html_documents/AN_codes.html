<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title offset="1034">AN codes</title>
   <script type="text/javascript"
      src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js">
    </script>
</head>
<body>
<h1>AN codes</h1>
<hr/>
<p><strong>AN codes</strong><a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> are <a href="error-correcting_code" title="wikilink">error-correcting code</a> that are used in arithmetic applications. Arithmetic codes were commonly used in computer processors to ensure the accuracy of its arithmetic operations when electronics were more unreliable. Arithmetic codes help the processor to detect when an error is made and correct it. Without these codes, processors would be unreliable since any errors would go undetected. AN codes are arithmetic codes that are named for the integers <span class="LaTeX">$A$</span> and <span class="LaTeX">$N$</span> that are used to encode and decode the codewords.</p>
<p>These codes differ from most other codes in that they use arithmetic weight to maximize the arithmetic distance between codewords as opposed to the <a href="hamming_weight" title="wikilink">hamming weight</a> and <a href="hamming_distance" title="wikilink">hamming distance</a>. The arithmetic distance between two words is a measure of the number of errors made while computing an arithmetic operation. Using the arithmetic distance is necessary since one error in an arithmetic operation can cause a large hamming distance between the received answer and the correct answer.</p>
<h2 id="arithmetic-weight-and-distance">Arithmetic Weight and Distance</h2>
<p>The arithmetic weight of an integer <span class="LaTeX">$x$</span> in base <span class="LaTeX">$r$</span> is defined by</p>
<p><span class="LaTeX">$$w(x) = \min \{t | x=\sum_{i=1}^t a_i r^{n(i)}\}$$</span> </p>
<p>where <span class="LaTeX">$|{a_i}|</math>< <math>r$</span>, <span class="LaTeX">$n(i) \geq 0$</span>, and <span class="LaTeX">$r, n(i) \in \mathbb{Z}$</span>. The arithmetic distance of a word is upper bounded by its hamming weight since any integer can be represented by its standard polynomial form of <span class="LaTeX">$x=\sum_{i=1}^n b_i r^i$</span> where the <span class="LaTeX">$b_i$</span> are the digits in the integer. Removing all the terms where <span class="LaTeX">$b_i = 0$</span> will simulate a <span class="LaTeX">$t$</span> equal to its hamming weight. The arithmetic weight will usually be less than the hamming weight since the <span class="LaTeX">$a_i$</span> are allowed to be negative. For example, the integer <span class="LaTeX">$x = 29$</span> which is <span class="LaTeX">$11101$</span> in binary has a hamming weight of <span class="LaTeX">$4$</span>. This is a quick upper bound on the arithmetic weight since <span class="LaTeX">$x = 2^0 + 2^2 + 2^3 + 2^4$</span>. However, since the <span class="LaTeX">$a_i$</span> can be negative, we can write <span class="LaTeX">$x = 2^5 - 2^1 - 2^0$</span> which makes the arithmetic weight equal to <span class="LaTeX">$3$</span>.</p>
<p>The arithmetic distance between two integers is defined by</p>
<p><span class="LaTeX">$$d(x,y) = w(x-y)$$</span> </p>
<p>This is one of the primary metrics used when analyzing arithmetic codes. </p>
<h2 id="an-codes">AN Codes</h2>
<p>AN codes are defined by integers <span class="LaTeX">$A$</span> and <span class="LaTeX">$B$</span> and are used to encode integers from <span class="LaTeX">$0$</span> to <span class="LaTeX">$B-1$</span> such that</p>
<p><span class="LaTeX">$$C = \{ AN|N\in \mathbb{Z}, 0 \leq N </math><<math>B \}$$</span></p>
<p>Each choice of <span class="LaTeX">$A$</span> will result in a different code, while <span class="LaTeX">$B$</span> serves as a limiting factor to ensure useful properties in the distance of the code. If <span class="LaTeX">$B$</span> is too large, it could let a codeword with a very small arithmetic weight into the code which will degrade the distance of the entire code. To utilize these codes, before an arithmetic operation is performed on two integers, each integer is multiplied by <span class="LaTeX">$A$</span>. Let the result of the operation on the codewords be <span class="LaTeX">$R$</span>. Note that <span class="LaTeX">$R$</span> must also be between <span class="LaTeX">$0$</span> to <span class="LaTeX">$B-1$</span> for proper decoding. To decode, simply divide <span class="LaTeX">$R/A$</span>. If <span class="LaTeX">$A$</span> is not a factor of <span class="LaTeX">$R$</span>, then at least one error has occurred and the most likely solution will be the codeword with the least arithmetic distance from <span class="LaTeX">$R$</span>. As with codes using hamming distance, AN codes can correct up to <span class="LaTeX">$\lfloor \frac{d-1}{2} \rfloor$</span> errors where <span class="LaTeX">$d$</span> is the distance of the code.</p>
<p>For example, an AN code with <span class="LaTeX">$A = 3$</span>, the operation of adding <span class="LaTeX">$15$</span> and <span class="LaTeX">$16$</span> will start by encoding both operands. This results in the operation <span class="LaTeX">$R = 45 + 48 = 93$</span>. Then, to find the solution we divide <span class="LaTeX">$93/3 = 31$</span>. As long as <span class="LaTeX">$B$</span>><span class="LaTeX">$31$</span>, this will be a possible operation under the code. Suppose an error occurs in each of the binary representation of the operands such that <span class="LaTeX">$45 = 101101 \rightarrow 101111$</span> and <span class="LaTeX">$48 = 110000 \rightarrow 110001$</span>, then <span class="LaTeX">$R = 101111 + 110001 = 1100000$</span>. Notice that since <span class="LaTeX">$93 = 1011101$</span>, the hamming weight between the received word and the correct solution is <span class="LaTeX">$5$</span> after just <span class="LaTeX">$2$</span> errors. To compute the arithmetic weight, we take <span class="LaTeX">$1100000 - 1011101 = 11$</span> which can be represented as <span class="LaTeX">$11 = 2^0 + 2^1$</span> or <span class="LaTeX">$11 = 2^2 - 2^0$</span>. In either case, the arithmetic distance is <span class="LaTeX">$2$</span> as expected since this is the number of errors that were made. To correct this error, an algorithm would be used to compute the nearest codeword to the received word in terms of arithmetic distance. We will not describe the algorithms in detail.</p>
<p>To ensure that the distance of the code will not be too small, we will define modular AN codes. A modular AN code <span class="LaTeX">$C$</span> is a subgroup of <span class="LaTeX">$\mathbb{Z}/m \mathbb{Z}$</span>, where <span class="LaTeX">$m = AB$</span>. The codes are measured in terms of modular distance which is defined in terms of a graph with vertices being the elements of <span class="LaTeX">$\mathbb{Z}/m \mathbb{Z}$</span>. Two vertices <span class="LaTeX">$x \pmod{m}$</span> and <span class="LaTeX">$x' \pmod{m}$</span> are connected iff</p>
<p><span class="LaTeX">$$x - x' \equiv \pm c \cdot r^j \pmod{m}$$</span></p>
<p>where <span class="LaTeX">$c,j \in \mathbb{Z}$</span> and <span class="LaTeX">$0 </math><<math> c </math><<math> r$</span>, <span class="LaTeX">$j \geq 0$</span>. Then the modular distance between two words is the length of the shortest path between their nodes in the graph. The modular weight of a word is its distance from <span class="LaTeX">$0$</span> which is equal to</p>
<p><span class="LaTeX">$$w_m(x) = min\{w(y)|y \in \mathbb{Z}, y \equiv x \pmod{m} \}$$</span></p>
<p>In practice, the value of <span class="LaTeX">$m$</span> is typically chosen such that <span class="LaTeX">$m=r^n -1$</span> since most computer arithmetic is computed <span class="LaTeX">$\mod 2^n-1$</span> so there is no additional loss of data due to the code going out of bounds since the computer will also be out of bounds. Choosing <span class="LaTeX">$m=r^n-1$</span> also tends to result in codes with larger distances than other codes.</p>
<p>By using modular weight with <span class="LaTeX">$m=r^n-1$</span>, the AN codes will be <a href="cyclic_code" title="wikilink">cyclic code</a>.</p>
<p><strong>definition</strong>: A cyclic AN code is a code <span class="LaTeX">$C$</span> that is a subgroup of <span class="LaTeX">$[r^n-1]$</span>, where <span class="LaTeX">$[r^n-1] = \{0,1,2,\dots,r^n-1\}$</span>.</p>
<p>A cyclic AN code is a principal ideal of the ring <span class="LaTeX">$[r^n-1]$</span>. There are integers <span class="LaTeX">$A$</span> and <span class="LaTeX">$B$</span> where <span class="LaTeX">$AB = r^n-1$</span> and <span class="LaTeX">$A,B$</span> satisfy the definition of an AN code. Cyclic AN codes are a subset of cyclic codes and have the same properties.</p>
<h2 id="mandelbaum-barrows-codes">Mandelbaum-Barrows Codes</h2>
<p>The Mandelbaum-Barrows Codes are a type of cyclic AN codes introduced by D. Mandelbaum and J. T. Barrows.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a><a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> These codes are created by choosing <span class="LaTeX">$B$</span> to be a prime number that does not divide <span class="LaTeX">$r$</span> such that <span class="LaTeX">$\mathbb{Z}/B\mathbb{Z}$</span> is generated by <span class="LaTeX">$r$</span> and <span class="LaTeX">$-1$</span>, and <span class="LaTeX">$m=r^n-1$</span>. Let <span class="LaTeX">$n$</span> be a positive integer where <span class="LaTeX">$r^n \equiv 1 \pmod{B}$</span> and <span class="LaTeX">$A = (r^n -1)/B$</span>. For example, choosing <span class="LaTeX">$r=2, B=5, n=4$</span>, and <span class="LaTeX">$A= (r^n-1)/B = 3$</span> the result will be a Mandelbaum-Barrows Code such that <span class="LaTeX">$C = \{ 3N|N\in \mathbb{Z}, 0 \leq N </math><<math>5 \}$</span> in base <span class="LaTeX">$2$</span>.</p>
<p>To analyze the distance of the Mandelbaum-Barrows Codes, we will need the following theorem.</p>
<p><strong>theorem</strong>: Let <span class="LaTeX">$C \subset [r^n - 1]$</span> be a cyclic AN code with generator <span class="LaTeX">$A$</span>, and</p>
<p><span class="LaTeX">$$B = |C| =  (r^n - 1)/A$$</span></p>
<p>Then,</p>
<p><span class="LaTeX">$$\sum_{x \in C} w_m(x) = n(\lfloor\frac{rB}{r+1}\rfloor - \lfloor\frac{B}{r+1}\rfloor)$$</span></p>
<p><strong>proof</strong>: Assume that each <span class="LaTeX">$x \in C$</span> has a unique cyclic <a class="uri" href="NAF" title="wikilink">NAF</a><a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> representation which is</p>
<p><span class="LaTeX">$$x \equiv \sum_{i=0}^{n-1} c_{i,x}r^i \pmod{r^n -1}$$</span></p>
<p>We define an <span class="LaTeX">$n \times B$</span> matrix with elements <span class="LaTeX">$c_{i,x}$</span> where <span class="LaTeX">$0 \leq i \leq n-1$</span> and <span class="LaTeX">$x \in C$</span>. This matrix is essentially a list of all the codewords in <span class="LaTeX">$C$</span> where each column is a codeword. Since <span class="LaTeX">$C$</span> is cyclic, each column of the matrix has the same number of zeros. We must now calculate <span class="LaTeX">$n|\{  x \in C | c_{n-1,x} \neq 0\}|$</span>, which is <span class="LaTeX">$n$</span> times the number of codewords that don't end with a <span class="LaTeX">$0$</span>. As a property of being in cyclic NAF, <span class="LaTeX">$c_{n-1,x} \neq 0$</span> iff there is a <span class="LaTeX">$y \in \mathbb{Z}$</span> with <span class="LaTeX">$y \equiv x \pmod{ r^n -1}, \frac{m}{r+1}</math><<math>y \leq \frac{mr}{r+1}$</span>. Since <span class="LaTeX">$x = AN \pmod{r^n-1}$</span> with <span class="LaTeX">$0 \leq N</math><<math>B$</span>, then <span class="LaTeX">$\frac{B}{r+1}</math><<math>N \leq \frac{Br}{r+1}$</span>. Then the number of integers that have a zero as their last bit are <span class="LaTeX">$\lfloor\frac{rB}{r+1}\rfloor - \lfloor\frac{B}{r+1}\rfloor$</span>. Multiplying this by the <span class="LaTeX">$n$</span> characters in the codewords gives us a sum of the weights of the codewords of <span class="LaTeX">$n(\lfloor\frac{rB}{r+1}\rfloor - \lfloor\frac{B}{r+1}\rfloor)$</span> as desired.</p>
<p>We will now use the previous theorem to show that the Mandelbaum-Barrows Codes are equidistant(which means that every pair of codewords have the same distance), with a distance of</p>
<p><span class="LaTeX">$$\frac{n}{B-1}(\lfloor\frac{rB}{r+1}\rfloor - \lfloor\frac{B}{r+1}\rfloor)$$</span></p>
<p><strong>proof</strong>: Let <span class="LaTeX">$x \in C, x \neq 0$</span>, then <span class="LaTeX">$x = AN \pmod{r^n-1}$</span> and <span class="LaTeX">$N$</span> is not divisible by <span class="LaTeX">$B$</span>. This implies there <span class="LaTeX">$\exists j (N \equiv \pm r^j \pmod{B})$</span>. Then <span class="LaTeX">$w_m(x) = w_m(\pm r^j A) = w_m(A)$</span>. This proves that <span class="LaTeX">$C$</span> is equidistant since all codewords have the same weight as <span class="LaTeX">$A$</span>. Since all codewords have the same weight, and by the previous theorem we know the total weight of all codewords, the distance of the code is found by dividing the total weight by the number of codewords(excluding 0).</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Error_detection_and_correction" title="wikilink">Error detection and correction</a></li>
<li><a href="Forward_Error_Correction" title="wikilink">Forward Error Correction</a></li>
</ul>
<h2 id="references">References</h2>
<p>"</p>
<p><a href="Category:Error_detection_and_correction" title="wikilink">Category:Error detection and correction</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Peterson, W. W. and Weldon, E. J.: Error-correcting Codes. Cambridge, Mass.: MIT Press, 1972<a href="#fnref1">↩</a></li>
<li id="fn2">Massey, J. L. and Garcia, O. N.: Error-correcting codes in computer arithmetic. In: Advances in Information Systems Science, Vol. 4, Ch. 5. (Edited by J. T. Ton). New York: Plenum Press, 1972<a href="#fnref2">↩</a></li>
<li id="fn3">J.H. Van Lint (1982). Introduction to Coding Theory. GTM. 86. New York: Springer-Verlag.<a href="#fnref3">↩</a></li>
<li id="fn4">Clark, W. E. and Liang, J. J.: On modular weight and cyclic nonadjacent forms for arithmetic codes. IEEE Trans. Info. Theory, 20 pp. 767-770(1974)<a href="#fnref4">↩</a></li>
</ol>
</section>
</body>
</html>
