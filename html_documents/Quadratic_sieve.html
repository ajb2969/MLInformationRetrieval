<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1761">Quadratic sieve</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Quadratic sieve</h1>
<hr/>

<p>The <strong>quadratic sieve</strong> <a class="uri" href="algorithm" title="wikilink">algorithm</a> (<strong>QS</strong>) is an <a href="integer_factorization" title="wikilink">integer factorization</a> algorithm and, in practice, the second fastest method known (after the <a href="general_number_field_sieve" title="wikilink">general number field sieve</a>). It is still the fastest for integers under 100 decimal digits or so, and is considerably simpler than the number field sieve. It is a general-purpose factorization algorithm, meaning that its running time depends solely on the size of the <a class="uri" href="integer" title="wikilink">integer</a> to be factored, and not on special structure or properties. It was invented by <a href="Carl_Pomerance" title="wikilink">Carl Pomerance</a> in 1981 as an improvement to Schroeppel's linear sieve.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>
<h2 id="basic-aim">Basic aim</h2>

<p>The algorithm attempts to set up a <a href="congruence_of_squares" title="wikilink">congruence of squares</a> <a href="modular_arithmetic" title="wikilink">modulo</a> <em>n</em> (the integer to be factorized), which often leads to a factorization of <em>n</em>. The algorithm works in two phases: the <em>data collection</em> phase, where it collects information that may lead to a congruence of squares; and the <em>data processing</em> phase, where it puts all the data it has collected into a <a href="Matrix_(mathematics)" title="wikilink">matrix</a> and solves it to obtain a congruence of squares. The data collection phase can be easily <a href="parallel_computing" title="wikilink">parallelized</a> to many processors, but the data processing phase requires large amounts of memory, and is difficult to parallelize efficiently over many nodes or if the processing nodes do not each have enough memory to store the whole matrix. The <a href="block_Wiedemann_algorithm" title="wikilink">block Wiedemann algorithm</a> can be used in the case of a few systems each capable of holding the matrix.</p>

<p>The naive approach to finding a congruence of squares is to pick a random number, square it, and hope the least non-negative remainder modulo <em>n</em> is a <a href="Square_number" title="wikilink">perfect square</a> (in the integers). For example, 80<sup>2</sup> mod 5959 is 441, which is 21<sup>2</sup>. This approach finds a congruence of squares only rarely for large <em>n</em>, but when it does find one, more often than not, the congruence is nontrivial and the factorization is complete. This is roughly the basis of <a href="Fermat's_factorization_method" title="wikilink">Fermat's factorization method</a>.</p>

<p>The quadratic sieve is a modification of <a href="Dixon's_factorization_method" title="wikilink">Dixon's factorization method</a>.</p>

<p>The general running time required for the quadratic sieve (to factor an integer <em>n</em>) is</p>

<p>

<math display="block" id="Quadratic_sieve:0">
 <semantics>
  <mrow>
   <msup>
    <mi>e</mi>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mn>1</mn>
       <mo>+</mo>
       <mrow>
        <mi>o</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mn>1</mn>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <msqrt>
      <mrow>
       <mi>ln</mi>
       <mrow>
        <mi>n</mi>
        <mrow>
         <mi>ln</mi>
         <mrow>
          <mi>ln</mi>
          <mi>n</mi>
         </mrow>
        </mrow>
       </mrow>
      </mrow>
     </msqrt>
    </mrow>
   </msup>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>L</mi>
     <mi>n</mi>
    </msub>
    <mrow>
     <mo>[</mo>
     <mrow>
      <mn>1</mn>
      <mo>/</mo>
      <mn>2</mn>
     </mrow>
     <mo>,</mo>
     <mn>1</mn>
     <mo>]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>e</ci>
     <apply>
      <times></times>
      <apply>
       <plus></plus>
       <cn type="integer">1</cn>
       <apply>
        <times></times>
        <ci>o</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <root></root>
       <apply>
        <ln></ln>
        <apply>
         <times></times>
         <ci>n</ci>
         <apply>
          <ln></ln>
          <apply>
           <ln></ln>
           <ci>n</ci>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>L</ci>
      <ci>n</ci>
     </apply>
     <interval closure="closed">
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <cn type="integer">2</cn>
      </apply>
      <cn type="integer">1</cn>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e^{(1+o(1))\sqrt{\ln n\ln\ln n}}=L_{n}\left[1/2,1\right]
  </annotation>
 </semantics>
</math>

 in the <a class="uri" href="L-notation" title="wikilink">L-notation</a>.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>

<p>The constant <em>e</em> is the base of the natural logarithm.</p>
<h2 id="the-approach">The approach</h2>

<p>Let <em>x</em> <a href="modular_arithmetic" title="wikilink">mod</a> <em>y</em> denote the remainder after <a href="division_(mathematics)#Division_of_integers" title="wikilink">dividing</a> x by y. To factorize the integer <em>n</em>, <a href="Fermat's_factorization_method" title="wikilink">Fermat's method</a> entails a search for a single number <em>a</em> such that <em>a</em><sup>2</sup> mod <em>n</em> is a square. But these <em>a</em> are hard to find. The quadratic sieve consists of computing <em>a</em><sup>2</sup> mod <em>n</em> for several <em>a</em>, then finding a subset of these whose product is a square. This will yield a congruence of squares.</p>

<p>For example, 41<sup>2</sup> mod 1649 = 32, 42<sup>2</sup> mod 1649 = 115, and 43<sup>2</sup> mod 1649 is 200. None of these are squares, but the product (32)(200) = 6400 = 80<sup>2</sup>, and mod 1649, (32)(200) = (41<sup>2</sup>)(43<sup>2</sup>) = ((41)(43))<sup>2</sup>. Since (41)(43) mod 1649 = 114, this gives a congruence of squares: 114<sup>2</sup> ≡ 80<sup>2</sup> (mod 1649). To finish this factorization example, continue reading <a href="Congruence_of_squares" title="wikilink">Congruence of squares</a>.</p>

<p>But how will this solve the problem of, given a set of numbers, finding a subset whose product is a square? The solution uses the concept of an <em>exponent <a href="vector_(mathematics)" title="wikilink">vector</a></em>. For example, the <a href="fundamental_theorem_of_arithmetic" title="wikilink">prime-power factorization</a> of 504 is 2<sup>3</sup>3<sup>2</sup>5<sup>0</sup>7<sup>1</sup>. It can be represented by the exponent vector (3,2,0,1), which gives the exponents of 2, 3, 5, and 7 in the prime factorization. The number 490 would similarly have the vector (1,0,1,2). Multiplying the numbers is the same as componentwise adding their exponent vectors: (504)(490) has the vector (4,2,1,3).</p>

<p>A number is a square if every number in its exponent vector is even. For example, the vectors (3,0,0,1) and (1,2,0,1) add to (4,2,0,2), so (56)(126) is a square. Searching for a square requires knowledge only of the <a href="parity_(mathematics)" title="wikilink">parity</a> of the numbers in the vectors, so it is possible to reduce the entire vector mod 2 and perform addition of elements mod 2: (1,0,0,1) + (1,0,0,1) = (0,0,0,0). This is particularly efficient in practical implementations, as the vectors can be represented as <a href="bitset" title="wikilink">bitsets</a> and addition mod 2 reduces to <a href="bitwise_operation#XOR" title="wikilink">bitwise XOR</a>.</p>

<p>The problem is reduced to: given a set of (0,1)-vectors, find a subset which adds to the <a href="zero_vector" title="wikilink">zero vector</a> mod 2. This is a <a href="linear_algebra" title="wikilink">linear algebra</a> problem; the solution is a <a href="linear_dependency" title="wikilink">linear dependency</a>. It is a theorem of linear algebra that with more vectors than each vector has elements, such a dependency must exist. It can be found efficiently, for example by placing the vectors as rows in a <a href="matrix_(mathematics)" title="wikilink">matrix</a> and then using <a href="Gaussian_elimination" title="wikilink">Gaussian elimination</a>, which is easily adapted to work for integers mod 2 instead of <a href="real_number" title="wikilink">real numbers</a>. The desired square is then the product of the numbers corresponding to those vectors.</p>

<p>However, simply squaring many random numbers mod <em>n</em> produces a very large number of different prime factors, and so very long vectors and a very large matrix. The answer is to look specifically for numbers <em>a</em> such that <em>a</em><sup>2</sup> mod <em>n</em> has only small prime factors (they are <a href="smooth_number" title="wikilink">smooth numbers</a>). They are harder to find, but using only smooth numbers keeps the vectors and matrices smaller and more tractable. The quadratic sieve searches for smooth numbers using a technique called <a href="sieve_theory" title="wikilink">sieving</a>, discussed later, from which the algorithm takes its name.</p>
<h2 id="the-algorithm">The algorithm</h2>

<p>To summarize, the basic quadratic sieve algorithm has these main steps:</p>
<ol>
<li>Choose a <a href="Smooth_number#Definition" title="wikilink">smoothness bound</a> <em>B</em>. The number π(<em>B</em>), denoting the number of prime numbers less than <em>B</em>, will control both the length of the vectors and the number of vectors needed.</li>
<li>Use sieving to locate π(<em>B</em>) + 1 numbers <em>a<sub>i</sub></em> such that <em>b<sub>i</sub></em>=(<em>a<sub>i</sub></em><sup>2</sup> mod <em>n</em>) is <em>B</em>-smooth.</li>
<li>Factor the <em>b<sub>i</sub></em> and generate exponent vectors mod 2 for each one.</li>
<li>Use linear algebra to find a subset of these vectors which add to the zero vector. Multiply the corresponding ''a<sub>i</sub> ''together naming the result mod <em>n</em>: <em>a</em> and the <em>b<sub>i</sub></em> together which yields a <em>B</em>-smooth square <em>b<sup>2</sup></em>.</li>
<li>We are now left with the equality <em>a</em><sup>2</sup>=<em>b</em><sup>2</sup> mod <em>n</em> from which we get two square roots of (<em>a</em><sup>2</sup> mod <em>n</em>), one by taking the square root in the integers of <em>b<sup>2</sup></em> namely <em>b</em>, and the other the <em>a</em> computed in step 4.</li>
<li>We now have the desired identity

<math display="block" id="Quadratic_sieve:1">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>a</mi>
      <mo>+</mo>
      <mi>b</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>a</mi>
      <mo>-</mo>
      <mi>b</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mn>0</mn>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mrow>
     <mo lspace="8.1pt" stretchy="false">(</mo>
     <mrow>
      <mo>mod</mo>
      <mi>n</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <plus></plus>
      <ci>a</ci>
      <ci>b</ci>
     </apply>
     <apply>
      <minus></minus>
      <ci>a</ci>
      <ci>b</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <cn type="integer">0</cn>
     <apply>
      <ci>pmod</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (a+b)(a-b)=0\;\;(\mathop{{\rm mod}}n)
  </annotation>
 </semantics>
</math>

. Compute the GCD of <em>n</em> with the difference (or sum) of <em>a</em> and <em>b</em>. This produces a factor, although it may be a trivial factor (<em>n</em> or 1). If the factor is trivial, try again with a different linear dependency or different <em>a</em>.</li>
</ol>

<p>The remainder of this article explains details and extensions of this basic algorithm.</p>
<h2 id="how-qs-optimizes-finding-congruences">How QS optimizes finding congruences</h2>

<p>The quadratic sieve attempts to find pairs of integers <em>x</em> and <em>y(x)</em> (where <em>y(x)</em> is a function of <em>x</em>) satisfying a much weaker condition than <em>x</em><sup>2</sup> ≡ <em>y</em><sup>2</sup> (mod <em>n</em>). It selects a set of <a href="prime_number" title="wikilink">primes</a> called the <em>factor base</em>, and attempts to find <em>x</em> such that the least absolute remainder of <em>y(x)</em> = <em>x</em><sup>2</sup> mod <em>n</em> factorizes completely over the factor base. Such <em>x</em> values are said to be <em>smooth</em> with respect to the factor base.</p>

<p>The factorization of a value of y(x) that splits over the factor base, together with the value of x, is known as a <em>relation</em>. The quadratic sieve speeds up the process of finding relations by taking <em>x</em> close to the square root of <em>n</em>. This ensures that <em>y(x)</em> will be smaller, and thus have a greater chance of being smooth.</p>

<p>

<math display="block" id="Quadratic_sieve:2">
 <semantics>
  <mrow>
   <mrow>
    <mi>y</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msup>
     <mrow>
      <mo>(</mo>
      <mrow>
       <mrow>
        <mo>⌈</mo>
        <msqrt>
         <mi>n</mi>
        </msqrt>
        <mo>⌉</mo>
       </mrow>
       <mo>+</mo>
       <mi>x</mi>
      </mrow>
      <mo>)</mo>
     </mrow>
     <mn>2</mn>
    </msup>
    <mo>-</mo>
    <mrow>
     <mi>n</mi>
     <mtext>(where</mtext>
     <mi>x</mi>
     <mtext>is a small integer)</mtext>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>y</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <plus></plus>
       <apply>
        <ceiling></ceiling>
        <apply>
         <root></root>
         <ci>n</ci>
        </apply>
       </apply>
       <ci>x</ci>
      </apply>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <times></times>
      <ci>n</ci>
      <mtext>(where</mtext>
      <ci>x</ci>
      <mtext>is a small integer)</mtext>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y(x)=\left(\left\lceil\sqrt{n}\right\rceil+x\right)^{2}-n\hbox{ (where }x\hbox%
{ is a small integer)}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Quadratic_sieve:3">
 <semantics>
  <mrow>
   <mrow>
    <mi>y</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≈</mo>
   <mrow>
    <mn>2</mn>
    <mi>x</mi>
    <mrow>
     <mo>⌈</mo>
     <msqrt>
      <mi>n</mi>
     </msqrt>
     <mo>⌉</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <apply>
     <times></times>
     <ci>y</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <cn type="integer">2</cn>
     <ci>x</ci>
     <apply>
      <ceiling></ceiling>
      <apply>
       <root></root>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y(x)\approx 2x\left\lceil\sqrt{n}\right\rceil
  </annotation>
 </semantics>
</math>

</p>

<p>This implies that <em>y</em> is on the order of 2<em>x</em>[√<em>n</em>]. However, it also implies that <em>y</em> grows linearly with x times the square root of n.</p>

<p>Another way to increase the chance of smoothness is by simply increasing the size of the factor base. However, it is necessary to find at least one smooth relation more than the number of primes in the factor base, to ensure the existence of a linear dependency.</p>
<h3 id="partial-relations-and-cycles">Partial relations and cycles</h3>

<p>Even if for some relation <em>y(x)</em> is not smooth, it may be possible to merge two of these <em>partial relations</em> to form a full one, if the two <em>y</em> 's are products of the same prime(s) outside the factor base. [Note that this is equivalent to extending the factor base.] For example, if the factor base is {2, 3, 5, 7} and <em>n</em> = 91, there are partial relations:</p>

<p>

<math display="block" id="Quadratic_sieve:4">
 <semantics>
  <mrow>
   <msup>
    <mn>21</mn>
    <mn>2</mn>
   </msup>
   <mo>≡</mo>
   <mrow>
    <mrow>
     <msup>
      <mn>7</mn>
      <mn>1</mn>
     </msup>
     <mo>⋅</mo>
     <mn>11</mn>
    </mrow>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mrow>
     <mo lspace="8.1pt" stretchy="false">(</mo>
     <mrow>
      <mo>mod</mo>
      <mn>91</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">21</cn>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <apply>
      <ci>normal-⋅</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">7</cn>
       <cn type="integer">1</cn>
      </apply>
      <cn type="integer">11</cn>
     </apply>
     <apply>
      <ci>pmod</ci>
      <cn type="integer">91</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {21^{2}\equiv 7^{1}\cdot 11\;\;(\mathop{{\rm mod}}91)}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Quadratic_sieve:5">
 <semantics>
  <mrow>
   <msup>
    <mn>29</mn>
    <mn>2</mn>
   </msup>
   <mo>≡</mo>
   <mrow>
    <mrow>
     <msup>
      <mn>2</mn>
      <mn>1</mn>
     </msup>
     <mo>⋅</mo>
     <mn>11</mn>
    </mrow>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mrow>
     <mo lspace="8.1pt" stretchy="false">(</mo>
     <mrow>
      <mo>mod</mo>
      <mn>91</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">29</cn>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <apply>
      <ci>normal-⋅</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">2</cn>
       <cn type="integer">1</cn>
      </apply>
      <cn type="integer">11</cn>
     </apply>
     <apply>
      <ci>pmod</ci>
      <cn type="integer">91</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {29^{2}\equiv 2^{1}\cdot 11\;\;(\mathop{{\rm mod}}91)}
  </annotation>
 </semantics>
</math>

</p>

<p>Multiply these together:</p>

<p>

<math display="block" id="Quadratic_sieve:6">
 <semantics>
  <mrow>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mn>21</mn>
      <mo>⋅</mo>
      <mn>29</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mn>2</mn>
   </msup>
   <mo>≡</mo>
   <mrow>
    <mrow>
     <msup>
      <mn>2</mn>
      <mn>1</mn>
     </msup>
     <mo>⋅</mo>
     <msup>
      <mn>7</mn>
      <mn>1</mn>
     </msup>
     <mo>⋅</mo>
     <msup>
      <mn>11</mn>
      <mn>2</mn>
     </msup>
    </mrow>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mrow>
     <mo lspace="8.1pt" stretchy="false">(</mo>
     <mrow>
      <mo>mod</mo>
      <mn>91</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <ci>normal-⋅</ci>
      <cn type="integer">21</cn>
      <cn type="integer">29</cn>
     </apply>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <apply>
      <ci>normal-⋅</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">2</cn>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">7</cn>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">11</cn>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <ci>pmod</ci>
      <cn type="integer">91</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {(21\cdot 29)^{2}\equiv 2^{1}\cdot 7^{1}\cdot 11^{2}\;\;(\mathop{{\rm mod}}91)}
  </annotation>
 </semantics>
</math>

</p>

<p>and multiply both sides by (11<sup>−1</sup>)<sup>2</sup> modulo 91. 11<sup>−1</sup> modulo 91 is 58, so:</p>

<p>

<math display="block" id="Quadratic_sieve:7">
 <semantics>
  <mrow>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mn>58</mn>
      <mo>⋅</mo>
      <mn>21</mn>
      <mo>⋅</mo>
      <mn>29</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mn>2</mn>
   </msup>
   <mo>≡</mo>
   <mrow>
    <mrow>
     <msup>
      <mn>2</mn>
      <mn>1</mn>
     </msup>
     <mo>⋅</mo>
     <msup>
      <mn>7</mn>
      <mn>1</mn>
     </msup>
    </mrow>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mrow>
     <mo lspace="8.1pt" stretchy="false">(</mo>
     <mrow>
      <mo>mod</mo>
      <mn>91</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <ci>normal-⋅</ci>
      <cn type="integer">58</cn>
      <cn type="integer">21</cn>
      <cn type="integer">29</cn>
     </apply>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <apply>
      <ci>normal-⋅</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">2</cn>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">7</cn>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <ci>pmod</ci>
      <cn type="integer">91</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (58\cdot 21\cdot 29)^{2}\equiv 2^{1}\cdot 7^{1}\;\;(\mathop{{\rm mod}}91)
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Quadratic_sieve:8">
 <semantics>
  <mrow>
   <msup>
    <mn>14</mn>
    <mn>2</mn>
   </msup>
   <mo>≡</mo>
   <mrow>
    <mrow>
     <msup>
      <mn>2</mn>
      <mn>1</mn>
     </msup>
     <mo>⋅</mo>
     <msup>
      <mn>7</mn>
      <mn>1</mn>
     </msup>
    </mrow>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mrow>
     <mo lspace="8.1pt" stretchy="false">(</mo>
     <mrow>
      <mo>mod</mo>
      <mn>91</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">14</cn>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <apply>
      <ci>normal-⋅</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">2</cn>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">7</cn>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <ci>pmod</ci>
      <cn type="integer">91</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   14^{2}\equiv 2^{1}\cdot 7^{1}\;\;(\mathop{{\rm mod}}91)
  </annotation>
 </semantics>
</math>

</p>

<p>producing a full relation. Such a full relation (obtained by combining partial relations) is called a <em>cycle</em>. Sometimes, forming a cycle from two partial relations leads directly to a congruence of squares, but rarely.</p>
<h3 id="checking-smoothness-by-sieving">Checking smoothness by sieving</h3>

<p>There are several ways to check for smoothness of the <em>y</em>s. The most obvious is by <a href="trial_division" title="wikilink">trial division</a>, although this increases the running time for the data collection phase. Another method that has some acceptance is the <a href="Lenstra_elliptic_curve_factorization" title="wikilink">elliptic curve method</a> (ECM). In practice, a process called <em>sieving</em> is typically used. If <em>f(x)</em> is the polynomial <em>f(x)=x^2-n</em> we have</p>

<p>

<math display="block" id="Quadratic_sieve:9">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>x</mi>
     <mn>2</mn>
    </msup>
    <mo>-</mo>
    <mi>n</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x)=x^{2}-n
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Quadratic_sieve:10">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>x</mi>
      <mo>+</mo>
      <mrow>
       <mi>k</mi>
       <mi>p</mi>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>x</mi>
       <mo>+</mo>
       <mrow>
        <mi>k</mi>
        <mi>p</mi>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mn>2</mn>
    </msup>
    <mo>-</mo>
    <mi>n</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <apply>
      <plus></plus>
      <ci>x</ci>
      <apply>
       <times></times>
       <ci>k</ci>
       <ci>p</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <plus></plus>
       <ci>x</ci>
       <apply>
        <times></times>
        <ci>k</ci>
        <ci>p</ci>
       </apply>
      </apply>
      <cn type="integer">2</cn>
     </apply>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x+kp)=(x+kp)^{2}-n
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Quadratic_sieve:11">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>x</mi>
      <mo>+</mo>
      <mrow>
       <mi>k</mi>
       <mi>p</mi>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msup>
      <mi>x</mi>
      <mn>2</mn>
     </msup>
     <mo>+</mo>
     <mrow>
      <mn>2</mn>
      <mi>x</mi>
      <mi>k</mi>
      <mi>p</mi>
     </mrow>
     <mo>+</mo>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>k</mi>
        <mi>p</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mn>2</mn>
     </msup>
    </mrow>
    <mo>-</mo>
    <mi>n</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <apply>
      <plus></plus>
      <ci>x</ci>
      <apply>
       <times></times>
       <ci>k</ci>
       <ci>p</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>x</ci>
       <ci>k</ci>
       <ci>p</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <times></times>
        <ci>k</ci>
        <ci>p</ci>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x+kp)=x^{2}+2xkp+(kp)^{2}-n
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Quadratic_sieve:12">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>x</mi>
      <mo>+</mo>
      <mrow>
       <mi>k</mi>
       <mi>p</mi>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mn>2</mn>
     <mi>x</mi>
     <mi>k</mi>
     <mi>p</mi>
    </mrow>
    <mo>+</mo>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>k</mi>
       <mi>p</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mn>2</mn>
    </msup>
   </mrow>
   <mo>≡</mo>
   <mrow>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mrow>
     <mo lspace="8.1pt" stretchy="false">(</mo>
     <mrow>
      <mo>mod</mo>
      <mi>p</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>f</ci>
      <apply>
       <plus></plus>
       <ci>x</ci>
       <apply>
        <times></times>
        <ci>k</ci>
        <ci>p</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>f</ci>
       <ci>x</ci>
      </apply>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>x</ci>
       <ci>k</ci>
       <ci>p</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <times></times>
        <ci>k</ci>
        <ci>p</ci>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <equivalent></equivalent>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="latexml">annotated</csymbol>
      <apply>
       <times></times>
       <ci>f</ci>
       <ci>x</ci>
      </apply>
      <apply>
       <ci>pmod</ci>
       <ci>p</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x+kp)=f(x)+2xkp+(kp)^{2}\equiv f(x)\;\;(\mathop{{\rm mod}}p)
  </annotation>
 </semantics>
</math>

</p>

<p>Thus solving <em>f(x)</em> ≡ 0 (mod <em>p</em>) for <em>x</em> generates a whole sequence of <em>y=f(x)</em>s which are divisible by <em>p</em>. This is finding a square root modulo a prime, for which there exist efficient algorithms, such as the <a href="Shanks–Tonelli_algorithm" title="wikilink">Shanks–Tonelli algorithm</a>. (This is where the quadratic sieve gets its name: <em>y</em> is a quadratic polynomial in <em>x</em>, and the sieving process works like the <a href="Sieve_of_Eratosthenes" title="wikilink">Sieve of Eratosthenes</a>.)</p>

<p>The sieve starts by setting every entry in a large array <em>A</em>[] of bytes to zero. For each <em>p</em>, solve the quadratic equation mod <em>p</em> to get two roots <em>α</em> and <em>β</em>, and then add an approximation to log(p) to every entry for which <em>y</em>(<em>x</em>) = 0 mod <em>p</em> ... that is, <em>A</em>[<em>kp</em> + <em>α</em>] and <em>A</em>[<em>kp</em> + <em>β</em>]. It is also necessary to solve the quadratic equation modulo small powers of <em>p</em> in order to recognise numbers divisible by the square of a factor-base prime.</p>

<p>At the end of the factor base, any <em>A</em>[] containing a value above a threshold of roughly log(<em>n</em>) will correspond to a value of <em>y</em>(<em>x</em>) which splits over the factor base. The information about exactly which primes divide <em>y</em>(<em>x</em>) has been lost, but it has only small factors, and there are many good algorithms (trial division by small primes, <a class="uri" href="SQUFOF" title="wikilink">SQUFOF</a>, <a href="Pollard_rho" title="wikilink">Pollard rho</a>, and ECM are usually used in some combination) for factoring a number known to have only small factors.</p>

<p>There are many <em>y</em>(<em>x</em>) values that work, so the factorization process at the end doesn't have to be entirely reliable; often the processes misbehave on say 5% of inputs, requiring a small amount of extra sieving.</p>
<h2 id="example-of-basic-sieve">Example of basic sieve</h2>

<p>This example will demonstrate standard quadratic sieve without logarithm optimizations or prime powers. Let the number to be factored <em>N</em> = 15347, therefore the ceiling of the square root of <em>N</em> is 124. Since <em>N</em> is small, the basic polynomial is enough: <em>y</em>(<em>x</em>) = (<em>x</em> + 124)<sup>2</sup> − 15347.</p>
<h3 id="data-collection">Data collection</h3>

<p>Since <em>N</em> is small, only 4 primes are necessary. The first 4 primes <em>p</em> for which 15347 has a square root mod <em>p</em> are 2, 17, 23, and 29 (in other words, 15347 is a <a href="quadratic_residue" title="wikilink">quadratic residue</a> modulo each of these primes). These primes will be the basis for sieving.</p>

<p>Now we construct our sieve 

<math display="inline" id="Quadratic_sieve:13">
 <semantics>
  <msub>
   <mi>V</mi>
   <mi>X</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>V</ci>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V_{X}
  </annotation>
 </semantics>
</math>

 of 

<math display="inline" id="Quadratic_sieve:14">
 <semantics>
  <mrow>
   <mrow>
    <mi>Y</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>X</mi>
       <mo>+</mo>
       <mrow>
        <mo stretchy="false">⌈</mo>
        <msqrt>
         <mi>N</mi>
        </msqrt>
        <mo stretchy="false">⌉</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mn>2</mn>
    </msup>
    <mo>-</mo>
    <mi>N</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>X</mi>
       <mo>+</mo>
       <mn>124</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mn>2</mn>
    </msup>
    <mo>-</mo>
    <mn>15347</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>Y</ci>
      <ci>X</ci>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <plus></plus>
        <ci>X</ci>
        <apply>
         <ceiling></ceiling>
         <apply>
          <root></root>
          <ci>N</ci>
         </apply>
        </apply>
       </apply>
       <cn type="integer">2</cn>
      </apply>
      <ci>N</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <plus></plus>
        <ci>X</ci>
        <cn type="integer">124</cn>
       </apply>
       <cn type="integer">2</cn>
      </apply>
      <cn type="integer">15347</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y(X)=(X+\lceil\sqrt{N}\rceil)^{2}-N=(X+124)^{2}-15347
  </annotation>
 </semantics>
</math>

 and begin the sieving process for each prime in the basis, choosing to sieve the first 0 ≤ X  \begin{align}V &amp;= \begin{bmatrix} Y(0) &amp; Y(1) &amp; Y(2) &amp; Y(3) &amp; Y(4) &amp; Y(5) &amp; \cdots &amp; Y(99) \end{bmatrix} \\</p>

<p><code>&amp; =\begin{bmatrix} 29 &amp; 278 &amp; 529 &amp; 782 &amp; 1037 &amp; 1294 &amp; \cdots &amp; 34382 \end{bmatrix}\end{align}</code></p>

<p>The next step is to perform the sieve. For each p in our factor base 

<math display="inline" id="Quadratic_sieve:15">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mn>2</mn>
   <mo>,</mo>
   <mn>17</mn>
   <mo>,</mo>
   <mn>23</mn>
   <mo>,</mo>
   <mn>29</mn>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <cn type="integer">2</cn>
    <cn type="integer">17</cn>
    <cn type="integer">23</cn>
    <cn type="integer">29</cn>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{2,17,23,29\}
  </annotation>
 </semantics>
</math>

 solve the equation</p>

<p>

<math display="block" id="Quadratic_sieve:16">
 <semantics>
  <mrow>
   <mrow>
    <mi>Y</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≡</mo>
   <mrow>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>X</mi>
       <mo>+</mo>
       <mrow>
        <mo stretchy="false">⌈</mo>
        <msqrt>
         <mi>N</mi>
        </msqrt>
        <mo stretchy="false">⌉</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mn>2</mn>
    </msup>
    <mo>-</mo>
    <mi>N</mi>
   </mrow>
   <mo>≡</mo>
   <mrow>
    <mn>0</mn>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mrow>
     <mo lspace="8.1pt" stretchy="false">(</mo>
     <mrow>
      <mo>mod</mo>
      <mi>p</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <equivalent></equivalent>
     <apply>
      <times></times>
      <ci>Y</ci>
      <ci>X</ci>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <plus></plus>
        <ci>X</ci>
        <apply>
         <ceiling></ceiling>
         <apply>
          <root></root>
          <ci>N</ci>
         </apply>
        </apply>
       </apply>
       <cn type="integer">2</cn>
      </apply>
      <ci>N</ci>
     </apply>
    </apply>
    <apply>
     <equivalent></equivalent>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="latexml">annotated</csymbol>
      <cn type="integer">0</cn>
      <apply>
       <ci>pmod</ci>
       <ci>p</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y(X)\equiv(X+\lceil\sqrt{N}\rceil)^{2}-N\equiv 0\;\;(\mathop{{\rm mod}}p)
  </annotation>
 </semantics>
</math>

</p>

<p>to find the entries in the array <em>V</em> which are divisible by <em>p</em>.</p>

<p>For 

<math display="inline" id="Quadratic_sieve:17">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mo>=</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>p</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p=2
  </annotation>
 </semantics>
</math>

 solve 

<math display="inline" id="Quadratic_sieve:18">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>X</mi>
       <mo>+</mo>
       <mn>124</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mn>2</mn>
    </msup>
    <mo>-</mo>
    <mn>15347</mn>
   </mrow>
   <mo>≡</mo>
   <mrow>
    <mn>0</mn>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mrow>
     <mo lspace="8.1pt" stretchy="false">(</mo>
     <mrow>
      <mo>mod</mo>
      <mn>2</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <plus></plus>
       <ci>X</ci>
       <cn type="integer">124</cn>
      </apply>
      <cn type="integer">2</cn>
     </apply>
     <cn type="integer">15347</cn>
    </apply>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <cn type="integer">0</cn>
     <apply>
      <ci>pmod</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (X+124)^{2}-15347\equiv 0\;\;(\mathop{{\rm mod}}2)
  </annotation>
 </semantics>
</math>

 to get the solution 

<math display="inline" id="Quadratic_sieve:19">
 <semantics>
  <mrow>
   <mi>X</mi>
   <mo>≡</mo>
   <mrow>
    <msqrt>
     <mn>15347</mn>
    </msqrt>
    <mo>-</mo>
    <mn>124</mn>
   </mrow>
   <mo>≡</mo>
   <mrow>
    <mn>1</mn>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mrow>
     <mo lspace="8.1pt" stretchy="false">(</mo>
     <mrow>
      <mo>mod</mo>
      <mn>2</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <equivalent></equivalent>
     <ci>X</ci>
     <apply>
      <minus></minus>
      <apply>
       <root></root>
       <cn type="integer">15347</cn>
      </apply>
      <cn type="integer">124</cn>
     </apply>
    </apply>
    <apply>
     <equivalent></equivalent>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="latexml">annotated</csymbol>
      <cn type="integer">1</cn>
      <apply>
       <ci>pmod</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X\equiv\sqrt{15347}-124\equiv 1\;\;(\mathop{{\rm mod}}2)
  </annotation>
 </semantics>
</math>

.</p>

<p>Thus, starting at X=1 and incrementing by 2, each entry will be divisible by 2. Dividing each of those entries by 2 yields</p>

<p>

<math display="block" id="Quadratic_sieve:20">
 <semantics>
  <mrow>
   <mi>V</mi>
   <mo>=</mo>
   <mrow>
    <mo>[</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="center">
       <mn>29</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>139</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>529</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>391</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>1037</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>647</mn>
      </mtd>
      <mtd columnalign="center">
       <mi mathvariant="normal">⋯</mi>
      </mtd>
      <mtd columnalign="center">
       <mn>17191</mn>
      </mtd>
     </mtr>
    </mtable>
    <mo>]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>V</ci>
    <matrix>
     <matrixrow>
      <cn type="integer">29</cn>
      <cn type="integer">139</cn>
      <cn type="integer">529</cn>
      <cn type="integer">391</cn>
      <cn type="integer">1037</cn>
      <cn type="integer">647</cn>
      <ci>normal-⋯</ci>
      <cn type="integer">17191</cn>
     </matrixrow>
    </matrix>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V=\begin{bmatrix}29&139&529&391&1037&647&\cdots&17191\end{bmatrix}
  </annotation>
 </semantics>
</math>

</p>

<p>Similarly for the remaining primes <em>p</em> in 

<math display="inline" id="Quadratic_sieve:21">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mn>17</mn>
   <mo>,</mo>
   <mn>23</mn>
   <mo>,</mo>
   <mn>29</mn>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <cn type="integer">17</cn>
    <cn type="integer">23</cn>
    <cn type="integer">29</cn>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{17,23,29\}
  </annotation>
 </semantics>
</math>

 the equation

<math display="inline" id="Quadratic_sieve:22">
 <semantics>
  <mrow>
   <mi>X</mi>
   <mo>≡</mo>
   <mrow>
    <mrow>
     <msqrt>
      <mn>15347</mn>
     </msqrt>
     <mo>-</mo>
     <mn>124</mn>
    </mrow>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mrow>
     <mo lspace="8.1pt" stretchy="false">(</mo>
     <mrow>
      <mo>mod</mo>
      <mi>p</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <ci>X</ci>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <apply>
      <minus></minus>
      <apply>
       <root></root>
       <cn type="integer">15347</cn>
      </apply>
      <cn type="integer">124</cn>
     </apply>
     <apply>
      <ci>pmod</ci>
      <ci>p</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X\equiv\sqrt{15347}-124\;\;(\mathop{{\rm mod}}p)
  </annotation>
 </semantics>
</math>

 is solved. Note that for every p &gt; 2, there will be 2 resulting linear equations due to there being 2 modular square roots.</p>

<p>

<math display="inline" id="Quadratic_sieve:23">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle X
  </annotation>
 </semantics>
</math>


</p>

<p>Each equation 

<math display="inline" id="Quadratic_sieve:24">
 <semantics>
  <mrow>
   <mi>X</mi>
   <mo>≡</mo>
   <mrow>
    <mi>a</mi>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mrow>
     <mo lspace="8.1pt" stretchy="false">(</mo>
     <mrow>
      <mo>mod</mo>
      <mi>p</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <ci>X</ci>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <ci>a</ci>
     <apply>
      <ci>pmod</ci>
      <ci>p</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X\equiv a\;\;(\mathop{{\rm mod}}p)
  </annotation>
 </semantics>
</math>

 results in 

<math display="inline" id="Quadratic_sieve:25">
 <semantics>
  <msub>
   <mi>V</mi>
   <mi>x</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>V</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V_{x}
  </annotation>
 </semantics>
</math>

 being divisible by <em>p</em> at <em>x</em>=<em>a</em> and each <em>p</em>th value beyond that. Dividing <em>V</em> by <em>p</em> at <em>a</em>, <em>a</em>+<em>p</em>, <em>a</em>+2<em>p</em>, <em>a</em>+3<em>p</em>, etc., for each prime in the basis finds the smooth numbers which are products of unique primes (first powers).</p>

<p>

<math display="block" id="Quadratic_sieve:26">
 <semantics>
  <mrow>
   <mi>V</mi>
   <mo>=</mo>
   <mrow>
    <mo>[</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="center">
       <mn>1</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>139</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>23</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>1</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>61</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>647</mn>
      </mtd>
      <mtd columnalign="center">
       <mi mathvariant="normal">⋯</mi>
      </mtd>
      <mtd columnalign="center">
       <mn>17191</mn>
      </mtd>
     </mtr>
    </mtable>
    <mo>]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>V</ci>
    <matrix>
     <matrixrow>
      <cn type="integer">1</cn>
      <cn type="integer">139</cn>
      <cn type="integer">23</cn>
      <cn type="integer">1</cn>
      <cn type="integer">61</cn>
      <cn type="integer">647</cn>
      <ci>normal-⋯</ci>
      <cn type="integer">17191</cn>
     </matrixrow>
    </matrix>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V=\begin{bmatrix}1&139&23&1&61&647&\cdots&17191\end{bmatrix}
  </annotation>
 </semantics>
</math>

</p>

<p>Any entry of <em>V</em> that equals 1 corresponds to a smooth number. Since 

<math display="inline" id="Quadratic_sieve:27">
 <semantics>
  <msub>
   <mi>V</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>V</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V_{0}
  </annotation>
 </semantics>
</math>


, 

<math display="inline" id="Quadratic_sieve:28">
 <semantics>
  <msub>
   <mi>V</mi>
   <mn>3</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>V</ci>
    <cn type="integer">3</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V_{3}
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="Quadratic_sieve:29">
 <semantics>
  <msub>
   <mi>V</mi>
   <mn>71</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>V</ci>
    <cn type="integer">71</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V_{71}
  </annotation>
 </semantics>
</math>

 equal one, this corresponds to:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p><em>X</em> + 124</p></th>
<th style="text-align: left;">
<p><em>Y</em></p></th>
<th style="text-align: left;">
<p>factors</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>124</p></td>
<td style="text-align: left;">
<p>29</p></td>
<td style="text-align: left;">
<p>2<sup>0</sup> • 17<sup>0</sup> • 23<sup>0</sup> • 29<sup>1</sup></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>127</p></td>
<td style="text-align: left;">
<p>782</p></td>
<td style="text-align: left;">
<p>2<sup>1</sup> • 17<sup>1</sup> • 23<sup>1</sup> • 29<sup>0</sup></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>195</p></td>
<td style="text-align: left;">
<p>22678</p></td>
<td style="text-align: left;">
<p>2<sup>1</sup> • 17<sup>1</sup> • 23<sup>1</sup> • 29<sup>1</sup></p></td>
</tr>
</tbody>
</table>
<h3 id="matrix-processing">Matrix Processing</h3>

<p>Since smooth numbers <em>Y</em> have been found with the property 

<math display="inline" id="Quadratic_sieve:30">
 <semantics>
  <mrow>
   <mi>Y</mi>
   <mo>≡</mo>
   <mrow>
    <msup>
     <mi>Z</mi>
     <mn>2</mn>
    </msup>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mrow>
     <mo lspace="8.1pt" stretchy="false">(</mo>
     <mrow>
      <mo>mod</mo>
      <mi>N</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <ci>Y</ci>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>Z</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <ci>pmod</ci>
      <ci>N</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y\equiv Z^{2}\;\;(\mathop{{\rm mod}}N)
  </annotation>
 </semantics>
</math>

, the remainder of the algorithm follows equivalently to any other variation of <a href="Dixon's_factorization_method" title="wikilink">Dixon's factorization method</a>.</p>

<p>Writing the exponents of the product of a subset of the equations</p>

<p>

<math display="inline" id="Quadratic_sieve:31">
 <semantics>
  <mn>29</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">29</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle 29
  </annotation>
 </semantics>
</math>


</p>

<p>as a matrix 

<math display="inline" id="Quadratic_sieve:32">
 <semantics>
  <mrow>
   <mo lspace="8.1pt" stretchy="false">(</mo>
   <mrow>
    <mo>mod</mo>
    <mn>2</mn>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>pmod</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \;\;(\mathop{{\rm mod}}2)
  </annotation>
 </semantics>
</math>

 yields:</p>

<p>

<math display="block" id="Quadratic_sieve:33">
 <semantics>
  <mrow>
   <mrow>
    <mi>S</mi>
    <mo>⋅</mo>
    <mrow>
     <mo>[</mo>
     <mtable displaystyle="true">
      <mtr>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
      </mtr>
     </mtable>
     <mo>]</mo>
    </mrow>
   </mrow>
   <mo>≡</mo>
   <mrow>
    <mrow>
     <mo>[</mo>
     <mtable displaystyle="true">
      <mtr>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
      </mtr>
     </mtable>
     <mo>]</mo>
    </mrow>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mrow>
     <mo lspace="8.1pt" stretchy="false">(</mo>
     <mrow>
      <mo>mod</mo>
      <mn>2</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <ci>normal-⋅</ci>
     <ci>S</ci>
     <matrix>
      <matrixrow>
       <cn type="integer">0</cn>
       <cn type="integer">0</cn>
       <cn type="integer">0</cn>
       <cn type="integer">1</cn>
      </matrixrow>
      <matrixrow>
       <cn type="integer">1</cn>
       <cn type="integer">1</cn>
       <cn type="integer">1</cn>
       <cn type="integer">0</cn>
      </matrixrow>
      <matrixrow>
       <cn type="integer">1</cn>
       <cn type="integer">1</cn>
       <cn type="integer">1</cn>
       <cn type="integer">1</cn>
      </matrixrow>
     </matrix>
    </apply>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <matrix>
      <matrixrow>
       <cn type="integer">0</cn>
       <cn type="integer">0</cn>
       <cn type="integer">0</cn>
       <cn type="integer">0</cn>
      </matrixrow>
     </matrix>
     <apply>
      <ci>pmod</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S\cdot\begin{bmatrix}0&0&0&1\\
1&1&1&0\\
1&1&1&1\end{bmatrix}\equiv\begin{bmatrix}0&0&0&0\end{bmatrix}\;\;(\mathop{{\rm
mod%
}}2)
  </annotation>
 </semantics>
</math>

</p>

<p>A solution to the equation is given by the <a href="Left_null_space#Left_null_space" title="wikilink">left null space</a>, simply</p>

<p>

<math display="block" id="Quadratic_sieve:34">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>=</mo>
   <mrow>
    <mo>[</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="center">
       <mn>1</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>1</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>1</mn>
      </mtd>
     </mtr>
    </mtable>
    <mo>]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>S</ci>
    <matrix>
     <matrixrow>
      <cn type="integer">1</cn>
      <cn type="integer">1</cn>
      <cn type="integer">1</cn>
     </matrixrow>
    </matrix>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S=\begin{bmatrix}1&1&1\end{bmatrix}
  </annotation>
 </semantics>
</math>

</p>

<p>Thus the product of all 3 equations yields a square (mod N).</p>

<p>

<math display="block" id="Quadratic_sieve:35">
 <semantics>
  <mrow>
   <mrow>
    <mn>29</mn>
    <mo>⋅</mo>
    <mn>782</mn>
    <mo>⋅</mo>
    <mn>22678</mn>
   </mrow>
   <mo>=</mo>
   <msup>
    <mn>22678</mn>
    <mn>2</mn>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>normal-⋅</ci>
     <cn type="integer">29</cn>
     <cn type="integer">782</cn>
     <cn type="integer">22678</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">22678</cn>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   29\cdot 782\cdot 22678=22678^{2}
  </annotation>
 </semantics>
</math>

 and</p>

<p>

<math display="block" id="Quadratic_sieve:36">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mn>124</mn>
     <mn>2</mn>
    </msup>
    <mo>⋅</mo>
    <msup>
     <mn>127</mn>
     <mn>2</mn>
    </msup>
    <mo>⋅</mo>
    <msup>
     <mn>195</mn>
     <mn>2</mn>
    </msup>
   </mrow>
   <mo>=</mo>
   <msup>
    <mn>3070860</mn>
    <mn>2</mn>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>normal-⋅</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">124</cn>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">127</cn>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">195</cn>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">3070860</cn>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   124^{2}\cdot 127^{2}\cdot 195^{2}=3070860^{2}
  </annotation>
 </semantics>
</math>

</p>

<p>So the algorithm found</p>

<p>

<math display="block" id="Quadratic_sieve:37">
 <semantics>
  <mrow>
   <msup>
    <mn>22678</mn>
    <mn>2</mn>
   </msup>
   <mo>≡</mo>
   <mrow>
    <msup>
     <mn>3070860</mn>
     <mn>2</mn>
    </msup>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mrow>
     <mo lspace="8.1pt" stretchy="false">(</mo>
     <mrow>
      <mo>mod</mo>
      <mn>15347</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">22678</cn>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">3070860</cn>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <ci>pmod</ci>
      <cn type="integer">15347</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   22678^{2}\equiv 3070860^{2}\;\;(\mathop{{\rm mod}}15347)
  </annotation>
 </semantics>
</math>

</p>

<p>Testing the result yields GCD(3070860 - 22678, 15347) = 103, a nontrivial factor of 15347, the other being 149.</p>

<p>This demonstration should also serve to show that the quadratic sieve is only appropriate when <em>n</em> is large. For a number as small as 15347, this algorithm is overkill. <a href="Trial_division" title="wikilink">Trial division</a> or <a href="Pollard_rho" title="wikilink">Pollard rho</a> could have found a factor with much less computation.</p>
<h2 id="multiple-polynomials">Multiple polynomials</h2>

<p>In practice, many different <a href="polynomial" title="wikilink">polynomials</a> are used for <em>y</em>, since only one polynomial will not typically provide enough (<em>x</em>, <em>y</em>) pairs that are smooth over the factor base. The polynomials used must have a special form, since they need to be squares modulo <em>n</em>. The polynomials must all have a similar form to the original <em>y</em>(<em>x</em>) = <em>x</em><sup>2</sup> − <em>n</em>:</p>

<p>

<math display="block" id="Quadratic_sieve:38">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>y</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mrow>
          <mi>A</mi>
          <mi>x</mi>
         </mrow>
         <mo>+</mo>
         <mi>B</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mn>2</mn>
      </msup>
      <mo>-</mo>
      <mi>n</mi>
     </mrow>
     <mi>A</mi>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>B</mi>
    <mo>∈</mo>
    <mi>ℤ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>y</ci>
      <ci>x</ci>
     </apply>
     <list>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <plus></plus>
         <apply>
          <times></times>
          <ci>A</ci>
          <ci>x</ci>
         </apply>
         <ci>B</ci>
        </apply>
        <cn type="integer">2</cn>
       </apply>
       <ci>n</ci>
      </apply>
      <ci>A</ci>
     </list>
    </apply>
    <apply>
     <in></in>
     <ci>B</ci>
     <ci>ℤ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y(x)=(Ax+B)^{2}-n\qquad A,B\in\mathbb{Z}
  </annotation>
 </semantics>
</math>

</p>

<p>Assuming 

<math display="inline" id="Quadratic_sieve:39">
 <semantics>
  <mrow>
   <msup>
    <mi>B</mi>
    <mn>2</mn>
   </msup>
   <mo>-</mo>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>B</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B^{2}-n
  </annotation>
 </semantics>
</math>

 is a multiple of A, so that 

<math display="inline" id="Quadratic_sieve:40">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>B</mi>
     <mn>2</mn>
    </msup>
    <mo>-</mo>
    <mi>n</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>A</mi>
    <mi>C</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>B</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>n</ci>
    </apply>
    <apply>
     <times></times>
     <ci>A</ci>
     <ci>C</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B^{2}-n=AC
  </annotation>
 </semantics>
</math>

 the polynomial y(x) can be written as 

<math display="inline" id="Quadratic_sieve:41">
 <semantics>
  <mrow>
   <mrow>
    <mi>y</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>A</mi>
    <mo>⋅</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mi>A</mi>
       <msup>
        <mi>x</mi>
        <mn>2</mn>
       </msup>
      </mrow>
      <mo>+</mo>
      <mrow>
       <mn>2</mn>
       <mi>B</mi>
       <mi>x</mi>
      </mrow>
      <mo>+</mo>
      <mi>C</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>y</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <ci>normal-⋅</ci>
     <ci>A</ci>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>A</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>x</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>B</ci>
       <ci>x</ci>
      </apply>
      <ci>C</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y(x)=A\cdot(Ax^{2}+2Bx+C)
  </annotation>
 </semantics>
</math>

. If then A is a square, only the factor 

<math display="inline" id="Quadratic_sieve:42">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mrow>
     <mi>A</mi>
     <msup>
      <mi>x</mi>
      <mn>2</mn>
     </msup>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mn>2</mn>
     <mi>B</mi>
     <mi>x</mi>
    </mrow>
    <mo>+</mo>
    <mi>C</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <times></times>
     <ci>A</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <times></times>
     <cn type="integer">2</cn>
     <ci>B</ci>
     <ci>x</ci>
    </apply>
    <ci>C</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (Ax^{2}+2Bx+C)
  </annotation>
 </semantics>
</math>

 has to be considered.</p>

<p>This approach (called MPQS, Multiple Polynomial Quadratic Sieve) is ideally suited for <a href="parallel_algorithm" title="wikilink">parallelization</a>, since each <a href="central_processing_unit" title="wikilink">processor</a> involved in the factorization can be given <em>n</em>, the factor base and a collection of polynomials, and it will have no need to communicate with the central processor until it is finished with its polynomials.</p>
<h2 id="large-primes">Large primes</h2>
<h3 id="one-large-prime">One large prime</h3>

<p>If, after dividing by all the factors less than A, the remaining part of the number (the cofactor) is less than A<sup>2</sup>, then this cofactor must be prime. In effect, it can be added to the factor base, by sorting the list of relations into order by cofactor. If y(a) = 7*11*23*137 and y(b) = 3*5*7*137, then y(a)y(b) = 3*5*11*23 * 7<sup>2</sup> * 137<sup>2</sup>. This works by reducing the threshold of entries in the sieving array above which a full factorization is performed.</p>
<h3 id="more-large-primes">More large primes</h3>

<p>Reducing the threshold even further, and using an effective process for factoring y(x) values into products of even relatively large primes - ECM is superb for this - can find relations with most of their factors in the factor base, but with two or even three larger primes. Cycle finding then allows combining a set of relations sharing several primes into a single relation.</p>
<h2 id="parameters-from-realistic-example">Parameters from realistic example</h2>

<p>To illustrate typical parameter choices for a realistic example on a real implementation including the multiple polynomial and large prime optimizations, the tool <a href="http://sourceforge.net/projects/msieve/">msieve</a> was run on a 267-bit <a class="uri" href="semiprime" title="wikilink">semiprime</a>, producing the following parameters:</p>
<ul>
<li>Trial factoring cutoff: 27 bits</li>
<li>Sieve interval (per polynomial): 393216 (12 blocks of size 32768)</li>
<li>Smoothness bound: 1300967 (50294 primes)</li>
<li>Number of factors for polynomial <em>A</em> coefficients: 10 <em>(see <a href="#Multiple_polynomials" title="wikilink">Multiple polynomials</a> above)</em></li>
<li>Large prime bound: 128795733 (26 bits) <em>(see <a href="#Large_primes" title="wikilink">Large primes</a> above)</em></li>
<li>Smooth values found: 25952 by sieving directly, 24462 by combining numbers with large primes</li>
<li>Final matrix size: 50294 × 50414, reduced by filtering to 35750 × 35862</li>
<li>Nontrivial dependencies found: 15</li>
<li>Total time (on a 1.6 GHz UltraSparc III): 35 min 39 seconds</li>
<li>Maximum memory used: 8 MB</li>
</ul>
<h2 id="factoring-records">Factoring records</h2>

<p>Until the discovery of the <a href="general_number_field_sieve" title="wikilink">number field sieve</a> (NFS), QS was the asymptotically fastest known general-purpose factoring algorithm. Now, <a href="Lenstra_elliptic_curve_factorization" title="wikilink">Lenstra elliptic curve factorization</a> has the same asymptotic running time as QS (in the case where <em>n</em> has exactly two prime factors of equal size), but in practice, QS is faster since it uses <a class="uri" href="single-precision" title="wikilink">single-precision</a> operations instead of the <a class="uri" href="multi-precision" title="wikilink">multi-precision</a> operations used by the elliptic curve method.</p>

<p>On April 2, 1994, the factorization of <a class="uri" href="RSA-129" title="wikilink">RSA-129</a> was completed using QS. It was a 129-digit number, the product of two large primes, one of 64 digits and the other of 65. The factor base for this factorization contained 524339 primes. The data collection phase took 5000 <a href="MIPS-year" title="wikilink">MIPS-years</a>, done in distributed fashion over the Internet. The data collected totaled 2<a href="gigabyte" title="wikilink">GB</a>. The data processing phase took 45 hours on <a class="uri" href="Bellcore" title="wikilink">Bellcore</a>'s (now <a href="Telcordia_Technologies" title="wikilink">Telcordia Technologies</a>) <a class="uri" href="MasPar" title="wikilink">MasPar</a> (massively parallel) supercomputer. This was the largest published factorization by a general-purpose algorithm, until NFS was used to factor <a class="uri" href="RSA-130" title="wikilink">RSA-130</a>, completed April 10, 1996. All <a href="RSA_number" title="wikilink">RSA numbers</a> factored since then have been factored using NFS.</p>

<p>The current QS record is a 135-digit cofactor of 

<math display="inline" id="Quadratic_sieve:43">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mn>2</mn>
     <mn>803</mn>
    </msup>
    <mo>-</mo>
    <msup>
     <mn>2</mn>
     <mn>402</mn>
    </msup>
   </mrow>
   <mo>+</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <cn type="integer">803</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <cn type="integer">402</cn>
     </apply>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{803}-2^{402}+1
  </annotation>
 </semantics>
</math>

, itself an <a href="Aurifeuillian_factorization" title="wikilink">Aurifeuillian factor</a> of 

<math display="inline" id="Quadratic_sieve:44">
 <semantics>
  <mrow>
   <msup>
    <mn>2</mn>
    <mn>1606</mn>
   </msup>
   <mo>+</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <cn type="integer">1606</cn>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{1606}+1
  </annotation>
 </semantics>
</math>

, which was split into 66-digit and 69-digit prime factors in 2001.</p>
<h2 id="implementations">Implementations</h2>
<ul>
<li><a href="http://www.asahi-net.or.jp/~KC2H-MSM/cn">PPMPQS and PPSIQS</a></li>
<li><a href="http://gforge.inria.fr/projects/mpqs/">mpqs</a></li>
<li><a href="http://www.friedspace.com/QS/">SIMPQS</a> is a fast implementation of the self-initialising multiple polynomial quadratic sieve written by William Hart. It provides support for the large prime variant and uses Jason Papadopoulos' block Lanczos code for the linear algebra stage. SIMPQS is accessible as the qsieve command in the <a href="Software_for_Algebra_and_Geometry_Experimentation" title="wikilink">SAGE</a> computer algebra package or can be downloaded in source form. SIMPQS is optimized for use on Athlon and Opteron machines, but will operate on most common 32 and 64 bit architectures. It is written entirely in C.</li>
<li>a <a href="http://www.alpertron.com.ar/ECM.HTM">factoring applet</a> by Dario Alpern, that uses the quadratic sieve if certain conditions are met.</li>
<li>The <a class="uri" href="PARI/GP" title="wikilink">PARI/GP</a> computer algebra package includes an implementation of the self-initialising multiple polynomial quadratic sieve implementing the large prime variant. It was adapted by Thomas Papanikolaou and Xavier Roblot from a sieve written for the LiDIA project. The self initialisation scheme is based on an idea from the thesis of Thomas Sosnowski.</li>
<li>A variant of the quadratic sieve is available in the <a href="Magma_computer_algebra_system" title="wikilink">MAGMA</a> computer algebra package. It is based on an implementation of Arjen Lenstra from 1995, used in his "factoring by email" program.</li>
<li><a href="http://sourceforge.net/projects/msieve/">msieve</a>, an implementation of the multiple polynomial quadratic sieve with support for single and double large primes, written by Jason Papadopoulos. Source code and a Windows binary are available.</li>
<li><a href="http://bbuhrow.googlepages.com/home">YAFU</a>, written by Ben Buhrow, is similar to msieve but is faster for most modern <a class="uri" href="processors" title="wikilink">processors</a>. It uses Jason Papadopoulos' block Lanczos code. Source code and binaries for Windows and Linux are available.</li>
<li><a href="http://sourceforge.net/projects/arielqs/">Ariel</a>, a simple Java implementation of the quadratic sieve for didactic purposes.</li>
</ul>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Lenstra_elliptic_curve_factorization" title="wikilink">Lenstra elliptic curve factorization</a></li>
<li><a href="primality_test" title="wikilink">primality test</a></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li>

<p>Section 6.1: The quadratic sieve factorization method, pp. 227–244.</p></li>
</ul>
<h2 id="other-external-links">Other external links</h2>
<ul>
<li>Reference paper <a href="http://www.cs.virginia.edu/crab/QFS_Simple.pdf">"The Quadratic Sieve Factoring Algorithm"</a> by Eric Landquist</li>
</ul>

<p>"</p>

<p><a href="Category:Integer_factorization_algorithms" title="wikilink">Category:Integer factorization algorithms</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Carl Pomerance, Analysis and Comparison of Some Integer Factoring Algorithms, in Computational Methods in Number Theory, Part I, H.W. Lenstra, Jr. and R. Tijdeman, eds., Math. Centre Tract 154, Amsterdam, 1982, pp 89-139.<a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
</ol>
</section>
</body>
</html>
