<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="238">Bernoulli process</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Bernoulli process</h1>
<hr/>

<p>In <a class="uri" href="probability" title="wikilink">probability</a> and <a class="uri" href="statistics" title="wikilink">statistics</a>, a <strong>Bernoulli process</strong> is a finite or infinite sequence of binary <a href="random_variable" title="wikilink">random variables</a>, so it is a <a href="discrete-time_stochastic_process" title="wikilink">discrete-time stochastic process</a> that takes only two values, canonically 0 and 1. The component <strong>Bernoulli variables</strong> <em>X</em><sub><em>i</em></sub> are identical and <a href="statistical_independence" title="wikilink">independent</a>. Prosaically, a Bernoulli process is a repeated <a href="coin_flipping" title="wikilink">coin flipping</a>, possibly with an unfair coin (but with consistent unfairness). Every variable <em>X</em><sub><em>i</em></sub> in the sequence is associated with a <a href="Bernoulli_trial" title="wikilink">Bernoulli trial</a> or experiment. They all have the same <a href="Bernoulli_distribution" title="wikilink">Bernoulli distribution</a>. Much of what can be said about the Bernoulli process can also be generalized to more than two outcomes (such as the process for a six-sided die); this generalization is known as the <a href="Bernoulli_scheme" title="wikilink">Bernoulli scheme</a>.</p>

<p>The problem of determining the process, given only a limited sample of the Bernoulli trials, may be called the problem of <a href="checking_whether_a_coin_is_fair" title="wikilink">checking whether a coin is fair</a>.</p>
<h2 id="definition">Definition</h2>

<p>A <strong>Bernoulli process</strong> is a finite or infinite sequence of <a href="statistical_independence" title="wikilink">independent</a> <a href="random_variable" title="wikilink">random variables</a> <em>X</em><sub>1</sub>, <em>X</em><sub>2</sub>, <em>X</em><sub>3</sub>, ..., such that</p>
<ul>
<li>For each <em>i</em>, the value of <em>X</em><sub><em>i</em></sub> is either 0 or 1;</li>
<li>For all values of <em>i</em>, the probability that <em>X</em><sub><em>i</em></sub> = 1 is the same number <em>p</em>.</li>
</ul>

<p>In other words, a Bernoulli process is a sequence of <a href="independent_identically_distributed" title="wikilink">independent identically distributed</a> <a href="Bernoulli_trial" title="wikilink">Bernoulli trials</a>.</p>

<p>Independence of the trials implies that the process is memoryless. Given that the probability <em>p</em> is known, past outcomes provide no information about future outcomes. (If <em>p</em> is unknown, however, the past informs about the future indirectly, through inferences about <em>p</em>.)</p>

<p>If the process is infinite, then from any point the future trials constitute a Bernoulli process identical to the whole process, the fresh-start property.</p>
<h3 id="interpretation">Interpretation</h3>

<p>The two possible values of each <em>X</em><sub><em>i</em></sub> are often called "success" and "failure". Thus, when expressed as a number 0 or 1, the outcome may be called the number of successes on the <em>i</em>th "trial".</p>

<p>Two other common interpretations of the values are true or false and yes or no. Under any interpretation of the two values, the individual variables <em>X</em><sub><em>i</em></sub> may be called <a href="Bernoulli_trial" title="wikilink">Bernoulli trials</a> with parameter p.</p>

<p>In many applications time passes between trials, as the index i increases. In effect, the trials <em>X</em><sub>1</sub>, <em>X</em><sub>2</sub>, ... <em>X</em><sub>i</sub>, ... happen at "points in time" 1, 2, ..., <em>i</em>, .... That passage of time and the associated notions of "past" and "future" are not necessary, however. Most generally, any <em>X</em><sub>i</sub> and <em>X</em><sub><em>j</em></sub> in the process are simply two from a set of random variables indexed by {1, 2, ..., <em>n</em>} or by {1, 2, 3, ...}, the finite and infinite cases.</p>

<p>Several random variables and probability distributions beside the Bernoullis may be derived from the Bernoulli process:</p>
<ul>
<li>The number of successes in the first <em>n</em> trials, which has a <a href="binomial_distribution" title="wikilink">binomial distribution</a> B(<em>n</em>, <em>p</em>)</li>
<li>The number of trials needed to get <em>r</em> successes, which has a <a href="negative_binomial_distribution" title="wikilink">negative binomial distribution</a> NB(<em>r</em>, <em>p</em>)</li>
<li>The number of trials needed to get one success, which has a <a href="geometric_distribution" title="wikilink">geometric distribution</a> NB(1, <em>p</em>), a special case of the negative binomial distribution</li>
</ul>

<p>The negative binomial variables may be interpreted as random <a href="Negative_binomial_distribution#Waiting_time_in_a_Bernoulli_process" title="wikilink">waiting times</a>.</p>
<h2 id="formal-definition">Formal definition</h2>

<p>The Bernoulli process can be formalized in the language of <a href="probability_space" title="wikilink">probability spaces</a> as a random sequence of independent realisations of a random variable that can take values of heads or tails. The state space for an individual value is denoted by 

<math display="inline" id="Bernoulli_process:0">
<semantics>
<mrow>
<mrow>
<mn>2</mn>
<mo>=</mo>
<mrow>
<mo stretchy="false">{</mo>
<mi>H</mi>
<mo>,</mo>
<mi>T</mi>
<mo stretchy="false">}</mo>
</mrow>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<cn type="integer">2</cn>
<set>
<ci>H</ci>
<ci>T</ci>
</set>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   2=\{H,T\}.
  </annotation>
</semantics>
</math>
</p>

<p>Specifically, one considers the <a href="countably_infinite" title="wikilink">countably infinite</a> <a href="direct_product" title="wikilink">direct product</a> of copies of 

<math display="inline" id="Bernoulli_process:1">
<semantics>
<mrow>
<mn>2</mn>
<mo>=</mo>
<mrow>
<mo stretchy="false">{</mo>
<mi>H</mi>
<mo>,</mo>
<mi>T</mi>
<mo stretchy="false">}</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<cn type="integer">2</cn>
<set>
<ci>H</ci>
<ci>T</ci>
</set>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   2=\{H,T\}
  </annotation>
</semantics>
</math>

. It is common to examine either the one-sided set 

<math display="inline" id="Bernoulli_process:2">
<semantics>
<mrow>
<mi mathvariant="normal">Ω</mi>
<mo>=</mo>
<msup>
<mn>2</mn>
<mi>ℕ</mi>
</msup>
<mo>=</mo>
<msup>
<mrow>
<mo stretchy="false">{</mo>
<mi>H</mi>
<mo>,</mo>
<mi>T</mi>
<mo stretchy="false">}</mo>
</mrow>
<mi>ℕ</mi>
</msup>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<and></and>
<apply>
<eq></eq>
<ci>normal-Ω</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<cn type="integer">2</cn>
<ci>ℕ</ci>
</apply>
</apply>
<apply>
<eq></eq>
<share href="#.cmml">
</share>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<set>
<ci>H</ci>
<ci>T</ci>
</set>
<ci>ℕ</ci>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \Omega=2^{\mathbb{N}}=\{H,T\}^{\mathbb{N}}
  </annotation>
</semantics>
</math>

 or the two-sided set 

<math display="inline" id="Bernoulli_process:3">
<semantics>
<mrow>
<mi mathvariant="normal">Ω</mi>
<mo>=</mo>
<msup>
<mn>2</mn>
<mi>ℤ</mi>
</msup>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<ci>normal-Ω</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<cn type="integer">2</cn>
<ci>ℤ</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \Omega=2^{\mathbb{Z}}
  </annotation>
</semantics>
</math>

. There is a natural <a class="uri" href="topology" title="wikilink">topology</a> on this space, called the <a href="product_topology" title="wikilink">product topology</a>. The sets in this topology are finite sequences of coin flips, that is, finite-length <a href="string_(computer_science)" title="wikilink">strings</a> of <em>H</em> and <em>T</em>, with the rest of (infinitely long) sequence taken as "don't care". These sets of finite sequences are referred to as <a href="cylinder_set" title="wikilink">cylinder sets</a> in the product topology. The set of all such strings form a <a href="sigma_algebra" title="wikilink">sigma algebra</a>, specifically, a <a href="Borel_algebra" title="wikilink">Borel algebra</a>. This algebra is then commonly written as 

<math display="inline" id="Bernoulli_process:4">
<semantics>
<mrow>
<mo stretchy="false">(</mo>
<mi mathvariant="normal">Ω</mi>
<mo>,</mo>
<mi class="ltx_font_mathcaligraphic">ℱ</mi>
<mo stretchy="false">)</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<interval closure="open">
<ci>normal-Ω</ci>
<ci>ℱ</ci>
</interval>
</annotation-xml>
<annotation encoding="application/x-tex">
   (\Omega,\mathcal{F})
  </annotation>
</semantics>
</math>

 where the elements of 

<math display="inline" id="Bernoulli_process:5">
<semantics>
<mi class="ltx_font_mathcaligraphic">ℱ</mi>
<annotation-xml encoding="MathML-Content">
<ci>ℱ</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mathcal{F}
  </annotation>
</semantics>
</math>

 are the finite-length sequences of coin flips (the cylinder sets).</p>

<p>If the chances of flipping heads or tails are given by the probabilities 

<math display="inline" id="Bernoulli_process:6">
<semantics>
<mrow>
<mo stretchy="false">{</mo>
<mi>p</mi>
<mo>,</mo>
<mrow>
<mn>1</mn>
<mo>-</mo>
<mi>p</mi>
</mrow>
<mo stretchy="false">}</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<set>
<ci>p</ci>
<apply>
<minus></minus>
<cn type="integer">1</cn>
<ci>p</ci>
</apply>
</set>
</annotation-xml>
<annotation encoding="application/x-tex">
   \{p,1-p\}
  </annotation>
</semantics>
</math>

, then one can define a natural <a href="measure_(mathematics)" title="wikilink">measure</a> on the product space, given by 

<math display="inline" id="Bernoulli_process:7">
<semantics>
<mrow>
<mi>P</mi>
<mo>=</mo>
<msup>
<mrow>
<mo stretchy="false">{</mo>
<mi>p</mi>
<mo>,</mo>
<mrow>
<mn>1</mn>
<mo>-</mo>
<mi>p</mi>
</mrow>
<mo stretchy="false">}</mo>
</mrow>
<mi>ℕ</mi>
</msup>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<ci>P</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<set>
<ci>p</ci>
<apply>
<minus></minus>
<cn type="integer">1</cn>
<ci>p</ci>
</apply>
</set>
<ci>ℕ</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   P=\{p,1-p\}^{\mathbb{N}}
  </annotation>
</semantics>
</math>

 (or by 

<math display="inline" id="Bernoulli_process:8">
<semantics>
<mrow>
<mi>P</mi>
<mo>=</mo>
<msup>
<mrow>
<mo stretchy="false">{</mo>
<mi>p</mi>
<mo>,</mo>
<mrow>
<mn>1</mn>
<mo>-</mo>
<mi>p</mi>
</mrow>
<mo stretchy="false">}</mo>
</mrow>
<mi>ℤ</mi>
</msup>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<ci>P</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<set>
<ci>p</ci>
<apply>
<minus></minus>
<cn type="integer">1</cn>
<ci>p</ci>
</apply>
</set>
<ci>ℤ</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   P=\{p,1-p\}^{\mathbb{Z}}
  </annotation>
</semantics>
</math>

 for the two-sided process). Given a cylinder set, that is, a specific sequence of coin flip results 

<math display="inline" id="Bernoulli_process:9">
<semantics>
<mrow>
<mo stretchy="false">[</mo>
<msub>
<mi>ω</mi>
<mn>1</mn>
</msub>
<mo>,</mo>
<msub>
<mi>ω</mi>
<mn>2</mn>
</msub>
<mo>,</mo>
<mrow>
<mi mathvariant="normal">⋯</mi>
<msub>
<mi>ω</mi>
<mi>n</mi>
</msub>
</mrow>
<mo stretchy="false">]</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<list>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>ω</ci>
<cn type="integer">1</cn>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>ω</ci>
<cn type="integer">2</cn>
</apply>
<apply>
<times></times>
<ci>normal-⋯</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>ω</ci>
<ci>n</ci>
</apply>
</apply>
</list>
</annotation-xml>
<annotation encoding="application/x-tex">
   [\omega_{1},\omega_{2},\cdots\omega_{n}]
  </annotation>
</semantics>
</math>

 at times 

<math display="inline" id="Bernoulli_process:10">
<semantics>
<mrow>
<mn>1</mn>
<mo>,</mo>
<mn>2</mn>
<mo>,</mo>
<mi mathvariant="normal">⋯</mi>
<mo>,</mo>
<mi>n</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<list>
<cn type="integer">1</cn>
<cn type="integer">2</cn>
<ci>normal-⋯</ci>
<ci>n</ci>
</list>
</annotation-xml>
<annotation encoding="application/x-tex">
   1,2,\cdots,n
  </annotation>
</semantics>
</math>

, the probability of observing this particular sequence is given by</p>

<p>
<math display="block" id="Bernoulli_process:11">
<semantics>
<mrow>
<mrow>
<mi>P</mi>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mo stretchy="false">[</mo>
<msub>
<mi>ω</mi>
<mn>1</mn>
</msub>
<mo>,</mo>
<msub>
<mi>ω</mi>
<mn>2</mn>
</msub>
<mo>,</mo>
<mi mathvariant="normal">⋯</mi>
<mo>,</mo>
<msub>
<mi>ω</mi>
<mi>n</mi>
</msub>
<mo stretchy="false">]</mo>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<msup>
<mi>p</mi>
<mi>k</mi>
</msup>
<msup>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mn>1</mn>
<mo>-</mo>
<mi>p</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mrow>
<mi>n</mi>
<mo>-</mo>
<mi>k</mi>
</mrow>
</msup>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<times></times>
<ci>P</ci>
<list>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>ω</ci>
<cn type="integer">1</cn>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>ω</ci>
<cn type="integer">2</cn>
</apply>
<ci>normal-⋯</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>ω</ci>
<ci>n</ci>
</apply>
</list>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>p</ci>
<ci>k</ci>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<minus></minus>
<cn type="integer">1</cn>
<ci>p</ci>
</apply>
<apply>
<minus></minus>
<ci>n</ci>
<ci>k</ci>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   P([\omega_{1},\omega_{2},\cdots,\omega_{n}])=p^{k}(1-p)^{n-k}
  </annotation>
</semantics>
</math>

 where <em>k</em> is the number of times that <em>H</em> appears in the sequence, and <em>n</em>-<em>k</em> is the number of times that <em>T</em> appears in the sequence. There are several different kinds of notations for the above; a common one is to write</p>

<p>
<math display="block" id="Bernoulli_process:12">
<semantics>
<mrow>
<mi>P</mi>
<mrow>
<mo stretchy="false">(</mo>
<msub>
<mi>X</mi>
<mn>1</mn>
</msub>
<mo>=</mo>
<msub>
<mi>ω</mi>
<mn>1</mn>
</msub>
<mo>,</mo>
<msub>
<mi>X</mi>
<mn>2</mn>
</msub>
<mo>=</mo>
<msub>
<mi>ω</mi>
<mn>2</mn>
</msub>
<mo>,</mo>
<mi mathvariant="normal">⋯</mi>
<mo>,</mo>
<msub>
<mi>X</mi>
<mi>n</mi>
</msub>
<mo>=</mo>
<msub>
<mi>ω</mi>
<mi>n</mi>
</msub>
<mo stretchy="false">)</mo>
</mrow>
<mo>=</mo>
<msup>
<mi>p</mi>
<mi>k</mi>
</msup>
<msup>
<mrow>
<mo stretchy="false">(</mo>
<mn>1</mn>
<mo>-</mo>
<mi>p</mi>
<mo stretchy="false">)</mo>
</mrow>
<mrow>
<mi>n</mi>
<mo>-</mo>
<mi>k</mi>
</mrow>
</msup>
</mrow>
<annotation-xml encoding="MathML-Content">
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<csymbol cd="unknown">P</csymbol>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>X</ci>
<cn type="integer">1</cn>
</apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>ω</ci>
<cn type="integer">1</cn>
</apply>
<ci>normal-,</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>X</ci>
<cn type="integer">2</cn>
</apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>ω</ci>
<cn type="integer">2</cn>
</apply>
<ci>normal-,</ci>
<ci>normal-⋯</ci>
<ci>normal-,</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>X</ci>
<ci>n</ci>
</apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>ω</ci>
<ci>n</ci>
</apply>
<ci>normal-)</ci>
</cerror>
<eq></eq>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>p</ci>
<ci>k</ci>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<cn type="integer">1</cn>
<minus></minus>
<csymbol cd="unknown">p</csymbol>
<ci>normal-)</ci>
</cerror>
<apply>
<minus></minus>
<ci>n</ci>
<ci>k</ci>
</apply>
</apply>
</cerror>
</annotation-xml>
<annotation encoding="application/x-tex">
   P(X_{1}=\omega_{1},X_{2}=\omega_{2},\cdots,X_{n}=\omega_{n})=p^{k}(1-p)^{n-k}
  </annotation>
</semantics>
</math>

 where each 

<math display="inline" id="Bernoulli_process:13">
<semantics>
<msub>
<mi>X</mi>
<mi>i</mi>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>X</ci>
<ci>i</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   X_{i}
  </annotation>
</semantics>
</math>

 is a binary-valued <a href="random_variable" title="wikilink">random variable</a>. It is common to write 

<math display="inline" id="Bernoulli_process:14">
<semantics>
<msub>
<mi>x</mi>
<mi>i</mi>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<ci>i</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   x_{i}
  </annotation>
</semantics>
</math>

 for 

<math display="inline" id="Bernoulli_process:15">
<semantics>
<msub>
<mi>ω</mi>
<mi>i</mi>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>ω</ci>
<ci>i</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \omega_{i}
  </annotation>
</semantics>
</math>

. This probability <em>P</em> is commonly called the <a href="Bernoulli_measure" title="wikilink">Bernoulli measure</a>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>

<p>Note that the probability of any specific, infinitely long sequence of coin flips is exactly zero; this is because 

<math display="inline" id="Bernoulli_process:16">
<semantics>
<mrow>
<mrow>
<msub>
<mo>lim</mo>
<mrow>
<mi>n</mi>
<mo>→</mo>
<mi mathvariant="normal">∞</mi>
</mrow>
</msub>
<msup>
<mi>p</mi>
<mi>n</mi>
</msup>
</mrow>
<mo>=</mo>
<mn>0</mn>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<limit></limit>
<apply>
<ci>normal-→</ci>
<ci>n</ci>
<infinity></infinity>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>p</ci>
<ci>n</ci>
</apply>
</apply>
<cn type="integer">0</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \lim_{n\to\infty}p^{n}=0
  </annotation>
</semantics>
</math>

, for any 

<math display="inline" id="Bernoulli_process:17">
<semantics>
<mrow>
<mn>0</mn>
<mo>≤</mo>
<mi>p</mi>
<mo>&lt;</mo>
<mn>1</mn>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<and></and>
<apply>
<leq></leq>
<cn type="integer">0</cn>
<ci>p</ci>
</apply>
<apply>
<lt></lt>
<share href="#.cmml">
</share>
<cn type="integer">1</cn>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   0\leq p&lt;1
  </annotation>
</semantics>
</math>

. One says that any given infinite sequence has <a href="measure_zero" title="wikilink">measure zero</a>. Nevertheless, one can still say that some classes of infinite sequences of coin flips are far more likely than others, this is given by the <a href="asymptotic_equipartition_property" title="wikilink">asymptotic equipartition property</a>.</p>

<p>To conclude the formal definition, a Bernoulli process is then given by the probability triple 

<math display="inline" id="Bernoulli_process:18">
<semantics>
<mrow>
<mo stretchy="false">(</mo>
<mi mathvariant="normal">Ω</mi>
<mo>,</mo>
<mi class="ltx_font_mathcaligraphic">ℱ</mi>
<mo>,</mo>
<mi>P</mi>
<mo stretchy="false">)</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<vector>
<ci>normal-Ω</ci>
<ci>ℱ</ci>
<ci>P</ci>
</vector>
</annotation-xml>
<annotation encoding="application/x-tex">
   (\Omega,\mathcal{F},P)
  </annotation>
</semantics>
</math>

, as defined above.</p>
<h2 id="binomial-distribution">Binomial distribution</h2>

<p>The <a href="law_of_large_numbers" title="wikilink">law of large numbers</a> states that, on average, the <a href="expectation_value" title="wikilink">expectation value</a> of flipping <em>heads</em> for any one coin flip is <em>p</em>. That is, one writes</p>

<p>
<math display="block" id="Bernoulli_process:19">
<semantics>
<mrow>
<mi>E</mi>
<mrow>
<mo stretchy="false">[</mo>
<msub>
<mi>X</mi>
<mi>i</mi>
</msub>
<mo>=</mo>
<mi>H</mi>
<mo stretchy="false">]</mo>
</mrow>
<mo>=</mo>
<mi>p</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<csymbol cd="unknown">E</csymbol>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-[</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>X</ci>
<ci>i</ci>
</apply>
<eq></eq>
<csymbol cd="unknown">H</csymbol>
<ci>normal-]</ci>
</cerror>
<eq></eq>
<csymbol cd="unknown">p</csymbol>
</cerror>
</annotation-xml>
<annotation encoding="application/x-tex">
   E[X_{i}=H]=p
  </annotation>
</semantics>
</math>

 for any one given random variable 

<math display="inline" id="Bernoulli_process:20">
<semantics>
<msub>
<mi>X</mi>
<mi>i</mi>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>X</ci>
<ci>i</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   X_{i}
  </annotation>
</semantics>
</math>

 out of the infinite sequence of <a href="Bernoulli_trial" title="wikilink">Bernoulli trials</a> that compose the Bernoulli process.</p>

<p>One is often interested in knowing how often one will observe <em>H</em> in a sequence of <em>n</em> coin flips. This is given by simply counting: Given <em>n</em> successive coin flips, that is, given the set of all possible <a href="string_(computer_science)" title="wikilink">strings</a> of length <em>n</em>, the number <em>N</em>(<em>k</em>,<em>n</em>) of such strings that contain <em>k</em> occurrences of <em>H</em> is given by the <a href="binomial_coefficient" title="wikilink">binomial coefficient</a></p>

<p>
<math display="block" id="Bernoulli_process:21">
<semantics>
<mrow>
<mrow>
<mi>N</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>k</mi>
<mo>,</mo>
<mi>n</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<mo>(</mo>
<mtable columnspacing="0.4em" rowspacing="0.2ex">
<mtr>
<mtd>
<mi>n</mi>
</mtd>
</mtr>
<mtr>
<mtd>
<mi>k</mi>
</mtd>
</mtr>
</mtable>
<mo>)</mo>
</mrow>
<mo>=</mo>
<mfrac>
<mrow>
<mi>n</mi>
<mo lspace="0pt" rspace="3.5pt">!</mo>
</mrow>
<mrow>
<mrow>
<mi>k</mi>
<mo lspace="0pt" rspace="3.5pt">!</mo>
</mrow>
<mrow>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>n</mi>
<mo>-</mo>
<mi>k</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mo lspace="0pt" rspace="3.5pt">!</mo>
</mrow>
</mrow>
</mfrac>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<and></and>
<apply>
<eq></eq>
<apply>
<times></times>
<ci>N</ci>
<interval closure="open">
<ci>k</ci>
<ci>n</ci>
</interval>
</apply>
<apply>
<csymbol cd="latexml">binomial</csymbol>
<ci>n</ci>
<ci>k</ci>
</apply>
</apply>
<apply>
<eq></eq>
<share href="#.cmml">
</share>
<apply>
<divide></divide>
<apply>
<factorial></factorial>
<ci>n</ci>
</apply>
<apply>
<times></times>
<apply>
<factorial></factorial>
<ci>k</ci>
</apply>
<apply>
<factorial></factorial>
<apply>
<minus></minus>
<ci>n</ci>
<ci>k</ci>
</apply>
</apply>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   N(k,n)={n\choose k}=\frac{n!}{k!(n-k)!}
  </annotation>
</semantics>
</math>
</p>

<p>If the probability of flipping heads is given by <em>p</em>, then the total probability of seeing a string of length <em>n</em> with <em>k</em> heads is</p>

<p>
<math display="block" id="Bernoulli_process:22">
<semantics>
<mrow>
<mi>E</mi>
<mrow>
<mo stretchy="false">[</mo>
<msub>
<mi>X</mi>
<mi>i</mi>
</msub>
<mo>=</mo>
<mi>H</mi>
<mtext>k out of n times</mtext>
<mo stretchy="false">]</mo>
</mrow>
<mo>=</mo>
<mi>P</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>k</mi>
<mo>,</mo>
<mi>n</mi>
<mo stretchy="false">)</mo>
</mrow>
<mo>=</mo>
<mrow>
<mo>(</mo>
<mtable columnspacing="0.4em" rowspacing="0.2ex">
<mtr>
<mtd>
<mi>n</mi>
</mtd>
</mtr>
<mtr>
<mtd>
<mi>k</mi>
</mtd>
</mtr>
</mtable>
<mo>)</mo>
</mrow>
<msup>
<mi>p</mi>
<mi>k</mi>
</msup>
<msup>
<mrow>
<mo stretchy="false">(</mo>
<mn>1</mn>
<mo>-</mo>
<mi>p</mi>
<mo stretchy="false">)</mo>
</mrow>
<mrow>
<mi>n</mi>
<mo>-</mo>
<mi>k</mi>
</mrow>
</msup>
</mrow>
<annotation-xml encoding="MathML-Content">
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<csymbol cd="unknown">E</csymbol>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-[</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>X</ci>
<ci>i</ci>
</apply>
<eq></eq>
<csymbol cd="unknown">H</csymbol>
<mtext>k out of n times</mtext>
<ci>normal-]</ci>
</cerror>
<eq></eq>
<csymbol cd="unknown">P</csymbol>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<csymbol cd="unknown">k</csymbol>
<ci>normal-,</ci>
<csymbol cd="unknown">n</csymbol>
<ci>normal-)</ci>
</cerror>
<eq></eq>
<apply>
<csymbol cd="latexml">binomial</csymbol>
<ci>n</ci>
<ci>k</ci>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>p</ci>
<ci>k</ci>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<cn type="integer">1</cn>
<minus></minus>
<csymbol cd="unknown">p</csymbol>
<ci>normal-)</ci>
</cerror>
<apply>
<minus></minus>
<ci>n</ci>
<ci>k</ci>
</apply>
</apply>
</cerror>
</annotation-xml>
<annotation encoding="application/x-tex">
   E[X_{i}=H\mbox{ k out of n times}]=P(k,n)={n\choose k}p^{k}(1-p)^{n-k}
  </annotation>
</semantics>
</math>

 This probability is known as the <a href="Binomial_distribution" title="wikilink">Binomial distribution</a>.</p>

<p>Of particular interest is the question of the value of <em>P</em>(<em>k</em>,<em>n</em>) for very, very long sequences of coin flips, that is, for the limit 

<math display="inline" id="Bernoulli_process:23">
<semantics>
<mrow>
<mi>n</mi>
<mo>→</mo>
<mi mathvariant="normal">∞</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<ci>normal-→</ci>
<ci>n</ci>
<infinity></infinity>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   n\to\infty
  </annotation>
</semantics>
</math>

. In this case, one may make use of <a href="Stirling's_approximation" title="wikilink">Stirling's approximation</a> to the factorial, and write</p>

<p>
<math display="block" id="Bernoulli_process:24">
<semantics>
<mrow>
<mrow>
<mi>n</mi>
<mo lspace="0pt" rspace="3.5pt">!</mo>
</mrow>
<mo>=</mo>
<mrow>
<mpadded width="+2.8pt">
<msqrt>
<mrow>
<mn>2</mn>
<mi>π</mi>
<mi>n</mi>
</mrow>
</msqrt>
</mpadded>
<msup>
<mi>n</mi>
<mi>n</mi>
</msup>
<msup>
<mi>e</mi>
<mrow>
<mo>-</mo>
<mi>n</mi>
</mrow>
</msup>
<mrow>
<mo>(</mo>
<mrow>
<mn>1</mn>
<mo>+</mo>
<mrow>
<mi class="ltx_font_mathcaligraphic">𝒪</mi>
<mrow>
<mo>(</mo>
<mfrac>
<mn>1</mn>
<mi>n</mi>
</mfrac>
<mo>)</mo>
</mrow>
</mrow>
</mrow>
<mo>)</mo>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<factorial></factorial>
<ci>n</ci>
</apply>
<apply>
<times></times>
<apply>
<root></root>
<apply>
<times></times>
<cn type="integer">2</cn>
<ci>π</ci>
<ci>n</ci>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>n</ci>
<ci>n</ci>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>e</ci>
<apply>
<minus></minus>
<ci>n</ci>
</apply>
</apply>
<apply>
<plus></plus>
<cn type="integer">1</cn>
<apply>
<times></times>
<ci>𝒪</ci>
<apply>
<divide></divide>
<cn type="integer">1</cn>
<ci>n</ci>
</apply>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   n!=\sqrt{2\pi n}\;n^{n}e^{-n}\left(1+\mathcal{O}\left(\frac{1}{n}\right)\right)
  </annotation>
</semantics>
</math>
</p>

<p>Inserting this into the expression for <em>P</em>(<em>k</em>,<em>n</em>), one obtains the <a href="Gaussian_distribution" title="wikilink">Gaussian distribution</a>; this is the content of the <a href="central_limit_theorem" title="wikilink">central limit theorem</a>, and this is the simplest example thereof.</p>

<p>The combination of the law of large numbers, together with the central limit theorem, leads to an interesting and perhaps surprising result: the <a href="asymptotic_equipartition_property" title="wikilink">asymptotic equipartition property</a>. Put informally, one notes that, yes, over many coin flips, one will observe <em>H</em> exactly <em>p</em> fraction of the time, and that this corresponds exactly with the peak of the Gaussian. The asymptotic equipartition property essentially states that this peak is infinitely sharp, with infinite fall-off on either side. That is, given the set of all possible infinitely long strings of <em>H</em> and <em>T</em> occurring in the Bernoulli process, this set is partitioned into two: those strings that occur with probability 1, and those that occur with probability 0. This partitioning is known as the <a href="Kolmogorov_0-1_law" title="wikilink">Kolmogorov 0-1 law</a>.</p>

<p>The size of this set is interesting, also, and can be explicitly determined: the logarithm of it is exactly the <a href="information_entropy" title="wikilink">entropy</a> of the Bernoulli process. Once again, consider the set of all strings of length <em>n</em>. The size of this set is 

<math display="inline" id="Bernoulli_process:25">
<semantics>
<msup>
<mn>2</mn>
<mi>n</mi>
</msup>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<cn type="integer">2</cn>
<ci>n</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   2^{n}
  </annotation>
</semantics>
</math>

. Of these, only a certain subset are likely; the size of this set is 

<math display="inline" id="Bernoulli_process:26">
<semantics>
<msup>
<mn>2</mn>
<mrow>
<mi>n</mi>
<mi>H</mi>
</mrow>
</msup>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<cn type="integer">2</cn>
<apply>
<times></times>
<ci>n</ci>
<ci>H</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   2^{nH}
  </annotation>
</semantics>
</math>

 for 

<math display="inline" id="Bernoulli_process:27">
<semantics>
<mrow>
<mi>H</mi>
<mo>≤</mo>
<mn>1</mn>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<leq></leq>
<ci>H</ci>
<cn type="integer">1</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   H\leq 1
  </annotation>
</semantics>
</math>

. By using Stirling's approximation, putting it into the expression for <em>P</em>(<em>k</em>,<em>n</em>), solving for the location and width of the peak, and finally taking 

<math display="inline" id="Bernoulli_process:28">
<semantics>
<mrow>
<mi>n</mi>
<mo>→</mo>
<mi mathvariant="normal">∞</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<ci>normal-→</ci>
<ci>n</ci>
<infinity></infinity>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   n\to\infty
  </annotation>
</semantics>
</math>

 one finds that</p>

<p>
<math display="block" id="Bernoulli_process:29">
<semantics>
<mrow>
<mi>H</mi>
<mo>=</mo>
<mrow>
<mrow>
<mo>-</mo>
<mrow>
<mi>p</mi>
<mrow>
<msub>
<mi>log</mi>
<mn>2</mn>
</msub>
<mi>p</mi>
</mrow>
</mrow>
</mrow>
<mo>-</mo>
<mrow>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mn>1</mn>
<mo>-</mo>
<mi>p</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mrow>
<msub>
<mi>log</mi>
<mn>2</mn>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mn>1</mn>
<mo>-</mo>
<mi>p</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<ci>H</ci>
<apply>
<minus></minus>
<apply>
<minus></minus>
<apply>
<times></times>
<ci>p</ci>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<log></log>
<cn type="integer">2</cn>
</apply>
<ci>p</ci>
</apply>
</apply>
</apply>
<apply>
<times></times>
<apply>
<minus></minus>
<cn type="integer">1</cn>
<ci>p</ci>
</apply>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<log></log>
<cn type="integer">2</cn>
</apply>
<apply>
<minus></minus>
<cn type="integer">1</cn>
<ci>p</ci>
</apply>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   H=-p\log_{2}p-(1-p)\log_{2}(1-p)
  </annotation>
</semantics>
</math>
</p>

<p>This value is the <a href="Bernoulli_entropy" title="wikilink">Bernoulli entropy</a> of a Bernoulli process. Here, <em>H</em> stands for entropy; do not confuse it with the same symbol <em>H</em> standing for <em>heads</em>.</p>

<p><a href="von_Neumann" title="wikilink">von Neumann</a> posed a curious question about the Bernoulli process: is it ever possible that a given process is <a class="uri" href="isomorphic" title="wikilink">isomorphic</a> to another, in the sense of the <a href="isomorphism_of_dynamical_systems" title="wikilink">isomorphism of dynamical systems</a>? The question long defied analysis, but was finally and completely answered with the <a href="Ornstein_isomorphism_theorem" title="wikilink">Ornstein isomorphism theorem</a>. This breakthrough resulted in the understanding that the Bernoulli process is unique and <a href="universal_property" title="wikilink">universal</a>; in a certain sense, it is the single most random process possible; nothing is 'more' random than the Bernoulli process (although one must be careful with this informal statement; certainly, systems that are <a href="mixing_(mathematics)" title="wikilink">mixing</a> are, in a certain sense, 'stronger' than the Bernoulli process, which is merely ergodic but not mixing. However, such processes do not consist of independent random variables: indeed, many purely deterministic, non-random systems can be mixing).</p>
<h2 id="dynamical-system">Dynamical system</h2>

<p>The Bernoulli process can also be understood to be a <a href="dynamical_system" title="wikilink">dynamical system</a>, specifically, a <a href="measure-preserving_dynamical_system" title="wikilink">measure-preserving dynamical system</a>. This arises because there is a natural translation symmetry on the (two-sided) product space 

<math display="inline" id="Bernoulli_process:30">
<semantics>
<mrow>
<mi mathvariant="normal">Ω</mi>
<mo>=</mo>
<msup>
<mn>2</mn>
<mi>ℤ</mi>
</msup>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<ci>normal-Ω</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<cn type="integer">2</cn>
<ci>ℤ</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \Omega=2^{\mathbb{Z}}
  </annotation>
</semantics>
</math>

 given by the <a href="shift_operator" title="wikilink">shift operator</a></p>

<p>
<math display="block" id="Bernoulli_process:31">
<semantics>
<mrow>
<mrow>
<mi>T</mi>
<msub>
<mi>X</mi>
<mi>i</mi>
</msub>
</mrow>
<mo>=</mo>
<msub>
<mi>X</mi>
<mrow>
<mi>i</mi>
<mo>+</mo>
<mn>1</mn>
</mrow>
</msub>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<times></times>
<ci>T</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>X</ci>
<ci>i</ci>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>X</ci>
<apply>
<plus></plus>
<ci>i</ci>
<cn type="integer">1</cn>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   TX_{i}=X_{i+1}
  </annotation>
</semantics>
</math>
</p>

<p>The measure is translation-invariant; that is, given any cylinder set 

<math display="inline" id="Bernoulli_process:32">
<semantics>
<mrow>
<mi>ω</mi>
<mo>∈</mo>
<mi mathvariant="normal">Ω</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<in></in>
<ci>ω</ci>
<ci>normal-Ω</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \omega\in\Omega
  </annotation>
</semantics>
</math>

, one has</p>

<p>
<math display="block" id="Bernoulli_process:33">
<semantics>
<mrow>
<mrow>
<mi>P</mi>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>T</mi>
<mi>ω</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<mi>P</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>ω</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<times></times>
<ci>P</ci>
<apply>
<times></times>
<ci>T</ci>
<ci>ω</ci>
</apply>
</apply>
<apply>
<times></times>
<ci>P</ci>
<ci>ω</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   P(T\omega)=P(\omega)
  </annotation>
</semantics>
</math>

 and thus the <a href="Bernoulli_measure" title="wikilink">Bernoulli measure</a> is a <a href="Haar_measure" title="wikilink">Haar measure</a>.</p>

<p>The shift operator should be understood to be an operator acting on the sigma algebra 

<math display="inline" id="Bernoulli_process:34">
<semantics>
<mrow>
<mo stretchy="false">(</mo>
<mi mathvariant="normal">Ω</mi>
<mo>,</mo>
<mi class="ltx_font_mathcaligraphic">ℱ</mi>
<mo stretchy="false">)</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<interval closure="open">
<ci>normal-Ω</ci>
<ci>ℱ</ci>
</interval>
</annotation-xml>
<annotation encoding="application/x-tex">
   (\Omega,\mathcal{F})
  </annotation>
</semantics>
</math>

, so that one has</p>

<p>
<math display="block" id="Bernoulli_process:35">
<semantics>
<mrow>
<mi>T</mi>
<mo>:</mo>
<mrow>
<mi class="ltx_font_mathcaligraphic">ℱ</mi>
<mo>→</mo>
<mi class="ltx_font_mathcaligraphic">ℱ</mi>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<ci>normal-:</ci>
<ci>T</ci>
<apply>
<ci>normal-→</ci>
<ci>ℱ</ci>
<ci>ℱ</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   T:\mathcal{F}\to\mathcal{F}
  </annotation>
</semantics>
</math>

 In this guise, the shift operator is known as the <a href="transfer_operator" title="wikilink">transfer operator</a> or the <em>Ruelle-Frobenius-Perron operator</em>. It is interesting to consider the <a href="eigenfunction" title="wikilink">eigenfunctions</a> of this operator, and how they differ when restricted to different subspaces of 

<math display="inline" id="Bernoulli_process:36">
<semantics>
<mrow>
<mo stretchy="false">(</mo>
<mi mathvariant="normal">Ω</mi>
<mo>,</mo>
<mi class="ltx_font_mathcaligraphic">ℱ</mi>
<mo stretchy="false">)</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<interval closure="open">
<ci>normal-Ω</ci>
<ci>ℱ</ci>
</interval>
</annotation-xml>
<annotation encoding="application/x-tex">
   (\Omega,\mathcal{F})
  </annotation>
</semantics>
</math>

. When restricted to the standard topology of the real numbers, the eigenfunctions are curiously the <a href="Bernoulli_polynomial" title="wikilink">Bernoulli polynomials</a>!<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a><a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> This coincidence of naming was presumably not known to Bernoulli.</p>
<h2 id="bernoulli-sequence">Bernoulli sequence</h2>

<p>The term <strong>Bernoulli sequence</strong> is often used informally to refer to a <a href="realization_(probability)" title="wikilink">realization</a> of a Bernoulli process. However, the term has an entirely different formal definition as given below.</p>

<p>Suppose a Bernoulli process formally defined as a single random variable (see preceding section). For every infinite sequence <em>x</em> of coin flips, there is a <a class="uri" href="sequence" title="wikilink">sequence</a> of integers</p>

<p>
<math display="block" id="Bernoulli_process:37">
<semantics>
<mrow>
<msup>
<mi>ℤ</mi>
<mi>x</mi>
</msup>
<mo>=</mo>
<mrow>
<mo stretchy="false">{</mo>
<mrow>
<mi>n</mi>
<mo>∈</mo>
<mi>ℤ</mi>
</mrow>
<mo>:</mo>
<mrow>
<mrow>
<msub>
<mi>X</mi>
<mi>n</mi>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>x</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mn>1</mn>
</mrow>
<mo rspace="4.2pt" stretchy="false">}</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>ℤ</ci>
<ci>x</ci>
</apply>
<apply>
<csymbol cd="latexml">conditional-set</csymbol>
<apply>
<in></in>
<ci>n</ci>
<ci>ℤ</ci>
</apply>
<apply>
<eq></eq>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>X</ci>
<ci>n</ci>
</apply>
<ci>x</ci>
</apply>
<cn type="integer">1</cn>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mathbb{Z}^{x}=\{n\in\mathbb{Z}:X_{n}(x)=1\}\,
  </annotation>
</semantics>
</math>
</p>

<p>called the <strong>Bernoulli sequence</strong> associated with the Bernoulli process. For example, if <em>x</em> represents a sequence of coin flips, then the associated Bernoulli sequence is the list of natural numbers or time-points for which the coin toss outcome is <em>heads</em>.</p>

<p>So defined, a Bernoulli sequence 

<math display="inline" id="Bernoulli_process:38">
<semantics>
<msup>
<mi>ℤ</mi>
<mi>x</mi>
</msup>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>ℤ</ci>
<ci>x</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mathbb{Z}^{x}
  </annotation>
</semantics>
</math>

 is also a random subset of the index set, the natural numbers 

<math display="inline" id="Bernoulli_process:39">
<semantics>
<mi>ℕ</mi>
<annotation-xml encoding="MathML-Content">
<ci>ℕ</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mathbb{N}
  </annotation>
</semantics>
</math>

.</p>

<p><a href="Almost_all" title="wikilink">Almost all</a> Bernoulli sequences 

<math display="inline" id="Bernoulli_process:40">
<semantics>
<msup>
<mi>ℤ</mi>
<mi>x</mi>
</msup>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>ℤ</ci>
<ci>x</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mathbb{Z}^{x}
  </annotation>
</semantics>
</math>

 are <a href="ergodic_sequence" title="wikilink">ergodic sequences</a>.</p>
<h2 id="randomness-extraction">Randomness extraction</h2>

<p>From any Bernoulli process one may derive a Bernoulli process with <em>p</em> = 1/2 by the <a href="von_Neumann_extractor" title="wikilink">von Neumann extractor</a>, the earliest <a href="randomness_extractor" title="wikilink">randomness extractor</a>, which actually extracts uniform randomness.</p>
<h3 id="basic-von-neumann-extractor">Basic Von Neumann extractor</h3>

<p>Represent the observed process as a sequence of zeroes and ones, or bits, and group that input stream in non-overlapping pairs of successive bits, such as (11)(00)(10)... . Then for each pair,</p>
<ul>
<li>if the bits are equal, discard;</li>
<li>if the bits are not equal, output the first bit.</li>
</ul>

<p>This table summarizes the computation.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">

<p>input</p></th>
<th style="text-align: left;">

<p>output</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">

<p>00</p></td>
<td style="text-align: left;">

<p>discard</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">

<p>01</p></td>
<td style="text-align: left;">

<p>0</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">

<p>10</p></td>
<td style="text-align: left;">

<p>1</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">

<p>11</p></td>
<td style="text-align: left;">

<p>discard</p></td>
</tr>
</tbody>
</table>

<p>For example, an input stream of eight bits <strong>10011011</strong> would by grouped into pairs as <strong>(10)(01)(10)(11)</strong>. Then, according to the table above, these pairs are translated into the output of the procedure: <strong>(1)(0)(1)()</strong> (=<strong>101</strong>).</p>

<p>In the output stream 0 and 1 are equally likely, as 10 and 01 are equally likely in the original, both having probability <em>pq</em> = <em>qp.</em> This extraction of uniform randomness does not require the input trials to be independent, only <a class="uri" href="uncorrelated" title="wikilink">uncorrelated</a>. More generally, it works for any <a href="exchangeable_random_variables" title="wikilink">exchangeable sequence</a> of bits: all sequences that are finite rearrangements are equally likely.</p>

<p>The Von Neumann extractor uses two input bits to produce either zero or one output bits, so the output is shorter than the input by a factor of at least 2. On average the computation discards proportion <em>p</em><sup>2</sup> + (1 − <em>p</em>)<sup>2</sup> of the input pairs, or proportion <em>p</em><sup>2</sup> + <em>q</em><sup>2</sup>, which is near one when <em>p</em> is near zero or one.</p>

<p>The discard of input pairs is at least proportion 1/2, the minimum which occurs where <em>p</em> = 1/2 for the original process. In that case the output stream is 1/4 the length of the input on average.</p>
<h3 id="iterated-von-neumann-extractor">Iterated Von Neumann extractor</h3>

<p>This decrease in efficiency, or waste of randomness present in the input stream, can be mitigated by iterating the algorithm over the input data. This way the output can be made to be "arbitrarily close to the entropy bound".<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> In short, the algorithm can be described as: For every pair (xy) of bits consumed from the input stream append <em>one</em> of them to the input again; it does not matter which bit from (xy) is appended, either bit <em>x</em> or <em>y</em> may be used. This way, for each iteration, <em>two</em> bits are first removed from the input and then <em>one</em> bit is added to the input again, so that, as a result, the input is only shortened by <em>one</em> bit per iteration as opposed to two bits in the original approach. The table from above thus changes with this approach:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">

<p>input</p></th>
<th style="text-align: left;">

<p>output</p></th>
<th style="text-align: left;">

<p>appended</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">

<p>00</p></td>
<td style="text-align: left;">

<p><em>none</em></p></td>
<td style="text-align: left;">

<p>0</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">

<p>01</p></td>
<td style="text-align: left;">

<p>0</p></td>
<td style="text-align: left;">

<p>1</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">

<p>10</p></td>
<td style="text-align: left;">

<p>1</p></td>
<td style="text-align: left;">

<p>0</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">

<p>11</p></td>
<td style="text-align: left;">

<p><em>none</em></p></td>
<td style="text-align: left;">

<p>1</p></td>
</tr>
</tbody>
</table>

<p>(In this case, from each pair (xy) the <em>y</em> bit is appended, but the <em>x</em> bit could have been chosen alternatively without affecting the randomness of the output.)</p>

<p>Example: The input stream from above, <strong>10011011</strong>, is processed this way:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">

<p>step</p></th>
<th style="text-align: left;">

<p>input</p></th>
<th style="text-align: left;">

<p>output</p></th>
<th style="text-align: left;">

<p>appended</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">

<p>1</p></td>
<td style="text-align: left;">

<p><strong>011011</strong></p></td>
<td style="text-align: left;">

<p>1</p></td>
<td style="text-align: left;">

<p>0</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">

<p>2</p></td>
<td style="text-align: left;">

<p><strong>1011</strong>0</p></td>
<td style="text-align: left;">

<p>0</p></td>
<td style="text-align: left;">

<p>1</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">

<p>3</p></td>
<td style="text-align: left;">

<p><strong>11</strong>01</p></td>
<td style="text-align: left;">

<p>1</p></td>
<td style="text-align: left;">

<p>0</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">

<p>4</p></td>
<td style="text-align: left;">

<p><strong></strong>010</p></td>
<td style="text-align: left;">

<p><em>none</em></p></td>
<td style="text-align: left;">

<p>1</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">

<p>5</p></td>
<td style="text-align: left;">

<p>01</p></td>
<td style="text-align: left;">

<p>0</p></td>
<td style="text-align: left;">

<p>1</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">

<p>6</p></td>
<td style="text-align: left;">

<p>1</p></td>
<td style="text-align: left;">

<p>0</p></td>
<td style="text-align: left;">

<p>1</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">

<p>7</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">

<p><em>none</em></p></td>
<td style="text-align: left;">

<p>1</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">

<p>8</p></td>
<td style="text-align: left;">

<p>1</p></td>
<td style="text-align: left;">

<p><em>terminate</em></p></td>
<td style="text-align: left;">

<p><em>none</em></p></td>
</tr>
</tbody>
</table>

<p>The output is therefore <strong>(1)(0)(1)()(0)(0)()</strong> (=<strong>10100</strong>), so that from the eight bits of input five bits of output were generated, as opposed to three bits through the basic algorithm above.</p>
<h2 id="references">References</h2>
<h2 id="further-reading">Further reading</h2>
<ul>
<li>Carl W. Helstrom, <em>Probability and Stochastic Processes for Engineers</em>, (1984) Macmillan Publishing Company, New York ISBN 0-02-353560-1.</li>
<li>Dimitri P. Bertsekas and John N. Tsitsiklis, <em>Introduction to Probability</em>, (2002) Athena Scientific, Massachusetts ISBN 1-886529-40-X</li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.r-statistics.com/2011/11/diagram-for-a-bernoulli-process-using-r/">Using a binary tree diagram for describing a Bernoulli process</a></li>
</ul>

<p>"</p>

<p><a href="Category:Stochastic_processes" title="wikilink">Category:Stochastic processes</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2">Pierre Gaspard, "<em>r</em>-adic one-dimensional maps and the Euler summation formula", <em>Journal of Physics A</em>, <strong>25</strong> (letter) L483-L485 (1992).<a href="#fnref2">↩</a></li>
<li id="fn3">Dean J. Driebe, Fully Chaotic Maps and Broken Time Symmetry, (1999) Kluwer Academic Publishers, Dordrecht Netherlands ISBN 0-7923-5564-4<a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
</ol>
</section>
</body>
</html>
