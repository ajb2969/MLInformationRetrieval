<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="668">Butcher group</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Butcher group</h1>
<hr/>

<p>In <a class="uri" href="mathematics" title="wikilink">mathematics</a>, the <strong>Butcher group</strong>, named after the New Zealand mathematician <a href="John_C._Butcher" title="wikilink">John C. Butcher</a> by , is an infinite-dimensional <a href="group_(mathematics)" title="wikilink">group</a> first introduced in <a href="numerical_analysis" title="wikilink">numerical analysis</a> to study solutions of non-linear <a href="ordinary_differential_equation" title="wikilink">ordinary differential equations</a> by the <a href="Runge–Kutta_method" title="wikilink">Runge–Kutta method</a>. It arose from an algebraic formalism involving <a href="rooted_tree" title="wikilink">rooted trees</a> that provides <a href="formal_power_series" title="wikilink">formal power series</a> solutions of the differential equation modeling the flow of a <a href="vector_field" title="wikilink">vector field</a>. It was , prompted by the work of <a href="James_Joseph_Sylvester" title="wikilink">Sylvester</a> on change of variables in <a href="differential_calculus" title="wikilink">differential calculus</a>, who first noted that the <a href="Faà_di_Bruno's_formula" title="wikilink">derivatives of a composition of functions</a> can be conveniently expressed in terms of rooted trees and their combinatorics.</p>

<p>pointed out that the Butcher group is the group of characters of the <a href="Hopf_algebra" title="wikilink">Hopf algebra</a> of rooted trees that had arisen independently in their own work on <a class="uri" href="renormalization" title="wikilink">renormalization</a> in <a href="quantum_field_theory" title="wikilink">quantum field theory</a> and <a href="Alain_Connes" title="wikilink">Connes</a>' work with <a href="Henri_Moscovici" title="wikilink">Moscovici</a> on local <a href="index_theorem" title="wikilink">index theorems</a>. This Hopf algebra, often called the <em>Connes-Kreimer algebra</em>, is essentially equivalent to the Butcher group, since its dual can be identified with the <a href="universal_enveloping_algebra" title="wikilink">universal enveloping algebra</a> of the <a href="Lie_algebra" title="wikilink">Lie algebra</a> of the Butcher group.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> As they commented: </p>
<h2 id="differentials-and-rooted-trees">Differentials and rooted trees</h2>

<p> A rooted tree is a <a href="graph_theory" title="wikilink">graph</a> with a distinguished node, called the <em>root</em>, in which every other node is connected to the root by a unique path. If the root of a tree <strong>t</strong> is removed and the nodes connected to the original node by a single bond are taken as new roots, the tree <strong>t</strong> breaks up into rooted trees <strong>t</strong><sub>1</sub>, <strong>t</strong><sub>2</sub>, ... Reversing this process a new tree <strong>t</strong> = [<strong>t</strong><sub>1</sub>, <strong>t</strong><sub>2</sub>, ...] can be constructed by joining the roots of the trees to a new common root. The number of nodes in a tree is denoted by |<strong>t</strong>|. A <em>heap-ordering</em> of a rooted tree <strong>t</strong> is an allocation of the numbers 1 through |<strong>t</strong>| to the nodes so that the numbers increase on any path going away from the root. Two heap orderings are <em>equivalent</em>, if there is an <a class="uri" href="automorphism" title="wikilink">automorphism</a> of rooted trees mapping one of them on the other. The number of <a href="equivalence_class" title="wikilink">equivalence classes</a> of heap-orderings on a particular tree is denoted by α(<strong>t</strong>) and can be computed using the Butcher's formula:<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a><a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>

<p>

<math display="block" id="Butcher_group:0">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>α</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mfrac>
     <mrow>
      <mrow>
       <mo stretchy="false">|</mo>
       <mi>t</mi>
       <mo stretchy="false">|</mo>
      </mrow>
      <mo lspace="0pt" rspace="3.5pt">!</mo>
     </mrow>
     <mrow>
      <mrow>
       <mi>t</mi>
       <mo lspace="0pt" rspace="3.5pt">!</mo>
      </mrow>
      <mrow>
       <mo stretchy="false">|</mo>
       <msub>
        <mi>S</mi>
        <mi>t</mi>
       </msub>
       <mo stretchy="false">|</mo>
      </mrow>
     </mrow>
    </mfrac>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>α</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <factorial></factorial>
      <apply>
       <abs></abs>
       <ci>t</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <factorial></factorial>
       <ci>t</ci>
      </apply>
      <apply>
       <abs></abs>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>S</ci>
        <ci>t</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle\alpha(t)={|t|!\over t!|S_{t}|},
  </annotation>
 </semantics>
</math>

</p>

<p>where <em>S</em><sub><strong>t</strong></sub> denotes the <a href="symmetry_group" title="wikilink">symmetry group</a> of <strong>t</strong> and the tree factorial is defined recursively by</p>

<p>

<math display="block" id="Butcher_group:1">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">[</mo>
     <msub>
      <mi>t</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <msub>
      <mi>t</mi>
      <mi>n</mi>
     </msub>
     <mo stretchy="false">]</mo>
    </mrow>
    <mo lspace="0pt" rspace="3.5pt">!</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <mo stretchy="false">|</mo>
      <mrow>
       <mo stretchy="false">[</mo>
       <msub>
        <mi>t</mi>
        <mn>1</mn>
       </msub>
       <mo>,</mo>
       <mi mathvariant="normal">…</mi>
       <mo>,</mo>
       <msub>
        <mi>t</mi>
        <mi>n</mi>
       </msub>
       <mo stretchy="false">]</mo>
      </mrow>
      <mo stretchy="false">|</mo>
     </mrow>
     <mo>⋅</mo>
     <mrow>
      <msub>
       <mi>t</mi>
       <mn>1</mn>
      </msub>
      <mo lspace="0pt" rspace="3.5pt">!</mo>
     </mrow>
    </mrow>
    <mi mathvariant="normal">⋯</mi>
    <mrow>
     <msub>
      <mi>t</mi>
      <mi>n</mi>
     </msub>
     <mo lspace="0pt" rspace="3.5pt">!</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <factorial></factorial>
     <list>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>t</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>t</ci>
       <ci>n</ci>
      </apply>
     </list>
    </apply>
    <apply>
     <times></times>
     <apply>
      <ci>normal-⋅</ci>
      <apply>
       <abs></abs>
       <list>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>t</ci>
         <cn type="integer">1</cn>
        </apply>
        <ci>normal-…</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>t</ci>
         <ci>n</ci>
        </apply>
       </list>
      </apply>
      <apply>
       <factorial></factorial>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>t</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
     <ci>normal-⋯</ci>
     <apply>
      <factorial></factorial>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>t</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [t_{1},\dots,t_{n}]!=|[t_{1},\dots,t_{n}]|\cdot t_{1}!\cdots t_{n}!
  </annotation>
 </semantics>
</math>

</p>

<p>with the tree factorial of an isolated root defined to be 1</p>

<p>

<math display="block" id="Butcher_group:2">
 <semantics>
  <mrow>
   <mo>∙</mo>
   <mo lspace="0pt" rspace="3.5pt">!</mo>
   <mo>=</mo>
   <mn>1.</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-∙</ci>
    <factorial></factorial>
    <eq></eq>
    <cn type="float">1.</cn>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bullet!=1.
  </annotation>
 </semantics>
</math>

</p>

<p>The ordinary differential equation for the flow of a <a href="vector_field" title="wikilink">vector field</a> on an open subset <em>U</em> of <strong>R</strong><sup>N</sup> can be written</p>

<p>

<math display="block" id="Butcher_group:3">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mfrac>
      <mrow>
       <mi>d</mi>
       <mi>x</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>s</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mrow>
       <mi>d</mi>
       <mi>s</mi>
      </mrow>
     </mfrac>
     <mo>=</mo>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>x</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>s</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo rspace="5.9pt">,</mo>
    <mrow>
     <mrow>
      <mi>x</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mn>0</mn>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>=</mo>
     <msub>
      <mi>x</mi>
      <mn>0</mn>
     </msub>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <ci>d</ci>
       <ci>x</ci>
       <ci>s</ci>
      </apply>
      <apply>
       <times></times>
       <ci>d</ci>
       <ci>s</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <apply>
       <times></times>
       <ci>x</ci>
       <ci>s</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>x</ci>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">0</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{dx(s)\over ds}=f(x(s)),\,\,x(0)=x_{0},
  </annotation>
 </semantics>
</math>

</p>

<p>where <em>x</em>(<em>s</em>) takes values in <em>U</em>, <em>f</em> is a smooth function from <em>U</em> to <strong>R</strong><sup>N</sup> and <em>x</em><sub>0</sub> is the starting point of the flow at time <em>s</em> = 0.</p>

<p>gave a method to compute the higher order derivatives <em>x</em><sup>(<em>m</em>)</sup>(<em>s</em>) in terms of rooted trees. His formula can be conveniently expressed using the <em>elementary differentials</em> introduced by Butcher. These are defined inductively by</p>

<p>

<math display="block" id="Butcher_group:4">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msubsup>
      <mi>δ</mi>
      <mo>∙</mo>
      <mi>i</mi>
     </msubsup>
     <mo>=</mo>
     <msup>
      <mi>f</mi>
      <mi>i</mi>
     </msup>
    </mrow>
    <mo rspace="7.6pt">,</mo>
    <mrow>
     <msubsup>
      <mi>δ</mi>
      <mrow>
       <mo stretchy="false">[</mo>
       <msub>
        <mi>t</mi>
        <mn>1</mn>
       </msub>
       <mo>,</mo>
       <mi mathvariant="normal">…</mi>
       <mo>,</mo>
       <msub>
        <mi>t</mi>
        <mi>n</mi>
       </msub>
       <mo stretchy="false">]</mo>
      </mrow>
      <mi>i</mi>
     </msubsup>
     <mo>=</mo>
     <mrow>
      <munderover>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mrow>
        <mrow>
         <msub>
          <mi>j</mi>
          <mn>1</mn>
         </msub>
         <mo>,</mo>
         <mi mathvariant="normal">…</mi>
         <mo>,</mo>
         <msub>
          <mi>j</mi>
          <mi>n</mi>
         </msub>
        </mrow>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <mi>N</mi>
      </munderover>
      <mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <msubsup>
          <mi>δ</mi>
          <msub>
           <mi>t</mi>
           <mn>1</mn>
          </msub>
          <msub>
           <mi>j</mi>
           <mn>1</mn>
          </msub>
         </msubsup>
         <mi mathvariant="normal">⋯</mi>
         <msubsup>
          <mi>δ</mi>
          <msub>
           <mi>t</mi>
           <mi>n</mi>
          </msub>
          <msub>
           <mi>j</mi>
           <mi>n</mi>
          </msub>
         </msubsup>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mrow>
        <msub>
         <mo>∂</mo>
         <msub>
          <mi>j</mi>
          <mn>1</mn>
         </msub>
        </msub>
        <mi mathvariant="normal">⋯</mi>
       </mrow>
       <mrow>
        <msub>
         <mo>∂</mo>
         <msub>
          <mi>j</mi>
          <mi>n</mi>
         </msub>
        </msub>
        <msup>
         <mi>f</mi>
         <mi>i</mi>
        </msup>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>δ</ci>
       <ci>normal-∙</ci>
      </apply>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>f</ci>
      <ci>i</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>δ</ci>
       <ci>i</ci>
      </apply>
      <list>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>t</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>normal-…</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>t</ci>
        <ci>n</ci>
       </apply>
      </list>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <list>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>j</ci>
           <cn type="integer">1</cn>
          </apply>
          <ci>normal-…</ci>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>j</ci>
           <ci>n</ci>
          </apply>
         </list>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>N</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>δ</ci>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>j</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>t</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>normal-⋯</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>δ</ci>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>j</ci>
           <ci>n</ci>
          </apply>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>t</ci>
          <ci>n</ci>
         </apply>
        </apply>
       </apply>
       <apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <partialdiff></partialdiff>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>j</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>normal-⋯</ci>
       </apply>
       <apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <partialdiff></partialdiff>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>j</ci>
          <ci>n</ci>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>f</ci>
         <ci>i</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta_{\bullet}^{i}=f^{i},\,\,\,\delta^{i}_{[t_{1},\dots,t_{n}]}=\sum_{j_{1},%
\dots,j_{n}=1}^{N}(\delta^{j_{1}}_{t_{1}}\cdots\delta^{j_{n}}_{t_{n}})\partial%
_{j_{1}}\cdots\partial_{j_{n}}f^{i}.
  </annotation>
 </semantics>
</math>

</p>

<p>With this notation</p>

<p>

<math display="block" id="Butcher_group:5">
 <semantics>
  <mrow>
   <mrow>
    <mfrac>
     <mrow>
      <msup>
       <mi>d</mi>
       <mi>m</mi>
      </msup>
      <mi>x</mi>
     </mrow>
     <mrow>
      <mi>d</mi>
      <msup>
       <mi>s</mi>
       <mi>m</mi>
      </msup>
     </mrow>
    </mfrac>
    <mo>=</mo>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mrow>
        <mo stretchy="false">|</mo>
        <mi>t</mi>
        <mo stretchy="false">|</mo>
       </mrow>
       <mo>=</mo>
       <mi>m</mi>
      </mrow>
     </munder>
     <mrow>
      <mi>α</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <msub>
       <mi>δ</mi>
       <mi>t</mi>
      </msub>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>d</ci>
       <ci>m</ci>
      </apply>
      <ci>x</ci>
     </apply>
     <apply>
      <times></times>
      <ci>d</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>s</ci>
       <ci>m</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <eq></eq>
       <apply>
        <abs></abs>
        <ci>t</ci>
       </apply>
       <ci>m</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>α</ci>
      <ci>t</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>δ</ci>
       <ci>t</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {d^{m}x\over ds^{m}}=\sum_{|t|=m}\alpha(t)\delta_{t},
  </annotation>
 </semantics>
</math>

</p>

<p>giving the power series expansion</p>

<p>

<math display="block" id="Butcher_group:6">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>x</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>s</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>x</mi>
      <mn>0</mn>
     </msub>
     <mo>+</mo>
     <mrow>
      <munder>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mi>t</mi>
      </munder>
      <mrow>
       <mfrac>
        <msup>
         <mi>s</mi>
         <mrow>
          <mo stretchy="false">|</mo>
          <mi>t</mi>
          <mo stretchy="false">|</mo>
         </mrow>
        </msup>
        <mrow>
         <mrow>
          <mo stretchy="false">|</mo>
          <mi>t</mi>
          <mo stretchy="false">|</mo>
         </mrow>
         <mo lspace="0pt" rspace="3.5pt">!</mo>
        </mrow>
       </mfrac>
       <mi>α</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>t</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <msub>
        <mi>δ</mi>
        <mi>t</mi>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mn>0</mn>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>x</ci>
     <ci>s</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <ci>t</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>s</ci>
         <apply>
          <abs></abs>
          <ci>t</ci>
         </apply>
        </apply>
        <apply>
         <factorial></factorial>
         <apply>
          <abs></abs>
          <ci>t</ci>
         </apply>
        </apply>
       </apply>
       <ci>α</ci>
       <ci>t</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>δ</ci>
        <ci>t</ci>
       </apply>
       <cn type="integer">0</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle x(s)=x_{0}+\sum_{t}{s^{|t|}\over|t|!}\alpha(t)\delta_{t}(0).
  </annotation>
 </semantics>
</math>

</p>

<p>As an example when <em>N</em> = 1, so that <em>x</em> and <em>f</em> are real-valued functions of a single real variable, the formula yields</p>

<p>

<math display="block" id="Butcher_group:7">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>x</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>4</mn>
      <mo stretchy="false">)</mo>
     </mrow>
    </msup>
    <mo>=</mo>
    <mrow>
     <mrow>
      <msup>
       <mi>f</mi>
       <mi>′′′</mi>
      </msup>
      <msup>
       <mi>f</mi>
       <mn>3</mn>
      </msup>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mn>3</mn>
      <msup>
       <mi>f</mi>
       <mi>′′</mi>
      </msup>
      <msup>
       <mi>f</mi>
       <mo>′</mo>
      </msup>
      <msup>
       <mi>f</mi>
       <mn>2</mn>
      </msup>
     </mrow>
     <mo>+</mo>
     <mrow>
      <msup>
       <mi>f</mi>
       <mo>′</mo>
      </msup>
      <msup>
       <mi>f</mi>
       <mi>′′</mi>
      </msup>
      <msup>
       <mi>f</mi>
       <mn>2</mn>
      </msup>
     </mrow>
     <mo>+</mo>
     <mrow>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <msup>
         <mi>f</mi>
         <mo>′</mo>
        </msup>
        <mo stretchy="false">)</mo>
       </mrow>
       <mn>3</mn>
      </msup>
      <mi>f</mi>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <cn type="integer">4</cn>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>f</ci>
       <ci>′′′</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>f</ci>
       <cn type="integer">3</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">3</cn>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>f</ci>
       <ci>′′</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>f</ci>
       <ci>normal-′</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>f</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>f</ci>
       <ci>normal-′</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>f</ci>
       <ci>′′</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>f</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>f</ci>
        <ci>normal-′</ci>
       </apply>
       <cn type="integer">3</cn>
      </apply>
      <ci>f</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{(4)}=f^{\prime\prime\prime}f^{3}+3f^{\prime\prime}f^{\prime}f^{2}+f^{\prime%
}f^{\prime\prime}f^{2}+(f^{\prime})^{3}f,
  </annotation>
 </semantics>
</math>

</p>

<p>where the four terms correspond to the four rooted trees from left to right in Figure 3 above.</p>

<p>In a single variable this formula is the same as <a href="Faà_di_Bruno's_formula" title="wikilink">Faà di Bruno's formula</a> of 1855; however in several variables it has to be written more carefully in the form</p>

<p>

<math display="block" id="Butcher_group:8">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>x</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>4</mn>
      <mo stretchy="false">)</mo>
     </mrow>
    </msup>
    <mo>=</mo>
    <mrow>
     <mrow>
      <msup>
       <mi>f</mi>
       <mi>′′′</mi>
      </msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>f</mi>
       <mo>,</mo>
       <mi>f</mi>
       <mo>,</mo>
       <mi>f</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mn>3</mn>
      <msup>
       <mi>f</mi>
       <mi>′′</mi>
      </msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>f</mi>
       <mo>,</mo>
       <mrow>
        <msup>
         <mi>f</mi>
         <mo>′</mo>
        </msup>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>f</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mrow>
      <msup>
       <mi>f</mi>
       <mo>′</mo>
      </msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <msup>
         <mi>f</mi>
         <mi>′′</mi>
        </msup>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>f</mi>
         <mo>,</mo>
         <mi>f</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mrow>
      <msup>
       <mi>f</mi>
       <mo>′</mo>
      </msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <msup>
         <mi>f</mi>
         <mo>′</mo>
        </msup>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <msup>
           <mi>f</mi>
           <mo>′</mo>
          </msup>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>f</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <cn type="integer">4</cn>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>f</ci>
       <ci>′′′</ci>
      </apply>
      <vector>
       <ci>f</ci>
       <ci>f</ci>
       <ci>f</ci>
      </vector>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">3</cn>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>f</ci>
       <ci>′′</ci>
      </apply>
      <interval closure="open">
       <ci>f</ci>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>f</ci>
         <ci>normal-′</ci>
        </apply>
        <ci>f</ci>
       </apply>
      </interval>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>f</ci>
       <ci>normal-′</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>f</ci>
        <ci>′′</ci>
       </apply>
       <interval closure="open">
        <ci>f</ci>
        <ci>f</ci>
       </interval>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>f</ci>
       <ci>normal-′</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>f</ci>
        <ci>normal-′</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>f</ci>
         <ci>normal-′</ci>
        </apply>
        <ci>f</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{(4)}=f^{\prime\prime\prime}(f,f,f)+3f^{\prime\prime}(f,f^{\prime}(f))+f^{%
\prime}(f^{\prime\prime}(f,f))+f^{\prime}(f^{\prime}(f^{\prime}(f))),
  </annotation>
 </semantics>
</math>

</p>

<p>where the tree structure is crucial.</p>
<h2 id="definition-using-hopf-algebra-of-rooted-trees">Definition using Hopf algebra of rooted trees</h2>

<p>The <a href="Hopf_algebra" title="wikilink">Hopf algebra</a> <strong>H</strong> of rooted trees was defined by  in connection with <a href="Dirk_Kreimer" title="wikilink">Kreimer</a>'s previous work on <a class="uri" href="renormalization" title="wikilink">renormalization</a> in <a href="quantum_field_theory" title="wikilink">quantum field theory</a>. It was later discovered that the Hopf algebra was the dual of a Hopf algebra defined earlier by  in a different context. The characters of <strong>H</strong>, i.e. the homomorphisms of the underlying commutative algebra into <strong>R</strong>, form a group, called the <strong>Butcher group</strong>. It corresponds to the <a href="formal_group" title="wikilink">formal group</a> structure discovered in <a href="numerical_analysis" title="wikilink">numerical analysis</a> by .</p>

<p>The <strong>Hopf algebra of rooted trees</strong> <strong>H</strong> is defined to be the <a href="polynomial_ring" title="wikilink">polynomial ring</a> in the variables <strong>t</strong>, where <strong>t</strong> runs through rooted trees.</p>
<ul>
<li>Its <a class="uri" href="comultiplication" title="wikilink">comultiplication</a> 

<math display="inline" id="Butcher_group:9">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Δ</mi>
   <mo>:</mo>
   <mrow>
    <mi>H</mi>
    <mo>→</mo>
    <mrow>
     <mi>H</mi>
     <mo>⊗</mo>
     <mi>H</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>normal-Δ</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>H</ci>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <ci>H</ci>
      <ci>H</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta:H\rightarrow H\otimes H
  </annotation>
 </semantics>
</math>

 is defined by</li>
</ul>

<p>

<math display="block" id="Butcher_group:10">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi mathvariant="normal">Δ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mi>t</mi>
      <mo>⊗</mo>
      <mi>I</mi>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mi>I</mi>
      <mo>⊗</mo>
      <mi>t</mi>
     </mrow>
     <mo>+</mo>
     <mrow>
      <munder>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mrow>
        <mi>s</mi>
        <mo>⊂</mo>
        <mi>t</mi>
       </mrow>
      </munder>
      <mrow>
       <mi>s</mi>
       <mo>⊗</mo>
       <mrow>
        <mo stretchy="false">[</mo>
        <mrow>
         <mi>t</mi>
         <mo>\</mo>
         <mi>s</mi>
        </mrow>
        <mo stretchy="false">]</mo>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>normal-Δ</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <ci>t</ci>
      <ci>I</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <ci>I</ci>
      <ci>t</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <subset></subset>
        <ci>s</ci>
        <ci>t</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <ci>s</ci>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <apply>
         <ci>normal-\</ci>
         <ci>t</ci>
         <ci>s</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta(t)=t\otimes I+I\otimes t+\sum_{s\subset t}s\otimes[t\backslash s],
  </annotation>
 </semantics>
</math>

</p>

<p>where the sum is over all proper rooted subtrees <strong>s</strong> of <strong>t</strong>; 

<math display="inline" id="Butcher_group:11">
 <semantics>
  <mrow>
   <mo stretchy="false">[</mo>
   <mrow>
    <mi>t</mi>
    <mo>\</mo>
    <mi>s</mi>
   </mrow>
   <mo stretchy="false">]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">delimited-[]</csymbol>
    <apply>
     <ci>normal-\</ci>
     <ci>t</ci>
     <ci>s</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [t\backslash s]
  </annotation>
 </semantics>
</math>

 is the monomial given by the product the variables <strong>t</strong><sub>i</sub> formed by the rooted trees that arise on erasing all the nodes of <strong>s</strong> and connected links from <strong>t</strong>. The number of such trees is denoted by <em>n</em>(<strong>t</strong>\<strong>s</strong>).</p>
<ul>
<li>Its <a class="uri" href="counit" title="wikilink">counit</a> is the homomorphism ε of <strong>H</strong> into <strong>R</strong> sending each variable <strong>t</strong> to zero.</li>
</ul>
<ul>
<li>Its <a href="antipode_(algebra)" title="wikilink">antipode</a> <em>S</em> can be defined recursively by the formula</li>
</ul>

<p>

<math display="block" id="Butcher_group:12">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mo>-</mo>
   <mi>t</mi>
   <mo>-</mo>
   <munder>
    <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
    <mrow>
     <mi>s</mi>
     <mo>⊂</mo>
     <mi>t</mi>
    </mrow>
   </munder>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mo>-</mo>
     <mn>1</mn>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mi>n</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>t</mi>
       <mo>\</mo>
       <mi>s</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </msup>
   <mi>S</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>t</mi>
     <mo>\</mo>
     <mi>s</mi>
     <mo stretchy="false">]</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi>s</mi>
   <mo rspace="7.6pt">,</mo>
   <mi>S</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>∙</mo>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mo>-</mo>
   <mo>∙</mo>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">S</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">t</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <minus></minus>
    <csymbol cd="unknown">t</csymbol>
    <minus></minus>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <sum></sum>
     <apply>
      <subset></subset>
      <ci>s</ci>
      <ci>t</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <minus></minus>
      <cn type="integer">1</cn>
      <ci>normal-)</ci>
     </cerror>
     <apply>
      <times></times>
      <ci>n</ci>
      <apply>
       <ci>normal-\</ci>
       <ci>t</ci>
       <ci>s</ci>
      </apply>
     </apply>
    </apply>
    <csymbol cd="unknown">S</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-[</ci>
      <csymbol cd="unknown">t</csymbol>
      <ci>normal-\</ci>
      <csymbol cd="unknown">s</csymbol>
      <ci>normal-]</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">s</csymbol>
    <ci>normal-,</ci>
    <csymbol cd="unknown">S</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <ci>normal-∙</ci>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <minus></minus>
    <ci>normal-∙</ci>
    <ci>normal-.</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S(t)=-t-\sum_{s\subset t}(-1)^{n(t\backslash s)}S([t\backslash s])s,\,\,\,S(%
\bullet)=-\bullet.
  </annotation>
 </semantics>
</math>

</p>

<p>The <strong>Butcher group</strong> is defined to be the set of algebra homomorphisms φ of <strong>H</strong> into <strong>R</strong> with group structure</p>

<p>

<math display="block" id="Butcher_group:13">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <msub>
       <mi>φ</mi>
       <mn>1</mn>
      </msub>
      <mo>⋆</mo>
      <msub>
       <mi>φ</mi>
       <mn>2</mn>
      </msub>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>φ</mi>
        <mn>1</mn>
       </msub>
       <mo>⊗</mo>
       <msub>
        <mi>φ</mi>
        <mn>2</mn>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi mathvariant="normal">Δ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <ci>normal-⋆</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>φ</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>φ</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <ci>t</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>φ</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>φ</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <ci>normal-Δ</ci>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varphi_{1}\star\varphi_{2}(t)=(\varphi_{1}\otimes\varphi_{2})\Delta(t).
  </annotation>
 </semantics>
</math>

</p>

<p>The inverse in the Butcher group is given by</p>

<p>

<math display="block" id="Butcher_group:14">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>φ</mi>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>φ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>S</mi>
      <mi>t</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>φ</ci>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>t</ci>
    </apply>
    <apply>
     <times></times>
     <ci>φ</ci>
     <apply>
      <times></times>
      <ci>S</ci>
      <ci>t</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varphi^{-1}(t)=\varphi(St)
  </annotation>
 </semantics>
</math>

</p>

<p>and the identity by the counit ε.</p>
<h2 id="butcher-series-and-rungekutta-method">Butcher series and Runge–Kutta method</h2>

<p>The non-linear ordinary differential equation</p>

<p>

<math display="block" id="Butcher_group:15">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mfrac>
      <mrow>
       <mi>d</mi>
       <mi>x</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>s</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mrow>
       <mi>d</mi>
       <mi>s</mi>
      </mrow>
     </mfrac>
     <mo>=</mo>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>x</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>s</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo rspace="7.6pt">,</mo>
    <mrow>
     <mrow>
      <mi>x</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mn>0</mn>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>=</mo>
     <msub>
      <mi>x</mi>
      <mn>0</mn>
     </msub>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <ci>d</ci>
       <ci>x</ci>
       <ci>s</ci>
      </apply>
      <apply>
       <times></times>
       <ci>d</ci>
       <ci>s</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <apply>
       <times></times>
       <ci>x</ci>
       <ci>s</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>x</ci>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">0</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {dx(s)\over ds}=f(x(s)),\,\,\,x(0)=x_{0},
  </annotation>
 </semantics>
</math>

</p>

<p>can be solved approximately by the <a href="Runge-Kutta_method" title="wikilink">Runge-Kutta method</a>. This iterative scheme requires an <em>m</em> x <em>m</em> matrix</p>

<p>

<math display="block" id="Butcher_group:16">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>a</mi>
     <mrow>
      <mi>i</mi>
      <mi>j</mi>
     </mrow>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>A</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>j</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A=(a_{ij})
  </annotation>
 </semantics>
</math>

</p>

<p>and a vector</p>

<p>

<math display="block" id="Butcher_group:17">
 <semantics>
  <mrow>
   <mi>b</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>b</mi>
     <mi>i</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>b</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>b</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b=(b_{i})
  </annotation>
 </semantics>
</math>

</p>

<p>with <em>m</em> components.</p>

<p>The scheme defines vectors <em>x</em><sub><em>n</em></sub> by first finding a solution <em>X</em><sub>1</sub>, ... , <em>X</em><sub><em>m</em></sub> of</p>

<p>

<math display="block" id="Butcher_group:18">
 <semantics>
  <mrow>
   <msub>
    <mi>X</mi>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>x</mi>
     <mrow>
      <mi>n</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo>+</mo>
    <mrow>
     <mi>h</mi>
     <mrow>
      <munderover>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mrow>
        <mi>j</mi>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <mi>m</mi>
      </munderover>
      <mrow>
       <msub>
        <mi>a</mi>
        <mrow>
         <mi>i</mi>
         <mi>j</mi>
        </mrow>
       </msub>
       <mi>f</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>X</mi>
         <mi>j</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <apply>
       <minus></minus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>h</ci>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <ci>j</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>m</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>a</ci>
         <apply>
          <times></times>
          <ci>i</ci>
          <ci>j</ci>
         </apply>
        </apply>
        <ci>f</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>X</ci>
         <ci>j</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{i}=x_{n-1}+h\sum_{j=1}^{m}a_{ij}f(X_{j})
  </annotation>
 </semantics>
</math>

</p>

<p>and then setting</p>

<p>

<math display="block" id="Butcher_group:19">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>x</mi>
     <mi>n</mi>
    </msub>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>x</mi>
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msub>
     <mo>+</mo>
     <mrow>
      <mi>h</mi>
      <mrow>
       <munderover>
        <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
        <mrow>
         <mi>j</mi>
         <mo>=</mo>
         <mn>1</mn>
        </mrow>
        <mi>m</mi>
       </munderover>
       <mrow>
        <msub>
         <mi>b</mi>
         <mi>j</mi>
        </msub>
        <mi>f</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>x</mi>
          <mi>j</mi>
         </msub>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <apply>
       <minus></minus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>h</ci>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <ci>j</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>m</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>b</ci>
         <ci>j</ci>
        </apply>
        <ci>f</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>j</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{n}=x_{n-1}+h\sum_{j=1}^{m}b_{j}f(x_{j}).
  </annotation>
 </semantics>
</math>

  showed that the solution of the corresponding ordinary differential equations</p>

<p>

<math display="block" id="Butcher_group:20">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>X</mi>
      <mi>i</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>s</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>x</mi>
      <mn>0</mn>
     </msub>
     <mo>+</mo>
     <mrow>
      <mi>s</mi>
      <mrow>
       <munderover>
        <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
        <mrow>
         <mi>j</mi>
         <mo>=</mo>
         <mn>1</mn>
        </mrow>
        <mi>m</mi>
       </munderover>
       <mrow>
        <msub>
         <mi>a</mi>
         <mrow>
          <mi>i</mi>
          <mi>j</mi>
         </mrow>
        </msub>
        <mi>f</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <msub>
           <mi>X</mi>
           <mi>j</mi>
          </msub>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>s</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo rspace="7.6pt">,</mo>
   <mrow>
    <mrow>
     <mi>x</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>s</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>x</mi>
      <mn>0</mn>
     </msub>
     <mo>+</mo>
     <mrow>
      <mi>s</mi>
      <mrow>
       <munderover>
        <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
        <mrow>
         <mi>j</mi>
         <mo>=</mo>
         <mn>1</mn>
        </mrow>
        <mi>m</mi>
       </munderover>
       <mrow>
        <msub>
         <mi>b</mi>
         <mi>j</mi>
        </msub>
        <mi>f</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <msub>
           <mi>X</mi>
           <mi>j</mi>
          </msub>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>s</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>X</ci>
       <ci>i</ci>
      </apply>
      <ci>s</ci>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">0</cn>
      </apply>
      <apply>
       <times></times>
       <ci>s</ci>
       <apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <sum></sum>
          <apply>
           <eq></eq>
           <ci>j</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
         <ci>m</ci>
        </apply>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>a</ci>
          <apply>
           <times></times>
           <ci>i</ci>
           <ci>j</ci>
          </apply>
         </apply>
         <ci>f</ci>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>X</ci>
           <ci>j</ci>
          </apply>
          <ci>s</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>x</ci>
      <ci>s</ci>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">0</cn>
      </apply>
      <apply>
       <times></times>
       <ci>s</ci>
       <apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <sum></sum>
          <apply>
           <eq></eq>
           <ci>j</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
         <ci>m</ci>
        </apply>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>b</ci>
          <ci>j</ci>
         </apply>
         <ci>f</ci>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>X</ci>
           <ci>j</ci>
          </apply>
          <ci>s</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{i}(s)=x_{0}+s\sum_{j=1}^{m}a_{ij}f(X_{j}(s)),\,\,\,x(s)=x_{0}+s\sum_{j=1}^{%
m}b_{j}f(X_{j}(s))
  </annotation>
 </semantics>
</math>

</p>

<p>has the power series expansion</p>

<p>

<math display="block" id="Butcher_group:21">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <msub>
       <mi>X</mi>
       <mi>i</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>s</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>=</mo>
     <mrow>
      <msub>
       <mi>x</mi>
       <mn>0</mn>
      </msub>
      <mo>+</mo>
      <mrow>
       <munder>
        <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
        <mi>t</mi>
       </munder>
       <mrow>
        <mfrac>
         <msup>
          <mi>s</mi>
          <mrow>
           <mo stretchy="false">|</mo>
           <mi>t</mi>
           <mo stretchy="false">|</mo>
          </mrow>
         </msup>
         <mrow>
          <mrow>
           <mo stretchy="false">|</mo>
           <mi>t</mi>
           <mo stretchy="false">|</mo>
          </mrow>
          <mo lspace="0pt" rspace="3.5pt">!</mo>
         </mrow>
        </mfrac>
        <mi>α</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>t</mi>
         <mo stretchy="false">)</mo>
        </mrow>
        <mrow>
         <mi>t</mi>
         <mo lspace="0pt" rspace="3.5pt">!</mo>
        </mrow>
        <mrow>
         <munderover>
          <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
          <mrow>
           <mi>j</mi>
           <mo>=</mo>
           <mn>1</mn>
          </mrow>
          <mi>m</mi>
         </munderover>
         <mrow>
          <msub>
           <mi>a</mi>
           <mrow>
            <mi>i</mi>
            <mi>j</mi>
           </mrow>
          </msub>
          <msub>
           <mi>φ</mi>
           <mi>j</mi>
          </msub>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>t</mi>
           <mo stretchy="false">)</mo>
          </mrow>
          <msub>
           <mi>δ</mi>
           <mi>t</mi>
          </msub>
          <mrow>
           <mo stretchy="false">(</mo>
           <mn>0</mn>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
        </mrow>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
    <mo rspace="9.3pt">,</mo>
    <mrow>
     <mrow>
      <mi>x</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>s</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>=</mo>
     <mrow>
      <msub>
       <mi>x</mi>
       <mn>0</mn>
      </msub>
      <mo>+</mo>
      <mrow>
       <munder>
        <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
        <mi>t</mi>
       </munder>
       <mrow>
        <mfrac>
         <msup>
          <mi>s</mi>
          <mrow>
           <mo stretchy="false">|</mo>
           <mi>t</mi>
           <mo stretchy="false">|</mo>
          </mrow>
         </msup>
         <mrow>
          <mrow>
           <mo stretchy="false">|</mo>
           <mi>t</mi>
           <mo stretchy="false">|</mo>
          </mrow>
          <mo lspace="0pt" rspace="3.5pt">!</mo>
         </mrow>
        </mfrac>
        <mi>α</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>t</mi>
         <mo stretchy="false">)</mo>
        </mrow>
        <mrow>
         <mi>t</mi>
         <mo lspace="0pt" rspace="3.5pt">!</mo>
        </mrow>
        <mi>φ</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>t</mi>
         <mo stretchy="false">)</mo>
        </mrow>
        <msub>
         <mi>δ</mi>
         <mi>t</mi>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <mn>0</mn>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>X</ci>
       <ci>i</ci>
      </apply>
      <ci>s</ci>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">0</cn>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <ci>t</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <divide></divide>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>s</ci>
          <apply>
           <abs></abs>
           <ci>t</ci>
          </apply>
         </apply>
         <apply>
          <factorial></factorial>
          <apply>
           <abs></abs>
           <ci>t</ci>
          </apply>
         </apply>
        </apply>
        <ci>α</ci>
        <ci>t</ci>
        <apply>
         <factorial></factorial>
         <ci>t</ci>
        </apply>
        <apply>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <sum></sum>
           <apply>
            <eq></eq>
            <ci>j</ci>
            <cn type="integer">1</cn>
           </apply>
          </apply>
          <ci>m</ci>
         </apply>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>a</ci>
           <apply>
            <times></times>
            <ci>i</ci>
            <ci>j</ci>
           </apply>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>φ</ci>
           <ci>j</ci>
          </apply>
          <ci>t</ci>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>δ</ci>
           <ci>t</ci>
          </apply>
          <cn type="integer">0</cn>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>x</ci>
      <ci>s</ci>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">0</cn>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <ci>t</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <divide></divide>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>s</ci>
          <apply>
           <abs></abs>
           <ci>t</ci>
          </apply>
         </apply>
         <apply>
          <factorial></factorial>
          <apply>
           <abs></abs>
           <ci>t</ci>
          </apply>
         </apply>
        </apply>
        <ci>α</ci>
        <ci>t</ci>
        <apply>
         <factorial></factorial>
         <ci>t</ci>
        </apply>
        <ci>φ</ci>
        <ci>t</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>δ</ci>
         <ci>t</ci>
        </apply>
        <cn type="integer">0</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{i}(s)=x_{0}+\sum_{t}{s^{|t|}\over|t|!}\alpha(t)t!\sum_{j=1}^{m}a_{ij}%
\varphi_{j}(t)\delta_{t}(0),\,\,\,\,x(s)=x_{0}+\sum_{t}{s^{|t|}\over|t|!}%
\alpha(t)t!\varphi(t)\delta_{t}(0),
  </annotation>
 </semantics>
</math>

</p>

<p>where φ<sub><em>j</em></sub> and φ are determined recursively by</p>

<p>

<math display="block" id="Butcher_group:22">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>φ</mi>
     <mi>j</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mo>∙</mo>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mpadded width="+5.1pt">
     <mn>1.</mn>
    </mpadded>
    <msub>
     <mi>φ</mi>
     <mi>i</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo stretchy="false">[</mo>
      <msub>
       <mi>t</mi>
       <mn>1</mn>
      </msub>
      <mo>,</mo>
      <mi mathvariant="normal">⋯</mi>
      <mo>,</mo>
      <msub>
       <mi>t</mi>
       <mi>k</mi>
      </msub>
      <mo stretchy="false">]</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <msub>
       <mi>j</mi>
       <mn>1</mn>
      </msub>
      <mo>,</mo>
      <mi mathvariant="normal">…</mi>
      <mo>,</mo>
      <msub>
       <mi>j</mi>
       <mi>k</mi>
      </msub>
     </mrow>
    </munder>
    <mrow>
     <msub>
      <mi>a</mi>
      <mrow>
       <mi>i</mi>
       <msub>
        <mi>j</mi>
        <mn>1</mn>
       </msub>
      </mrow>
     </msub>
     <mi mathvariant="normal">…</mi>
     <msub>
      <mi>a</mi>
      <mrow>
       <mi>i</mi>
       <msub>
        <mi>j</mi>
        <mi>k</mi>
       </msub>
      </mrow>
     </msub>
     <msub>
      <mi>φ</mi>
      <msub>
       <mi>j</mi>
       <mn>1</mn>
      </msub>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>t</mi>
       <mn>1</mn>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi mathvariant="normal">…</mi>
     <msub>
      <mi>φ</mi>
      <msub>
       <mi>j</mi>
       <mi>k</mi>
      </msub>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>t</mi>
       <mi>k</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>φ</ci>
       <ci>j</ci>
      </apply>
      <ci>normal-∙</ci>
     </apply>
     <apply>
      <times></times>
      <cn type="float">1.</cn>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>φ</ci>
       <ci>i</ci>
      </apply>
      <list>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>t</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>normal-⋯</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>t</ci>
        <ci>k</ci>
       </apply>
      </list>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <list>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>j</ci>
         <cn type="integer">1</cn>
        </apply>
        <ci>normal-…</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>j</ci>
         <ci>k</ci>
        </apply>
       </list>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <apply>
         <times></times>
         <ci>i</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>j</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
       </apply>
       <ci>normal-…</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <apply>
         <times></times>
         <ci>i</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>j</ci>
          <ci>k</ci>
         </apply>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>φ</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>j</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>t</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>normal-…</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>φ</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>j</ci>
         <ci>k</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>t</ci>
        <ci>k</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varphi_{j}(\bullet)=1.\,\,\,\varphi_{i}([t_{1},\cdots,t_{k}])=\sum_{j_{1},%
\dots,j_{k}}a_{ij_{1}}\dots a_{ij_{k}}\varphi_{j_{1}}(t_{1})\dots\varphi_{j_{k%
}}(t_{k})
  </annotation>
 </semantics>
</math>

</p>

<p>and</p>

<p>

<math display="block" id="Butcher_group:23">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>φ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>j</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>m</mi>
     </munderover>
     <mrow>
      <msub>
       <mi>b</mi>
       <mi>j</mi>
      </msub>
      <msub>
       <mi>φ</mi>
       <mi>j</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>φ</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>j</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>m</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <ci>j</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>φ</ci>
       <ci>j</ci>
      </apply>
      <ci>t</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varphi(t)=\sum_{j=1}^{m}b_{j}\varphi_{j}(t).
  </annotation>
 </semantics>
</math>

</p>

<p>The power series above are called <strong>B-series</strong> or <strong>Butcher series</strong>.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a><a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> The corresponding assignment φ is an element of the Butcher group. The homomorphism corresponding to the actual flow has</p>

<p>

<math display="block" id="Butcher_group:24">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi mathvariant="normal">Φ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mfrac>
     <mn>1</mn>
     <mrow>
      <mi>t</mi>
      <mo lspace="0pt" rspace="3.5pt">!</mo>
     </mrow>
    </mfrac>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>normal-Φ</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <apply>
      <factorial></factorial>
      <ci>t</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Phi(t)={1\over t!}.
  </annotation>
 </semantics>
</math>

</p>

<p>Butcher showed that the Runge-Kutta method gives an <em>n</em>th order approximation of the actual flow provided that φ and Φ agree on all trees with <em>n</em> nodes or less. Moreover  showed that the homomorphisms defined by the Runge-Kutta method form a dense subgroup of the Butcher group: in fact he showed that, given a homomorphism φ', there is a Runge-Kutta homomorphism φ agreeing with φ' to order <em>n</em>; and that if given homomorphims φ and φ' corresponding to Runge-Kutta data (<em>A</em>, <em>b</em>) and (''A' '', ''b' ''), the product homomorphism 

<math display="inline" id="Butcher_group:25">
 <semantics>
  <mrow>
   <mi>φ</mi>
   <mo>⋆</mo>
   <msup>
    <mi>φ</mi>
    <mo>′</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-⋆</ci>
    <ci>φ</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>φ</ci>
     <ci>normal-′</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varphi\star\varphi^{\prime}
  </annotation>
 </semantics>
</math>


 corresponds to the data</p>

<p>

<math display="block" id="Butcher_group:26">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>(</mo>
     <mtable displaystyle="true">
      <mtr>
       <mtd columnalign="center">
        <mi>A</mi>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <msup>
         <mi>A</mi>
         <mo>′</mo>
        </msup>
       </mtd>
      </mtr>
     </mtable>
     <mo>)</mo>
    </mrow>
    <mo rspace="5.9pt">,</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>b</mi>
     <mo>,</mo>
     <msup>
      <mi>b</mi>
      <mo>′</mo>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <matrix>
     <matrixrow>
      <ci>A</ci>
      <cn type="integer">0</cn>
     </matrixrow>
     <matrixrow>
      <cn type="integer">0</cn>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>A</ci>
       <ci>normal-′</ci>
      </apply>
     </matrixrow>
    </matrix>
    <interval closure="open">
     <ci>b</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>b</ci>
      <ci>normal-′</ci>
     </apply>
    </interval>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{pmatrix}A&0\\
0&A^{\prime}\\
\end{pmatrix},\,\,(b,b^{\prime}).
  </annotation>
 </semantics>
</math>

  proved that the Butcher group acts naturally on the functions <em>f</em>. Indeed setting</p>

<p>

<math display="block" id="Butcher_group:27">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>φ</mi>
     <mo>∘</mo>
     <mi>f</mi>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mn>1</mn>
     <mo>+</mo>
     <mrow>
      <munder>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mi>t</mi>
      </munder>
      <mrow>
       <mfrac>
        <msup>
         <mi>s</mi>
         <mrow>
          <mo stretchy="false">|</mo>
          <mi>t</mi>
          <mo stretchy="false">|</mo>
         </mrow>
        </msup>
        <mrow>
         <mrow>
          <mo stretchy="false">|</mo>
          <mi>t</mi>
          <mo stretchy="false">|</mo>
         </mrow>
         <mo lspace="0pt" rspace="3.5pt">!</mo>
        </mrow>
       </mfrac>
       <mi>α</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>t</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <mrow>
        <mi>t</mi>
        <mo lspace="0pt" rspace="3.5pt">!</mo>
       </mrow>
       <mi>φ</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>t</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <msub>
        <mi>δ</mi>
        <mi>t</mi>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mn>0</mn>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <compose></compose>
     <ci>φ</ci>
     <ci>f</ci>
    </apply>
    <apply>
     <plus></plus>
     <cn type="integer">1</cn>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <ci>t</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>s</ci>
         <apply>
          <abs></abs>
          <ci>t</ci>
         </apply>
        </apply>
        <apply>
         <factorial></factorial>
         <apply>
          <abs></abs>
          <ci>t</ci>
         </apply>
        </apply>
       </apply>
       <ci>α</ci>
       <ci>t</ci>
       <apply>
        <factorial></factorial>
        <ci>t</ci>
       </apply>
       <ci>φ</ci>
       <ci>t</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>δ</ci>
        <ci>t</ci>
       </apply>
       <cn type="integer">0</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varphi\circ f=1+\sum_{t}{s^{|t|}\over|t|!}\alpha(t)t!\varphi(t)\delta_{t}(0),
  </annotation>
 </semantics>
</math>

</p>

<p>they proved that</p>

<p>

<math display="block" id="Butcher_group:28">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>φ</mi>
      <mn>1</mn>
     </msub>
     <mo>∘</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>φ</mi>
        <mn>2</mn>
       </msub>
       <mo>∘</mo>
       <mi>f</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>φ</mi>
        <mn>1</mn>
       </msub>
       <mo>⋆</mo>
       <msub>
        <mi>φ</mi>
        <mn>2</mn>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>∘</mo>
     <mi>f</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <compose></compose>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>φ</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <compose></compose>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>φ</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>f</ci>
     </apply>
    </apply>
    <apply>
     <compose></compose>
     <apply>
      <ci>normal-⋆</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>φ</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>φ</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <ci>f</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varphi_{1}\circ(\varphi_{2}\circ f)=(\varphi_{1}\star\varphi_{2})\circ f.
  </annotation>
 </semantics>
</math>

</p>
<h2 id="lie-algebra">Lie algebra</h2>

<p>showed that associated with the Butcher group <strong>G</strong> is an infinite-dimensional Lie algebra. The existence of this Lie algebra is predicted by a <a href="Milnor–Moore_theorem" title="wikilink">theorem</a> of : the commutativity and natural grading on <strong>H</strong> implies that the dual <strong>H</strong>* can be identified with the <a href="universal_enveloping_algebra" title="wikilink">universal enveloping algebra</a> of a Lie algebra 

<math display="inline" id="Butcher_group:29">
 <semantics>
  <mi>𝔤</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝔤</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathfrak{g}
  </annotation>
 </semantics>
</math>

. Connes and Kreimer explicitly identify 

<math display="inline" id="Butcher_group:30">
 <semantics>
  <mi>𝔤</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝔤</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathfrak{g}
  </annotation>
 </semantics>
</math>


 with a space of <a href="derivation_(abstract_algebra)" title="wikilink">derivations</a> θ of <strong>H</strong> into <strong>R</strong>, i.e. linear maps such that</p>

<p>

<math display="block" id="Butcher_group:31">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>θ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>a</mi>
       <mi>b</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mi>ε</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>a</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>θ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>b</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mi>θ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>a</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>ε</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>b</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>θ</ci>
     <apply>
      <times></times>
      <ci>a</ci>
      <ci>b</ci>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>ε</ci>
      <ci>a</ci>
      <ci>θ</ci>
      <ci>b</ci>
     </apply>
     <apply>
      <times></times>
      <ci>θ</ci>
      <ci>a</ci>
      <ci>ε</ci>
      <ci>b</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta(ab)=\varepsilon(a)\theta(b)+\theta(a)\varepsilon(b),
  </annotation>
 </semantics>
</math>

</p>

<p>the formal tangent space of <strong>G</strong> at the identity ε. This forms a Lie algebra with Lie bracket</p>

<p>

<math display="block" id="Butcher_group:32">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mo stretchy="false">[</mo>
      <msub>
       <mi>θ</mi>
       <mn>1</mn>
      </msub>
      <mo>,</mo>
      <msub>
       <mi>θ</mi>
       <mn>2</mn>
      </msub>
      <mo stretchy="false">]</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <msub>
         <mi>θ</mi>
         <mn>1</mn>
        </msub>
        <mo>⊗</mo>
        <msub>
         <mi>θ</mi>
         <mn>2</mn>
        </msub>
       </mrow>
       <mo>-</mo>
       <mrow>
        <msub>
         <mi>θ</mi>
         <mn>2</mn>
        </msub>
        <mo>⊗</mo>
        <msub>
         <mi>θ</mi>
         <mn>1</mn>
        </msub>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi mathvariant="normal">Δ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <interval closure="closed">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>θ</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>θ</ci>
       <cn type="integer">2</cn>
      </apply>
     </interval>
     <ci>t</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>θ</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>θ</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>θ</ci>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>θ</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
     <ci>normal-Δ</ci>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [\theta_{1},\theta_{2}](t)=(\theta_{1}\otimes\theta_{2}-\theta_{2}\otimes%
\theta_{1})\Delta(t).
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Butcher_group:33">
 <semantics>
  <mi>𝔤</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝔤</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathfrak{g}
  </annotation>
 </semantics>
</math>

 is generated by the derivations θ<sub><strong>t</strong></sub> defined by</p>

<p>

<math display="block" id="Butcher_group:34">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>θ</mi>
      <mi>t</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <msup>
       <mi>t</mi>
       <mo>′</mo>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <msub>
     <mi>δ</mi>
     <mrow>
      <mi>t</mi>
      <msup>
       <mi>t</mi>
       <mo>′</mo>
      </msup>
     </mrow>
    </msub>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>θ</ci>
      <ci>t</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>t</ci>
      <ci>normal-′</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>δ</ci>
     <apply>
      <times></times>
      <ci>t</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>t</ci>
       <ci>normal-′</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta_{t}(t^{\prime})=\delta_{tt^{\prime}},
  </annotation>
 </semantics>
</math>

</p>

<p>for each rooted tree <strong>t</strong>.</p>
<h2 id="renormalization">Renormalization</h2>

<p>provided a general context for using <a href="Hopf_algebra" title="wikilink">Hopf algebraic</a> methods to give a simple mathematical formulation of <a class="uri" href="renormalization" title="wikilink">renormalization</a> in <a href="quantum_field_theory" title="wikilink">quantum field theory</a>. Renormalization was interpreted as <a href="Riemann–Hilbert_problem" title="wikilink">Birkhoff factorization</a> of loops in the character group of the associated Hopf algebra. The models considered by  had Hopf algebra <strong>H</strong> and character group <strong>G</strong>, the Butcher group.  has given an account of this renormalization process in terms of Runge-Kutta data.</p>

<p>In this simplified setting, a <em>renormalizable model</em> has two pieces of input data:<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>
<ul>
<li>a set of <em>Feynman rules</em> given by an algebra homomorphism Φ of <strong>H</strong> into the algebra <em>V</em> of <a href="Laurent_series" title="wikilink">Laurent series</a> in <em>z</em> with poles of finite order;</li>
<li>a <em>renormalization scheme</em> given by a linear operator <em>R</em> on <em>V</em> such that <em>R</em> satisfies the <a href="Rota-Baxter_algebra" title="wikilink">Rota-Baxter identity</a></li>
</ul>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Butcher_group:35">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>R</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>f</mi>
       <mi>g</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>R</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>f</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>R</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>g</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>R</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>f</mi>
       <mi>R</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>g</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>R</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>R</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>f</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <mi>g</mi>
      </mrow>
      <mo rspace="4.2pt" stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>R</ci>
      <apply>
       <times></times>
       <ci>f</ci>
       <ci>g</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>R</ci>
      <ci>f</ci>
      <ci>R</ci>
      <ci>g</ci>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>R</ci>
      <apply>
       <times></times>
       <ci>f</ci>
       <ci>R</ci>
       <ci>g</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>R</ci>
      <apply>
       <times></times>
       <ci>R</ci>
       <ci>f</ci>
       <ci>g</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R(fg)+R(f)R(g)=R(fR(g))+R(R(f)g)\,
  </annotation>
 </semantics>
</math>



</dd>
</dl>
</dd>
<dd>and the image of <em>R</em> – <em>id</em> lies in the algebra <em>V</em><sub>+</sub> of <a href="power_series" title="wikilink">power series</a> in <em>z</em>.
</dd>
</dl>

<p>Note that <em>R</em> satisfies the Rota-Baxter identity if and only if <em>id</em> – <em>R</em> does. An important example is the <em><a href="minimal_subtraction_scheme" title="wikilink">minimal subtraction scheme</a></em></p>

<p>

<math display="block" id="Butcher_group:36">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>R</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <munder>
        <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
        <mi>n</mi>
       </munder>
       <mrow>
        <msub>
         <mi>a</mi>
         <mi>n</mi>
        </msub>
        <msup>
         <mi>z</mi>
         <mi>n</mi>
        </msup>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>n</mi>
       <mo><</mo>
       <mn>0</mn>
      </mrow>
     </munder>
     <mrow>
      <msub>
       <mi>a</mi>
       <mi>n</mi>
      </msub>
      <msup>
       <mi>z</mi>
       <mi>n</mi>
      </msup>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>R</ci>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <ci>n</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <ci>n</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>z</ci>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <lt></lt>
       <ci>n</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>z</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle R(\sum_{n}a_{n}z^{n})=\sum_{n<0}a_{n}z^{n}.
  </annotation>
 </semantics>
</math>

</p>

<p>In addition there is a projection <em>P</em> of <strong>H</strong> onto the <a href="augmentation_ideal" title="wikilink">augmentation ideal</a> ker ε given by</p>

<p>

<math display="block" id="Butcher_group:37">
 <semantics>
  <mrow>
   <mrow>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>x</mi>
    <mo>-</mo>
    <mrow>
     <mi>ε</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mn>1.</mn>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>P</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <minus></minus>
     <ci>x</ci>
     <apply>
      <times></times>
      <ci>ε</ci>
      <ci>x</ci>
      <cn type="float">1.</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle P(x)=x-\varepsilon(x)1.
  </annotation>
 </semantics>
</math>

</p>

<p>To define the renormalized Feynman rules, note that the antipode <em>S</em> satisfies</p>

<p>

<math display="block" id="Butcher_group:38">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>m</mi>
     <mo>∘</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>S</mi>
       <mo>⊗</mo>
       <mi>id</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mi mathvariant="normal">Δ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>ε</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <compose></compose>
      <ci>m</ci>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <ci>S</ci>
       <ci>id</ci>
      </apply>
     </apply>
     <ci>normal-Δ</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <ci>ε</ci>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m\circ(S\otimes{\rm id})\Delta(x)=\varepsilon(x)1
  </annotation>
 </semantics>
</math>

</p>

<p>so that</p>

<p>

<math display="block" id="Butcher_group:39">
 <semantics>
  <mrow>
   <mrow>
    <mi>S</mi>
    <mo>=</mo>
    <mrow>
     <mo>-</mo>
     <mrow>
      <mrow>
       <mi>m</mi>
       <mo>∘</mo>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>S</mi>
         <mo>⊗</mo>
         <mi>P</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mi mathvariant="normal">Δ</mi>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>S</ci>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <apply>
       <compose></compose>
       <ci>m</ci>
       <apply>
        <csymbol cd="latexml">tensor-product</csymbol>
        <ci>S</ci>
        <ci>P</ci>
       </apply>
      </apply>
      <ci>normal-Δ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S=-m\circ(S\otimes P)\Delta,
  </annotation>
 </semantics>
</math>

</p>

<p>The <em>renormalized Feynman rules</em> are given by a homomorphism 

<math display="inline" id="Butcher_group:40">
 <semantics>
  <msubsup>
   <mi mathvariant="normal">Φ</mi>
   <mi>S</mi>
   <mi>R</mi>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-Φ</ci>
     <ci>S</ci>
    </apply>
    <ci>R</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Phi_{S}^{R}
  </annotation>
 </semantics>
</math>


 of <strong>H</strong> into <em>V</em> obtained by twisting the homomorphism Φ • S. The homomorphism 

<math display="inline" id="Butcher_group:41">
 <semantics>
  <msubsup>
   <mi mathvariant="normal">Φ</mi>
   <mi>S</mi>
   <mi>R</mi>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-Φ</ci>
     <ci>S</ci>
    </apply>
    <ci>R</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Phi_{S}^{R}
  </annotation>
 </semantics>
</math>

 is uniquely specified by</p>

<p>

<math display="block" id="Butcher_group:42">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mi mathvariant="normal">Φ</mi>
     <mi>S</mi>
     <mi>R</mi>
    </msubsup>
    <mo>=</mo>
    <mrow>
     <mo>-</mo>
     <mrow>
      <mi>m</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mrow>
         <mi>S</mi>
         <mo>⊗</mo>
         <msubsup>
          <mi mathvariant="normal">Φ</mi>
          <mi>S</mi>
          <mi>R</mi>
         </msubsup>
        </mrow>
        <mo>∘</mo>
        <mi>P</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi mathvariant="normal">Δ</mi>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-Φ</ci>
      <ci>S</ci>
     </apply>
     <ci>R</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>m</ci>
      <apply>
       <compose></compose>
       <apply>
        <csymbol cd="latexml">tensor-product</csymbol>
        <ci>S</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>normal-Φ</ci>
          <ci>S</ci>
         </apply>
         <ci>R</ci>
        </apply>
       </apply>
       <ci>P</ci>
      </apply>
      <ci>normal-Δ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Phi_{S}^{R}=-m(S\otimes\Phi_{S}^{R}\circ P)\Delta.
  </annotation>
 </semantics>
</math>

</p>

<p>Because of the precise form of Δ, this gives a recursive formula for 

<math display="inline" id="Butcher_group:43">
 <semantics>
  <msubsup>
   <mi mathvariant="normal">Φ</mi>
   <mi>S</mi>
   <mi>R</mi>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-Φ</ci>
     <ci>S</ci>
    </apply>
    <ci>R</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Phi_{S}^{R}
  </annotation>
 </semantics>
</math>

.</p>

<p>For the minimal subtraction scheme, this process can be interpreted in terms of Birkhoff factorization in the complex Butcher group. Φ can be regarded as a map γ of the unit circle into the complexification <strong>G</strong><sub><strong>C</strong></sub> of <strong>G</strong> (maps into <strong>C</strong> instead of <strong>R</strong>). As such it has a Birkhoff factorization</p>

<p>

<math display="block" id="Butcher_group:44">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>γ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>z</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>γ</mi>
      <mo>-</mo>
     </msub>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>z</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msup>
     <msub>
      <mi>γ</mi>
      <mo>+</mo>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>z</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>γ</ci>
     <ci>z</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>γ</ci>
      <minus></minus>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>z</ci>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>γ</ci>
      <plus></plus>
     </apply>
     <ci>z</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle\gamma(z)=\gamma_{-}(z)^{-1}\gamma_{+}(z),
  </annotation>
 </semantics>
</math>

</p>

<p>where γ<sub>+</sub> is <a href="Holomorphic_function" title="wikilink">holomorphic</a> on the interior of the closed unit disk and γ<sub>–</sub> is holomorphic on its complement in the <a href="Riemann_sphere" title="wikilink">Riemann sphere</a> <strong>C</strong> 

<math display="inline" id="Butcher_group:45">
 <semantics>
  <mrow>
   <mo>∪</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mi mathvariant="normal">∞</mi>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <union></union>
    <set>
     <infinity></infinity>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \cup\{\infty\}
  </annotation>
 </semantics>
</math>


 with γ<sub>–</sub>(∞) = 1. The loop γ<sub>+</sub> corresponds to the renormalized homomorphism. The evaluation at <em>z</em> = 0 of γ<sub>+</sub> or the renormalized homomorphism gives the <em>dimensionally regularized</em> values for each rooted tree.</p>

<p>In example, the Feynman rules depend on additional parameter μ, a "unit of mass".  showed that</p>

<p>

<math display="block" id="Butcher_group:46">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mo>∂</mo>
      <mi>μ</mi>
     </msub>
     <msub>
      <mi>γ</mi>
      <mrow>
       <mi>μ</mi>
       <mo>-</mo>
      </mrow>
     </msub>
    </mrow>
    <mo>=</mo>
    <mn>0</mn>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <partialdiff></partialdiff>
      <ci>μ</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>γ</ci>
      <apply>
       <csymbol cd="latexml">limit-from</csymbol>
       <ci>μ</ci>
       <minus></minus>
      </apply>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \partial_{\mu}\gamma_{\mu-}=0,
  </annotation>
 </semantics>
</math>

</p>

<p>so that γ<sub>μ–</sub> is independent of μ.</p>

<p>The complex Butcher group comes with a natural one-parameter group λ<sub><em>w</em></sub> of automorphisms, dual to that on <strong>H</strong></p>

<p>

<math display="block" id="Butcher_group:47">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>λ</mi>
     <mi>w</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>w</mi>
     <mrow>
      <mo stretchy="false">|</mo>
      <mi>t</mi>
      <mo stretchy="false">|</mo>
     </mrow>
    </msup>
    <mi>t</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>λ</ci>
      <ci>w</ci>
     </apply>
     <ci>t</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>w</ci>
      <apply>
       <abs></abs>
       <ci>t</ci>
      </apply>
     </apply>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda_{w}(t)=w^{|t|}t
  </annotation>
 </semantics>
</math>

</p>

<p>for <em>w</em> ≠ 0 in <strong>C</strong>.</p>

<p>The loops γ<sub>μ</sub> and λ<sub><em>w</em></sub> · γ<sub>μ</sub> have the same negative part and, for <em>t</em> real,</p>

<p>

<math display="block" id="Butcher_group:48">
 <semantics>
  <mrow>
   <msub>
    <mi>F</mi>
    <mi>t</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <munder>
     <mo movablelimits="false">lim</mo>
     <mrow>
      <mi>z</mi>
      <mo>=</mo>
      <mn>0</mn>
     </mrow>
    </munder>
    <mrow>
     <msub>
      <mi>γ</mi>
      <mo>-</mo>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>z</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <msub>
      <mi>λ</mi>
      <mrow>
       <mi>t</mi>
       <mi>z</mi>
      </mrow>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>γ</mi>
        <mo>-</mo>
       </msub>
       <msup>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>z</mi>
         <mo stretchy="false">)</mo>
        </mrow>
        <mrow>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
       </msup>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>F</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <limit></limit>
      <apply>
       <eq></eq>
       <ci>z</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>γ</ci>
       <minus></minus>
      </apply>
      <ci>z</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>λ</ci>
       <apply>
        <times></times>
        <ci>t</ci>
        <ci>z</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>γ</ci>
        <minus></minus>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>z</ci>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle F_{t}=\lim_{z=0}\gamma_{-}(z)\lambda_{tz}(\gamma_{-}(z)^{-1})
  </annotation>
 </semantics>
</math>

</p>

<p>defines a one-parameter subgroup of the complex Butcher group <strong>G</strong><sub><strong>C</strong></sub> called the <a href="renormalization_group" title="wikilink"> renormalization group flow</a> (RG).</p>

<p>Its infinitesimal generator β is an element of the Lie algebra of <strong>G</strong><sub><strong>C</strong></sub> and is defined by</p>

<p>

<math display="block" id="Butcher_group:49">
 <semantics>
  <mrow>
   <mrow>
    <mi>β</mi>
    <mo>=</mo>
    <msub>
     <mrow>
      <mrow>
       <msub>
        <mo>∂</mo>
        <mi>t</mi>
       </msub>
       <msub>
        <mi>F</mi>
        <mi>t</mi>
       </msub>
      </mrow>
      <mo fence="true">|</mo>
     </mrow>
     <mrow>
      <mi>t</mi>
      <mo>=</mo>
      <mn>0</mn>
     </mrow>
    </msub>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>β</ci>
    <apply>
     <csymbol cd="latexml">evaluated-at</csymbol>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <partialdiff></partialdiff>
       <ci>t</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>F</ci>
       <ci>t</ci>
      </apply>
     </apply>
     <apply>
      <eq></eq>
      <ci>t</ci>
      <cn type="integer">0</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta=\partial_{t}F_{t}|_{t=0}.
  </annotation>
 </semantics>
</math>

</p>

<p>It is called the <a class="uri" href="beta-function" title="wikilink">beta-function</a> of the model.</p>

<p>In any given model, there is usually a finite-dimensional space of complex coupling constants. The complex Butcher group acts by diffeomorphims on this space. In particular the renormalization group defines a flow on the space of coupling constants, with the beta function giving the corresponding vector field.</p>

<p>More general models in quantum field theory require rooted trees to be replaced by <a href="Feynman_diagram" title="wikilink">Feynman diagrams</a> with vertices decorated by symbols from a finite index set. Connes and Kreimer have also defined Hopf algebras in this setting and have shown how they can be used to systematize standard computations in renormalization theory.</p>
<h2 id="example">Example</h2>

<p>has given a "toy model" involving <a href="dimensional_regularization" title="wikilink">dimensional regularization</a> for <strong>H</strong> and the algebra <em>V</em>. If <em>c</em> is a positive integer and <em>q</em><sub>μ</sub> = <em>q</em> / μ is a dimensionless constant, Feynman rules can be defined recursively by</p>

<p>

<math display="block" id="Butcher_group:50">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi mathvariant="normal">Φ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mo stretchy="false">[</mo>
       <msub>
        <mi>t</mi>
        <mn>1</mn>
       </msub>
       <mo>,</mo>
       <mi mathvariant="normal">…</mi>
       <mo>,</mo>
       <msub>
        <mi>t</mi>
        <mi>n</mi>
       </msub>
       <mo stretchy="false">]</mo>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo largeop="true" symmetric="true">∫</mo>
     <mrow>
      <mfrac>
       <mrow>
        <mi mathvariant="normal">Φ</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>t</mi>
          <mn>1</mn>
         </msub>
         <mo stretchy="false">)</mo>
        </mrow>
        <mi mathvariant="normal">⋯</mi>
        <mi mathvariant="normal">Φ</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>t</mi>
          <mi>n</mi>
         </msub>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mrow>
        <msup>
         <mrow>
          <mo stretchy="false">|</mo>
          <mi>y</mi>
          <mo stretchy="false">|</mo>
         </mrow>
         <mn>2</mn>
        </msup>
        <mo>+</mo>
        <msubsup>
         <mi>q</mi>
         <mi>μ</mi>
         <mn>2</mn>
        </msubsup>
       </mrow>
      </mfrac>
      <mpadded width="+1.7pt">
       <msup>
        <mrow>
         <mo stretchy="false">(</mo>
         <msup>
          <mrow>
           <mo stretchy="false">|</mo>
           <mi>y</mi>
           <mo stretchy="false">|</mo>
          </mrow>
          <mn>2</mn>
         </msup>
         <mo stretchy="false">)</mo>
        </mrow>
        <mrow>
         <mo>-</mo>
         <mrow>
          <mi>z</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mrow>
            <mfrac>
             <mi>c</mi>
             <mn>2</mn>
            </mfrac>
            <mo>-</mo>
            <mn>1</mn>
           </mrow>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
        </mrow>
       </msup>
      </mpadded>
      <msup>
       <mi>d</mi>
       <mi>D</mi>
      </msup>
      <mi>y</mi>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>normal-Φ</ci>
     <list>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>t</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>t</ci>
       <ci>n</ci>
      </apply>
     </list>
    </apply>
    <apply>
     <int></int>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <ci>normal-Φ</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>t</ci>
         <cn type="integer">1</cn>
        </apply>
        <ci>normal-⋯</ci>
        <ci>normal-Φ</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>t</ci>
         <ci>n</ci>
        </apply>
       </apply>
       <apply>
        <plus></plus>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <abs></abs>
          <ci>y</ci>
         </apply>
         <cn type="integer">2</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>q</ci>
          <ci>μ</ci>
         </apply>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <abs></abs>
         <ci>y</ci>
        </apply>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <ci>z</ci>
         <apply>
          <minus></minus>
          <apply>
           <divide></divide>
           <ci>c</ci>
           <cn type="integer">2</cn>
          </apply>
          <cn type="integer">1</cn>
         </apply>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>d</ci>
       <ci>D</ci>
      </apply>
      <ci>y</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle\Phi([t_{1},\dots,t_{n}])=\int{\Phi(t_{1})\cdots\Phi(t_{n})\over|%
y|^{2}+q_{\mu}^{2}}(|y|^{2})^{-z({c\over 2}-1)}\,d^{D}y,
  </annotation>
 </semantics>
</math>

</p>

<p>where <em>z</em> = 1 – <em>D</em>/2 is the regularization parameter. These integrals can be computed explicitly in terms of the <a href="Gamma_function" title="wikilink">Gamma function</a> using the formula</p>

<p>

<math display="block" id="Butcher_group:51">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo largeop="true" symmetric="true">∫</mo>
     <mrow>
      <mpadded width="+1.7pt">
       <mfrac>
        <msup>
         <mrow>
          <mo stretchy="false">(</mo>
          <msup>
           <mrow>
            <mo stretchy="false">|</mo>
            <mi>y</mi>
            <mo stretchy="false">|</mo>
           </mrow>
           <mn>2</mn>
          </msup>
          <mo stretchy="false">)</mo>
         </mrow>
         <mrow>
          <mo>-</mo>
          <mi>u</mi>
         </mrow>
        </msup>
        <mrow>
         <msup>
          <mrow>
           <mo stretchy="false">|</mo>
           <mi>y</mi>
           <mo stretchy="false">|</mo>
          </mrow>
          <mn>2</mn>
         </msup>
         <mo>+</mo>
         <msubsup>
          <mi>q</mi>
          <mi>μ</mi>
          <mn>2</mn>
         </msubsup>
        </mrow>
       </mfrac>
      </mpadded>
      <msup>
       <mi>d</mi>
       <mi>D</mi>
      </msup>
      <mi>y</mi>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msup>
      <mi>π</mi>
      <mrow>
       <mi>D</mi>
       <mo>/</mo>
       <mn>2</mn>
      </mrow>
     </msup>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <msubsup>
        <mi>q</mi>
        <mi>μ</mi>
        <mn>2</mn>
       </msubsup>
       <mo stretchy="false">)</mo>
      </mrow>
      <mrow>
       <mrow>
        <mo>-</mo>
        <mi>z</mi>
       </mrow>
       <mo>-</mo>
       <mi>u</mi>
      </mrow>
     </msup>
     <mfrac>
      <mrow>
       <mi mathvariant="normal">Γ</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mrow>
          <mo>-</mo>
          <mi>u</mi>
         </mrow>
         <mo>+</mo>
         <mrow>
          <mi>D</mi>
          <mo>/</mo>
          <mn>2</mn>
         </mrow>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mi mathvariant="normal">Γ</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mrow>
          <mn>1</mn>
          <mo>+</mo>
          <mi>u</mi>
         </mrow>
         <mo>-</mo>
         <mrow>
          <mi>D</mi>
          <mo>/</mo>
          <mn>2</mn>
         </mrow>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mrow>
       <mi mathvariant="normal">Γ</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>D</mi>
         <mo>/</mo>
         <mn>2</mn>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mfrac>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <int></int>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <abs></abs>
          <ci>y</ci>
         </apply>
         <cn type="integer">2</cn>
        </apply>
        <apply>
         <minus></minus>
         <ci>u</ci>
        </apply>
       </apply>
       <apply>
        <plus></plus>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <abs></abs>
          <ci>y</ci>
         </apply>
         <cn type="integer">2</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>q</ci>
          <ci>μ</ci>
         </apply>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>d</ci>
       <ci>D</ci>
      </apply>
      <ci>y</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>π</ci>
      <apply>
       <divide></divide>
       <ci>D</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>q</ci>
        <ci>μ</ci>
       </apply>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <minus></minus>
       <apply>
        <minus></minus>
        <ci>z</ci>
       </apply>
       <ci>u</ci>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <ci>normal-Γ</ci>
       <apply>
        <plus></plus>
        <apply>
         <minus></minus>
         <ci>u</ci>
        </apply>
        <apply>
         <divide></divide>
         <ci>D</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
       <ci>normal-Γ</ci>
       <apply>
        <minus></minus>
        <apply>
         <plus></plus>
         <cn type="integer">1</cn>
         <ci>u</ci>
        </apply>
        <apply>
         <divide></divide>
         <ci>D</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>normal-Γ</ci>
       <apply>
        <divide></divide>
        <ci>D</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle\int{(|y|^{2})^{-u}\over|y|^{2}+q_{\mu}^{2}}\,d^{D}y=\pi^{D/2}(q_%
{\mu}^{2})^{-z-u}{\Gamma(-u+D/2)\Gamma(1+u-D/2)\over\Gamma(D/2)}.
  </annotation>
 </semantics>
</math>

</p>

<p>In particular</p>

<p>

<math display="block" id="Butcher_group:52">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi mathvariant="normal">Φ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mo>∙</mo>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msup>
      <mi>π</mi>
      <mrow>
       <mi>D</mi>
       <mo>/</mo>
       <mn>2</mn>
      </mrow>
     </msup>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <msubsup>
        <mi>q</mi>
        <mi>μ</mi>
        <mn>2</mn>
       </msubsup>
       <mo stretchy="false">)</mo>
      </mrow>
      <mrow>
       <mo>-</mo>
       <mrow>
        <mrow>
         <mi>z</mi>
         <mi>c</mi>
        </mrow>
        <mo>/</mo>
        <mn>2</mn>
       </mrow>
      </mrow>
     </msup>
     <mfrac>
      <mrow>
       <mi mathvariant="normal">Γ</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mn>1</mn>
         <mo>+</mo>
         <mrow>
          <mi>c</mi>
          <mi>z</mi>
         </mrow>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mrow>
       <mi>c</mi>
       <mi>z</mi>
      </mrow>
     </mfrac>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>normal-Φ</ci>
     <ci>normal-∙</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>π</ci>
      <apply>
       <divide></divide>
       <ci>D</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>q</ci>
        <ci>μ</ci>
       </apply>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <minus></minus>
       <apply>
        <divide></divide>
        <apply>
         <times></times>
         <ci>z</ci>
         <ci>c</ci>
        </apply>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <ci>normal-Γ</ci>
       <apply>
        <plus></plus>
        <cn type="integer">1</cn>
        <apply>
         <times></times>
         <ci>c</ci>
         <ci>z</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>c</ci>
       <ci>z</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle\Phi(\bullet)=\pi^{D/2}(q_{\mu}^{2})^{-zc/2}{\Gamma(1+cz)\over cz}.
  </annotation>
 </semantics>
</math>

</p>

<p>Taking the renormalization scheme <em>R</em> of minimal subtraction, the renormalized quantities 

<math display="inline" id="Butcher_group:53">
 <semantics>
  <mrow>
   <msubsup>
    <mi mathvariant="normal">Φ</mi>
    <mi>S</mi>
    <mi>R</mi>
   </msubsup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-Φ</ci>
      <ci>S</ci>
     </apply>
     <ci>R</ci>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Phi_{S}^{R}(t)
  </annotation>
 </semantics>
</math>

 are <a href="polynomial" title="wikilink">polynomials</a> in 

<math display="inline" id="Butcher_group:54">
 <semantics>
  <mrow>
   <mi>log</mi>
   <msubsup>
    <mi>q</mi>
    <mi>μ</mi>
    <mn>2</mn>
   </msubsup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <log></log>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>q</ci>
      <ci>μ</ci>
     </apply>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \log q_{\mu}^{2}
  </annotation>
 </semantics>
</math>

 when evaluated at <em>z</em> = 0.</p>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li>

<p>(also in Volume 3 of the Collected Works of Cayley, pages 242–246)</p></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li>

<p>, Chapter 14.</p></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>

<p>"</p>

<p><a class="uri" href="Category:Combinatorics" title="wikilink">Category:Combinatorics</a> <a href="Category:Numerical_analysis" title="wikilink">Category:Numerical analysis</a> <a href="Category:Quantum_field_theory" title="wikilink">Category:Quantum field theory</a> <a href="Category:Renormalization_group" title="wikilink">Category:Renormalization group</a> <a href="Category:Hopf_algebras" title="wikilink">Category:Hopf algebras</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"></li>
<li id="fn5"> (Special issue to honor professor J. C. Butcher on his sixtieth birthday)<a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
</ol>
</section>
</body>
</html>
