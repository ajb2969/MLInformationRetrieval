<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1931">CMA-ES</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>CMA-ES</h1>
<hr>'''CMA-ES''' stands fo<style>
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
<style>
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
</hr></body></html>
<body>

<p>r Covariance Matrix Adaptation Evolution Strategy. <a href="Evolution_strategies" title="wikilink">Evolution strategies</a> (ES) are <a class="uri" href="stochastic" title="wikilink">stochastic</a>, <a href="Derivative-free_optimization" title="wikilink">derivative-free methods</a> for <a href="numerical_optimization" title="wikilink">numerical optimization</a> of non-<a href="Linear_map" title="wikilink">linear</a> or non-<a href="Convex_function" title="wikilink">convex</a> <a href="continuous_optimization" title="wikilink">continuous optimization</a> problems. They belong to the class of <a href="evolutionary_algorithms" title="wikilink">evolutionary algorithms</a> and <a href="evolutionary_computation" title="wikilink">evolutionary computation</a>. An <a href="evolutionary_algorithm" title="wikilink">evolutionary algorithm</a> is broadly based on the principle of <a href="biological_evolution" title="wikilink">biological evolution</a>, namely the repeated interplay of variation (via recombination and mutation) and selection: in each generation (iteration) new individuals (candidate solutions, denoted as 

<math display="inline" id="CMA-ES:0">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

) are generated by variation, usually in a stochastic way, of the current parental individuals. Then, some individuals are selected to become the parents in the next generation based on their fitness or <a href="objective_function" title="wikilink">objective function</a> value 

<math display="inline" id="CMA-ES:1">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x)
  </annotation>
 </semantics>
</math>

. Like this, over the generation sequence, individuals with better and better 

<math display="inline" id="CMA-ES:2">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

-values are generated.</p>

<p>In an <a href="evolution_strategy" title="wikilink">evolution strategy</a>, new candidate solutions are sampled according to a <a href="multivariate_normal_distribution" title="wikilink">multivariate normal distribution</a> in the 

<math display="inline" id="CMA-ES:3">
 <semantics>
  <msup>
   <mi>ℝ</mi>
   <mi>n</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>ℝ</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{R}^{n}
  </annotation>
 </semantics>
</math>

. Recombination amounts to selecting a new mean value for the distribution. Mutation amounts to adding a random vector, a perturbation with zero mean. Pairwise dependencies between the variables in the distribution are represented by a <a href="covariance_matrix" title="wikilink">covariance matrix</a>. The covariance matrix adaptation (CMA) is a method to update the <a href="covariance_matrix" title="wikilink">covariance matrix</a> of this distribution. This is particularly useful, if the function 

<math display="inline" id="CMA-ES:4">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 is <a class="uri" href="ill-conditioned" title="wikilink">ill-conditioned</a>.</p>

<p>Adaptation of the <a href="covariance_matrix" title="wikilink">covariance matrix</a> amounts to learning a second order model of the underlying <a href="objective_function" title="wikilink">objective function</a> similar to the approximation of the inverse <a href="Hessian_matrix" title="wikilink">Hessian matrix</a> in the <a href="Quasi-Newton_method" title="wikilink">Quasi-Newton method</a> in classical <a href="Optimization_(mathematics)" title="wikilink">optimization</a>. In contrast to most classical methods, fewer assumptions on the nature of the underlying objective function are made. Only the ranking between candidate solutions is exploited for learning the sample distribution and neither derivatives nor even the function values themselves are required by the method.</p>
<h2 id="principles">Principles</h2>

<p> Two main principles for the adaptation of parameters of the search distribution are exploited in the CMA-ES algorithm.</p>

<p>First, a <a class="uri" href="maximum-likelihood" title="wikilink">maximum-likelihood</a> principle, based on the idea to increase the probability of successful candidate solutions and search steps. The mean of the distribution is updated such that the <a class="uri" href="likelihood" title="wikilink">likelihood</a> of previously successful candidate solutions is maximized. The <a href="covariance_matrix" title="wikilink">covariance matrix</a> of the distribution is updated (incrementally) such that the likelihood of previously successful search steps is increased. Both updates can be interpreted as a <a href="Information_geometry#Natural_gradient" title="wikilink">natural gradient</a> descent. Also, in consequence, the CMA conducts an iterated <a href="principal_components_analysis" title="wikilink">principal components analysis</a> of successful search steps while retaining <em>all</em> principal axes. <a href="Estimation_of_Distribution_Algorithms" title="wikilink">Estimation of distribution algorithms</a> and the <a href="Cross-Entropy_Method" title="wikilink">Cross-Entropy Method</a> are based on very similar ideas, but estimate (non-incrementally) the covariance matrix by maximizing the likelihood of successful solution <em>points</em> instead of successful search <em>steps</em>.</p>

<p>Second, two paths of the time evolution of the distribution mean of the strategy are recorded, called search or evolution paths. These paths contain significant information about the correlation between consecutive steps. Specifically, if consecutive steps are taken in a similar direction, the evolution paths become long. The evolution paths are exploited in two ways. One path is used for the covariance matrix adaptation procedure in place of single successful search steps and facilitates a possibly much faster variance increase of favorable directions. The other path is used to conduct an additional step-size control. This step-size control aims to make consecutive movements of the distribution mean orthogonal in expectation. The step-size control effectively prevents <a href="premature_convergence" title="wikilink">premature convergence</a> yet allowing fast convergence to an optimum.</p>
<h2 id="algorithm">Algorithm</h2>

<p>In the following the most commonly used (μ/μ<sub>w</sub>, λ)-CMA-ES is outlined, where in each iteration step a weighted combination of the μ best out of λ new candidate solutions is used to update the distribution parameters. The main loop consists of three main parts: 1) sampling of new solutions, 2) re-ordering of the sampled solutions based on their fitness, 3) update of the internal state variables based on the re-ordered samples. A <a class="uri" href="pseudocode" title="wikilink">pseudocode</a> of the algorithm looks as follows.</p>

<p><code> </code><strong><code>set</code></strong><code> </code>

<math display="inline" id="CMA-ES:5">
 <semantics>
  <mi>λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda
  </annotation>
 </semantics>
</math>

<code>  // number of samples per iteration, at least two, generally &gt; 4</code><br/>
<code> </code><strong><code>initialize</code></strong><code> </code>

<math display="inline" id="CMA-ES:6">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

<code>, </code>

<math display="inline" id="CMA-ES:7">
 <semantics>
  <mi>σ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma
  </annotation>
 </semantics>
</math>

<code>, </code>

<math display="inline" id="CMA-ES:8">
 <semantics>
  <mrow>
   <mi>C</mi>
   <mo>=</mo>
   <mi>I</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>C</ci>
    <ci>I</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C=I
  </annotation>
 </semantics>
</math>

<code>, </code>

<math display="inline" id="CMA-ES:9">
 <semantics>
  <mrow>
   <msub>
    <mi>p</mi>
    <mi>σ</mi>
   </msub>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>p</ci>
     <ci>σ</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{\sigma}=0
  </annotation>
 </semantics>
</math>

<code>, </code>

<math display="inline" id="CMA-ES:10">
 <semantics>
  <mrow>
   <msub>
    <mi>p</mi>
    <mi>c</mi>
   </msub>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>p</ci>
     <ci>c</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{c}=0
  </annotation>
 </semantics>
</math>

<code>  // initialize state variables</code><br/>
<code> </code><strong><code>while</code></strong><code> </code><em><code>not</code> <code>terminate</code></em><code>  // iterate</code><br/>
<code>    </code><strong><code>for</code></strong><code> </code>

<math display="inline" id="CMA-ES:11">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

<code> </code><strong><code>in</code></strong><code> </code>

<math display="inline" id="CMA-ES:12">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mrow>
    <mn>1...</mn>
    <mi>λ</mi>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <times></times>
     <cn type="float">1...</cn>
     <ci>λ</ci>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{1...\lambda\}
  </annotation>
 </semantics>
</math>

<code>  // sample </code>

<math display="inline" id="CMA-ES:13">
 <semantics>
  <mi>λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda
  </annotation>
 </semantics>
</math>

<code> new solutions and evaluate them</code><br/>
<code>       </code>

<math display="inline" id="CMA-ES:14">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i}
  </annotation>
 </semantics>
</math>

<code> = sample_multivariate_normal(mean=</code>

<math display="inline" id="CMA-ES:15">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

<code>, covariance_matrix=</code>

<math display="inline" id="CMA-ES:16">
 <semantics>
  <mrow>
   <msup>
    <mi>σ</mi>
    <mn>2</mn>
   </msup>
   <mi>C</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>σ</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>C</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma^{2}C
  </annotation>
 </semantics>
</math>

<code>)</code><br/>
<code>       </code>

<math display="inline" id="CMA-ES:17">
 <semantics>
  <msub>
   <mi>f</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>f</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{i}
  </annotation>
 </semantics>
</math>

<code> = fitness(</code>

<math display="inline" id="CMA-ES:18">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i}
  </annotation>
 </semantics>
</math>

<code>)</code><br/>
<code>    </code>

<math display="inline" id="CMA-ES:19">
 <semantics>
  <msub>
   <mi>x</mi>
   <mrow>
    <mn>1...</mn>
    <mi>λ</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <apply>
     <times></times>
     <cn type="float">1...</cn>
     <ci>λ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1...\lambda}
  </annotation>
 </semantics>
</math>

<code> ← </code>

<math display="inline" id="CMA-ES:20">
 <semantics>
  <msub>
   <mi>x</mi>
   <mrow>
    <mi>s</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>1</mn>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi mathvariant="normal">…</mi>
    <mi>s</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <apply>
     <times></times>
     <ci>s</ci>
     <cn type="integer">1</cn>
     <ci>normal-…</ci>
     <ci>s</ci>
     <ci>λ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{s(1)...s(\lambda)}
  </annotation>
 </semantics>
</math>

<code> with </code>

<math display="inline" id="CMA-ES:21">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>i</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>s</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s(i)
  </annotation>
 </semantics>
</math>

<code> = argsort(</code>

<math display="inline" id="CMA-ES:22">
 <semantics>
  <msub>
   <mi>f</mi>
   <mrow>
    <mn>1...</mn>
    <mi>λ</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>f</ci>
    <apply>
     <times></times>
     <cn type="float">1...</cn>
     <ci>λ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{1...\lambda}
  </annotation>
 </semantics>
</math>

<code>, </code>

<math display="inline" id="CMA-ES:23">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

<code>)  // sort solutions</code><br/>
<code>    </code>

<math display="inline" id="CMA-ES:24">
 <semantics>
  <msup>
   <mi>m</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>m</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m^{\prime}
  </annotation>
 </semantics>
</math>

<code> = </code>

<math display="inline" id="CMA-ES:25">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

<code>  // we need later </code>

<math display="inline" id="CMA-ES:26">
 <semantics>
  <mrow>
   <mi>m</mi>
   <mo>-</mo>
   <msup>
    <mi>m</mi>
    <mo>′</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>m</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>m</ci>
     <ci>normal-′</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m-m^{\prime}
  </annotation>
 </semantics>
</math>

<code> and </code>

<math display="inline" id="CMA-ES:27">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mi>i</mi>
   </msub>
   <mo>-</mo>
   <msup>
    <mi>m</mi>
    <mo>′</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>m</ci>
     <ci>normal-′</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i}-m^{\prime}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="inline" id="CMA-ES:28">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

 ← update_m

<math display="inline" id="CMA-ES:29">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msub>
    <mi>x</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-(</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-,</ci>
    <ci>normal-…</ci>
    <ci>normal-,</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x_{1},...,
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="CMA-ES:30">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mi>λ</mi>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>λ</ci>
    </apply>
    <ci>normal-)</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{\lambda})
  </annotation>
 </semantics>
</math>

 // move mean to better solutions</p>

<p><code>    </code>

<math display="inline" id="CMA-ES:31">
 <semantics>
  <msub>
   <mi>p</mi>
   <mi>σ</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>p</ci>
    <ci>σ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{\sigma}
  </annotation>
 </semantics>
</math>

<code> ← update_ps</code>

<math display="inline" id="CMA-ES:32">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msub>
    <mi>p</mi>
    <mi>σ</mi>
   </msub>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-(</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>p</ci>
     <ci>σ</ci>
    </apply>
    <ci>normal-,</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (p_{\sigma},
  </annotation>
 </semantics>
</math>

<code> </code>

<math display="inline" id="CMA-ES:33">
 <semantics>
  <mrow>
   <msup>
    <mi>σ</mi>
    <mrow>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msup>
   <msup>
    <mi>C</mi>
    <mrow>
     <mo>-</mo>
     <mrow>
      <mn>1</mn>
      <mo>/</mo>
      <mn>2</mn>
     </mrow>
    </mrow>
   </msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>m</mi>
    <mo>-</mo>
    <msup>
     <mi>m</mi>
     <mo>′</mo>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>σ</ci>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>C</ci>
     <apply>
      <minus></minus>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">m</csymbol>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>m</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-)</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma^{-1}C^{-1/2}(m-m^{\prime}))
  </annotation>
 </semantics>
</math>

<code>  // update isotropic evolution path</code><br/>
<code>    </code>

<math display="inline" id="CMA-ES:34">
 <semantics>
  <msub>
   <mi>p</mi>
   <mi>c</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>p</ci>
    <ci>c</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{c}
  </annotation>
 </semantics>
</math>

<code> ← update_pc</code>

<math display="inline" id="CMA-ES:35">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msub>
    <mi>p</mi>
    <mi>c</mi>
   </msub>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-(</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>p</ci>
     <ci>c</ci>
    </apply>
    <ci>normal-,</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (p_{c},
  </annotation>
 </semantics>
</math>

<code> </code>

<math display="inline" id="CMA-ES:36">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>σ</mi>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>m</mi>
      <mo>-</mo>
      <msup>
       <mi>m</mi>
       <mo>′</mo>
      </msup>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>σ</ci>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <ci>m</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>m</ci>
      <ci>normal-′</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma^{-1}(m-m^{\prime}),
  </annotation>
 </semantics>
</math>

<code> </code>

<math display="inline" id="CMA-ES:37">
 <semantics>
  <mrow>
   <mo stretchy="false">|</mo>
   <mo stretchy="false">|</mo>
   <msub>
    <mi>p</mi>
    <mi>σ</mi>
   </msub>
   <mo stretchy="false">|</mo>
   <mo stretchy="false">|</mo>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-|</ci>
    <ci>normal-|</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>p</ci>
     <ci>σ</ci>
    </apply>
    <ci>normal-|</ci>
    <ci>normal-|</ci>
    <ci>normal-)</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ||p_{\sigma}||)
  </annotation>
 </semantics>
</math>

<code>  // update anisotropic evolution path</code><br/>
<code>    </code>

<math display="inline" id="CMA-ES:38">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

<code> ← update_C</code>

<math display="inline" id="CMA-ES:39">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>C</mi>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-(</ci>
    <csymbol cd="unknown">C</csymbol>
    <ci>normal-,</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (C,
  </annotation>
 </semantics>
</math>

<code> </code>

<math display="inline" id="CMA-ES:40">
 <semantics>
  <mrow>
   <msub>
    <mi>p</mi>
    <mi>c</mi>
   </msub>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>p</ci>
    <ci>c</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{c},
  </annotation>
 </semantics>
</math>

<code> </code>

<math display="inline" id="CMA-ES:41">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>x</mi>
        <mn>1</mn>
       </msub>
       <mo>-</mo>
       <msup>
        <mi>m</mi>
        <mo>′</mo>
       </msup>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>/</mo>
     <mi>σ</mi>
    </mrow>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <divide></divide>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>m</ci>
       <ci>normal-′</ci>
      </apply>
     </apply>
     <ci>σ</ci>
    </apply>
    <ci>normal-…</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {(x_{1}-m^{\prime})}/{\sigma},...,
  </annotation>
 </semantics>
</math>

<code> </code>

<math display="inline" id="CMA-ES:42">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mi>λ</mi>
    </msub>
    <mo>-</mo>
    <msup>
     <mi>m</mi>
     <mo>′</mo>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>/</mo>
   <mi>σ</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>λ</ci>
     </apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>m</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <divide></divide>
    <csymbol cd="unknown">σ</csymbol>
    <ci>normal-)</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {(x_{\lambda}-m^{\prime})}/{\sigma})
  </annotation>
 </semantics>
</math>

<code>  // update covariance matrix</code><br/>
<code>    </code>

<math display="inline" id="CMA-ES:43">
 <semantics>
  <mi>σ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma
  </annotation>
 </semantics>
</math>

<code> ← update_sigma</code>

<math display="inline" id="CMA-ES:44">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>σ</mi>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-(</ci>
    <csymbol cd="unknown">σ</csymbol>
    <ci>normal-,</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\sigma,
  </annotation>
 </semantics>
</math>

<code> </code>

<math display="inline" id="CMA-ES:45">
 <semantics>
  <mrow>
   <mo stretchy="false">|</mo>
   <mo stretchy="false">|</mo>
   <msub>
    <mi>p</mi>
    <mi>σ</mi>
   </msub>
   <mo stretchy="false">|</mo>
   <mo stretchy="false">|</mo>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-|</ci>
    <ci>normal-|</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>p</ci>
     <ci>σ</ci>
    </apply>
    <ci>normal-|</ci>
    <ci>normal-|</ci>
    <ci>normal-)</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ||p_{\sigma}||)
  </annotation>
 </semantics>
</math>

<code>  // update step-size using isotropic path length</code><br/>
<code> </code><strong><code>return</code></strong><code> </code>

<math display="inline" id="CMA-ES:46">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

<code> or </code>

<math display="inline" id="CMA-ES:47">
 <semantics>
  <msub>
   <mi>x</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1}
  </annotation>
 </semantics>
</math>

<code> </code></p>

<p>The order of the five update assignments is relevant. In the following, the update equations for the five state variables are specified.</p>

<p>Given are the search space dimension 

<math display="inline" id="CMA-ES:48">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 and the iteration step 

<math display="inline" id="CMA-ES:49">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

. The five state variables are</p>

<p>

<math display="block" id="CMA-ES:50">
 <semantics>
  <mrow>
   <msub>
    <mi>m</mi>
    <mi>k</mi>
   </msub>
   <mo>∈</mo>
   <msup>
    <mi>ℝ</mi>
    <mi>n</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>m</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ℝ</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m_{k}\in\mathbb{R}^{n}
  </annotation>
 </semantics>
</math>

, the distribution mean and current favorite solution to the optimization problem,</p>

<p>

<math display="block" id="CMA-ES:51">
 <semantics>
  <mrow>
   <msub>
    <mi>σ</mi>
    <mi>k</mi>
   </msub>
   <mo>></mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>σ</ci>
     <ci>k</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma_{k}>0
  </annotation>
 </semantics>
</math>

, the step-size,</p>

<p>

<math display="block" id="CMA-ES:52">
 <semantics>
  <msub>
   <mi>C</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>C</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{k}
  </annotation>
 </semantics>
</math>

, a symmetric and <a href="Positive-definite_matrix" title="wikilink">positive definite</a> 

<math display="inline" id="CMA-ES:53">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>×</mo>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>n</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n\times n
  </annotation>
 </semantics>
</math>

 <a href="covariance_matrix" title="wikilink">covariance matrix</a> with 

<math display="inline" id="CMA-ES:54">
 <semantics>
  <mrow>
   <msub>
    <mi>C</mi>
    <mn>0</mn>
   </msub>
   <mo>=</mo>
   <mi>I</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <cn type="integer">0</cn>
    </apply>
    <ci>I</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{0}=I
  </annotation>
 </semantics>
</math>

 and</p>

<p>

<math display="block" id="CMA-ES:55">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>p</mi>
     <mi>σ</mi>
    </msub>
    <mo>∈</mo>
    <msup>
     <mi>ℝ</mi>
     <mi>n</mi>
    </msup>
   </mrow>
   <mo>,</mo>
   <mrow>
    <msub>
     <mi>p</mi>
     <mi>c</mi>
    </msub>
    <mo>∈</mo>
    <msup>
     <mi>ℝ</mi>
     <mi>n</mi>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <in></in>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>p</ci>
      <ci>σ</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ℝ</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <in></in>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>p</ci>
      <ci>c</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ℝ</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{\sigma}\in\mathbb{R}^{n},p_{c}\in\mathbb{R}^{n}
  </annotation>
 </semantics>
</math>

, two evolution paths, initially set to the zero vector.</p>

<p>The iteration starts with sampling 

<math display="inline" id="CMA-ES:56">
 <semantics>
  <mrow>
   <mi>λ</mi>
   <mo>></mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <ci>λ</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda>1
  </annotation>
 </semantics>
</math>

 candidate solutions 

<math display="inline" id="CMA-ES:57">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mi>i</mi>
   </msub>
   <mo>∈</mo>
   <msup>
    <mi>ℝ</mi>
    <mi>n</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ℝ</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i}\in\mathbb{R}^{n}
  </annotation>
 </semantics>
</math>

 from a <a href="multivariate_normal_distribution" title="wikilink">multivariate normal distribution</a> 

<math display="inline" id="CMA-ES:58">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">𝒩</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>m</mi>
     <mi>k</mi>
    </msub>
    <mo>,</mo>
    <mrow>
     <msubsup>
      <mi>σ</mi>
      <mi>k</mi>
      <mn>2</mn>
     </msubsup>
     <msub>
      <mi>C</mi>
      <mi>k</mi>
     </msub>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>𝒩</ci>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>m</ci>
      <ci>k</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>σ</ci>
        <ci>k</ci>
       </apply>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>C</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle\mathcal{N}(m_{k},\sigma_{k}^{2}C_{k})
  </annotation>
 </semantics>
</math>

, i.e. for 

<math display="inline" id="CMA-ES:59">
 <semantics>
  <mrow>
   <mi>i</mi>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mi>λ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>i</ci>
    <list>
     <cn type="integer">1</cn>
     <ci>normal-…</ci>
     <ci>λ</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i=1,...,\lambda
  </annotation>
 </semantics>
</math>

</p>
<dl>
<dd><dl>
<dd><math>
</math></dd>
</dl>
</dd>
</dl>

<p>\begin{align}</p>

<p><code> x_i \ &amp;\sim\ \mathcal{N}(m_k,\sigma_k^2 C_k)      </code><br/>
<code>    \\&amp;\sim\ m_k + \sigma_k\times\mathcal{N}(0,C_k) </code></p>

<p>\end{align}</p>

<p><code> </code></p>

<p>The second line suggests the interpretation as perturbation (mutation) of the current favorite solution vector 

<math display="inline" id="CMA-ES:60">
 <semantics>
  <msub>
   <mi>m</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>m</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m_{k}
  </annotation>
 </semantics>
</math>

 (the distribution mean vector). The candidate solutions 

<math display="inline" id="CMA-ES:61">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i}
  </annotation>
 </semantics>
</math>

 are evaluated on the objective function 

<math display="inline" id="CMA-ES:62">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mo>:</mo>
   <mrow>
    <msup>
     <mi>ℝ</mi>
     <mi>n</mi>
    </msup>
    <mo>→</mo>
    <mi>ℝ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>f</ci>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ℝ</ci>
      <ci>n</ci>
     </apply>
     <ci>ℝ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f:\mathbb{R}^{n}\to\mathbb{R}
  </annotation>
 </semantics>
</math>

 to be minimized. Denoting the 

<math display="inline" id="CMA-ES:63">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

-sorted candidate solutions as</p>

<p>

<math display="block" id="CMA-ES:64">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">{</mo>
     <mpadded width="+2.8pt">
      <msub>
       <mi>x</mi>
       <mrow>
        <mi>i</mi>
        <mo>:</mo>
        <mi>λ</mi>
       </mrow>
      </msub>
     </mpadded>
     <mo rspace="5.3pt" stretchy="false">|</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mrow>
       <mn>1</mn>
       <mi mathvariant="normal">…</mi>
       <mi>λ</mi>
      </mrow>
     </mrow>
     <mo stretchy="false">}</mo>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">{</mo>
      <mpadded width="+2.8pt">
       <msub>
        <mi>x</mi>
        <mi>i</mi>
       </msub>
      </mpadded>
      <mo rspace="5.3pt" stretchy="false">|</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mrow>
        <mn>1</mn>
        <mi mathvariant="normal">…</mi>
        <mi>λ</mi>
       </mrow>
      </mrow>
      <mo rspace="8.1pt" stretchy="false">}</mo>
     </mrow>
     <mpadded width="+5.6pt">
      <mtext>and</mtext>
     </mpadded>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mrow>
        <mn>1</mn>
        <mo>:</mo>
        <mi>λ</mi>
       </mrow>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>≤</mo>
    <mi mathvariant="normal">…</mi>
    <mo>≤</mo>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mrow>
        <mi>μ</mi>
        <mo>:</mo>
        <mi>λ</mi>
       </mrow>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>≤</mo>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mrow>
        <mrow>
         <mi>μ</mi>
         <mo>+</mo>
         <mn>1</mn>
        </mrow>
        <mo>:</mo>
        <mi>λ</mi>
       </mrow>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi mathvariant="normal">…</mi>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="latexml">conditional-set</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <apply>
        <ci>normal-:</ci>
        <ci>i</ci>
        <ci>λ</ci>
       </apply>
      </apply>
      <apply>
       <eq></eq>
       <ci>i</ci>
       <apply>
        <times></times>
        <cn type="integer">1</cn>
        <ci>normal-…</ci>
        <ci>λ</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="latexml">conditional-set</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <apply>
         <times></times>
         <cn type="integer">1</cn>
         <ci>normal-…</ci>
         <ci>λ</ci>
        </apply>
       </apply>
      </apply>
      <mtext>and</mtext>
      <ci>f</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <apply>
        <ci>normal-:</ci>
        <cn type="integer">1</cn>
        <ci>λ</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <ci>normal-…</ci>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>f</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <apply>
        <ci>normal-:</ci>
        <ci>μ</ci>
        <ci>λ</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>f</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <apply>
        <ci>normal-:</ci>
        <apply>
         <plus></plus>
         <ci>μ</ci>
         <cn type="integer">1</cn>
        </apply>
        <ci>λ</ci>
       </apply>
      </apply>
      <ci>normal-…</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{x_{i:\lambda}\;|\;i=1\dots\lambda\}=\{x_{i}\;|\;i=1\dots\lambda\}\;\;\text{%
and}\;\;f(x_{1:\lambda})\leq\dots\leq f(x_{\mu:\lambda})\leq f(x_{\mu+1:%
\lambda})\dots,
  </annotation>
 </semantics>
</math>

</p>

<p>the new mean value is computed as</p>
<dl>
<dd><dl>
<dd><math>
</math></dd>
</dl>
</dd>
</dl>

<p>\begin{align}</p>

<p><code> m_{k+1} &amp;= \sum_{i=1}^{\mu} w_i\, x_{i:\lambda} </code><br/>
<code> \\ &amp;= m_k + \sum_{i=1}^{\mu} w_i\, (x_{i:\lambda} - m_k) </code></p>

<p>\end{align}</p>

<p><code> </code></p>

<p>where the positive (recombination) weights 

<math display="inline" id="CMA-ES:65">
 <semantics>
  <mrow>
   <msub>
    <mi>w</mi>
    <mn>1</mn>
   </msub>
   <mo>≥</mo>
   <msub>
    <mi>w</mi>
    <mn>2</mn>
   </msub>
   <mo>≥</mo>
   <mi mathvariant="normal">…</mi>
   <mo>≥</mo>
   <msub>
    <mi>w</mi>
    <mi>μ</mi>
   </msub>
   <mo>></mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <geq></geq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>w</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>w</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <geq></geq>
     <share href="#.cmml">
     </share>
     <ci>normal-…</ci>
    </apply>
    <apply>
     <geq></geq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>w</ci>
      <ci>μ</ci>
     </apply>
    </apply>
    <apply>
     <gt></gt>
     <share href="#.cmml">
     </share>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w_{1}\geq w_{2}\geq\dots\geq w_{\mu}>0
  </annotation>
 </semantics>
</math>

 sum to one. Typically, 

<math display="inline" id="CMA-ES:66">
 <semantics>
  <mrow>
   <mi>μ</mi>
   <mo>≤</mo>
   <mrow>
    <mi>λ</mi>
    <mo>/</mo>
    <mn>2</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <ci>μ</ci>
    <apply>
     <divide></divide>
     <ci>λ</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu\leq\lambda/2
  </annotation>
 </semantics>
</math>

 and the weights are chosen such that 

<math display="inline" id="CMA-ES:67">
 <semantics>
  <mrow>
   <msub>
    <mi>μ</mi>
    <mi>w</mi>
   </msub>
   <mo>:=</mo>
   <mrow>
    <mn>1</mn>
    <mo>/</mo>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>μ</mi>
     </msubsup>
     <msubsup>
      <mi>w</mi>
      <mi>i</mi>
      <mn>2</mn>
     </msubsup>
    </mrow>
   </mrow>
   <mo>≈</mo>
   <mrow>
    <mi>λ</mi>
    <mo>/</mo>
    <mn>4</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <csymbol cd="latexml">assign</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>μ</ci>
      <ci>w</ci>
     </apply>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <ci>i</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>μ</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>w</ci>
         <ci>i</ci>
        </apply>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <approx></approx>
     <share href="#.cmml">
     </share>
     <apply>
      <divide></divide>
      <ci>λ</ci>
      <cn type="integer">4</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle\mu_{w}:=1/\sum_{i=1}^{\mu}w_{i}^{2}\approx\lambda/4
  </annotation>
 </semantics>
</math>

. The only feedback used from the objective function here and in the following is an ordering of the sampled candidate solutions due to the indices 

<math display="inline" id="CMA-ES:68">
 <semantics>
  <mrow>
   <mi>i</mi>
   <mo>:</mo>
   <mi>λ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>i</ci>
    <ci>λ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i:\lambda
  </annotation>
 </semantics>
</math>

.</p>

<p>The step-size 

<math display="inline" id="CMA-ES:69">
 <semantics>
  <msub>
   <mi>σ</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>σ</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma_{k}
  </annotation>
 </semantics>
</math>

 is updated using <em>cumulative step-size adaptation</em> (CSA), sometimes also denoted as <em>path length control</em>. The evolution path (or search path) 

<math display="inline" id="CMA-ES:70">
 <semantics>
  <msub>
   <mi>p</mi>
   <mi>σ</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>p</ci>
    <ci>σ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{\sigma}
  </annotation>
 </semantics>
</math>

 is updated first.</p>
<dl>
<dd><dl>
<dd><math>
</math></dd>
</dl>
</dd>
</dl>

<p><code> p_\sigma \gets \underbrace{(1-c_\sigma)}_{\!\!\!\!\!\text{discount factor}\!\!\!\!\!}\, p_\sigma </code><br/>
<code>   + \overbrace{\sqrt{1 - (1-c_\sigma)^2}}^{</code><br/>
<code>    \!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\text{complements for discounted variance}</code><br/>
<code>    \!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!} \underbrace{\sqrt{\mu_w} </code><br/>
<code>    \,C_k^{\;-1/2} \, \frac{\overbrace{m_{k+1} - m_k}^{\!\!\!\text{displacement of}\; m\!\!\!}}{\sigma_k}}_{\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!</code><br/>
<code>                     \text{distributed as}\; \mathcal{N}(0,I)\;\text{under neutral selection}</code><br/>
<code>                     \!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!}</code><br/>
<code> </code></p>
<dl>
<dd><dl>
<dd><math>
</math></dd>
</dl>
</dd>
</dl>

<p><code> \sigma_{k+1} = \sigma_k \times \exp\bigg(\frac{c_\sigma}{d_\sigma}</code><br/>
<code>                         \underbrace{\left(\frac{\|p_\sigma\|}{E\|\mathcal{N}(0,I)\|} - 1\right)}_{\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!</code><br/>
<code>   \text{unbiased about 0 under neutral selection}</code><br/>
<code>   \!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!</code></p>

<p>}\bigg)</p>

<p><code> </code></p>

<p>where</p>

<p>

<math display="block" id="CMA-ES:71">
 <semantics>
  <mrow>
   <msubsup>
    <mi>c</mi>
    <mi>σ</mi>
    <mrow>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msubsup>
   <mo>≈</mo>
   <mrow>
    <mi>n</mi>
    <mo>/</mo>
    <mn>3</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>c</ci>
      <ci>σ</ci>
     </apply>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <ci>n</ci>
     <cn type="integer">3</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{\sigma}^{-1}\approx n/3
  </annotation>
 </semantics>
</math>

 is the backward time horizon for the evolution path 

<math display="inline" id="CMA-ES:72">
 <semantics>
  <msub>
   <mi>p</mi>
   <mi>σ</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>p</ci>
    <ci>σ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{\sigma}
  </annotation>
 </semantics>
</math>

 and larger than one,</p>

<p>

<math display="block" id="CMA-ES:73">
 <semantics>
  <mrow>
   <msub>
    <mi>μ</mi>
    <mi>w</mi>
   </msub>
   <mo>=</mo>
   <msup>
    <mrow>
     <mo>(</mo>
     <mrow>
      <munderover>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mrow>
        <mi>i</mi>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <mi>μ</mi>
      </munderover>
      <msubsup>
       <mi>w</mi>
       <mi>i</mi>
       <mn>2</mn>
      </msubsup>
     </mrow>
     <mo>)</mo>
    </mrow>
    <mrow>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>μ</ci>
     <ci>w</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>μ</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>w</ci>
        <ci>i</ci>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu_{w}=\left(\sum_{i=1}^{\mu}w_{i}^{2}\right)^{-1}
  </annotation>
 </semantics>
</math>

 is the variance effective selection mass and 

<math display="inline" id="CMA-ES:74">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>≤</mo>
   <msub>
    <mi>μ</mi>
    <mi>w</mi>
   </msub>
   <mo>≤</mo>
   <mi>μ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <cn type="integer">1</cn>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>μ</ci>
      <ci>w</ci>
     </apply>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <ci>μ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1\leq\mu_{w}\leq\mu
  </annotation>
 </semantics>
</math>

 by definition of 

<math display="inline" id="CMA-ES:75">
 <semantics>
  <msub>
   <mi>w</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>w</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w_{i}
  </annotation>
 </semantics>
</math>

,</p>

<p>

<math display="block" id="CMA-ES:76">
 <semantics>
  <mrow>
   <msubsup>
    <mi>C</mi>
    <mi>k</mi>
    <mrow>
     <mo lspace="5.3pt">-</mo>
     <mrow>
      <mn>1</mn>
      <mo>/</mo>
      <mn>2</mn>
     </mrow>
    </mrow>
   </msubsup>
   <mo>=</mo>
   <msup>
    <msqrt>
     <msub>
      <mi>C</mi>
      <mi>k</mi>
     </msub>
    </msqrt>
    <mrow>
     <mo lspace="5.3pt">-</mo>
     <mn>1</mn>
    </mrow>
   </msup>
   <mo>=</mo>
   <msqrt>
    <msubsup>
     <mi>C</mi>
     <mi>k</mi>
     <mrow>
      <mo lspace="5.3pt">-</mo>
      <mn>1</mn>
     </mrow>
    </msubsup>
   </msqrt>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>C</ci>
       <ci>k</ci>
      </apply>
      <apply>
       <minus></minus>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <root></root>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>C</ci>
        <ci>k</ci>
       </apply>
      </apply>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <root></root>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>C</ci>
        <ci>k</ci>
       </apply>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{k}^{\;-1/2}=\sqrt{C_{k}}^{\;-1}=\sqrt{C_{k}^{\;-1}}
  </annotation>
 </semantics>
</math>

 is the unique symmetric <a href="Square_root_of_a_matrix" title="wikilink">square root</a> of the <a href="Invertible_matrix" title="wikilink">inverse</a> of 

<math display="inline" id="CMA-ES:77">
 <semantics>
  <msub>
   <mi>C</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>C</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{k}
  </annotation>
 </semantics>
</math>

, and</p>

<p>

<math display="block" id="CMA-ES:78">
 <semantics>
  <msub>
   <mi>d</mi>
   <mi>σ</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>d</ci>
    <ci>σ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d_{\sigma}
  </annotation>
 </semantics>
</math>

 is the damping parameter usually close to one. For 

<math display="inline" id="CMA-ES:79">
 <semantics>
  <mrow>
   <msub>
    <mi>d</mi>
    <mi>σ</mi>
   </msub>
   <mo>=</mo>
   <mi mathvariant="normal">∞</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>d</ci>
     <ci>σ</ci>
    </apply>
    <infinity></infinity>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d_{\sigma}=\infty
  </annotation>
 </semantics>
</math>

 or 

<math display="inline" id="CMA-ES:80">
 <semantics>
  <mrow>
   <msub>
    <mi>c</mi>
    <mi>σ</mi>
   </msub>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>c</ci>
     <ci>σ</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{\sigma}=0
  </annotation>
 </semantics>
</math>

 the step-size remains unchanged.</p>

<p>The step-size 

<math display="inline" id="CMA-ES:81">
 <semantics>
  <msub>
   <mi>σ</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>σ</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma_{k}
  </annotation>
 </semantics>
</math>

 is increased if and only if 

<math display="inline" id="CMA-ES:82">
 <semantics>
  <mrow>
   <mo>∥</mo>
   <msub>
    <mi>p</mi>
    <mi>σ</mi>
   </msub>
   <mo>∥</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">norm</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>p</ci>
     <ci>σ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \|p_{\sigma}\|
  </annotation>
 </semantics>
</math>

 is larger than the <a href="expected_value" title="wikilink">expected value</a></p>

<p>

<math display="inline" id="CMA-ES:83">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mrow>
    <mo>∥</mo>
    <mrow>
     <mi class="ltx_font_mathcaligraphic">𝒩</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>0</mn>
      <mo>,</mo>
      <mi>I</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>∥</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>E</ci>
    <apply>
     <csymbol cd="latexml">norm</csymbol>
     <apply>
      <times></times>
      <ci>𝒩</ci>
      <interval closure="open">
       <cn type="integer">0</cn>
       <ci>I</ci>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle E\|\mathcal{N}(0,I)\|
  </annotation>
 </semantics>
</math>


</p>

<p>and decreased if it is smaller. For this reason, the step-size update tends to make consecutive steps <a href="Conjugate_gradient#The_conjugate_gradient_method_as_a_direct_method" title="wikilink">

<math display="inline" id="CMA-ES:84">
 <semantics>
  <msubsup>
   <mi>C</mi>
   <mi>k</mi>
   <mrow>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{k}^{-1}
  </annotation>
 </semantics>
</math>

-conjugate</a>, in that after the adaptation has been successful 

<math display="inline" id="CMA-ES:85">
 <semantics>
  <mrow>
   <mrow>
    <mpadded width="-1.7pt">
     <msup>
      <mrow>
       <mo>(</mo>
       <mfrac>
        <mrow>
         <msub>
          <mi>m</mi>
          <mrow>
           <mi>k</mi>
           <mo>+</mo>
           <mn>2</mn>
          </mrow>
         </msub>
         <mo>-</mo>
         <msub>
          <mi>m</mi>
          <mrow>
           <mi>k</mi>
           <mo>+</mo>
           <mn>1</mn>
          </mrow>
         </msub>
        </mrow>
        <msub>
         <mi>σ</mi>
         <mrow>
          <mi>k</mi>
          <mo>+</mo>
          <mn>1</mn>
         </mrow>
        </msub>
       </mfrac>
       <mo>)</mo>
      </mrow>
      <mi>T</mi>
     </msup>
    </mpadded>
    <msubsup>
     <mi>C</mi>
     <mi>k</mi>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msubsup>
    <mfrac>
     <mrow>
      <msub>
       <mi>m</mi>
       <mrow>
        <mi>k</mi>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
      </msub>
      <mo>-</mo>
      <msub>
       <mi>m</mi>
       <mi>k</mi>
      </msub>
     </mrow>
     <msub>
      <mi>σ</mi>
      <mi>k</mi>
     </msub>
    </mfrac>
   </mrow>
   <mo>≈</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <divide></divide>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>m</ci>
         <apply>
          <plus></plus>
          <ci>k</ci>
          <cn type="integer">2</cn>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>m</ci>
         <apply>
          <plus></plus>
          <ci>k</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>σ</ci>
        <apply>
         <plus></plus>
         <ci>k</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
      <ci>T</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>C</ci>
       <ci>k</ci>
      </apply>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>m</ci>
        <apply>
         <plus></plus>
         <ci>k</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>m</ci>
        <ci>k</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>σ</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle\left(\frac{m_{k+2}-m_{k+1}}{\sigma_{k+1}}\right)^{T}\!C_{k}^{-1}%
\frac{m_{k+1}-m_{k}}{\sigma_{k}}\approx 0
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>

<p>Finally, the <a href="covariance_matrix" title="wikilink">covariance matrix</a> is updated, where again the respective evolution path is updated first.</p>
<dl>
<dd><dl>
<dd><math>
</math></dd>
</dl>
</dd>
</dl>

<p><code> p_c \gets \underbrace{(1-c_c)}_{\!\!\!\!\!\text{discount factor}\!\!\!\!\!}\, </code><br/>
<code>           p_c + </code><br/>
<code>    \underbrace{\mathbf{1}_{[0,\alpha\sqrt{n}]}(\|p_\sigma\|)}_{\text{indicator function}} </code><br/>
<code>    \overbrace{\sqrt{1 - (1-c_c)^2}}^{</code><br/>
<code>    \!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\text{complements for discounted variance}</code><br/>
<code>    \!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!}</code><br/>
<code>    \underbrace{\sqrt{\mu_w} </code><br/>
<code>    \, \frac{m_{k+1} - m_k}{\sigma_k}}_{\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!</code><br/>
<code>                     \text{distributed as}\; \mathcal{N}(0,C_k)\;\text{under neutral selection}</code><br/>
<code>                     \!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!}</code><br/>
<code> </code></p>
<dl>
<dd><dl>
<dd><math>
</math></dd>
</dl>
</dd>
</dl>

<p><code> C_{k+1} = \underbrace{(1 - c_1 - c_\mu + c_s)}_{\!\!\!\!\!\text{discount factor}\!\!\!\!\!}</code><br/>
<code>              \, C_k + c_1 \underbrace{p_c p_c^T}_{</code><br/>
<code>  \!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!</code><br/>
<code>  \text{rank one matrix}</code><br/>
<code>  \!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!} </code><br/>
<code>        + \,c_\mu \underbrace{\sum_{i=1}^\mu w_i \frac{x_{i:\lambda} - m_k}{\sigma_k} </code><br/>
<code>            \left( \frac{x_{i:\lambda} - m_k}{\sigma_k} \right)^T}_{</code><br/>
<code>                    \text{rank} \;\min(\mu,n)\; \text{matrix}}</code><br/>
<code> </code></p>

<p>where 

<math display="inline" id="CMA-ES:86">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

 denotes the transpose and</p>

<p>

<math display="block" id="CMA-ES:87">
 <semantics>
  <mrow>
   <msubsup>
    <mi>c</mi>
    <mi>c</mi>
    <mrow>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msubsup>
   <mo>≈</mo>
   <mrow>
    <mi>n</mi>
    <mo>/</mo>
    <mn>4</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>c</ci>
      <ci>c</ci>
     </apply>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <ci>n</ci>
     <cn type="integer">4</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{c}^{-1}\approx n/4
  </annotation>
 </semantics>
</math>

 is the backward time horizon for the evolution path 

<math display="inline" id="CMA-ES:88">
 <semantics>
  <msub>
   <mi>p</mi>
   <mi>c</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>p</ci>
    <ci>c</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{c}
  </annotation>
 </semantics>
</math>

 and larger than one,</p>

<p>

<math display="block" id="CMA-ES:89">
 <semantics>
  <mrow>
   <mi>α</mi>
   <mo>≈</mo>
   <mn>1.5</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <ci>α</ci>
    <cn type="float">1.5</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha\approx 1.5
  </annotation>
 </semantics>
</math>

 and the <a href="indicator_function" title="wikilink">indicator function</a> 

<math display="inline" id="CMA-ES:90">
 <semantics>
  <mrow>
   <msub>
    <mn>𝟏</mn>
    <mrow>
     <mo stretchy="false">[</mo>
     <mn>0</mn>
     <mo>,</mo>
     <mrow>
      <mi>α</mi>
      <msqrt>
       <mi>n</mi>
      </msqrt>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo>∥</mo>
     <msub>
      <mi>p</mi>
      <mi>σ</mi>
     </msub>
     <mo>∥</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <cn type="integer">1</cn>
     <interval closure="closed">
      <cn type="integer">0</cn>
      <apply>
       <times></times>
       <ci>α</ci>
       <apply>
        <root></root>
        <ci>n</ci>
       </apply>
      </apply>
     </interval>
    </apply>
    <apply>
     <csymbol cd="latexml">norm</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>p</ci>
      <ci>σ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{1}_{[0,\alpha\sqrt{n}]}(\|p_{\sigma}\|)
  </annotation>
 </semantics>
</math>

 evaluates to one <a href="if_and_only_if" title="wikilink">iff</a> 

<math display="inline" id="CMA-ES:91">
 <semantics>
  <mrow>
   <mrow>
    <mo>∥</mo>
    <msub>
     <mi>p</mi>
     <mi>σ</mi>
    </msub>
    <mo>∥</mo>
   </mrow>
   <mo>∈</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mrow>
     <mi>α</mi>
     <msqrt>
      <mi>n</mi>
     </msqrt>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="latexml">norm</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>p</ci>
      <ci>σ</ci>
     </apply>
    </apply>
    <interval closure="closed">
     <cn type="integer">0</cn>
     <apply>
      <times></times>
      <ci>α</ci>
      <apply>
       <root></root>
       <ci>n</ci>
      </apply>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \|p_{\sigma}\|\in[0,\alpha\sqrt{n}]
  </annotation>
 </semantics>
</math>

 or, in other words, 

<math display="inline" id="CMA-ES:92">
 <semantics>
  <mrow>
   <mrow>
    <mo>∥</mo>
    <msub>
     <mi>p</mi>
     <mi>σ</mi>
    </msub>
    <mo>∥</mo>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mi>α</mi>
    <msqrt>
     <mi>n</mi>
    </msqrt>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <csymbol cd="latexml">norm</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>p</ci>
      <ci>σ</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>α</ci>
     <apply>
      <root></root>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \|p_{\sigma}\|\leq\alpha\sqrt{n}
  </annotation>
 </semantics>
</math>

, which is usually the case,</p>

<p>

<math display="block" id="CMA-ES:93">
 <semantics>
  <mrow>
   <msub>
    <mi>c</mi>
    <mi>s</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mn>1</mn>
      <mo>-</mo>
      <mrow>
       <msub>
        <mn>𝟏</mn>
        <mrow>
         <mo stretchy="false">[</mo>
         <mn>0</mn>
         <mo>,</mo>
         <mrow>
          <mi>α</mi>
          <msqrt>
           <mi>n</mi>
          </msqrt>
         </mrow>
         <mo stretchy="false">]</mo>
        </mrow>
       </msub>
       <msup>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mo>∥</mo>
          <msub>
           <mi>p</mi>
           <mi>σ</mi>
          </msub>
          <mo>∥</mo>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
        <mn>2</mn>
       </msup>
      </mrow>
     </mrow>
     <mo rspace="4.2pt" stretchy="false">)</mo>
    </mrow>
    <msub>
     <mi>c</mi>
     <mn>1</mn>
    </msub>
    <msub>
     <mi>c</mi>
     <mi>c</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mn>2</mn>
      <mo>-</mo>
      <msub>
       <mi>c</mi>
       <mi>c</mi>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>c</ci>
     <ci>s</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <cn type="integer">1</cn>
        <interval closure="closed">
         <cn type="integer">0</cn>
         <apply>
          <times></times>
          <ci>α</ci>
          <apply>
           <root></root>
           <ci>n</ci>
          </apply>
         </apply>
        </interval>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="latexml">norm</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>p</ci>
          <ci>σ</ci>
         </apply>
        </apply>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>c</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>c</ci>
      <ci>c</ci>
     </apply>
     <apply>
      <minus></minus>
      <cn type="integer">2</cn>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>c</ci>
       <ci>c</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{s}=(1-\mathbf{1}_{[0,\alpha\sqrt{n}]}(\|p_{\sigma}\|)^{2})\,c_{1}c_{c}(2-c_%
{c})
  </annotation>
 </semantics>
</math>

 makes partly up for the small variance loss in case the indicator is zero,</p>

<p>

<math display="block" id="CMA-ES:94">
 <semantics>
  <mrow>
   <msub>
    <mi>c</mi>
    <mn>1</mn>
   </msub>
   <mo>≈</mo>
   <mrow>
    <mn>2</mn>
    <mo>/</mo>
    <msup>
     <mi>n</mi>
     <mn>2</mn>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>c</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <divide></divide>
     <cn type="integer">2</cn>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>n</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{1}\approx 2/n^{2}
  </annotation>
 </semantics>
</math>

 is the learning rate for the rank-one update of the <a href="covariance_matrix" title="wikilink">covariance matrix</a> and</p>

<p>

<math display="block" id="CMA-ES:95">
 <semantics>
  <mrow>
   <msub>
    <mi>c</mi>
    <mi>μ</mi>
   </msub>
   <mo>≈</mo>
   <mrow>
    <msub>
     <mi>μ</mi>
     <mi>w</mi>
    </msub>
    <mo>/</mo>
    <msup>
     <mi>n</mi>
     <mn>2</mn>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>c</ci>
     <ci>μ</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>μ</ci>
      <ci>w</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>n</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{\mu}\approx\mu_{w}/n^{2}
  </annotation>
 </semantics>
</math>

 is the learning rate for the rank-

<math display="inline" id="CMA-ES:96">
 <semantics>
  <mi>μ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>μ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu
  </annotation>
 </semantics>
</math>

 update of the <a href="covariance_matrix" title="wikilink">covariance matrix</a> and must not exceed 

<math display="inline" id="CMA-ES:97">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>-</mo>
   <msub>
    <mi>c</mi>
    <mn>1</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <cn type="integer">1</cn>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>c</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1-c_{1}
  </annotation>
 </semantics>
</math>

.</p>

<p>The <a href="covariance_matrix" title="wikilink">covariance matrix</a> update tends to increase the <a href="Likelihood_function" title="wikilink">likelihood</a> for 

<math display="inline" id="CMA-ES:98">
 <semantics>
  <msub>
   <mi>p</mi>
   <mi>c</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>p</ci>
    <ci>c</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{c}
  </annotation>
 </semantics>
</math>

 and for 

<math display="inline" id="CMA-ES:99">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msub>
      <mi>x</mi>
      <mrow>
       <mi>i</mi>
       <mo>:</mo>
       <mi>λ</mi>
      </mrow>
     </msub>
     <mo>-</mo>
     <msub>
      <mi>m</mi>
      <mi>k</mi>
     </msub>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>/</mo>
   <msub>
    <mi>σ</mi>
    <mi>k</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <apply>
       <ci>normal-:</ci>
       <ci>i</ci>
       <ci>λ</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>m</ci>
      <ci>k</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>σ</ci>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x_{i:\lambda}-m_{k})/\sigma_{k}
  </annotation>
 </semantics>
</math>

 to be sampled from 

<math display="inline" id="CMA-ES:100">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">𝒩</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>0</mn>
    <mo>,</mo>
    <msub>
     <mi>C</mi>
     <mrow>
      <mi>k</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>𝒩</ci>
    <interval closure="open">
     <cn type="integer">0</cn>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>C</ci>
      <apply>
       <plus></plus>
       <ci>k</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{N}(0,C_{k+1})
  </annotation>
 </semantics>
</math>

. This completes the iteration step.</p>

<p>The number of candidate samples per iteration, 

<math display="inline" id="CMA-ES:101">
 <semantics>
  <mi>λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda
  </annotation>
 </semantics>
</math>

, is not determined a priori and can vary in a wide range. Smaller values, for example 

<math display="inline" id="CMA-ES:102">
 <semantics>
  <mrow>
   <mi>λ</mi>
   <mo>=</mo>
   <mn>10</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>λ</ci>
    <cn type="integer">10</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda=10
  </annotation>
 </semantics>
</math>

, lead to more local search behavior. Larger values, for example 

<math display="inline" id="CMA-ES:103">
 <semantics>
  <mrow>
   <mi>λ</mi>
   <mo>=</mo>
   <mrow>
    <mn>10</mn>
    <mi>n</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>λ</ci>
    <apply>
     <times></times>
     <cn type="integer">10</cn>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda=10n
  </annotation>
 </semantics>
</math>

 with default value 

<math display="inline" id="CMA-ES:104">
 <semantics>
  <mrow>
   <msub>
    <mi>μ</mi>
    <mi>w</mi>
   </msub>
   <mo>≈</mo>
   <mrow>
    <mi>λ</mi>
    <mo>/</mo>
    <mn>4</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>μ</ci>
     <ci>w</ci>
    </apply>
    <apply>
     <divide></divide>
     <ci>λ</ci>
     <cn type="integer">4</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu_{w}\approx\lambda/4
  </annotation>
 </semantics>
</math>

, render the search more global. Sometimes the algorithm is repeatedly restarted with increasing 

<math display="inline" id="CMA-ES:105">
 <semantics>
  <mi>λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda
  </annotation>
 </semantics>
</math>

 by a factor of two for each restart.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> Besides of setting 

<math display="inline" id="CMA-ES:106">
 <semantics>
  <mi>λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda
  </annotation>
 </semantics>
</math>

 (or possibly 

<math display="inline" id="CMA-ES:107">
 <semantics>
  <mi>μ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>μ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu
  </annotation>
 </semantics>
</math>

 instead, if for example 

<math display="inline" id="CMA-ES:108">
 <semantics>
  <mi>λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda
  </annotation>
 </semantics>
</math>

 is predetermined by the number of available processors), the above introduced parameters are not specific to the given objective function and therefore not meant to be modified by the user.</p>
<h2 id="example-code-in-matlaboctave">Example code in MATLAB/Octave</h2>
<div class="sourceCode"><pre class="sourceCode matlab"><code class="sourceCode matlab">function xmin=purecmaes   <span class="co">% (mu/mu_w, lambda)-CMA-ES</span>

  <span class="co">% --------------------  Initialization --------------------------------  </span>
  <span class="co">% User defined input parameters (need to be edited)</span>
  strfitnessfct = <span class="st">'frosenbrock'</span>;  <span class="co">% name of objective/fitness function</span>
  N = <span class="fl">20</span>;               <span class="co">% number of objective variables/problem dimension</span>
  xmean = rand(N,<span class="fl">1</span>);    <span class="co">% objective variables initial point</span>
  sigma = <span class="fl">0.3</span>;          <span class="co">% coordinate wise standard deviation (step size)</span>
  stopfitness = <span class="fl">1e-10</span>;  <span class="co">% stop if fitness &lt; stopfitness (minimization)</span>
  stopeval = <span class="fl">1e3</span>*N^<span class="fl">2</span>;   <span class="co">% stop after stopeval number of function evaluations</span>
  
  <span class="co">% Strategy parameter setting: Selection  </span>
  lambda = <span class="fl">4</span>+floor(<span class="fl">3</span>*log(N));  <span class="co">% population size, offspring number</span>
  mu = lambda/<span class="fl">2</span>;               <span class="co">% number of parents/points for recombination</span>
  weights = log(mu+<span class="fl">1</span>/<span class="fl">2</span>)-log(<span class="fl">1</span>:mu)'; <span class="co">% muXone array for weighted recombination</span>
  mu = floor(mu);        
  weights = weights/sum(weights);     <span class="co">% normalize recombination weights array</span>
  mueff=sum(weights)^<span class="fl">2</span>/sum(weights.^<span class="fl">2</span>); <span class="co">% variance-effectiveness of sum w_i x_i</span>

  <span class="co">% Strategy parameter setting: Adaptation</span>
  cc = (<span class="fl">4</span>+mueff/N) / (N+<span class="fl">4</span> + <span class="fl">2</span>*mueff/N);  <span class="co">% time constant for cumulation for C</span>
  cs = (mueff+<span class="fl">2</span>) / (N+mueff+<span class="fl">5</span>);  <span class="co">% t-const for cumulation for sigma control</span>
  c1 = <span class="fl">2</span> / ((N+<span class="fl">1.3</span>)^<span class="fl">2</span>+mueff);    <span class="co">% learning rate for rank-one update of C</span>
  cmu = min(<span class="fl">1</span>-c1, <span class="fl">2</span> * (mueff-<span class="fl">2</span>+<span class="fl">1</span>/mueff) / ((N+<span class="fl">2</span>)^<span class="fl">2</span>+mueff));  <span class="co">% and for rank-mu update</span>
  damps = <span class="fl">1</span> + <span class="fl">2</span>*max(<span class="fl">0</span>, sqrt((mueff-<span class="fl">1</span>)/(N+<span class="fl">1</span>))-<span class="fl">1</span>) + cs; <span class="co">% damping for sigma </span>
                                                      <span class="co">% usually close to 1</span>
  <span class="co">% Initialize dynamic (internal) strategy parameters and constants</span>
  pc = zeros(N,<span class="fl">1</span>); ps = zeros(N,<span class="fl">1</span>);   <span class="co">% evolution paths for C and sigma</span>
  B = eye(N,N);                       <span class="co">% B defines the coordinate system</span>
  D = ones(N,<span class="fl">1</span>);                      <span class="co">% diagonal D defines the scaling</span>
  C = B * diag(D.^<span class="fl">2</span>) * B';            <span class="co">% covariance matrix C</span>
  invsqrtC = B * diag(D.^-<span class="fl">1</span>) * B';    <span class="co">% C^-1/2 </span>
  eigeneval = <span class="fl">0</span>;                      <span class="co">% track update of B and D</span>
  chiN=N^<span class="fl">0.5</span>*(<span class="fl">1</span>-<span class="fl">1</span>/(<span class="fl">4</span>*N)+<span class="fl">1</span>/(<span class="fl">21</span>*N^<span class="fl">2</span>));  <span class="co">% expectation of </span>
                                      <span class="co">%   ||N(0,I)|| == norm(randn(N,1))</span>
  
  <span class="co">% -------------------- Generation Loop --------------------------------</span>
  counteval = <span class="fl">0</span>;  <span class="co">% the next 40 lines contain the 20 lines of interesting code </span>
  while counteval &lt; stopeval
    
      <span class="co">% Generate and evaluate lambda offspring</span>
      for k=<span class="fl">1</span>:lambda,
          arx(:,k) = xmean + sigma * B * (D .* randn(N,<span class="fl">1</span>)); <span class="co">% m + sig * Normal(0,C) </span>
          arfitness(k) = feval(strfitnessfct, arx(:,k)); <span class="co">% objective function call</span>
          counteval = counteval+<span class="fl">1</span>;
      end
    
      <span class="co">% Sort by fitness and compute weighted mean into xmean</span>
      [arfitness, arindex] = sort(arfitness); <span class="co">% minimization</span>
      xold = xmean;
      xmean = arx(:,arindex(<span class="fl">1</span>:mu))*weights;   <span class="co">% recombination, new mean value</span>
    
      <span class="co">% Cumulation: Update evolution paths</span>
      ps = (<span class="fl">1</span>-cs)*ps ... 
            + sqrt(cs*(<span class="fl">2</span>-cs)*mueff) * invsqrtC * (xmean-xold) / sigma; 
      hsig = norm(ps)/sqrt(<span class="fl">1</span>-(<span class="fl">1</span>-cs)^(<span class="fl">2</span>*counteval/lambda))/chiN &lt; <span class="fl">1.4</span> + <span class="fl">2</span>/(N+<span class="fl">1</span>);
      pc = (<span class="fl">1</span>-cc)*pc ...
            + hsig * sqrt(cc*(<span class="fl">2</span>-cc)*mueff) * (xmean-xold) / sigma;

      <span class="co">% Adapt covariance matrix C</span>
      artmp = (<span class="fl">1</span>/sigma) * (arx(:,arindex(<span class="fl">1</span>:mu))-repmat(xold,<span class="fl">1</span>,mu));
      C = (<span class="fl">1</span>-c1-cmu) * C ...                  <span class="co">% regard old matrix  </span>
           + c1 * (pc*pc' ...                 <span class="co">% plus rank one update</span>
                   + (<span class="fl">1</span>-hsig) * cc*(<span class="fl">2</span>-cc) * C) ... <span class="co">% minor correction if hsig==0</span>
           + cmu * artmp * diag(weights) * artmp'; <span class="co">% plus rank mu update</span>

      <span class="co">% Adapt step size sigma</span>
      sigma = sigma * exp((cs/damps)*(norm(ps)/chiN - <span class="fl">1</span>)); 
    
      <span class="co">% Decomposition of C into B*diag(D.^2)*B' (diagonalization)</span>
      if counteval - eigeneval &gt; lambda/(c1+cmu)/N/<span class="fl">10</span>  <span class="co">% to achieve O(N^2)</span>
          eigeneval = counteval;
          C = triu(C) + triu(C,<span class="fl">1</span>)'; <span class="co">% enforce symmetry</span>
          [B,D] = eig(C);           <span class="co">% eigen decomposition, B==normalized eigenvectors</span>
          D = sqrt(diag(D));        <span class="co">% D is a vector of standard deviations now</span>
          invsqrtC = B * diag(D.^-<span class="fl">1</span>) * B';
      end
    
      <span class="co">% Break, if fitness is good enough or condition exceeds 1e14, better termination methods are advisable </span>
      if arfitness(<span class="fl">1</span>) &lt;= stopfitness || max(D) &gt; <span class="fl">1e7</span> * min(D)
          break;
      end

  end <span class="co">% while, end generation loop</span>

  xmin = arx(:, arindex(<span class="fl">1</span>)); <span class="co">% Return best point of last iteration.</span>
                             <span class="co">% Notice that xmean is expected to be even</span>
                             <span class="co">% better.</span>
  
<span class="co">% ---------------------------------------------------------------  </span>
function f=frosenbrock(x)
    if size(x,<span class="fl">1</span>) &lt; <span class="fl">2</span> error(<span class="st">'dimension must be greater one'</span>); end
    f = <span class="fl">100</span>*sum((x(<span class="fl">1</span>:end-<span class="fl">1</span>).^<span class="fl">2</span> - x(<span class="fl">2</span>:end)).^<span class="fl">2</span>) + sum((x(<span class="fl">1</span>:end-<span class="fl">1</span>)-<span class="fl">1</span>).^<span class="fl">2</span>);</code></pre></div>
<h2 id="theoretical-foundations">Theoretical Foundations</h2>

<p>Given the distribution parameters—mean, variances and covariances—the <a href="multivariate_normal_distribution" title="wikilink">normal probability distribution</a> for sampling new candidate solutions is the <a href="maximum_entropy_probability_distribution" title="wikilink">maximum entropy probability distribution</a> over 

<math display="inline" id="CMA-ES:109">
 <semantics>
  <msup>
   <mi>ℝ</mi>
   <mi>n</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>ℝ</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{R}^{n}
  </annotation>
 </semantics>
</math>

, that is, the sample distribution with the minimal amount of prior information built into the distribution. More considerations on the update equations of CMA-ES are made in the following.</p>
<h3 id="variable-metric">Variable Metric</h3>

<p>The CMA-ES implements a stochastic <a class="uri" href="variable-metric" title="wikilink">variable-metric</a> method. In the very particular case of a convex-quadratic objective function</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="CMA-ES:110">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mn>2</mn>
    </mfrac>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>x</mi>
       <mo>-</mo>
       <msup>
        <mi>x</mi>
        <mo>*</mo>
       </msup>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>T</mi>
    </msup>
    <mi>H</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>x</mi>
      <mo>-</mo>
      <msup>
       <mi>x</mi>
       <mo>*</mo>
      </msup>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <minus></minus>
       <ci>x</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>x</ci>
        <times></times>
       </apply>
      </apply>
      <ci>T</ci>
     </apply>
     <ci>H</ci>
     <apply>
      <minus></minus>
      <ci>x</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <times></times>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x)={\textstyle\frac{1}{2}}(x-x^{*})^{T}H(x-x^{*})
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>the covariance matrix 

<math display="inline" id="CMA-ES:111">
 <semantics>
  <msub>
   <mi>C</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>C</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{k}
  </annotation>
 </semantics>
</math>

 adapts to the inverse of the <a href="Hessian_matrix" title="wikilink">Hessian matrix</a> 

<math display="inline" id="CMA-ES:112">
 <semantics>
  <mi>H</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>H</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H
  </annotation>
 </semantics>
</math>

, <a href="up_to" title="wikilink">up to</a> a scalar factor and small random fluctuations. More general, also on the function 

<math display="inline" id="CMA-ES:113">
 <semantics>
  <mrow>
   <mi>g</mi>
   <mo>∘</mo>
   <mi>f</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <compose></compose>
    <ci>g</ci>
    <ci>f</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g\circ f
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="CMA-ES:114">
 <semantics>
  <mi>g</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>g</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g
  </annotation>
 </semantics>
</math>

 is strictly increasing and therefore order preserving and 

<math display="inline" id="CMA-ES:115">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 is convex-quadratic, the covariance matrix 

<math display="inline" id="CMA-ES:116">
 <semantics>
  <msub>
   <mi>C</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>C</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{k}
  </annotation>
 </semantics>
</math>

 adapts to 

<math display="inline" id="CMA-ES:117">
 <semantics>
  <msup>
   <mi>H</mi>
   <mrow>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>H</ci>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H^{-1}
  </annotation>
 </semantics>
</math>

, <a href="up_to" title="wikilink">up to</a> a scalar factor and small random fluctuations.</p>
<h3 id="maximum-likelihood-updates">Maximum-Likelihood Updates</h3>

<p>The update equations for mean and covariance matrix maximize a <a class="uri" href="likelihood" title="wikilink">likelihood</a> while resembling an <a href="Expectation_maximization" title="wikilink">expectation-maximization</a> algorithm. The update of the mean vector 

<math display="inline" id="CMA-ES:118">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

 maximizes a log-likelihood, such that</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="CMA-ES:119">
 <semantics>
  <mrow>
   <msub>
    <mi>m</mi>
    <mrow>
     <mi>k</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo>=</mo>
   <mi>arg</mi>
   <msub>
    <mi>max</mi>
    <mi>m</mi>
   </msub>
   <msubsup>
    <mo largeop="true" symmetric="true">∑</mo>
    <mrow>
     <mi>i</mi>
     <mo>=</mo>
     <mn>1</mn>
    </mrow>
    <mi>μ</mi>
   </msubsup>
   <msub>
    <mi>w</mi>
    <mi>i</mi>
   </msub>
   <mi>log</mi>
   <msub>
    <mi>p</mi>
    <mi class="ltx_font_mathcaligraphic">𝒩</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mrow>
      <mi>i</mi>
      <mo>:</mo>
      <mi>λ</mi>
     </mrow>
    </msub>
    <mo stretchy="false">|</mo>
    <mi>m</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>m</ci>
     <apply>
      <plus></plus>
      <ci>k</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <eq></eq>
    <arg></arg>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <max></max>
     <ci>m</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <eq></eq>
       <ci>i</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>μ</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>w</ci>
     <ci>i</ci>
    </apply>
    <log></log>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>p</ci>
     <ci>𝒩</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <apply>
       <ci>normal-:</ci>
       <ci>i</ci>
       <ci>λ</ci>
      </apply>
     </apply>
     <ci>normal-|</ci>
     <csymbol cd="unknown">m</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m_{k+1}=\arg\max_{m}\sum_{i=1}^{\mu}w_{i}\log p_{\mathcal{N}}(x_{i:\lambda}|m)
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>where</p>
<dl>
<dd><dl>
<dd><math> \log p_\mathcal{N}(x) =
</math></dd>
</dl>
</dd>
</dl>

<p><code>  - \frac{1}{2} \log\det(2\pi C) - \frac{1}{2} (x-m)^T C^{-1} (x-m) </code></p>

<p>denotes the log-likelihood of 

<math display="inline" id="CMA-ES:120">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 from a multivariate normal distribution with mean 

<math display="inline" id="CMA-ES:121">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

 and any positive definite covariance matrix 

<math display="inline" id="CMA-ES:122">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

. To see that 

<math display="inline" id="CMA-ES:123">
 <semantics>
  <msub>
   <mi>m</mi>
   <mrow>
    <mi>k</mi>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>m</ci>
    <apply>
     <plus></plus>
     <ci>k</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m_{k+1}
  </annotation>
 </semantics>
</math>

 is independent of 

<math display="inline" id="CMA-ES:124">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

 remark first that this is the case for any diagonal matrix 

<math display="inline" id="CMA-ES:125">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

, because the coordinate-wise maximizer is independent of a scaling factor. Then, rotation of the data points or choosing 

<math display="inline" id="CMA-ES:126">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

 non-diagonal are equivalent.</p>

<p>The rank-

<math display="inline" id="CMA-ES:127">
 <semantics>
  <mi>μ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>μ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu
  </annotation>
 </semantics>
</math>

 update of the covariance matrix, that is, the right most summand in the update equation of 

<math display="inline" id="CMA-ES:128">
 <semantics>
  <msub>
   <mi>C</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>C</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{k}
  </annotation>
 </semantics>
</math>

, maximizes a log-likelihood in that</p>
<dl>
<dd><dl>
<dd><math> \sum_{i=1}^\mu w_i \frac{x_{i:\lambda} - m_k}{\sigma_k}
</math></dd>
</dl>
</dd>
</dl>

<p><code>            \left( \frac{x_{i:\lambda} - m_k}{\sigma_k} \right)^T </code><br/>
<code>    = \arg\max_{C} \sum_{i=1}^\mu w_i \log p_\mathcal{N}\left(\left.\frac{x_{i:\lambda} - m_k}{\sigma_k} \right| C\right) </code></p>

<p>for 

<math display="inline" id="CMA-ES:129">
 <semantics>
  <mrow>
   <mi>μ</mi>
   <mo>≥</mo>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <ci>μ</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu\geq n
  </annotation>
 </semantics>
</math>

 (otherwise 

<math display="inline" id="CMA-ES:130">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

 is singular, but substantially the same result holds for 

<math display="inline" id="CMA-ES:131">
 <semantics>
  <mrow>
   <mi>μ</mi>
   <mo><</mo>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <ci>μ</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu<n
  </annotation>
 </semantics>
</math>

). Here, 

<math display="inline" id="CMA-ES:132">
 <semantics>
  <mrow>
   <msub>
    <mi>p</mi>
    <mi class="ltx_font_mathcaligraphic">𝒩</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">|</mo>
    <mi>C</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>p</ci>
     <ci>𝒩</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">C</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{\mathcal{N}}(x|C)
  </annotation>
 </semantics>
</math>

 denotes the likelihood of 

<math display="inline" id="CMA-ES:133">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 from a multivariate normal distribution with zero mean and covariance matrix 

<math display="inline" id="CMA-ES:134">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

. Therefore, for 

<math display="inline" id="CMA-ES:135">
 <semantics>
  <mrow>
   <msub>
    <mi>c</mi>
    <mn>1</mn>
   </msub>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>c</ci>
     <cn type="integer">1</cn>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{1}=0
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="CMA-ES:136">
 <semantics>
  <mrow>
   <msub>
    <mi>c</mi>
    <mi>μ</mi>
   </msub>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>c</ci>
     <ci>μ</ci>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{\mu}=1
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="CMA-ES:137">
 <semantics>
  <msub>
   <mi>C</mi>
   <mrow>
    <mi>k</mi>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>C</ci>
    <apply>
     <plus></plus>
     <ci>k</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{k+1}
  </annotation>
 </semantics>
</math>

 is the above <a class="uri" href="maximum-likelihood" title="wikilink">maximum-likelihood</a> estimator. See <a href="estimation_of_covariance_matrices" title="wikilink">estimation of covariance matrices</a> for details on the derivation.</p>
<h3 id="natural-gradient-descent-in-the-space-of-sample-distributions">Natural Gradient Descent in the Space of Sample Distributions</h3>

<p>Akimoto <em>et al.</em><a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> and Glasmachers <em>et al.</em><a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> discovered independently that the update of the distribution parameters resembles the descend in direction of a sampled <a href="Information_geometry#Natural_gradient" title="wikilink">natural gradient</a> of the expected objective function value <mtpl> (to be minimized), where the expectation is taken under the sample distribution. With the parameter setting of 

<math display="inline" id="CMA-ES:138">
 <semantics>
  <mrow>
   <msub>
    <mi>c</mi>
    <mi>σ</mi>
   </msub>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>c</ci>
     <ci>σ</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{\sigma}=0
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="CMA-ES:139">
 <semantics>
  <mrow>
   <msub>
    <mi>c</mi>
    <mn>1</mn>
   </msub>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>c</ci>
     <cn type="integer">1</cn>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{1}=0
  </annotation>
 </semantics>
</math>

, i.e. without step-size control and rank-one update, CMA-ES can thus be viewed as an instantiation of <a href="Natural_Evolution_Strategies" title="wikilink">Natural Evolution Strategies</a> (NES).<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a><a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> The natural gradient is independent of the parameterization of the distribution. Taken with respect to the parameters <mtpl></mtpl> of the sample distribution <mtpl></mtpl>, the gradient of <mtpl> can be expressed as</mtpl></mtpl></p>
<dl>
<dd><dl>
<dd><math> \begin{align}
</math></dd>
</dl>
</dd>
</dl>

<p><code> {\nabla}_{\!\theta} E(f(x) | \theta) </code><br/>
<code>    &amp;= \nabla_{\!\theta} \int_{\mathbb R^n}f(x) p(x) \mathrm{d}x</code><br/>
<code> \\ &amp;= \int_{\mathbb R^n}f(x) \nabla_{\!\theta} p(x) \mathrm{d}x</code><br/>
<code> \\ &amp;= \int_{\mathbb R^n}f(x) p(x) \nabla_{\!\theta} \ln p(x) \mathrm{d}x</code><br/>
<code> \\ &amp;= E(f(x) \nabla_{\!\theta} \ln p(x|\theta))</code></p>

<p>\end{align}</p>

<p>where 

<math display="inline" id="CMA-ES:140">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">|</mo>
    <mi>θ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">θ</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(x)=p(x|\theta)
  </annotation>
 </semantics>
</math>

 depends on the parameter vector 

<math display="inline" id="CMA-ES:141">
 <semantics>
  <mi>θ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>θ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta
  </annotation>
 </semantics>
</math>

, the so-called <a href="Score_(statistics)" title="wikilink">score function</a>, 

<math display="inline" id="CMA-ES:142">
 <semantics>
  <mrow>
   <msub>
    <mo>∇</mo>
    <mpadded lspace="-1.7pt" width="-1.7pt">
     <mi>θ</mi>
    </mpadded>
   </msub>
   <mi>ln</mi>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">|</mo>
    <mi>θ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mrow>
      <msub>
       <mo>∇</mo>
       <mpadded lspace="-1.7pt" width="-1.7pt">
        <mi>θ</mi>
       </mpadded>
      </msub>
      <mi>p</mi>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mrow>
     <mi>p</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-∇</ci>
     <ci>θ</ci>
    </apply>
    <ln></ln>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">θ</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>normal-∇</ci>
        <ci>θ</ci>
       </apply>
       <ci>p</ci>
      </apply>
      <ci>x</ci>
     </apply>
     <apply>
      <times></times>
      <ci>p</ci>
      <ci>x</ci>
     </apply>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \nabla_{\!\theta}\ln p(x|\theta)=\frac{\nabla_{\!\theta}p(x)}{p(x)}
  </annotation>
 </semantics>
</math>

, indicates the relative sensitivity of <mtpl></mtpl> w.r.t. <mtpl></mtpl>, and the expectation is taken with respect to the distribution <mtpl></mtpl>. The <a href="Information_geometry#Natural_gradient" title="wikilink"><em>natural</em> gradient</a> of <mtpl>, complying with the <a href="Fisher_information_metric" title="wikilink">Fisher information metric</a> (an informational distance measure between probability distributions and the curvature of the <a href="relative_entropy" title="wikilink">relative entropy</a>), now reads</mtpl></p>
<dl>
<dd><dl>
<dd><math> \begin{align}
</math></dd>
</dl>
</dd>
</dl>

<p><code> \tilde{\nabla} E(f(x) | \theta) </code><br/>
<code> &amp;= F^{-1}_\theta \nabla_{\!\theta} E(f(x) | \theta) </code></p>

<p>\end{align}</p>

<p>where the <a href="Fisher_information" title="wikilink">Fisher information</a> matrix 

<math display="inline" id="CMA-ES:143">
 <semantics>
  <msub>
   <mi>F</mi>
   <mi>θ</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>F</ci>
    <ci>θ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F_{\theta}
  </annotation>
 </semantics>
</math>

 is the expectation of the <a href="Hessian_matrix" title="wikilink">Hessian</a> of <mtpl></mtpl> and renders the expression independent of the chosen parameterization. Combining the previous equalities we get</p>
<dl>
<dd><dl>
<dd><math> \begin{align}
</math></dd>
</dl>
</dd>
</dl>

<p><code> \tilde{\nabla} E(f(x) | \theta) </code><br/>
<code> &amp;= F^{-1}_\theta E(f(x) \nabla_{\!\theta} \ln p(x|\theta))</code><br/>
<code> \\ &amp;= E(f(x) F^{-1}_\theta \nabla_{\!\theta} \ln p(x|\theta))</code></p>

<p>\end{align}</p>

<p>A Monte Carlo approximation of the latter expectation takes the average over <mtpl></mtpl> samples from <mtpl></mtpl></p>
<dl>
<dd><dl>
<dd><math> \tilde{\nabla} \widehat{E}_\theta(f) := -\sum_{i=1}^\lambda \overbrace{w_i}^{\!\!\!\!\text{preference weight}\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!} \underbrace{F^{-1}_\theta \nabla_{\!\theta} \ln p(x_{i:\lambda}|\theta)}_{\!\!\!\!\!\text{candidate direction from }x_{i:\lambda}\!\!\!\!\!}
</math></dd>
</dl>
</dd>
</dl>

<p>\quad\mathrm{with~}w_i = -f(x_{i:\lambda})/\lambda</p>

<p>where the notation 

<math display="inline" id="CMA-ES:144">
 <semantics>
  <mrow>
   <mi>i</mi>
   <mo>:</mo>
   <mi>λ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>i</ci>
    <ci>λ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i:\lambda
  </annotation>
 </semantics>
</math>

 from above is used and therefore 

<math display="inline" id="CMA-ES:145">
 <semantics>
  <msub>
   <mi>w</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>w</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w_{i}
  </annotation>
 </semantics>
</math>

 are monotonously decreasing in 

<math display="inline" id="CMA-ES:146">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

.</p>

<p>Ollivier <em>et al.</em><a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> finally found a rigorous formulation for the more robust weights, 

<math display="inline" id="CMA-ES:147">
 <semantics>
  <msub>
   <mi>w</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>w</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w_{i}
  </annotation>
 </semantics>
</math>

, as they are defined in the CMA-ES (weights are zero for <mtpl></mtpl>), formulated as consistent estimator for the <a href="Cumulative_distribution_function" title="wikilink">CDF</a> of 

<math display="inline" id="CMA-ES:148">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>,</mo>
   <mi>X</mi>
   <mo>∼</mo>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>.</mo>
    <mo stretchy="false">|</mo>
    <mi>θ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">f</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">X</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-,</ci>
    <csymbol cd="unknown">X</csymbol>
    <csymbol cd="latexml">similar-to</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <ci>normal-.</ci>
     <ci>normal-|</ci>
     <csymbol cd="unknown">θ</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(X),X\sim p(.|\theta)
  </annotation>
 </semantics>
</math>

 at the point 

<math display="inline" id="CMA-ES:149">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mrow>
      <mi>i</mi>
      <mo>:</mo>
      <mi>λ</mi>
     </mrow>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <apply>
      <ci>normal-:</ci>
      <ci>i</ci>
      <ci>λ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x_{i:\lambda})
  </annotation>
 </semantics>
</math>

, composed with a fixed monotonous decreased transformation 

<math display="inline" id="CMA-ES:150">
 <semantics>
  <mi>w</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>w</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w
  </annotation>
 </semantics>
</math>

, i.e.,</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="CMA-ES:151">
 <semantics>
  <mrow>
   <msub>
    <mi>w</mi>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mi>w</mi>
    <mrow>
     <mo>(</mo>
     <mfrac>
      <mrow>
       <mrow>
        <mi>𝗋𝖺𝗇𝗄</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mi>f</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <msub>
            <mi>x</mi>
            <mrow>
             <mi>i</mi>
             <mo>:</mo>
             <mi>λ</mi>
            </mrow>
           </msub>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>-</mo>
       <mrow>
        <mn>1</mn>
        <mo>/</mo>
        <mn>2</mn>
       </mrow>
      </mrow>
      <mi>λ</mi>
     </mfrac>
     <mo>)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>w</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <times></times>
     <ci>w</ci>
     <apply>
      <divide></divide>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <ci>𝗋𝖺𝗇𝗄</ci>
        <apply>
         <times></times>
         <ci>f</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <apply>
           <ci>normal-:</ci>
           <ci>i</ci>
           <ci>λ</ci>
          </apply>
         </apply>
        </apply>
       </apply>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <ci>λ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w_{i}=w\left(\frac{\mathsf{rank}(f(x_{i:\lambda}))-1/2}{\lambda}\right)
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>Let</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="CMA-ES:152">
 <semantics>
  <mrow>
   <mi>θ</mi>
   <mo>=</mo>
   <msup>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <msubsup>
       <mi>m</mi>
       <mi>k</mi>
       <mi>T</mi>
      </msubsup>
      <mi>vec</mi>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>C</mi>
         <mi>k</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
       <mi>T</mi>
      </msup>
      <msub>
       <mi>σ</mi>
       <mi>k</mi>
      </msub>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
    <mi>T</mi>
   </msup>
   <mo>∈</mo>
   <msup>
    <mi>ℝ</mi>
    <mrow>
     <mi>n</mi>
     <mo>+</mo>
     <msup>
      <mi>n</mi>
      <mn>2</mn>
     </msup>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>θ</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>m</ci>
          <ci>k</ci>
         </apply>
         <ci>T</ci>
        </apply>
        <ci>vec</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>C</ci>
          <ci>k</ci>
         </apply>
         <ci>T</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>σ</ci>
         <ci>k</ci>
        </apply>
       </apply>
      </apply>
      <ci>T</ci>
     </apply>
    </apply>
    <apply>
     <in></in>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ℝ</ci>
      <apply>
       <plus></plus>
       <ci>n</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>n</ci>
        <cn type="integer">2</cn>
       </apply>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta=[m_{k}^{T}\mathrm{vec}(C_{k})^{T}\sigma_{k}]^{T}\in\mathbb{R}^{n+n^{2}+1}
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>such that 

<math display="inline" id="CMA-ES:153">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>.</mo>
    <mo stretchy="false">|</mo>
    <mi>θ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <ci>normal-.</ci>
     <ci>normal-|</ci>
     <csymbol cd="unknown">θ</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(.|\theta)
  </annotation>
 </semantics>
</math>

 is the density of the <a href="multivariate_normal_distribution" title="wikilink">multivariate normal distribution</a> 

<math display="inline" id="CMA-ES:154">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">𝒩</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>m</mi>
     <mi>k</mi>
    </msub>
    <mo>,</mo>
    <mrow>
     <msubsup>
      <mi>σ</mi>
      <mi>k</mi>
      <mn>2</mn>
     </msubsup>
     <msub>
      <mi>C</mi>
      <mi>k</mi>
     </msub>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>𝒩</ci>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>m</ci>
      <ci>k</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>σ</ci>
        <ci>k</ci>
       </apply>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>C</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{N}(m_{k},\sigma_{k}^{2}C_{k})
  </annotation>
 </semantics>
</math>

. Then, we have an explicit expression for the inverse of the Fisher information matrix where 

<math display="inline" id="CMA-ES:155">
 <semantics>
  <msub>
   <mi>σ</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>σ</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma_{k}
  </annotation>
 </semantics>
</math>

 is fixed</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="CMA-ES:156">
 <semantics>
  <mrow>
   <msubsup>
    <mi>F</mi>
    <mrow>
     <mi>θ</mi>
     <mo stretchy="false">|</mo>
     <msub>
      <mi>σ</mi>
      <mi>k</mi>
     </msub>
    </mrow>
    <mrow>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msubsup>
   <mo>=</mo>
   <mrow>
    <mo>[</mo>
    <mtable>
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <msubsup>
         <mi>σ</mi>
         <mi>k</mi>
         <mn>2</mn>
        </msubsup>
        <msub>
         <mi>C</mi>
         <mi>k</mi>
        </msub>
       </mrow>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mrow>
        <mrow>
         <mn>2</mn>
         <msub>
          <mi>C</mi>
          <mi>k</mi>
         </msub>
        </mrow>
        <mo>⊗</mo>
        <msub>
         <mi>C</mi>
         <mi>k</mi>
        </msub>
       </mrow>
      </mtd>
     </mtr>
    </mtable>
    <mo>]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>F</ci>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="unknown">θ</csymbol>
      <ci>normal-|</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>σ</ci>
       <ci>k</ci>
      </apply>
     </cerror>
    </apply>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <matrix>
      <matrixrow>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>σ</ci>
          <ci>k</ci>
         </apply>
         <cn type="integer">2</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>C</ci>
         <ci>k</ci>
        </apply>
       </apply>
       <cn type="integer">0</cn>
      </matrixrow>
      <matrixrow>
       <cn type="integer">0</cn>
       <apply>
        <csymbol cd="latexml">tensor-product</csymbol>
        <apply>
         <times></times>
         <cn type="integer">2</cn>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>C</ci>
          <ci>k</ci>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>C</ci>
         <ci>k</ci>
        </apply>
       </apply>
      </matrixrow>
     </matrix>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F^{-1}_{\theta|\sigma_{k}}=\left[\begin{array}[]{cc}\sigma_{k}^{2}C_{k}&0\\
0&2C_{k}\otimes C_{k}\end{array}\right]
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>and for</p>
<dl>
<dd><dl>
<dd><math>\ln p(x|\theta) = \ln p(x|m_k,\sigma_k^2 C_k) = -\frac{1}{2}(x-m_k)^T \sigma_k^{-2} C_k^{-1} (x-m_k)
</math></dd>
</dl>
</dd>
</dl>

<p><code>        \,-\, \frac{1}{2}\ln\det(2\pi\sigma_k^2 C_k)</code></p>

<p>and, after some calculations, the updates in the CMA-ES turn out as<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> <span id="update_in_gradient_formulation"></span></p>
<dl>
<dd><dl>
<dd><math> \begin{align}
</math></dd>
</dl>
</dd>
</dl>

<p><code>  m_{k+1} </code><br/>
<code>    &amp;= m_k - \underbrace{[\tilde{\nabla} \widehat{E}_\theta(f)]_{1,\dots, n}}_{</code><br/>
<code>    \!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!</code><br/>
<code>    \text{natural gradient for mean}</code><br/>
<code>    \!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!</code><br/>
<code>    } </code><br/>
<code>  \\</code><br/>
<code>    &amp;= m_k + \sum_{i=1}^\lambda w_i (x_{i:\lambda} - m_k) </code><br/>
<code>  \end{align} </code></p>

<p>and</p>
<dl>
<dd><dl>
<dd><math> \begin{align}
</math></dd>
</dl>
</dd>
</dl>

<p><code>  C_{k+1} </code><br/>
<code>    &amp;= C_k + c_1(p_c p_c^T - C_k)  </code><br/>
<code>        - c_\mu\,\mathrm{mat}(\overbrace{[\tilde{\nabla} \widehat{E}_\theta(f)]_{n+1,\dots,n+n^2}}^{</code><br/>
<code>    \!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!</code><br/>
<code>       \text{natural gradient for covariance matrix} </code><br/>
<code>    \!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!</code><br/>
<code>    })\\</code><br/>
<code>    &amp;= C_k + c_1(p_c p_c^T - C_k) </code><br/>
<code>       + c_\mu \sum_{i=1}^\lambda w_i \left(\frac{x_{i:\lambda} - m_k}{\sigma_k} \left(\frac{x_{i:\lambda} - m_k}{\sigma_k}\right)^T - C_k\right) </code><br/>
<code>  \end{align}</code></p>

<p></p>

<p>where mat forms the proper matrix from the respective natural gradient sub-vector. That means, setting 

<math display="inline" id="CMA-ES:157">
 <semantics>
  <mrow>
   <msub>
    <mi>c</mi>
    <mn>1</mn>
   </msub>
   <mo>=</mo>
   <msub>
    <mi>c</mi>
    <mi>σ</mi>
   </msub>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>c</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>c</ci>
      <ci>σ</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{1}=c_{\sigma}=0
  </annotation>
 </semantics>
</math>

, the CMA-ES updates descend in direction of the approximation 

<math display="inline" id="CMA-ES:158">
 <semantics>
  <mrow>
   <mover accent="true">
    <mo>∇</mo>
    <mo stretchy="false">~</mo>
   </mover>
   <msub>
    <mover accent="true">
     <mi>E</mi>
     <mo>^</mo>
    </mover>
    <mi>θ</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>f</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <ci>normal-~</ci>
     <ci>normal-∇</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <ci>normal-^</ci>
      <ci>E</ci>
     </apply>
     <ci>θ</ci>
    </apply>
    <ci>f</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tilde{\nabla}\widehat{E}_{\theta}(f)
  </annotation>
 </semantics>
</math>

 of the natural gradient while using different step-sizes (learning rates) for the <a href="Fisher_information#Orthogonal_parameters" title="wikilink">orthogonal parameters</a> 

<math display="inline" id="CMA-ES:159">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="CMA-ES:160">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

 respectively.</p>
<h3 id="stationarity-or-unbiasedness">Stationarity or Unbiasedness</h3>

<p>It is comparatively easy to see that the update equations of CMA-ES satisfy some stationarity conditions, in that they are essentially unbiased. Under neutral selection, where 

<math display="inline" id="CMA-ES:161">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mrow>
     <mi>i</mi>
     <mo>:</mo>
     <mi>λ</mi>
    </mrow>
   </msub>
   <mo>∼</mo>
   <mrow>
    <mi class="ltx_font_mathcaligraphic">𝒩</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>m</mi>
      <mi>k</mi>
     </msub>
     <mo>,</mo>
     <mrow>
      <msubsup>
       <mi>σ</mi>
       <mi>k</mi>
       <mn>2</mn>
      </msubsup>
      <msub>
       <mi>C</mi>
       <mi>k</mi>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">similar-to</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <apply>
      <ci>normal-:</ci>
      <ci>i</ci>
      <ci>λ</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>𝒩</ci>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>m</ci>
       <ci>k</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>σ</ci>
         <ci>k</ci>
        </apply>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>C</ci>
        <ci>k</ci>
       </apply>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i:\lambda}\sim\mathcal{N}(m_{k},\sigma_{k}^{2}C_{k})
  </annotation>
 </semantics>
</math>

, we find that</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="CMA-ES:162">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mpadded width="+1.7pt">
     <msub>
      <mi>m</mi>
      <mrow>
       <mi>k</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </msub>
    </mpadded>
    <mo rspace="4.2pt" stretchy="false">|</mo>
    <msub>
     <mi>m</mi>
     <mi>k</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <msub>
    <mi>m</mi>
    <mi>k</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">E</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>m</ci>
      <apply>
       <plus></plus>
       <ci>k</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>normal-|</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>m</ci>
      <ci>k</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>m</ci>
     <ci>k</ci>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E(m_{k+1}\,|\,m_{k})=m_{k}
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>and under some mild additional assumptions on the initial conditions</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="CMA-ES:163">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>log</mi>
    <mpadded width="+1.7pt">
     <msub>
      <mi>σ</mi>
      <mrow>
       <mi>k</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </msub>
    </mpadded>
    <mo rspace="4.2pt" stretchy="false">|</mo>
    <msub>
     <mi>σ</mi>
     <mi>k</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mi>log</mi>
   <msub>
    <mi>σ</mi>
    <mi>k</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">E</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <log></log>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>σ</ci>
      <apply>
       <plus></plus>
       <ci>k</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>normal-|</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>σ</ci>
      <ci>k</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <log></log>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>σ</ci>
     <ci>k</ci>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E(\log\sigma_{k+1}\,|\,\sigma_{k})=\log\sigma_{k}
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>and with an additional minor correction in the covariance matrix update for the case where the indicator function evaluates to zero, we find</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="CMA-ES:164">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mpadded width="+1.7pt">
     <msub>
      <mi>C</mi>
      <mrow>
       <mi>k</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </msub>
    </mpadded>
    <mo rspace="4.2pt" stretchy="false">|</mo>
    <msub>
     <mi>C</mi>
     <mi>k</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <msub>
    <mi>C</mi>
    <mi>k</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">E</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>C</ci>
      <apply>
       <plus></plus>
       <ci>k</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>normal-|</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>C</ci>
      <ci>k</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <ci>k</ci>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E(C_{k+1}\,|\,C_{k})=C_{k}
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>
<h3 id="invariance">Invariance</h3>

<p><a href="Invariant_(mathematics)" title="wikilink">Invariance properties</a> imply uniform performance on a class of objective functions. They have been argued to be an advantage, because they allow to generalize and predict the behavior of the algorithm and therefore strengthen the meaning of empirical results obtained on single functions. The following invariance properties have been established for CMA-ES.</p>
<ul>
<li>Invariance under order-preserving transformations of the objective function value 

<math display="inline" id="CMA-ES:165">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

, in that for any 

<math display="inline" id="CMA-ES:166">
 <semantics>
  <mrow>
   <mi>h</mi>
   <mo>:</mo>
   <mrow>
    <msup>
     <mi>ℝ</mi>
     <mi>n</mi>
    </msup>
    <mo>→</mo>
    <mi>ℝ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>h</ci>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ℝ</ci>
      <ci>n</ci>
     </apply>
     <ci>ℝ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h:\mathbb{R}^{n}\to\mathbb{R}
  </annotation>
 </semantics>
</math>

 the behavior is identical on 

<math display="inline" id="CMA-ES:167">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mo>:</mo>
   <mrow>
    <mi>x</mi>
    <mo>↦</mo>
    <mrow>
     <mi>g</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>h</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>f</ci>
    <apply>
     <csymbol cd="latexml">maps-to</csymbol>
     <ci>x</ci>
     <apply>
      <times></times>
      <ci>g</ci>
      <apply>
       <times></times>
       <ci>h</ci>
       <ci>x</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f:x\mapsto g(h(x))
  </annotation>
 </semantics>
</math>

 for all strictly increasing 

<math display="inline" id="CMA-ES:168">
 <semantics>
  <mrow>
   <mi>g</mi>
   <mo>:</mo>
   <mrow>
    <mi>ℝ</mi>
    <mo>→</mo>
    <mi>ℝ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>g</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>ℝ</ci>
     <ci>ℝ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g:\mathbb{R}\to\mathbb{R}
  </annotation>
 </semantics>
</math>

. This invariance is easy to verify, because only the 

<math display="inline" id="CMA-ES:169">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

-ranking is used in the algorithm, which is invariant under the choice of 

<math display="inline" id="CMA-ES:170">
 <semantics>
  <mi>g</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>g</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g
  </annotation>
 </semantics>
</math>

.</li>
</ul>
<ul>
<li><a class="uri" href="Scale-invariance" title="wikilink">Scale-invariance</a>, in that for any 

<math display="inline" id="CMA-ES:171">
 <semantics>
  <mrow>
   <mi>h</mi>
   <mo>:</mo>
   <mrow>
    <msup>
     <mi>ℝ</mi>
     <mi>n</mi>
    </msup>
    <mo>→</mo>
    <mi>ℝ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>h</ci>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ℝ</ci>
      <ci>n</ci>
     </apply>
     <ci>ℝ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h:\mathbb{R}^{n}\to\mathbb{R}
  </annotation>
 </semantics>
</math>

 the behavior is independent of 

<math display="inline" id="CMA-ES:172">
 <semantics>
  <mrow>
   <mi>α</mi>
   <mo>></mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <ci>α</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha>0
  </annotation>
 </semantics>
</math>

 for the objective function 

<math display="inline" id="CMA-ES:173">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mo>:</mo>
   <mrow>
    <mi>x</mi>
    <mo>↦</mo>
    <mrow>
     <mi>h</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>α</mi>
       <mi>x</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>f</ci>
    <apply>
     <csymbol cd="latexml">maps-to</csymbol>
     <ci>x</ci>
     <apply>
      <times></times>
      <ci>h</ci>
      <apply>
       <times></times>
       <ci>α</ci>
       <ci>x</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f:x\mapsto h(\alpha x)
  </annotation>
 </semantics>
</math>

 given 

<math display="inline" id="CMA-ES:174">
 <semantics>
  <mrow>
   <msub>
    <mi>σ</mi>
    <mn>0</mn>
   </msub>
   <mo>∝</mo>
   <mrow>
    <mn>1</mn>
    <mo>/</mo>
    <mi>α</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">proportional-to</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>σ</ci>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <ci>α</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma_{0}\propto 1/\alpha
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="CMA-ES:175">
 <semantics>
  <mrow>
   <msub>
    <mi>m</mi>
    <mn>0</mn>
   </msub>
   <mo>∝</mo>
   <mrow>
    <mn>1</mn>
    <mo>/</mo>
    <mi>α</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">proportional-to</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>m</ci>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <ci>α</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m_{0}\propto 1/\alpha
  </annotation>
 </semantics>
</math>

.</li>
</ul>
<ul>
<li>Invariance under rotation of the search space in that for any 

<math display="inline" id="CMA-ES:176">
 <semantics>
  <mrow>
   <mi>h</mi>
   <mo>:</mo>
   <mrow>
    <msup>
     <mi>ℝ</mi>
     <mi>n</mi>
    </msup>
    <mo>→</mo>
    <mi>ℝ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>h</ci>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ℝ</ci>
      <ci>n</ci>
     </apply>
     <ci>ℝ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h:\mathbb{R}^{n}\to\mathbb{R}
  </annotation>
 </semantics>
</math>

 and any 

<math display="inline" id="CMA-ES:177">
 <semantics>
  <mrow>
   <mi>z</mi>
   <mo>∈</mo>
   <msup>
    <mi>ℝ</mi>
    <mi>n</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>z</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ℝ</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z\in\mathbb{R}^{n}
  </annotation>
 </semantics>
</math>

 the behavior on 

<math display="inline" id="CMA-ES:178">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mo>:</mo>
   <mrow>
    <mi>x</mi>
    <mo>↦</mo>
    <mrow>
     <mi>h</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>R</mi>
       <mi>x</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>f</ci>
    <apply>
     <csymbol cd="latexml">maps-to</csymbol>
     <ci>x</ci>
     <apply>
      <times></times>
      <ci>h</ci>
      <apply>
       <times></times>
       <ci>R</ci>
       <ci>x</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f:x\mapsto h(Rx)
  </annotation>
 </semantics>
</math>

 is independent of the <a href="orthogonal_matrix" title="wikilink">orthogonal matrix</a> 

<math display="inline" id="CMA-ES:179">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

, given 

<math display="inline" id="CMA-ES:180">
 <semantics>
  <mrow>
   <msub>
    <mi>m</mi>
    <mn>0</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>R</mi>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <mi>z</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>m</ci>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>R</ci>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>z</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m_{0}=R^{-1}z
  </annotation>
 </semantics>
</math>

. More general, the algorithm is also invariant under general linear transformations 

<math display="inline" id="CMA-ES:181">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

 when additionally the initial covariance matrix is chosen as 

<math display="inline" id="CMA-ES:182">
 <semantics>
  <mrow>
   <msup>
    <mi>R</mi>
    <mrow>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msup>
   <mmultiscripts>
    <mi>R</mi>
    <none></none>
    <mrow>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
    <none></none>
    <mi>T</mi>
   </mmultiscripts>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>R</ci>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>R</ci>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>T</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R^{-1}{R^{-1}}^{T}
  </annotation>
 </semantics>
</math>

.</li>
</ul>

<p>Any serious parameter optimization method should be translation invariant, but most methods do not exhibit all the above described invariance properties. A prominent example with the same invariance properties is the <a href="Nelder–Mead_method" title="wikilink">Nelder–Mead method</a>, where the initial simplex must be chosen respectively.</p>
<h3 id="convergence">Convergence</h3>

<p>Conceptual considerations like the scale-invariance property of the algorithm, the analysis of simpler <a href="evolution_strategies" title="wikilink">evolution strategies</a>, and overwhelming empirical evidence suggest that the algorithm converges on a large class of functions fast to the global optimum, denoted as 

<math display="inline" id="CMA-ES:183">
 <semantics>
  <msup>
   <mi>x</mi>
   <mo>*</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>x</ci>
    <times></times>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{*}
  </annotation>
 </semantics>
</math>

. On some functions, convergence occurs independently of the initial conditions with probability one. On some functions the probability is smaller than one and typically depends on the initial 

<math display="inline" id="CMA-ES:184">
 <semantics>
  <msub>
   <mi>m</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>m</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m_{0}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="CMA-ES:185">
 <semantics>
  <msub>
   <mi>σ</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>σ</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma_{0}
  </annotation>
 </semantics>
</math>

. Empirically, the fastest possible convergence rate in 

<math display="inline" id="CMA-ES:186">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 for rank-based direct search methods can often be observed (depending on the context denoted as <em><a href="Rate_of_convergence#linear_convergence" title="wikilink">linear</a></em> or <em>log-linear</em> or <em>exponential</em> convergence). Informally, we can write</p>
<dl>
<dd><dl>
<dd><math>\|m_k - x^*\| \;\approx\; \|m_0 - x^*\| \times e^{-ck}
</math></dd>
</dl>
</dd>
</dl>

<p><code>  </code></p>

<p>for some 

<math display="inline" id="CMA-ES:187">
 <semantics>
  <mrow>
   <mi>c</mi>
   <mo>></mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <ci>c</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c>0
  </annotation>
 </semantics>
</math>

, and more rigorously</p>
<dl>
<dd><dl>
<dd><math>\frac{1}{k}\sum_{i=1}^k\log\frac{\|m_i - x^*\|}{\|m_{i-1} - x^*\|}
</math></dd>
</dl>
</dd>
</dl>

<p><code>  \;=\; \frac{1}{k}\log\frac{\|m_k - x^*\|}{\|m_{0} - x^*\|}</code><br/>
<code>   \;\to\; -c </code></p>

<p>or similarly,</p>
<dl>
<dd><dl>
<dd><math>E\log\frac{\|m_k - x^*\|}{\|m_{k-1} - x^*\|}
</math></dd>
</dl>
</dd>
</dl>

<p><code>   \;\to\; -c </code></p>

<p>This means that on average the distance to the optimum decreases in each iteration by a "constant" factor, namely by 

<math display="inline" id="CMA-ES:188">
 <semantics>
  <mrow>
   <mi>exp</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo>-</mo>
     <mi>c</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <exp></exp>
    <apply>
     <minus></minus>
     <ci>c</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \exp(-c)
  </annotation>
 </semantics>
</math>

. The convergence rate 

<math display="inline" id="CMA-ES:189">
 <semantics>
  <mi>c</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>c</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c
  </annotation>
 </semantics>
</math>

 is roughly 

<math display="inline" id="CMA-ES:190">
 <semantics>
  <mrow>
   <mrow>
    <mn>0.1</mn>
    <mi>λ</mi>
   </mrow>
   <mo>/</mo>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <times></times>
     <cn type="float">0.1</cn>
     <ci>λ</ci>
    </apply>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0.1\lambda/n
  </annotation>
 </semantics>
</math>

, given 

<math display="inline" id="CMA-ES:191">
 <semantics>
  <mi>λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda
  </annotation>
 </semantics>
</math>

 is not much larger than the dimension 

<math display="inline" id="CMA-ES:192">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

. Even with optimal 

<math display="inline" id="CMA-ES:193">
 <semantics>
  <mi>σ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="CMA-ES:194">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

, the convergence rate 

<math display="inline" id="CMA-ES:195">
 <semantics>
  <mi>c</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>c</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c
  </annotation>
 </semantics>
</math>

 cannot largely exceed 

<math display="inline" id="CMA-ES:196">
 <semantics>
  <mrow>
   <mrow>
    <mn>0.25</mn>
    <mi>λ</mi>
   </mrow>
   <mo>/</mo>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <times></times>
     <cn type="float">0.25</cn>
     <ci>λ</ci>
    </apply>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0.25\lambda/n
  </annotation>
 </semantics>
</math>

, given the above recombination weights 

<math display="inline" id="CMA-ES:197">
 <semantics>
  <msub>
   <mi>w</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>w</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w_{i}
  </annotation>
 </semantics>
</math>

 are all non-negative. The actual linear dependencies in 

<math display="inline" id="CMA-ES:198">
 <semantics>
  <mi>λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="CMA-ES:199">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 are remarkable and they are in both cases the best one can hope for in this kind of algorithm. Yet, a rigorous proof of convergence is missing.</p>
<h3 id="interpretation-as-coordinate-system-transformation">Interpretation as Coordinate System Transformation</h3>

<p>Using a non-identity covariance matrix for the <a href="multivariate_normal_distribution" title="wikilink">multivariate normal distribution</a> in <a href="evolution_strategies" title="wikilink">evolution strategies</a> is equivalent to a coordinate system transformation of the solution vectors,<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> mainly because the sampling equation</p>

<p>

<math display="inline" id="CMA-ES:200">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle x_{i}
  </annotation>
 </semantics>
</math>


</p>

<p>can be equivalently expressed in an "encoded space" as</p>

<p>

<math display="block" id="CMA-ES:201">
 <semantics>
  <mrow>
   <munder>
    <munder accentunder="true">
     <mrow>
      <msubsup>
       <mi>C</mi>
       <mi>k</mi>
       <mrow>
        <mo movablelimits="false">-</mo>
        <mrow>
         <mn>1</mn>
         <mo movablelimits="false">/</mo>
         <mn>2</mn>
        </mrow>
       </mrow>
      </msubsup>
      <msub>
       <mi>x</mi>
       <mi>i</mi>
      </msub>
     </mrow>
     <mo movablelimits="false">⏟</mo>
    </munder>
    <mpadded width="-83.3pt">
     <mtext>represented in the encode space</mtext>
    </mpadded>
   </munder>
   <mo rspace="7.5pt">∼</mo>
   <mrow>
    <munder accentunder="true">
     <mrow>
      <msubsup>
       <mi>C</mi>
       <mi>k</mi>
       <mrow>
        <mo>-</mo>
        <mrow>
         <mn>1</mn>
         <mo>/</mo>
         <mn>2</mn>
        </mrow>
       </mrow>
      </msubsup>
      <msub>
       <mi>m</mi>
       <mi>k</mi>
      </msub>
     </mrow>
     <mo>⏟</mo>
    </munder>
    <mo>+</mo>
    <mrow>
     <mrow>
      <msub>
       <mi>σ</mi>
       <mi>k</mi>
      </msub>
      <mo>×</mo>
      <mi class="ltx_font_mathcaligraphic">𝒩</mi>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>0</mn>
      <mo>,</mo>
      <mi>I</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">similar-to</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <ci>normal-⏟</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>C</ci>
         <ci>k</ci>
        </apply>
        <apply>
         <minus></minus>
         <apply>
          <divide></divide>
          <cn type="integer">1</cn>
          <cn type="integer">2</cn>
         </apply>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>i</ci>
       </apply>
      </apply>
     </apply>
     <mtext>represented in the encode space</mtext>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <ci>normal-⏟</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>C</ci>
         <ci>k</ci>
        </apply>
        <apply>
         <minus></minus>
         <apply>
          <divide></divide>
          <cn type="integer">1</cn>
          <cn type="integer">2</cn>
         </apply>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>m</ci>
        <ci>k</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>σ</ci>
        <ci>k</ci>
       </apply>
       <ci>𝒩</ci>
      </apply>
      <interval closure="open">
       <cn type="integer">0</cn>
       <ci>I</ci>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \underbrace{C_{k}^{-1/2}x_{i}}_{\text{represented in the encode space}\!\!\!\!%
\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!%
\!\!\!\!\!\!}\sim\ \underbrace{C_{k}^{-1/2}m_{k}}{}+\sigma_{k}\times\mathcal{N%
}(0,I)
  </annotation>
 </semantics>
</math>

</p>

<p>The covariance matrix defines a <a class="uri" href="bijective" title="wikilink">bijective</a> transformation (encoding) for all solution vectors into a space, where the sampling takes place with identity covariance matrix. Because the update equations in the CMA-ES are invariant under linear coordinate system transformations, the CMA-ES can be re-written as an adaptive encoding procedure applied to a simple <a href="evolution_strategy" title="wikilink">evolution strategy</a> with identity covariance matrix.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> This adaptive encoding procedure is not confined to algorithms that sample from a multivariate normal distribution (like evolution strategies), but can in principle be applied to any iterative search method.</p>
<h2 id="performance-in-practice">Performance in Practice</h2>

<p>In contrast to most other <a href="evolutionary_algorithms" title="wikilink">evolutionary algorithms</a>, the CMA-ES is, from the users perspective, quasi parameter-free. The user has to choose an initial solution point, 

<math display="inline" id="CMA-ES:202">
 <semantics>
  <mrow>
   <msub>
    <mi>m</mi>
    <mn>0</mn>
   </msub>
   <mo>∈</mo>
   <msup>
    <mi>ℝ</mi>
    <mi>n</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>m</ci>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ℝ</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m_{0}\in\mathbb{R}^{n}
  </annotation>
 </semantics>
</math>

, and the initial step-size, 

<math display="inline" id="CMA-ES:203">
 <semantics>
  <mrow>
   <msub>
    <mi>σ</mi>
    <mn>0</mn>
   </msub>
   <mo>></mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>σ</ci>
     <cn type="integer">0</cn>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma_{0}>0
  </annotation>
 </semantics>
</math>

. Optionally, the number of candidate samples λ (population size) can be modified by the user in order to change the characteristic search behavior (see above) and termination conditions can or should be adjusted to the problem at hand.</p>

<p>The CMA-ES has been empirically successful in hundreds of applications and is considered to be useful in particular on non-convex, non-separable, ill-conditioned, multi-modal or noisy objective functions. The search space dimension ranges typically between two and a few hundred. Assuming a black-box optimization scenario, where gradients are not available (or not useful) and function evaluations are the only considered cost of search, the CMA-ES method is likely to be outperformed by other methods in the following conditions:</p>
<ul>
<li>on low-dimensional functions, say 

<math display="inline" id="CMA-ES:204">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo><</mo>
   <mn>5</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <ci>n</ci>
    <cn type="integer">5</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n<5
  </annotation>
 </semantics>
</math>

, for example by the <a href="Nelder-Mead_method" title="wikilink">downhill simplex method</a> or surrogate-based methods (like <a class="uri" href="kriging" title="wikilink">kriging</a> with expected improvement);</li>
</ul>
<ul>
<li>on separable functions without or with only negligible dependencies between the design variables in particular in the case of multi-modality or large dimension, for example by <a href="differential_evolution" title="wikilink">differential evolution</a>;</li>
</ul>
<ul>
<li>on (nearly) <a href="Convex_function" title="wikilink">convex</a>-quadratic functions with low or moderate <a href="condition_number" title="wikilink">condition number</a> of the <a href="Hessian_matrix" title="wikilink">Hessian matrix</a>, where <a href="BFGS_method" title="wikilink">BFGS</a> or <a class="uri" href="NEWUOA" title="wikilink">NEWUOA</a> are typically ten times faster;</li>
</ul>
<ul>
<li>on functions that can already be solved with a comparatively small number of function evaluations, say no more than 

<math display="inline" id="CMA-ES:205">
 <semantics>
  <mrow>
   <mn>10</mn>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <cn type="integer">10</cn>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   10n
  </annotation>
 </semantics>
</math>

, where CMA-ES is often slower than, for example, <a class="uri" href="NEWUOA" title="wikilink">NEWUOA</a> or <a href="MCS_algorithm" title="wikilink">Multilevel Coordinate Search</a> (MCS).</li>
</ul>

<p>On separable functions, the performance disadvantage is likely to be most significant in that CMA-ES might not be able to find at all comparable solutions. On the other hand, on non-separable functions that are ill-conditioned or rugged or can only be solved with more than 

<math display="inline" id="CMA-ES:206">
 <semantics>
  <mrow>
   <mn>100</mn>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <cn type="integer">100</cn>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   100n
  </annotation>
 </semantics>
</math>

 function evaluations, the CMA-ES shows most often superior performance.</p>
<h2 id="variations-and-extensions">Variations and Extensions</h2>

<p>The (1+1)-CMA-ES<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> generates only one candidate solution per iteration step which becomes the new distribution mean if it is better than the current mean. For 

<math display="inline" id="CMA-ES:207">
 <semantics>
  <mrow>
   <msub>
    <mi>c</mi>
    <mi>c</mi>
   </msub>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>c</ci>
     <ci>c</ci>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{c}=1
  </annotation>
 </semantics>
</math>

 the (1+1)-CMA-ES is a close variant of <a href="Gaussian_adaptation" title="wikilink">Gaussian adaptation</a>. Some <a href="Natural_Evolution_Strategies" title="wikilink">Natural Evolution Strategies</a> are close variants of the CMA-ES with specific parameter settings. Natural Evolution Strategies do not utilize evolution paths (that means in CMA-ES setting 

<math display="inline" id="CMA-ES:208">
 <semantics>
  <mrow>
   <msub>
    <mi>c</mi>
    <mi>c</mi>
   </msub>
   <mo>=</mo>
   <msub>
    <mi>c</mi>
    <mi>σ</mi>
   </msub>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>c</ci>
      <ci>c</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>c</ci>
      <ci>σ</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{c}=c_{\sigma}=1
  </annotation>
 </semantics>
</math>

) and they formalize the update of variances and covariances on a <a href="Cholesky_decomposition" title="wikilink">Cholesky factor</a> instead of a covariance matrix. The CMA-ES has also been extended to <a href="multiobjective_optimization" title="wikilink">multiobjective optimization</a> as MO-CMA-ES.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> Another remarkable extension has been the addition of a negative update of the covariance matrix with the so-called active CMA.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a></p>

<p>With the advent of niching methods in evolutionary strategies, the question of an optimal niche radius arises. An "adaptive individual niche radius" is introduced in <a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Global_optimization" title="wikilink">Global optimization</a></li>
<li><a href="Stochastic_optimization" title="wikilink">Stochastic optimization</a></li>
<li><a href="Derivative-free_optimization" title="wikilink">Derivative-free optimization</a></li>
</ul>
<h2 id="references">References</h2>
<h2 id="bibliography">Bibliography</h2>
<ul>
<li>Hansen N, Ostermeier A (2001). Completely derandomized self-adaptation in evolution strategies. <a href="http://www.mitpressjournals.org/toc/evco/9/2"><em>Evolutionary Computation</em>, <strong>9</strong>(2)</a> pp. 159–195. <a href="http://www.lri.fr/~hansen/cmaartic.pdf">1</a></li>
<li>Hansen N, Müller SD, Koumoutsakos P (2003). Reducing the time complexity of the derandomized evolution strategy with covariance matrix adaptation (CMA-ES). <a href="http://www.mitpressjournals.org/toc/evco/11/1"><em>Evolutionary Computation</em>, <strong>11</strong>(1)</a> pp. 1–18. <a href="http://mitpress.mit.edu/journals/pdf/evco_11_1_1_0.pdf">2</a></li>
<li>Hansen N, Kern S (2004). Evaluating the CMA evolution strategy on multimodal test functions. In Xin Yao et al., editors, <em>Parallel Problem Solving from Nature - PPSN VIII</em>, pp. 282–291, Springer. <a href="http://www.lri.fr/~hansen/ppsn2004hansenkern.pdf">3</a></li>
<li>Igel C, Hansen N, Roth S (2007). Covariance Matrix Adaptation for Multi-objective Optimization. <a href="http://www.mitpressjournals.org/toc/evco/15/1"><em>Evolutionary Computation</em>, <strong>15</strong>(1)</a> pp. 1–28. <a href="http://www.mitpressjournals.org/doi/pdfplus/10.1162/evco.2007.15.1.1">4</a></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.lri.fr/~hansen/cmaesintro.html">A short introduction to CMA-ES by N. Hansen</a></li>
<li><a href="http://www.lri.fr/~hansen/cmatutorial.pdf">The CMA Evolution Strategy: A Tutorial</a></li>
<li><a href="http://www.lri.fr/~hansen/cmaes_inmatlab.html">CMA-ES source code page</a></li>
</ul>

<p><a href="fr:Stratégie_d'évolution#CMA-ES" title="wikilink">fr:Stratégie d'évolution#CMA-ES</a>"</p>

<p><a href="Category:Evolutionary_algorithms" title="wikilink">Category:Evolutionary algorithms</a> <a href="Category:Stochastic_optimization" title="wikilink">Category:Stochastic optimization</a> <a href="Category:Optimization_algorithms_and_methods" title="wikilink">Category:Optimization algorithms and methods</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"></li>
<li id="fn6"></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
<li id="fn8"></li>
<li id="fn9"></li>
<li id="fn10"><a href="#fnref10">↩</a></li>
<li id="fn11"><a href="#fnref11">↩</a></li>
<li id="fn12"><a href="#fnref12">↩</a></li>
<li id="fn13"><a href="#fnref13">↩</a></li>
<li id="fn14"><a href="#fnref14">↩</a></li>
</ol>
</section>
</body>

