<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1445">Normalization property (abstract rewriting)</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Normalization property (abstract rewriting)</h1>
<hr/>

<p>In <a href="mathematical_logic" title="wikilink">mathematical logic</a> and <a href="theoretical_computer_science" title="wikilink">theoretical computer science</a>, a <a href="rewrite_system" title="wikilink">rewrite system</a> has the <strong>strong normalization property</strong> or is <strong>terminating</strong> (in short: the <strong>normalization</strong> or the <strong>termination</strong>) if every term is <em>strongly normalizing</em>; that is, if every sequence of rewrites eventually terminates to an <em>irreducible</em> term also called a <a href="Normal_form_(term_rewriting)" title="wikilink">normal form</a>. A rewrite system may also have the <strong>weak normalization property</strong>, meaning that for every term, there exists at least one particular sequence of rewrites that eventually yields a normal form, i.e., an irreducible term.</p>
<h2 id="lambda-calculus">Lambda calculus</h2>
<h3 id="untyped-lambda-calculus">Untyped lambda calculus</h3>

<p>The <em>pure</em> untyped <a href="lambda_calculus" title="wikilink">lambda calculus</a> does not satisfy the strong normalization property, and not even the weak normalization property. Consider the term 

<math display="inline" id="Normalization_property_(abstract_rewriting):0">
 <semantics>
  <mrow>
   <mrow>
    <mi>λ</mi>
    <mi>x</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>x</mi>
    <mi>x</mi>
    <mi>x</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <ci>x</ci>
     <ci>x</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda x.xxx
  </annotation>
 </semantics>
</math>

. It has the following rewrite rule: For any term 

<math display="inline" id="Normalization_property_(abstract_rewriting):1">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

,</p>

<p>

<math display="block" id="Normalization_property_(abstract_rewriting):2">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>x</mi>
    <mo>.</mo>
    <mi>x</mi>
    <mi>x</mi>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi>t</mi>
   <mo>→</mo>
   <mi>t</mi>
   <mi>t</mi>
   <mi>t</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">t</csymbol>
    <ci>normal-→</ci>
    <csymbol cd="unknown">t</csymbol>
    <csymbol cd="unknown">t</csymbol>
    <csymbol cd="unknown">t</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\mathbf{\lambda}x.xxx)t\rightarrow ttt
  </annotation>
 </semantics>
</math>

</p>

<p>But consider what happens when we apply 

<math display="inline" id="Normalization_property_(abstract_rewriting):3">
 <semantics>
  <mrow>
   <mrow>
    <mi>λ</mi>
    <mi>x</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>x</mi>
    <mi>x</mi>
    <mi>x</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <ci>x</ci>
     <ci>x</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda x.xxx
  </annotation>
 </semantics>
</math>

 to itself:</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>

<math display="inline" id="Normalization_property_(abstract_rewriting):4">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>x</mi>
    <mo>.</mo>
    <mi>x</mi>
    <mi>x</mi>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>x</mi>
    <mo>.</mo>
    <mi>x</mi>
    <mi>x</mi>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\mathbf{\lambda}x.xxx)(\lambda x.xxx)
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Normalization_property_(abstract_rewriting):5">
 <semantics>
  <mrow>
   <mo>→</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>x</mi>
    <mo>.</mo>
    <mi>x</mi>
    <mi>x</mi>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>x</mi>
    <mo>.</mo>
    <mi>x</mi>
    <mi>x</mi>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>x</mi>
    <mo>.</mo>
    <mi>x</mi>
    <mi>x</mi>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-→</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rightarrow(\mathbf{\lambda}x.xxx)(\lambda x.xxx)(\lambda x.xxx)
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Normalization_property_(abstract_rewriting):6">
 <semantics>
  <mrow>
   <mo>→</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>x</mi>
    <mo>.</mo>
    <mi>x</mi>
    <mi>x</mi>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>x</mi>
    <mo>.</mo>
    <mi>x</mi>
    <mi>x</mi>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>x</mi>
    <mo>.</mo>
    <mi>x</mi>
    <mi>x</mi>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>x</mi>
    <mo>.</mo>
    <mi>x</mi>
    <mi>x</mi>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-→</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rightarrow(\mathbf{\lambda}x.xxx)(\lambda x.xxx)(\lambda x.xxx)(\lambda x.xxx)
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Normalization_property_(abstract_rewriting):7">
 <semantics>
  <mrow>
   <mo>→</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>x</mi>
    <mo>.</mo>
    <mi>x</mi>
    <mi>x</mi>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>x</mi>
    <mo>.</mo>
    <mi>x</mi>
    <mi>x</mi>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>x</mi>
    <mo>.</mo>
    <mi>x</mi>
    <mi>x</mi>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>x</mi>
    <mo>.</mo>
    <mi>x</mi>
    <mi>x</mi>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>x</mi>
    <mo>.</mo>
    <mi>x</mi>
    <mi>x</mi>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-→</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rightarrow(\mathbf{\lambda}x.xxx)(\lambda x.xxx)(\lambda x.xxx)(\lambda x.xxx%
)(\lambda x.xxx)
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Normalization_property_(abstract_rewriting):8">
 <semantics>
  <mrow>
   <mi></mi>
   <mo rspace="7.5pt">→</mo>
   <mpadded width="+1.7pt">
    <mi mathvariant="normal">…</mi>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <csymbol cd="latexml">absent</csymbol>
    <ci>normal-…</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rightarrow\ \ldots\,
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
</tbody>
</table>

<p>Therefore the term 

<math display="inline" id="Normalization_property_(abstract_rewriting):9">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>x</mi>
    <mo>.</mo>
    <mi>x</mi>
    <mi>x</mi>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>x</mi>
    <mo>.</mo>
    <mi>x</mi>
    <mi>x</mi>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\lambda x.xxx)(\lambda x.xxx)
  </annotation>
 </semantics>
</math>

 is neither strongly nor weakly normalizing.</p>
<h3 id="typed-lambda-calculus">Typed lambda calculus</h3>

<p>Various systems of <a href="typed_lambda_calculus" title="wikilink">typed lambda calculus</a> including the <a href="simply_typed_lambda_calculus" title="wikilink">simply typed lambda calculus</a>, <a href="Jean-Yves_Girard" title="wikilink">Jean-Yves Girard</a>'s <a href="System_F" title="wikilink">System F</a>, and <a href="Thierry_Coquand" title="wikilink">Thierry Coquand</a>'s <a href="calculus_of_constructions" title="wikilink">calculus of constructions</a> are strongly normalizing.</p>

<p>A lambda calculus system with the <strong>normalization property</strong> can be viewed as a programming language with the property that every program <a href="termination_analysis" title="wikilink">terminates</a>. Although this is a very useful property, it has a drawback: a programming language with the normalization property cannot be <a href="turing_completeness" title="wikilink">Turing complete</a>. That means that there are computable functions that cannot be defined in the simply typed lambda calculus (and similarly there are computable functions that cannot be computed in the <a href="calculus_of_constructions" title="wikilink">calculus of constructions</a> or <a href="System_F" title="wikilink">System F</a>). As an example, it is impossible to define a <a class="uri" href="self-interpreter" title="wikilink">self-interpreter</a> in any of the calculi cited above.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a><a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Typed_lambda_calculus" title="wikilink">Typed lambda calculus</a></li>
<li><a class="uri" href="Rewriting" title="wikilink">Rewriting</a></li>
<li><a href="Total_functional_programming" title="wikilink">Total functional programming</a></li>
<li><a href="Barendregt–Geuvers–Klop_conjecture" title="wikilink">Barendregt–Geuvers–Klop conjecture</a></li>
<li><a href="Newman's_lemma" title="wikilink">Newman's lemma</a></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li>

<p>316 pages.</p></li>
</ul>

<p>"</p>

<p><a href="Category:Lambda_calculus" title="wikilink">Category:Lambda calculus</a> <a href="Category:Logic_in_computer_science" title="wikilink">Category:Logic in computer science</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Conor McBride (May 2003), <a href="http://www.haskell.org/pipermail/haskell-cafe/2003-May/004343.html">"on termination"</a> (posted to the Haskell-Cafe mailing list).<a href="#fnref1">↩</a></li>
<li id="fn2"><a href="Andrej_Bauer" title="wikilink">Andrej Bauer</a> (June 2014), <a href="http://cstheory.stackexchange.com/questions/24986/a-total-language-that-only-a-turing-complete-language-can-interpret/24994#24994">Answer to: A total language that only a Turing complete language can interpret</a> (posted to the Theoretical Computer Science <a class="uri" href="StackExchange" title="wikilink">StackExchange</a> site)<a href="#fnref2">↩</a></li>
</ol>
</section>
</body>
</html>
