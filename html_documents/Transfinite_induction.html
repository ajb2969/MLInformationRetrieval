<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1035">Transfinite induction</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Transfinite induction</h1>
<hr/>
<figure><b>(Figure)</b>
<figcaption>Representation of the ordinal numbers up to ω<sup>ω</sup>. Each turn of the spiral represents one power of ω. Transfinite induction requires proving a <strong>base case</strong> (used for 0), a <strong>successor case</strong> (used for those ordinals which have a predecessor), and a <strong>limit case</strong> (used for ordinals which don't have a predecessor).</figcaption>
</figure>

<p><strong>Transfinite induction</strong> is an extension of <a href="mathematical_induction" title="wikilink">mathematical induction</a> to <a href="well-order" title="wikilink">well-ordered sets</a>, for example to sets of <a href="ordinal_number" title="wikilink">ordinal numbers</a> or <a href="cardinal_number" title="wikilink">cardinal numbers</a>.</p>

<p>Let P(α) be a <a href="Property_(philosophy)" title="wikilink">property</a> defined for all ordinals α. Suppose that whenever P(β) is true for all β \alpha\in\emptyset). Then transfinite induction tells us that P is true for all ordinals.</p>

<p>That is, if P(α) is true whenever P(β) is true for all β P(0) is true.</p>
<ul>
<li><strong>Successor case:</strong> Prove that for any <a href="successor_ordinal" title="wikilink">successor ordinal</a> α+1, P(α+1) follows from P(α) (and, if necessary, P(β) for all β &lt; α).</li>
</ul>
<ul>
<li><strong>Limit case:</strong> Prove that for any <a href="limit_ordinal" title="wikilink">limit ordinal</a> λ, P(λ) follows from [P(β) for all β &lt; λ].</li>
</ul>

<p>Notice that all three cases are identical except for the type of ordinal considered. They do not formally need to be considered separately, but in practice the proofs are typically so different as to require separate presentations. Zero is sometimes considered a <a href="limit_ordinal" title="wikilink">limit ordinal</a> and then may sometimes be treated in proofs in the same case as limit ordinals.</p>
<h2 id="transfinite-recursion">Transfinite recursion</h2>

<p><strong>Transfinite recursion</strong> is similar to transfinite induction; however, instead of proving that something holds for all ordinal numbers, we construct a sequence of objects, one for each ordinal.</p>

<p>As an example, a basis for a (possibly infinite-dimensional) vector space can be created by choosing a vector 

<math display="inline" id="Transfinite_induction:0">
 <semantics>
  <msub>
   <mi>v</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>v</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v_{0}
  </annotation>
 </semantics>
</math>

 and for each ordinal α choosing a vector that is not in the span of the vectors 

<math display="inline" id="Transfinite_induction:1">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <msub>
    <mi>v</mi>
    <mi>β</mi>
   </msub>
   <mo stretchy="false">|</mo>
   <mrow>
    <mi>β</mi>
    <mo><</mo>
    <mi>α</mi>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">conditional-set</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>v</ci>
     <ci>β</ci>
    </apply>
    <apply>
     <lt></lt>
     <ci>β</ci>
     <ci>α</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{v_{\beta}|\beta<\alpha\}
  </annotation>
 </semantics>
</math>

. This process stops when no vector can be chosen.</p>

<p>More formally, we can state the Transfinite Recursion Theorem as follows:</p>
<ul>
<li><strong>Transfinite Recursion Theorem (version 1)</strong>. Given a class function<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> <em>G</em>: <em>V</em> → <em>V</em> (where <em>V</em> is the <a href="Class_(set_theory)" title="wikilink">class</a> of all sets), there exists a unique <a href="transfinite_sequence" title="wikilink">transfinite sequence</a> <em>F</em>: Ord → <em>V</em> (where Ord is the class of all ordinals) such that</li>
</ul>
<dl>
<dd><em>F</em>(α) = <em>G</em>(<em>F</em> 

<math display="inline" id="Transfinite_induction:2">
 <semantics>
  <mo>↾</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-↾</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \upharpoonright
  </annotation>
 </semantics>
</math>

 α) for all ordinals α, where 

<math display="inline" id="Transfinite_induction:3">
 <semantics>
  <mo>↾</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-↾</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \upharpoonright
  </annotation>
 </semantics>
</math>

 denotes the restriction of <em>F</em>'s domain to ordinals &lt; α.
</dd>
</dl>

<p>As in the case of induction, we may treat different types of ordinals separately: another formulation of transfinite recursion is the following:</p>
<ul>
<li><strong>Transfinite Recursion Theorem (version 2)</strong>. Given a set <em>g</em><sub>1</sub>, and class functions <em>G</em><sub>2</sub>, <em>G</em><sub>3</sub>, there exists a unique function <em>F</em>: Ord → <em>V</em> such that</li>
<li><em>F</em>(0) = <em>g</em><sub>1</sub>,</li>
<li><em>F</em>(α + 1) = <em>G</em><sub>2</sub>(<em>F</em>(α)), for all α ∈ Ord,</li>
<li><em>F</em>(λ) = <em>G</em><sub>3</sub>(<em>F</em> 

<math display="inline" id="Transfinite_induction:4">
 <semantics>
  <mo>↾</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-↾</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \upharpoonright
  </annotation>
 </semantics>
</math>

 λ), for all limit λ ≠ 0.</li>
</ul>

<p>Note that we require the domains of <em>G</em><sub>2</sub>, <em>G</em><sub>3</sub> to be broad enough to make the above properties meaningful. The uniqueness of the sequence satisfying these properties can be proven using transfinite induction.</p>

<p>More generally, one can define objects by transfinite recursion on any <a href="well-founded_relation" title="wikilink">well-founded relation</a> <em>R</em>. (<em>R</em> need not even be a set; it can be a <a href="proper_class" title="wikilink">proper class</a>, provided it is a <a href="binary_relation#Relations_over_a_set" title="wikilink">set-like</a> relation; that is, for any <em>x</em>, the collection of all <em>y</em> such that <em>y R x</em> must be a set.)</p>
<h2 id="relationship-to-the-axiom-of-choice">Relationship to the axiom of choice</h2>

<p>Proofs or constructions using induction and recursion often use the <a href="axiom_of_choice" title="wikilink">axiom of choice</a> to produce a well-ordered relation that can be treated by transfinite induction. However, if the relation in question is already well-ordered, one can often use transfinite induction without invoking the axiom of choice.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> For example, many results about <a href="Borel_sets" title="wikilink">Borel sets</a> are proved by transfinite induction on the ordinal rank of the set; these ranks are already well-ordered, so the axiom of choice is not needed to well-order them.</p>

<p>The following construction of the <a href="Vitali_set" title="wikilink">Vitali set</a> shows one way that the axiom of choice can be used in a proof by transfinite induction:</p>
<dl>
<dd>First, <a class="uri" href="well-order" title="wikilink">well-order</a> the <a href="real_number" title="wikilink">real numbers</a> (this is where the axiom of choice enters via the <a href="well-ordering_theorem" title="wikilink">well-ordering theorem</a>), giving a sequence 

<math display="inline" id="Transfinite_induction:5">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <msub>
     <mi>r</mi>
     <mi>α</mi>
    </msub>
    <mo fence="true" stretchy="false">|</mo>
   </mrow>
   <mi>α</mi>
   <mrow>
    <mo><</mo>
    <mi>β</mi>
    <mo stretchy="false">⟩</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="latexml">bra</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>r</ci>
      <ci>α</ci>
     </apply>
    </apply>
    <ci>α</ci>
    <apply>
     <csymbol cd="latexml">delimited-<⟩</csymbol>
     <ci>β</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle r_{\alpha}|\alpha<\beta\rangle
  </annotation>
 </semantics>
</math>

, where β is an ordinal with the <a href="cardinality_of_the_continuum" title="wikilink">cardinality of the continuum</a>. Let <em>v</em><sub>0</sub> equal <em>r</em><sub>0</sub>. Then let <em>v</em><sub>1</sub> equal <em>r</em><sub>α<sub>1</sub></sub>, where α<sub>1</sub> is least such that <em>r</em><sub>α<sub>1</sub></sub> − <em>v</em><sub>0</sub> is not a <a href="rational_number" title="wikilink">rational number</a>. Continue; at each step use the least real from the <em>r</em> sequence that does not have a rational difference with any element thus far constructed in the <em>v</em> sequence. Continue until all the reals in the <em>r</em> sequence are exhausted. The final <em>v</em> sequence will enumerate the Vitali set.
</dd>
</dl>

<p>The above argument uses the axiom of choice in an essential way at the very beginning, in order to well-order the reals. After that step, the axiom of choice is not used again.</p>

<p>Other uses of the axiom of choice are more subtle. For example, a construction by transfinite recursion frequently will not specify a <em>unique</em> value for <em>A</em><sub>α+1</sub>, given the sequence up to α, but will specify only a <em>condition</em> that <em>A</em><sub>α+1</sub> must satisfy, and argue that there is at least one set satisfying this condition. If it is not possible to define a unique example of such a set at each stage, then it may be necessary to invoke (some form of) the axiom of choice to select one such at each step. For inductions and recursions of <a href="countable_set" title="wikilink">countable</a> length, the weaker <a href="axiom_of_dependent_choice" title="wikilink">axiom of dependent choice</a> is sufficient. Because there are models of <a href="Zermelo–Fraenkel_set_theory" title="wikilink">Zermelo–Fraenkel set theory</a> of interest to set theorists that satisfy the axiom of dependent choice but not the full axiom of choice, the knowledge that a particular proof only requires dependent choice can be useful.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Mathematical_induction" title="wikilink">Mathematical induction</a></li>
<li><a href="Epsilon-induction" title="wikilink">∈-induction</a></li>
<li><a href="Well-founded_relation#Induction_and_recursion" title="wikilink">Well-founded induction</a></li>
</ul>
<h2 id="notes">Notes</h2>
<references>
</references>
<h2 id="references">References</h2>
<ul>
<li></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Ordinal_numbers" title="wikilink">Category:Ordinal numbers</a> <a class="uri" href="Category:Recursion" title="wikilink">Category:Recursion</a> <a href="Category:Mathematical_induction" title="wikilink">Category:Mathematical induction</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">A class function is a rule (specifically, a logical formula) assigning each element in the lefthand class to an element in the righthand class. It is not a <a href="function_(mathematics)" title="wikilink">function</a> because its domain and codomain are not sets.<a href="#fnref1">↩</a></li>
<li id="fn2">In fact, the domain of the relation does not even need to be a set. It can be a proper class, provided that the relation <em>R</em> is set-like: for any <em>x</em>, the collection of all <em>y</em> such that <em>y</em> <em>R</em> <em>x</em> must be a set.<a href="#fnref2">↩</a></li>
</ol>
</section>
</body>
</html>
