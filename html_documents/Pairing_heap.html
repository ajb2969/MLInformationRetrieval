<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="289">Pairing heap</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Pairing heap</h1>
<hr/>

<p>A <strong>pairing heap</strong> is a type of <a href="heap_(data_structure)" title="wikilink">heap</a> <a href="data_structure" title="wikilink">data structure</a> with relatively simple implementation and excellent practical <a class="uri" href="amortized" title="wikilink">amortized</a> performance. Pairing heaps are <a href="heap_property" title="wikilink">heap-ordered</a> multiway <a href="Tree_(data_structure)" title="wikilink">tree structures</a>, and can be considered simplified <a href="Fibonacci_heap" title="wikilink">Fibonacci heaps</a>. They are considered a "robust choice" for implementing such algorithms as <a href="Prim's_algorithm" title="wikilink">Prim's MST algorithm</a>,<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> and support the following operations (assuming a min-heap):</p>
<ul>
<li><em>find-min</em>: simply return the top element of the heap.</li>
<li><em>merge</em>: compare the two root elements, the smaller remains the root of the result, the larger element and its subtree is appended as a child of this root.</li>
<li><em>insert</em>: create a new heap for the inserted element and <em>merge</em> into the original heap.</li>
<li><em>decrease-key</em> (optional): remove the subtree rooted at the key to be decreased, replace the key with a smaller key, then <em>merge</em> the result back into the heap.</li>
<li><em>delete-min</em>: remove the root and <em>merge</em> its subtrees. Various strategies are employed.</li>
</ul>

<p>The analysis of pairing heaps' time complexity was initially inspired by that of <a href="splay_tree" title="wikilink">splay trees</a>.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> The amortized time per <em>delete-min</em> is 

<math display="inline" id="Pairing_heap:0">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>l</mi>
     <mi>o</mi>
     <mi>g</mi>
     <mi>n</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>l</ci>
     <ci>o</ci>
     <ci>g</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(logn)
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> The operations <em>find-min</em>, <em>merge</em>, and <em>insert</em> run in constant time, 

<math display="inline" id="Pairing_heap:1">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(1)
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>

<p>Determining the precise asymptotic running time of pairing heaps when a <em>decrease-key</em> operation is needed has turned out to be difficult. Initially, the time complexity of this operation was conjectured on empirical grounds to be 

<math display="inline" id="Pairing_heap:2">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(1)
  </annotation>
 </semantics>
</math>

,<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> but <a href="Michael_Fredman" title="wikilink">Fredman</a> proved that the amortized time per <em>decrease-key</em> is at least 

<math display="inline" id="Pairing_heap:3">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Ω</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>log</mi>
     <mrow>
      <mi>log</mi>
      <mi>n</mi>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Ω</ci>
    <apply>
     <log></log>
     <apply>
      <log></log>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Omega(\log\log n)
  </annotation>
 </semantics>
</math>

 for some sequences of operations.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> Pettie then derived an upper bound of 

<math display="inline" id="Pairing_heap:4">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mn>2</mn>
     <mrow>
      <mn>2</mn>
      <msqrt>
       <mrow>
        <mi>log</mi>
        <mrow>
         <mi>log</mi>
         <mi>n</mi>
        </mrow>
       </mrow>
      </msqrt>
     </mrow>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <apply>
       <root></root>
       <apply>
        <log></log>
        <apply>
         <log></log>
         <ci>n</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(2^{2\sqrt{\log\log n}})
  </annotation>
 </semantics>
</math>

 amortized time for <em>decrease-key</em>, which is 

<math display="inline" id="Pairing_heap:5">
 <semantics>
  <mrow>
   <mi>o</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>log</mi>
     <mi>n</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>o</ci>
    <apply>
     <log></log>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   o(\log n)
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> No tight 

<math display="inline" id="Pairing_heap:6">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Θ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>log</mi>
     <mrow>
      <mi>log</mi>
      <mi>n</mi>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Θ</ci>
    <apply>
     <log></log>
     <apply>
      <log></log>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Theta(\log\log n)
  </annotation>
 </semantics>
</math>

 bound is known.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></p>

<p>Although this is worse than other priority queue algorithms such as <a href="Fibonacci_heap" title="wikilink">Fibonacci heaps</a>, which perform <em>decrease-key</em> in 

<math display="inline" id="Pairing_heap:7">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(1)
  </annotation>
 </semantics>
</math>

 amortized time, the performance in practice is excellent. <a href="John_Stasko" title="wikilink">Stasko</a> and <a href="Jeff_Vitter" title="wikilink">Vitter</a><a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> and Moret and Shapiro<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> conducted experiments on pairing heaps and other heap data structures. They concluded that the pairing heap is as fast as, and often faster than, other efficient data structures like the <a href="binary_heap" title="wikilink">binary heaps</a>.</p>
<h2 id="structure">Structure</h2>

<p>A pairing heap is either an empty heap, or a pair consisting of a root element and a possibly empty list of pairing heaps. The heap ordering property requires that all the root elements of the subheaps in the list are not smaller than the root element of the heap. The following description assumes a purely functional heap that does not support the <em>decrease-key</em> operation.</p>

<p><strong><code>type</code></strong><code> PairingHeap[Elem] = Empty | Heap(elem: Elem, subheaps: List[PairingHeap[Elem]])</code></p>

<p>A pointer-based implementation for <a href="RAM_machine" title="wikilink">RAM machines</a>, supporting <em>decrease-key</em>, can be achieved using three pointers per node, by representing the children of a node by a <a href="singly-linked_list" title="wikilink">singly-linked list</a>: a pointer to the node's first child, one to its next sibling, and one to the parent. Alternatively, the parent pointer can be omitted by letting the last child point back to the parent, if a single boolean flag is added to indicate "end of list". This achieves a more compact structure at the expense of a constant overhead factor per operation.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a></p>
<h2 id="operations">Operations</h2>
<h3 id="find-min">find-min</h3>

<p>The function <em>find-min</em> simply returns the root element of the heap:</p>

<p><strong><code>function</code></strong><code> find-min(heap)</code><br/>
<code>  </code><strong><code>if</code></strong><code> heap == Empty</code><br/>
<code>    </code><strong><code>error</code></strong><br/>
<code>  </code><strong><code>else</code></strong><br/>
<code>    </code><strong><code>return</code></strong><code> heap.elem</code></p>
<h3 id="merge">merge</h3>

<p>Merging with an empty heap returns the other heap, otherwise a new heap is returned that has the minimum of the two root elements as its root element and just adds the heap with the larger root to the list of subheaps:</p>

<p><strong><code>function</code></strong><code> merge(heap1, heap2)</code><br/>
<code>  </code><strong><code>if</code></strong><code> heap1 == Empty</code><br/>
<code>    </code><strong><code>return</code></strong><code> heap2</code><br/>
<code>  </code><strong><code>elsif</code></strong><code> heap2 == Empty</code><br/>
<code>    </code><strong><code>return</code></strong><code> heap1</code><br/>
<code>  </code><strong><code>elsif</code></strong><code> heap1.elem </code><code> merge(merge(H1, H2), merge-pairs([H3, H4, H5, H6, H7]))</code><br/>
<code>     # merge H1 and H2 to H12, then the rest of the list</code><br/>
<code>=&gt; merge(</code><strong><code>H12</code></strong><code>, merge(merge(H3, H4), merge-pairs([H5, H6, H7])))</code><br/>
<code>     # merge H3 and H4 to H34, then the rest of the list</code><br/>
<code>=&gt; merge(H12, merge(</code><strong><code>H34</code></strong><code>, merge(merge(H5, H6), merge-pairs([H7]))))</code><br/>
<code>     # merge H5 and H6 to H56, then the rest of the list</code><br/>
<code>=&gt; merge(H12, merge(H34, merge(</code><strong><code>H56</code></strong><code>, H7)))</code><br/>
<code>     # switch direction, merge the last two resulting heaps, giving H567</code><br/>
<code>=&gt; merge(H12, merge(H34, </code><strong><code>H567</code></strong><code>))</code><br/>
<code>     # merge the last two resulting heaps, giving H34567</code><br/>
<code>=&gt; merge(H12, </code><strong><code>H34567</code></strong><code>) </code><br/>
<code>     # finally, merge the first merged pair with the result of merging the rest</code><br/>
<code>=&gt; </code><strong><code>H1234567</code></strong></p>
<h2 id="summary-of-running-times">Summary of running times</h2>
<h2 id="references">References</h2>
<h2 id="external-links">External links</h2>
<ul>
<li>Louis Wasserman discusses pairing heaps and their implementation in <a href="Haskell_(programming_language)" title="wikilink">Haskell</a> in <a href="http://themonadreader.files.wordpress.com/2010/05/issue16.pdf">The Monad Reader, Issue 16</a> (pp. 37–52).</li>
<li><a href="http://www.cise.ufl.edu/~sahni/dsaaj/enrich/c13/pairing.htm">pairing heaps</a>, <a href="Sartaj_Sahni" title="wikilink">Sartaj Sahni</a></li>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Heaps_(data_structures)" title="wikilink">Category:Heaps (data structures)</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
<li id="fn8"></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
<li id="fn10"><a href="#fnref10">↩</a></li>
<li id="fn11"></li>
</ol>
</section>
</body>
</html>
