<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1830">Admissible rule</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Admissible rule</h1>
<hr/>

<p>In <a class="uri" href="logic" title="wikilink">logic</a>, a <a href="rule_of_inference" title="wikilink">rule of inference</a> is <strong>admissible</strong> in a <a href="formal_system" title="wikilink">formal system</a> if the set of <a href="theorem" title="wikilink">theorems</a> of the system does not change when that rule is added to the existing rules of the system. In other words, every <a href="well-formed_formula" title="wikilink">formula</a> that can be <a href="formal_proof" title="wikilink">derived</a> using that rule is already derivable without that rule, so, in a sense, it is redundant. The concept of an admissible rule was introduced by <a href="Paul_Lorenzen" title="wikilink">Paul Lorenzen</a> (1955).</p>
<h2 id="definitions">Definitions</h2>

<p>Admissibility has been systematically studied only in the case of structural rules in <a href="propositional_logic" title="wikilink">propositional</a> <a href="non-classical_logic" title="wikilink">non-classical logics</a>, which we will describe next.</p>

<p>Let a set of basic <a href="logical_connective" title="wikilink">propositional connectives</a> be fixed (for instance, 

<math display="inline" id="Admissible_rule:0">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mo>→</mo>
   <mo>,</mo>
   <mo>∧</mo>
   <mo>,</mo>
   <mo>∨</mo>
   <mo>,</mo>
   <mo>⊥</mo>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <ci>normal-→</ci>
    <and></and>
    <or></or>
    <csymbol cd="latexml">bottom</csymbol>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{\to,\land,\lor,\bot\}
  </annotation>
 </semantics>
</math>

 in the case of <a href="superintuitionistic_logic" title="wikilink">superintuitionistic logics</a>, or 

<math display="inline" id="Admissible_rule:1">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mo>→</mo>
   <mo>,</mo>
   <mo>⊥</mo>
   <mo>,</mo>
   <mi mathvariant="normal">□</mi>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <ci>normal-→</ci>
    <csymbol cd="latexml">bottom</csymbol>
    <ci>normal-□</ci>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{\to,\bot,\Box\}
  </annotation>
 </semantics>
</math>

 in the case of <a href="modal_logic" title="wikilink">monomodal logics</a>). <a href="Well-formed_formulas" title="wikilink">Well-formed formulas</a> are built freely using these connectives from a <a href="countable_set" title="wikilink">countably infinite</a> set of <a href="propositional_variable" title="wikilink">propositional variables</a> <em>p</em><sub><em>n</em></sub>. A <a href="substitution_(logic)" title="wikilink">substitution</a> σ is a function from formulas to formulas which commutes with the connectives, i.e.,</p>

<p>

<math display="block" id="Admissible_rule:2">
 <semantics>
  <mrow>
   <mrow>
    <mi>σ</mi>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>A</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <msub>
      <mi>A</mi>
      <mi>n</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>σ</mi>
      <msub>
       <mi>A</mi>
       <mn>1</mn>
      </msub>
     </mrow>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <mrow>
      <mi>σ</mi>
      <msub>
       <mi>A</mi>
       <mi>n</mi>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>σ</ci>
     <ci>f</ci>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>A</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>A</ci>
       <ci>n</ci>
      </apply>
     </vector>
    </apply>
    <apply>
     <times></times>
     <ci>f</ci>
     <vector>
      <apply>
       <times></times>
       <ci>σ</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>A</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <times></times>
       <ci>σ</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>A</ci>
        <ci>n</ci>
       </apply>
      </apply>
     </vector>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma f(A_{1},\dots,A_{n})=f(\sigma A_{1},\dots,\sigma A_{n})
  </annotation>
 </semantics>
</math>

 for every connective <em>f</em>, and formulas <em>A</em><sub>1</sub>, …, <em>A</em><sub><em>n</em></sub>. (We may also apply substitutions to sets Γ of formulas, making ) A Tarski-style <a href="consequence_relation" title="wikilink">consequence relation</a><a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> is a relation 

<math display="inline" id="Admissible_rule:3">
 <semantics>
  <mo>⊢</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">proves</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vdash
  </annotation>
 </semantics>
</math>

 between sets of formulas, and formulas, such that  for all formulas <em>A</em>, <em>B</em>, and sets of formulas Γ, Δ. A consequence relation such that  for all substitutions σ is called <strong>structural</strong>. (Note that the term "structural" as used here and below is unrelated to the notion of <a href="structural_rule" title="wikilink">structural rules</a> in <a href="sequent_calculus" title="wikilink">sequent calculi</a>.) A structural consequence relation is called a <strong>propositional logic</strong>. A formula <em>A</em> is a theorem of a logic 

<math display="inline" id="Admissible_rule:4">
 <semantics>
  <mo>⊢</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">proves</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vdash
  </annotation>
 </semantics>
</math>

 if 

<math display="inline" id="Admissible_rule:5">
 <semantics>
  <mrow>
   <mi mathvariant="normal">∅</mi>
   <mo>⊢</mo>
   <mi>A</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">proves</csymbol>
    <emptyset></emptyset>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varnothing\vdash A
  </annotation>
 </semantics>
</math>

.</p>

<p>For example, we identify a superintuitionistic logic <em>L</em> with its standard consequence relation 

<math display="inline" id="Admissible_rule:6">
 <semantics>
  <msub>
   <mo>⊢</mo>
   <mi>L</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <csymbol cd="latexml">proves</csymbol>
    <ci>L</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vdash_{L}
  </annotation>
 </semantics>
</math>

 axiomatizable by <a href="modus_ponens" title="wikilink">modus ponens</a> and axioms, and we identify a <a href="normal_modal_logic" title="wikilink">normal modal logic</a> with its global consequence relation 

<math display="inline" id="Admissible_rule:7">
 <semantics>
  <msub>
   <mo>⊢</mo>
   <mi>L</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <csymbol cd="latexml">proves</csymbol>
    <ci>L</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vdash_{L}
  </annotation>
 </semantics>
</math>


 axiomatized by modus ponens, necessitation, and axioms.</p>

<p>A <strong>structural inference rule</strong><a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> (or just <strong>rule</strong> for short) is given by a pair (Γ,<em>B</em>), usually written as</p>

<p>

<math display="block" id="Admissible_rule:8">
 <semantics>
  <mrow>
   <mrow>
    <mfrac>
     <mrow>
      <msub>
       <mi>A</mi>
       <mn>1</mn>
      </msub>
      <mo>,</mo>
      <mi mathvariant="normal">…</mi>
      <mo>,</mo>
      <msub>
       <mi>A</mi>
       <mi>n</mi>
      </msub>
     </mrow>
     <mi>B</mi>
    </mfrac>
    <mtext>or</mtext>
    <msub>
     <mi>A</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mrow>
     <msub>
      <mi>A</mi>
      <mi>n</mi>
     </msub>
     <mo>/</mo>
     <mi>B</mi>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <divide></divide>
     <list>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>A</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>A</ci>
       <ci>n</ci>
      </apply>
     </list>
     <ci>B</ci>
    </apply>
    <mtext>or</mtext>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>A</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <divide></divide>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <ci>n</ci>
     </apply>
     <ci>B</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{A_{1},\dots,A_{n}}{B}\qquad\text{or}\qquad A_{1},\dots,A_{n}/B,
  </annotation>
 </semantics>
</math>

 where Γ = {<em>A</em><sub>1</sub>, …, <em>A</em><sub><em>n</em></sub>} is a finite set of formulas, and <em>B</em> is a formula. An <strong>instance</strong> of the rule is</p>

<p>

<math display="block" id="Admissible_rule:9">
 <semantics>
  <mrow>
   <mrow>
    <mi>σ</mi>
    <msub>
     <mi>A</mi>
     <mn>1</mn>
    </msub>
   </mrow>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <mrow>
    <mrow>
     <mrow>
      <mi>σ</mi>
      <msub>
       <mi>A</mi>
       <mi>n</mi>
      </msub>
     </mrow>
     <mo>/</mo>
     <mi>σ</mi>
    </mrow>
    <mi>B</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <times></times>
     <ci>σ</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <ci>σ</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>A</ci>
        <ci>n</ci>
       </apply>
      </apply>
      <ci>σ</ci>
     </apply>
     <ci>B</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma A_{1},\dots,\sigma A_{n}/\sigma B
  </annotation>
 </semantics>
</math>

 for a substitution σ. The rule Γ/<em>B</em> is <strong>derivable</strong> in 

<math display="inline" id="Admissible_rule:10">
 <semantics>
  <mo>⊢</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">proves</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vdash
  </annotation>
 </semantics>
</math>

, if 

<math display="inline" id="Admissible_rule:11">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Γ</mi>
   <mo>⊢</mo>
   <mi>B</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">proves</csymbol>
    <ci>normal-Γ</ci>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Gamma\vdash B
  </annotation>
 </semantics>
</math>

. It is <strong>admissible</strong> if for every instance of the rule, σ<em>B</em> is a theorem whenever all formulas from σΓ are theorems.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> In other words, a rule is admissible if, when added to the logic, does not lead to new theorems.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> We also write 

<math display="inline" id="Admissible_rule:12">
 <semantics>
  <mrow>
   <mpadded width="+1.7pt">
    <mi mathvariant="normal">Γ</mi>
   </mpadded>
   <mo rspace="0pt" stretchy="false">|</mo>
   <mo>∼</mo>
   <mi>B</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">Γ</csymbol>
    <ci>normal-|</ci>
    <csymbol cd="latexml">similar-to</csymbol>
    <csymbol cd="unknown">B</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Gamma\,|\!\!\!\sim B
  </annotation>
 </semantics>
</math>


 if Γ/<em>B</em> is admissible. (Note that 

<math display="inline" id="Admissible_rule:13">
 <semantics>
  <mrow>
   <mo rspace="0pt" stretchy="false">|</mo>
   <mo>∼</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-|</ci>
    <csymbol cd="latexml">similar-to</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\!\!\!\sim
  </annotation>
 </semantics>
</math>

 is a structural consequence relation on its own.)</p>

<p>Every derivable rule is admissible, but not vice versa in general. A logic is <strong>structurally complete</strong> if every admissible rule is derivable, i.e., 

<math display="inline" id="Admissible_rule:14">
 <semantics>
  <mrow>
   <mo>⊢</mo>
   <mo rspace="4.2pt">=</mo>
   <mo rspace="0pt" stretchy="false">|</mo>
   <mo>∼</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="latexml">proves</csymbol>
    <eq></eq>
    <ci>normal-|</ci>
    <csymbol cd="latexml">similar-to</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\vdash}={\,|\!\!\!\sim}
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>

<p>In logics with a well-behaved <a href="logical_conjunction" title="wikilink">conjunction</a> connective (such as superintuitionistic or modal logics), a rule 

<math display="inline" id="Admissible_rule:15">
 <semantics>
  <mrow>
   <msub>
    <mi>A</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <mrow>
    <msub>
     <mi>A</mi>
     <mi>n</mi>
    </msub>
    <mo>/</mo>
    <mi>B</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>A</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <divide></divide>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <ci>n</ci>
     </apply>
     <ci>B</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{1},\dots,A_{n}/B
  </annotation>
 </semantics>
</math>

 is equivalent to 

<math display="inline" id="Admissible_rule:16">
 <semantics>
  <mrow>
   <msub>
    <mi>A</mi>
    <mn>1</mn>
   </msub>
   <mo>∧</mo>
   <mi mathvariant="normal">…</mi>
   <mo>∧</mo>
   <mrow>
    <msub>
     <mi>A</mi>
     <mi>n</mi>
    </msub>
    <mo>/</mo>
    <mi>B</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>A</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <divide></divide>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <ci>n</ci>
     </apply>
     <ci>B</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{1}\land\dots\land A_{n}/B
  </annotation>
 </semantics>
</math>

 with respect to admissibility and derivability. It is therefore customary to only deal with <a href="unary_operation" title="wikilink">unary</a> rules <em>A</em>/<em>B</em>.</p>
<h2 id="examples">Examples</h2>
<ul>
<li><a href="classical_logic" title="wikilink">Classical propositional calculus</a> (<em>CPC</em>) is structurally complete.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> Indeed, assume that <em>A</em>/<em>B</em> is non-derivable rule, and fix an assignment <em>v</em> such that <em>v</em>(<em>A</em>) = 1, and <em>v</em>(<em>B</em>) = 0. Define a substitution σ such that for every variable <em>p</em>, σ<em>p</em> = 

<math display="inline" id="Admissible_rule:17">
 <semantics>
  <mo>⊤</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">top</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \top
  </annotation>
 </semantics>
</math>


 if <em>v</em>(<em>p</em>) = 1, and σ<em>p</em> = 

<math display="inline" id="Admissible_rule:18">
 <semantics>
  <mo>⊥</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">bottom</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bot
  </annotation>
 </semantics>
</math>

 if <em>v</em>(<em>p</em>) = 0. Then σ<em>A</em> is a theorem, but σ<em>B</em> is not (in fact, ¬σ<em>B</em> is a theorem). Thus the rule <em>A</em>/<em>B</em> is not admissible either. (The same argument applies to any <a href="multi-valued_logic" title="wikilink">multi-valued logic</a> <em>L</em> complete with respect to a logical matrix whose all elements have a name in the language of <em>L</em>.)</li>
<li>The <a href="Georg_Kreisel" title="wikilink">Kreisel</a>–<a href="Hilary_Putnam" title="wikilink">Putnam</a> rule (aka <a href="Ronald_Harrop" title="wikilink">Harrop</a>'s rule, or independence of premise rule)</li>
</ul>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Admissible_rule:19">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>𝐾𝑃𝑅</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mfrac>
    <mrow>
     <mrow>
      <mi mathvariant="normal">¬</mi>
      <mi>p</mi>
     </mrow>
     <mo>→</mo>
     <mrow>
      <mi>q</mi>
      <mo>∨</mo>
      <mi>r</mi>
     </mrow>
    </mrow>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi mathvariant="normal">¬</mi>
      <mi>p</mi>
      <mo>→</mo>
      <mi>q</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>∨</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi mathvariant="normal">¬</mi>
      <mi>p</mi>
      <mo>→</mo>
      <mi>r</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>𝐾𝑃𝑅</ci>
    <apply>
     <divide></divide>
     <apply>
      <ci>normal-→</ci>
      <apply>
       <times></times>
       <not></not>
       <ci>p</ci>
      </apply>
      <apply>
       <or></or>
       <ci>q</ci>
       <ci>r</ci>
      </apply>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <not></not>
       <csymbol cd="unknown">p</csymbol>
       <ci>normal-→</ci>
       <csymbol cd="unknown">q</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <or></or>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <not></not>
       <csymbol cd="unknown">p</csymbol>
       <ci>normal-→</ci>
       <csymbol cd="unknown">r</csymbol>
       <ci>normal-)</ci>
      </cerror>
     </cerror>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\mathit{KPR})\qquad\frac{\neg p\to q\lor r}{(\neg p\to q)\lor(\neg p\to r)}
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
<dd>is admissible in the <a href="intuitionistic_logic" title="wikilink">intuitionistic propositional calculus</a> (<em>IPC</em>). In fact, it is admissible in every superintuitionistic logic.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> On the other hand, the formula

<p>

<math display="block" id="Admissible_rule:20">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi mathvariant="normal">¬</mi>
    <mi>p</mi>
    <mo>→</mo>
    <mi>q</mi>
    <mo>∨</mo>
    <mi>r</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi mathvariant="normal">¬</mi>
    <mi>p</mi>
    <mo>→</mo>
    <mi>q</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∨</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi mathvariant="normal">¬</mi>
    <mi>p</mi>
    <mo>→</mo>
    <mi>r</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <not></not>
     <csymbol cd="unknown">p</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">q</csymbol>
     <or></or>
     <csymbol cd="unknown">r</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <not></not>
     <csymbol cd="unknown">p</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">q</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <or></or>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <not></not>
     <csymbol cd="unknown">p</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">r</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\neg p\to q\lor r)\to(\neg p\to q)\lor(\neg p\to r)
  </annotation>
 </semantics>
</math>

</p>
</dd>
<dd>is not an intuitionistic tautology, hence <em>KPR</em> is not derivable in <em>IPC</em>. In particular, <em>IPC</em> is not structurally complete.
</dd>
</dl>
<ul>
<li>The rule</li>
</ul>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Admissible_rule:21">
 <semantics>
  <mfrac>
   <mrow>
    <mi mathvariant="normal">□</mi>
    <mi>p</mi>
   </mrow>
   <mi>p</mi>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <times></times>
     <ci>normal-□</ci>
     <ci>p</ci>
    </apply>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{\Box p}{p}
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
<dd>is admissible in many modal logics, such as <em>K</em>, <em>D</em>, <em>K</em>4, <em>S</em>4, <em>GL</em> (see <a href="Kripke_semantics#Correspondence_and_completeness" title="wikilink">this table</a> for names of modal logics). It is derivable in <em>S</em>4, but it is not derivable in <em>K</em>, <em>D</em>, <em>K</em>4, or <em>GL</em>.
</dd>
</dl>
<ul>
<li>The rule</li>
</ul>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Admissible_rule:22">
 <semantics>
  <mfrac>
   <mrow>
    <mrow>
     <mi mathvariant="normal">◇</mi>
     <mi>p</mi>
    </mrow>
    <mo>∧</mo>
    <mrow>
     <mi mathvariant="normal">◇</mi>
     <mi mathvariant="normal">¬</mi>
     <mi>p</mi>
    </mrow>
   </mrow>
   <mo>⊥</mo>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <and></and>
     <apply>
      <times></times>
      <ci>normal-◇</ci>
      <ci>p</ci>
     </apply>
     <apply>
      <times></times>
      <ci>normal-◇</ci>
      <not></not>
      <ci>p</ci>
     </apply>
    </apply>
    <csymbol cd="latexml">bottom</csymbol>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{\Diamond p\land\Diamond\neg p}{\bot}
  </annotation>
 </semantics>
</math>



</dd>
</dl>
</dd>
<dd>is admissible in every normal modal logic.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> It is derivable in <em>GL</em> and <em>S</em>4.1, but it is not derivable in <em>K</em>, <em>D</em>, <em>K</em>4, <em>S</em>4, <em>S</em>5.
</dd>
</dl>
<ul>
<li><a href="Löb's_theorem" title="wikilink">Löb's rule</a></li>
</ul>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Admissible_rule:23">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>𝐿𝑅</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mfrac>
    <mrow>
     <mrow>
      <mi mathvariant="normal">□</mi>
      <mi>p</mi>
     </mrow>
     <mo>→</mo>
     <mi>p</mi>
    </mrow>
    <mi>p</mi>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>𝐿𝑅</ci>
    <apply>
     <divide></divide>
     <apply>
      <ci>normal-→</ci>
      <apply>
       <times></times>
       <ci>normal-□</ci>
       <ci>p</ci>
      </apply>
      <ci>p</ci>
     </apply>
     <ci>p</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\mathit{LR})\qquad\frac{\Box p\to p}{p}
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
<dd>is admissible (but not derivable) in the basic modal logic <em>K</em>, and it is derivable in <em>GL</em>. However, <em>LR</em> is not admissible in <em>K</em>4. In particular, it is <em>not</em> true in general that a rule admissible in a logic <em>L</em> must be admissible in its extensions.
</dd>
</dl>
<ul>
<li>The <a href="intermediate_logic" title="wikilink">Gödel–Dummett logic</a> (<em>LC</em>), and the modal logic <em>Grz</em>.3 are structurally complete.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> The <a href="t-norm_fuzzy_logics" title="wikilink">product fuzzy logic</a> is also structurally complete.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a></li>
</ul>
<h2 id="decidability-and-reduced-rules">Decidability and reduced rules</h2>

<p>The basic question about admissible rules of a given logic is whether the set of all admissible rules is <a href="decidable_set" title="wikilink">decidable</a>. Note that the problem is nontrivial even if the logic itself (i.e., its set of theorems) is <a href="decidability_(logic)" title="wikilink">decidable</a>: the definition of admissibility of a rule <em>A</em>/<em>B</em> involves an unbounded <a href="universal_quantifier" title="wikilink">universal quantifier</a> over all propositional substitutions, hence <em>a priori</em> we only know that admissibility of rule in a decidable logic is 

<math display="inline" id="Admissible_rule:24">
 <semantics>
  <msubsup>
   <mi mathvariant="normal">Π</mi>
   <mn>1</mn>
   <mn>0</mn>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-Π</ci>
     <cn type="integer">0</cn>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Pi^{0}_{1}
  </annotation>
 </semantics>
</math>

 (i.e., its complement is <a href="recursively_enumerable" title="wikilink">recursively enumerable</a>). For instance, it is known that admissibility in the bimodal logics <em>K</em><sub><em>u</em></sub> and <em>K</em>4<sub><em>u</em></sub> (the extensions of <em>K</em> or <em>K</em>4 with the <a href="universal_modality" title="wikilink">universal modality</a>) is undecidable.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> Remarkably, decidability of admissibility in the basic modal logic <em>K</em> is a major open problem.</p>

<p>Nevertheless, admissibility of rules is known to be decidable in many modal and superintuitionistic logics. The first decision procedures for admissible rules in basic transitive modal logics were constructed by <a href="Vladimir_V._Rybakov" title="wikilink">Rybakov</a>, using the <strong>reduced form of rules</strong>.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> A modal rule in variables <em>p</em><sub>0</sub>, …, <em>p</em><sub><em>k</em></sub> is called reduced if it has the form</p>

<p>

<math display="block" id="Admissible_rule:25">
 <semantics>
  <mrow>
   <mfrac>
    <mrow>
     <msubsup>
      <mo largeop="true" mathsize="160%" stretchy="false" symmetric="true">⋁</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>0</mn>
      </mrow>
      <mi>n</mi>
     </msubsup>
     <mrow>
      <mo maxsize="120%" minsize="120%">(</mo>
      <mrow>
       <mrow>
        <msubsup>
         <mo largeop="true" mathsize="160%" stretchy="false" symmetric="true">⋀</mo>
         <mrow>
          <mi>j</mi>
          <mo>=</mo>
          <mn>0</mn>
         </mrow>
         <mi>k</mi>
        </msubsup>
        <mrow>
         <msubsup>
          <mi mathvariant="normal">¬</mi>
          <mrow>
           <mi>i</mi>
           <mo>,</mo>
           <mi>j</mi>
          </mrow>
          <mn>0</mn>
         </msubsup>
         <msub>
          <mi>p</mi>
          <mi>j</mi>
         </msub>
        </mrow>
       </mrow>
       <mo>∧</mo>
       <mrow>
        <msubsup>
         <mo largeop="true" mathsize="160%" stretchy="false" symmetric="true">⋀</mo>
         <mrow>
          <mi>j</mi>
          <mo>=</mo>
          <mn>0</mn>
         </mrow>
         <mi>k</mi>
        </msubsup>
        <mrow>
         <msubsup>
          <mi mathvariant="normal">¬</mi>
          <mrow>
           <mi>i</mi>
           <mo>,</mo>
           <mi>j</mi>
          </mrow>
          <mn>1</mn>
         </msubsup>
         <mi mathvariant="normal">□</mi>
         <msub>
          <mi>p</mi>
          <mi>j</mi>
         </msub>
        </mrow>
       </mrow>
      </mrow>
      <mo maxsize="120%" minsize="120%">)</mo>
     </mrow>
    </mrow>
    <msub>
     <mi>p</mi>
     <mn>0</mn>
    </msub>
   </mfrac>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <or></or>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <ci>n</ci>
     </apply>
     <apply>
      <and></and>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <and></and>
         <apply>
          <eq></eq>
          <ci>j</ci>
          <cn type="integer">0</cn>
         </apply>
        </apply>
        <ci>k</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <not></not>
          <list>
           <ci>i</ci>
           <ci>j</ci>
          </list>
         </apply>
         <cn type="integer">0</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>p</ci>
         <ci>j</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <and></and>
         <apply>
          <eq></eq>
          <ci>j</ci>
          <cn type="integer">0</cn>
         </apply>
        </apply>
        <ci>k</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <not></not>
          <list>
           <ci>i</ci>
           <ci>j</ci>
          </list>
         </apply>
         <cn type="integer">1</cn>
        </apply>
        <ci>normal-□</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>p</ci>
         <ci>j</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>p</ci>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{\bigvee_{i=0}^{n}\bigl(\bigwedge_{j=0}^{k}\neg_{i,j}^{0}p_{j}\land%
\bigwedge_{j=0}^{k}\neg_{i,j}^{1}\Box p_{j}\bigr)}{p_{0}},
  </annotation>
 </semantics>
</math>

 where each 

<math display="inline" id="Admissible_rule:26">
 <semantics>
  <msubsup>
   <mi mathvariant="normal">¬</mi>
   <mrow>
    <mi>i</mi>
    <mo>,</mo>
    <mi>j</mi>
   </mrow>
   <mi>u</mi>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <not></not>
     <list>
      <ci>i</ci>
      <ci>j</ci>
     </list>
    </apply>
    <ci>u</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg_{i,j}^{u}
  </annotation>
 </semantics>
</math>

 is either blank, or <a href="logical_negation" title="wikilink">negation</a> 

<math display="inline" id="Admissible_rule:27">
 <semantics>
  <mi mathvariant="normal">¬</mi>
  <annotation-xml encoding="MathML-Content">
   <not></not>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg
  </annotation>
 </semantics>
</math>


. For each rule <em>r</em>, we can effectively construct a reduced rule <em>s</em> (called the reduced form of <em>r</em>) such that any logic admits (or derives) <em>r</em> if and only if it admits (or derives) <em>s</em>, by introducing <a href="extension_variable" title="wikilink">extension variables</a> for all subformulas in <em>A</em>, and expressing the result in the full <a href="disjunctive_normal_form" title="wikilink">disjunctive normal form</a>. It is thus sufficient to construct a decision algorithm for admissibility of reduced rules.</p>

<p>Let 

<math display="inline" id="Admissible_rule:28">
 <semantics>
  <mrow>
   <msubsup>
    <mo largeop="true" mathsize="160%" stretchy="false" symmetric="true">⋁</mo>
    <mrow>
     <mi>i</mi>
     <mo>=</mo>
     <mn>0</mn>
    </mrow>
    <mi>n</mi>
   </msubsup>
   <mrow>
    <msub>
     <mi>φ</mi>
     <mi>i</mi>
    </msub>
    <mo>/</mo>
    <msub>
     <mi>p</mi>
     <mn>0</mn>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <or></or>
      <apply>
       <eq></eq>
       <ci>i</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
     <ci>n</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>φ</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>p</ci>
      <cn type="integer">0</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle\bigvee_{i=0}^{n}\varphi_{i}/p_{0}
  </annotation>
 </semantics>
</math>

 be a reduced rule as above. We identify every conjunction 

<math display="inline" id="Admissible_rule:29">
 <semantics>
  <msub>
   <mi>φ</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>φ</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varphi_{i}
  </annotation>
 </semantics>
</math>

 with the set 

<math display="inline" id="Admissible_rule:30">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mrow>
    <mrow>
     <msubsup>
      <mi mathvariant="normal">¬</mi>
      <mrow>
       <mi>i</mi>
       <mo>,</mo>
       <mi>j</mi>
      </mrow>
      <mn>0</mn>
     </msubsup>
     <msub>
      <mi>p</mi>
      <mi>j</mi>
     </msub>
    </mrow>
    <mo>,</mo>
    <mrow>
     <msubsup>
      <mi mathvariant="normal">¬</mi>
      <mrow>
       <mi>i</mi>
       <mo>,</mo>
       <mi>j</mi>
      </mrow>
      <mn>1</mn>
     </msubsup>
     <mi mathvariant="normal">□</mi>
     <msub>
      <mi>p</mi>
      <mi>j</mi>
     </msub>
    </mrow>
   </mrow>
   <mo>∣</mo>
   <mrow>
    <mi>j</mi>
    <mo>≤</mo>
    <mi>k</mi>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">conditional-set</csymbol>
    <list>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <not></not>
        <list>
         <ci>i</ci>
         <ci>j</ci>
        </list>
       </apply>
       <cn type="integer">0</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <ci>j</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <not></not>
        <list>
         <ci>i</ci>
         <ci>j</ci>
        </list>
       </apply>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-□</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <ci>j</ci>
      </apply>
     </apply>
    </list>
    <apply>
     <leq></leq>
     <ci>j</ci>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{\neg_{i,j}^{0}p_{j},\neg_{i,j}^{1}\Box p_{j}\mid j\leq k\}
  </annotation>
 </semantics>
</math>

 of its conjuncts. For any subset <em>W</em> of the set 

<math display="inline" id="Admissible_rule:31">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <msub>
    <mi>φ</mi>
    <mi>i</mi>
   </msub>
   <mo>∣</mo>
   <mrow>
    <mi>i</mi>
    <mo>≤</mo>
    <mi>n</mi>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">conditional-set</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>φ</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <leq></leq>
     <ci>i</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{\varphi_{i}\mid i\leq n\}
  </annotation>
 </semantics>
</math>

 of all conjunctions, let us define a <a href="Kripke_model" title="wikilink">Kripke model</a> 

<math display="inline" id="Admissible_rule:32">
 <semantics>
  <mrow>
   <mi>M</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mi>W</mi>
    <mo>,</mo>
    <mi>R</mi>
    <mo>,</mo>
    <mo>⊩</mo>
    <mo stretchy="false">⟩</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>M</ci>
    <list>
     <ci>W</ci>
     <ci>R</ci>
     <csymbol cd="latexml">forces</csymbol>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M=\langle W,R,{\Vdash}\rangle
  </annotation>
 </semantics>
</math>


 by</p>

<p>

<math display="block" id="Admissible_rule:33">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>φ</mi>
      <mi>i</mi>
     </msub>
     <mo>⊩</mo>
     <msub>
      <mi>p</mi>
      <mi>j</mi>
     </msub>
    </mrow>
    <mo>⇔</mo>
    <mrow>
     <msub>
      <mi>p</mi>
      <mi>j</mi>
     </msub>
     <mo>∈</mo>
     <msub>
      <mi>φ</mi>
      <mi>i</mi>
     </msub>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">iff</csymbol>
    <apply>
     <csymbol cd="latexml">forces</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>φ</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>p</ci>
      <ci>j</ci>
     </apply>
    </apply>
    <apply>
     <in></in>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>p</ci>
      <ci>j</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>φ</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varphi_{i}\Vdash p_{j}\iff p_{j}\in\varphi_{i},
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Admissible_rule:34">
 <semantics>
  <mrow>
   <mpadded width="+1.7pt">
    <msub>
     <mi>φ</mi>
     <mi>i</mi>
    </msub>
   </mpadded>
   <mpadded width="+1.7pt">
    <mi>R</mi>
   </mpadded>
   <msub>
    <mi>φ</mi>
    <msup>
     <mi>i</mi>
     <mo>′</mo>
    </msup>
   </msub>
   <mo>⇔</mo>
   <mo>∀</mo>
   <mi>j</mi>
   <mo>≤</mo>
   <mpadded width="+1.7pt">
    <mi>k</mi>
   </mpadded>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi mathvariant="normal">□</mi>
    <msub>
     <mi>p</mi>
     <mi>j</mi>
    </msub>
    <mo>∈</mo>
    <msub>
     <mi>φ</mi>
     <mi>i</mi>
    </msub>
    <mo>⇒</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <msub>
      <mi>p</mi>
      <mi>j</mi>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">□</mi>
     <msub>
      <mi>p</mi>
      <mi>j</mi>
     </msub>
     <mo stretchy="false">}</mo>
    </mrow>
    <mo>⊆</mo>
    <msub>
     <mi>φ</mi>
     <msup>
      <mi>i</mi>
      <mo>′</mo>
     </msup>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>φ</ci>
     <ci>i</ci>
    </apply>
    <csymbol cd="unknown">R</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>φ</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>i</ci>
      <ci>normal-′</ci>
     </apply>
    </apply>
    <csymbol cd="latexml">iff</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">j</csymbol>
    <leq></leq>
    <csymbol cd="unknown">k</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">□</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>p</ci>
      <ci>j</ci>
     </apply>
     <in></in>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>φ</ci>
      <ci>i</ci>
     </apply>
     <ci>normal-⇒</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-{</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <ci>j</ci>
      </apply>
      <ci>normal-,</ci>
      <csymbol cd="unknown">□</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <ci>j</ci>
      </apply>
      <ci>normal-}</ci>
     </cerror>
     <subset></subset>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>φ</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>i</ci>
       <ci>normal-′</ci>
      </apply>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-.</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varphi_{i}\,R\,\varphi_{i^{\prime}}\iff\forall j\leq k\,(\Box p_{j}\in\varphi%
_{i}\Rightarrow\{p_{j},\Box p_{j}\}\subseteq\varphi_{i^{\prime}}).
  </annotation>
 </semantics>
</math>

 Then the following provides an algorithmic criterion for admissibility in <em>K</em>4:<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a></p>

<p><strong>Theorem</strong>. The rule 

<math display="inline" id="Admissible_rule:35">
 <semantics>
  <mrow>
   <msubsup>
    <mo largeop="true" mathsize="160%" stretchy="false" symmetric="true">⋁</mo>
    <mrow>
     <mi>i</mi>
     <mo>=</mo>
     <mn>0</mn>
    </mrow>
    <mi>n</mi>
   </msubsup>
   <mrow>
    <msub>
     <mi>φ</mi>
     <mi>i</mi>
    </msub>
    <mo>/</mo>
    <msub>
     <mi>p</mi>
     <mn>0</mn>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <or></or>
      <apply>
       <eq></eq>
       <ci>i</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
     <ci>n</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>φ</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>p</ci>
      <cn type="integer">0</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle\bigvee_{i=0}^{n}\varphi_{i}/p_{0}
  </annotation>
 </semantics>
</math>

 is <em>not</em> admissible in <em>K</em>4 if and only if there exists a set 

<math display="inline" id="Admissible_rule:36">
 <semantics>
  <mrow>
   <mi>W</mi>
   <mo>⊆</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <msub>
     <mi>φ</mi>
     <mi>i</mi>
    </msub>
    <mo>∣</mo>
    <mrow>
     <mi>i</mi>
     <mo>≤</mo>
     <mi>n</mi>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <ci>W</ci>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>φ</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <leq></leq>
      <ci>i</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W\subseteq\{\varphi_{i}\mid i\leq n\}
  </annotation>
 </semantics>
</math>

 such that</p>
<ol>
<li>

<math display="inline" id="Admissible_rule:37">
 <semantics>
  <mrow>
   <msub>
    <mi>φ</mi>
    <mi>i</mi>
   </msub>
   <mo>⊮</mo>
   <msub>
    <mi>p</mi>
    <mn>0</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">not-forces</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>φ</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>p</ci>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varphi_{i}\nVdash p_{0}
  </annotation>
 </semantics>
</math>


 for some 

<math display="inline" id="Admissible_rule:38">
 <semantics>
  <mrow>
   <mrow>
    <mi>i</mi>
    <mo>≤</mo>
    <mi>n</mi>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <ci>i</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i\leq n,
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="Admissible_rule:39">
 <semantics>
  <mrow>
   <msub>
    <mi>φ</mi>
    <mi>i</mi>
   </msub>
   <mo>⊩</mo>
   <msub>
    <mi>φ</mi>
    <mi>i</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">forces</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>φ</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>φ</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varphi_{i}\Vdash\varphi_{i}
  </annotation>
 </semantics>
</math>

 for every 

<math display="inline" id="Admissible_rule:40">
 <semantics>
  <mrow>
   <mrow>
    <mi>i</mi>
    <mo>≤</mo>
    <mi>n</mi>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <ci>i</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i\leq n,
  </annotation>
 </semantics>
</math>

</li>
<li>for every subset <em>D</em> of <em>W</em> there exist elements 

<math display="inline" id="Admissible_rule:41">
 <semantics>
  <mrow>
   <mrow>
    <mi>α</mi>
    <mo>,</mo>
    <mi>β</mi>
   </mrow>
   <mo>∈</mo>
   <mi>W</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <list>
     <ci>α</ci>
     <ci>β</ci>
    </list>
    <ci>W</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha,\beta\in W
  </annotation>
 </semantics>
</math>

 such that the equivalences</li>
</ol>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Admissible_rule:42">
 <semantics>
  <mrow>
   <mi>α</mi>
   <mo>⊩</mo>
   <mrow>
    <mi mathvariant="normal">□</mi>
    <msub>
     <mi>p</mi>
     <mi>j</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">forces</csymbol>
    <ci>α</ci>
    <apply>
     <times></times>
     <ci>normal-□</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>p</ci>
      <ci>j</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha\Vdash\Box p_{j}
  </annotation>
 </semantics>
</math>


 if and only if 

<math display="inline" id="Admissible_rule:43">
 <semantics>
  <mrow>
   <mi>φ</mi>
   <mo>⊩</mo>
   <mrow>
    <msub>
     <mi>p</mi>
     <mi>j</mi>
    </msub>
    <mo>∧</mo>
    <mrow>
     <mi mathvariant="normal">□</mi>
     <msub>
      <mi>p</mi>
      <mi>j</mi>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">forces</csymbol>
    <ci>φ</ci>
    <apply>
     <and></and>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>p</ci>
      <ci>j</ci>
     </apply>
     <apply>
      <times></times>
      <ci>normal-□</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <ci>j</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varphi\Vdash p_{j}\land\Box p_{j}
  </annotation>
 </semantics>
</math>

 for every 

<math display="inline" id="Admissible_rule:44">
 <semantics>
  <mrow>
   <mi>φ</mi>
   <mo>∈</mo>
   <mi>D</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>φ</ci>
    <ci>D</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varphi\in D
  </annotation>
 </semantics>
</math>


</dd>
<dd>

<math display="inline" id="Admissible_rule:45">
 <semantics>
  <mrow>
   <mi>α</mi>
   <mo>⊩</mo>
   <mrow>
    <mi mathvariant="normal">□</mi>
    <msub>
     <mi>p</mi>
     <mi>j</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">forces</csymbol>
    <ci>α</ci>
    <apply>
     <times></times>
     <ci>normal-□</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>p</ci>
      <ci>j</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha\Vdash\Box p_{j}
  </annotation>
 </semantics>
</math>

 if and only if 

<math display="inline" id="Admissible_rule:46">
 <semantics>
  <mrow>
   <mi>α</mi>
   <mo>⊩</mo>
   <msub>
    <mi>p</mi>
    <mi>j</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">forces</csymbol>
    <ci>α</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>p</ci>
     <ci>j</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha\Vdash p_{j}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Admissible_rule:47">
 <semantics>
  <mrow>
   <mi>φ</mi>
   <mo>⊩</mo>
   <mrow>
    <msub>
     <mi>p</mi>
     <mi>j</mi>
    </msub>
    <mo>∧</mo>
    <mrow>
     <mi mathvariant="normal">□</mi>
     <msub>
      <mi>p</mi>
      <mi>j</mi>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">forces</csymbol>
    <ci>φ</ci>
    <apply>
     <and></and>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>p</ci>
      <ci>j</ci>
     </apply>
     <apply>
      <times></times>
      <ci>normal-□</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <ci>j</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varphi\Vdash p_{j}\land\Box p_{j}
  </annotation>
 </semantics>
</math>


 for every 

<math display="inline" id="Admissible_rule:48">
 <semantics>
  <mrow>
   <mi>φ</mi>
   <mo>∈</mo>
   <mi>D</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>φ</ci>
    <ci>D</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varphi\in D
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
<dd>hold for all <em>j</em>.
</dd>
</dl>

<p>Similar criteria can be found for the logics <em>S</em>4, <em>GL</em>, and <em>Grz</em>.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a> Furthermore, admissibility in intuitionistic logic can be reduced to admissibility in <em>Grz</em> using the <a href="modal_companion" title="wikilink">Gödel–McKinsey–Tarski translation</a>:<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a></p>

<p>

<math display="block" id="Admissible_rule:49">
 <semantics>
  <mrow>
   <mpadded width="+1.7pt">
    <mi>A</mi>
   </mpadded>
   <mo rspace="0pt" stretchy="false">|</mo>
   <msub>
    <mo>∼</mo>
    <mrow>
     <mi>I</mi>
     <mi>P</mi>
     <mi>C</mi>
    </mrow>
   </msub>
   <mi>B</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">A</csymbol>
    <ci>normal-|</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">similar-to</csymbol>
     <apply>
      <times></times>
      <ci>I</ci>
      <ci>P</ci>
      <ci>C</ci>
     </apply>
    </apply>
    <csymbol cd="unknown">B</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\,|\!\!\!\sim_{IPC}B
  </annotation>
 </semantics>
</math>

 if and only if 

<math display="inline" id="Admissible_rule:50">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>A</mi>
    <mo rspace="4.2pt" stretchy="false">)</mo>
   </mrow>
   <mo rspace="0pt" stretchy="false">|</mo>
   <msub>
    <mo>∼</mo>
    <mrow>
     <mi>G</mi>
     <mi>r</mi>
     <mi>z</mi>
    </mrow>
   </msub>
   <mi>T</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>B</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">T</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">A</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-|</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">similar-to</csymbol>
     <apply>
      <times></times>
      <ci>G</ci>
      <ci>r</ci>
      <ci>z</ci>
     </apply>
    </apply>
    <csymbol cd="unknown">T</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">B</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-.</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T(A)\,|\!\!\!\sim_{Grz}T(B).
  </annotation>
 </semantics>
</math>

</p>

<p>Rybakov (1997) developed much more sophisticated techniques for showing decidability of admissibility, which apply to a robust (infinite) class of transitive (i.e., extending <em>K</em>4 or <em>IPC</em>) modal and superintuitionistic logics, including e.g. <em>S</em>4.1, <em>S</em>4.2, <em>S</em>4.3, <em>KC</em>, <em>T</em><sub><em>k</em></sub> (as well as the above mentioned logics <em>IPC</em>, <em>K</em>4, <em>S</em>4, <em>GL</em>, <em>Grz</em>).<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a></p>

<p>Despite being decidable, the admissibility problem has relatively high <a href="Computational_complexity_theory" title="wikilink">computational complexity</a>, even in simple logics: admissibility of rules in the basic transitive logics <em>IPC</em>, <em>K</em>4, <em>S</em>4, <em>GL</em>, <em>Grz</em> is <a href="NEXP" title="wikilink">coNEXP</a>-complete.<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a> This should be contrasted with the derivability problem (for rules or formulas) in these logics, which is <a class="uri" href="PSPACE" title="wikilink">PSPACE</a>-complete.<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a></p>
<h2 id="projectivity-and-unification">Projectivity and unification</h2>

<p>Admissibility in propositional logics is closely related to <a class="uri" href="unification" title="wikilink">unification</a> in the <a href="equational_theory" title="wikilink">equational theory</a> of <a href="modal_algebra" title="wikilink">modal</a> or <a href="Heyting_algebra" title="wikilink">Heyting algebras</a>. The connection was developed by Ghilardi (1999, 2000). In the logical setup, a <strong>unifier</strong> of a formula <em>A</em> in a logic <em>L</em> (an <em>L</em>-unifier for short) is a substitution σ such that σ<em>A</em> is a theorem of <em>L</em>. (Using this notion, we can rephrase admissibility of a rule <em>A</em>/<em>B</em> in <em>L</em> as "every <em>L</em>-unifier of <em>A</em> is an <em>L</em>-unifier of <em>B</em>".) An <em>L</em>-unifier σ is <strong>less general</strong> than an <em>L</em>-unifier τ, written as σ ≤ τ, if there exists a substitution υ such that</p>

<p>

<math display="block" id="Admissible_rule:51">
 <semantics>
  <mrow>
   <msub>
    <mo>⊢</mo>
    <mi>L</mi>
   </msub>
   <mi>σ</mi>
   <mi>p</mi>
   <mo>↔</mo>
   <mi>υ</mi>
   <mi>τ</mi>
   <mi>p</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">proves</csymbol>
     <ci>L</ci>
    </apply>
    <csymbol cd="unknown">σ</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <ci>normal-↔</ci>
    <csymbol cd="unknown">υ</csymbol>
    <csymbol cd="unknown">τ</csymbol>
    <csymbol cd="unknown">p</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vdash_{L}\sigma p\leftrightarrow\upsilon\tau p
  </annotation>
 </semantics>
</math>

 for every variable <em>p</em>. A <strong>complete set of unifiers</strong> of a formula <em>A</em> is a set <em>S</em> of <em>L</em>-unifiers of <em>A</em> such that every <em>L</em>-unifier of <em>A</em> is less general than some unifier from <em>S</em>. A <a href="most_general_unifier" title="wikilink">most general unifier</a> (mgu) of <em>A</em> is a unifier σ such that {σ} is a complete set of unifiers of <em>A</em>. It follows that if <em>S</em> is a complete set of unifiers of <em>A</em>, then a rule <em>A</em>/<em>B</em> is <em>L</em>-admissible if and only if every σ in <em>S</em> is an <em>L</em>-unifier of <em>B</em>. Thus we can characterize admissible rules if we can find well-behaved complete sets of unifiers.</p>

<p>An important class of formulas which have a most general unifier are the <strong>projective formulas</strong>: these are formulas <em>A</em> such that there exists a unifier σ of <em>A</em> such that</p>

<p>

<math display="block" id="Admissible_rule:52">
 <semantics>
  <mrow>
   <mi>A</mi>
   <msub>
    <mo>⊢</mo>
    <mi>L</mi>
   </msub>
   <mi>B</mi>
   <mo>↔</mo>
   <mi>σ</mi>
   <mi>B</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">A</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">proves</csymbol>
     <ci>L</ci>
    </apply>
    <csymbol cd="unknown">B</csymbol>
    <ci>normal-↔</ci>
    <csymbol cd="unknown">σ</csymbol>
    <csymbol cd="unknown">B</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\vdash_{L}B\leftrightarrow\sigma B
  </annotation>
 </semantics>
</math>

 for every formula <em>B</em>. Note that σ is a mgu of <em>A</em>. In transitive modal and superintuitionistic logics with the <a href="Kripke_semantics#Finite_model_property" title="wikilink">finite model property</a> (fmp), one can characterize projective formulas semantically as those whose set of finite <em>L</em>-models has the <strong>extension property</strong>:<a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a> if <em>M</em> is a finite Kripke <em>L</em>-model with a root <em>r</em> whose cluster is a <a href="singleton_(mathematics)" title="wikilink">singleton</a>, and the formula <em>A</em> holds in all points of <em>M</em> except for <em>r</em>, then we can change the valuation of variables in <em>r</em> so as to make <em>A</em> true in <em>r</em> as well. Moreover, the proof provides an explicit construction of a mgu for a given projective formula <em>A</em>.</p>

<p>In the basic transitive logics <em>IPC</em>, <em>K</em>4, <em>S</em>4, <em>GL</em>, <em>Grz</em> (and more generally in any transitive logic with the fmp whose set of finite frame satisfies another kind of extension property), we can effectively construct for any formula <em>A</em> its <strong>projective approximation</strong> Π(<em>A</em>):<a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a> a finite set of projective formulas such that</p>
<ol>
<li>

<math display="inline" id="Admissible_rule:53">
 <semantics>
  <mrow>
   <mi>P</mi>
   <msub>
    <mo>⊢</mo>
    <mi>L</mi>
   </msub>
   <mi>A</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">proves</csymbol>
     <ci>L</ci>
    </apply>
    <csymbol cd="unknown">A</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P\vdash_{L}A
  </annotation>
 </semantics>
</math>

 for every 

<math display="inline" id="Admissible_rule:54">
 <semantics>
  <mrow>
   <mrow>
    <mi>P</mi>
    <mo>∈</mo>
    <mrow>
     <mi mathvariant="normal">Π</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>A</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>P</ci>
    <apply>
     <times></times>
     <ci>normal-Π</ci>
     <ci>A</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P\in\Pi(A),
  </annotation>
 </semantics>
</math>

</li>
<li>every unifier of <em>A</em> is a unifier of a formula from Π(<em>A</em>).</li>
</ol>

<p>It follows that the set of mgus of elements of Π(<em>A</em>) is a complete set of unifiers of <em>A</em>. Furthermore, if <em>P</em> is a projective formula, then</p>

<p>

<math display="block" id="Admissible_rule:55">
 <semantics>
  <mrow>
   <mpadded width="+1.7pt">
    <mi>P</mi>
   </mpadded>
   <mo rspace="0pt" stretchy="false">|</mo>
   <msub>
    <mo>∼</mo>
    <mi>L</mi>
   </msub>
   <mi>B</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <ci>normal-|</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">similar-to</csymbol>
     <ci>L</ci>
    </apply>
    <csymbol cd="unknown">B</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P\,|\!\!\!\sim_{L}B
  </annotation>
 </semantics>
</math>

 if and only if 

<math display="inline" id="Admissible_rule:56">
 <semantics>
  <mrow>
   <mi>P</mi>
   <msub>
    <mo>⊢</mo>
    <mi>L</mi>
   </msub>
   <mi>B</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">proves</csymbol>
     <ci>L</ci>
    </apply>
    <csymbol cd="unknown">B</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P\vdash_{L}B
  </annotation>
 </semantics>
</math>

 for any formula <em>B</em>. Thus we obtain the following effective characterization of admissible rules:<a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a></p>

<p>

<math display="block" id="Admissible_rule:57">
 <semantics>
  <mrow>
   <mpadded width="+1.7pt">
    <mi>A</mi>
   </mpadded>
   <mo rspace="0pt" stretchy="false">|</mo>
   <msub>
    <mo>∼</mo>
    <mi>L</mi>
   </msub>
   <mi>B</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">A</csymbol>
    <ci>normal-|</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">similar-to</csymbol>
     <ci>L</ci>
    </apply>
    <csymbol cd="unknown">B</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\,|\!\!\!\sim_{L}B
  </annotation>
 </semantics>
</math>

 if and only if 

<math display="inline" id="Admissible_rule:58">
 <semantics>
  <mrow>
   <mo>∀</mo>
   <mi>P</mi>
   <mo>∈</mo>
   <mi mathvariant="normal">Π</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>A</mi>
    <mo rspace="4.2pt" stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>P</mi>
    <msub>
     <mo>⊢</mo>
     <mi>L</mi>
    </msub>
    <mi>B</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <in></in>
    <csymbol cd="unknown">Π</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">A</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">P</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">proves</csymbol>
      <ci>L</ci>
     </apply>
     <csymbol cd="unknown">B</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-.</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall P\in\Pi(A)\,(P\vdash_{L}B).
  </annotation>
 </semantics>
</math>

</p>
<h2 id="bases-of-admissible-rules">Bases of admissible rules</h2>

<p>Let <em>L</em> be a logic. A set <em>R</em> of <em>L</em>-admissible rule is called a <strong>basis</strong><a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a> of admissible rules, if every admissible rule Γ/<em>B</em> can be derived from <em>R</em> and the derivable rules of <em>L</em>, using substitution, composition, and weakening. In other words, <em>R</em> is a basis if and only if 

<math display="inline" id="Admissible_rule:59">
 <semantics>
  <mrow>
   <mo rspace="0pt" stretchy="false">|</mo>
   <msub>
    <mo>∼</mo>
    <mi>L</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-|</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">similar-to</csymbol>
     <ci>L</ci>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\!\!\!\sim_{L}
  </annotation>
 </semantics>
</math>

 is the smallest structural consequence relation which includes 

<math display="inline" id="Admissible_rule:60">
 <semantics>
  <msub>
   <mo>⊢</mo>
   <mi>L</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <csymbol cd="latexml">proves</csymbol>
    <ci>L</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vdash_{L}
  </annotation>
 </semantics>
</math>

 and <em>R</em>.</p>

<p>Notice that decidability of admissible rules of a decidable logic is equivalent to the existence of recursive (or <a href="recursively_enumerable" title="wikilink">recursively enumerable</a>) bases: on the one hand, the set of <em>all</em> admissible rule is a recursive basis if admissibility is decidable. On the other hand, the set of admissible rules is always co-r.e., and if we further have an r.e. basis, it is also r.e., hence it is decidable. (In other words, we can decide admissibility of <em>A</em>/<em>B</em> by the following <a class="uri" href="algorithm" title="wikilink">algorithm</a>: we start in parallel two <a href="exhaustive_search" title="wikilink">exhaustive searches</a>, one for a substitution σ which unifies <em>A</em> but not <em>B</em>, and one for a derivation of <em>A</em>/<em>B</em> from <em>R</em> and 

<math display="inline" id="Admissible_rule:61">
 <semantics>
  <msub>
   <mo>⊢</mo>
   <mi>L</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <csymbol cd="latexml">proves</csymbol>
    <ci>L</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vdash_{L}
  </annotation>
 </semantics>
</math>

. One of the searches has to eventually come up with an answer.) Apart from decidability, explicit bases of admissible rules are useful for some applications, e.g. in <a href="proof_complexity" title="wikilink">proof complexity</a>.<a class="footnoteRef" href="#fn23" id="fnref23"><sup>23</sup></a></p>

<p>For a given logic, we can ask whether it has a recursive or <a href="finite_set" title="wikilink">finite</a> basis of admissible rules, and to provide an explicit basis. If a logic has no finite basis, it can nevertheless has an <strong>independent basis</strong>: a basis <em>R</em> such that no proper subset of <em>R</em> is a basis.</p>

<p>In general, very little can be said about existence of bases with desirable properties. For example, while <a href="tabular_logic" title="wikilink">tabular logics</a> are generally well-behaved, and always finitely axiomatizable, there exist tabular modal logics without a finite or independent basis of rules.<a class="footnoteRef" href="#fn24" id="fnref24"><sup>24</sup></a> Finite bases are relatively rare: even the basic transitive logics <em>IPC</em>, <em>K</em>4, <em>S</em>4, <em>GL</em>, <em>Grz</em> do not have a finite basis of admissible rules,<a class="footnoteRef" href="#fn25" id="fnref25"><sup>25</sup></a> though they have independent bases.<a class="footnoteRef" href="#fn26" id="fnref26"><sup>26</sup></a></p>
<h3 id="examples-of-bases">Examples of bases</h3>
<ul>
<li>The empty set is a basis of <em>L</em>-admissible rules if and only if <em>L</em> is structurally complete.</li>
<li>Every extension of the modal logic <em>S</em>4.3 (including, notably, <em>S</em>5) has a finite basis consisting of the single rule<a class="footnoteRef" href="#fn27" id="fnref27"><sup>27</sup></a></li>
</ul>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Admissible_rule:62">
 <semantics>
  <mrow>
   <mfrac>
    <mrow>
     <mrow>
      <mi mathvariant="normal">◇</mi>
      <mi>p</mi>
     </mrow>
     <mo>∧</mo>
     <mrow>
      <mi mathvariant="normal">◇</mi>
      <mi mathvariant="normal">¬</mi>
      <mi>p</mi>
     </mrow>
    </mrow>
    <mo>⊥</mo>
   </mfrac>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <and></and>
     <apply>
      <times></times>
      <ci>normal-◇</ci>
      <ci>p</ci>
     </apply>
     <apply>
      <times></times>
      <ci>normal-◇</ci>
      <not></not>
      <ci>p</ci>
     </apply>
    </apply>
    <csymbol cd="latexml">bottom</csymbol>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{\Diamond p\land\Diamond\neg p}{\bot}.
  </annotation>
 </semantics>
</math>



</dd>
</dl>
</dd>
</dl>
<ul>
<li><a href="Albert_Visser" title="wikilink">Visser</a>'s rules</li>
</ul>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Admissible_rule:63">
 <semantics>
  <mrow>
   <mrow>
    <mfrac>
     <mrow>
      <mrow>
       <mo maxsize="160%" minsize="160%">(</mo>
       <mstyle displaystyle="true">
        <munderover>
         <mo largeop="true" mathsize="160%" movablelimits="false" stretchy="false" symmetric="true">⋀</mo>
         <mrow>
          <mi>i</mi>
          <mo>=</mo>
          <mn>1</mn>
         </mrow>
         <mi>n</mi>
        </munderover>
       </mstyle>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>p</mi>
         <mi>i</mi>
        </msub>
        <mo>→</mo>
        <msub>
         <mi>q</mi>
         <mi>i</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
       <mo>→</mo>
       <msub>
        <mi>p</mi>
        <mrow>
         <mi>n</mi>
         <mo>+</mo>
         <mn>1</mn>
        </mrow>
       </msub>
       <mo>∨</mo>
       <msub>
        <mi>p</mi>
        <mrow>
         <mi>n</mi>
         <mo>+</mo>
         <mn>2</mn>
        </mrow>
       </msub>
       <mo maxsize="160%" minsize="160%">)</mo>
      </mrow>
      <mo>∨</mo>
      <mi>r</mi>
     </mrow>
     <mrow>
      <mstyle displaystyle="true">
       <munderover>
        <mo largeop="true" mathsize="160%" movablelimits="false" stretchy="false" symmetric="true">⋁</mo>
        <mrow>
         <mi>j</mi>
         <mo>=</mo>
         <mn>1</mn>
        </mrow>
        <mrow>
         <mi>n</mi>
         <mo>+</mo>
         <mn>2</mn>
        </mrow>
       </munderover>
      </mstyle>
      <mrow>
       <mo maxsize="160%" minsize="160%">(</mo>
       <mstyle displaystyle="true">
        <munderover>
         <mo largeop="true" mathsize="160%" movablelimits="false" stretchy="false" symmetric="true">⋀</mo>
         <mrow>
          <mi>i</mi>
          <mo>=</mo>
          <mn>1</mn>
         </mrow>
         <mi>n</mi>
        </munderover>
       </mstyle>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>p</mi>
         <mi>i</mi>
        </msub>
        <mo>→</mo>
        <msub>
         <mi>q</mi>
         <mi>i</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
       <mo>→</mo>
       <msub>
        <mi>p</mi>
        <mi>j</mi>
       </msub>
       <mo maxsize="160%" minsize="160%">)</mo>
      </mrow>
      <mo>∨</mo>
      <mi>r</mi>
     </mrow>
    </mfrac>
    <mo rspace="22.5pt">,</mo>
    <mi>n</mi>
   </mrow>
   <mo>≥</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <list>
     <apply>
      <divide></divide>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <and></and>
          <apply>
           <eq></eq>
           <ci>i</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
         <ci>n</ci>
        </apply>
        <cerror>
         <csymbol cd="ambiguous">fragments</csymbol>
         <ci>normal-(</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>p</ci>
          <ci>i</ci>
         </apply>
         <ci>normal-→</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>q</ci>
          <ci>i</ci>
         </apply>
         <ci>normal-)</ci>
        </cerror>
        <ci>normal-→</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>p</ci>
         <apply>
          <plus></plus>
          <ci>n</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <or></or>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>p</ci>
         <apply>
          <plus></plus>
          <ci>n</ci>
          <cn type="integer">2</cn>
         </apply>
        </apply>
        <ci>normal-)</ci>
       </cerror>
       <or></or>
       <csymbol cd="unknown">r</csymbol>
      </cerror>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <or></or>
         <apply>
          <eq></eq>
          <ci>j</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <apply>
         <plus></plus>
         <ci>n</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <and></and>
          <apply>
           <eq></eq>
           <ci>i</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
         <ci>n</ci>
        </apply>
        <cerror>
         <csymbol cd="ambiguous">fragments</csymbol>
         <ci>normal-(</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>p</ci>
          <ci>i</ci>
         </apply>
         <ci>normal-→</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>q</ci>
          <ci>i</ci>
         </apply>
         <ci>normal-)</ci>
        </cerror>
        <ci>normal-→</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>p</ci>
         <ci>j</ci>
        </apply>
        <ci>normal-)</ci>
       </cerror>
       <or></or>
       <csymbol cd="unknown">r</csymbol>
      </cerror>
     </apply>
     <ci>n</ci>
    </list>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{\displaystyle\Bigl(\bigwedge_{i=1}^{n}(p_{i}\to q_{i})\to p_{n+1}\lor p_%
{n+2}\Bigr)\lor r}{\displaystyle\bigvee_{j=1}^{n+2}\Bigl(\bigwedge_{i=1}^{n}(p%
_{i}\to q_{i})\to p_{j}\Bigr)\lor r},\qquad n\geq 1
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
<dd>are a basis of admissible rules in <em>IPC</em> or <em>KC</em>.<a class="footnoteRef" href="#fn28" id="fnref28"><sup>28</sup></a>
</dd>
</dl>
<ul>
<li>The rules</li>
</ul>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Admissible_rule:64">
 <semantics>
  <mrow>
   <mrow>
    <mfrac>
     <mrow>
      <mi mathvariant="normal">□</mi>
      <mrow>
       <mo maxsize="160%" minsize="160%">(</mo>
       <mi mathvariant="normal">□</mi>
       <mi>q</mi>
       <mo>→</mo>
       <mstyle displaystyle="true">
        <munderover>
         <mo largeop="true" mathsize="160%" movablelimits="false" stretchy="false" symmetric="true">⋁</mo>
         <mrow>
          <mi>i</mi>
          <mo>=</mo>
          <mn>1</mn>
         </mrow>
         <mi>n</mi>
        </munderover>
       </mstyle>
       <mi mathvariant="normal">□</mi>
       <msub>
        <mi>p</mi>
        <mi>i</mi>
       </msub>
       <mo maxsize="160%" minsize="160%">)</mo>
      </mrow>
      <mo>∨</mo>
      <mi mathvariant="normal">□</mi>
      <mi>r</mi>
     </mrow>
     <mrow>
      <mstyle displaystyle="true">
       <munderover>
        <mo largeop="true" mathsize="160%" movablelimits="false" stretchy="false" symmetric="true">⋁</mo>
        <mrow>
         <mi>i</mi>
         <mo>=</mo>
         <mn>1</mn>
        </mrow>
        <mi>n</mi>
       </munderover>
      </mstyle>
      <mi mathvariant="normal">□</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>q</mi>
       <mo>∧</mo>
       <mi mathvariant="normal">□</mi>
       <mi>q</mi>
       <mo>→</mo>
       <msub>
        <mi>p</mi>
        <mi>i</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>∨</mo>
      <mi>r</mi>
     </mrow>
    </mfrac>
    <mo rspace="22.5pt">,</mo>
    <mi>n</mi>
   </mrow>
   <mo>≥</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <list>
     <apply>
      <divide></divide>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <csymbol cd="unknown">□</csymbol>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <csymbol cd="unknown">□</csymbol>
        <csymbol cd="unknown">q</csymbol>
        <ci>normal-→</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <or></or>
          <apply>
           <eq></eq>
           <ci>i</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
         <ci>n</ci>
        </apply>
        <csymbol cd="unknown">□</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>p</ci>
         <ci>i</ci>
        </apply>
        <ci>normal-)</ci>
       </cerror>
       <or></or>
       <csymbol cd="unknown">□</csymbol>
       <csymbol cd="unknown">r</csymbol>
      </cerror>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <or></or>
         <apply>
          <eq></eq>
          <ci>i</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>n</ci>
       </apply>
       <csymbol cd="unknown">□</csymbol>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <csymbol cd="unknown">q</csymbol>
        <and></and>
        <csymbol cd="unknown">□</csymbol>
        <csymbol cd="unknown">q</csymbol>
        <ci>normal-→</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>p</ci>
         <ci>i</ci>
        </apply>
        <ci>normal-)</ci>
       </cerror>
       <or></or>
       <csymbol cd="unknown">r</csymbol>
      </cerror>
     </apply>
     <ci>n</ci>
    </list>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{\displaystyle\Box\Bigl(\Box q\to\bigvee_{i=1}^{n}\Box p_{i}\Bigr)\lor%
\Box r}{\displaystyle\bigvee_{i=1}^{n}\Box(q\land\Box q\to p_{i})\lor r},%
\qquad n\geq 0
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
<dd>are a basis of admissible rules of <em>GL</em>.<a class="footnoteRef" href="#fn29" id="fnref29"><sup>29</sup></a> (Note that the empty disjunction is defined as 

<math display="inline" id="Admissible_rule:65">
 <semantics>
  <mo>⊥</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">bottom</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bot
  </annotation>
 </semantics>
</math>

.)
</dd>
</dl>
<ul>
<li>The rules</li>
</ul>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Admissible_rule:66">
 <semantics>
  <mrow>
   <mrow>
    <mfrac>
     <mrow>
      <mi mathvariant="normal">□</mi>
      <mrow>
       <mo maxsize="160%" minsize="160%">(</mo>
       <mi mathvariant="normal">□</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>q</mi>
        <mo>→</mo>
        <mi mathvariant="normal">□</mi>
        <mi>q</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <mo>→</mo>
       <mstyle displaystyle="true">
        <munderover>
         <mo largeop="true" mathsize="160%" movablelimits="false" stretchy="false" symmetric="true">⋁</mo>
         <mrow>
          <mi>i</mi>
          <mo>=</mo>
          <mn>1</mn>
         </mrow>
         <mi>n</mi>
        </munderover>
       </mstyle>
       <mi mathvariant="normal">□</mi>
       <msub>
        <mi>p</mi>
        <mi>i</mi>
       </msub>
       <mo maxsize="160%" minsize="160%">)</mo>
      </mrow>
      <mo>∨</mo>
      <mi mathvariant="normal">□</mi>
      <mi>r</mi>
     </mrow>
     <mrow>
      <mstyle displaystyle="true">
       <munderover>
        <mo largeop="true" mathsize="160%" movablelimits="false" stretchy="false" symmetric="true">⋁</mo>
        <mrow>
         <mi>i</mi>
         <mo>=</mo>
         <mn>1</mn>
        </mrow>
        <mi>n</mi>
       </munderover>
      </mstyle>
      <mi mathvariant="normal">□</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi mathvariant="normal">□</mi>
       <mi>q</mi>
       <mo>→</mo>
       <msub>
        <mi>p</mi>
        <mi>i</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>∨</mo>
      <mi>r</mi>
     </mrow>
    </mfrac>
    <mo rspace="22.5pt">,</mo>
    <mi>n</mi>
   </mrow>
   <mo>≥</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <list>
     <apply>
      <divide></divide>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <csymbol cd="unknown">□</csymbol>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <csymbol cd="unknown">□</csymbol>
        <cerror>
         <csymbol cd="ambiguous">fragments</csymbol>
         <ci>normal-(</ci>
         <csymbol cd="unknown">q</csymbol>
         <ci>normal-→</ci>
         <csymbol cd="unknown">□</csymbol>
         <csymbol cd="unknown">q</csymbol>
         <ci>normal-)</ci>
        </cerror>
        <ci>normal-→</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <or></or>
          <apply>
           <eq></eq>
           <ci>i</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
         <ci>n</ci>
        </apply>
        <csymbol cd="unknown">□</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>p</ci>
         <ci>i</ci>
        </apply>
        <ci>normal-)</ci>
       </cerror>
       <or></or>
       <csymbol cd="unknown">□</csymbol>
       <csymbol cd="unknown">r</csymbol>
      </cerror>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <or></or>
         <apply>
          <eq></eq>
          <ci>i</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>n</ci>
       </apply>
       <csymbol cd="unknown">□</csymbol>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <csymbol cd="unknown">□</csymbol>
        <csymbol cd="unknown">q</csymbol>
        <ci>normal-→</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>p</ci>
         <ci>i</ci>
        </apply>
        <ci>normal-)</ci>
       </cerror>
       <or></or>
       <csymbol cd="unknown">r</csymbol>
      </cerror>
     </apply>
     <ci>n</ci>
    </list>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{\displaystyle\Box\Bigl(\Box(q\to\Box q)\to\bigvee_{i=1}^{n}\Box p_{i}%
\Bigr)\lor\Box r}{\displaystyle\bigvee_{i=1}^{n}\Box(\Box q\to p_{i})\lor r},%
\qquad n\geq 0
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
<dd>are a basis of admissible rules of <em>S</em>4 or <em>Grz</em>.<a class="footnoteRef" href="#fn30" id="fnref30"><sup>30</sup></a>
</dd>
</dl>
<h2 id="semantics-for-admissible-rules">Semantics for admissible rules</h2>

<p>A rule Γ/<em>B</em> is <strong>valid</strong> in a modal or intuitionistic <a href="Kripke_frame" title="wikilink">Kripke frame</a> 

<math display="inline" id="Admissible_rule:67">
 <semantics>
  <mrow>
   <mi>F</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mi>W</mi>
    <mo>,</mo>
    <mi>R</mi>
    <mo stretchy="false">⟩</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>F</ci>
    <list>
     <ci>W</ci>
     <ci>R</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F=\langle W,R\rangle
  </annotation>
 </semantics>
</math>


, if the following is true for every valuation 

<math display="inline" id="Admissible_rule:68">
 <semantics>
  <mo>⊩</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">forces</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Vdash
  </annotation>
 </semantics>
</math>

 in <em>F</em>:</p>
<dl>
<dd>if 

<math display="inline" id="Admissible_rule:69">
 <semantics>
  <mrow>
   <mo>∀</mo>
   <mi>x</mi>
   <mo>∈</mo>
   <mpadded width="+1.7pt">
    <mi>W</mi>
   </mpadded>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>⊩</mo>
    <mi>A</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <in></in>
    <csymbol cd="unknown">W</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="latexml">forces</csymbol>
     <csymbol cd="unknown">A</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall x\in W\,(x\Vdash A)
  </annotation>
 </semantics>
</math>

 for all 

<math display="inline" id="Admissible_rule:70">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>∈</mo>
   <mi mathvariant="normal">Γ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>A</ci>
    <ci>normal-Γ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\in\Gamma
  </annotation>
 </semantics>
</math>

, then 

<math display="inline" id="Admissible_rule:71">
 <semantics>
  <mrow>
   <mo>∀</mo>
   <mi>x</mi>
   <mo>∈</mo>
   <mpadded width="+1.7pt">
    <mi>W</mi>
   </mpadded>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>⊩</mo>
    <mi>B</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <in></in>
    <csymbol cd="unknown">W</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="latexml">forces</csymbol>
     <csymbol cd="unknown">B</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall x\in W\,(x\Vdash B)
  </annotation>
 </semantics>
</math>

.
</dd>
</dl>

<p>(The definition readily generalizes to <a href="general_frame" title="wikilink">general frames</a>, if needed.)</p>

<p>Let <em>X</em> be a subset of <em>W</em>, and <em>t</em> a point in <em>W</em>. We say that <em>t</em> is</p>
<ul>
<li>a <strong>reflexive tight predecessor</strong> of <em>X</em>, if for every <em>y</em> in <em>W</em>: <em>t R y</em> if and only if <em>t</em> = <em>y</em> or <em>x</em> = <em>y</em> or <em>x R y</em> for some <em>x</em> in <em>X</em>,</li>
<li>an <strong>irreflexive tight predecessor</strong> of <em>X</em>, if for every <em>y</em> in <em>W</em>: <em>t R y</em> if and only if <em>x</em> = <em>y</em> or <em>x R y</em> for some <em>x</em> in <em>X</em>.</li>
</ul>

<p>We say that a frame <em>F</em> has reflexive (irreflexive) tight predecessors, if for every <em>finite</em> subset <em>X</em> of <em>W</em>, there exists a reflexive (irreflexive) tight predecessor of <em>X</em> in <em>W</em>.</p>

<p>We have:<a class="footnoteRef" href="#fn31" id="fnref31"><sup>31</sup></a></p>
<ul>
<li>a rule is admissible in <em>IPC</em> if and only if it is valid in all intuitionistic frames which have reflexive tight predecessors,</li>
<li>a rule is admissible in <em>K</em>4 if and only if it is valid in all <a href="transitive_relation" title="wikilink">transitive</a> frames which have reflexive and irreflexive tight predecessors,</li>
<li>a rule is admissible in <em>S</em>4 if and only if it is valid in all transitive <a href="reflexive_relation" title="wikilink">reflexive</a> frames which have reflexive tight predecessors,</li>
<li>a rule is admissible in <em>GL</em> if and only if it is valid in all transitive converse <a href="well-founded_relation" title="wikilink">well-founded</a> frames which have irreflexive tight predecessors.</li>
</ul>

<p>Note that apart from a few trivial cases, frames with tight predecessors must be infinite, hence admissible rules in basic transitive logics do not enjoy the finite model property.</p>
<h2 id="structural-completeness">Structural completeness</h2>

<p>While a general classification of structurally complete logics is not an easy task, we have a good understanding of some special cases.</p>

<p>Intuitionistic logic itself is not structurally complete, but its <em>fragments</em> may behave differently. Namely, any disjunction-free rule or implication-free rule admissible in a superintuitionistic logic is derivable.<a class="footnoteRef" href="#fn32" id="fnref32"><sup>32</sup></a> On the other hand, the Mints rule</p>

<p>

<math display="block" id="Admissible_rule:72">
 <semantics>
  <mfrac>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>p</mi>
     <mo>→</mo>
     <mi>q</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>→</mo>
    <mi>p</mi>
    <mo>∨</mo>
    <mi>r</mi>
   </mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>p</mi>
      <mo>→</mo>
      <mi>q</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>→</mo>
     <mi>p</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∨</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>p</mi>
      <mo>→</mo>
      <mi>q</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>→</mo>
     <mi>r</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">p</csymbol>
      <ci>normal-→</ci>
      <csymbol cd="unknown">q</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-→</ci>
     <csymbol cd="unknown">p</csymbol>
     <or></or>
     <csymbol cd="unknown">r</csymbol>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">p</csymbol>
       <ci>normal-→</ci>
       <csymbol cd="unknown">q</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-→</ci>
      <csymbol cd="unknown">p</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <or></or>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">p</csymbol>
       <ci>normal-→</ci>
       <csymbol cd="unknown">q</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-→</ci>
      <csymbol cd="unknown">r</csymbol>
      <ci>normal-)</ci>
     </cerror>
    </cerror>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{(p\to q)\to p\lor r}{((p\to q)\to p)\lor((p\to q)\to r)}
  </annotation>
 </semantics>
</math>

 is admissible in intuitionistic logic but not derivable, and contains only implications and disjunctions.</p>

<p>We know the <em>maximal</em> structurally incomplete transitive logics. A logic is called <strong>hereditarily structurally complete</strong>, if every its extension is structurally complete. For example, classical logic, as well as the logics <em>LC</em> and <em>Grz</em>.3 mentioned above, are hereditarily structurally complete. A complete description of hereditarily structurally complete superintuitionistic and transitive modal logics was given by Citkin and Rybakov. Namely, a superintuitionistic logic is hereditarily structurally complete if and only if it is not valid in any of the five Kripke frames<a class="footnoteRef" href="#fn33" id="fnref33"><sup>33</sup></a></p>
<dl>
<dd><dl>
<dd>
</dd>
</dl>
</dd>
</dl>

<p>Similarly, an extension of <em>K</em>4 is hereditarily structurally complete if and only if it is not valid in any of certain twenty Kripke frames (including the five intuitionistic frames above).<a class="footnoteRef" href="#fn34" id="fnref34"><sup>34</sup></a></p>

<p>There exist structurally complete logics that are not hereditarily structurally complete: for example, <a href="intermediate_logic" title="wikilink">Medvedev's logic</a> is structurally complete,<a class="footnoteRef" href="#fn35" id="fnref35"><sup>35</sup></a> but it is included in the structurally incomplete logic <em>KC</em>.</p>
<h2 id="variants">Variants</h2>

<p>A <strong>rule with parameters</strong> is a rule of the form</p>

<p>

<math display="block" id="Admissible_rule:73">
 <semantics>
  <mrow>
   <mfrac>
    <mrow>
     <mi>A</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>p</mi>
       <mn>1</mn>
      </msub>
      <mo>,</mo>
      <mi mathvariant="normal">…</mi>
      <mo>,</mo>
      <msub>
       <mi>p</mi>
       <mi>n</mi>
      </msub>
      <mo>,</mo>
      <msub>
       <mi>s</mi>
       <mn>1</mn>
      </msub>
      <mo>,</mo>
      <mi mathvariant="normal">…</mi>
      <mo>,</mo>
      <msub>
       <mi>s</mi>
       <mi>k</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mrow>
     <mi>B</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>p</mi>
       <mn>1</mn>
      </msub>
      <mo>,</mo>
      <mi mathvariant="normal">…</mi>
      <mo>,</mo>
      <msub>
       <mi>p</mi>
       <mi>n</mi>
      </msub>
      <mo>,</mo>
      <msub>
       <mi>s</mi>
       <mn>1</mn>
      </msub>
      <mo>,</mo>
      <mi mathvariant="normal">…</mi>
      <mo>,</mo>
      <msub>
       <mi>s</mi>
       <mi>k</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mfrac>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <times></times>
     <ci>A</ci>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>s</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>s</ci>
       <ci>k</ci>
      </apply>
     </vector>
    </apply>
    <apply>
     <times></times>
     <ci>B</ci>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>s</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>s</ci>
       <ci>k</ci>
      </apply>
     </vector>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{A(p_{1},\dots,p_{n},s_{1},\dots,s_{k})}{B(p_{1},\dots,p_{n},s_{1},\dots,%
s_{k})},
  </annotation>
 </semantics>
</math>

 whose variables are divided into the "regular" variables <em>p</em><sub><em>i</em></sub>, and the parameters <em>s</em><sub><em>i</em></sub>. The rule is <em>L</em>-admissible if every <em>L</em>-unifier σ of <em>A</em> such that σ<em>s</em><sub><em>i</em></sub> = <em>s</em><sub><em>i</em></sub> for each <em>i</em> is also a unifier of <em>B</em>. The basic decidability results for admissible rules also carry to rules with parameters.<a class="footnoteRef" href="#fn36" id="fnref36"><sup>36</sup></a></p>

<p>A <strong>multiple-conclusion rule</strong> is a pair (Γ,Δ) of two finite sets of formulas, written as</p>

<p>

<math display="block" id="Admissible_rule:74">
 <semantics>
  <mrow>
   <mrow>
    <mfrac>
     <mrow>
      <msub>
       <mi>A</mi>
       <mn>1</mn>
      </msub>
      <mo>,</mo>
      <mi mathvariant="normal">…</mi>
      <mo>,</mo>
      <msub>
       <mi>A</mi>
       <mi>n</mi>
      </msub>
     </mrow>
     <mrow>
      <msub>
       <mi>B</mi>
       <mn>1</mn>
      </msub>
      <mo>,</mo>
      <mi mathvariant="normal">…</mi>
      <mo>,</mo>
      <msub>
       <mi>B</mi>
       <mi>m</mi>
      </msub>
     </mrow>
    </mfrac>
    <mtext>or</mtext>
    <msub>
     <mi>A</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mrow>
     <msub>
      <mi>A</mi>
      <mi>n</mi>
     </msub>
     <mo>/</mo>
     <msub>
      <mi>B</mi>
      <mn>1</mn>
     </msub>
    </mrow>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>B</mi>
     <mi>m</mi>
    </msub>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <divide></divide>
     <list>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>A</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>A</ci>
       <ci>n</ci>
      </apply>
     </list>
     <list>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>B</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>B</ci>
       <ci>m</ci>
      </apply>
     </list>
    </apply>
    <mtext>or</mtext>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>A</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <divide></divide>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>B</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>B</ci>
     <ci>m</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{A_{1},\dots,A_{n}}{B_{1},\dots,B_{m}}\qquad\text{or}\qquad A_{1},\dots,A%
_{n}/B_{1},\dots,B_{m}.
  </annotation>
 </semantics>
</math>

 Such a rule is admissible if every unifier of Γ is also a unifier of some formula from Δ.<a class="footnoteRef" href="#fn37" id="fnref37"><sup>37</sup></a> For example, a logic <em>L</em> is <a class="uri" href="consistent" title="wikilink">consistent</a> iff it admits the rule</p>

<p>

<math display="block" id="Admissible_rule:75">
 <semantics>
  <mrow>
   <mfrac>
    <mo lspace="5.3pt" rspace="5.3pt">⊥</mo>
    <mi></mi>
   </mfrac>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <csymbol cd="latexml">bottom</csymbol>
    <csymbol cd="latexml">absent</csymbol>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{\;\bot\;}{},
  </annotation>
 </semantics>
</math>

 and a superintuitionistic logic has the <a href="disjunction_property" title="wikilink">disjunction property</a> iff it admits the rule</p>

<p>

<math display="block" id="Admissible_rule:76">
 <semantics>
  <mrow>
   <mfrac>
    <mrow>
     <mi>p</mi>
     <mo>∨</mo>
     <mi>q</mi>
    </mrow>
    <mrow>
     <mi>p</mi>
     <mo>,</mo>
     <mi>q</mi>
    </mrow>
   </mfrac>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <or></or>
     <ci>p</ci>
     <ci>q</ci>
    </apply>
    <list>
     <ci>p</ci>
     <ci>q</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{p\lor q}{p,q}.
  </annotation>
 </semantics>
</math>

 Again, basic results on admissible rules generalize smoothly to multiple-conclusion rules.<a class="footnoteRef" href="#fn38" id="fnref38"><sup>38</sup></a> In logics with a variant of the disjunction property, the multiple-conclusion rules have the same expressive power as single-conclusion rules: for example, in <em>S</em>4 the rule above is equivalent to</p>

<p>

<math display="block" id="Admissible_rule:77">
 <semantics>
  <mrow>
   <mfrac>
    <mrow>
     <msub>
      <mi>A</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <msub>
      <mi>A</mi>
      <mi>n</mi>
     </msub>
    </mrow>
    <mrow>
     <mrow>
      <mi mathvariant="normal">□</mi>
      <msub>
       <mi>B</mi>
       <mn>1</mn>
      </msub>
     </mrow>
     <mo>∨</mo>
     <mi mathvariant="normal">…</mi>
     <mo>∨</mo>
     <mrow>
      <mi mathvariant="normal">□</mi>
      <msub>
       <mi>B</mi>
       <mi>m</mi>
      </msub>
     </mrow>
    </mrow>
   </mfrac>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <list>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <ci>n</ci>
     </apply>
    </list>
    <apply>
     <or></or>
     <apply>
      <times></times>
      <ci>normal-□</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>B</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <times></times>
      <ci>normal-□</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>B</ci>
       <ci>m</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{A_{1},\dots,A_{n}}{\Box B_{1}\lor\dots\lor\Box B_{m}}.
  </annotation>
 </semantics>
</math>

 Nevertheless, multiple-conclusion rules can often be employed to simplify arguments.</p>

<p>In <a href="proof_theory" title="wikilink">proof theory</a>, admissibility is often considered in the context of <a href="sequent_calculus" title="wikilink">sequent calculi</a>, where the basic objects are sequents rather than formulas. For example, one can rephrase the <a href="cut-elimination_theorem" title="wikilink">cut-elimination theorem</a> as saying that the cut-free sequent calculus admits the <a href="cut_rule" title="wikilink">cut rule</a></p>

<p>

<math display="block" id="Admissible_rule:78">
 <semantics>
  <mrow>
   <mfrac>
    <mrow>
     <mi mathvariant="normal">Γ</mi>
     <mo>⊢</mo>
     <mrow>
      <mi>A</mi>
      <mo>,</mo>
      <mi mathvariant="normal">Δ</mi>
      <mi mathvariant="normal">Π</mi>
      <mo>,</mo>
      <mi>A</mi>
     </mrow>
     <mo>⊢</mo>
     <mi mathvariant="normal">Λ</mi>
    </mrow>
    <mrow>
     <mrow>
      <mi mathvariant="normal">Γ</mi>
      <mo>,</mo>
      <mi mathvariant="normal">Π</mi>
     </mrow>
     <mo>⊢</mo>
     <mrow>
      <mi mathvariant="normal">Δ</mi>
      <mo>,</mo>
      <mi mathvariant="normal">Λ</mi>
     </mrow>
    </mrow>
   </mfrac>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <and></and>
     <apply>
      <csymbol cd="latexml">proves</csymbol>
      <ci>normal-Γ</ci>
      <list>
       <ci>A</ci>
       <ci>normal-Δ</ci>
       <ci>normal-Π</ci>
       <ci>A</ci>
      </list>
     </apply>
     <apply>
      <csymbol cd="latexml">proves</csymbol>
      <share href="#.cmml">
      </share>
      <ci>normal-Λ</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">proves</csymbol>
     <list>
      <ci>normal-Γ</ci>
      <ci>normal-Π</ci>
     </list>
     <list>
      <ci>normal-Δ</ci>
      <ci>normal-Λ</ci>
     </list>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{\Gamma\vdash A,\Delta\qquad\Pi,A\vdash\Lambda}{\Gamma,\Pi\vdash\Delta,%
\Lambda}.
  </annotation>
 </semantics>
</math>

 (By abuse of language, it is also sometimes said that the (full) sequent calculus admits cut, meaning its cut-free version does.) However, admissibility in sequent calculi is usually only a notational variant for admissibility in the corresponding logic: any complete calculus for (say) intuitionistic logic admits a sequent rule if and only if <em>IPC</em> admits the formula rule which we obtain by translating each sequent 

<math display="inline" id="Admissible_rule:79">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Γ</mi>
   <mo>⊢</mo>
   <mi mathvariant="normal">Δ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">proves</csymbol>
    <ci>normal-Γ</ci>
    <ci>normal-Δ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Gamma\vdash\Delta
  </annotation>
 </semantics>
</math>

 to its characteristic formula 

<math display="inline" id="Admissible_rule:80">
 <semantics>
  <mrow>
   <mrow>
    <mo largeop="true" mathsize="160%" stretchy="false" symmetric="true">⋀</mo>
    <mi mathvariant="normal">Γ</mi>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mo largeop="true" mathsize="160%" stretchy="false" symmetric="true">⋁</mo>
    <mi mathvariant="normal">Δ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <and></and>
     <ci>normal-Γ</ci>
    </apply>
    <apply>
     <or></or>
     <ci>normal-Δ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bigwedge\Gamma\to\bigvee\Delta
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<ul>
<li>W. Blok, D. Pigozzi, <em>Algebraizable logics</em>, Memoirs of the American Mathematical Society 77 (1989), no. 396, 1989.</li>
<li>A. Chagrov and M. Zakharyaschev, <em>Modal Logic</em>, Oxford Logic Guides vol. 35, Oxford University Press, 1997. ISBN 0-19-853779-4</li>
<li>P. Cintula and G. Metcalfe, <em>Structural completeness in fuzzy logics</em>, Notre Dame Journal of Formal Logic 50 (2009), no. 2, pp. 153–182. </li>
<li>A. I. Citkin, <em>On structurally complete superintuitionistic logics</em>, Soviet Mathematics Doklady, vol. 19 (1978), pp. 816–819.</li>
<li>S. Ghilardi, <em>Unification in intuitionistic logic</em>, Journal of Symbolic Logic 64 (1999), no. 2, pp. 859–880. <a href="http://projecteuclid.org/euclid.jsl/1183745815">Project Euclid</a> <a href="http://www.jstor.org/stable/view/2586506">JSTOR</a></li>
<li>S. Ghilardi, <em>Best solving modal equations</em>, Annals of Pure and Applied Logic 102 (2000), no. 3, pp. 183–198. </li>
<li>R. Iemhoff, <em>On the admissible rules of intuitionistic propositional logic</em>, Journal of Symbolic Logic 66 (2001), no. 1, pp. 281–294. <a href="http://projecteuclid.org/euclid.jsl/1183746371">Project Euclid</a> <a href="http://www.jstor.org/stable/view/2694922">JSTOR</a></li>
<li>R. Iemhoff, <em>Intermediate logics and Visser's rules</em>, Notre Dame Journal of Formal Logic 46 (2005), no. 1, pp. 65–81. </li>
<li>R. Iemhoff, <em>On the rules of intermediate logics</em>, Archive for Mathematical Logic, 45 (2006), no. 5, pp. 581–599. </li>
<li>E. Jeřábek, <em>Admissible rules of modal logics</em>, Journal of Logic and Computation 15 (2005), no. 4, pp. 411–431. </li>
<li>E. Jeřábek, <em>Complexity of admissible rules</em>, Archive for Mathematical Logic 46 (2007), no. 2, pp. 73–92. </li>
<li>E. Jeřábek, <em>Independent bases of admissible rules</em>, Logic Journal of the IGPL 16 (2008), no. 3, pp. 249–267. </li>
<li>M. Kracht, <em>Modal Consequence Relations</em>, in: Handbook of Modal Logic (P. Blackburn, J. van Benthem, and F. Wolter, eds.), Studies of Logic and Practical Reasoning vol. 3, Elsevier, 2007, pp. 492–545. ISBN 978-0-444-51690-9</li>
<li>P. Lorenzen, <em>Einführung in die operative Logik und Mathematik</em>, Grundlehren der mathematischen Wissenschaften vol. 78, Springer–Verlag, 1955.</li>
<li>G. Mints and A. Kojevnikov, <em>Intuitionistic Frege systems are polynomially equivalent</em>, Zapiski Nauchnyh Seminarov POMI 316 (2004), pp. 129–146. <a href="http://www.emis.de/journals/ZPOMI/v316/p129.ps.gz">gzipped PS</a></li>
<li>T. Prucnal, <em>Structural completeness of Medvedev's propositional calculus</em>, Reports on Mathematical Logic 6 (1976), pp. 103–105.</li>
<li>T. Prucnal, <em>On two problems of Harvey Friedman</em>, Studia Logica 38 (1979), no. 3, pp. 247–262. </li>
<li>P. Rozière, <em>Règles admissibles en calcul propositionnel intuitionniste</em>, Ph.D. thesis, Université de Paris VII, 1992. <a href="http://www.pps.jussieu.fr/~roziere/admiss/these.pdf">PDF</a></li>
<li>V. V. Rybakov, <em>Admissibility of Logical Inference Rules</em>, Studies in Logic and the Foundations of Mathematics vol. 136, Elsevier, 1997. ISBN 0-444-89505-1</li>
<li>F. Wolter, M. Zakharyaschev, <em>Undecidability of the unification and admissibility problems for modal and description logics</em>, ACM Transactions on Computational Logic 9 (2008), no. 4, article no. 25.  <a href="http://tocl.acm.org/accepted/318wolter.pdf">PDF</a></li>
</ul>

<p>"</p>

<p><a href="Category:Rules_of_inference" title="wikilink">Category:Rules of inference</a> <a href="Category:Modal_logic" title="wikilink">Category:Modal logic</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Blok &amp; Pigozzi (1989), Kracht (2007)<a href="#fnref1">↩</a></li>
<li id="fn2">Rybakov (1997), Def. 1.1.3<a href="#fnref2">↩</a></li>
<li id="fn3">Rybakov (1997), Def. 1.7.2<a href="#fnref3">↩</a></li>
<li id="fn4"><a href="http://www.illc.uva.nl/D65/artemov.pdf">From de Jongh’s theorem to intuitionistic logic of proofs</a><a href="#fnref4">↩</a></li>
<li id="fn5">Rybakov (1997), Def. 1.7.7<a href="#fnref5">↩</a></li>
<li id="fn6">Chagrov &amp; Zakharyaschev (1997), Thm. 1.25<a href="#fnref6">↩</a></li>
<li id="fn7">Prucnal (1979), cf. Iemhoff (2006)<a href="#fnref7">↩</a></li>
<li id="fn8">Rybakov (1997), p. 439<a href="#fnref8">↩</a></li>
<li id="fn9">Rybakov (1997), Thms. 5.4.4, 5.4.8<a href="#fnref9">↩</a></li>
<li id="fn10">Cintula &amp; Metcalfe (2009)<a href="#fnref10">↩</a></li>
<li id="fn11">Wolter &amp; Zakharyaschev (2008)<a href="#fnref11">↩</a></li>
<li id="fn12">Rybakov (1997), §3.9<a href="#fnref12">↩</a></li>
<li id="fn13">Rybakov (1997), Thm. 3.9.3<a href="#fnref13">↩</a></li>
<li id="fn14">Rybakov (1997), Thms. 3.9.6, 3.9.9, 3.9.12; cf. Chagrov &amp; Zakharyaschev (1997), §16.7<a href="#fnref14">↩</a></li>
<li id="fn15">Rybakov (1997), Thm. 3.2.2<a href="#fnref15">↩</a></li>
<li id="fn16">Rybakov (1997), §3.5<a href="#fnref16">↩</a></li>
<li id="fn17">Jeřábek (2007)<a href="#fnref17">↩</a></li>
<li id="fn18">Chagrov &amp; Zakharyaschev (1997), §18.5<a href="#fnref18">↩</a></li>
<li id="fn19">Ghilardi (2000), Thm. 2.2<a href="#fnref19">↩</a></li>
<li id="fn20">Ghilardi (2000), p. 196<a href="#fnref20">↩</a></li>
<li id="fn21">Ghilardi (2000), Thm. 3.6<a href="#fnref21">↩</a></li>
<li id="fn22">Rybakov (1997), Def. 1.4.13<a href="#fnref22">↩</a></li>
<li id="fn23">Mints &amp; Kojevnikov (2004)<a href="#fnref23">↩</a></li>
<li id="fn24">Rybakov (1997), Thm. 4.5.5<a href="#fnref24">↩</a></li>
<li id="fn25">Rybakov (1997), §4.2<a href="#fnref25">↩</a></li>
<li id="fn26">Jeřábek (2008)<a href="#fnref26">↩</a></li>
<li id="fn27">Rybakov (1997), Cor. 4.3.20<a href="#fnref27">↩</a></li>
<li id="fn28">Iemhoff (2001, 2005), Rozière (1992)<a href="#fnref28">↩</a></li>
<li id="fn29">Jeřábek (2005)<a href="#fnref29">↩</a></li>
<li id="fn30">Jeřábek (2005,2008)<a href="#fnref30">↩</a></li>
<li id="fn31">Iemhoff (2001), Jeřábek (2005)<a href="#fnref31">↩</a></li>
<li id="fn32">Rybakov (1997), Thms. 5.5.6, 5.5.9<a href="#fnref32">↩</a></li>
<li id="fn33"></li>
<li id="fn34"></li>
<li id="fn35">Prucnal (1976)<a href="#fnref35">↩</a></li>
<li id="fn36">Rybakov (1997), §6.1<a href="#fnref36">↩</a></li>
<li id="fn37">Jeřábek (2005); cf. Kracht (2007), §7<a href="#fnref37">↩</a></li>
<li id="fn38">Jeřábek (2005, 2007, 2008)<a href="#fnref38">↩</a></li>
</ol>
</section>
</body>
</html>
