<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="817">Miller–Rabin primality test</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Miller–Rabin primality test</h1>
<hr>The '''Miller–Rabin primality tes

<p>t''' or <strong>Rabin–Miller primality test</strong> is a <a href="primality_test" title="wikilink">primality test</a>: an <a class="uri" href="algorithm" title="wikilink">algorithm</a> which determines whether a given number is <a href="prime_number" title="wikilink">prime</a>, similar to the <a href="Fermat_primality_test" title="wikilink">Fermat primality test</a> and the <a href="Solovay–Strassen_primality_test" title="wikilink">Solovay–Strassen primality test</a>. Its original version, due to <a href="Gary_Miller_(professor)" title="wikilink">Gary L. Miller</a>, is <a href="deterministic_algorithm" title="wikilink">deterministic</a>, but the determinism relies on the unproven <a href="Extended_Riemann_hypothesis" title="wikilink">Extended Riemann hypothesis</a>;<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> <a href="Michael_O._Rabin" title="wikilink">Michael O. Rabin</a> modified it to obtain an unconditional <a href="randomized_algorithm" title="wikilink">probabilistic algorithm</a>.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>
<h2 id="concepts">Concepts</h2>

<p>Just like the Fermat and Solovay–Strassen tests, the Miller–Rabin test relies on an equality or set of equalities that hold true for prime values, then checks whether or not they hold for a number that we want to test for primality.</p>

<p>First, a <a href="lemma_(mathematics)" title="wikilink">lemma</a> about square <a href="root_of_unity" title="wikilink">roots of unity</a> in the <a href="finite_field" title="wikilink">finite field</a> <strong>Z</strong>/<em>p</em><strong>Z</strong>, where <em>p</em> is prime and <em>p</em> &gt; 2. Certainly 1 and −1 always yield 1 when squared modulo <em>p</em>; call these <a href="Trivial_(mathematics)" title="wikilink">trivial</a> <a href="square_root" title="wikilink">square roots</a> of 1. There are no <em>nontrivial</em> square roots of 1 modulo <em>p</em> (a special case of the result that, in a field, a <a class="uri" href="polynomial" title="wikilink">polynomial</a> has no more zeroes than its degree). To show this, suppose that <em>x</em> is a square root of 1 modulo <em>p</em>. Then:</p>

<p>
<math display="block" id="Miller–Rabin_primality_test:0">
<semantics>
<mrow>
<msup>
<mi>x</mi>
<mn>2</mn>
</msup>
<mo>≡</mo>
<mrow>
<mn>1</mn>
<mspace width="veryverythickmathspace">
</mspace>
<mrow>
<mo lspace="8.1pt" stretchy="false">(</mo>
<mrow>
<mo>mod</mo>
<mi>p</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<equivalent></equivalent>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>x</ci>
<cn type="integer">2</cn>
</apply>
<apply>
<csymbol cd="latexml">annotated</csymbol>
<cn type="integer">1</cn>
<apply>
<ci>pmod</ci>
<ci>p</ci>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   x^{2}\equiv 1\;\;(\mathop{{\rm mod}}p)
  </annotation>
</semantics>
</math>
</p>

<p>
<math display="block" id="Miller–Rabin_primality_test:1">
<semantics>
<mrow>
<mrow>
<mrow>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>x</mi>
<mo>-</mo>
<mn>1</mn>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>x</mi>
<mo>+</mo>
<mn>1</mn>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>≡</mo>
<mrow>
<mn>0</mn>
<mspace width="veryverythickmathspace">
</mspace>
<mrow>
<mo lspace="8.1pt" stretchy="false">(</mo>
<mrow>
<mo>mod</mo>
<mi>p</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<equivalent></equivalent>
<apply>
<times></times>
<apply>
<minus></minus>
<ci>x</ci>
<cn type="integer">1</cn>
</apply>
<apply>
<plus></plus>
<ci>x</ci>
<cn type="integer">1</cn>
</apply>
</apply>
<apply>
<csymbol cd="latexml">annotated</csymbol>
<cn type="integer">0</cn>
<apply>
<ci>pmod</ci>
<ci>p</ci>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   (x-1)(x+1)\equiv 0\;\;(\mathop{{\rm mod}}p).
  </annotation>
</semantics>
</math>

 In other words, prime <em>p</em> divides the product  By <a href="Euclid's_lemma" title="wikilink">Euclid's lemma</a> it divides one of the factors  or  implying that <em>x</em> is congruent to either 1 or −1 modulo <em>p</em>.</p>

<p>Now, let <em>n</em> be prime with <em>n</em> &gt; 2. It follows that  is even and we can write it as 2<sup><em>s</em></sup>·<em>d</em>, where <em>s</em> and <em>d</em> are positive integers (<em>d</em> is odd). For each <em>a</em> in (<strong>Z</strong>/<em>n</em><strong>Z</strong>)*, either</p>

<p>
<math display="block" id="Miller–Rabin_primality_test:2">
<semantics>
<mrow>
<msup>
<mi>a</mi>
<mi>d</mi>
</msup>
<mo>≡</mo>
<mrow>
<mn>1</mn>
<mspace width="veryverythickmathspace">
</mspace>
<mrow>
<mo lspace="8.1pt" stretchy="false">(</mo>
<mrow>
<mo>mod</mo>
<mi>n</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<equivalent></equivalent>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>a</ci>
<ci>d</ci>
</apply>
<apply>
<csymbol cd="latexml">annotated</csymbol>
<cn type="integer">1</cn>
<apply>
<ci>pmod</ci>
<ci>n</ci>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   a^{d}\equiv 1\;\;(\mathop{{\rm mod}}n)
  </annotation>
</semantics>
</math>

 or</p>

<p>
<math display="block" id="Miller–Rabin_primality_test:3">
<semantics>
<mrow>
<msup>
<mi>a</mi>
<mrow>
<msup>
<mn>2</mn>
<mi>r</mi>
</msup>
<mo>⋅</mo>
<mi>d</mi>
</mrow>
</msup>
<mo>≡</mo>
<mrow>
<mrow>
<mo>-</mo>
<mn>1</mn>
</mrow>
<mspace width="veryverythickmathspace">
</mspace>
<mrow>
<mo lspace="8.1pt" stretchy="false">(</mo>
<mrow>
<mo>mod</mo>
<mi>n</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<equivalent></equivalent>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>a</ci>
<apply>
<ci>normal-⋅</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<cn type="integer">2</cn>
<ci>r</ci>
</apply>
<ci>d</ci>
</apply>
</apply>
<apply>
<csymbol cd="latexml">annotated</csymbol>
<apply>
<minus></minus>
<cn type="integer">1</cn>
</apply>
<apply>
<ci>pmod</ci>
<ci>n</ci>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   a^{2^{r}\cdot d}\equiv-1\;\;(\mathop{{\rm mod}}n)
  </annotation>
</semantics>
</math>

 for some 0 ≤ r ≤ <em>s</em> − 1.</p>

<p>To show that one of these must be true, recall <a href="Fermat's_little_theorem" title="wikilink">Fermat's little theorem</a>, that for a prime number n:</p>

<p>
<math display="block" id="Miller–Rabin_primality_test:4">
<semantics>
<mrow>
<mrow>
<msup>
<mi>a</mi>
<mrow>
<mi>n</mi>
<mo>-</mo>
<mn>1</mn>
</mrow>
</msup>
<mo>≡</mo>
<mrow>
<mn>1</mn>
<mspace width="veryverythickmathspace">
</mspace>
<mrow>
<mo lspace="8.1pt" stretchy="false">(</mo>
<mrow>
<mo>mod</mo>
<mi>n</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<equivalent></equivalent>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>a</ci>
<apply>
<minus></minus>
<ci>n</ci>
<cn type="integer">1</cn>
</apply>
</apply>
<apply>
<csymbol cd="latexml">annotated</csymbol>
<cn type="integer">1</cn>
<apply>
<ci>pmod</ci>
<ci>n</ci>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   a^{n-1}\equiv 1\;\;(\mathop{{\rm mod}}n).
  </annotation>
</semantics>
</math>
</p>

<p>By the lemma above, if we keep taking square roots of <em>a</em><sup><em>n</em>−1</sup>, we will get either 1 or −1. If we get −1 then the second equality holds and it is done. If we never get −1, then when we have taken out every power of 2, we are left with the first equality.</p>

<p>The Miller–Rabin primality test is based on the <a class="uri" href="contrapositive" title="wikilink">contrapositive</a> of the above claim. That is, if we can find an <em>a</em> such that</p>

<p>
<math display="block" id="Miller–Rabin_primality_test:5">
<semantics>
<mrow>
<msup>
<mi>a</mi>
<mi>d</mi>
</msup>
<mo>≢</mo>
<mrow>
<mn>1</mn>
<mspace width="veryverythickmathspace">
</mspace>
<mrow>
<mo lspace="8.1pt" stretchy="false">(</mo>
<mrow>
<mo>mod</mo>
<mi>n</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="latexml">not-equivalent-to</csymbol>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>a</ci>
<ci>d</ci>
</apply>
<apply>
<csymbol cd="latexml">annotated</csymbol>
<cn type="integer">1</cn>
<apply>
<ci>pmod</ci>
<ci>n</ci>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   a^{d}\not\equiv 1\;\;(\mathop{{\rm mod}}n)
  </annotation>
</semantics>
</math>

 and</p>

<p>
<math display="block" id="Miller–Rabin_primality_test:6">
<semantics>
<mrow>
<msup>
<mi>a</mi>
<mrow>
<msup>
<mn>2</mn>
<mi>r</mi>
</msup>
<mi>d</mi>
</mrow>
</msup>
<mo>≢</mo>
<mrow>
<mrow>
<mo>-</mo>
<mn>1</mn>
</mrow>
<mspace width="veryverythickmathspace">
</mspace>
<mrow>
<mo lspace="8.1pt" stretchy="false">(</mo>
<mrow>
<mo>mod</mo>
<mi>n</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="latexml">not-equivalent-to</csymbol>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>a</ci>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<cn type="integer">2</cn>
<ci>r</ci>
</apply>
<ci>d</ci>
</apply>
</apply>
<apply>
<csymbol cd="latexml">annotated</csymbol>
<apply>
<minus></minus>
<cn type="integer">1</cn>
</apply>
<apply>
<ci>pmod</ci>
<ci>n</ci>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   a^{2^{r}d}\not\equiv-1\;\;(\mathop{{\rm mod}}n)
  </annotation>
</semantics>
</math>

 for all 0 ≤ r ≤ <em>s</em> − 1, then <em>n</em> is not prime. We call <em>a</em> a <a href="Witness_(mathematics)" title="wikilink">witness</a> for the compositeness of <em>n</em> (sometimes misleadingly called a <em>strong witness</em>, although it is a certain proof of this fact). Otherwise <em>a</em> is called a <em>strong liar</em>, and <em>n</em> is a <a href="probable_prime" title="wikilink">strong probable prime</a> to base <em>a</em>. The term "strong liar" refers to the case where <em>n</em> is composite but nevertheless the equations hold as they would for a prime.</p>

<p>Every odd composite <em>n</em> has many witnesses <em>a</em>, however, no simple way of generating such an <em>a</em> is known. The solution is to make the test <a href="primality_test#Probabilistic_tests" title="wikilink">probabilistic</a>: we choose a non-zero <em>a</em> in <strong>Z</strong>/<em>n</em><strong>Z</strong> randomly, and check whether or not it is a witness for the compositeness of <em>n</em>. If <em>n</em> is composite, most of the choices for <em>a</em> will be witnesses, and the test will detect <em>n</em> as composite with high probability. There is, nevertheless, a small chance that we are unlucky and hit an <em>a</em> which is a strong liar for <em>n</em>. We may reduce the probability of such error by repeating the test for several independently chosen <em>a</em>.</p>

<p>For testing large numbers, it is common to choose random bases <em>a</em>, as, a priori, we don't know the distribution of witnesses and liars among the numbers 1, 2, ..., <em>n</em> − 1. In particular, Arnault <a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> gave a 397-digit composite number for which all bases <em>a</em> less than 307 are strong liars. As expected this number was reported to be prime by the <a href="Maple_(software)" title="wikilink">Maple</a> <code>isprime()</code> function, which implemented the Miller–Rabin test by checking the specific bases 2,3,5,7, and 11. However, selection of a few specific small bases can guarantee identification of composites for <em>n</em> less than some maximum determined by said bases. This maximum is generally quite large compared to the bases. As random bases lack such determinism for small <em>n</em>, specific bases are better in some circumstances.</p>
<h2 id="example">Example</h2>

<p>Suppose we wish to determine if <em>n</em> = 221 is prime. We write  as 2<sup>2</sup>·55, so that we have <em>s</em> = 2 and <em>d</em> = 55. We randomly select a number <em>a</em> such that 0 2<sup>0</sup>·<em>d</em> mod <em>n</em> = 174<sup>55</sup> mod 221 = 47 ≠ 1, <em>n</em> − 1</p>
<ul>
<li><em>a</em><sup>2<sup>1</sup>·<em>d</em></sup> mod <em>n</em> = 174<sup>110</sup> mod 221 = 220 = <em>n</em> − 1.</li>
</ul>

<p>Since 220 ≡ −1 mod <em>n</em>, either 221 is prime, or 174 is a strong liar for 221. We try another random <em>a</em>, this time choosing <em>a</em> = 137:</p>
<ul>
<li><em>a</em><sup>2<sup>0</sup>·<em>d</em></sup> mod <em>n</em> = 137<sup>55</sup> mod 221 = 188 ≠ 1, <em>n</em> − 1</li>
<li><em>a</em><sup>2<sup>1</sup>·<em>d</em></sup> mod <em>n</em> = 137<sup>110</sup> mod 221 = 205 ≠ <em>n</em> − 1.</li>
</ul>

<p>Hence 137 is a witness for the compositeness of 221, and 174 was in fact a strong liar. Note that this tells us nothing about the factors of 221 (which are 13 and 17). However, the example with 341 in the next section shows how these calculations can sometimes produce a factor of <em>n</em>.</p>
<h2 id="algorithm-and-running-time">Algorithm and running time</h2>

<p>The algorithm can be written in <a class="uri" href="pseudocode" title="wikilink">pseudocode</a> as follows:</p>

<p><strong><code>Input</code></strong><code>: </code><em><code>n</code></em><code> &gt; 3, an odd integer to be tested for primality;</code><br/>
<strong><code>Input</code></strong><code>: </code><em><code>k</code></em><code>, a parameter that determines the accuracy of the test</code><br/>
<strong><code>Output</code></strong><code>: </code><em><code>composite</code></em><code> if </code><em><code>n</code></em><code> is composite, otherwise </code><em><code>probably</code> <code>prime</code></em><br/>
<code>write </code><em><code>n</code></em><code> − 1 as 2</code><sup><em><code>s</code></em></sup><code>·</code><em><code>d</code></em><code> with </code><em><code>d</code></em><code> odd by factoring powers of 2 from </code><em><code>n</code></em><code> − 1</code><br/>
<code>WitnessLoop: repeat </code><em><code>k</code></em><code> times:</code><br/>
<code>   pick a random integer </code><em><code>a</code></em><code> in the range [2, </code><em><code>n</code></em><code> − 2]</code><br/>
<code>   </code><em><code>x</code></em><code> ← </code><em><code>a</code></em><sup><em><code>d</code></em></sup><code> mod </code><em><code>n</code></em><br/>
<code>   if </code><em><code>x</code></em><code> = 1 or </code><em><code>x</code></em><code> = </code><em><code>n</code></em><code> − 1 then do next WitnessLoop</code><br/>
<code>   repeat </code><em><code>s</code></em><code> − 1 times:</code><br/>
<code>      </code><em><code>x</code></em><code> ← </code><em><code>x</code></em><sup><code>2</code></sup><code> mod </code><em><code>n</code></em><br/>
<code>      if </code><em><code>x</code></em><code> = 1 then return </code><em><code>composite</code></em><br/>
<code>      if </code><em><code>x</code></em><code> = </code><em><code>n</code></em><code> − 1 then do next WitnessLoop</code><br/>
<code>   return </code><em><code>composite</code></em><br/>
<code>return </code><em><code>probably</code> <code>prime</code></em></p>

<p>Using <a href="modular_exponentiation" title="wikilink">modular exponentiation</a> by <a href="Exponentiation_by_squaring" title="wikilink">repeated squaring</a>, the running time of this algorithm is <a href="Big_O_notation" title="wikilink">O</a>(<em>k</em> log<sup>3</sup><em>n</em>), where <em>k</em> is the number of different values of <em>a</em> that we test; thus this is an efficient, polynomial-time algorithm. <a href="Fast_Fourier_transform" title="wikilink">FFT</a>-based multiplication can push the running time down to <mtpl></mtpl> = <a href="Big_O_notation#Extensions_to_the_Bachmann–Landau_notations" title="wikilink">Õ</a>(<em>k</em> log<sup>2</sup><em>n</em>).</p>

<p>If we insert <a href="Greatest_common_divisor" title="wikilink">Greatest common divisor</a> (GCD) calculations into the above algorithm, we can sometimes obtain a factor of <em>n</em> instead of merely determining that <em>n</em> is composite. In particular, if <em>n</em> is a probable prime base <em>a</em> but not a strong probable prime base <em>a</em>, then either <mtpl></mtpl> or (for some <em>r</em> in the above range) <mtpl></mtpl> will produce a (not necessarily prime) factor of <em>n</em>; see page 1402 of.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> If factoring is a goal, these GCDs can be inserted into the above algorithm at little additional computational cost.</p>

<p>For example, consider <em>n</em> = 341. We have  Then <mtpl> 32.}}</mtpl> This tells us that <em>n</em> is not a strong probable prime base 2, so we know <em>n</em> is composite. If we take a GCD at this stage, we can get a factor of 341: <mtpl> 31.}}</mtpl> This works because 341 is a pseudoprime base 2, but is not a <a href="strong_pseudoprime" title="wikilink">strong pseudoprime</a> base 2.</p>

<p>In the case that the algorithm returns "composite" because <em>x</em> = 1, it has also discovered that <em>d</em>2<sup><em>r</em></sup> is (an odd multiple of) the <a href="order_(group_theory)" title="wikilink">order</a> of <em>a</em>—a fact which can (as in <a href="Shor's_algorithm" title="wikilink">Shor's algorithm</a>) be used to factorize <em>n</em>, since <em>n</em> then divides</p>

<p>
<math display="block" id="Miller–Rabin_primality_test:7">
<semantics>
<mrow>
<mrow>
<msup>
<mi>a</mi>
<mrow>
<mi>d</mi>
<msup>
<mn>2</mn>
<mi>r</mi>
</msup>
</mrow>
</msup>
<mo>-</mo>
<mn>1</mn>
</mrow>
<mo>=</mo>
<mrow>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<msup>
<mi>a</mi>
<mrow>
<mi>d</mi>
<msup>
<mn>2</mn>
<mrow>
<mi>r</mi>
<mo>-</mo>
<mn>1</mn>
</mrow>
</msup>
</mrow>
</msup>
<mo>-</mo>
<mn>1</mn>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<msup>
<mi>a</mi>
<mrow>
<mi>d</mi>
<msup>
<mn>2</mn>
<mrow>
<mi>r</mi>
<mo>-</mo>
<mn>1</mn>
</mrow>
</msup>
</mrow>
</msup>
<mo>+</mo>
<mn>1</mn>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<minus></minus>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>a</ci>
<apply>
<times></times>
<ci>d</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<cn type="integer">2</cn>
<ci>r</ci>
</apply>
</apply>
</apply>
<cn type="integer">1</cn>
</apply>
<apply>
<times></times>
<apply>
<minus></minus>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>a</ci>
<apply>
<times></times>
<ci>d</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<cn type="integer">2</cn>
<apply>
<minus></minus>
<ci>r</ci>
<cn type="integer">1</cn>
</apply>
</apply>
</apply>
</apply>
<cn type="integer">1</cn>
</apply>
<apply>
<plus></plus>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>a</ci>
<apply>
<times></times>
<ci>d</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<cn type="integer">2</cn>
<apply>
<minus></minus>
<ci>r</ci>
<cn type="integer">1</cn>
</apply>
</apply>
</apply>
</apply>
<cn type="integer">1</cn>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   a^{d2^{r}}-1=(a^{d2^{r-1}}-1)(a^{d2^{r-1}}+1)
  </annotation>
</semantics>
</math>

 but not either factor by itself. The reason Miller–Rabin does <em>not</em> yield a probabilistic <a href="Integer_factorization" title="wikilink">factorization</a> algorithm is that if</p>

<p>
<math display="block" id="Miller–Rabin_primality_test:8">
<semantics>
<mrow>
<msup>
<mi>a</mi>
<mrow>
<mi>n</mi>
<mo>-</mo>
<mn>1</mn>
</mrow>
</msup>
<mo>≢</mo>
<mrow>
<mn>1</mn>
<mspace width="veryverythickmathspace">
</mspace>
<mrow>
<mo lspace="8.1pt" stretchy="false">(</mo>
<mrow>
<mo>mod</mo>
<mi>n</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="latexml">not-equivalent-to</csymbol>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>a</ci>
<apply>
<minus></minus>
<ci>n</ci>
<cn type="integer">1</cn>
</apply>
</apply>
<apply>
<csymbol cd="latexml">annotated</csymbol>
<cn type="integer">1</cn>
<apply>
<ci>pmod</ci>
<ci>n</ci>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   a^{n-1}\not\equiv 1\;\;(\mathop{{\rm mod}}n)
  </annotation>
</semantics>
</math>

 (i.e., <em>n</em> is not a <a class="uri" href="pseudoprime" title="wikilink">pseudoprime</a> to base <em>a</em>) then no such information is obtained about the period of <em>a</em>, and the second "return composite" is taken.</p>
<h2 id="accuracy-of-the-test">Accuracy of the test</h2>

<p>The more bases <em>a</em> we test, the better the accuracy of the test. It can be shown that for any odd composite <em>n</em>, at least 3/4 of the bases <em>a</em> are witnesses for the compositeness of <em>n</em>.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a><a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> The Miller–Rabin test is strictly stronger than the Solovay–Strassen primality test in the sense that for every composite <em>n</em>, the set of strong liars for <em>n</em> is a subset of the set of <a href="Euler_liar" title="wikilink">Euler liars</a> for <em>n</em>, and for many <em>n</em>, the subset is proper. If <em>n</em> is composite then the Miller–Rabin primality test declares <em>n</em> probably prime with a probability at most 4<sup>−<em>k</em></sup>. On the other hand, the Solovay–Strassen primality test declares <em>n</em> probably prime with a probability at most 2<sup>−<em>k</em></sup>.</p>

<p>It is important to note that in many common applications of this algorithm, we are not interested in the error bound described above. The above error bound is the probability of a composite number being declared as a probable prime after <em>k</em> rounds of testing. We are often instead interested in the probability that, after passing <em>k</em> rounds of testing, the number being tested is actually a composite number. Formally, if we call the event of declaring <em>n</em> a probable prime after <em>k</em> rounds of Miller–Rabin <em>Y<sub>k</sub></em>, and we call the event that <em>n</em> is composite <em>X</em> (and denote the event that <em>n</em> is prime 

<math display="inline" id="Miller–Rabin_primality_test:9">
<semantics>
<mover accent="true">
<mi>X</mi>
<mo>¯</mo>
</mover>
<annotation-xml encoding="MathML-Content">
<apply>
<ci>normal-¯</ci>
<ci>X</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \overline{X}
  </annotation>
</semantics>
</math>

), then the above bound gives us 

<math display="inline" id="Miller–Rabin_primality_test:10">
<semantics>
<mrow>
<mi>P</mi>
<mrow>
<mo stretchy="false">(</mo>
<msub>
<mi>Y</mi>
<mi>k</mi>
</msub>
<mo stretchy="false">|</mo>
<mi>X</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<csymbol cd="unknown">P</csymbol>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>Y</ci>
<ci>k</ci>
</apply>
<ci>normal-|</ci>
<csymbol cd="unknown">X</csymbol>
<ci>normal-)</ci>
</cerror>
</cerror>
</annotation-xml>
<annotation encoding="application/x-tex">
   P(Y_{k}|X)
  </annotation>
</semantics>
</math>

, whereas we are interested in 

<math display="inline" id="Miller–Rabin_primality_test:11">
<semantics>
<mrow>
<mi>P</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>X</mi>
<mo stretchy="false">|</mo>
<msub>
<mi>Y</mi>
<mi>k</mi>
</msub>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<csymbol cd="unknown">P</csymbol>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<csymbol cd="unknown">X</csymbol>
<ci>normal-|</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>Y</ci>
<ci>k</ci>
</apply>
<ci>normal-)</ci>
</cerror>
</cerror>
</annotation-xml>
<annotation encoding="application/x-tex">
   P(X|Y_{k})
  </annotation>
</semantics>
</math>

. <a href="Bayes'_theorem" title="wikilink">Bayes' theorem</a> gives us a way to relate these two conditional probabilities, namely</p>

<p>
<math display="block" id="Miller–Rabin_primality_test:12">
<semantics>
<mrow>
<mi>P</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>X</mi>
<mo stretchy="false">|</mo>
<msub>
<mi>Y</mi>
<mi>k</mi>
</msub>
<mo stretchy="false">)</mo>
</mrow>
<mo>=</mo>
<mfrac>
<mrow>
<mi>P</mi>
<mrow>
<mo stretchy="false">(</mo>
<msub>
<mi>Y</mi>
<mi>k</mi>
</msub>
<mo stretchy="false">|</mo>
<mi>X</mi>
<mo stretchy="false">)</mo>
</mrow>
<mi>P</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>X</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mrow>
<mi>P</mi>
<mrow>
<mo stretchy="false">(</mo>
<msub>
<mi>Y</mi>
<mi>k</mi>
</msub>
<mo stretchy="false">|</mo>
<mi>X</mi>
<mo stretchy="false">)</mo>
</mrow>
<mi>P</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>X</mi>
<mo stretchy="false">)</mo>
</mrow>
<mo>+</mo>
<mi>P</mi>
<mrow>
<mo stretchy="false">(</mo>
<msub>
<mi>Y</mi>
<mi>k</mi>
</msub>
<mo stretchy="false">|</mo>
<mover accent="true">
<mi>X</mi>
<mo>¯</mo>
</mover>
<mo stretchy="false">)</mo>
</mrow>
<mi>P</mi>
<mrow>
<mo stretchy="false">(</mo>
<mover accent="true">
<mi>X</mi>
<mo>¯</mo>
</mover>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mfrac>
</mrow>
<annotation-xml encoding="MathML-Content">
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<csymbol cd="unknown">P</csymbol>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<csymbol cd="unknown">X</csymbol>
<ci>normal-|</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>Y</ci>
<ci>k</ci>
</apply>
<ci>normal-)</ci>
</cerror>
<eq></eq>
<apply>
<divide></divide>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<csymbol cd="unknown">P</csymbol>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>Y</ci>
<ci>k</ci>
</apply>
<ci>normal-|</ci>
<csymbol cd="unknown">X</csymbol>
<ci>normal-)</ci>
</cerror>
<csymbol cd="unknown">P</csymbol>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<csymbol cd="unknown">X</csymbol>
<ci>normal-)</ci>
</cerror>
</cerror>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<csymbol cd="unknown">P</csymbol>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>Y</ci>
<ci>k</ci>
</apply>
<ci>normal-|</ci>
<csymbol cd="unknown">X</csymbol>
<ci>normal-)</ci>
</cerror>
<csymbol cd="unknown">P</csymbol>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<csymbol cd="unknown">X</csymbol>
<ci>normal-)</ci>
</cerror>
<plus></plus>
<csymbol cd="unknown">P</csymbol>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>Y</ci>
<ci>k</ci>
</apply>
<ci>normal-|</ci>
<apply>
<ci>normal-¯</ci>
<ci>X</ci>
</apply>
<ci>normal-)</ci>
</cerror>
<csymbol cd="unknown">P</csymbol>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<apply>
<ci>normal-¯</ci>
<ci>X</ci>
</apply>
<ci>normal-)</ci>
</cerror>
</cerror>
</apply>
</cerror>
</annotation-xml>
<annotation encoding="application/x-tex">
   P(X|Y_{k})=\frac{P(Y_{k}|X)P(X)}{P(Y_{k}|X)P(X)+P(Y_{k}|\overline{X})P(%
\overline{X})}
  </annotation>
</semantics>
</math>

.</p>

<p>This tells us that the probability that we are often interested in is related not just to the 4<sup>−<em>k</em></sup> bound above, but also probabilities related to the density of prime numbers in the region near <em>n</em>.</p>

<p>In addition, for large values of <em>n</em>, on average the probability that a composite number is declared <em>probably prime</em> is significantly smaller than 4<sup>−<em>k</em></sup>. <a href="Ivan_Damgård" title="wikilink">Damgård</a>, Landrock and <a href="Carl_Pomerance" title="wikilink">Pomerance</a><a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> compute some explicit bounds and provide a method to make a reasonable selection for <em>k</em> for a desired error bound. Such bounds can, for example, be used to <em>generate</em> probable primes; however, they should not be used to <em>verify</em> primes with unknown origin, since in <a href="cryptography" title="wikilink">cryptographic</a> applications an adversary might try to send you a <a class="uri" href="pseudoprime" title="wikilink">pseudoprime</a> in a place where a prime number is required. In such cases, only the error bound of 4<sup>−<em>k</em></sup> can be relied upon.</p>
<h2 id="deterministic-variants-of-the-test">Deterministic variants of the test</h2>

<p>The Miller–Rabin algorithm can be made deterministic by trying all possible <em>a</em> below a certain limit. The problem in general is to set the limit so that the test is still reliable.</p>

<p>If the tested number <em>n</em> is composite, the strong liars <em>a</em> coprime to <em>n</em> are contained in a proper <a class="uri" href="subgroup" title="wikilink">subgroup</a> of the group (<strong>Z</strong>/''n'<strong>'Z</strong>)*, which means that if we test all <em>a</em> from a set which <a href="generating_set_of_a_group" title="wikilink">generates</a> (<strong>Z</strong>/<em>n</em><strong>Z</strong>)*, one of them must be a witness for the compositeness of <em>n</em>. Assuming the truth of the <a href="generalized_Riemann_hypothesis" title="wikilink">generalized Riemann hypothesis</a> (GRH), it is known that the group is generated by its elements smaller than O((log <em>n</em>)<sup>2</sup>), which was already noted by Miller.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> The constant involved in the <a href="Big_O_notation" title="wikilink">Big O notation</a> was reduced to 2 by <a href="Eric_Bach" title="wikilink">Eric Bach</a>.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> This leads to the following conditional primality testing algorithm:</p>

<p><strong><code>Input</code></strong><code>: </code><em><code>n</code></em><code> &gt; 1, an odd integer to test for primality.</code><br/>
<strong><code>Output</code></strong><code>: </code><em><code>composite</code></em><code> if </code><em><code>n</code></em><code> is composite, otherwise </code><em><code>prime</code></em><br/>
<code>write </code><em><code>n</code></em><code>−1 as 2</code><sup><code>s</code></sup><code>·</code><em><code>d</code></em><code> by factoring powers of 2 from </code><em><code>n</code></em><code>−1</code><br/>
<code>repeat for all </code>
<math display="inline" id="Miller–Rabin_primality_test:13">
<semantics>
<mrow>
<mi>a</mi>
<mo>∈</mo>
<mrow>
<mo stretchy="false">[</mo>
<mn>2</mn>
<mo>,</mo>
<mrow>
<mi>min</mi>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>n</mi>
<mo>-</mo>
<mn>1</mn>
</mrow>
<mo>,</mo>
<mrow>
<mo stretchy="false">⌊</mo>
<mrow>
<mn>2</mn>
<msup>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>ln</mi>
<mi>n</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mn>2</mn>
</msup>
</mrow>
<mo stretchy="false">⌋</mo>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo stretchy="false">]</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<in></in>
<ci>a</ci>
<interval closure="closed">
<cn type="integer">2</cn>
<apply>
<min></min>
<apply>
<minus></minus>
<ci>n</ci>
<cn type="integer">1</cn>
</apply>
<apply>
<floor></floor>
<apply>
<times></times>
<cn type="integer">2</cn>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<ln></ln>
<ci>n</ci>
</apply>
<cn type="integer">2</cn>
</apply>
</apply>
</apply>
</apply>
</interval>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   a\in[2,\min(n-1,\lfloor 2(\ln n)^{2}\rfloor)]
  </annotation>
</semantics>
</math>
<code>:</code><br/>
<code>    if </code>
<math display="inline" id="Miller–Rabin_primality_test:14">
<semantics>
<mrow>
<msup>
<mi>a</mi>
<mi>d</mi>
</msup>
<mo>≢</mo>
<mn>1</mn>
<mrow>
<mo lspace="8.1pt" stretchy="false">(</mo>
<mrow>
<mo>mod</mo>
<mi>n</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mtext>and</mtext>
<msup>
<mi>a</mi>
<mrow>
<msup>
<mn>2</mn>
<mi>r</mi>
</msup>
<mo>⋅</mo>
<mi>d</mi>
</mrow>
</msup>
<mo>≢</mo>
<mo>-</mo>
<mn>1</mn>
<mrow>
<mo lspace="8.1pt" stretchy="false">(</mo>
<mrow>
<mo>mod</mo>
<mi>n</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mtext>for all</mtext>
<mi>r</mi>
<mo>∈</mo>
<mrow>
<mo stretchy="false">[</mo>
<mn>0</mn>
<mo>,</mo>
<mi>s</mi>
<mo>-</mo>
<mn>1</mn>
<mo stretchy="false">]</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>a</ci>
<ci>d</ci>
</apply>
<csymbol cd="latexml">not-equivalent-to</csymbol>
<cn type="integer">1</cn>
<apply>
<ci>pmod</ci>
<ci>n</ci>
</apply>
<mtext>and</mtext>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>a</ci>
<apply>
<ci>normal-⋅</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<cn type="integer">2</cn>
<ci>r</ci>
</apply>
<ci>d</ci>
</apply>
</apply>
<csymbol cd="latexml">not-equivalent-to</csymbol>
<minus></minus>
<cn type="integer">1</cn>
<apply>
<ci>pmod</ci>
<ci>n</ci>
</apply>
<mtext>for all</mtext>
<csymbol cd="unknown">r</csymbol>
<in></in>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-[</ci>
<cn type="integer">0</cn>
<ci>normal-,</ci>
<csymbol cd="unknown">s</csymbol>
<minus></minus>
<cn type="integer">1</cn>
<ci>normal-]</ci>
</cerror>
</cerror>
</annotation-xml>
<annotation encoding="application/x-tex">
   a^{d}\not\equiv 1\;\;(\mathop{{\rm mod}}n)\text{ and }a^{2^{r}\cdot d}\not%
\equiv-1\;\;(\mathop{{\rm mod}}n)\text{ for all }r\in[0,s-1]
  </annotation>
</semantics>
</math>
<br/>
<code>    then return </code><em><code>composite</code></em><br/>
<code>return </code><em><code>prime</code></em></p>

<p>The running time of the algorithm is Õ((log <em>n</em>)<sup>4</sup>) (with FFT-based multiplication). The full power of the generalized Riemann hypothesis is not needed to ensure the correctness of the test: as we deal with subgroups of even <a href="index_of_a_subgroup" title="wikilink">index</a>, it suffices to assume the validity of GRH for <a href="Legendre_symbol" title="wikilink">quadratic</a> <a href="Dirichlet_character" title="wikilink">Dirichlet characters</a>.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a></p>

<p>The Miller test (the algorithm above) is not used in practice. For most purposes, proper use of the probabilistic Miller-Rabin test or the <a href="Baillie-PSW_primality_test" title="wikilink">Baillie-PSW primality test</a> gives sufficient confidence while running much faster. It is also slower in practice than commonly used proof methods such as <a href="Adleman–Pomerance–Rumely_primality_test" title="wikilink">APR-CL</a> and <a href="Elliptic_curve_primality_proving" title="wikilink">ECPP</a> which give results that do not rely on unproven assumptions. For theoretical purposes requiring a deterministic polynomial time algorithm, it was superseded by the <a href="AKS_primality_test" title="wikilink">AKS primality test</a>, which also does not rely on unproven assumptions.</p>

<p>When the number <em>n</em> to be tested is small, trying all <mtpl></mtpl> is not necessary, as much smaller sets of potential witnesses are known to suffice. For example, Pomerance, Selfridge and Wagstaff<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> and Jaeschke<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> have verified that</p>
<ul>
<li>if <em>n</em> &lt; 2,047, it is enough to test <em>a</em> = 2;</li>
<li>if <em>n</em> &lt; 1,373,653, it is enough to test <em>a</em> = 2 and 3;</li>
<li>if <em>n</em> &lt; 9,080,191, it is enough to test <em>a</em> = 31 and 73;</li>
<li>if <em>n</em> &lt; 25,326,001, it is enough to test <em>a</em> = 2, 3, and 5;</li>
<li>if <em>n</em> &lt; 4,759,123,141, it is enough to test <em>a</em> = 2, 7, and 61;</li>
<li>if <em>n</em> &lt; 1,122,004,669,633, it is enough to test <em>a</em> = 2, 13, 23, and 1662803;</li>
<li>if <em>n</em> &lt; 2,152,302,898,747, it is enough to test <em>a</em> = 2, 3, 5, 7, and 11;</li>
<li>if <em>n</em> &lt; 3,474,749,660,383, it is enough to test <em>a</em> = 2, 3, 5, 7, 11, and 13;</li>
<li>if <em>n</em> &lt; 341,550,071,728,321, it is enough to test <em>a</em> = 2, 3, 5, 7, 11, 13, and 17;</li>
<li>if <em>n</em> &lt; 3,825,123,056,546,413,051, it is enough to test <em>a</em> = 2, 3, 5, 7, 11, 13, 17, 19, and 23.</li>
</ul>

<p>Note that Miller-Rabin pseudoprimes are called <a href="strong_pseudoprime" title="wikilink">strong pseudoprimes</a>.</p>

<p>Other criteria of this sort exist<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a><a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a><a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a><a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a> and these results give very fast deterministic primality tests for numbers in the appropriate range, without any assumptions.</p>

<p>There is a small list of potential witnesses for every possible input size (at most <em>n</em> values for <em>n</em>-bit numbers). However, no finite set of bases is sufficient for all composite numbers. Alford, Granville, and Pomerance have shown that there exist infinitely many composite numbers <em>n</em> whose smallest compositeness witness is at least <mtpl></mtpl>.<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a> They also argue heuristically that the smallest number <em>w</em> such that every composite number below <em>n</em> has a compositeness witness less than <em>w</em> should be of order </p>
<h2 id="notes">Notes</h2>
<h2 id="external-links">External links</h2>
<ul>
<li></li>
<li><a href="http://gandraxa.com/miller_rabin_primality_test.xml">Interactive Online Implementation of the Deterministic Variant</a> (stepping through the algorithm step-by-step)</li>
<li><a href="http://www.informationsuebertragung.ch/indexAlgorithmenRabinMiller.html">Applet (German)</a></li>
<li><a href="http://stackoverflow.com/questions/4236673/sample-code-for-fast-primality-testing-in-c-sharp/4236870#4236870">Miller-Rabin primality test in C#</a></li>
<li><a href="http://www.javascripter.net/math/primes/millerrabinprimalitytest.htm">Miller-Rabin primality test in JavaScript using arbitrary precision arithmetic</a></li>
</ul>

<p>"</p>

<p><a href="Category:Primality_tests" title="wikilink">Category:Primality tests</a> <a href="Category:Finite_fields" title="wikilink">Category:Finite fields</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
<li id="fn8"></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
<li id="fn10"></li>
<li id="fn11"><mtpl></mtpl><a href="#fnref11">↩</a></li>
<li id="fn12"><a href="#fnref12">↩</a></li>
<li id="fn13"><a href="#fnref13">↩</a></li>
<li id="fn14"><a href="#fnref14">↩</a></li>
<li id="fn15"><a href="#fnref15">↩</a></li>
<li id="fn16"><a href="#fnref16">↩</a></li>
<li id="fn17"><a href="#fnref17">↩</a></li>
</ol>
</section>
</hr></body>
</html>
