<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="407">Quantum circuit</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Quantum circuit</h1>
<hr/>

<p>In <a href="quantum_information_theory" title="wikilink">quantum information theory</a>, a <strong>quantum circuit</strong> is a <a href="model_(abstract)" title="wikilink">model</a> for <a href="quantum_computation" title="wikilink">quantum computation</a> in which a computation is a sequence of <a href="quantum_gate" title="wikilink">quantum gates</a>, which are reversible transformations on a <a href="quantum_mechanics" title="wikilink">quantum mechanical</a> <a href="Quantum_register" title="wikilink">analog</a> of an <em>n</em>-<a class="uri" href="bit" title="wikilink">bit</a> <a href="Processor_register" title="wikilink">register</a>. This analogous structure is referred to as an <em>n</em>-<a class="uri" href="qubit" title="wikilink">qubit</a> register.</p>
<h2 id="reversible-classical-logic-gates">Reversible classical logic gates</h2>

<p>The elementary <a href="logic_gate" title="wikilink">logic gates</a> of a classical computer, other than the <a href="NOT_gate" title="wikilink">NOT gate</a>, are not <a href="Reversible_computing" title="wikilink">reversible</a>. Thus, for instance, for an <a href="AND_gate" title="wikilink">AND gate</a> one cannot recover the two input bits from the output bit; for example, if the output bit is 0, we cannot tell from this whether the input bits are 0,1 or 1,0 or 0,0.</p>

<p>However, reversible gates in classical computers are easily constructed for bit strings of any length; moreover, these are actually of practical interest, since they do not increase <a class="uri" href="entropy" title="wikilink">entropy</a>. A reversible gate is a reversible function on <em>n</em>-bit data that returns <em>n</em>-bit data, where an <em>n</em>-bit data is a <a href="string_(computer_science)" title="wikilink">string</a> of bits <em>x</em><sub>1</sub>,<em>x</em><sub>2</sub>, ...,<em>x</em><sub><em>n</em></sub> of length <em>n</em>. The set of <em>n</em>-bit data is the space {0,1}<sup><em>n</em></sup>, which consists of 2<sup><em>n</em></sup> strings of 0's and 1's.</p>

<p>More precisely: an <em>n</em>-bit reversible gate is a <a class="uri" href="bijective" title="wikilink">bijective</a> mapping <em>f</em> from the set {0,1}<sup><em>n</em></sup> of <em>n</em>-bit data onto itself. An example of such a reversible gate <em>f</em> is a mapping that applies a fixed permutation to its inputs. For reasons of practical engineering, one typically studies gates only for small values of <em>n</em>, e.g. <em>n</em>=1, <em>n</em>=2 or <em>n</em>=3. These gates can be easily described by tables.</p>
<h2 id="quantum-logic-gates">Quantum logic gates</h2>

<p>To define quantum gates, we first need to specify the quantum replacement of an <em>n</em>-bit datum. The <em>quantized version</em> of classical <em>n</em>-bit space {0,1}<sup><em>n</em></sup> is the Hilbert space</p>

<p>

<math display="block" id="Quantum_circuit:0">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>H</mi>
     <mrow>
      <mo>QB</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>n</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </msub>
    <mo>=</mo>
    <mrow>
     <msup>
      <mi mathvariant="normal">ℓ</mi>
      <mn>2</mn>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <msup>
       <mrow>
        <mo stretchy="false">{</mo>
        <mn>0</mn>
        <mo>,</mo>
        <mn>1</mn>
        <mo stretchy="false">}</mo>
       </mrow>
       <mi>n</mi>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>H</ci>
     <apply>
      <ci>QB</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>normal-ℓ</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <set>
       <cn type="integer">0</cn>
       <cn type="integer">1</cn>
      </set>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{\operatorname{QB}(n)}=\ell^{2}(\{0,1\}^{n}).
  </annotation>
 </semantics>
</math>

</p>

<p>This is by definition the space of complex-valued functions on {0,1}<sup><em>n</em></sup> and is naturally an <a href="inner_product_space" title="wikilink">inner product space</a>. This space can also be regarded as consisting of linear superpositions of classical bit strings. Note that <em>H</em><sub>QB(<em>n</em>)</sub> is a vector space over the complex numbers of <a class="uri" href="dimension" title="wikilink">dimension</a> 2<sup><em>n</em></sup>. The elements of this space are called <em>n</em>-qubits.</p>

<p>Using Dirac <a href="bra-ket" title="wikilink">ket</a> notation, if <em>x</em><sub>1</sub>,<em>x</em><sub>2</sub>, ...,<em>x</em><sub><em>n</em></sub> is a classical bit string, then</p>

<p>

<math display="block" id="Quantum_circuit:1">
 <semantics>
  <mrow>
   <mrow>
    <mo fence="true" stretchy="false">|</mo>
    <mrow>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>x</mi>
      <mn>2</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">⋯</mi>
     <mo>,</mo>
     <msub>
      <mi>x</mi>
      <mi>n</mi>
     </msub>
    </mrow>
    <mo stretchy="false">⟩</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">ket</csymbol>
    <list>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-⋯</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>n</ci>
     </apply>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |x_{1},x_{2},\cdots,x_{n}\rangle\quad
  </annotation>
 </semantics>
</math>

 is a special <em>n</em>-qubit corresponding to the function which maps this classical bit string to 1 and maps all other bit strings to 0; these 2<sup><em>n</em></sup> special <em>n</em>-qubits are called <em>computational basis states</em>. All <em>n</em>-qubits are complex linear combinations of these computational basis states.</p>

<p>Quantum logic gates, in contrast to classical logic gates, are always reversible. One requires a special kind of reversible function, namely a <a href="unitarity_(physics)" title="wikilink">unitary</a> mapping, that is, a linear transformation of a complex <a href="inner_product_space" title="wikilink">inner product space</a> that preserves the <a href="Hermitian_inner_product" title="wikilink">Hermitian inner product</a>. An <em>n</em>-qubit (reversible) quantum gate is a <a href="unitary_operators" title="wikilink">unitary mapping</a> <em>U</em> from the space <em>H</em><sub>QB(<em>n</em>)</sub> of <em>n</em>-qubits onto itself.</p>

<p>Typically, we are only interested in gates for small values of <em>n</em>.</p>

<p>A reversible <em>n</em>-bit classical logic gate give rise to a reversible <em>n</em>-bit quantum gate as follows: to each reversible <em>n</em>-bit logic gate <em>f</em> corresponds a quantum gate <em>W</em><sub><em>f</em></sub> defined as follows:</p>

<p>

<math display="block" id="Quantum_circuit:2">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>W</mi>
      <mi>f</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mo fence="true" stretchy="false">|</mo>
       <mrow>
        <msub>
         <mi>x</mi>
         <mn>1</mn>
        </msub>
        <mo>,</mo>
        <msub>
         <mi>x</mi>
         <mn>2</mn>
        </msub>
        <mo>,</mo>
        <mi mathvariant="normal">⋯</mi>
        <mo>,</mo>
        <msub>
         <mi>x</mi>
         <mi>n</mi>
        </msub>
       </mrow>
       <mo stretchy="false">⟩</mo>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo fence="true" stretchy="false">|</mo>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>x</mi>
        <mn>1</mn>
       </msub>
       <mo>,</mo>
       <msub>
        <mi>x</mi>
        <mn>2</mn>
       </msub>
       <mo>,</mo>
       <mi mathvariant="normal">⋯</mi>
       <mo>,</mo>
       <msub>
        <mi>x</mi>
        <mi>n</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">⟩</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>W</ci>
      <ci>f</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">ket</csymbol>
      <list>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <cn type="integer">2</cn>
       </apply>
       <ci>normal-⋯</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>n</ci>
       </apply>
      </list>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">ket</csymbol>
     <apply>
      <times></times>
      <ci>f</ci>
      <vector>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <cn type="integer">2</cn>
       </apply>
       <ci>normal-⋯</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>n</ci>
       </apply>
      </vector>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W_{f}(|x_{1},x_{2},\cdots,x_{n}\rangle)=|f(x_{1},x_{2},\cdots,x_{n})\rangle.
  </annotation>
 </semantics>
</math>

 Note that <em>W</em><sub><em>f</em></sub> permutes the computational basis states.</p>

<p>Of particular importance is the controlled NOT gate (also called <a href="Controlled_NOT_gate" title="wikilink">CNOT</a> gate) <em>W</em><sub>CNOT</sub> defined on a quantized 2 qubit. Other examples of quantum logic gates derived from classical ones are the <a href="Toffoli_gate" title="wikilink">Toffoli gate</a> and the <a href="Fredkin_gate" title="wikilink">Fredkin gate</a>.</p>

<p>However, the Hilbert-space structure of the qubits permits many quantum gates that are not induced by classical ones. For example, a relative phase shift is a 1 qubit gate given by multiplication by the unitary matrix:</p>

<p>

<math display="block" id="Quantum_circuit:3">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>U</mi>
     <mi>θ</mi>
    </msub>
    <mo>=</mo>
    <mrow>
     <mo>[</mo>
     <mtable displaystyle="true">
      <mtr>
       <mtd columnalign="center">
        <msup>
         <mi>e</mi>
         <mrow>
          <mi>i</mi>
          <mi>θ</mi>
         </mrow>
        </msup>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
      </mtr>
     </mtable>
     <mo>]</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>U</ci>
     <ci>θ</ci>
    </apply>
    <matrix>
     <matrixrow>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>e</ci>
       <apply>
        <times></times>
        <ci>i</ci>
        <ci>θ</ci>
       </apply>
      </apply>
      <cn type="integer">0</cn>
     </matrixrow>
     <matrixrow>
      <cn type="integer">0</cn>
      <cn type="integer">1</cn>
     </matrixrow>
    </matrix>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U_{\theta}=\begin{bmatrix}e^{i\theta}&0\\
0&1\end{bmatrix},
  </annotation>
 </semantics>
</math>

 so</p>

<p>

<math display="block" id="Quantum_circuit:4">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <msub>
       <mi>U</mi>
       <mi>θ</mi>
      </msub>
      <mrow>
       <mo fence="true" stretchy="false">|</mo>
       <mn>0</mn>
       <mo stretchy="false">⟩</mo>
      </mrow>
     </mrow>
     <mo>=</mo>
     <mrow>
      <msup>
       <mi>e</mi>
       <mrow>
        <mi>i</mi>
        <mi>θ</mi>
       </mrow>
      </msup>
      <mrow>
       <mo fence="true" stretchy="false">|</mo>
       <mn>0</mn>
       <mo stretchy="false">⟩</mo>
      </mrow>
     </mrow>
    </mrow>
    <mrow>
     <mrow>
      <msub>
       <mi>U</mi>
       <mi>θ</mi>
      </msub>
      <mrow>
       <mo fence="true" stretchy="false">|</mo>
       <mn>1</mn>
       <mo stretchy="false">⟩</mo>
      </mrow>
     </mrow>
     <mo>=</mo>
     <mrow>
      <mo fence="true" stretchy="false">|</mo>
      <mn>1</mn>
      <mo stretchy="false">⟩</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>U</ci>
       <ci>θ</ci>
      </apply>
      <apply>
       <csymbol cd="latexml">ket</csymbol>
       <cn type="integer">0</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>e</ci>
       <apply>
        <times></times>
        <ci>i</ci>
        <ci>θ</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="latexml">ket</csymbol>
       <cn type="integer">0</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>U</ci>
       <ci>θ</ci>
      </apply>
      <apply>
       <csymbol cd="latexml">ket</csymbol>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">ket</csymbol>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U_{\theta}|0\rangle=e^{i\theta}|0\rangle\quad U_{\theta}|1\rangle=|1\rangle.
  </annotation>
 </semantics>
</math>

</p>
<h2 id="reversible-logic-circuits">Reversible logic circuits</h2>

<p>Again, we consider first <em>reversible</em> classical computation. Conceptually, there is no difference between a reversible <em>n</em>-bit circuit and a reversible <em>n</em>-bit logic gate: either one is just an invertible function on the space of <em>n</em> bit data. However, as mentioned in the previous section, for engineering reasons we would like to have a small number of simple reversible gates, that can be put together to assemble any reversible circuit.</p>

<p>To explain this assembly process, suppose we have a reversible <em>n</em>-bit gate <em>f</em> and a reversible <em>m</em>-bit gate <em>g</em>. Putting them together means producing a new circuit by connecting some set of <em>k</em> outputs of <em>f</em> to some set of <em>k</em> inputs of <em>g</em> as in the figure below. In that figure <em>n</em>=5, <em>k</em> =3 and <em>m</em> = 7. The resulting circuit is also reversible and operates on <em>n</em>+<em>m</em>−<em>k</em> bits.</p>
<center>
<figure><b>(Figure)</b>
<figcaption>Reversible circuit composition.svg</figcaption>
</figure>
</center>

<p>We will refer to this scheme as a <em>classical assemblage</em> (This concept corresponds to a technical definition in Kitaev's pioneering paper cited below). In composing these reversible machines, it is important to ensure that the intermediate machines are also reversible. This condition assures that <em>intermediate</em> "garbage" is not created (the net physical effect would be to increase entropy, which is one of the motivations for going through this exercise).</p>

<p>Now it is possible to show that the <a href="Toffoli_gate" title="wikilink">Toffoli gate</a> is a <a href="quantum_gate" title="wikilink">universal gate</a>. This means that given any reversible classical <em>n</em>-bit circuit <em>h</em>, we can construct a classical assemblage of Toffoli gates in the above manner to produce an (<em>n</em>+<em>m</em>)-bit circuit <em>f</em> such that</p>

<p>

<math display="block" id="Quantum_circuit:5">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <msub>
      <mi>x</mi>
      <mi>n</mi>
     </msub>
     <mo>,</mo>
     <munder accentunder="true">
      <mrow>
       <mn>0</mn>
       <mo>,</mo>
       <mi mathvariant="normal">…</mi>
       <mo>,</mo>
       <mn>0</mn>
      </mrow>
      <mo>⏟</mo>
     </munder>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>y</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>y</mi>
     <mi>n</mi>
    </msub>
    <mo>,</mo>
    <munder accentunder="true">
     <mrow>
      <mn>0</mn>
      <mo>,</mo>
      <mi mathvariant="normal">…</mi>
      <mo>,</mo>
      <mn>0</mn>
     </mrow>
     <mo>⏟</mo>
    </munder>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <ci>normal-⏟</ci>
       <list>
        <cn type="integer">0</cn>
        <ci>normal-…</ci>
        <cn type="integer">0</cn>
       </list>
      </apply>
     </vector>
    </apply>
    <vector>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <ci>normal-⏟</ci>
      <list>
       <cn type="integer">0</cn>
       <ci>normal-…</ci>
       <cn type="integer">0</cn>
      </list>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x_{1},\ldots,x_{n},\underbrace{0,\dots,0})=(y_{1},\ldots,y_{n},\underbrace{0%
,\ldots,0})
  </annotation>
 </semantics>
</math>

 where there are <em>m</em> underbraced zeroed inputs and</p>

<p>

<math display="block" id="Quantum_circuit:6">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>y</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>y</mi>
     <mi>n</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>h</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <msub>
      <mi>x</mi>
      <mi>n</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <vector>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <ci>n</ci>
     </apply>
    </vector>
    <apply>
     <times></times>
     <ci>h</ci>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>n</ci>
      </apply>
     </vector>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (y_{1},\ldots,y_{n})=h(x_{1},\ldots,x_{n})
  </annotation>
 </semantics>
</math>

. Notice that the end result always has a string of <em>m</em> zeros as the <a href="ancilla_(quantum_computing)" title="wikilink">ancilla</a> bits! No "rubbish" is ever produced, and so this computation is indeed one that, in a physical sense, generates no entropy. This issue is carefully discussed in Kitaev's article.</p>

<p>More generally, any function <em>f</em> (bijective or not) can be simulated by a circuit of Toffoli gates. Obviously, if the mapping fails to be <a class="uri" href="injective" title="wikilink">injective</a>, at some point in the simulation (for example as the last step) some "garbage" has to be produced.</p>

<p>For quantum circuits a similar composition of qubit gates can be defined. That is, associated to any <em>classical assemblage</em> as above, we can produce a reversible quantum circuit when in place of <em>f</em> we have an <em>n</em>-qubit gate <em>U</em> and in place of <em>g</em> we have an <em>m</em>-qubit gate <em>W</em>. See illustration below:</p>
<center>
<figure><b>(Figure)</b>
<figcaption>Quantum circuit composition.svg</figcaption>
</figure>
</center>

<p>The fact that connecting gates this way gives rise to a unitary mapping on <em>n</em>+<em>m</em>−<em>k</em> qubit space is easy to check. It should also be noted that in a real quantum computer the physical connection between the gates is a major engineering challenge, since it is one of the places where <a class="uri" href="decoherence" title="wikilink">decoherence</a> may occur.</p>

<p>There are also <a href="Quantum_gate#Universal_quantum_gates" title="wikilink">universality theorems</a> for certain sets of well-known gates; such a universality theorem exists, for instance, for the pair consisting of the single qubit phase gate <em>U</em><sub>θ</sub> mentioned above (for a suitable value of θ), together with the 2-qubit <a href="controlled_NOT_gate" title="wikilink">CNOT gate</a> <em>W</em><sub>CNOT</sub>. However, the universality theorem for the quantum case is somewhat weaker than the one for the classical case; it asserts only that any reversible <em>n</em>-qubit circuit can be <em>approximated</em> arbitrarily well by circuits assembled from these two elementary gates. Note that there are <a href="uncountable" title="wikilink">uncountably</a> many possible single qubit phase gates, one for every possible angle θ, so they cannot all be represented by a finite circuit constructed from {<em>U</em><sub>θ</sub>, <em>W</em><sub>CNOT</sub>)}.</p>
<h2 id="quantum-computations">Quantum computations</h2>

<p>So far we have not shown how quantum circuits are used to perform computations. Since many important numerical problems reduce to computing a unitary transformation <em>U</em> on a finite-dimensional space (the celebrated <a href="discrete_Fourier_transform" title="wikilink">discrete Fourier transform</a> being a prime example), one might expect that some quantum circuit could be designed to carry out the transformation <em>U</em>. In principle, one needs only to prepare an <em>n</em> qubit state ψ as an appropriate superposition of computational basis states for the input and measure the output <em>U</em>ψ. Unfortunately, there are two problems with this:</p>
<ul>
<li>One cannot measure the phase of ψ at any computational basis state so there is no way of reading out the complete answer. This is in the nature of <a href="measurement_in_quantum_mechanics" title="wikilink">measurement in quantum mechanics</a>.</li>
</ul>
<ul>
<li>There is no way to efficiently prepare the input state ψ.</li>
</ul>

<p>This does not prevent quantum circuits for the discrete Fourier transform from being used as intermediate steps in other quantum circuits, but the use is more subtle. In fact quantum computations are <em>probabilistic</em>.</p>

<p>We now provide a mathematical model for how quantum circuits can simulate <em>probabilistic</em> but classical computations. Consider an <em>r</em>-qubit circuit <em>U</em> with register space <em>H</em><sub>QB(<em>r</em>)</sub>. <em>U</em> is thus a unitary map</p>

<p>

<math display="block" id="Quantum_circuit:7">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>H</mi>
     <mrow>
      <mo>QB</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>r</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </msub>
    <mo>→</mo>
    <msub>
     <mi>H</mi>
     <mrow>
      <mo>QB</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>r</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </msub>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>H</ci>
     <apply>
      <ci>QB</ci>
      <ci>r</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>H</ci>
     <apply>
      <ci>QB</ci>
      <ci>r</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{\operatorname{QB}(r)}\rightarrow H_{\operatorname{QB}(r)}.
  </annotation>
 </semantics>
</math>

</p>

<p>In order to associate this circuit to a classical mapping on bitstrings, we specify</p>
<ul>
<li>An <em>input register</em> <em>X</em> = {0,1}<sup><em>m</em></sup> of <em>m</em> (classical) bits.</li>
</ul>
<ul>
<li>An <em>output register</em> <em>Y</em> = {0,1}<sup><em>n</em></sup> of <em>n</em> (classical) bits.</li>
</ul>

<p>The contents <em>x</em> = <em>x</em><sub>1</sub>, ..., <em>x</em><sub><em>m</em></sub> of the classical input register are used to initialize the qubit register in some way. Ideally, this would be done with the computational basis state</p>

<p>

<math display="block" id="Quantum_circuit:8">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo fence="true" stretchy="false">|</mo>
     <mrow>
      <mover accent="true">
       <mi>x</mi>
       <mo stretchy="false">→</mo>
      </mover>
      <mo>,</mo>
      <mn>0</mn>
     </mrow>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo fence="true" stretchy="false">|</mo>
     <mrow>
      <msub>
       <mi>x</mi>
       <mn>1</mn>
      </msub>
      <mo>,</mo>
      <msub>
       <mi>x</mi>
       <mn>2</mn>
      </msub>
      <mo>,</mo>
      <mi mathvariant="normal">⋯</mi>
      <mo>,</mo>
      <msub>
       <mi>x</mi>
       <mi>m</mi>
      </msub>
      <mo>,</mo>
      <munder accentunder="true">
       <mrow>
        <mn>0</mn>
        <mo>,</mo>
        <mi mathvariant="normal">…</mi>
        <mo>,</mo>
        <mn>0</mn>
       </mrow>
       <mo>⏟</mo>
      </munder>
     </mrow>
     <mo stretchy="false">⟩</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="latexml">ket</csymbol>
     <list>
      <apply>
       <ci>normal-→</ci>
       <ci>x</ci>
      </apply>
      <cn type="integer">0</cn>
     </list>
    </apply>
    <apply>
     <csymbol cd="latexml">ket</csymbol>
     <list>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-⋯</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>m</ci>
      </apply>
      <apply>
       <ci>normal-⏟</ci>
       <list>
        <cn type="integer">0</cn>
        <ci>normal-…</ci>
        <cn type="integer">0</cn>
       </list>
      </apply>
     </list>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\vec{x},0\rangle=|x_{1},x_{2},\cdots,x_{m},\underbrace{0,\dots,0}\rangle,
  </annotation>
 </semantics>
</math>

 where there are <em>r</em>-<em>m</em> underbraced zeroed inputs. Nevertheless, this perfect initialization is completely unrealistic. Let us assume therefore that the initialization is a mixed state given by some density operator <em>S</em> which is near the idealized input in some appropriate metric, e.g.</p>

<p>

<math display="block" id="Quantum_circuit:9">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>Tr</mo>
     <mrow>
      <mo>(</mo>
      <mrow>
       <mo mathsize="120%" stretchy="false">|</mo>
       <mrow>
        <mrow>
         <mrow>
          <mo fence="true" stretchy="false">|</mo>
          <mrow>
           <mover accent="true">
            <mi>x</mi>
            <mo stretchy="false">→</mo>
           </mover>
           <mo>,</mo>
           <mn>0</mn>
          </mrow>
          <mo stretchy="false">⟩</mo>
         </mrow>
         <mrow>
          <mo stretchy="false">⟨</mo>
          <mrow>
           <mover accent="true">
            <mi>x</mi>
            <mo stretchy="false">→</mo>
           </mover>
           <mo>,</mo>
           <mn>0</mn>
          </mrow>
          <mo fence="true" stretchy="false">|</mo>
         </mrow>
        </mrow>
        <mo>-</mo>
        <mi>S</mi>
       </mrow>
       <mo mathsize="120%" stretchy="false">|</mo>
      </mrow>
      <mo>)</mo>
     </mrow>
    </mrow>
    <mo>≤</mo>
    <mi>δ</mi>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <ci>Tr</ci>
     <apply>
      <abs></abs>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="latexml">ket</csymbol>
         <list>
          <apply>
           <ci>normal-→</ci>
           <ci>x</ci>
          </apply>
          <cn type="integer">0</cn>
         </list>
        </apply>
        <apply>
         <csymbol cd="latexml">bra</csymbol>
         <list>
          <apply>
           <ci>normal-→</ci>
           <ci>x</ci>
          </apply>
          <cn type="integer">0</cn>
         </list>
        </apply>
       </apply>
       <ci>S</ci>
      </apply>
     </apply>
    </apply>
    <ci>δ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{Tr}\left(\big||\vec{x},0\rangle\langle\vec{x},0|-S\big|\right)%
\leq\delta.
  </annotation>
 </semantics>
</math>

</p>

<p>Similarly, the output register space is related to the qubit register, by a <em>Y</em> valued observable <em>A</em>. Note that observables in quantum mechanics are usually defined in terms of <em>projection valued measures</em> on <strong>R</strong>; if the variable happens to be discrete, the projection valued measure reduces to a family {E<sub>λ</sub>} indexed on some parameter λ ranging over a countable set. Similarly, a <em>Y</em> valued observable, can be associated with a family of pairwise orthogonal projections {E<sub><em>y</em></sub>} indexed by elements of <em>Y</em>. such that</p>

<p>

<math display="block" id="Quantum_circuit:10">
 <semantics>
  <mrow>
   <mrow>
    <mi>I</mi>
    <mo>=</mo>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>y</mi>
       <mo>∈</mo>
       <mi>Y</mi>
      </mrow>
     </munder>
     <msub>
      <mo>E</mo>
      <mi>y</mi>
     </msub>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>I</ci>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <in></in>
       <ci>y</ci>
       <ci>Y</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-E</ci>
      <ci>y</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I=\sum_{y\in Y}\operatorname{E}_{y}.
  </annotation>
 </semantics>
</math>

</p>

<p>Given a mixed state <em>S</em>, there corresponds a probability measure on <em>Y</em> given by</p>

<p>

<math display="block" id="Quantum_circuit:11">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>Pr</mo>
     <mrow>
      <mo stretchy="false">{</mo>
      <mi>y</mi>
      <mo stretchy="false">}</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo>Tr</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>S</mi>
       <msub>
        <mo>E</mo>
        <mi>y</mi>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>Pr</ci>
     <ci>y</ci>
    </apply>
    <apply>
     <ci>Tr</ci>
     <apply>
      <times></times>
      <ci>S</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>normal-E</ci>
       <ci>y</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{Pr}\{y\}=\operatorname{Tr}(S\operatorname{E}_{y}).
  </annotation>
 </semantics>
</math>

</p>

<p>The function <em>F</em>:<em>X</em> → <em>Y</em> is computed by a circuit <em>U</em>:<em>H</em><sub>QB(<em>r</em>)</sub> → <em>H</em><sub>QB(<em>r</em>)</sub> to within ε if and only if for all bitstrings <em>x</em> of length <em>m</em></p>

<p>

<math display="block" id="Quantum_circuit:12">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>⟨</mo>
     <mover accent="true">
      <mi>x</mi>
      <mo stretchy="false">→</mo>
     </mover>
     <mo>,</mo>
     <mn>0</mn>
     <mo mathsize="120%" stretchy="false">|</mo>
     <msup>
      <mi>U</mi>
      <mo>*</mo>
     </msup>
     <msub>
      <mo>E</mo>
      <mrow>
       <mi>F</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </msub>
     <mi>U</mi>
     <mo mathsize="120%" stretchy="false">|</mo>
     <mover accent="true">
      <mi>x</mi>
      <mo stretchy="false">→</mo>
     </mover>
     <mo>,</mo>
     <mn>0</mn>
     <mo>⟩</mo>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo>⟨</mo>
     <msub>
      <mo>E</mo>
      <mrow>
       <mi>F</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </msub>
     <mi>U</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mo stretchy="false">|</mo>
      <mover accent="true">
       <mi>x</mi>
       <mo stretchy="false">→</mo>
      </mover>
      <mo>,</mo>
      <mn>0</mn>
      <mo stretchy="false">⟩</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo mathsize="120%" stretchy="false">|</mo>
    <mi>U</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mo stretchy="false">|</mo>
     <mover accent="true">
      <mi>x</mi>
      <mo stretchy="false">→</mo>
     </mover>
     <mo>,</mo>
     <mn>0</mn>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>⟩</mo>
   <mo>≥</mo>
   <mn>1</mn>
   <mo>-</mo>
   <mi>ϵ</mi>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-⟨</ci>
      <apply>
       <ci>normal-→</ci>
       <ci>x</ci>
      </apply>
      <ci>normal-,</ci>
      <cn type="integer">0</cn>
      <ci>normal-|</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>U</ci>
       <times></times>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>normal-E</ci>
       <apply>
        <times></times>
        <ci>F</ci>
        <ci>x</ci>
       </apply>
      </apply>
      <csymbol cd="unknown">U</csymbol>
      <ci>normal-|</ci>
      <apply>
       <ci>normal-→</ci>
       <ci>x</ci>
      </apply>
      <ci>normal-,</ci>
      <cn type="integer">0</cn>
      <ci>normal-⟩</ci>
     </cerror>
     <eq></eq>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-⟨</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>normal-E</ci>
       <apply>
        <times></times>
        <ci>F</ci>
        <ci>x</ci>
       </apply>
      </apply>
      <csymbol cd="unknown">U</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <ci>normal-|</ci>
       <apply>
        <ci>normal-→</ci>
        <ci>x</ci>
       </apply>
       <ci>normal-,</ci>
       <cn type="integer">0</cn>
       <ci>normal-⟩</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-|</ci>
     <csymbol cd="unknown">U</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <ci>normal-|</ci>
      <apply>
       <ci>normal-→</ci>
       <ci>x</ci>
      </apply>
      <ci>normal-,</ci>
      <cn type="integer">0</cn>
      <ci>normal-⟩</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-⟩</ci>
    <geq></geq>
    <cn type="integer">1</cn>
    <minus></minus>
    <csymbol cd="unknown">ϵ</csymbol>
    <ci>normal-.</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left\langle\vec{x},0\big|U^{*}\operatorname{E}_{F(x)}U\big|\vec{x},0\right%
\rangle=\left\langle\operatorname{E}_{F(x)}U(|\vec{x},0\rangle)\big|U(|\vec{x}%
,0\rangle)\right\rangle\geq 1-\epsilon.
  </annotation>
 </semantics>
</math>

</p>

<p>Now</p>

<p>

<math display="block" id="Quantum_circuit:13">
 <semantics>
  <mrow>
   <mrow>
    <mo>|</mo>
    <mrow>
     <mrow>
      <mo>Tr</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>S</mi>
        <msup>
         <mi>U</mi>
         <mo>*</mo>
        </msup>
        <mrow>
         <msub>
          <mo>E</mo>
          <mrow>
           <mi>F</mi>
           <mrow>
            <mo stretchy="false">(</mo>
            <mi>x</mi>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
         </msub>
         <mi>U</mi>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>-</mo>
     <mrow>
      <mo>⟨</mo>
      <mrow>
       <mover accent="true">
        <mi>x</mi>
        <mo stretchy="false">→</mo>
       </mover>
       <mo>,</mo>
       <mn>0</mn>
      </mrow>
      <mo fence="true" maxsize="120%" minsize="120%">|</mo>
      <mrow>
       <msup>
        <mi>U</mi>
        <mo>*</mo>
       </msup>
       <mrow>
        <msub>
         <mo>E</mo>
         <mrow>
          <mi>F</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>x</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
        </msub>
        <mi>U</mi>
       </mrow>
      </mrow>
      <mo fence="true" maxsize="120%" minsize="120%">|</mo>
      <mrow>
       <mover accent="true">
        <mi>x</mi>
        <mo stretchy="false">→</mo>
       </mover>
       <mo>,</mo>
       <mn>0</mn>
      </mrow>
      <mo>⟩</mo>
     </mrow>
    </mrow>
    <mo>|</mo>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mrow>
     <mo>Tr</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mo mathsize="120%" stretchy="false">|</mo>
       <mrow>
        <mrow>
         <mrow>
          <mo fence="true" stretchy="false">|</mo>
          <mrow>
           <mover accent="true">
            <mi>x</mi>
            <mo stretchy="false">→</mo>
           </mover>
           <mo>,</mo>
           <mn>0</mn>
          </mrow>
          <mo stretchy="false">⟩</mo>
         </mrow>
         <mrow>
          <mo stretchy="false">⟨</mo>
          <mrow>
           <mover accent="true">
            <mi>x</mi>
            <mo stretchy="false">→</mo>
           </mover>
           <mo>,</mo>
           <mn>0</mn>
          </mrow>
          <mo fence="true" stretchy="false">|</mo>
         </mrow>
        </mrow>
        <mo>-</mo>
        <mi>S</mi>
       </mrow>
       <mo mathsize="120%" stretchy="false">|</mo>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mrow>
     <mo>∥</mo>
     <mrow>
      <msup>
       <mi>U</mi>
       <mo>*</mo>
      </msup>
      <mrow>
       <msub>
        <mo>E</mo>
        <mrow>
         <mi>F</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>x</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </msub>
       <mi>U</mi>
      </mrow>
     </mrow>
     <mo>∥</mo>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mi>δ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <apply>
      <abs></abs>
      <apply>
       <minus></minus>
       <apply>
        <ci>Tr</ci>
        <apply>
         <times></times>
         <ci>S</ci>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>U</ci>
          <times></times>
         </apply>
         <apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>normal-E</ci>
           <apply>
            <times></times>
            <ci>F</ci>
            <ci>x</ci>
           </apply>
          </apply>
          <ci>U</ci>
         </apply>
        </apply>
       </apply>
       <apply>
        <csymbol cd="latexml">quantum-operator-product</csymbol>
        <list>
         <apply>
          <ci>normal-→</ci>
          <ci>x</ci>
         </apply>
         <cn type="integer">0</cn>
        </list>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>U</ci>
          <times></times>
         </apply>
         <apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>normal-E</ci>
           <apply>
            <times></times>
            <ci>F</ci>
            <ci>x</ci>
           </apply>
          </apply>
          <ci>U</ci>
         </apply>
        </apply>
        <list>
         <apply>
          <ci>normal-→</ci>
          <ci>x</ci>
         </apply>
         <cn type="integer">0</cn>
        </list>
       </apply>
      </apply>
     </apply>
     <apply>
      <apply>
       <ci>Tr</ci>
       <apply>
        <abs></abs>
        <apply>
         <minus></minus>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="latexml">ket</csymbol>
           <list>
            <apply>
             <ci>normal-→</ci>
             <ci>x</ci>
            </apply>
            <cn type="integer">0</cn>
           </list>
          </apply>
          <apply>
           <csymbol cd="latexml">bra</csymbol>
           <list>
            <apply>
             <ci>normal-→</ci>
             <ci>x</ci>
            </apply>
            <cn type="integer">0</cn>
           </list>
          </apply>
         </apply>
         <ci>S</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="latexml">norm</csymbol>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>U</ci>
         <times></times>
        </apply>
        <apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>normal-E</ci>
          <apply>
           <times></times>
           <ci>F</ci>
           <ci>x</ci>
          </apply>
         </apply>
         <ci>U</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <ci>δ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left|\operatorname{Tr}(SU^{*}\operatorname{E}_{F(x)}U)-\left\langle\vec{x},0%
\big|U^{*}\operatorname{E}_{F(x)}U\big|\vec{x},0\right\rangle\right|\leq%
\operatorname{Tr}(\big||\vec{x},0\rangle\langle\vec{x},0|-S\big|)\|U^{*}%
\operatorname{E}_{F(x)}U\|\leq\delta
  </annotation>
 </semantics>
</math>

 so that</p>

<p>

<math display="block" id="Quantum_circuit:14">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>Tr</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>S</mi>
       <msup>
        <mi>U</mi>
        <mo>*</mo>
       </msup>
       <mrow>
        <msub>
         <mo>E</mo>
         <mrow>
          <mi>F</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>x</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
        </msub>
        <mi>U</mi>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>≥</mo>
    <mrow>
     <mn>1</mn>
     <mo>-</mo>
     <mi>ϵ</mi>
     <mo>-</mo>
     <mi>δ</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <ci>Tr</ci>
     <apply>
      <times></times>
      <ci>S</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>U</ci>
       <times></times>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>normal-E</ci>
        <apply>
         <times></times>
         <ci>F</ci>
         <ci>x</ci>
        </apply>
       </apply>
       <ci>U</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
     <ci>ϵ</ci>
     <ci>δ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{Tr}(SU^{*}\operatorname{E}_{F(x)}U)\geq 1-\epsilon-\delta.
  </annotation>
 </semantics>
</math>

</p>

<p><strong>Theorem</strong>. If ε+ δ  \operatorname{Pr}\{y\} = \operatorname{Tr} (S U^* \operatorname{E}_{y} U) on <em>Y</em> can be used to determine <em>F</em>(<em>x</em>) with an arbitrarily small probability of error by majority sampling, for a sufficiently large sample size. Specifically, take <em>k</em> independent samples from the probability distribution Pr on <em>Y</em> and choose a value on which more than half of the samples agree. The probability that the value <em>F</em>(<em>x</em>) is sampled more than <em>k</em>/2 times is at least</p>

<p>

<math display="block" id="Quantum_circuit:15">
 <semantics>
  <mrow>
   <mrow>
    <mn>1</mn>
    <mo>-</mo>
    <msup>
     <mi>e</mi>
     <mrow>
      <mo>-</mo>
      <mrow>
       <mn>2</mn>
       <msup>
        <mi>γ</mi>
        <mn>2</mn>
       </msup>
       <mi>k</mi>
      </mrow>
     </mrow>
    </msup>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <cn type="integer">1</cn>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>e</ci>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>γ</ci>
        <cn type="integer">2</cn>
       </apply>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1-e^{-2\gamma^{2}k},
  </annotation>
 </semantics>
</math>

 where γ = 1/2 -ε - δ.</p>

<p>This follows by applying the <a href="Chernoff_bound" title="wikilink">Chernoff bound</a>.</p>
<h2 id="references">References</h2>
<ul>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.cquic.org/Qcircuit/">Q-circuit</a> is a macro package for drawing quantum circuit diagrams in LaTeX.</li>
<li><a href="http://www.davyw.com/quantum">Quantum Circuit Simulator</a> a browser-based quantum circuit diagram editor and simulator.</li>
</ul>

<p>"</p>

<p><a href="Category:Quantum_information_science" title="wikilink">Category:Quantum information science</a> <a href="Category:Models_of_computation" title="wikilink">Category:Models of computation</a></p>
</body>
</html>
