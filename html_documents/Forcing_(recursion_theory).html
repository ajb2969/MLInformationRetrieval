<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="133">Forcing (recursion theory)</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Forcing (recursion theory)</h1>
<hr>'''Forcing''' in [[recursion theory]] is a modification of [[Paul Cohen (mathematician)|Paul Cohen's]] original [[set theory|set theoretic]] technique of [[forcing 
<p>(set theory)|forcing]] to deal with the effective concerns in <a href="recursion_theory" title="wikilink">recursion theory</a>. Conceptually the two techniques are quite similar, in both one attempts to build <a href="generic_set" title="wikilink">generic</a> objects (intuitively objects that are somehow 'typical') by meeting dense sets. Also both techniques are elegantly described as a relation (customarily denoted 

<math display="inline" id="Forcing_(recursion_theory):0">
 <semantics>
  <mo>⊩</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">forces</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Vdash
  </annotation>
 </semantics>
</math>

) between 'conditions' and sentences. However, where set theoretic forcing is usually interested in creating objects that meet every dense set of conditions in the ground model, recursion theoretic forcing only aims to meet dense sets that are arithmetically or hyperarithmetically definable. Therefore some of the more difficult machinery used in set theoretic forcing can be eliminated or substantially simplified when defining forcing in recursion theory. But while the machinery may be somewhat different recursion theoretic and set theoretic forcing are properly regarded as an application of the same technique to different classes of formulas.</p>
<h2 id="terminology">Terminology</h2>

<p>In this article we use the following terminology.</p>
<dl>
<dt>real: an element of 

<math display="inline" id="Forcing_(recursion_theory):1">
 <semantics>
  <msup>
   <mn>2</mn>
   <mi>ω</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <ci>ω</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{\omega}
  </annotation>
 </semantics>
</math>

. In other words a function that maps each integer to either 0 or 1.<br/>
string: an element of 

<math display="inline" id="Forcing_(recursion_theory):2">
 <semantics>
  <msup>
   <mn>2</mn>
   <mrow>
    <mi></mi>
    <mo><</mo>
    <mi>ω</mi>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <apply>
     <lt></lt>
     <csymbol cd="latexml">absent</csymbol>
     <ci>ω</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{<\omega}
  </annotation>
 </semantics>
</math>

. In other words a finite approximation to a real.</dt>
</dl>
<dl>
<dt>notion of forcing : A notion of forcing is a set 

<math display="inline" id="Forcing_(recursion_theory):3">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 and a <a href="partial_order" title="wikilink">partial order</a> on 

<math display="inline" id="Forcing_(recursion_theory):4">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Forcing_(recursion_theory):5">
 <semantics>
  <msub>
   <mo>≻</mo>
   <mi>P</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <csymbol cd="latexml">succeeds</csymbol>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \succ_{P}
  </annotation>
 </semantics>
</math>

 with a <em>greatest element</em> 

<math display="inline" id="Forcing_(recursion_theory):6">
 <semantics>
  <msub>
   <mn>0</mn>
   <mi>P</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <cn type="integer">0</cn>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0_{P}
  </annotation>
 </semantics>
</math>

.</dt>
</dl>
<dl>
<dt>condition: An element in a notion of forcing. We say a condition 

<math display="inline" id="Forcing_(recursion_theory):7">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 is stronger than a condition 

<math display="inline" id="Forcing_(recursion_theory):8">
 <semantics>
  <mi>q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q
  </annotation>
 </semantics>
</math>

 just when 

<math display="inline" id="Forcing_(recursion_theory):9">
 <semantics>
  <mrow>
   <mi>q</mi>
   <msub>
    <mo>≻</mo>
    <mi>P</mi>
   </msub>
   <mi>p</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">succeeds</csymbol>
     <ci>P</ci>
    </apply>
    <ci>q</ci>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q\succ_{P}p
  </annotation>
 </semantics>
</math>

.</dt>
</dl>
<dl>
<dt>

<math display="inline" id="Forcing_(recursion_theory):10">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mo>∣</mo>
   <mi>q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <ci>normal-∣</ci>
    <csymbol cd="unknown">q</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\mid q
  </annotation>
 </semantics>
</math>

: Given conditions 

<math display="inline" id="Forcing_(recursion_theory):11">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mo>,</mo>
   <mi>q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>p</ci>
    <ci>q</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p,q
  </annotation>
 </semantics>
</math>

 say that 

<math display="inline" id="Forcing_(recursion_theory):12">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Forcing_(recursion_theory):13">
 <semantics>
  <mi>q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q
  </annotation>
 </semantics>
</math>

 are incompatible if there is no condition 

<math display="inline" id="Forcing_(recursion_theory):14">
 <semantics>
  <mi>r</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>r</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r
  </annotation>
 </semantics>
</math>

 with 

<math display="inline" id="Forcing_(recursion_theory):15">
 <semantics>
  <mrow>
   <mi>p</mi>
   <msub>
    <mo>≻</mo>
    <mi>P</mi>
   </msub>
   <mi>r</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">succeeds</csymbol>
     <ci>P</ci>
    </apply>
    <ci>p</ci>
    <ci>r</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\succ_{P}r
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Forcing_(recursion_theory):16">
 <semantics>
  <mrow>
   <mi>q</mi>
   <msub>
    <mo>≻</mo>
    <mi>P</mi>
   </msub>
   <mi>r</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">succeeds</csymbol>
     <ci>P</ci>
    </apply>
    <ci>q</ci>
    <ci>r</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q\succ_{P}r
  </annotation>
 </semantics>
</math>

. 

<math display="inline" id="Forcing_(recursion_theory):17">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 is compatible with 

<math display="inline" id="Forcing_(recursion_theory):18">
 <semantics>
  <mi>q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q
  </annotation>
 </semantics>
</math>

 if they are not incompatible.</dt>
</dl>
<dl>
<dt>Filter : A subset 

<math display="inline" id="Forcing_(recursion_theory):19">
 <semantics>
  <mi>F</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>F</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F
  </annotation>
 </semantics>
</math>

 of a notion of forcing 

<math display="inline" id="Forcing_(recursion_theory):20">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 is a filter if 

<math display="inline" id="Forcing_(recursion_theory):21">
 <semantics>
  <mrow>
   <mrow>
    <mi>p</mi>
    <mo>,</mo>
    <mi>q</mi>
   </mrow>
   <mo>∈</mo>
   <mi>F</mi>
   <mo>⟹</mo>
   <mi>p</mi>
   <mo>∤</mo>
   <mi>q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <in></in>
     <list>
      <ci>p</ci>
      <ci>q</ci>
     </list>
     <ci>F</ci>
    </apply>
    <apply>
     <implies></implies>
     <share href="#.cmml">
     </share>
     <ci>p</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">not-divides</csymbol>
     <share href="#.cmml">
     </share>
     <ci>q</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p,q\in F\implies p\nmid q
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Forcing_(recursion_theory):22">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mo>∈</mo>
   <mrow>
    <mi>F</mi>
    <mo>∧</mo>
    <mi>q</mi>
   </mrow>
   <msub>
    <mo>≻</mo>
    <mi>P</mi>
   </msub>
   <mi>p</mi>
   <mo>⟹</mo>
   <mi>q</mi>
   <mo>∈</mo>
   <mi>F</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <in></in>
     <ci>p</ci>
     <apply>
      <and></and>
      <ci>F</ci>
      <ci>q</ci>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">succeeds</csymbol>
      <ci>P</ci>
     </apply>
     <share href="#.cmml">
     </share>
     <ci>p</ci>
    </apply>
    <apply>
     <implies></implies>
     <share href="#.cmml">
     </share>
     <ci>q</ci>
    </apply>
    <apply>
     <in></in>
     <share href="#.cmml">
     </share>
     <ci>F</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\in F\land q\succ_{P}p\implies q\in F
  </annotation>
 </semantics>
</math>

. In other words a filter is a compatible set of conditions closed under weakening of conditions.</dt>
</dl>
<dl>
<dt>Ultrafilter : A maximal filter, i.e., 

<math display="inline" id="Forcing_(recursion_theory):23">
 <semantics>
  <mi>F</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>F</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F
  </annotation>
 </semantics>
</math>

 is an ultrafilter if 

<math display="inline" id="Forcing_(recursion_theory):24">
 <semantics>
  <mi>F</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>F</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F
  </annotation>
 </semantics>
</math>

 is a filter and there is no filter 

<math display="inline" id="Forcing_(recursion_theory):25">
 <semantics>
  <msup>
   <mi>F</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>F</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F^{\prime}
  </annotation>
 </semantics>
</math>

 properly containing 

<math display="inline" id="Forcing_(recursion_theory):26">
 <semantics>
  <mi>F</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>F</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F
  </annotation>
 </semantics>
</math>

</dt>
</dl>
<dl>
<dt>Cohen forcing: The notion of forcing 

<math display="inline" id="Forcing_(recursion_theory):27">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

 where conditions are elements of 

<math display="inline" id="Forcing_(recursion_theory):28">
 <semantics>
  <msup>
   <mn>2</mn>
   <mrow>
    <mi></mi>
    <mo><</mo>
    <mi>ω</mi>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <apply>
     <lt></lt>
     <csymbol cd="latexml">absent</csymbol>
     <ci>ω</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{<\omega}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Forcing_(recursion_theory):29">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>τ</mi>
   <msub>
    <mo>≻</mo>
    <mi>C</mi>
   </msub>
   <mi>σ</mi>
   <mo>⇔</mo>
   <mi>σ</mi>
   <mo>⊃</mo>
   <mi>τ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-(</ci>
    <csymbol cd="unknown">τ</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">succeeds</csymbol>
     <ci>C</ci>
    </apply>
    <csymbol cd="unknown">σ</csymbol>
    <csymbol cd="latexml">iff</csymbol>
    <csymbol cd="unknown">σ</csymbol>
    <csymbol cd="latexml">superset-of</csymbol>
    <csymbol cd="unknown">τ</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\tau\succ_{C}\sigma\iff\sigma\supset\tau
  </annotation>
 </semantics>
</math>

)</dt>
</dl>

<p>Note that for Cohen forcing 

<math display="inline" id="Forcing_(recursion_theory):30">
 <semantics>
  <msub>
   <mo>≻</mo>
   <mi>C</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <csymbol cd="latexml">succeeds</csymbol>
    <ci>C</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \succ_{C}
  </annotation>
 </semantics>
</math>

 is the <strong>reverse</strong> of the containment relation. This leads to an unfortunate notational confusion where some recursion theorists reverse the direction of the forcing partial order (exchanging 

<math display="inline" id="Forcing_(recursion_theory):31">
 <semantics>
  <msub>
   <mo>≻</mo>
   <mi>P</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <csymbol cd="latexml">succeeds</csymbol>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \succ_{P}
  </annotation>
 </semantics>
</math>

 with 

<math display="inline" id="Forcing_(recursion_theory):32">
 <semantics>
  <msub>
   <mo>≺</mo>
   <mi>P</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <csymbol cd="latexml">precedes</csymbol>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \prec_{P}
  </annotation>
 </semantics>
</math>

 which is more natural for Cohen forcing but is at odds with the notation used in set theory.</p>
<h2 id="generic-objects">Generic objects</h2>

<p>The intuition behind forcing is that our conditions are finite approximations to some object we wish to build and that 

<math display="inline" id="Forcing_(recursion_theory):33">
 <semantics>
  <mi>σ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma
  </annotation>
 </semantics>
</math>

 is stronger than 

<math display="inline" id="Forcing_(recursion_theory):34">
 <semantics>
  <mi>τ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>τ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau
  </annotation>
 </semantics>
</math>

 when 

<math display="inline" id="Forcing_(recursion_theory):35">
 <semantics>
  <mi>σ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma
  </annotation>
 </semantics>
</math>

 agrees with everything 

<math display="inline" id="Forcing_(recursion_theory):36">
 <semantics>
  <mi>τ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>τ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau
  </annotation>
 </semantics>
</math>

 says about the object we are building and adds some information of its own. For instance in Cohen forcing the conditions can be viewed as finite approximations to a real and if 

<math display="inline" id="Forcing_(recursion_theory):37">
 <semantics>
  <mrow>
   <mi>τ</mi>
   <msub>
    <mo>≻</mo>
    <mi>C</mi>
   </msub>
   <mi>σ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">succeeds</csymbol>
     <ci>C</ci>
    </apply>
    <ci>τ</ci>
    <ci>σ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau\succ_{C}\sigma
  </annotation>
 </semantics>
</math>

 then 

<math display="inline" id="Forcing_(recursion_theory):38">
 <semantics>
  <mi>σ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma
  </annotation>
 </semantics>
</math>

 tells us the value of the real on more places.</p>

<p>In a moment we will define a relation 

<math display="inline" id="Forcing_(recursion_theory):39">
 <semantics>
  <mrow>
   <mi>σ</mi>
   <msub>
    <mo>⊩</mo>
    <mi>P</mi>
   </msub>
   <mi>ψ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">forces</csymbol>
     <ci>P</ci>
    </apply>
    <ci>σ</ci>
    <ci>ψ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma\Vdash_{P}\psi
  </annotation>
 </semantics>
</math>

 (read 

<math display="inline" id="Forcing_(recursion_theory):40">
 <semantics>
  <mi>σ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma
  </annotation>
 </semantics>
</math>

 forces 

<math display="inline" id="Forcing_(recursion_theory):41">
 <semantics>
  <mi>ψ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ψ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \psi
  </annotation>
 </semantics>
</math>

) that holds between conditions (elements of 

<math display="inline" id="Forcing_(recursion_theory):42">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

) and sentences but first we need to explain the <a href="language_(mathematics)" title="wikilink">language (mathematics)</a> that 

<math display="inline" id="Forcing_(recursion_theory):43">
 <semantics>
  <mi>ψ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ψ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \psi
  </annotation>
 </semantics>
</math>

 is a sentence for. However, forcing is a technique not a definition and the language for 

<math display="inline" id="Forcing_(recursion_theory):44">
 <semantics>
  <mi>ψ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ψ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \psi
  </annotation>
 </semantics>
</math>

 will depend on the application one has in mind and the choice of 

<math display="inline" id="Forcing_(recursion_theory):45">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

.</p>

<p>The idea is that our language should express facts about the object we wish to build with our forcing construction.</p>
<h2 id="references">References</h2>
<ul>
<li>Melvin Fitting (1981), <em>Fundamentals of generalized recursion theory</em>.</li>
<li>Piergiorgio Odifreddi (1999), <em>Classical Recursion Theory</em>, v. 2.</li>
</ul>

<p>"</p>

<p><a href="Category:Computability_theory" title="wikilink">Category:Computability theory</a></p>
</hr></body>
</html>
