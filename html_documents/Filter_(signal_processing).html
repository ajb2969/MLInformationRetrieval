<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="706">Filter (signal processing)</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Filter (signal processing)</h1>
<hr/>

<p>In <a href="signal_processing" title="wikilink">signal processing</a>, a <strong>filter</strong> is a device or process that removes from a <a href="Signal_(electronics)" title="wikilink">signal</a> some unwanted component or feature. Filtering is a class of signal processing, the defining feature of filters being the complete or partial suppression of some aspect of the signal. Most often, this means removing some <a href="frequency" title="wikilink">frequencies</a> and not others in order to suppress interfering signals and reduce background <a href="signal_noise" title="wikilink">noise</a>. However, filters do not exclusively act in the <a href="frequency_domain" title="wikilink">frequency domain</a>; especially in the field of <a href="image_processing" title="wikilink">image processing</a> many other targets for filtering exist. Correlations can be removed for certain frequency components and not for others <a href="scaled_correlation" title="wikilink"> without having to act in the frequency domain</a>.</p>

<p>There are many different bases of classifying filters and these overlap in many different ways; there is no simple hierarchical classification. Filters may be:</p>
<ul>
<li><a href="linear_filter" title="wikilink">linear</a> or <a href="non-linear_filter" title="wikilink">non-linear</a></li>
<li><a href="Time-invariant_system" title="wikilink">time-invariant</a> or <a href="Time-variant_system" title="wikilink">time-variant</a>, also known as shift invariance. If the filter operates in a spatial domain then the characterization is space invariance.</li>
<li>causal or not-causal: depending if present output depends or not on "future" input; of course, for time related signals processed in real-time all the filters are causal; it is not necessarily so for filters acting on space-related signals or for deferred-time processing of time-related signals.</li>
<li><a href="analogue_filter" title="wikilink">analog</a> or <a href="digital_filter" title="wikilink">digital</a></li>
<li><a class="uri" href="discrete-time" title="wikilink">discrete-time</a> (sampled) or <a href="continuous_signal" title="wikilink">continuous-time</a></li>
<li><a href="passive_component" title="wikilink">passive</a> or <a href="active_filter" title="wikilink">active</a> type of continuous-time filter</li>
<li><a href="infinite_impulse_response" title="wikilink">infinite impulse response</a> (IIR) or <a href="finite_impulse_response" title="wikilink">finite impulse response</a> (FIR) type of discrete-time or digital filter.</li>
</ul>
<h2 id="linear-continuous-time-filters">Linear continuous-time filters</h2>

<p>Linear continuous-time circuit is perhaps the most common meaning for filter in the signal processing world, and simply "filter" is often taken to be synonymous. These circuits are generally <a href="filter_design" title="wikilink">designed</a> to remove certain <a href="frequency" title="wikilink">frequencies</a> and allow others to pass. Circuits that perform this function are generally <a href="linear_filter" title="wikilink">linear</a> in their response, or at least approximately so. Any nonlinearity would potentially result in the output signal containing frequency components not present in the input signal.</p>

<p>The modern design methodology for linear continuous-time filters is called <a href="network_synthesis_filters" title="wikilink">network synthesis</a>. Some important filter families designed in this way are:</p>
<ul>
<li><a href="Chebyshev_filter" title="wikilink">Chebyshev filter</a>, has the best approximation to the ideal response of any filter for a specified order and ripple.</li>
<li><a href="Butterworth_filter" title="wikilink">Butterworth filter</a>, has a maximally flat frequency response.</li>
<li><a href="Bessel_filter" title="wikilink">Bessel filter</a>, has a maximally flat <a href="phase_delay" title="wikilink">phase delay</a>.</li>
<li><a href="Elliptic_filter" title="wikilink">Elliptic filter</a>, has the steepest cutoff of any filter for a specified order and ripple.</li>
</ul>

<p>The difference between these filter families is that they all use a different <a href="polynomial_function" title="wikilink">polynomial function</a> to approximate to the <a href="ideal_filter" title="wikilink">ideal filter</a> response. This results in each having a different <a href="transfer_function" title="wikilink">transfer function</a>.</p>

<p>Another older, less-used methodology is the <a href="composite_image_filter" title="wikilink">image parameter method</a>. Filters designed by this methodology are archaically called "wave filters". Some important filters designed by this method are:</p>
<ul>
<li><a href="Constant_k_filter" title="wikilink">Constant k filter</a>, the original and simplest form of wave filter.</li>
<li><a href="m-derived_filter" title="wikilink">m-derived filter</a>, a modification of the constant k with improved cutoff steepness and <a href="impedance_matching" title="wikilink">impedance matching</a>.</li>
</ul>
<h3 id="terminology">Terminology</h3>

<p>Some terms used to describe and classify linear filters: </p>
<ul>
<li>The frequency response can be classified into a number of different bandforms describing which frequency <a href="Band_(radio)" title="wikilink">bands</a> the filter passes (the <a class="uri" href="passband" title="wikilink">passband</a>) and which it rejects (the <a class="uri" href="stopband" title="wikilink">stopband</a>):
<ul>
<li><a href="Low-pass_filter" title="wikilink">Low-pass filter</a> – low frequencies are passed, high frequencies are attenuated.</li>
<li><a href="High-pass_filter" title="wikilink">High-pass filter</a> – high frequencies are passed, low frequencies are attenuated.</li>
<li><a href="Band-pass_filter" title="wikilink">Band-pass filter</a> – only frequencies in a frequency band are passed.</li>
<li><a href="Band-stop_filter" title="wikilink">Band-stop filter</a> or band-reject filter – only frequencies in a frequency band are attenuated.</li>
<li><a href="Notch_filter" title="wikilink">Notch filter</a> – rejects just one specific frequency - an extreme band-stop filter.</li>
<li><a href="Comb_filter" title="wikilink">Comb filter</a> – has multiple regularly spaced narrow passbands giving the bandform the appearance of a comb.</li>
<li><a href="All-pass_filter" title="wikilink">All-pass filter</a> – all frequencies are passed, but the phase of the output is modified.</li>
</ul></li>
</ul>
<ul>
<li><a href="Cutoff_frequency" title="wikilink">Cutoff frequency</a> is the frequency beyond which the filter will not pass signals. It is usually measured at a specific attenuation such as 3dB.</li>
<li><a class="uri" href="Roll-off" title="wikilink">Roll-off</a> is the rate at which attenuation increases beyond the cut-off frequency.</li>
<li><a href="Transition_band" title="wikilink">Transition band</a>, the (usually narrow) band of frequencies between a passband and stopband.</li>
<li><a href="Ripple_(electrical)#Frequency_domain" title="wikilink">Ripple</a> is the variation of the filter's <a href="insertion_loss" title="wikilink">insertion loss</a> in the passband.</li>
<li>The order of a filter is the <a href="degree_of_a_polynomial" title="wikilink">degree of the approximating polynomial</a> and in passive filters corresponds to the number of elements required to build it. Increasing order increases roll-off and brings the filter closer to the ideal response.</li>
</ul>

<p>One important application of filters is in <a class="uri" href="telecommunication" title="wikilink">telecommunication</a>. Many telecommunication systems use <a href="frequency-division_multiplexing" title="wikilink">frequency-division multiplexing</a>, where the system designers divide a wide frequency band into many narrower frequency bands called "slots" or "channels", and each stream of information is allocated one of those channels. The people who design the filters at each transmitter and each receiver try to balance passing the desired signal through as accurately as possible, keeping interference to and from other cooperating transmitters and noise sources outside the system as low as possible, at reasonable cost.</p>

<p><a href="amplitude-shift_keying" title="wikilink"> Multilevel</a> and <a href="phase-shift_keying" title="wikilink"> multiphase</a> <a href="digital_modulation" title="wikilink">digital modulation</a> systems require filters that have flat phase delay -- are linear phase in the passband -- to preserve pulse integrity in the time domain,<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> giving less <a href="intersymbol_interference" title="wikilink">intersymbol interference</a> than other kinds of filters.</p>

<p>On the other hand, <a href="analog_audio" title="wikilink">analog audio</a> systems using <a href="analog_transmission" title="wikilink">analog transmission</a> can tolerate much larger ripples in <a href="phase_delay" title="wikilink">phase delay</a>, and so designers of such systems often deliberately sacrifice linear phase to get filters that are better in other ways -- better stop-band rejection, lower passband amplitude ripple, lower cost, etc.</p>
<h2 id="technologies">Technologies</h2>

<p>Filters can be built in a number of different technologies. The same transfer function can be realised in several different ways, that is the mathematical properties of the filter are the same but the physical properties are quite different. Often the components in different technologies are directly analogous to each other and fulfill the same role in their respective filters. For instance, the resistors, inductors and capacitors of electronics correspond respectively to dampers, masses and springs in mechanics. Likewise, there are corresponding components in distributed element filters.</p>
<ul>
<li><a href="Electronic_filter" title="wikilink">Electronic filters</a> were originally entirely passive consisting of resistance, inductance and capacitance. Active technology makes design easier and opens up new possibilities in filter specifications.</li>
<li><a href="Digital_filter" title="wikilink">Digital filters</a> operate on signals represented in digital form. The essence of a digital filter is that it directly implements a mathematical algorithm, corresponding to the desired filter transfer function, in its programming or microcode.</li>
<li><a href="Mechanical_filter" title="wikilink">Mechanical filters</a> are built out of mechanical components. In the vast majority of cases they are used to process an electronic signal and <a href="transducer" title="wikilink">transducers</a> are provided to convert this to and from a mechanical vibration. However, examples do exist of filters that have been designed for operation entirely in the mechanical domain.</li>
<li><a href="Distributed_element_filter" title="wikilink">Distributed element filters</a> are constructed out of components made from small pieces of <a href="transmission_line" title="wikilink">transmission line</a> or other <a href="distributed_element_model" title="wikilink">distributed elements</a>. There are structures in distributed element filters that directly correspond to the <a href="lumped_element_model" title="wikilink">lumped elements</a> of electronic filters, and others that are unique to this class of technology.</li>
<li><a href="Waveguide_filter" title="wikilink">Waveguide filters</a> consist of waveguide components or components inserted in the waveguide. Waveguides are a class of transmission line and many structures of distributed element filters, for instance the <a href="stub_(electronics)" title="wikilink">stub (electronics)</a>, can be implemented in waveguides also.</li>
<li><a href="Crystal_filter" title="wikilink">Crystal filters</a> use <a class="uri" href="quartz" title="wikilink">quartz</a> crystals as resonators, or some other <a class="uri" href="piezoelectric" title="wikilink">piezoelectric</a> material.</li>
<li><a href="Acoustic_filter" title="wikilink">Acoustic filters</a></li>
<li><a href="Filter_(optics)" title="wikilink">Optical filters</a> were originally developed for purposes other than signal processing such as lighting and photography. With the rise of <a href="optical_fiber" title="wikilink">optical fiber</a> technology, however, optical filters increasingly find signal processing applications and signal processing filter terminology, such as <a href="Filter_(optics)#Longpass" title="wikilink">longpass</a> and <a href="Filter_(optics)#Shortpass" title="wikilink">shortpass</a>, are entering the field.</li>
</ul>
<h2 id="the-transfer-function">The transfer function</h2>

<p>The <a href="transfer_function" title="wikilink">transfer function</a> of a filter is most often defined in the domain of the complex frequencies. The back and forth passage to/from this domain is operated by the <a href="Laplace_transform" title="wikilink">Laplace transform</a> and its inverse (therefore, here below, the term "input signal" shall be understood as "the Laplace transform of" (the time representation of) the input signal, and so on).</p>

<p>The <a href="transfer_function" title="wikilink">transfer function</a> 

<math display="inline" id="Filter_(signal_processing):0">
 <semantics>
  <mrow>
   <mpadded lspace="5pt" width="+5pt">
    <mi>H</mi>
   </mpadded>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>s</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>H</ci>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ H(s)
  </annotation>
 </semantics>
</math>

 of a filter is the ratio of the output signal 

<math display="inline" id="Filter_(signal_processing):1">
 <semantics>
  <mrow>
   <mpadded lspace="5pt" width="+5pt">
    <mi>Y</mi>
   </mpadded>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>s</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>Y</ci>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ Y(s)
  </annotation>
 </semantics>
</math>

 to that of the input signal 

<math display="inline" id="Filter_(signal_processing):2">
 <semantics>
  <mrow>
   <mpadded lspace="5pt" width="+5pt">
    <mi>X</mi>
   </mpadded>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>s</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>X</ci>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ X(s)
  </annotation>
 </semantics>
</math>

 as a function of the complex frequency 

<math display="inline" id="Filter_(signal_processing):3">
 <semantics>
  <mpadded lspace="5pt" width="+5pt">
   <mi>s</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ s
  </annotation>
 </semantics>
</math>

:</p>

<p>

<math display="block" id="Filter_(signal_processing):4">
 <semantics>
  <mrow>
   <mrow>
    <mpadded lspace="5pt" width="+5pt">
     <mi>H</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>s</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mi>Y</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>s</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mrow>
     <mi>X</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>s</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>H</ci>
     <ci>s</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <ci>Y</ci>
      <ci>s</ci>
     </apply>
     <apply>
      <times></times>
      <ci>X</ci>
      <ci>s</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ H(s)=\frac{Y(s)}{X(s)}
  </annotation>
 </semantics>
</math>

 with 

<math display="inline" id="Filter_(signal_processing):5">
 <semantics>
  <mrow>
   <mpadded lspace="5pt" width="+5pt">
    <mi>s</mi>
   </mpadded>
   <mo>=</mo>
   <mrow>
    <mi>σ</mi>
    <mo>+</mo>
    <mrow>
     <mi>j</mi>
     <mi>ω</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>s</ci>
    <apply>
     <plus></plus>
     <ci>σ</ci>
     <apply>
      <times></times>
      <ci>j</ci>
      <ci>ω</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ s=\sigma+j\omega
  </annotation>
 </semantics>
</math>

.</p>

<p>The transfer function of all linear time-invariant filters generally share certain characteristics:</p>
<ul>
<li>For filters which are constructed of discrete components, their transfer function must be the ratio of two polynomials in 

<math display="inline" id="Filter_(signal_processing):6">
 <semantics>
  <mpadded lspace="5pt" width="+5pt">
   <mi>s</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ s
  </annotation>
 </semantics>
</math>

, i.e. a <a href="rational_function" title="wikilink">rational function</a> of 

<math display="inline" id="Filter_(signal_processing):7">
 <semantics>
  <mpadded lspace="5pt" width="+5pt">
   <mi>s</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ s
  </annotation>
 </semantics>
</math>

. The order of the transfer function will be the highest power of 

<math display="inline" id="Filter_(signal_processing):8">
 <semantics>
  <mpadded lspace="5pt" width="+5pt">
   <mi>s</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ s
  </annotation>
 </semantics>
</math>

 encountered in either the numerator or the denominator.</li>
<li>The polynomials of the transfer function will all have real coefficients. Therefore, the poles and zeroes of the transfer function will either be real or occur in complex conjugate pairs.</li>
<li>Since the filters are assumed to be stable, the real part of all poles (i.e. zeroes of the denominator) will be negative, i.e. they will lie in the left half-plane in complex frequency space.</li>
</ul>

<p>Distributed element filters do not, in general, produce rational functions but can often approximate to them.</p>

<p>The proper construction of a transfer function involves the <a href="Laplace_transform" title="wikilink">Laplace transform</a>, and therefore it is needed to assume null initial conditions, because</p>

<p>

<math display="block" id="Filter_(signal_processing):9">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi class="ltx_font_mathcaligraphic">ℒ</mi>
     <mrow>
      <mo>{</mo>
      <mfrac>
       <mrow>
        <mi>d</mi>
        <mi>f</mi>
       </mrow>
       <mrow>
        <mi>d</mi>
        <mi>t</mi>
       </mrow>
      </mfrac>
      <mo>}</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mrow>
       <mi>s</mi>
       <mo>⋅</mo>
       <mi class="ltx_font_mathcaligraphic">ℒ</mi>
      </mrow>
      <mrow>
       <mo>{</mo>
       <mrow>
        <mi>f</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>t</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>}</mo>
      </mrow>
     </mrow>
     <mo>-</mo>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mn>0</mn>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>ℒ</ci>
     <set>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <ci>d</ci>
        <ci>f</ci>
       </apply>
       <apply>
        <times></times>
        <ci>d</ci>
        <ci>t</ci>
       </apply>
      </apply>
     </set>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <apply>
       <ci>normal-⋅</ci>
       <ci>s</ci>
       <ci>ℒ</ci>
      </apply>
      <set>
       <apply>
        <times></times>
        <ci>f</ci>
        <ci>t</ci>
       </apply>
      </set>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <cn type="integer">0</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{L}\left\{\frac{df}{dt}\right\}=s\cdot\mathcal{L}\left\{f(t)\right\}-f%
(0),
  </annotation>
 </semantics>
</math>

 And when f(0)=0 we can get rid of the constants and use the usual expression</p>

<p>

<math display="block" id="Filter_(signal_processing):10">
 <semantics>
  <mrow>
   <mrow>
    <mi class="ltx_font_mathcaligraphic">ℒ</mi>
    <mrow>
     <mo>{</mo>
     <mfrac>
      <mrow>
       <mi>d</mi>
       <mi>f</mi>
      </mrow>
      <mrow>
       <mi>d</mi>
       <mi>t</mi>
      </mrow>
     </mfrac>
     <mo>}</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>s</mi>
     <mo>⋅</mo>
     <mi class="ltx_font_mathcaligraphic">ℒ</mi>
    </mrow>
    <mrow>
     <mo>{</mo>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>}</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>ℒ</ci>
     <set>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <ci>d</ci>
        <ci>f</ci>
       </apply>
       <apply>
        <times></times>
        <ci>d</ci>
        <ci>t</ci>
       </apply>
      </apply>
     </set>
    </apply>
    <apply>
     <times></times>
     <apply>
      <ci>normal-⋅</ci>
      <ci>s</ci>
      <ci>ℒ</ci>
     </apply>
     <set>
      <apply>
       <times></times>
       <ci>f</ci>
       <ci>t</ci>
      </apply>
     </set>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{L}\left\{\frac{df}{dt}\right\}=s\cdot\mathcal{L}\left\{f(t)\right\}
  </annotation>
 </semantics>
</math>

 An alternative to transfer functions is to give the behavior of the filter as a <a class="uri" href="convolution" title="wikilink">convolution</a>. The <a href="convolution_theorem" title="wikilink">convolution theorem</a>, which holds for Laplace transforms, guarantees equivalence with transfer functions.</p>
<h3 id="classification">Classification</h3>

<p>Filters may be specified by family and bandform. A filter's family is specified by the approximating polynomial used and each leads to certain characteristics of the transfer function of the filter. Some common filter families and their particular characteristics are:</p>
<ul>
<li><a href="Butterworth_filter" title="wikilink">Butterworth filter</a> – no gain <a href="ripple_(filters)" title="wikilink">ripple</a> in pass band and stop band, slow cutoff</li>
<li><a href="Chebyshev_filter" title="wikilink">Chebyshev filter (Type I)</a> – no gain ripple in stop band, moderate cutoff</li>
<li><a href="Chebyshev_filter" title="wikilink">Chebyshev filter (Type II)</a> – no gain ripple in pass band, moderate cutoff</li>
<li><a href="Bessel_filter" title="wikilink">Bessel filter</a> – no <a href="group_delay" title="wikilink">group delay</a> ripple, no gain ripple in both bands, slow gain cutoff</li>
<li><a href="Elliptic_filter" title="wikilink">Elliptic filter</a> – gain ripple in pass and stop band, fast cutoff</li>
<li><a href='Optimum_"L"_filter' title="wikilink">Optimum "L" filter</a></li>
<li><a href="Gaussian_filter" title="wikilink">Gaussian filter</a> – no ripple in response to step function</li>
<li><a href="Hourglass_filter" title="wikilink">Hourglass filter</a></li>
<li><a href="Raised-cosine_filter" title="wikilink">Raised-cosine filter</a></li>
</ul>

<p>Each family of filters can be specified to a particular order. The higher the order, the more the filter will approach the "ideal" filter; but also the longer the impulse response is and the longer the latency will be. An ideal filter has full transmission in the pass band, complete attenuation in the stop band, and an abrupt transition between the two bands, but this filter has infinite order (i.e., the response cannot be expressed as a <a href="linear_differential_equation" title="wikilink">linear differential equation</a> with a finite sum) and infinite latency (i.e., its <a href="compact_support" title="wikilink">compact support</a> in the <a href="Fourier_transform" title="wikilink">Fourier transform</a> forces its time response to be ever lasting).</p>

<p>Here is an image comparing Butterworth, Chebyshev, and elliptic filters. The filters in this illustration are all fifth-order low-pass filters. The particular implementation – analog or digital, passive or active – makes no difference; their output would be the same.</p>
<figure><b>(Figure)</b>
<figcaption>Electronic linear filters.svg</figcaption>
</figure>

<p>As is clear from the image, elliptic filters are sharper than all the others, but they show ripples on the whole bandwidth.</p>

<p>Any family can be used to implement a particular bandform of which frequencies are transmitted, and which, outside the passband, are more or less attenuated. The transfer function completely specifies the behavior of a linear filter, but not the particular technology used to implement it. In other words, there are a number of different ways of achieving a particular transfer function when designing a circuit. A particular bandform of filter can be obtained by <a href="transform_(mathematics)" title="wikilink">transformation</a> of a <a href="prototype_filter#Bandform_transformation" title="wikilink">prototype filter</a> of that family.</p>
<h2 id="impedance-matching">Impedance matching</h2>

<p><a href="Impedance_matching" title="wikilink">Impedance matching</a> structures invariably take on the form of a filter, that is, a network of non-dissipative elements. For instance, in a passive electronics implementation, it would likely take the form of a <a href="ladder_topology" title="wikilink">ladder topology</a> of inductors and capacitors. The design of matching networks shares much in common with filters and the design invariably will have a filtering action as an incidental consequence. Although the prime purpose of a matching network is not to filter, it is often the case that both functions are combined in the same circuit. The need for impedance matching does not arise while signals are in the digital domain.</p>

<p>Similar comments can be made regarding <a href="power_dividers_and_directional_couplers" title="wikilink">power dividers and directional couplers</a>. When implemented in a distributed element format, these devices can take the form of a <a href="distributed_element_filter" title="wikilink">distributed element filter</a>. There are four ports to be matched and widening the bandwidth requires filter-like structures to achieve this. The inverse is also true: distributed element filters can take the form of coupled lines.</p>
<h2 id="some-filters-for-specific-purposes">Some filters for specific purposes</h2>
<ul>
<li><a href="Audio_filter" title="wikilink">Audio filter</a></li>
<li><a href="Line_filter" title="wikilink">Line filter</a></li>
<li><a href="Scaled_correlation" title="wikilink">Scaled correlation</a>, high-pass filter for correlations</li>
<li><a href="Texture_filtering" title="wikilink">Texture filtering</a></li>
</ul>
<h3 id="filters-for-removing-noise-from-data">Filters for removing noise from data</h3>
<ul>
<li><a href="Wiener_filter" title="wikilink">Wiener filter</a></li>
<li><a href="Kalman_filter" title="wikilink">Kalman filter</a></li>
<li><a href="Savitzky–Golay_smoothing_filter" title="wikilink">Savitzky–Golay smoothing filter</a></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li>Miroslav D. Lutovac, Dejan V. Tošić, Brian Lawrence Evans, <em>Filter Design for Signal Processing Using MATLAB and Mathematica</em>, Miroslav Lutovac, 2001 ISBN 0201361302.</li>
<li>B. A. Shenoi, <em>Introduction to Digital Signal Processing and Filter Design</em>, John Wiley &amp; Sons, 2005 ISBN 0471656380.</li>
<li>L. D. Paarmann, <em>Design and Analysis of Analog Filters: A Signal Processing Perspective</em>, Springer, 2001 ISBN 0792373731.</li>
<li>J.S.Chitode, <em>Digital Signal Processing</em>, Technical Publications, 2009 ISBN 8184316461.</li>
<li>Leland B. Jackson, <em>Digital Filters and Signal Processing</em>, Springer, 1996 ISBN 079239559X.</li>
</ul>

<p>"</p>

<p><a href="Category:Signal_processing" title="wikilink">Category:Signal processing</a> <a href="Category:Telecommunication_theory" title="wikilink">Category:Telecommunication theory</a> <a href="Category:Filter_theory" title="wikilink">Category:Filter theory</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Richard Markell. <a href="http://cds.linear.com/docs/en/application-note/an56.pdf">'"Better than Bessel" Linear Phase Filters for Data Communications'</a>. 1994. p. 3.<a href="#fnref1">↩</a></li>
</ol>
</section>
</body>
</html>
