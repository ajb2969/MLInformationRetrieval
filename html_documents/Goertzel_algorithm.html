<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="200">Goertzel algorithm</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Goertzel algorithm</h1>
<hr/>

<p>The <strong>Goertzel algorithm</strong> is a <a href="Digital_Signal_Processing" title="wikilink">Digital Signal Processing</a> (DSP) technique that provides a means for efficient evaluation of individual terms of the <a href="Discrete_Fourier_Transform" title="wikilink">Discrete Fourier Transform</a> (DFT), thus making it useful in certain practical applications, such as recognition of <a href="Dual-tone_multi-frequency_signaling" title="wikilink">DTMF</a> tones produced by the buttons pushed on a telephone keypad. The algorithm was first described by <a href="Gerald_Goertzel" title="wikilink">Gerald Goertzel</a> in 1958.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>

<p>Like the DFT, the Goertzel algorithm analyses one selectable frequency component from a <a href="discrete_signal" title="wikilink">discrete signal</a>.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a><a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a><a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> Unlike direct DFT calculations, the Goertzel algorithm applies a single real-valued coefficient at each iteration, using real-valued arithmetic for real-valued input sequences. For covering a full spectrum, the Goertzel algorithm has a <a href="Computational_complexity_theory" title="wikilink">higher order of complexity</a> than <a href="Fast_Fourier_Transform" title="wikilink">Fast Fourier Transform</a> (FFT) algorithms; but for computing a small number of selected frequency components, it is more numerically efficient. The simple structure of the Goertzel algorithm makes it well suited to small processors and embedded applications, though not limited to these.</p>

<p>The Goertzel algorithm can also be used "in reverse" as a sinusoid synthesis function, which requires only 1 multiplication and 1 subtraction per generated sample.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>
<h2 id="the-algorithm">The algorithm</h2>

<p>The main calculation in the Goertzel algorithm has the form of a <a href="digital_filter" title="wikilink">digital filter</a>, and for this reason the algorithm is often called a <em>Goertzel filter</em>. The filter operates on an input sequence, 

<math display="inline" id="Goertzel_algorithm:0">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>x</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x(n)
  </annotation>
 </semantics>
</math>

, in a cascade of two stages with a parameter, 

<math display="inline" id="Goertzel_algorithm:1">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

, giving the frequency to be analysed, normalised to cycles per sample.</p>

<p>The first stage calculates an intermediate sequence, 

<math display="inline" id="Goertzel_algorithm:2">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>s</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s(n)
  </annotation>
 </semantics>
</math>

:</p>
<dl>
<dd>(1) 

<math display="inline" id="Goertzel_algorithm:3">
 <semantics>
  <mrow>
   <mrow>
    <mi>s</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <mi>x</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>n</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mn>2</mn>
      <mrow>
       <mi>cos</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mn>2</mn>
         <mi>π</mi>
         <mi>f</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mi>s</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>n</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mi>s</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mn>2</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>s</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>x</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <apply>
        <cos></cos>
        <apply>
         <times></times>
         <cn type="integer">2</cn>
         <ci>π</ci>
         <ci>f</ci>
        </apply>
       </apply>
       <ci>s</ci>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>s</ci>
      <apply>
       <minus></minus>
       <ci>n</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s(n)=x(n)+2\cos(2\pi f)s(n-1)-s(n-2)
  </annotation>
 </semantics>
</math>


</dd>
</dl>

<p>The second stage applies the following filter to 

<math display="inline" id="Goertzel_algorithm:4">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>s</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s(n)
  </annotation>
 </semantics>
</math>

, producing output sequence 

<math display="inline" id="Goertzel_algorithm:5">
 <semantics>
  <mrow>
   <mi>y</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>y</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y(n)
  </annotation>
 </semantics>
</math>

.</p>
<dl>
<dd>(2) 

<math display="inline" id="Goertzel_algorithm:6">
 <semantics>
  <mrow>
   <mrow>
    <mi>y</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>s</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <msup>
      <mi>e</mi>
      <mrow>
       <mo>-</mo>
       <mrow>
        <mn>2</mn>
        <mi>π</mi>
        <mi>i</mi>
        <mi>f</mi>
       </mrow>
      </mrow>
     </msup>
     <mi>s</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>y</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>s</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>e</ci>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <cn type="integer">2</cn>
         <ci>π</ci>
         <ci>i</ci>
         <ci>f</ci>
        </apply>
       </apply>
      </apply>
      <ci>s</ci>
      <apply>
       <minus></minus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y(n)=s(n)-e^{-2\pi if}s(n-1)
  </annotation>
 </semantics>
</math>


</dd>
</dl>

<p>The first filter stage can be observed to be a second-order <a href="Infinite_impulse_response" title="wikilink">IIR filter</a> with a <a href="Digital_filter#Direct_Form_I" title="wikilink">direct form</a> structure. This particular structure has the property that its internal state variables equal the past output values from that stage. Input values 

<math display="inline" id="Goertzel_algorithm:7">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>x</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x(n)
  </annotation>
 </semantics>
</math>

 for 

<math display="inline" id="Goertzel_algorithm:8">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo><</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <ci>n</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n<0
  </annotation>
 </semantics>
</math>

 are presumed all equal to 0. To establish the initial filter state so that evaluation can begin at sample 

<math display="inline" id="Goertzel_algorithm:9">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>0</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>x</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x(0)
  </annotation>
 </semantics>
</math>

, the filter states are assigned initial values 

<math display="inline" id="Goertzel_algorithm:10">
 <semantics>
  <mrow>
   <mrow>
    <mi>s</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo>-</mo>
      <mn>2</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>s</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>s</ci>
      <apply>
       <minus></minus>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>s</ci>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s(-2)=s(-1)=0
  </annotation>
 </semantics>
</math>

. To avoid <a href="Aliasing" title="wikilink">aliasing hazards</a>, frequency 

<math display="inline" id="Goertzel_algorithm:11">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 is often restricted to the range 0 to 1/2 (see <a href="Nyquist–Shannon_sampling_theorem" title="wikilink">Nyquist–Shannon sampling theorem</a>); using a value outside this range is not meaningless, but is equivalent to using an aliased frequency inside this range, since the exponential function is periodic with a period of 1 cycle per sample in <em>f</em>.</p>

<p>The second stage filter can be observed to be a <a href="Finite_impulse_response" title="wikilink">FIR filter</a>, since its calculations do not use any of its past outputs.</p>

<p><a href="Z_transform" title="wikilink">Z transform</a> methods can be applied to study the properties of the filter cascade. The Z transform of the first filter stage given in equation (1) is:</p>
<dl>
<dd>(3) 

<math display="inline" id="Goertzel_algorithm:12">
 <semantics>
  <mrow>
   <mrow>
    <mfrac>
     <mrow>
      <mi>S</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>z</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mrow>
      <mi>X</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>z</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mfrac>
    <mo>=</mo>
    <mfrac>
     <mn>1</mn>
     <mrow>
      <mrow>
       <mn>1</mn>
       <mo>-</mo>
       <mrow>
        <mn>2</mn>
        <mrow>
         <mi>cos</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <mn>2</mn>
           <mi>π</mi>
           <mi>f</mi>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <msup>
         <mi>z</mi>
         <mrow>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
        </msup>
       </mrow>
      </mrow>
      <mo>+</mo>
      <msup>
       <mi>z</mi>
       <mrow>
        <mo>-</mo>
        <mn>2</mn>
       </mrow>
      </msup>
     </mrow>
    </mfrac>
    <mo>=</mo>
    <mfrac>
     <mn>1</mn>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mn>1</mn>
        <mo>-</mo>
        <mrow>
         <msup>
          <mi>e</mi>
          <mrow>
           <mo>+</mo>
           <mrow>
            <mn>2</mn>
            <mi>π</mi>
            <mi>i</mi>
            <mi>f</mi>
           </mrow>
          </mrow>
         </msup>
         <msup>
          <mi>z</mi>
          <mrow>
           <mo>-</mo>
           <mn>1</mn>
          </mrow>
         </msup>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mn>1</mn>
        <mo>-</mo>
        <mrow>
         <msup>
          <mi>e</mi>
          <mrow>
           <mo>-</mo>
           <mrow>
            <mn>2</mn>
            <mi>π</mi>
            <mi>i</mi>
            <mi>f</mi>
           </mrow>
          </mrow>
         </msup>
         <msup>
          <mi>z</mi>
          <mrow>
           <mo>-</mo>
           <mn>1</mn>
          </mrow>
         </msup>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mfrac>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <ci>S</ci>
       <ci>z</ci>
      </apply>
      <apply>
       <times></times>
       <ci>X</ci>
       <ci>z</ci>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <plus></plus>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
        <apply>
         <times></times>
         <cn type="integer">2</cn>
         <apply>
          <cos></cos>
          <apply>
           <times></times>
           <cn type="integer">2</cn>
           <ci>π</ci>
           <ci>f</ci>
          </apply>
         </apply>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>z</ci>
          <apply>
           <minus></minus>
           <cn type="integer">1</cn>
          </apply>
         </apply>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>z</ci>
        <apply>
         <minus></minus>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <times></times>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>e</ci>
          <apply>
           <plus></plus>
           <apply>
            <times></times>
            <cn type="integer">2</cn>
            <ci>π</ci>
            <ci>i</ci>
            <ci>f</ci>
           </apply>
          </apply>
         </apply>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>z</ci>
          <apply>
           <minus></minus>
           <cn type="integer">1</cn>
          </apply>
         </apply>
        </apply>
       </apply>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>e</ci>
          <apply>
           <minus></minus>
           <apply>
            <times></times>
            <cn type="integer">2</cn>
            <ci>π</ci>
            <ci>i</ci>
            <ci>f</ci>
           </apply>
          </apply>
         </apply>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>z</ci>
          <apply>
           <minus></minus>
           <cn type="integer">1</cn>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{S(z)}{X(z)}=\frac{1}{1-2\cos(2\pi f)z^{-1}+z^{-2}}=\frac{1}{(1-e^{+2\pi
if%
}z^{-1})(1-e^{-2\pi if}z^{-1})}.
  </annotation>
 </semantics>
</math>


</dd>
</dl>

<p>The Z transform of the second filter stage given in equation (2) is:</p>
<dl>
<dd>(4) 

<math display="inline" id="Goertzel_algorithm:13">
 <semantics>
  <mrow>
   <mfrac>
    <mrow>
     <mi>Y</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>z</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mrow>
     <mi>S</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>z</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mfrac>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mo>-</mo>
    <mrow>
     <msup>
      <mi>e</mi>
      <mrow>
       <mo>-</mo>
       <mrow>
        <mn>2</mn>
        <mi>π</mi>
        <mi>i</mi>
        <mi>f</mi>
       </mrow>
      </mrow>
     </msup>
     <msup>
      <mi>z</mi>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msup>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <ci>Y</ci>
      <ci>z</ci>
     </apply>
     <apply>
      <times></times>
      <ci>S</ci>
      <ci>z</ci>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>e</ci>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <cn type="integer">2</cn>
         <ci>π</ci>
         <ci>i</ci>
         <ci>f</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>z</ci>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{Y(z)}{S(z)}=1-e^{-2\pi if}z^{-1}
  </annotation>
 </semantics>
</math>


</dd>
</dl>

<p>The combined transfer function of the cascade of the two filter stages is then</p>
<dl>
<dd>(5) 

<math display="inline" id="Goertzel_algorithm:14">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mfrac>
      <mrow>
       <mi>S</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>z</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mrow>
       <mi>X</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>z</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mfrac>
     <mfrac>
      <mrow>
       <mi>Y</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>z</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mrow>
       <mi>S</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>z</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mfrac>
    </mrow>
    <mo>=</mo>
    <mfrac>
     <mrow>
      <mi>Y</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>z</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mrow>
      <mi>X</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>z</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mfrac>
    <mo>=</mo>
    <mfrac>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mn>1</mn>
       <mo>-</mo>
       <mrow>
        <msup>
         <mi>e</mi>
         <mrow>
          <mo>-</mo>
          <mrow>
           <mn>2</mn>
           <mi>π</mi>
           <mi>i</mi>
           <mi>f</mi>
          </mrow>
         </mrow>
        </msup>
        <msup>
         <mi>z</mi>
         <mrow>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
        </msup>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mn>1</mn>
        <mo>-</mo>
        <mrow>
         <msup>
          <mi>e</mi>
          <mrow>
           <mo>+</mo>
           <mrow>
            <mn>2</mn>
            <mi>π</mi>
            <mi>i</mi>
            <mi>f</mi>
           </mrow>
          </mrow>
         </msup>
         <msup>
          <mi>z</mi>
          <mrow>
           <mo>-</mo>
           <mn>1</mn>
          </mrow>
         </msup>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mn>1</mn>
        <mo>-</mo>
        <mrow>
         <msup>
          <mi>e</mi>
          <mrow>
           <mo>-</mo>
           <mrow>
            <mn>2</mn>
            <mi>π</mi>
            <mi>i</mi>
            <mi>f</mi>
           </mrow>
          </mrow>
         </msup>
         <msup>
          <mi>z</mi>
          <mrow>
           <mo>-</mo>
           <mn>1</mn>
          </mrow>
         </msup>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mfrac>
    <mo>=</mo>
    <mfrac>
     <mn>1</mn>
     <mrow>
      <mn>1</mn>
      <mo>-</mo>
      <mrow>
       <msup>
        <mi>e</mi>
        <mrow>
         <mo>+</mo>
         <mrow>
          <mn>2</mn>
          <mi>π</mi>
          <mi>i</mi>
          <mi>f</mi>
         </mrow>
        </mrow>
       </msup>
       <msup>
        <mi>z</mi>
        <mrow>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
       </msup>
      </mrow>
     </mrow>
    </mfrac>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <ci>S</ci>
        <ci>z</ci>
       </apply>
       <apply>
        <times></times>
        <ci>X</ci>
        <ci>z</ci>
       </apply>
      </apply>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <ci>Y</ci>
        <ci>z</ci>
       </apply>
       <apply>
        <times></times>
        <ci>S</ci>
        <ci>z</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <ci>Y</ci>
       <ci>z</ci>
      </apply>
      <apply>
       <times></times>
       <ci>X</ci>
       <ci>z</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <divide></divide>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>e</ci>
         <apply>
          <minus></minus>
          <apply>
           <times></times>
           <cn type="integer">2</cn>
           <ci>π</ci>
           <ci>i</ci>
           <ci>f</ci>
          </apply>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>z</ci>
         <apply>
          <minus></minus>
          <cn type="integer">1</cn>
         </apply>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>e</ci>
          <apply>
           <plus></plus>
           <apply>
            <times></times>
            <cn type="integer">2</cn>
            <ci>π</ci>
            <ci>i</ci>
            <ci>f</ci>
           </apply>
          </apply>
         </apply>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>z</ci>
          <apply>
           <minus></minus>
           <cn type="integer">1</cn>
          </apply>
         </apply>
        </apply>
       </apply>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>e</ci>
          <apply>
           <minus></minus>
           <apply>
            <times></times>
            <cn type="integer">2</cn>
            <ci>π</ci>
            <ci>i</ci>
            <ci>f</ci>
           </apply>
          </apply>
         </apply>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>z</ci>
          <apply>
           <minus></minus>
           <cn type="integer">1</cn>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>e</ci>
         <apply>
          <plus></plus>
          <apply>
           <times></times>
           <cn type="integer">2</cn>
           <ci>π</ci>
           <ci>i</ci>
           <ci>f</ci>
          </apply>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>z</ci>
         <apply>
          <minus></minus>
          <cn type="integer">1</cn>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{S(z)}{X(z)}\frac{Y(z)}{S(z)}=\frac{Y(z)}{X(z)}=\frac{(1-e^{-2\pi if}z^{-%
1})}{(1-e^{+2\pi if}z^{-1})(1-e^{-2\pi if}z^{-1})}=\frac{1}{1-e^{+2\pi if}z^{-%
1}}.
  </annotation>
 </semantics>
</math>


</dd>
</dl>

<p>This can be transformed back to an equivalent time domain sequence, and the terms unrolled back to the first input term at index 

<math display="inline" id="Goertzel_algorithm:15">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>n</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n=0
  </annotation>
 </semantics>
</math>

.</p>
<dl>
<dd>(6) <math> \begin{align}
</math></dd>
</dl>

<p><code>y(n) &amp; = x(n) + e^{+2 \pi i f} y(n-1) \\</code><br/>
<code> &amp; = \sum_{k=-\infty}^{n}x(k) e^{+2 \pi i f (n-k)} \\</code><br/>
<code> &amp; = e^{+2 \pi i f n} \sum_{k=0}^{n} x(k) e^{-2 \pi i f k} </code></p>

<p>\end{align}  </p>

<p>It can be observed that the <a href="Pole_(complex_analysis)" title="wikilink">poles</a> of the filter's <a href="Z_transform" title="wikilink">Z transform</a> are located at 

<math display="inline" id="Goertzel_algorithm:16">
 <semantics>
  <msup>
   <mi>e</mi>
   <mrow>
    <mo>+</mo>
    <mrow>
     <mn>2</mn>
     <mi>π</mi>
     <mi>i</mi>
     <mi>f</mi>
    </mrow>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>e</ci>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <ci>π</ci>
      <ci>i</ci>
      <ci>f</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e^{+2\pi if}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Goertzel_algorithm:17">
 <semantics>
  <msup>
   <mi>e</mi>
   <mrow>
    <mo>-</mo>
    <mrow>
     <mn>2</mn>
     <mi>π</mi>
     <mi>i</mi>
     <mi>f</mi>
    </mrow>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>e</ci>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <ci>π</ci>
      <ci>i</ci>
      <ci>f</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e^{-2\pi if}
  </annotation>
 </semantics>
</math>

, on a circle of unit radius centered on the origin of the complex <a href="Z_transform" title="wikilink">Z transform plane</a>. This property indicates that the filter process is <a href="Marginal_stability" title="wikilink">marginally stable</a> and vulnerable <a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> to <a href="Numerical_stability" title="wikilink">numerical error accumulation</a> when computed using low-precision arithmetic and long input sequences.</p>
<h2 id="dft-computations">DFT computations</h2>

<p>For the important case of computing a DFT term, the following special restrictions are applied.</p>
<ul>
<li>the filtering terminates at index 

<math display="inline" id="Goertzel_algorithm:18">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>=</mo>
   <mi>N</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>n</ci>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n=N
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Goertzel_algorithm:19">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

 is the number of terms in the input sequence of the DFT</li>
<li>the frequencies chosen for the Goertzel analysis are restricted to the special form</li>
</ul>
<dl>
<dd>(7) 

<math display="inline" id="Goertzel_algorithm:20">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mo>=</mo>
   <mfrac>
    <mi>K</mi>
    <mi>N</mi>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>f</ci>
    <apply>
     <divide></divide>
     <ci>K</ci>
     <ci>N</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f=\frac{K}{N}
  </annotation>
 </semantics>
</math>


</dd>
</dl>
<ul>
<li>the index number 

<math display="inline" id="Goertzel_algorithm:21">
 <semantics>
  <mi>K</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>K</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K
  </annotation>
 </semantics>
</math>

 indicating the "frequency bin" of the DFT is selected from the set of index numbers</li>
</ul>
<dl>
<dd>(8) 

<math display="inline" id="Goertzel_algorithm:22">
 <semantics>
  <mrow>
   <mi>K</mi>
   <mi>ϵ</mi>
   <mrow>
    <mo stretchy="false">{</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mn>1</mn>
    <mo>,</mo>
    <mn>2</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mrow>
     <mi>N</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>K</ci>
    <ci>ϵ</ci>
    <set>
     <cn type="integer">0</cn>
     <cn type="integer">1</cn>
     <cn type="integer">2</cn>
     <ci>normal-…</ci>
     <apply>
      <minus></minus>
      <ci>N</ci>
      <cn type="integer">1</cn>
     </apply>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K\epsilon\{0,1,2,...,N-1\}
  </annotation>
 </semantics>
</math>


</dd>
</dl>

<p>Making these substitutions into equation (6), and observing that the term 

<math display="inline" id="Goertzel_algorithm:23">
 <semantics>
  <mrow>
   <msup>
    <mi>e</mi>
    <mrow>
     <mo>+</mo>
     <mrow>
      <mn>2</mn>
      <mi>π</mi>
      <mi>i</mi>
      <mi>K</mi>
     </mrow>
    </mrow>
   </msup>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>e</ci>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>π</ci>
       <ci>i</ci>
       <ci>K</ci>
      </apply>
     </apply>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e^{+2\pi iK}=1
  </annotation>
 </semantics>
</math>

, equation (6) then takes the following form.</p>
<dl>
<dd>(9) 

<math display="inline" id="Goertzel_algorithm:24">
 <semantics>
  <mrow>
   <mrow>
    <mi>y</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>N</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∑</mo>
     <mrow>
      <mi>k</mi>
      <mo>=</mo>
      <mn>0</mn>
     </mrow>
     <mi>N</mi>
    </msubsup>
    <mrow>
     <mi>x</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>k</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <msup>
      <mi>e</mi>
      <mrow>
       <mo>-</mo>
       <mrow>
        <mn>2</mn>
        <mi>π</mi>
        <mi>i</mi>
        <mfrac>
         <mrow>
          <mi>k</mi>
          <mi>K</mi>
         </mrow>
         <mi>N</mi>
        </mfrac>
       </mrow>
      </mrow>
     </msup>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>y</ci>
     <ci>N</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>k</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <ci>N</ci>
     </apply>
     <apply>
      <times></times>
      <ci>x</ci>
      <ci>k</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>e</ci>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <cn type="integer">2</cn>
         <ci>π</ci>
         <ci>i</ci>
         <apply>
          <divide></divide>
          <apply>
           <times></times>
           <ci>k</ci>
           <ci>K</ci>
          </apply>
          <ci>N</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y(N)=\sum_{k=0}^{N}x(k)e^{-2\pi i\frac{kK}{N}}
  </annotation>
 </semantics>
</math>


</dd>
</dl>

<p>We can observe that the right side of equation (9) is extremely similar to the defining formula for DFT term 

<math display="inline" id="Goertzel_algorithm:25">
 <semantics>
  <mrow>
   <mi>X</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>K</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>X</ci>
    <ci>K</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X(K)
  </annotation>
 </semantics>
</math>

, the DFT term for index number K, but not exactly the same. The summation shown in equation (9) requires N+1 input terms, but only N input terms are available when evaluating a DFT. A simple but inelegant expedient is to extend the input sequence 

<math display="inline" id="Goertzel_algorithm:26">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 with one more artificial value 

<math display="inline" id="Goertzel_algorithm:27">
 <semantics>
  <mrow>
   <mrow>
    <mi>x</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>N</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>x</ci>
     <ci>N</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x(N)=0
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> We can see from equation (9), the mathematical effect on the final result is the same as removing term 

<math display="inline" id="Goertzel_algorithm:28">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>N</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>x</ci>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x(N)
  </annotation>
 </semantics>
</math>

 from the summation, thus delivering the intended DFT value.</p>

<p>However, there is a more elegant approach that avoids the extra filter pass. From equation (1), we can note that when the extended input term 

<math display="inline" id="Goertzel_algorithm:29">
 <semantics>
  <mrow>
   <mrow>
    <mi>x</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>N</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>x</ci>
     <ci>N</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x(N)=0
  </annotation>
 </semantics>
</math>

 is used in the final step,</p>
<dl>
<dd>(10) 

<math display="inline" id="Goertzel_algorithm:30">
 <semantics>
  <mrow>
   <mrow>
    <mi>s</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>N</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mn>2</mn>
     <mrow>
      <mi>cos</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mn>2</mn>
        <mi>π</mi>
        <mi>f</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mi>s</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>N</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mi>s</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>N</mi>
       <mo>-</mo>
       <mn>2</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>s</ci>
     <ci>N</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <apply>
       <cos></cos>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <ci>π</ci>
        <ci>f</ci>
       </apply>
      </apply>
      <ci>s</ci>
      <apply>
       <minus></minus>
       <ci>N</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>s</ci>
      <apply>
       <minus></minus>
       <ci>N</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s(N)=2\cos(2\pi f)s(N-1)-s(N-2)
  </annotation>
 </semantics>
</math>


</dd>
</dl>

<p>Thus, the algorithm can be completed as follows:</p>
<ul>
<li>terminate the IIR filter after processing input term 

<math display="inline" id="Goertzel_algorithm:31">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>N</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>x</ci>
    <apply>
     <minus></minus>
     <ci>N</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x(N-1)
  </annotation>
 </semantics>
</math>

</li>
<li>apply equation (10) to construct 

<math display="inline" id="Goertzel_algorithm:32">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>N</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>s</ci>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s(N)
  </annotation>
 </semantics>
</math>

 from the prior outputs 

<math display="inline" id="Goertzel_algorithm:33">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>N</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>s</ci>
    <apply>
     <minus></minus>
     <ci>N</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s(N-1)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Goertzel_algorithm:34">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>N</mi>
     <mo>-</mo>
     <mn>2</mn>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>s</ci>
    <apply>
     <minus></minus>
     <ci>N</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s(N-2)
  </annotation>
 </semantics>
</math>

</li>
<li>apply equation (2) with the calculated 

<math display="inline" id="Goertzel_algorithm:35">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>N</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>s</ci>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s(N)
  </annotation>
 </semantics>
</math>

 value, and with 

<math display="inline" id="Goertzel_algorithm:36">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>N</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>s</ci>
    <apply>
     <minus></minus>
     <ci>N</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s(N-1)
  </annotation>
 </semantics>
</math>

 produced by the final direct calculation of the filter.</li>
</ul>

<p>The last two mathematical operations are simplified by combining them algebraically.</p>
<dl>
<dd>(11) <math>\begin{align} y(N)\quad &amp; = s(N) - e^{-2 \pi i \frac{K}{N}} s(N-1)\quad \\
</math></dd>
</dl>

<p><code> &amp; = (2 \cos(2 \pi f) s(N-1) - s(N-2)) - e^{-2 \pi i \frac{K}{N}} s(N-1) \\</code><br/>
<code> &amp; =  e^{2 \pi i \frac{K}{N}} s(N-1) - s(N-2) </code></p>

<p>\end{align}</p>

<p>Note that stopping the filter updates at term 

<math display="inline" id="Goertzel_algorithm:37">
 <semantics>
  <mrow>
   <mi>N</mi>
   <mo>-</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>N</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N-1
  </annotation>
 </semantics>
</math>

 and immediately applying equation (2) rather than equation (11) misses the final filter state updates, yielding a result with incorrect phase.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></p>

<p>The particular filtering structure chosen for the Goertzel algorithm is the key to its efficient DFT calculations. We can observe that only one output value 

<math display="inline" id="Goertzel_algorithm:38">
 <semantics>
  <mrow>
   <mi>y</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>N</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>y</ci>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y(N)
  </annotation>
 </semantics>
</math>

 is used for calculating the DFT, so calculations for all the other output terms are omitted. Since the FIR filter is not calculated, the IIR stage calculations 

<math display="inline" id="Goertzel_algorithm:39">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>s</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>0</mn>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mi>s</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>1</mn>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <times></times>
     <ci>s</ci>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <times></times>
     <ci>s</ci>
     <cn type="integer">1</cn>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s(0),s(1),
  </annotation>
 </semantics>
</math>

 etc. can be discarded immediately after updating the first stage's internal state.</p>

<p>This seems to leave a paradox: to complete the algorithm, the FIR filter stage must be evaluated once using the final two outputs from the IIR filter stage, while for computational efficiency the IIR filter iteration discards its output values. This is where the properties of the direct-form filter structure are applied. The two internal state variables of the IIR filter provide the last two values of the IIR filter output, which are the terms required to evaluate the FIR filter stage.</p>
<h2 id="applications">Applications</h2>
<h3 id="power-spectrum-terms">Power spectrum terms</h3>

<p>Examining equation (6), a final IIR filter pass to calculate term 

<math display="inline" id="Goertzel_algorithm:40">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>N</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>s</ci>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s(N)
  </annotation>
 </semantics>
</math>

 using a supplemental input value 

<math display="inline" id="Goertzel_algorithm:41">
 <semantics>
  <mrow>
   <mrow>
    <mi>x</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>N</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>x</ci>
     <ci>N</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x(N)=0
  </annotation>
 </semantics>
</math>

 applies a complex multiplier of magnitude 1.0 to the previous term 

<math display="inline" id="Goertzel_algorithm:42">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>N</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>s</ci>
    <apply>
     <minus></minus>
     <ci>N</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s(N-1)
  </annotation>
 </semantics>
</math>

. Consequently, 

<math display="inline" id="Goertzel_algorithm:43">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>N</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>s</ci>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s(N)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Goertzel_algorithm:44">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>N</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>s</ci>
    <apply>
     <minus></minus>
     <ci>N</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s(N-1)
  </annotation>
 </semantics>
</math>

 represent equivalent signal power. It is equally valid to apply equation (11) and calculate the signal power from term 

<math display="inline" id="Goertzel_algorithm:45">
 <semantics>
  <mrow>
   <mi>y</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>N</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>y</ci>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y(N)
  </annotation>
 </semantics>
</math>

, or to apply equation (2) and calculate the signal power from term 

<math display="inline" id="Goertzel_algorithm:46">
 <semantics>
  <mrow>
   <mi>y</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>N</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>y</ci>
    <apply>
     <minus></minus>
     <ci>N</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y(N-1)
  </annotation>
 </semantics>
</math>

. Both cases lead to the following expression for the signal power represented by DFT term X(K).</p>
<dl>
<dd>(12) <math>\begin{align}
</math></dd>
</dl>

<p><code> X(K) X'(K) &amp; = y(N)\ y'(N) = y(N-1)\  y'(N-1) \\</code><br/>
<code> &amp; = s(N-1)^2 + s(N-2)^2 - 2 cos(2 \pi \frac{K}{N})\ s(N-1)\ s(N-2) </code></p>

<p>\end{align} </p>

<p>In the <a class="uri" href="pseudocode" title="wikilink">pseudocode</a> below, the variables <code>sprev</code> and <code>sprev2</code> temporarily store output history from the IIR filter, while <code>x[n]</code> is an indexed element of the <a href="array_data_type" title="wikilink">array</a> <code>x</code> which stores the input.</p>
<pre><code>Nterms defined here
Kterm selected here
ω = 2 * π * Kterm / Nterms;
cr = cos(ω);
ci = sin(ω);
coeff = 2 * cr;

sprev = 0;
sprev2 = 0;
for each index n in range 0 to Nterms-1
  s = x[n] + coeff * sprev - sprev2;
  sprev2 = sprev;
  sprev = s;
end

power = sprev2*sprev2 + sprev*sprev - coeff*sprev*sprev2 ;</code></pre>

<p>It is possible<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> to organise the computations so that incoming samples are delivered singly to a <a href="Object-oriented_programming" title="wikilink">software object</a> that maintains the filter state between updates, with the final power result accessed after the other processing is done.</p>
<h3 id="single-dft-term-with-real-valued-arithmetic">Single DFT term with real-valued arithmetic</h3>

<p>The case of real-valued input data arises frequently, especially in embedded systems where the input streams result from direct measurements of physical processes. Comparing to the illustration in the previous section, when the input data are real-valued, the filter internal state variables <em>sprev</em> and <em>sprev2</em> can be observed also to be real-valued, consequently, no complex arithmetic is required in the first IIR stage. Optimizing for real-valued arithmetic typically is as simple as applying appropriate real-valued data types for the variables.</p>

<p>After the calculations using input term 

<math display="inline" id="Goertzel_algorithm:47">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>N</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>x</ci>
    <apply>
     <minus></minus>
     <ci>N</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x(N-1)
  </annotation>
 </semantics>
</math>

, and filter iterations are terminated, equation (11) must be applied to evaluate the DFT term. The final calculation uses complex-valued arithmetic, but this can be converted into real-valued arithmetic by separating real and imaginary terms.</p>
<dl>
<dd>(13) <math>\begin{align}
</math></dd>
</dl>

<p><code> c_r  &amp; = \cos(2 \pi \frac{K}{N}) \\</code><br/>
<code> c_i  &amp; = \sin(2 \pi \frac{K}{N}) \\</code><br/>
<code> y(N) &amp; = c_rs(N-1) - s(N-2) +  i c_is(N-1)</code></p>

<p>\end{align} </p>

<p>Comparing to the power spectrum application, the only difference is the calculation used to finish.</p>
<pre><code>(Same IIR filter calculations as in the signal power implementation)
XKreal = sprev * cr - sprev2;
XKimag = sprev * ci;</code></pre>
<h3 id="phase-detection">Phase detection</h3>

<p>This application requires the same evaluation of DFT term 

<math display="inline" id="Goertzel_algorithm:48">
 <semantics>
  <mrow>
   <mi>X</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>K</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>X</ci>
    <ci>K</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X(K)
  </annotation>
 </semantics>
</math>

, as discussed in the previous section, using a real-valued or complex-valued input stream. Then the signal phase can be evaluated as:</p>
<dl>
<dd>(14) 

<math display="inline" id="Goertzel_algorithm:49">
 <semantics>
  <mrow>
   <mi>ϕ</mi>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>tan</mi>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <mfrac>
     <mrow>
      <mi mathvariant="normal">ℑ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>X</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>K</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mrow>
      <mi mathvariant="normal">ℜ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>X</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>K</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mfrac>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>ϕ</ci>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <tan></tan>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <imaginary></imaginary>
       <apply>
        <times></times>
        <ci>X</ci>
        <ci>K</ci>
       </apply>
      </apply>
      <apply>
       <real></real>
       <apply>
        <times></times>
        <ci>X</ci>
        <ci>K</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi=\tan^{-1}\frac{\Im(X(K))}{\Re(X(K))}
  </annotation>
 </semantics>
</math>


</dd>
</dl>

<p>taking appropriate precautions for singularities, quadrant, and so forth when computing the inverse tangent function.</p>
<h3 id="complex-signals-in-real-arithmetic">Complex signals in real arithmetic</h3>

<p>Since complex signals decompose linearly into real and imaginary parts, the Goertzel algorithm can be computed in real arithmetic separately over the sequence of real parts, yielding 

<math display="inline" id="Goertzel_algorithm:50">
 <semantics>
  <mrow>
   <msub>
    <mi>y</mi>
    <mi>r</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <ci>r</ci>
    </apply>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{r}(n)
  </annotation>
 </semantics>
</math>

; and over the sequence of imaginary parts, yielding 

<math display="inline" id="Goertzel_algorithm:51">
 <semantics>
  <mrow>
   <msub>
    <mi>y</mi>
    <mi>i</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <ci>i</ci>
    </apply>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{i}(n)
  </annotation>
 </semantics>
</math>

. After that, the two complex-valued partial results can be recombined:</p>
<dl>
<dd>(15) 

<math display="inline" id="Goertzel_algorithm:52">
 <semantics>
  <mrow>
   <mrow>
    <mi>y</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>y</mi>
      <mi>r</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mpadded width="+5pt">
      <mi>i</mi>
     </mpadded>
     <msub>
      <mi>y</mi>
      <mi>i</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>y</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <ci>r</ci>
      </apply>
      <ci>n</ci>
     </apply>
     <apply>
      <times></times>
      <ci>i</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <ci>i</ci>
      </apply>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y(n)=y_{r}(n)+i\ y_{i}(n)
  </annotation>
 </semantics>
</math>


</dd>
</dl>
<h2 id="computational-complexity">Computational complexity</h2>
<ul>
<li>According to <a href="computational_complexity_theory" title="wikilink">computational complexity theory</a>, computing a set of 

<math display="inline" id="Goertzel_algorithm:53">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 DFT terms using 

<math display="inline" id="Goertzel_algorithm:54">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 applications of the Goertzel algorithm on a data set with 

<math display="inline" id="Goertzel_algorithm:55">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

 values with a "cost per operation" of 

<math display="inline" id="Goertzel_algorithm:56">
 <semantics>
  <mi>K</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>K</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K
  </annotation>
 </semantics>
</math>

 has <a href="big_O_notation" title="wikilink">complexity</a> 

<math display="inline" id="Goertzel_algorithm:57">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>K</mi>
     <mi>N</mi>
     <mi>M</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>K</ci>
     <ci>N</ci>
     <ci>M</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(KNM)
  </annotation>
 </semantics>
</math>

.</li>
</ul>
<dl>
<dd>To compute a single <a href="Discrete_Fourier_transform" title="wikilink">DFT</a> bin 

<math display="inline" id="Goertzel_algorithm:58">
 <semantics>
  <mrow>
   <mi>X</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>f</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>X</ci>
    <ci>f</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X(f)
  </annotation>
 </semantics>
</math>

 for a complex input sequence of length 

<math display="inline" id="Goertzel_algorithm:59">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

, the Goertzel algorithm requires 

<math display="inline" id="Goertzel_algorithm:60">
 <semantics>
  <mrow>
   <mn>2</mn>
   <mi>N</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <cn type="integer">2</cn>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2N
  </annotation>
 </semantics>
</math>

 multiplications and 

<math display="inline" id="Goertzel_algorithm:61">
 <semantics>
  <mrow>
   <mpadded width="+5pt">
    <mn>4</mn>
   </mpadded>
   <mi>N</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <cn type="integer">4</cn>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   4\ N
  </annotation>
 </semantics>
</math>

 additions/subtractions within the loop, as well as 4 multiplications and 4 final additions/subtractions, for a total of 

<math display="inline" id="Goertzel_algorithm:62">
 <semantics>
  <mrow>
   <mrow>
    <mn>2</mn>
    <mi>N</mi>
   </mrow>
   <mo>+</mo>
   <mn>4</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <times></times>
     <cn type="integer">2</cn>
     <ci>N</ci>
    </apply>
    <cn type="integer">4</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2N+4
  </annotation>
 </semantics>
</math>

 multiplications and 

<math display="inline" id="Goertzel_algorithm:63">
 <semantics>
  <mrow>
   <mrow>
    <mn>4</mn>
    <mi>N</mi>
   </mrow>
   <mo>+</mo>
   <mn>4</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <times></times>
     <cn type="integer">4</cn>
     <ci>N</ci>
    </apply>
    <cn type="integer">4</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   4N+4
  </annotation>
 </semantics>
</math>

 additions/subtractions. This is repeated for each of the 

<math display="inline" id="Goertzel_algorithm:64">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 frequencies.
</dd>
</dl>
<ul>
<li>In contrast, using an <a href="Fast_Fourier_transform" title="wikilink">FFT</a> on a data set with 

<math display="inline" id="Goertzel_algorithm:65">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

 values has complexity 

<math display="inline" id="Goertzel_algorithm:66">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>K</mi>
     <mi>N</mi>
     <mrow>
      <mi>log</mi>
      <mi>N</mi>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>K</ci>
     <ci>N</ci>
     <apply>
      <log></log>
      <ci>N</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(KN\log N)
  </annotation>
 </semantics>
</math>

. </li>
</ul>
<dl>
<dd>This is harder to apply directly because it depends on the FFT algorithm used, but a typical  example is a radix-2 FFT, which requires 

<math display="inline" id="Goertzel_algorithm:67">
 <semantics>
  <mrow>
   <mn>2</mn>
   <mrow>
    <msub>
     <mi>log</mi>
     <mn>2</mn>
    </msub>
    <mi>N</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <cn type="integer">2</cn>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <log></log>
      <cn type="integer">2</cn>
     </apply>
     <ci>N</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2\log_{2}N
  </annotation>
 </semantics>
</math>

 multiplications and 

<math display="inline" id="Goertzel_algorithm:68">
 <semantics>
  <mrow>
   <mn>3</mn>
   <mrow>
    <msub>
     <mi>log</mi>
     <mn>2</mn>
    </msub>
    <mi>N</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <cn type="integer">3</cn>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <log></log>
      <cn type="integer">2</cn>
     </apply>
     <ci>N</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   3\log_{2}N
  </annotation>
 </semantics>
</math>

 additions/subtractions per <a href="Discrete_Fourier_transform" title="wikilink">DFT</a> bin, for each of the 

<math display="inline" id="Goertzel_algorithm:69">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

 bins. 
</dd>
</dl>

<p>In the complexity order expressions, when the number of calculated terms 

<math display="inline" id="Goertzel_algorithm:70">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 is smaller than 

<math display="inline" id="Goertzel_algorithm:71">
 <semantics>
  <mrow>
   <mi>log</mi>
   <mi>N</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <log></log>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \log N
  </annotation>
 </semantics>
</math>

, the advantage of the Goertzel algorithm is clear. But because FFT code is comparatively complex, the "cost per unit of work" factor 

<math display="inline" id="Goertzel_algorithm:72">
 <semantics>
  <mi>K</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>K</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K
  </annotation>
 </semantics>
</math>

 is often larger for an FFT, and the practical advantage favours the Goertzel algorithm even for 

<math display="inline" id="Goertzel_algorithm:73">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 several times larger than 

<math display="inline" id="Goertzel_algorithm:74">
 <semantics>
  <mrow>
   <msub>
    <mi>log</mi>
    <mn>2</mn>
   </msub>
   <mi>N</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <log></log>
     <cn type="integer">2</cn>
    </apply>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \log_{2}N
  </annotation>
 </semantics>
</math>

.</p>

<p>As a rule-of-thumb for determining whether a radix-2 FFT or a Goertzel algorithm is more efficient, adjust the number of terms N in the data set upward to the nearest exact power of 2, calling this 

<math display="inline" id="Goertzel_algorithm:75">
 <semantics>
  <msub>
   <mi>N</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>N</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N_{2}
  </annotation>
 </semantics>
</math>

, and the Goertzel algorithm is likely to be faster if</p>

<p>

<math display="block" id="Goertzel_algorithm:76">
 <semantics>
  <mrow>
   <mi>M</mi>
   <mo>≤</mo>
   <mrow>
    <mfrac>
     <mrow>
      <mn>5</mn>
      <msub>
       <mi>N</mi>
       <mn>2</mn>
      </msub>
     </mrow>
     <mrow>
      <mn>6</mn>
      <mi>N</mi>
     </mrow>
    </mfrac>
    <mrow>
     <msub>
      <mi>log</mi>
      <mn>2</mn>
     </msub>
     <msub>
      <mi>N</mi>
      <mn>2</mn>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <ci>M</ci>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <cn type="integer">5</cn>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>N</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <cn type="integer">6</cn>
       <ci>N</ci>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <log></log>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>N</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M\leq\frac{5N_{2}}{6N}\log_{2}N_{2}
  </annotation>
 </semantics>
</math>

 </p>

<p>FFT implementations and processing platforms have a significant impact on the relative performance. Some FFT implementations<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> perform internal complex-number calculations to generate coefficients on-the-fly, significantly increasing their "cost K per unit of work." FFT and DFT algorithms can use tables of pre-computed coefficient values for better numerical efficiency, but this requires more accesses to coefficient values buffered in external memory, which can lead to increased cache contention that counters some of the numerical advantage. </p>

<p>Both algorithms  gain approximately a factor of 2 efficiency  when using real-valued rather than complex-valued input data. However, these gains are natural for the Goertzel algorithm but will not be achieved for the FFT without using certain algorithm variants  specialised for <a href="Fast_Fourier_transform" title="wikilink">transforming real-valued data</a>.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Bluestein's_FFT_algorithm" title="wikilink">Bluestein's FFT algorithm</a> (chirp-Z)</li>
<li><a href="Frequency-shift_keying" title="wikilink">Frequency-Shift Keying</a> (FSK)</li>
<li><a href="Phase-shift_keying" title="wikilink">Phase-Shift Keying</a> (PSK)</li>
</ul>
<h2 id="references">References</h2>
<h2 id="further-reading">Further reading</h2>
<ul>
<li></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a class="uri" href="http://netwerkt.wordpress.com/2011/08/25/goertzel-filter/">http://netwerkt.wordpress.com/2011/08/25/goertzel-filter/</a> C Code implementation of iterative Goertzel algorithm</li>
<li><a class="uri" href="http://www.embedded.com/design/configurable-systems/4006427/A-DSP-algorithm-for-frequency-analysis">http://www.embedded.com/design/configurable-systems/4006427/A-DSP-algorithm-for-frequency-analysis</a> (<a href="http://www.embedded.com/design/embedded/source-code/4209925/02Sirin-txt">Java</a>) A DSP algorithm for frequency analysis - the Chirp-Z Transform (CZT)</li>
</ul>

<p>"</p>

<p><a href="Category:FFT_algorithms" title="wikilink">Category:FFT algorithms</a> <a href="Category:Digital_signal_processing" title="wikilink">Category:Digital signal processing</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2">; also found in DSP Applications with the TMS320 Family, Vol. 1, Texas Instruments, 1989.<a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a class="uri" href="http://cs-www.cs.yale.edu/c2/images/uploads/AudioProc-TR.pdf">http://cs-www.cs.yale.edu/c2/images/uploads/AudioProc-TR.pdf</a><a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
<li id="fn10"><a href="#fnref10">↩</a></li>
</ol>
</section>
</body>
</html>
