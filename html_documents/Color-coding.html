<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="358">Color-coding</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Color-coding</h1>
<hr/>

<p>In <a href="computer_science" title="wikilink">computer science</a> and <a href="graph_theory" title="wikilink">graph theory</a>, the method of <strong>color-coding</strong><a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a><a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> efficiently finds 

<math display="inline" id="Color-coding:0">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

-vertex <a href="Path_(graph_theory)" title="wikilink">simple paths</a>, 

<math display="inline" id="Color-coding:1">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

-vertex <a href="Cycle_(graph_theory)" title="wikilink">cycles</a>, and other small <a href="Glossary_of_graph_theory#Subgraphs" title="wikilink">subgraphs</a> within a given <a href="graph_theory" title="wikilink">graph</a> using <a href="probabilistic_algorithms" title="wikilink">probabilistic algorithms</a>, which can then be <a href="Derandomization#Derandomization" title="wikilink">derandomized</a> and turned into <a href="deterministic_algorithm" title="wikilink">deterministic algorithms</a>. This method shows that many subcases of the <a href="subgraph_isomorphism" title="wikilink">subgraph isomorphism problem</a> (an <a class="uri" href="NP-complete" title="wikilink">NP-complete</a> problem) can in fact be solved in <a href="polynomial_time" title="wikilink">polynomial time</a>.</p>

<p>The theory and analysis of the color-coding method was proposed in 1994 by <a href="Noga_Alon" title="wikilink">Noga Alon</a>, <a href="Raphael_Yuster" title="wikilink">Raphael Yuster</a>, and <a href="Uri_Zwick" title="wikilink">Uri Zwick</a>.</p>
<h2 id="results">Results</h2>

<p>The following results can be obtained through the method of color-coding:</p>
<ul>
<li>For every fixed constant 

<math display="inline" id="Color-coding:2">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

, if a graph 

<math display="inline" id="Color-coding:3">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>V</mi>
    <mo>,</mo>
    <mi>E</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>G</ci>
    <interval closure="open">
     <ci>V</ci>
     <ci>E</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G=(V,E)
  </annotation>
 </semantics>
</math>


 contains a simple cycle of size 

<math display="inline" id="Color-coding:4">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

, then such cycle can be found in:
<ul>
<li>O(

<math display="inline" id="Color-coding:5">
 <semantics>
  <msup>
   <mi>V</mi>
   <mi>ω</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>V</ci>
    <ci>ω</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V^{\omega}
  </annotation>
 </semantics>
</math>

) expected time, or</li>
<li>O(

<math display="inline" id="Color-coding:6">
 <semantics>
  <mrow>
   <msup>
    <mi>V</mi>
    <mi>ω</mi>
   </msup>
   <mrow>
    <mi>log</mi>
    <mi>V</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>V</ci>
     <ci>ω</ci>
    </apply>
    <apply>
     <log></log>
     <ci>V</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V^{\omega}\log V
  </annotation>
 </semantics>
</math>

) worst-case time, where 

<math display="inline" id="Color-coding:7">
 <semantics>
  <mi>ω</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ω</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ω
  </annotation>
 </semantics>
</math>

 is the exponent of <a href="matrix_multiplication" title="wikilink">matrix multiplication</a>.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></li>
</ul></li>
</ul>
<ul>
<li>For every fixed constant 

<math display="inline" id="Color-coding:8">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>


, and every graph 

<math display="inline" id="Color-coding:9">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>V</mi>
    <mo>,</mo>
    <mi>E</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>G</ci>
    <interval closure="open">
     <ci>V</ci>
     <ci>E</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G=(V,E)
  </annotation>
 </semantics>
</math>

 that is in any nontrivial <a href="Minor_(graph_theory)#Minor-closed_graph_families" title="wikilink">minor-closed graph family</a> (e.g., a <a href="planar_graph" title="wikilink">planar graph</a>), if 

<math display="inline" id="Color-coding:10">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

 contains a simple cycle of size 

<math display="inline" id="Color-coding:11">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

, then such cycle can be found in:
<ul>
<li>

<math display="inline" id="Color-coding:12">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>V</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <ci>V</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(V)
  </annotation>
 </semantics>
</math>

 expected time, or</li>
<li>

<math display="inline" id="Color-coding:13">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>V</mi>
     <mi>l</mi>
     <mi>o</mi>
     <mi>g</mi>
     <mi>V</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>V</ci>
     <ci>l</ci>
     <ci>o</ci>
     <ci>g</ci>
     <ci>V</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(VlogV)
  </annotation>
 </semantics>
</math>


 worst-case time.</li>
</ul></li>
</ul>
<ul>
<li>If a graph 

<math display="inline" id="Color-coding:14">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>V</mi>
    <mo>,</mo>
    <mi>E</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>G</ci>
    <interval closure="open">
     <ci>V</ci>
     <ci>E</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G=(V,E)
  </annotation>
 </semantics>
</math>

 contains a subgraph isomorphic to a bounded <a class="uri" href="treewidth" title="wikilink">treewidth</a> graph which has 

<math display="inline" id="Color-coding:15">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>l</mi>
     <mi>o</mi>
     <mi>g</mi>
     <mi>V</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>l</ci>
     <ci>o</ci>
     <ci>g</ci>
     <ci>V</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(logV)
  </annotation>
 </semantics>
</math>

 vertices, then such a subgraph can be found in <a href="polynomial_time" title="wikilink">polynomial time</a>.</li>
</ul>
<h2 id="the-method">The method</h2>

<p>To solve the problem of finding a subgraph 

<math display="inline" id="Color-coding:16">
 <semantics>
  <mrow>
   <mi>H</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>V</mi>
     <mi>H</mi>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>E</mi>
     <mi>H</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>H</ci>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>V</ci>
      <ci>H</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>E</ci>
      <ci>H</ci>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H=(V_{H},E_{H})
  </annotation>
 </semantics>
</math>

 in a given graph 

<math display="inline" id="Color-coding:17">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>V</mi>
    <mo>,</mo>
    <mi>E</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>G</ci>
    <interval closure="open">
     <ci>V</ci>
     <ci>E</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G=(V,E)
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Color-coding:18">
 <semantics>
  <mi>H</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>H</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H
  </annotation>
 </semantics>
</math>


 can be a path, a cycle, or any bounded <a class="uri" href="treewidth" title="wikilink">treewidth</a> graph where 

<math display="inline" id="Color-coding:19">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">|</mo>
    <msub>
     <mi>V</mi>
     <mi>H</mi>
    </msub>
    <mo stretchy="false">|</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>O</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>log</mi>
      <mi>V</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <abs></abs>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>V</ci>
      <ci>H</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>O</ci>
     <apply>
      <log></log>
      <ci>V</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |V_{H}|=O(\log V)
  </annotation>
 </semantics>
</math>

, the method of color-coding begins by randomly coloring each vertex of 

<math display="inline" id="Color-coding:20">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

 with 

<math display="inline" id="Color-coding:21">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">|</mo>
    <msub>
     <mi>V</mi>
     <mi>H</mi>
    </msub>
    <mo stretchy="false">|</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>k</ci>
    <apply>
     <abs></abs>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>V</ci>
      <ci>H</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k=|V_{H}|
  </annotation>
 </semantics>
</math>

 colors, and then tries to find a colorful copy of 

<math display="inline" id="Color-coding:22">
 <semantics>
  <mi>H</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>H</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H
  </annotation>
 </semantics>
</math>

 in colored 

<math display="inline" id="Color-coding:23">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>


. Here, a graph is colorful if every vertex in it is colored with a distinct color. This method works by repeating (1) random coloring a graph and (2) finding colorful copy of the target subgraph, and eventually the target subgraph can be found if the process is repeated a sufficient number of times.</p>

<p>Suppose 

<math display="inline" id="Color-coding:24">
 <semantics>
  <mi>H</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>H</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H
  </annotation>
 </semantics>
</math>

 becomes colorful with some non-zero probability 

<math display="inline" id="Color-coding:25">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

. It immediately follows that if the random coloring is repeated 

<math display="inline" id="Color-coding:26">
 <semantics>
  <mfrac>
   <mn>1</mn>
   <mi>p</mi>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <cn type="integer">1</cn>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{1}{p}
  </annotation>
 </semantics>
</math>

 times, then 

<math display="inline" id="Color-coding:27">
 <semantics>
  <mi>H</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>H</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H
  </annotation>
 </semantics>
</math>

 is expected to become colorful once. Note that though 

<math display="inline" id="Color-coding:28">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>


 is small, it is shown that if 

<math display="inline" id="Color-coding:29">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">|</mo>
    <msub>
     <mi>V</mi>
     <mi>H</mi>
    </msub>
    <mo stretchy="false">|</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>O</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>log</mi>
      <mi>V</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <abs></abs>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>V</ci>
      <ci>H</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>O</ci>
     <apply>
      <log></log>
      <ci>V</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |V_{H}|=O(\log V)
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Color-coding:30">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 is only polynomially small. Suppose again there exists an algorithm such that, given a graph 

<math display="inline" id="Color-coding:31">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

 and a coloring which maps each vertex of 

<math display="inline" id="Color-coding:32">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

 to one of the 

<math display="inline" id="Color-coding:33">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>


 colors, it finds a copy of colorful 

<math display="inline" id="Color-coding:34">
 <semantics>
  <mi>H</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>H</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H
  </annotation>
 </semantics>
</math>

, if one exists, within some runtime 

<math display="inline" id="Color-coding:35">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>r</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <ci>r</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(r)
  </annotation>
 </semantics>
</math>

. Then the expected time to find a copy of 

<math display="inline" id="Color-coding:36">
 <semantics>
  <mi>H</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>H</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H
  </annotation>
 </semantics>
</math>

 in 

<math display="inline" id="Color-coding:37">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

, if one exists, is 

<math display="inline" id="Color-coding:38">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mfrac>
     <mi>r</mi>
     <mi>p</mi>
    </mfrac>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <divide></divide>
     <ci>r</ci>
     <ci>p</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(\tfrac{r}{p})
  </annotation>
 </semantics>
</math>


.</p>

<p>Sometimes it is also desirable to use a more restricted version of colorfulness. For example, in the context of finding cycles in <a href="planar_graphs" title="wikilink">planar graphs</a>, it is possible to develop an algorithm that finds well-colored cycles. Here, a cycle is well-colored if its vertices are colored by consecutive colors.</p>
<h3 id="example">Example</h3>

<p>An example would be finding a simple cycle of length 

<math display="inline" id="Color-coding:39">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 in graph 

<math display="inline" id="Color-coding:40">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>V</mi>
    <mo>,</mo>
    <mi>E</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>G</ci>
    <interval closure="open">
     <ci>V</ci>
     <ci>E</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G=(V,E)
  </annotation>
 </semantics>
</math>

.</p>

<p>By applying random coloring method, each simple cycle has a probability of 

<math display="inline" id="Color-coding:41">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>k</mi>
     <mo lspace="0pt" rspace="3.5pt">!</mo>
    </mrow>
    <mo>/</mo>
    <msup>
     <mi>k</mi>
     <mi>k</mi>
    </msup>
   </mrow>
   <mo>></mo>
   <msup>
    <mi>e</mi>
    <mrow>
     <mo>-</mo>
     <mi>k</mi>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <apply>
     <divide></divide>
     <apply>
      <factorial></factorial>
      <ci>k</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>k</ci>
      <ci>k</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>e</ci>
     <apply>
      <minus></minus>
      <ci>k</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k!/k^{k}>e^{-k}
  </annotation>
 </semantics>
</math>

 to become colorful, since there are 

<math display="inline" id="Color-coding:42">
 <semantics>
  <msup>
   <mi>k</mi>
   <mi>k</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>k</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k^{k}
  </annotation>
 </semantics>
</math>

 ways of coloring the 

<math display="inline" id="Color-coding:43">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>


 vertices on the path, among which there are 

<math display="inline" id="Color-coding:44">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo lspace="0pt" rspace="3.5pt">!</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <factorial></factorial>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k!
  </annotation>
 </semantics>
</math>

 colorful occurrences. Then an algorithm (described below) of runtime 

<math display="inline" id="Color-coding:45">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>V</mi>
     <mi>ω</mi>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>V</ci>
     <ci>ω</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(V^{\omega})
  </annotation>
 </semantics>
</math>

 can be adopted to find colorful cycles in the randomly colored graph 

<math display="inline" id="Color-coding:46">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

. Therefore, it takes 

<math display="inline" id="Color-coding:47">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>e</mi>
     <mi>k</mi>
    </msup>
    <mo>⋅</mo>
    <mi>O</mi>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>V</mi>
     <mi>ω</mi>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <ci>normal-⋅</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>e</ci>
      <ci>k</ci>
     </apply>
     <ci>O</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>V</ci>
     <ci>ω</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e^{k}\cdot O(V^{\omega})
  </annotation>
 </semantics>
</math>

 overall time to find a simple cycle of length 

<math display="inline" id="Color-coding:48">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>


 in 

<math display="inline" id="Color-coding:49">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

.</p>

<p>The colorful cycle-finding algorithm works by first finding all pairs of vertices in 

<math display="inline" id="Color-coding:50">
 <semantics>
  <mi>V</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>V</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V
  </annotation>
 </semantics>
</math>

 that are connected by a simple path of length 

<math display="inline" id="Color-coding:51">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mi mathvariant="normal">−</mi>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>k</ci>
    <ci>normal-−</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k−1
  </annotation>
 </semantics>
</math>

, and then checking whether the two vertices in each pair are connected. Given a coloring function  to color graph 

<math display="inline" id="Color-coding:52">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

, enumerate all partitions of the color set  into two subsets <mtpl></mtpl> of size 

<math display="inline" id="Color-coding:53">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>/</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <ci>k</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k/2
  </annotation>
 </semantics>
</math>


 each. Note that 

<math display="inline" id="Color-coding:54">
 <semantics>
  <mi>V</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>V</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V
  </annotation>
 </semantics>
</math>

 can be divided into <mtpl></mtpl> and <mtpl></mtpl> accordingly, and let <mtpl></mtpl> and <mtpl></mtpl> denote the subgraphs induced by <mtpl></mtpl> and <mtpl></mtpl> respectively. Then, recursively find colorful paths of length 

<math display="inline" id="Color-coding:55">
 <semantics>
  <mrow>
   <mrow>
    <mi>k</mi>
    <mo>/</mo>
    <mn>2</mn>
   </mrow>
   <mo>-</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <apply>
     <divide></divide>
     <ci>k</ci>
     <cn type="integer">2</cn>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k/2-1
  </annotation>
 </semantics>
</math>

 in each of <mtpl></mtpl> and <mtpl></mtpl>. Suppose the boolean matrix <mtpl></mtpl> and <mtpl></mtpl> represent the connectivity of each pair of vertices in <mtpl></mtpl> and <mtpl></mtpl> by a colorful path, respectively, and let 

<math display="inline" id="Color-coding:56">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

 be the matrix describing the adjacency relations between vertices of <mtpl></mtpl> and those of <mtpl></mtpl>, the boolean product 

<math display="inline" id="Color-coding:57">
 <semantics>
  <mrow>
   <msub>
    <mi>A</mi>
    <mn>1</mn>
   </msub>
   <mi>B</mi>
   <msub>
    <mi>A</mi>
    <mn>2</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>A</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>B</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>A</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{1}BA_{2}
  </annotation>
 </semantics>
</math>

 gives all pairs of vertices in 

<math display="inline" id="Color-coding:58">
 <semantics>
  <mi>V</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>V</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V
  </annotation>
 </semantics>
</math>


 that are connected by a colorful path of length 

<math display="inline" id="Color-coding:59">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mi mathvariant="normal">−</mi>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>k</ci>
    <ci>normal-−</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k−1
  </annotation>
 </semantics>
</math>

. Thus, the recursive relation of matrix multiplications is 

<math display="inline" id="Color-coding:60">
 <semantics>
  <mrow>
   <mrow>
    <mi>t</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>k</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mrow>
     <msup>
      <mn>2</mn>
      <mi>k</mi>
     </msup>
     <mo>⋅</mo>
     <mi>t</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>k</mi>
      <mo>/</mo>
      <mn>2</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <times></times>
     <ci>t</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <ci>normal-⋅</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">2</cn>
       <ci>k</ci>
      </apply>
      <ci>t</ci>
     </apply>
     <apply>
      <divide></divide>
      <ci>k</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t(k)\leq 2^{k}\cdot t(k/2)
  </annotation>
 </semantics>
</math>

, which yields a runtime of 

<math display="inline" id="Color-coding:61">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mn>2</mn>
     <mrow>
      <mi>O</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>k</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </msup>
    <mo>⋅</mo>
    <msup>
     <mi>V</mi>
     <mi>ω</mi>
    </msup>
   </mrow>
   <mo>∈</mo>
   <mrow>
    <mi>O</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>V</mi>
      <mi>ω</mi>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <ci>normal-⋅</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <apply>
       <times></times>
       <ci>O</ci>
       <ci>k</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>V</ci>
      <ci>ω</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>O</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>V</ci>
      <ci>ω</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{O(k)}\cdot V^{\omega}\in O(V^{\omega})
  </annotation>
 </semantics>
</math>

. Although this algorithm finds only the end points of the colorful path, another algorithm by Alon and Naor<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> that finds colorful paths themselves can be incorporated into it.</p>
<h2 id="derandomization">Derandomization</h2>

<p>The <a class="uri" href="derandomization" title="wikilink">derandomization</a> of color-coding involves enumerating possible colorings of a graph 

<math display="inline" id="Color-coding:62">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

, such that the randomness of coloring 

<math display="inline" id="Color-coding:63">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>


 is no longer required. For the target subgraph 

<math display="inline" id="Color-coding:64">
 <semantics>
  <mi>H</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>H</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H
  </annotation>
 </semantics>
</math>

 in 

<math display="inline" id="Color-coding:65">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

 to be discoverable, the enumeration has to include at least one instance where the 

<math display="inline" id="Color-coding:66">
 <semantics>
  <mi>H</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>H</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H
  </annotation>
 </semantics>
</math>

 is colorful. To achieve this, enumerating a 

<math display="inline" id="Color-coding:67">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

-perfect family 

<math display="inline" id="Color-coding:68">
 <semantics>
  <mi>F</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>F</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F
  </annotation>
 </semantics>
</math>


 of hash functions from  to  is sufficient. By definition, 

<math display="inline" id="Color-coding:69">
 <semantics>
  <mi>F</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>F</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F
  </annotation>
 </semantics>
</math>

 is 

<math display="inline" id="Color-coding:70">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

-perfect if for every subset 

<math display="inline" id="Color-coding:71">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 of  where 

<math display="inline" id="Color-coding:72">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">|</mo>
    <mi>S</mi>
    <mo stretchy="false">|</mo>
   </mrow>
   <mo>=</mo>
   <mi>k</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <abs></abs>
     <ci>S</ci>
    </apply>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |S|=k
  </annotation>
 </semantics>
</math>

, there exists a hash function 

<math display="inline" id="Color-coding:73">
 <semantics>
  <mi>h</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>h</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h
  </annotation>
 </semantics>
</math>


 in 

<math display="inline" id="Color-coding:74">
 <semantics>
  <mi>F</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>F</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F
  </annotation>
 </semantics>
</math>

 such that  is <a href="perfect_hash" title="wikilink">perfect</a>. In other words, there must exist a hash function in 

<math display="inline" id="Color-coding:75">
 <semantics>
  <mi>F</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>F</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F
  </annotation>
 </semantics>
</math>

 that colors any given 

<math display="inline" id="Color-coding:76">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 vertices with 

<math display="inline" id="Color-coding:77">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 distinct colors.</p>

<p>There are several approaches to construct such a 

<math display="inline" id="Color-coding:78">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>


-perfect hash family:</p>
<ol>
<li>The best explicit construction is by <a href="Moni_Naor" title="wikilink">Moni Naor</a>, <a href="Leonard_J._Schulman" title="wikilink">Leonard J. Schulman</a>, and <a href="Aravind_Srinivasan" title="wikilink">Aravind Srinivasan</a>,<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> where a family of size 

<math display="inline" id="Color-coding:79">
 <semantics>
  <mrow>
   <msup>
    <mi>e</mi>
    <mi>k</mi>
   </msup>
   <msup>
    <mi>k</mi>
    <mrow>
     <mi>O</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>log</mi>
       <mi>k</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </msup>
   <mrow>
    <mi>log</mi>
    <mrow>
     <mo stretchy="false">|</mo>
     <mi>V</mi>
     <mo stretchy="false">|</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>e</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>k</ci>
     <apply>
      <times></times>
      <ci>O</ci>
      <apply>
       <log></log>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <log></log>
     <apply>
      <abs></abs>
      <ci>V</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e^{k}k^{O(\log k)}\log|V|
  </annotation>
 </semantics>
</math>

 can be obtained. This construction does not require the target subgraph to exist in the original subgraph finding problem.</li>
<li>Another explicit construction by <a href="Jeanette_P._Schmidt" title="wikilink">Jeanette P. Schmidt</a> and Alan Siegel<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> yields a family of size 

<math display="inline" id="Color-coding:80">
 <semantics>
  <mrow>
   <msup>
    <mn>2</mn>
    <mrow>
     <mi>O</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>k</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </msup>
   <mrow>
    <msup>
     <mi>log</mi>
     <mn>2</mn>
    </msup>
    <mrow>
     <mo stretchy="false">|</mo>
     <mi>V</mi>
     <mo stretchy="false">|</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <apply>
      <times></times>
      <ci>O</ci>
      <ci>k</ci>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <log></log>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <abs></abs>
      <ci>V</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{O(k)}\log^{2}|V|
  </annotation>
 </semantics>
</math>

.</li>
<li>Another construction that appears in the original paper of <a href="Noga_Alon" title="wikilink">Noga Alon</a> et al.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> can be obtained by first building a 

<math display="inline" id="Color-coding:81">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

-perfect family that maps  to  followed by building another 

<math display="inline" id="Color-coding:82">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

-perfect family that maps  to  In the first step, it is possible to construct such a family with 

<math display="inline" id="Color-coding:83">
 <semantics>
  <mrow>
   <mn>2</mn>
   <mi>n</mi>
   <mi>l</mi>
   <mi>o</mi>
   <mi>g</mi>
   <mi>k</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <cn type="integer">2</cn>
    <ci>n</ci>
    <ci>l</ci>
    <ci>o</ci>
    <ci>g</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2nlogk
  </annotation>
 </semantics>
</math>


 random bits that are almost 

<math display="inline" id="Color-coding:84">
 <semantics>
  <mrow>
   <mn>2</mn>
   <mi>l</mi>
   <mi>o</mi>
   <mi>g</mi>
   <mi>k</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <cn type="integer">2</cn>
    <ci>l</ci>
    <ci>o</ci>
    <ci>g</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2logk
  </annotation>
 </semantics>
</math>

-wise independent,<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a><a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> and the sample space needed for generating those random bits can be as small as 

<math display="inline" id="Color-coding:85">
 <semantics>
  <mrow>
   <msup>
    <mi>k</mi>
    <mrow>
     <mi>O</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>1</mn>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </msup>
   <mrow>
    <mi>log</mi>
    <mrow>
     <mo stretchy="false">|</mo>
     <mi>V</mi>
     <mo stretchy="false">|</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>k</ci>
     <apply>
      <times></times>
      <ci>O</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <log></log>
     <apply>
      <abs></abs>
      <ci>V</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k^{O(1)}\log|V|
  </annotation>
 </semantics>
</math>

. In the second step, it has been shown by Jeanette P. Schmidt and Alan Siegel<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> that the size of such 

<math display="inline" id="Color-coding:86">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

-perfect family can be 

<math display="inline" id="Color-coding:87">
 <semantics>
  <msup>
   <mn>2</mn>
   <mrow>
    <mi>O</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>k</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <apply>
     <times></times>
     <ci>O</ci>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{O(k)}
  </annotation>
 </semantics>
</math>

. Consequently, by composing the 

<math display="inline" id="Color-coding:88">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>


-perfect families from both steps, a 

<math display="inline" id="Color-coding:89">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

-perfect family of size 

<math display="inline" id="Color-coding:90">
 <semantics>
  <mrow>
   <msup>
    <mn>2</mn>
    <mrow>
     <mi>O</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>k</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </msup>
   <mrow>
    <mi>log</mi>
    <mrow>
     <mo stretchy="false">|</mo>
     <mi>V</mi>
     <mo stretchy="false">|</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <apply>
      <times></times>
      <ci>O</ci>
      <ci>k</ci>
     </apply>
    </apply>
    <apply>
     <log></log>
     <apply>
      <abs></abs>
      <ci>V</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{O(k)}\log|V|
  </annotation>
 </semantics>
</math>

 that maps from  to  can be obtained.</li>
</ol>

<p>In the case of derandomizing well-coloring, where each vertex on the subgraph is colored consecutively, a 

<math display="inline" id="Color-coding:91">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

-perfect family of hash functions from  to  is needed. A sufficient 

<math display="inline" id="Color-coding:92">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

-perfect family which maps from  to  can be constructed in a way similar to the approach 3 above (the first step). In particular, it is done by using 

<math display="inline" id="Color-coding:93">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mi>k</mi>
   <mi>l</mi>
   <mi>o</mi>
   <mi>g</mi>
   <mi>k</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>n</ci>
    <ci>k</ci>
    <ci>l</ci>
    <ci>o</ci>
    <ci>g</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   nklogk
  </annotation>
 </semantics>
</math>


 random bits that are almost 

<math display="inline" id="Color-coding:94">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mi>l</mi>
   <mi>o</mi>
   <mi>g</mi>
   <mi>k</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>k</ci>
    <ci>l</ci>
    <ci>o</ci>
    <ci>g</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   klogk
  </annotation>
 </semantics>
</math>

 independent, and the size of the resulting 

<math display="inline" id="Color-coding:95">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

-perfect family will be 

<math display="inline" id="Color-coding:96">
 <semantics>
  <mrow>
   <msup>
    <mi>k</mi>
    <mrow>
     <mi>O</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>k</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </msup>
   <mrow>
    <mi>log</mi>
    <mrow>
     <mo stretchy="false">|</mo>
     <mi>V</mi>
     <mo stretchy="false">|</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>k</ci>
     <apply>
      <times></times>
      <ci>O</ci>
      <ci>k</ci>
     </apply>
    </apply>
    <apply>
     <log></log>
     <apply>
      <abs></abs>
      <ci>V</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k^{O(k)}\log|V|
  </annotation>
 </semantics>
</math>

.</p>

<p>The derandomization of color-coding method can be easily parallelized, yielding efficient <a href="NC_(complexity)" title="wikilink">NC</a> algorithms.</p>
<h2 id="applications">Applications</h2>

<p>Recently, color-coding has attracted much attention in the field of bioinformatics. One example is the detection of <a href="Wnt_signaling_pathway" title="wikilink">signaling pathways</a> in <a href="protein-protein_interaction" title="wikilink">protein-protein interaction</a> (PPI) networks. Another example is to discover and to count the number of <a href="Structural_motif" title="wikilink">motifs</a> in PPI networks. Studying both <a href="Wnt_signaling_pathway" title="wikilink">signaling pathways</a> and <a href="Structural_motif" title="wikilink">motifs</a> allows a deeper understanding of the similarities and differences of many biological functions, processes, and structures among organisms.</p>

<p>Due to the huge amount of gene data that can be collected, searching for pathways or motifs can be highly time consuming. However, by exploiting the color-coding method, the motifs or signaling pathways with 

<math display="inline" id="Color-coding:97">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>=</mo>
   <mrow>
    <mi>O</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>log</mi>
      <mi>n</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>k</ci>
    <apply>
     <times></times>
     <ci>O</ci>
     <apply>
      <log></log>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k=O(\log n)
  </annotation>
 </semantics>
</math>

 vertices in a network 

<math display="inline" id="Color-coding:98">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>


 with 

<math display="inline" id="Color-coding:99">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 vertices can be found very efficiently in polynomial time. Thus, this enables us to explore more complex or larger structures in PPI networks. More details can be found in.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a><a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a></p>
<h2 id="references">References</h2>

<p>"</p>

<p><a href="Category:Graph_algorithms" title="wikilink">Category:Graph algorithms</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Alon, N., Yuster, R., and Zwick, U. 1994. Color-coding: a new method for finding simple paths, cycles and other small subgraphs within large graphs. In Proceedings of the Twenty-Sixth Annual ACM Symposium on theory of Computing (Montreal, Quebec, Canada, May 23–25, 1994). STOC '94. ACM, New York, NY, 326–335. DOI= <a class="uri" href="http://doi.acm.org/10.1145/195058.195179">http://doi.acm.org/10.1145/195058.195179</a><a href="#fnref1">↩</a></li>
<li id="fn2">Alon, N., Yuster, R., and Zwick, U. 1995. Color-coding. J. ACM 42, 4 (Jul. 1995), 844–856. DOI= <a class="uri" href="http://doi.acm.org/10.1145/210332.210337">http://doi.acm.org/10.1145/210332.210337</a><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="Coppersmith–Winograd_algorithm" title="wikilink">Coppersmith–Winograd Algorithm</a><a href="#fnref3">↩</a></li>
<li id="fn4">Alon, N. and Naor, M. 1994 Derandomization, Witnesses for Boolean Matrix Multiplication and Construction of Perfect Hash Functions. Technical Report. UMI Order Number: CS94-11., Weizmann Science Press of Israel.<a href="#fnref4">↩</a></li>
<li id="fn5">Naor, M., Schulman, L. J., and Srinivasan, A. 1995. Splitters and near-optimal derandomization. In Proceedings of the 36th Annual Symposium on Foundations of Computer Science (October 23–25, 1995). FOCS. IEEE Computer Society, Washington, DC, 182.<a href="#fnref5">↩</a></li>
<li id="fn6">Schmidt, J. P. and Siegel, A. 1990. The spatial complexity of oblivious k-probe Hash functions. SIAM J. Comput. 19, 5 (Sep. 1990), 775-786. DOI= <a class="uri" href="http://dx.doi.org/10.1137/0219054">http://dx.doi.org/10.1137/0219054</a><a href="#fnref6">↩</a></li>
<li id="fn7"></li>
<li id="fn8">Naor, J. and Naor, M. 1990. Small-bias probability spaces: efficient constructions and applications. In Proceedings of the Twenty-Second Annual ACM Symposium on theory of Computing (Baltimore, Maryland, United States, May 13–17, 1990). H. Ortiz, Ed. STOC '90. ACM, New York, NY, 213-223. DOI= <a class="uri" href="http://doi.acm.org/10.1145/100216.100244">http://doi.acm.org/10.1145/100216.100244</a><a href="#fnref8">↩</a></li>
<li id="fn9">Alon, N., Goldreich, O., Hastad, J., and Peralta, R. 1990. Simple construction of almost k-wise independent random variables. In Proceedings of the 31st Annual Symposium on Foundations of Computer Science (October 22–24, 1990). SFCS. IEEE Computer Society, Washington, DC, 544-553 vol.2. DOI= <a class="uri" href="http://dx.doi.org/10.1109/FSCS.1990.89575">http://dx.doi.org/10.1109/FSCS.1990.89575</a><a href="#fnref9">↩</a></li>
<li id="fn10"></li>
<li id="fn11">Alon, N., Dao, P., Hajirasouliha, I., Hormozdiari, F., and Sahinalp, S. C. 2008. Biomolecular network motif counting and discovery by color coding. Bioinformatics 24, 13 (Jul. 2008), i241-i249. DOI= <a class="uri" href="http://dx.doi.org/10.1093/bioinformatics/btn163">http://dx.doi.org/10.1093/bioinformatics/btn163</a><a href="#fnref11">↩</a></li>
<li id="fn12">Hüffner, F., Wernicke, S., and Zichner, T. 2008. Algorithm Engineering for Color-Coding with Applications to Signaling Pathway Detection. Algorithmica 52, 2 (Aug. 2008), 114-132. DOI= <a class="uri" href="http://dx.doi.org/10.1007/s00453-007-9008-7">http://dx.doi.org/10.1007/s00453-007-9008-7</a><a href="#fnref12">↩</a></li>
</ol>
</section>
</body>
</html>
