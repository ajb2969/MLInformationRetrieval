<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="978">Levenberg–Marquardt algorithm</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Levenberg–Marquardt algorithm</h1>
<hr/>

<p>In <a class="uri" href="mathematics" title="wikilink">mathematics</a> and computing, the <strong>Levenberg–Marquardt algorithm (LMA)</strong>, also known as the <strong>damped least-squares (DLS)</strong> method, is used to solve <a href="non-linear_least_squares" title="wikilink">non-linear least squares</a> problems. These minimization problems arise especially in <a href="least_squares" title="wikilink">least squares</a> <a href="curve_fitting" title="wikilink">curve fitting</a>.</p>

<p>The LMA is used in many software applications for solving generic curve-fitting problems. However, as for many fitting algorithms, the LMA finds only a <a href="local_minimum" title="wikilink">local minimum</a>, which is not necessarily the <a href="global_minimum" title="wikilink">global minimum</a>. The LMA interpolates between the <a href="Gauss–Newton_algorithm" title="wikilink">Gauss–Newton algorithm</a> (GNA) and the method of <a href="gradient_descent" title="wikilink">gradient descent</a>. The LMA is more <a href="Robustness_(computer_science)" title="wikilink">robust</a> than the GNA, which means that in many cases it finds a solution even if it starts very far off the final minimum. For well-behaved functions and reasonable starting parameters, the LMA tends to be a bit slower than the GNA. LMA can also be viewed as Gauss–Newton using a <a href="trust_region" title="wikilink">trust region</a> approach.</p>

<p>The algorithm was first published in 1944 by Kenneth Levenberg, while working at the <a href="Frankford_Arsenal" title="wikilink">Frankford Army Arsenal</a>. It was rediscovered in 1963 by <a href="Donald_Marquardt" title="wikilink">Donald Marquardt</a> who worked as a <a class="uri" href="statistician" title="wikilink">statistician</a> at <a class="uri" href="DuPont" title="wikilink">DuPont</a> and independently by Girard, Wynn and Morrison.</p>
<h2 id="the-problem">The problem</h2>

<p>The primary application of the Levenberg–Marquardt algorithm is in the least squares curve fitting problem: given a set of m empirical datum pairs of independent and dependent variables, (<em>x<sub>i</sub></em>, <em>y<sub>i</sub></em>), optimize the parameters <em>β</em> of the model curve <em>f</em>(<em>x</em>,<strong><em>β</em></strong>) so that the sum of the squares of the deviations</p>

<p>

<math display="block" id="Levenberg–Marquardt_algorithm:0">
 <semantics>
  <mrow>
   <mrow>
    <mi>S</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>𝜷</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>m</mi>
    </munderover>
    <msup>
     <mrow>
      <mo stretchy="false">[</mo>
      <mrow>
       <msub>
        <mi>y</mi>
        <mi>i</mi>
       </msub>
       <mo>-</mo>
       <mrow>
        <mi>f</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>x</mi>
          <mi>i</mi>
         </msub>
         <mo rspace="7.5pt">,</mo>
         <mi>𝜷</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
      <mo stretchy="false">]</mo>
     </mrow>
     <mn>2</mn>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>S</ci>
     <ci>𝜷</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>m</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>y</ci>
         <ci>i</ci>
        </apply>
        <apply>
         <times></times>
         <ci>f</ci>
         <interval closure="open">
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>x</ci>
           <ci>i</ci>
          </apply>
          <ci>𝜷</ci>
         </interval>
        </apply>
       </apply>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S(\boldsymbol{\beta})=\sum_{i=1}^{m}[y_{i}-f(x_{i},\ \boldsymbol{\beta})]^{2}
  </annotation>
 </semantics>
</math>

</p>

<p>becomes minimal.</p>
<h2 id="the-solution">The solution</h2>

<p>Like other numeric minimization algorithms, the Levenberg–Marquardt algorithm is an <a href="iteration" title="wikilink">iterative</a> procedure. To start a minimization, the user has to provide an initial guess for the parameter vector, <strong><em>β</em></strong>. In cases with only one minimum, an uninformed standard guess like <strong><em>β</em></strong><sup>T</sup>=(1,1,...,1) will work fine; in cases with <a href="local_minimum" title="wikilink">multiple minima</a>, the algorithm converges to the global minimum only if the initial guess is already somewhat close to the final solution.</p>

<p>In each iteration step, the parameter vector, <strong><em>β</em></strong>, is replaced by a new estimate, <strong><em>β</em></strong> + <strong><em>δ</em></strong>. To determine <strong><em>δ</em></strong>, the functions 

<math display="inline" id="Levenberg–Marquardt_algorithm:1">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mi>i</mi>
    </msub>
    <mo>,</mo>
    <mrow>
     <mi>𝜷</mi>
     <mo>+</mo>
     <mi>𝜹</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <plus></plus>
      <ci>𝜷</ci>
      <ci>𝜹</ci>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x_{i},\boldsymbol{\beta}+\boldsymbol{\delta})
  </annotation>
 </semantics>
</math>

 are approximated by their linearizations</p>

<p>

<math display="block" id="Levenberg–Marquardt_algorithm:2">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mi>i</mi>
     </msub>
     <mo>,</mo>
     <mrow>
      <mi>𝜷</mi>
      <mo>+</mo>
      <mi>𝜹</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≈</mo>
   <mrow>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mi>i</mi>
      </msub>
      <mo>,</mo>
      <mi>𝜷</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>J</mi>
      <mi>i</mi>
     </msub>
     <mpadded width="-1.7pt">
      <mi>𝜹</mi>
     </mpadded>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <apply>
     <times></times>
     <ci>f</ci>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <plus></plus>
       <ci>𝜷</ci>
       <ci>𝜹</ci>
      </apply>
     </interval>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>f</ci>
      <interval closure="open">
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>i</ci>
       </apply>
       <ci>𝜷</ci>
      </interval>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>J</ci>
       <ci>i</ci>
      </apply>
      <ci>𝜹</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x_{i},\boldsymbol{\beta}+\boldsymbol{\delta})\approx f(x_{i},\boldsymbol{%
\beta})+J_{i}\boldsymbol{\delta}\!
  </annotation>
 </semantics>
</math>

</p>

<p>where</p>

<p>

<math display="block" id="Levenberg–Marquardt_algorithm:3">
 <semantics>
  <mrow>
   <msub>
    <mi>J</mi>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mrow>
      <mo>∂</mo>
      <mi>f</mi>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mi>i</mi>
      </msub>
      <mo>,</mo>
      <mi>𝜷</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mrow>
     <mo>∂</mo>
     <mi>𝜷</mi>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>J</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <apply>
       <partialdiff></partialdiff>
       <ci>f</ci>
      </apply>
      <interval closure="open">
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>i</ci>
       </apply>
       <ci>𝜷</ci>
      </interval>
     </apply>
     <apply>
      <partialdiff></partialdiff>
      <ci>𝜷</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   J_{i}=\frac{\partial f(x_{i},\boldsymbol{\beta})}{\partial\boldsymbol{\beta}}
  </annotation>
 </semantics>
</math>

 is the <a class="uri" href="gradient" title="wikilink">gradient</a> (row-vector in this case) of <em>f</em> with respect to <strong><em>β</em></strong>.</p>

<p>At the minimum of the sum of squares, 

<math display="inline" id="Levenberg–Marquardt_algorithm:4">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>β</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>S</ci>
    <ci>β</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S(\beta)
  </annotation>
 </semantics>
</math>

, the <a class="uri" href="gradient" title="wikilink">gradient</a> of 

<math display="inline" id="Levenberg–Marquardt_algorithm:5">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 with respect to <strong><em>δ</em></strong> will be zero. The above first-order approximation of 

<math display="inline" id="Levenberg–Marquardt_algorithm:6">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mi>i</mi>
    </msub>
    <mo>,</mo>
    <mrow>
     <mi>𝜷</mi>
     <mo>+</mo>
     <mi>𝜹</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <plus></plus>
      <ci>𝜷</ci>
      <ci>𝜹</ci>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x_{i},\boldsymbol{\beta}+\boldsymbol{\delta})
  </annotation>
 </semantics>
</math>

 gives</p>

<p>

<math display="block" id="Levenberg–Marquardt_algorithm:7">
 <semantics>
  <mrow>
   <mrow>
    <mi>S</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>𝜷</mi>
      <mo>+</mo>
      <mi>𝜹</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≈</mo>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>m</mi>
    </munderover>
    <msup>
     <mrow>
      <mo>(</mo>
      <mrow>
       <msub>
        <mi>y</mi>
        <mi>i</mi>
       </msub>
       <mo>-</mo>
       <mrow>
        <mi>f</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>x</mi>
          <mi>i</mi>
         </msub>
         <mo>,</mo>
         <mi>𝜷</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>-</mo>
       <mrow>
        <msub>
         <mi>J</mi>
         <mi>i</mi>
        </msub>
        <mi>𝜹</mi>
       </mrow>
      </mrow>
      <mo>)</mo>
     </mrow>
     <mn>2</mn>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <apply>
     <times></times>
     <ci>S</ci>
     <apply>
      <plus></plus>
      <ci>𝜷</ci>
      <ci>𝜹</ci>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>m</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <times></times>
        <ci>f</ci>
        <interval closure="open">
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <ci>i</ci>
         </apply>
         <ci>𝜷</ci>
        </interval>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>J</ci>
         <ci>i</ci>
        </apply>
        <ci>𝜹</ci>
       </apply>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S(\boldsymbol{\beta}+\boldsymbol{\delta})\approx\sum_{i=1}^{m}\left(y_{i}-f(x_%
{i},\boldsymbol{\beta})-J_{i}\boldsymbol{\delta}\right)^{2}
  </annotation>
 </semantics>
</math>

. Or in vector notation,</p>

<p>

<math display="block" id="Levenberg–Marquardt_algorithm:8">
 <semantics>
  <mrow>
   <mrow>
    <mi>S</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>𝜷</mi>
      <mo>+</mo>
      <mi>𝜹</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≈</mo>
   <msup>
    <mrow>
     <mo>∥</mo>
     <mrow>
      <mi>𝐲</mi>
      <mo>-</mo>
      <mrow>
       <mi>𝐟</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>𝜷</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>-</mo>
      <mrow>
       <mi>𝐉</mi>
       <mi>𝜹</mi>
      </mrow>
     </mrow>
     <mo>∥</mo>
    </mrow>
    <mn>2</mn>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <apply>
     <times></times>
     <ci>S</ci>
     <apply>
      <plus></plus>
      <ci>𝜷</ci>
      <ci>𝜹</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="latexml">norm</csymbol>
      <apply>
       <minus></minus>
       <ci>𝐲</ci>
       <apply>
        <times></times>
        <ci>𝐟</ci>
        <ci>𝜷</ci>
       </apply>
       <apply>
        <times></times>
        <ci>𝐉</ci>
        <ci>𝜹</ci>
       </apply>
      </apply>
     </apply>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S(\boldsymbol{\beta}+\boldsymbol{\delta})\approx\|\mathbf{y}-\mathbf{f}(%
\boldsymbol{\beta})-\mathbf{J}\boldsymbol{\delta}\|^{2}
  </annotation>
 </semantics>
</math>

. Taking the derivative with respect to <strong>δ</strong> and setting the result to zero gives:</p>

<p>

<math display="block" id="Levenberg–Marquardt_algorithm:9">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msup>
       <mi>𝐉</mi>
       <mi>𝐓</mi>
      </msup>
      <mi>𝐉</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>𝜹</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>𝐉</mi>
     <mi>𝐓</mi>
    </msup>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mi>𝐲</mi>
      <mo>-</mo>
      <mrow>
       <mi>𝐟</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>𝜷</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo rspace="0.8pt" stretchy="false">]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>𝐉</ci>
       <ci>𝐓</ci>
      </apply>
      <ci>𝐉</ci>
     </apply>
     <ci>𝜹</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>𝐉</ci>
      <ci>𝐓</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <apply>
       <minus></minus>
       <ci>𝐲</ci>
       <apply>
        <times></times>
        <ci>𝐟</ci>
        <ci>𝜷</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{(J^{T}J)\boldsymbol{\delta}=J^{T}[y-f(\boldsymbol{\beta})]}\!
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Levenberg–Marquardt_algorithm:10">
 <semantics>
  <mi>𝐉</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐉</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{J}
  </annotation>
 </semantics>
</math>

 is the <a href="Jacobian_matrix_and_determinant" title="wikilink">Jacobian matrix</a> whose <em>i</em><sup>th</sup> row equals 

<math display="inline" id="Levenberg–Marquardt_algorithm:11">
 <semantics>
  <msub>
   <mi>J</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>J</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   J_{i}
  </annotation>
 </semantics>
</math>

, and where 

<math display="inline" id="Levenberg–Marquardt_algorithm:12">
 <semantics>
  <mi>𝐟</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐟</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{f}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Levenberg–Marquardt_algorithm:13">
 <semantics>
  <mi>𝐲</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐲</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{y}
  </annotation>
 </semantics>
</math>


 are vectors with <em>i</em><sup>th</sup> component 

<math display="inline" id="Levenberg–Marquardt_algorithm:14">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mi>i</mi>
    </msub>
    <mo>,</mo>
    <mi>𝜷</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>i</ci>
     </apply>
     <ci>𝜷</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x_{i},\boldsymbol{\beta})
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Levenberg–Marquardt_algorithm:15">
 <semantics>
  <msub>
   <mi>y</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>y</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{i}
  </annotation>
 </semantics>
</math>

, respectively. This is a set of linear equations which can be solved for <strong><em>δ</em></strong>.</p>

<p>Levenberg's contribution is to replace this equation by a "damped version",</p>

<p>

<math display="block" id="Levenberg–Marquardt_algorithm:16">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <msup>
        <mi>𝐉</mi>
        <mi>𝐓</mi>
       </msup>
       <mi>𝐉</mi>
      </mrow>
      <mo>+</mo>
      <mrow>
       <mi>λ</mi>
       <mi>𝐈</mi>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>𝜹</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>𝐉</mi>
     <mi>𝐓</mi>
    </msup>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mi>𝐲</mi>
      <mo>-</mo>
      <mrow>
       <mi>𝐟</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>𝜷</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo rspace="0.8pt" stretchy="false">]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>𝐉</ci>
        <ci>𝐓</ci>
       </apply>
       <ci>𝐉</ci>
      </apply>
      <apply>
       <times></times>
       <ci>λ</ci>
       <ci>𝐈</ci>
      </apply>
     </apply>
     <ci>𝜹</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>𝐉</ci>
      <ci>𝐓</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <apply>
       <minus></minus>
       <ci>𝐲</ci>
       <apply>
        <times></times>
        <ci>𝐟</ci>
        <ci>𝜷</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{(J^{T}J+\lambda I)\boldsymbol{\delta}=J^{T}[y-f(\boldsymbol{\beta})]}\!
  </annotation>
 </semantics>
</math>

</p>

<p>where <strong>I</strong> is the identity matrix, giving as the increment, <strong><em>δ</em></strong>, to the estimated parameter vector, <strong><em>β</em></strong>.</p>

<p>The (non-negative) damping factor, λ, is adjusted at each iteration. If reduction of <em>S</em> is rapid, a smaller value can be used, bringing the algorithm closer to the <a href="Gauss–Newton_algorithm" title="wikilink">Gauss–Newton algorithm</a>, whereas if an iteration gives insufficient reduction in the residual, λ can be increased, giving a step closer to the gradient descent direction. Note that the <a class="uri" href="gradient" title="wikilink">gradient</a> of <em>S</em> with respect to <strong><em>δ</em></strong> equals 

<math display="inline" id="Levenberg–Marquardt_algorithm:17">
 <semantics>
  <mrow>
   <mo>-</mo>
   <mrow>
    <mn>2</mn>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msup>
        <mi>𝐉</mi>
        <mi>T</mi>
       </msup>
       <mrow>
        <mo stretchy="false">[</mo>
        <mrow>
         <mi>𝐲</mi>
         <mo>-</mo>
         <mrow>
          <mi>𝐟</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>𝜷</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
        </mrow>
        <mo stretchy="false">]</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>T</mi>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <apply>
     <times></times>
     <cn type="integer">2</cn>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>𝐉</ci>
        <ci>T</ci>
       </apply>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <apply>
         <minus></minus>
         <ci>𝐲</ci>
         <apply>
          <times></times>
          <ci>𝐟</ci>
          <ci>𝜷</ci>
         </apply>
        </apply>
       </apply>
      </apply>
      <ci>T</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   -2(\mathbf{J}^{T}[\mathbf{y}-\mathbf{f}(\boldsymbol{\beta})])^{T}
  </annotation>
 </semantics>
</math>

. Therefore, for large values of <em>λ</em>, the step will be taken approximately in the direction of the gradient. If either the length of the calculated step, <strong><em>δ</em></strong>, or the reduction of sum of squares from the latest parameter vector, <strong><em>β</em></strong> + <strong><em>δ</em></strong>, fall below predefined limits, iteration stops and the last parameter vector, <strong><em>β</em></strong>, is considered to be the solution.</p>

<p>Levenberg's algorithm has the disadvantage that if the value of damping factor, λ, is large, inverting <strong>J</strong><sup>T</sup><strong>J</strong> + λ<strong>I</strong> is not used at all. Marquardt provided the insight that we can scale each component of the gradient according to the curvature so that there is larger movement along the directions where the gradient is smaller. This avoids slow convergence in the direction of small gradient. Therefore, Marquardt replaced the identity matrix, <strong>I</strong>, with the diagonal matrix consisting of the diagonal elements of <strong>J</strong><sup>T</sup><strong>J</strong>, resulting in the Levenberg–Marquardt algorithm:</p>

<p>

<math display="block" id="Levenberg–Marquardt_algorithm:18">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <msup>
        <mi>𝐉</mi>
        <mi>𝐓</mi>
       </msup>
       <mi>𝐉</mi>
      </mrow>
      <mo>+</mo>
      <mrow>
       <mpadded width="+1.7pt">
        <mi>λ</mi>
       </mpadded>
       <mi>𝐝𝐢𝐚𝐠</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <msup>
          <mi>𝐉</mi>
          <mi>𝐓</mi>
         </msup>
         <mi>𝐉</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>𝜹</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>𝐉</mi>
     <mi>𝐓</mi>
    </msup>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mi>𝐲</mi>
      <mo>-</mo>
      <mrow>
       <mi>𝐟</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>𝜷</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo rspace="0.8pt" stretchy="false">]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>𝐉</ci>
        <ci>𝐓</ci>
       </apply>
       <ci>𝐉</ci>
      </apply>
      <apply>
       <times></times>
       <ci>λ</ci>
       <ci>𝐝𝐢𝐚𝐠</ci>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>𝐉</ci>
         <ci>𝐓</ci>
        </apply>
        <ci>𝐉</ci>
       </apply>
      </apply>
     </apply>
     <ci>𝜹</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>𝐉</ci>
      <ci>𝐓</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <apply>
       <minus></minus>
       <ci>𝐲</ci>
       <apply>
        <times></times>
        <ci>𝐟</ci>
        <ci>𝜷</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{(J^{T}J+\lambda\,diag(J^{T}J))\boldsymbol{\delta}=J^{T}[y-f(%
\boldsymbol{\beta})]}\!
  </annotation>
 </semantics>
</math>

.</p>

<p>A similar damping factor appears in <a href="Tikhonov_regularization" title="wikilink">Tikhonov regularization</a>, which is used to solve linear <a href="ill-posed_problems" title="wikilink">ill-posed problems</a>, as well as in <a href="ridge_regression" title="wikilink">ridge regression</a>, an <a href="estimation_theory" title="wikilink">estimation</a> technique in <a class="uri" href="statistics" title="wikilink">statistics</a>.</p>
<h3 id="choice-of-damping-parameter">Choice of damping parameter</h3>

<p>Various more-or-less heuristic arguments have been put forward for the best choice for the damping parameter λ. Theoretical arguments exist showing why some of these choices guaranteed local convergence of the algorithm; however these choices can make the global convergence of the algorithm suffer from the undesirable properties of <a href="gradient_descent" title="wikilink">steepest-descent</a>, in particular very slow convergence close to the optimum.</p>

<p>The absolute values of any choice depends on how well-scaled the initial problem is. Marquardt recommended starting with a value λ<sub>0</sub> and a factor ν &gt; 1. Initially setting λ = λ<sub>0</sub> and computing the residual sum of squares <em>S</em>(<strong><em>β</em></strong>) after one step from the starting point with the damping factor of λ = λ<sub>0</sub> and secondly with λ<sub>0</sub>/ν. If both of these are worse than the initial point then the damping is increased by successive multiplication by ν until a better point is found with a new damping factor of λ<sub>0</sub>ν<sup><em>k</em></sup> for some <em>k</em>.</p>

<p>If use of the damping factor λ/ν results in a reduction in squared residual then this is taken as the new value of λ (and the new optimum location is taken as that obtained with this damping factor) and the process continues; if using λ/ν resulted in a worse residual, but using λ resulted in a better residual, then λ is left unchanged and the new optimum is taken as the value obtained with λ as damping factor.</p>
<h2 id="example">Example</h2>

<p> </p>

<p>In this example we try to fit the function 

<math display="inline" id="Levenberg–Marquardt_algorithm:19">
 <semantics>
  <mrow>
   <mi>y</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>a</mi>
     <mrow>
      <mi>cos</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>b</mi>
        <mi>X</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>b</mi>
     <mrow>
      <mi>sin</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>a</mi>
        <mi>X</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>y</ci>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>a</ci>
      <apply>
       <cos></cos>
       <apply>
        <times></times>
        <ci>b</ci>
        <ci>X</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>b</ci>
      <apply>
       <sin></sin>
       <apply>
        <times></times>
        <ci>a</ci>
        <ci>X</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y=a\cos(bX)+b\sin(aX)
  </annotation>
 </semantics>
</math>

 using the Levenberg–Marquardt algorithm implemented in <a href="GNU_Octave" title="wikilink">GNU Octave</a> as the <em>leasqr</em> function. The 3 graphs Fig 1,2,3 show progressively better fitting for the parameters <em>a</em>=100, <em>b</em>=102 used in the initial curve. Only when the parameters in Fig 3 are chosen closest to the original, are the curves fitting exactly. This equation is an example of very sensitive initial conditions for the Levenberg–Marquardt algorithm. One reason for this sensitivity is the existence of multiple minima — the function 

<math display="inline" id="Levenberg–Marquardt_algorithm:20">
 <semantics>
  <mrow>
   <mi>cos</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>β</mi>
     <mi>x</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <cos></cos>
    <apply>
     <times></times>
     <ci>β</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \cos(\beta x)
  </annotation>
 </semantics>
</math>

 has minima at parameter value 

<math display="inline" id="Levenberg–Marquardt_algorithm:21">
 <semantics>
  <mover accent="true">
   <mi>β</mi>
   <mo stretchy="false">^</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-^</ci>
    <ci>β</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{\beta}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Levenberg–Marquardt_algorithm:22">
 <semantics>
  <mrow>
   <mrow>
    <mover accent="true">
     <mi>β</mi>
     <mo stretchy="false">^</mo>
    </mover>
    <mo>+</mo>
    <mrow>
     <mn>2</mn>
     <mi>n</mi>
     <mi>π</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <ci>normal-^</ci>
     <ci>β</ci>
    </apply>
    <apply>
     <times></times>
     <cn type="integer">2</cn>
     <ci>n</ci>
     <ci>π</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{\beta}+2n\pi.
  </annotation>
 </semantics>
</math>

</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Trust_region" title="wikilink">Trust region</a></li>
<li><a href="Nelder–Mead_method" title="wikilink">Nelder–Mead method</a> (aka simplex)</li>
</ul>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<div class="references-normal">
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
<references>
</references>
</div>
<h2 id="external-links">External links</h2>
<h3 id="descriptions">Descriptions</h3>
<ul>
<li>Detailed description of the algorithm can be found in <a href="http://www.nrbook.com/a/bookcpdf.php">Numerical Recipes in C, Chapter 15.5: Nonlinear models</a></li>
<li>C. T. Kelley, <em>Iterative Methods for Optimization</em>, SIAM Frontiers in Applied Mathematics, no 18, 1999, ISBN 0-89871-433-8. <a href="http://www.siam.org/books/textbooks/fr18_book.pdf">Online copy</a></li>
<li><a href="https://web.archive.org/web/20140301154319/http://www3.villanova.edu/maple/misc/mtc1093.html">History of the algorithm in SIAM news</a></li>
<li><a href="http://ananth.in/docs/lmtut.pdf">A tutorial by Ananth Ranganathan</a></li>
<li><a href="http://www2.imm.dtu.dk/pubdb/views/edoc_download.php/3215/pdf/imm3215.pdf">Methods for Non-Linear Least Squares Problems</a> by K. Madsen, H.B. Nielsen, O. Tingleff is a tutorial discussing non-linear least-squares in general and the Levenberg-Marquardt method in particular</li>
<li>T. Strutz: <em>Data Fitting and Uncertainty (A practical introduction to weighted least squares and beyond)</em>. Vieweg+Teubner, ISBN 978-3-8348-1022-9.</li>
<li>H. P. Gavin, <a href="http://people.duke.edu/~hpgavin/ce281/lm.pdf"><em>The Levenberg-Marquardt method for nonlinear least squares curve-ﬁtting problems</em></a> (<a class="uri" href="MATLAB" title="wikilink">MATLAB</a> implementation included)</li>
</ul>
<h3 id="implementations">Implementations</h3>
<ul>
<li>Levenberg-Marquardt is a built-in algorithm in <a class="uri" href="Mathematica" title="wikilink">Mathematica</a> , <a class="uri" href="Matlab" title="wikilink">Matlab</a>, <a class="uri" href="NeuroSolutions" title="wikilink">NeuroSolutions</a>, <a href="GNU_Octave" title="wikilink">GNU Octave</a>, <a href="Origin_(software)" title="wikilink">Origin</a>, <a class="uri" href="SciPy" title="wikilink">SciPy</a>, <a class="uri" href="Fityk" title="wikilink">Fityk</a>, <a href="IGOR_Pro" title="wikilink">IGOR Pro</a> and <a class="uri" href="LabVIEW" title="wikilink">LabVIEW</a>.</li>
<li>The oldest implementation still in use is <a href="http://www.netlib.org/minpack/">lmdif</a>, from <a class="uri" href="MINPACK" title="wikilink">MINPACK</a>, in <a class="uri" href="Fortran" title="wikilink">Fortran</a>, in the <a href="public_domain" title="wikilink">public domain</a>. See also:
<ul>
<li><a href="http://apps.jcns.fz-juelich.de/lmfit">lmfit</a>, a self-contained <a href="C_programming_language" title="wikilink">C</a> implementation of the MINPACK algorithm, with an easy-to-use wrapper for curve fitting, liberal licence (freeBSD).</li>
<li><a href="http://eigen.tuxfamily.org/index.php?title=Main_Page">eigen</a>, a C++ linear algebra library, includes an adaptation of the minpack algorithm in the "NonLinearOptimization" module.</li>
<li>The <a href="GNU_Scientific_Library" title="wikilink">GNU Scientific Library</a> has a C interface to MINPACK.</li>
<li><a href="http://devernay.free.fr/hacks/cminpack.html">C/C++ Minpack</a> includes the Levenberg–Marquardt algorithm.</li>
<li>Several high-level languages and mathematical packages have wrappers for the <a class="uri" href="MINPACK" title="wikilink">MINPACK</a> routines, among them:
<ul>
<li>Python library <a class="uri" href="scipy" title="wikilink">scipy</a>, module <code>scipy.optimize.leastsq</code>,</li>
<li><a href="IDL_(programming_language)" title="wikilink">IDL</a>, add-on <a href="http://cow.physics.wisc.edu/~craigm/idl/fitting.html">MPFIT</a>.</li>
<li><a href="R_(programming_language)" title="wikilink">R (programming language)</a> has the <a href="http://cran.r-project.org/web/packages/minpack.lm/index.html">minpack.lm</a> package.</li>
</ul></li>
</ul></li>
<li><a href="http://www.ics.forth.gr/%7elourakis/levmar/">levmar</a> is an implementation in <a href="C_(programming_language)" title="wikilink">C</a>/<a class="uri" href="C++" title="wikilink">C++</a> with support for constraints, distributed under the <a href="GNU_General_Public_License" title="wikilink">GNU General Public License</a>.
<ul>
<li>levmar includes a <a href="MEX_file" title="wikilink">MEX file</a> interface for <a class="uri" href="MATLAB" title="wikilink">MATLAB</a></li>
<li><a class="uri" href="Perl" title="wikilink">Perl</a> (<a href="Perl_Data_Language" title="wikilink">PDL</a>), <a href="Python_(programming_language)" title="wikilink">python</a>, <a href="Haskell_(programming_language)" title="wikilink">Haskell</a> and <a href=".NET_Framework" title="wikilink">.NET</a> interfaces to levmar are available: see <a href="http://www.johnlapeyre.com/pdl/index.html">PDL::Fit::Levmar</a> or [<a class="uri" href="https://metacpan.org/module/PDL">https://metacpan.org/module/PDL</a>::Fit::LM PDL::Fit::LM], <a href="http://trac.astrometry.net/wiki/PyLevmar">PyLevmar</a>, <a href="http://hackage.haskell.org/package/levmar">HackageDB levmar</a> and <a href="https://github.com/AvengerDr/LevmarSharp">LevmarSharp</a>.</li>
</ul></li>
<li><a href="http://www.ics.forth.gr/%7elourakis/sparseLM/">sparseLM</a> is a <a href="C_(programming_language)" title="wikilink">C</a> implementation aimed at minimizing functions with large, arbitrarily <a href="Sparse_matrix" title="wikilink">sparse</a> Jacobians. Includes a MATLAB MEX interface.</li>
<li><a href="http://www2.imm.dtu.dk/~hbni/Software/SMarquardt.m">SMarquardt.m</a> is a stand-alone routine for Matlab or Octave.</li>
<li><a href="http://www.bnikolic.co.uk/inmin/inmin-library.html">InMin</a> library contains a C++ implementation of the algorithm based on the <a href="http://eigen.tuxfamily.org/index.php?title=Main_Page">eigen</a> C++ linear algebra library. It has a pure C-language API as well as a Python binding</li>
<li><a href="http://code.google.com/p/ceres-solver/">ceres</a> is a non-linear minimisation library with an implementation of the Levenberg–Marquardt algorithm. It is written in C++ and uses <a href="http://eigen.tuxfamily.org/index.php?title=Main_Page">eigen</a></li>
<li><a href="http://www.alglib.net/optimization/levenbergmarquardt.php">ALGLIB</a> has implementations of improved LMA in C# / C++ / Delphi / Visual Basic. Improved algorithm takes less time to converge and can use either Jacobian or exact Hessian.</li>
<li><a class="uri" href="NMath" title="wikilink">NMath</a> has an implementation for the <a href=".NET_Framework" title="wikilink">.NET Framework</a>.</li>
<li><a class="uri" href="gnuplot" title="wikilink">gnuplot</a> uses its own implementation <a href="http://www.gnuplot.info/">gnuplot.info</a>.</li>
<li><a href="Java_(programming_language)" title="wikilink">Java programming language</a> implementations: 1) <a href="http://scribblethink.org/Computer/Javanumeric/index.html">Javanumerics</a>, 2) <a href="http://virtualrisk.cvs.sourceforge.net/*checkout*/virtualrisk/util/lma/lma_v1.3.zip">LMA-package</a> (a small, user friendly and well documented implementation with examples and support), 3) <a href="http://commons.apache.org/math/apidocs/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.html">Apache Commons Math</a></li>
<li><a href="http://oooconv.free.fr/fitoo/fitoo_en.html">OOoConv</a> implements the L-M algorithm as an OpenOffice.org Calc spreadsheet.</li>
<li><a href="SAS_(software)" title="wikilink">SAS</a>, there are multiple ways to access SAS's implementation of the Levenberg–Marquardt algorithm: it can be accessed via <a href="http://support.sas.com/documentation/cdl/en/imlug/59656/HTML/default/langref_sect187.htm#imlug_langref_nlplm">NLPLM Call</a> in <a href="http://support.sas.com/documentation/cdl/en/imlug/59656/HTML/default/imlstart_sect1.htm">PROC IML</a> and it can also be accessed through the <a href="http://support.sas.com/documentation/cdl/en/ormpug/63352/HTML/default/viewer.htm#ormpug_nlp_sect021.htm">LSQ</a> statement in <a href="http://support.sas.com/documentation/cdl/en/ormpug/63352/HTML/default/viewer.htm#ormpug_nlp_sect001.htm">PROC NLP</a>, and the <a href="http://support.sas.com/documentation/cdl/en/statug/63033/HTML/default/viewer.htm#statug_nlin_sect007.htm">METHOD=MARQUARDT</a> option in <a href="http://support.sas.com/documentation/cdl/en/statug/63033/HTML/default/viewer.htm#statug_nlin_sect001.htm">PROC NLIN</a>.</li>
<li><a href="https://github.com/namp/lmam-olmam-matlab-toolbox">LMAM/OLMAM Matlab toolbox</a> implements Levenberg-Marquardt with adaptive momentum for training feedforward neural networks.</li>
<li><a href="https://raullaasner.github.io/gadfit">GADfit</a> is a Fortran implementation of global fitting based on a modified Levenberg-Marquardt. Uses automatic differentiation. Allows fitting functions of arbitrary complexity, including integrals.</li>
</ul>

<p>"</p>

<p><a href="Category:Statistical_algorithms" title="wikilink">Category:Statistical algorithms</a> <a href="Category:Optimization_algorithms_and_methods" title="wikilink">Category:Optimization algorithms and methods</a> <a href="Category:Least_squares" title="wikilink">Category:Least squares</a></p>
</body>
</html>
