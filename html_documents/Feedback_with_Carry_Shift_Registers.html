<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1126">Feedback with Carry Shift Registers</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Feedback with Carry Shift Registers</h1>
<hr>In sequence design, a '''Feedback with Carry Shift Register''' (or FCSR) is the  arithmetic or with carry analog of a [[Linear feedback shift register]] (LFSR).  If <math>N &gt;1</math> is an integer, then an N-ary FCSR of length <math>r</math> is a finite state device with a state <math>(a;z)  = (a_0,a_1,\dots,a_{r-1};z)</math> consisting of a vector of elements <math>a_i</math> in <math>\{0,1,\dots,N-1\}=S</math> and an integer <math>z</math>.<ref name="FCSR1">A. Klapper and M. Goresky, ''Feedback Shift Registers, 2-Adic Span, and Combiners With Memory, in Journal of Cryptology vol. 10, pp. 111-147'', 1997, [http://www.springerlink.com/content/bnxf4xc81ltqdlfm/?p=d309beafbf334b32b24164de4503446aπ=3]</ref><ref name="LEcuyer">R. Couture and P. L’Ecuyer, ''On the lattice structure of certain linear congruential sequences related to AWC/SWB generators, Math. Comp. vol. 62, 
<p>pp. 799–808'', 1994, <a href="http://www.jstor.org/journals/00255718.html">1</a>,<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a><a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> The state change operation is determined by a set of coefficients 

<math display="inline" id="Feedback_with_Carry_Shift_Registers:0">
 <semantics>
  <mrow>
   <msub>
    <mi>q</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>q</mi>
    <mi>n</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>q</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>q</ci>
     <ci>n</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q_{1},\dots,q_{n}
  </annotation>
 </semantics>
</math>

 and is defined as follows: compute 

<math display="inline" id="Feedback_with_Carry_Shift_Registers:1">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>q</mi>
      <mi>r</mi>
     </msub>
     <msub>
      <mi>a</mi>
      <mn>0</mn>
     </msub>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>q</mi>
      <mrow>
       <mi>r</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msub>
     <msub>
      <mi>a</mi>
      <mn>1</mn>
     </msub>
    </mrow>
    <mo>+</mo>
    <mi mathvariant="normal">…</mi>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>q</mi>
      <mn>1</mn>
     </msub>
     <msub>
      <mi>a</mi>
      <mrow>
       <mi>r</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msub>
    </mrow>
    <mo>+</mo>
    <mi>z</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>s</ci>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>q</ci>
       <ci>r</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>q</ci>
       <apply>
        <minus></minus>
        <ci>r</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>q</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <apply>
        <minus></minus>
        <ci>r</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
     <ci>z</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s=q_{r}a_{0}+q_{r-1}a_{1}+\dots+q_{1}a_{r-1}+z
  </annotation>
 </semantics>
</math>

. Express s as 

<math display="inline" id="Feedback_with_Carry_Shift_Registers:2">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>a</mi>
     <mi>r</mi>
    </msub>
    <mo>+</mo>
    <mrow>
     <mi>N</mi>
     <msup>
      <mi>z</mi>
      <mo>′</mo>
     </msup>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>s</ci>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <ci>r</ci>
     </apply>
     <apply>
      <times></times>
      <ci>N</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>z</ci>
       <ci>normal-′</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s=a_{r}+Nz^{\prime}
  </annotation>
 </semantics>
</math>

 with 

<math display="inline" id="Feedback_with_Carry_Shift_Registers:3">
 <semantics>
  <msub>
   <mi>a</mi>
   <mi>r</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>a</ci>
    <ci>r</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{r}
  </annotation>
 </semantics>
</math>

 in 

<math display="inline" id="Feedback_with_Carry_Shift_Registers:4">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

. Then the new state is 

<math display="inline" id="Feedback_with_Carry_Shift_Registers:5">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msub>
    <mi>a</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>a</mi>
    <mn>2</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>a</mi>
    <mi>r</mi>
   </msub>
   <mo>;</mo>
   <msup>
    <mi>z</mi>
    <mo>′</mo>
   </msup>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <ci>r</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>z</ci>
     <ci>normal-′</ci>
    </apply>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (a_{1},a_{2},\dots,a_{r};z^{\prime})
  </annotation>
 </semantics>
</math>

. By iterating the state change an FCSR generates an infinite, eventually period sequence of numbers in 

<math display="inline" id="Feedback_with_Carry_Shift_Registers:6">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

.</p>

<p>FCSRs have been used in the design of <a href="stream_ciphers" title="wikilink">stream ciphers</a> (such as the <a class="uri" href="F-FCSR" title="wikilink">F-FCSR</a> generator), in the cryptanalyis of the <a href="summation_generator" title="wikilink">summation combiner</a> stream cipher (the reason Goresky and Klapper invented them<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a>), and in generating <a href="Pseudorandomness" title="wikilink">pseudorandom numbers</a> for <a href="Quasi-Monte_Carlo_method" title="wikilink">quasi-Monte Carlo</a> (under the name <a href="Multiply-with-carry" title="wikilink">Multiply With Carry</a> (MWC) generator - invented by Couture and L'Ecuyer,<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a>) generalizing work of Marsaglia and Zaman.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>

<p>FCSRs are analyzed using <a href="number_theory" title="wikilink">number theory</a>. Associated with the FCSR is a connection integer 

<math display="inline" id="Feedback_with_Carry_Shift_Registers:7">
 <semantics>
  <mrow>
   <mi>q</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <msub>
       <mi>q</mi>
       <mi>r</mi>
      </msub>
      <msup>
       <mi>N</mi>
       <mi>r</mi>
      </msup>
     </mrow>
     <mo>+</mo>
     <mi mathvariant="normal">…</mi>
     <mo>+</mo>
     <mrow>
      <msub>
       <mi>q</mi>
       <mn>1</mn>
      </msub>
      <msup>
       <mi>N</mi>
       <mn>1</mn>
      </msup>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>q</ci>
    <apply>
     <minus></minus>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>q</ci>
        <ci>r</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>N</ci>
        <ci>r</ci>
       </apply>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>q</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>N</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q=q_{r}N^{r}+\dots+q_{1}N^{1}-1
  </annotation>
 </semantics>
</math>

. Associated with the output sequence is the <a href="p-adic_number" title="wikilink">N-adic number</a> 

<math display="inline" id="Feedback_with_Carry_Shift_Registers:8">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>a</mi>
     <mn>0</mn>
    </msub>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>a</mi>
      <mn>1</mn>
     </msub>
     <mi>N</mi>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>a</mi>
      <mn>2</mn>
     </msub>
     <msup>
      <mi>N</mi>
      <mn>2</mn>
     </msup>
    </mrow>
    <mo>+</mo>
    <mi mathvariant="normal">…</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>a</ci>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>N</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>N</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <ci>normal-…</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a=a_{0}+a_{1}N+a_{2}N^{2}+\dots
  </annotation>
 </semantics>
</math>

 The fundamental theorem of FCSRs says that there is an integer 

<math display="inline" id="Feedback_with_Carry_Shift_Registers:9">
 <semantics>
  <mi>u</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>u</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u
  </annotation>
 </semantics>
</math>

 so that 

<math display="inline" id="Feedback_with_Carry_Shift_Registers:10">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo>=</mo>
   <mrow>
    <mi>u</mi>
    <mo>/</mo>
    <mi>q</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>a</ci>
    <apply>
     <divide></divide>
     <ci>u</ci>
     <ci>q</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a=u/q
  </annotation>
 </semantics>
</math>

, a rational number. The output sequence is strictly periodic if and only if 

<math display="inline" id="Feedback_with_Carry_Shift_Registers:11">
 <semantics>
  <mi>u</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>u</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u
  </annotation>
 </semantics>
</math>

 is between 

<math display="inline" id="Feedback_with_Carry_Shift_Registers:12">
 <semantics>
  <mrow>
   <mo>-</mo>
   <mi>q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   -q
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Feedback_with_Carry_Shift_Registers:13">
 <semantics>
  <mn>0</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">0</cn>
  </annotation-xml>
 </semantics>
</math>

. It is possible to express u as a simple quadratic polynomial involving the initial state and the q<sub>i</sub>.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>

<p>There is also an exponential representation of FCSRs: if 

<math display="inline" id="Feedback_with_Carry_Shift_Registers:14">
 <semantics>
  <mi>g</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>g</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g
  </annotation>
 </semantics>
</math>

 is the inverse of 

<math display="inline" id="Feedback_with_Carry_Shift_Registers:15">
 <semantics>
  <mrow>
   <mi>N</mi>
   <mo lspace="2.5pt" rspace="2.5pt">mod</mo>
   <mi>q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">modulo</csymbol>
    <ci>N</ci>
    <ci>q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N\mod q
  </annotation>
 </semantics>
</math>

, and the output sequence is strictly periodic, then 

<math display="inline" id="Feedback_with_Carry_Shift_Registers:16">
 <semantics>
  <mrow>
   <msub>
    <mi>a</mi>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mi>A</mi>
       <msub>
        <mi>g</mi>
        <mi>i</mi>
       </msub>
      </mrow>
      <mo lspace="2.5pt" rspace="2.5pt">mod</mo>
      <mi>q</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo lspace="2.5pt" rspace="2.5pt">mod</mo>
    <mi>N</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">modulo</csymbol>
     <apply>
      <csymbol cd="latexml">modulo</csymbol>
      <apply>
       <times></times>
       <ci>A</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>g</ci>
        <ci>i</ci>
       </apply>
      </apply>
      <ci>q</ci>
     </apply>
     <ci>N</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{i}=(Ag_{i}\mod q)\mod N
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Feedback_with_Carry_Shift_Registers:17">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 is an integer. It follows that the period is at most the order of N in the multiplicative group of units modulo q. This is maximized when q is prime and N is a <a href="Primitive_root_modulo_n" title="wikilink">primitive element</a> modulo q. In this case, the period is 

<math display="inline" id="Feedback_with_Carry_Shift_Registers:18">
 <semantics>
  <mrow>
   <mi>q</mi>
   <mo>-</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>q</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q-1
  </annotation>
 </semantics>
</math>

. In this case the output sequence is called an l-sequence (for "long sequence").<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>

<p>l-sequences have many excellent statistical properties<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a><a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> that make them candidates for use in applications,<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> including near uniform distribution of sub-blocks, ideal arithmetic autocorrelations, and the arithmetic shift and add property. They are the with-carry analog of m-sequences or <a href="maximum_length_sequence" title="wikilink">maximum length sequences</a>.</p>

<p>There are efficient <a class="uri" href="algorithms" title="wikilink">algorithms</a> for FCSR synthesis. This is the problem: given a prefix of a sequence, construct a minimal length FCSR that outputs the sequence. This can be solved with a variant of Mahler<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> and De Weger's<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> lattice based analysis of N-adic numbers when 

<math display="inline" id="Feedback_with_Carry_Shift_Registers:19">
 <semantics>
  <mrow>
   <mi>N</mi>
   <mo>=</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>N</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N=2
  </annotation>
 </semantics>
</math>

;<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> by a variant of the Euclidean algorithm when N is prime; and in general by Xu's adaptation of the Berlekamp-Massey algorithm.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a> If L is the size of the smallest FCSR that outputs the sequence (called the N-adic complexity of the sequence), then all these algorithms require a prefix of length about 

<math display="inline" id="Feedback_with_Carry_Shift_Registers:20">
 <semantics>
  <mrow>
   <mn>2</mn>
   <mi>L</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <cn type="integer">2</cn>
    <ci>L</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2L
  </annotation>
 </semantics>
</math>

 to be successful and have quadratic time complexity. It follows that, as with LFSRs and linear complexity, any stream cipher whose N-adic complexity is low should not be used for cryptography.</p>

<p>FCSRs and LFSRs are special cases of a very general algebraic construction of sequence generators called Algebraic Feedback Shift Registers (AFSRs) in which the integers are replaced by an arbitrary ring R and N is replaced by an arbitrary non-unit in R.<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a> A general reference on the subject of LFSRs, FCSRs, and AFSRs is the book.<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a></p>
<h2 id="references">References</h2>
<references>
</references>

<p>"</p>

<p><a href="Category:Stream_ciphers" title="wikilink">Category:Stream ciphers</a> <a class="uri" href="Category:Cryptography" title="wikilink">Category:Cryptography</a> <a href="Category:Digital_registers" title="wikilink">Category:Digital registers</a> <a href="Category:Cryptographic_algorithms" title="wikilink">Category:Cryptographic algorithms</a> <a href="Category:Pseudorandom_number_generators" title="wikilink">Category:Pseudorandom number generators</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">M. Goresky and A. Klapper, <em>Efficient Multiply-with-Carry Random Number Generators with Optimal Distribution Properties, ACM Transactions on Modeling and Computer Simulation, vol 13, pp 310-321</em>, 2003, [<a class="uri" href="http://portal.acm.org/citation.cfm?id=945511.945514&amp;coll">http://portal.acm.org/citation.cfm?id=945511.945514&amp;coll;</a>;=portal&amp;dl;=ACM&amp;idx;=J781∂=transaction&amp;WantType;=Transactions&amp;title;=ACM%20Transactions%20on%20Modeling%20and%20Computer%20Simulation%20%28TOMACS%29&amp;CFID;=23002394&amp;CFTOKEN;=7200347]<a href="#fnref1">↩</a></li>
<li id="fn2"></li>
<li id="fn3"></li>
<li id="fn4"></li>
<li id="fn5">G. Marsaglia and A. Zaman, <em>A new class of random number generators, Annals of Applied Probability, vol 1, pp. 462–480</em>, 1991<a href="#fnref5">↩</a></li>
<li id="fn6"></li>
<li id="fn7"></li>
<li id="fn8"></li>
<li id="fn9"></li>
<li id="fn10">B. Schneier, <em>Applied Cryptography. John Wiley &amp; Sons, New York</em>, 1996<a href="#fnref10">↩</a></li>
<li id="fn11">K. Mahler, <em>On a geometrical representation of p–adic numbers, Ann. of Math., vol. 41, pp. 8–56</em>, 1940<a href="#fnref11">↩</a></li>
<li id="fn12">B. M. M. de Weger, Approximation lattices of p–adic numbers, J. Num. Th., vol 24, pp. 70–88'', 1986<a href="#fnref12">↩</a></li>
<li id="fn13"></li>
<li id="fn14">A. Klapper and J. Xu, ''Register Synthesis for Algebraic Feedback Shift Registers Based on Non-Primes, Designs, Codes, and Cryptography vo. 31, pp. 227-250", 2004<a href="#fnref14">↩</a></li>
<li id="fn15">A. Klapper and J. Xu, <em>Algebraic Feedback Shift Registers, Theoretical Computer Science, vol. 226, pp. 61-93</em>, 1999, [<a href="http://www.sciencedirect.com/science?_ob=ArticleURL&amp;_udi=B6V1G-3XBTTD9-8&amp;_user=10&amp;_coverDate=09%2F17%2F1999&amp;_alid=1053148847&amp;_rdoc=14&amp;_fmt=high&amp;_orig=search&amp;_cdi=5674&amp;_sort=r&amp;_docanchor">http://www.sciencedirect.com/science?_ob=ArticleURL&amp;_udi=B6V1G-3XBTTD9-8&amp;_user=10&amp;_coverDate=09%2F17%2F1999&amp;_alid=1053148847&amp;_rdoc=14&amp;_fmt=high&amp;_orig=search&amp;_cdi=5674&amp;_sort=r&amp;_docanchor</a>=&amp;view;=c&amp;_ct=16&amp;_acct=C000050221&amp;_version=1&amp;_urlVersion=0&amp;_userid=10&amp;md5;=a4c3ecea4ca8baaa26c7abebe8d3787b]<a href="#fnref15">↩</a></li>
<li id="fn16">M. Goresky and A. Klapper, Algebraic Shift Register Sequences, Cambridge University Press, 2012 ISBN 9781107014992<a href="#fnref16">↩</a></li>
</ol>
</section>
</ref></hr></body>
</html>
