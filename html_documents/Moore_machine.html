<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="290">Moore machine</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Moore machine</h1>
<hr/>

<p>In the <a href="theory_of_computation" title="wikilink">theory of computation</a>, a <strong>Moore machine</strong> is a <a href="finite-state_machine" title="wikilink">finite-state machine</a> whose output values are determined solely by its current <a href="state_(computer_science)" title="wikilink">state</a>. This is in contrast to a <a href="Mealy_machine" title="wikilink">Mealy machine</a>, whose output values are determined both by its current state and by the values of its inputs. The Moore machine is named after <a href="Edward_F._Moore" title="wikilink">Edward F. Moore</a>, who presented the concept in a 1956 paper, “<a href="Thought_experiment" title="wikilink">Gedanken-experiments</a> on Sequential Machines.”<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>
<h2 id="formal-definition">Formal definition</h2>

<p>A Moore machine can be defined as a <a href="N-tuple" title="wikilink">6-tuple</a> 

<math display="inline" id="Moore_machine:0">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>S</mi>
   <mo>,</mo>
   <msub>
    <mi>S</mi>
    <mn>0</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">Σ</mi>
   <mo>,</mo>
   <mi mathvariant="normal">Λ</mi>
   <mo>,</mo>
   <mi>T</mi>
   <mo>,</mo>
   <mi>G</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <ci>S</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>S</ci>
     <cn type="integer">0</cn>
    </apply>
    <ci>normal-Σ</ci>
    <ci>normal-Λ</ci>
    <ci>T</ci>
    <ci>G</ci>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (S,S_{0},\Sigma,\Lambda,T,G)
  </annotation>
 </semantics>
</math>

 consisting of the following:</p>
<ul>
<li>a finite set of <a href="State_(computer_science)" title="wikilink">states</a> 

<math display="inline" id="Moore_machine:1">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

</li>
<li>a start state (also called initial state) 

<math display="inline" id="Moore_machine:2">
 <semantics>
  <msub>
   <mi>S</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>S</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{0}
  </annotation>
 </semantics>
</math>

 which is an element of 

<math display="inline" id="Moore_machine:3">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

</li>
<li>a finite set called the input <a href="Alphabet_(computer_science)" title="wikilink">alphabet</a> 

<math display="inline" id="Moore_machine:4">
 <semantics>
  <mi mathvariant="normal">Σ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma
  </annotation>
 </semantics>
</math>

</li>
<li>a finite set called the output <a href="Alphabet_(computer_science)" title="wikilink">alphabet</a> 

<math display="inline" id="Moore_machine:5">
 <semantics>
  <mi mathvariant="normal">Λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Lambda
  </annotation>
 </semantics>
</math>

</li>
<li>a transition <a href="function_(mathematics)" title="wikilink">function</a> 

<math display="inline" id="Moore_machine:6">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mi>S</mi>
     <mo>×</mo>
     <mi mathvariant="normal">Σ</mi>
    </mrow>
    <mo>→</mo>
    <mi>S</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>T</ci>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <times></times>
      <ci>S</ci>
      <ci>normal-Σ</ci>
     </apply>
     <ci>S</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T:S\times\Sigma\rightarrow S
  </annotation>
 </semantics>
</math>

 mapping a state and the input alphabet to the next state</li>
<li>an output function 

<math display="inline" id="Moore_machine:7">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mo>:</mo>
   <mrow>
    <mi>S</mi>
    <mo>→</mo>
    <mi mathvariant="normal">Λ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>G</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>S</ci>
     <ci>normal-Λ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G:S\rightarrow\Lambda
  </annotation>
 </semantics>
</math>

 mapping each state to the output alphabet</li>
</ul>

<p>A Moore machine can be regarded as a restricted type of <a href="finite_state_transducer" title="wikilink">finite state transducer</a>.</p>
<h2 id="visual-representation">Visual representation</h2>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>States</p></th>
<th style="text-align: left;">
<p>a</p></th>
<th style="text-align: left;">
<p>b</p></th>
<th style="text-align: left;">
<p>output</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>q0</p></td>
<td style="text-align: left;">
<p>q0</p></td>
<td style="text-align: left;">
<p>q2</p></td>
<td style="text-align: left;">
<p>1</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>q1</p></td>
<td style="text-align: left;">
<p>q1</p></td>
<td style="text-align: left;">
<p>q1</p></td>
<td style="text-align: left;">
<p>0</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>q2</p></td>
<td style="text-align: left;">
<p>q1</p></td>
<td style="text-align: left;">
<p>q0</p></td>
<td style="text-align: left;">
<p>1</p></td>
</tr>
</tbody>
</table>
<h3 id="table">Table</h3>

<p><a href="State_transition_table" title="wikilink">State transition table</a> is a table showing relation between an input and a state.</p>
<h3 id="diagram">Diagram</h3>

<p>The <a href="state_diagram" title="wikilink">state diagram</a> for a Moore machine or Moore diagram is a diagram that associates an output value with each state. Moore machine is output producer</p>
<h2 id="relationship-with-mealy-machines">Relationship with Mealy machines</h2>

<p>The difference between Moore machines and <a href="Mealy_machine" title="wikilink">Mealy machines</a> is that in the latter, the output of a transition is determined by the combination of current <a href="state_(computer_science)" title="wikilink">state</a> and current input (

<math display="inline" id="Moore_machine:8">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>×</mo>
   <mi mathvariant="normal">Σ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>S</ci>
    <ci>normal-Σ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S\times\Sigma
  </annotation>
 </semantics>
</math>

 as the input to 

<math display="inline" id="Moore_machine:9">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

), as opposed to just the current state (

<math display="inline" id="Moore_machine:10">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 as the input to 

<math display="inline" id="Moore_machine:11">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

). When represented as a <a href="state_diagram" title="wikilink">state diagram</a>,</p>
<ul>
<li>for a Moore machine, each node (state) is labeled with an output value;</li>
<li>for a Mealy machine, each arc (transition) is labeled with an output value.</li>
</ul>

<p>Every Moore machine 

<math display="inline" id="Moore_machine:12">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 is equivalent to the Mealy machine with the same states and transitions and the output function 

<math display="inline" id="Moore_machine:13">
 <semantics>
  <mrow>
   <mrow>
    <mi>G</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>s</mi>
     <mo>,</mo>
     <mi>σ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>→</mo>
   <mrow>
    <msub>
     <mi>G</mi>
     <mi>M</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>s</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <times></times>
     <ci>G</ci>
     <interval closure="open">
      <ci>s</ci>
      <ci>σ</ci>
     </interval>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>G</ci>
      <ci>M</ci>
     </apply>
     <ci>s</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G(s,\sigma)\rightarrow G_{M}(s)
  </annotation>
 </semantics>
</math>

, which takes each state-input pair 

<math display="inline" id="Moore_machine:14">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>s</mi>
   <mo>,</mo>
   <mi>σ</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>s</ci>
    <ci>σ</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (s,\sigma)
  </annotation>
 </semantics>
</math>

 and yields 

<math display="inline" id="Moore_machine:15">
 <semantics>
  <mrow>
   <msub>
    <mi>G</mi>
    <mi>M</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>s</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>G</ci>
     <ci>M</ci>
    </apply>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G_{M}(s)
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Moore_machine:16">
 <semantics>
  <msub>
   <mi>G</mi>
   <mi>M</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>G</ci>
    <ci>M</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G_{M}
  </annotation>
 </semantics>
</math>

 is 

<math display="inline" id="Moore_machine:17">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

's output function.</p>

<p>However, not every Mealy machine can be converted to an equivalent Moore machine. Some can be converted only to an almost equivalent Moore machine, with outputs shifted in time. This is due to the way that state labels are paired with transition labels to form the input/output pairs. Consider a transition 

<math display="inline" id="Moore_machine:18">
 <semantics>
  <mrow>
   <msub>
    <mi>s</mi>
    <mi>i</mi>
   </msub>
   <mo>→</mo>
   <msub>
    <mi>s</mi>
    <mi>j</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>s</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>s</ci>
     <ci>j</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s_{i}\rightarrow s_{j}
  </annotation>
 </semantics>
</math>

 from state 

<math display="inline" id="Moore_machine:19">
 <semantics>
  <msub>
   <mi>s</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>s</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s_{i}
  </annotation>
 </semantics>
</math>

 to state 

<math display="inline" id="Moore_machine:20">
 <semantics>
  <msub>
   <mi>s</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>s</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s_{j}
  </annotation>
 </semantics>
</math>

. The input causing the transition 

<math display="inline" id="Moore_machine:21">
 <semantics>
  <mrow>
   <msub>
    <mi>s</mi>
    <mi>i</mi>
   </msub>
   <mo>→</mo>
   <msub>
    <mi>s</mi>
    <mi>j</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>s</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>s</ci>
     <ci>j</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s_{i}\rightarrow s_{j}
  </annotation>
 </semantics>
</math>

 labels the edge 

<math display="inline" id="Moore_machine:22">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msub>
    <mi>s</mi>
    <mi>i</mi>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>s</mi>
    <mi>j</mi>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>s</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>s</ci>
     <ci>j</ci>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (s_{i},s_{j})
  </annotation>
 </semantics>
</math>

. The output corresponding to that input, is the label of state 

<math display="inline" id="Moore_machine:23">
 <semantics>
  <msub>
   <mi>s</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>s</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s_{i}
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> Notice that this is the source state of the transition. So for each input, the output is already fixed before the input is received, and depends solely on the present state. This is the original definition by E. Moore. It is a common mistake to use the label of state 

<math display="inline" id="Moore_machine:24">
 <semantics>
  <msub>
   <mi>s</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>s</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s_{j}
  </annotation>
 </semantics>
</math>

 as output for the transition 

<math display="inline" id="Moore_machine:25">
 <semantics>
  <mrow>
   <msub>
    <mi>s</mi>
    <mi>i</mi>
   </msub>
   <mo>→</mo>
   <msub>
    <mi>s</mi>
    <mi>j</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>s</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>s</ci>
     <ci>j</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s_{i}\rightarrow s_{j}
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="examples">Examples</h2>

<p>Types according to number of inputs/outputs.</p>
<h3 id="simple">Simple</h3>

<p>Simple Moore machines have one input and one output:</p>
<ul>
<li><a href="Edge_detection" title="wikilink">edge detector</a> using <a class="uri" href="XOR" title="wikilink">XOR</a></li>
<li><a href="wikibooks:Fractals/Mathematics/group/Binary_adding_machine" title="wikilink">binary adding machine</a></li>
<li><a href="Clocked_sequential_system#Clocked_sequential_system" title="wikilink">clocked sequential systems</a> (a restricted form of Moore machine where the state changes only when the global clock signal changes)</li>
</ul>

<p>Most digital electronic systems are designed as <a href="Clocked_sequential_system#Clocked_sequential_system" title="wikilink">clocked sequential systems</a>. Clocked sequential systems are a restricted form of Moore machine where the state changes only when the global clock signal changes. Typically the current state is stored in <a href="Flip-flop_(electronics)" title="wikilink">flip-flops</a>, and a global clock signal is connected to the "clock" input of the flip-flops. Clocked sequential systems are one way to solve <a href="Metastability_in_electronics" title="wikilink">metastability</a> problems. A typical electronic Moore machine includes a <a href="combinational_logic" title="wikilink">combinational logic</a> chain to decode the current state into the outputs (lambda). The instant the current state changes, those changes ripple through that chain, and almost instantaneously the output gets updated. There are design techniques to ensure that no <a href="glitch" title="wikilink">glitches</a> occur on the outputs during that brief period while those changes are rippling through the chain, but most systems are designed so that glitches during that brief transition time are ignored or are irrelevant. The outputs then stay the same indefinitely (<a href="LED" title="wikilink">LEDs</a> stay bright, power stays connected to the motors, <a href="solenoid" title="wikilink">solenoids</a> stay energized, etc.), until the Moore machine changes state again.</p>
<figure><b>(Figure)</b>
<figcaption>Moore machine in combinational logic</figcaption>
</figure>
<h3 id="complex">Complex</h3>

<p>More complex Moore machines can have multiple inputs as well as multiple outputs.</p>
<h2 id="gedanken-experiments">Gedanken-experiments</h2>

<p>In Moore's paper "<a href="Thought_experiment" title="wikilink">Gedanken-experiments</a> on Sequential Machines",<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> the 

<math display="inline" id="Moore_machine:26">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>n</mi>
   <mo>;</mo>
   <mi>m</mi>
   <mo>;</mo>
   <mi>p</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>n</ci>
    <ci>m</ci>
    <ci>p</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (n;m;p)
  </annotation>
 </semantics>
</math>

 automata (or machines) 

<math display="inline" id="Moore_machine:27">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 are defined as having 

<math display="inline" id="Moore_machine:28">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 states, 

<math display="inline" id="Moore_machine:29">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

 input symbols and 

<math display="inline" id="Moore_machine:30">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 output symbols. Nine theorems are proved about the structure of 

<math display="inline" id="Moore_machine:31">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

, and experiments with 

<math display="inline" id="Moore_machine:32">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

. Later, "

<math display="inline" id="Moore_machine:33">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 machines" became known as "Moore machines".</p>

<p>At the end of the paper, in Section "Further problems", the following task is stated:</p>
<blockquote>

<p>Another directly following problem is the improvement of the bounds given at the theorems 8 and 9.</p>
</blockquote>

<p>Moore's Theorem 8 is formulated as:</p>
<blockquote>

<p>Given an arbitrary 

<math display="inline" id="Moore_machine:34">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>n</mi>
   <mo>;</mo>
   <mi>m</mi>
   <mo>;</mo>
   <mi>p</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>n</ci>
    <ci>m</ci>
    <ci>p</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (n;m;p)
  </annotation>
 </semantics>
</math>

 machine 

<math display="inline" id="Moore_machine:35">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

, such that every two of its states are distinguishable from one another, then there exists an experiment of length 

<math display="inline" id="Moore_machine:36">
 <semantics>
  <mfrac>
   <mrow>
    <mi>n</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>n</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mn>2</mn>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <times></times>
     <ci>n</ci>
     <apply>
      <minus></minus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tfrac{n(n-1)}{2}
  </annotation>
 </semantics>
</math>

 which determines the state of 

<math display="inline" id="Moore_machine:37">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 at the end of the experiment.</p>
</blockquote>

<p>In 1957, <a href="Anatolii_Alexeevitch_Karatsuba" title="wikilink">A. A. Karatsuba</a> proved the following two theorems, which completely solved Moore's problem on the improvement of the bounds of the experiment length of his "Theorem 8".</p>
<blockquote>

<p><strong>Theorem A.</strong> If 

<math display="inline" id="Moore_machine:38">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 is an 

<math display="inline" id="Moore_machine:39">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>n</mi>
   <mo>;</mo>
   <mi>m</mi>
   <mo>;</mo>
   <mi>p</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>n</ci>
    <ci>m</ci>
    <ci>p</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (n;m;p)
  </annotation>
 </semantics>
</math>

 machine, such that every two of its states are distinguishable from one another, then there exists a branched experiment of length at most 

<math display="inline" id="Moore_machine:40">
 <semantics>
  <mrow>
   <mfrac>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mn>2</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mn>2</mn>
   </mfrac>
   <mo>+</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <apply>
       <minus></minus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <minus></minus>
       <ci>n</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <cn type="integer">2</cn>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tfrac{(n-1)(n-2)}{2}+1
  </annotation>
 </semantics>
</math>

 through which one may determine the state of 

<math display="inline" id="Moore_machine:41">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 at the end of the experiment.</p>
</blockquote>
<blockquote>

<p><strong>Theorem B.</strong> There exists an 

<math display="inline" id="Moore_machine:42">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>n</mi>
   <mo>;</mo>
   <mi>m</mi>
   <mo>;</mo>
   <mi>p</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>n</ci>
    <ci>m</ci>
    <ci>p</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (n;m;p)
  </annotation>
 </semantics>
</math>

 machine, every two states of which are distinguishable from one another, such that the length of the shortest experiments establishing the state of the machine at the end of the experiment is equal to 

<math display="inline" id="Moore_machine:43">
 <semantics>
  <mrow>
   <mfrac>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mn>2</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mn>2</mn>
   </mfrac>
   <mo>+</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <apply>
       <minus></minus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <minus></minus>
       <ci>n</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <cn type="integer">2</cn>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tfrac{(n-1)(n-2)}{2}+1
  </annotation>
 </semantics>
</math>

.</p>
</blockquote>

<p>Theorems A and B were used for the basis of the course work of a student of the fourth year, A. A. Karatsuba, "On a problem from the automata theory", which was distinguished by testimonial reference at the competition of student works of the faculty of mechanics and mathematics of Moscow Lomonosow State University in 1958. The paper by Karatsuba was given to the journal <em>Uspekhi Mat. Nauk</em> on 17 December 1958 and was published there in June 1960.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>

<p>Until the present day (2011), Karatsuba's result on the length of experiments is the only exact nonlinear result, both in automata theory, and in similar problems of computational complexity theory.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Synchronous_circuit" title="wikilink">Synchronous circuit</a></li>
<li><a href="Mealy_machine" title="wikilink">Mealy machine</a></li>
<li><a href="Algorithmic_state_machine" title="wikilink">Algorithmic state machine</a></li>
</ul>
<h2 id="references">References</h2>
<h2 id="further-reading">Further reading</h2>
<ul>
<li></li>
<li>Moore E. F. Gedanken-experiments on Sequential Machines. Automata Studies, Annals of Mathematical Studies, 34, 129–153. Princeton University Press, Princeton, N.J.(1956).</li>
<li>Karatsuba A. A. Solution of one problem from the theory of finite automata. Usp. Mat. Nauk, 15:3, 157–159 (1960).</li>
<li>Karacuba A. A. Experimente mit Automaten (German) Elektron. Informationsverarb. Kybernetik, 11, 611–612 (1975).</li>
<li>Karatsuba A. A. <em><a href="http://www.mi.ras.ru/~karatsuba/list_e.html">List of research works</a></em></li>
</ul>

<p>its length is n+1/2."</p>

<p><a href="Category:Models_of_computation" title="wikilink">Category:Models of computation</a> <a href="Category:Automata_theory" title="wikilink">Category:Automata theory</a> <a href="Category:Digital_electronics" title="wikilink">Category:Digital electronics</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
</ol>
</section>
</body>
</html>
