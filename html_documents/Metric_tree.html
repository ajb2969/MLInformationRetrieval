<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="308">Metric tree</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Metric tree</h1>
<hr/>

<p>A <strong>metric tree</strong> is any <a href="tree_(data_structure)" title="wikilink">tree</a> <a href="data_structure" title="wikilink">data structure</a> specialized to index data in <a href="metric_space" title="wikilink">metric spaces</a>. Metric trees exploit properties of metric spaces such as the <a href="triangle_inequality" title="wikilink">triangle inequality</a> to make accesses to the data more efficient. Examples include the <a class="uri" href="M-tree" title="wikilink">M-tree</a>, <a href="vp-tree" title="wikilink">vp-trees</a>, <a href="cover_tree" title="wikilink">cover trees</a>, <a href="MVP_Tree" title="wikilink">MVP Trees</a>, and <a href="bk_tree" title="wikilink">bk trees</a>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>
<h2 id="multidimensional-search">Multidimensional search</h2>

<p>Most algorithms and data structures for searching a dataset are based on the classical <a href="binary_search" title="wikilink">binary search</a> algorithm, and generalizations such as the <a href="k-d_tree" title="wikilink">k-d tree</a> or <a href="range_tree" title="wikilink">range tree</a> work by interleaving the <a href="binary_search_algorithm" title="wikilink">binary search algorithm</a> over the separate coordinates and treating each spatial coordinate as an independent search constraint. These data structures are well-suited for <a href="range_query" title="wikilink">range query</a> problems asking for every point 

<math display="inline" id="Metric_tree:0">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>x</mi>
   <mo>,</mo>
   <mi>y</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>x</ci>
    <ci>y</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x,y)
  </annotation>
 </semantics>
</math>

 that satisfies 

<math display="inline" id="Metric_tree:1">
 <semantics>
  <mrow>
   <msub>
    <mtext>min</mtext>
    <mi>x</mi>
   </msub>
   <mo>≤</mo>
   <mi>x</mi>
   <mo>≤</mo>
   <msub>
    <mtext>max</mtext>
    <mi>x</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <mtext>min</mtext>
      <ci>x</ci>
     </apply>
     <ci>x</ci>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <mtext>max</mtext>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mbox{min}_{x}\leq x\leq\mbox{max}_{x}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Metric_tree:2">
 <semantics>
  <mrow>
   <msub>
    <mtext>min</mtext>
    <mi>y</mi>
   </msub>
   <mo>≤</mo>
   <mi>y</mi>
   <mo>≤</mo>
   <msub>
    <mtext>max</mtext>
    <mi>y</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <mtext>min</mtext>
      <ci>y</ci>
     </apply>
     <ci>y</ci>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <mtext>max</mtext>
      <ci>y</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mbox{min}_{y}\leq y\leq\mbox{max}_{y}
  </annotation>
 </semantics>
</math>

.</p>

<p>A limitation of these multidimensional search structures is that they are only defined for searching over objects that can be treated as vectors. They aren't applicable for the more general case in which the algorithm is given only a collection of objects and a function for measuring the distance or similarity between two objects. If, for example, someone were to create a function that returns a value indicating how similar one image is to another, a natural algorithmic problem would be to take a dataset of images and find the ones that are similar according to the function to a given query image.</p>
<h2 id="metric-data-structures">Metric data structures</h2>

<p>If there is no structure to the similarity measure then a <a href="brute_force_search" title="wikilink">brute force search</a> requiring the comparison of the query image to every image in the dataset is the best that can be done . If, however, the similarity function satisfies the <a href="triangle_inequality" title="wikilink">triangle inequality</a> then it is possible to use the result of each comparison to prune the set of candidates to be examined.</p>

<p>The first article on metric trees, as well as the first use of the term "metric tree", published in the open literature was by <a href="Jeffrey_Uhlmann" title="wikilink">Jeffrey Uhlmann</a> in 1991.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> Other researchers were working independently on similar data structures. In particular, Peter Yianilos claimed to have independently discovered the same method, which he called a <a href="Vantage-point_tree" title="wikilink">vantage point tree</a> (VP-tree).<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> The research on metric tree data structures blossomed in the late 1990s and included an examination by Google co-founder <a href="Sergey_Brin" title="wikilink">Sergey Brin</a> of their use for very large databases.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> The first textbook on metric data structures was published in 2006.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>
<h2 id="references">References</h2>

<p>"</p>

<p><a href="Category:Trees_(data_structures)" title="wikilink">Category:Trees (data structures)</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"></li>
</ol>
</section>
</body>
</html>
