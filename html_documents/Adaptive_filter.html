<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="650">Adaptive filter</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Adaptive filter</h1>
<hr/>

<p>An <strong>adaptive filter</strong> is a system with a linear <a href="filter_(signal_processing)" title="wikilink">filter</a> that has a <a href="transfer_function" title="wikilink">transfer function</a> controlled by variable parameters and a means to adjust those parameters according to an <a href="optimization_algorithm" title="wikilink">optimization algorithm</a>. Because of the complexity of the optimization algorithms, most adaptive filters are <a href="digital_filter" title="wikilink">digital filters</a>. Adaptive filters are required for some applications because some parameters of the desired processing operation (for instance, the locations of reflective surfaces in a <a class="uri" href="reverberant" title="wikilink">reverberant</a> space) are not known in advance or are changing. The closed loop adaptive filter uses feedback in the form of an error signal to refine its transfer function.</p>

<p>Generally speaking, the closed loop adaptive process involves the use of a <a href="Loss_function" title="wikilink">cost function</a>, which is a criterion for optimum performance of the filter, to feed an algorithm, which determines how to modify filter transfer function to minimize the cost on the next iteration. The most common cost function is the mean square of the error signal.</p>

<p>As the power of <a href="digital_signal_processor" title="wikilink">digital signal processors</a> has increased, adaptive filters have become much more common and are now routinely used in devices such as mobile phones and other communication devices, camcorders and digital cameras, and medical monitoring equipment.</p>
<h2 id="example-application">Example application</h2>

<p>The recording of a heart beat (an <a class="uri" href="ECG" title="wikilink">ECG</a>), may be corrupted by noise from the <a href="power_supply" title="wikilink">AC mains</a>. The exact frequency of the power and its <a class="uri" href="harmonics" title="wikilink">harmonics</a> may vary from moment to moment.</p>

<p>One way to remove the noise is to filter the signal with a <a href="notch_filter" title="wikilink">notch filter</a> at the mains frequency and its vicinity, which could excessively degrade the quality of the ECG since the heart beat would also likely have frequency components in the rejected range.</p>

<p>To circumvent this potential loss of information, an adaptive filter could be used. The adaptive filter would take input both from the patient and from the mains and would thus be able to track the actual frequency of the noise as it fluctuates and subtract the noise from the recording. Such an adaptive technique generally allows for a filter with a smaller rejection range, which means, in this case, that the quality of the output signal is more accurate for medical purposes.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>
<h2 id="block-diagram">Block diagram</h2>

<p>The idea behind a closed loop adaptive filter is that a variable filter is adjusted until the error (the difference between the filter output and the desired signal) is minimized. The <a href="Least_mean_squares_filter" title="wikilink">Least Mean Squares (LMS) filter</a> and the <a href="Recursive_least_squares_filter" title="wikilink">Recursive Least Squares (RLS) filter</a> are types of adaptive filter.</p>
<dl>
<dd>
</dd>
</dl>
<figure><b>(Figure)</b>
<figcaption>Adaptive Filter, compact representation. k = sample number, x = reference input, d = desired input, Œµ = error output, f = filter impulse response, Œ£ = summation, box=linear filter and adaption algorithm.</figcaption>
</figure>

<p>There are two input signals to the adaptive filter: <em>d</em><sub>k</sub> and <em>x</em><sub>k</sub> which are sometimes called the <em>primary input</em> and the <em>reference input</em> respectively.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>

<p>

<math display="block" id="Adaptive_filter:0">
 <semantics>
  <msub>
   <mi>d</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>d</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d_{k}
  </annotation>
 </semantics>
</math>

 which includes the desired signal plus undesired interference and</p>

<p>

<math display="block" id="Adaptive_filter:1">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{k}
  </annotation>
 </semantics>
</math>

 which includes the signals that are correlated to some of the undesired interference in 

<math display="inline" id="Adaptive_filter:2">
 <semantics>
  <msub>
   <mi>d</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>d</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d_{k}
  </annotation>
 </semantics>
</math>

.</p>
<dl>
<dd>k represents the discrete sample number.
</dd>
</dl>

<p>The filter is controlled by a set of L+1 coefficients or weights.</p>

<p>

<math display="block" id="Adaptive_filter:3">
 <semantics>
  <mrow>
   <msub>
    <mi>ùêñ</mi>
    <mi>k</mi>
   </msub>
   <mo>=</mo>
   <msup>
    <mrow>
     <mo>[</mo>
     <msub>
      <mi>w</mi>
      <mrow>
       <mn>0</mn>
       <mi>k</mi>
      </mrow>
     </msub>
     <mo rspace="4.2pt">,</mo>
     <msub>
      <mi>w</mi>
      <mrow>
       <mn>1</mn>
       <mi>k</mi>
      </mrow>
     </msub>
     <mo rspace="4.2pt">,</mo>
     <mi mathvariant="normal">‚Ä¶</mi>
     <mo rspace="4.2pt">,</mo>
     <msub>
      <mi>w</mi>
      <mrow>
       <mi>L</mi>
       <mi>k</mi>
      </mrow>
     </msub>
     <mo>]</mo>
    </mrow>
    <mi>T</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ùêñ</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <list>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>w</ci>
       <apply>
        <times></times>
        <cn type="integer">0</cn>
        <ci>k</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>w</ci>
       <apply>
        <times></times>
        <cn type="integer">1</cn>
        <ci>k</ci>
       </apply>
      </apply>
      <ci>normal-‚Ä¶</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>w</ci>
       <apply>
        <times></times>
        <ci>L</ci>
        <ci>k</ci>
       </apply>
      </apply>
     </list>
     <ci>T</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{W}_{k}=\left[w_{0k},\,w_{1k},\,...,\,w_{Lk}\right]^{T}
  </annotation>
 </semantics>
</math>

 represents the set or vector of weights, which control the filter at sample time k.</p>
<dl>
<dd><dl>
<dd>where 

<math display="inline" id="Adaptive_filter:4">
 <semantics>
  <msub>
   <mi>w</mi>
   <mrow>
    <mi>l</mi>
    <mi>k</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>w</ci>
    <apply>
     <times></times>
     <ci>l</ci>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w_{lk}
  </annotation>
 </semantics>
</math>

 refers to the 

<math display="inline" id="Adaptive_filter:5">
 <semantics>
  <mi>l</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>l</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   l
  </annotation>
 </semantics>
</math>

'th weight at k'th time.
</dd>
</dl>
</dd>
<dd>

<math display="inline" id="Adaptive_filter:6">
 <semantics>
  <mrow>
   <mi>ùö´</mi>
   <msub>
    <mi>ùêñ</mi>
    <mi>k</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>ùö´</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ùêñ</ci>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{\Delta W}_{k}
  </annotation>
 </semantics>
</math>

 represents the change in the weights that occurs as a result of adjustments computed at sample time k.
<dl>
<dd>These changes will be applied after sample time k and before they are used at sample time k+1.
</dd>
</dl>
</dd>
</dl>

<p>The output is usually 

<math display="inline" id="Adaptive_filter:7">
 <semantics>
  <msub>
   <mi>œµ</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>œµ</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon_{k}
  </annotation>
 </semantics>
</math>

 but it could be 

<math display="inline" id="Adaptive_filter:8">
 <semantics>
  <msub>
   <mi>y</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>y</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{k}
  </annotation>
 </semantics>
</math>

 or it could even be the filter coefficients.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a>(Widrow)</p>

<p>The input signals are defined as follows:</p>

<p>

<math display="block" id="Adaptive_filter:9">
 <semantics>
  <mrow>
   <msub>
    <mi>d</mi>
    <mi>k</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>g</mi>
     <mi>k</mi>
    </msub>
    <mo>+</mo>
    <msub>
     <mi>u</mi>
     <mi>k</mi>
    </msub>
    <mo>+</mo>
    <msub>
     <mi>v</mi>
     <mi>k</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>d</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>g</ci>
      <ci>k</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>u</ci>
      <ci>k</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>v</ci>
      <ci>k</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d_{k}=g_{k}+u_{k}+v_{k}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Adaptive_filter:10">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mi>k</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mi>g</mi>
     <mi>k</mi>
     <msup>
      <mi></mi>
      <mo>‚Ä≤</mo>
     </msup>
    </msubsup>
    <mo>+</mo>
    <msubsup>
     <mi>u</mi>
     <mi>k</mi>
     <msup>
      <mi></mi>
      <mo>‚Ä≤</mo>
     </msup>
    </msubsup>
    <mo>+</mo>
    <msubsup>
     <mi>v</mi>
     <mi>k</mi>
     <msup>
      <mi></mi>
      <mo>‚Ä≤</mo>
     </msup>
    </msubsup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>g</ci>
       <ci>k</ci>
      </apply>
      <apply>
       <ci>normal-‚Ä≤</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>u</ci>
       <ci>k</ci>
      </apply>
      <apply>
       <ci>normal-‚Ä≤</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>v</ci>
       <ci>k</ci>
      </apply>
      <apply>
       <ci>normal-‚Ä≤</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{k}=g_{k}^{^{\prime}}+u_{k}^{^{\prime}}+v_{k}^{^{\prime}}
  </annotation>
 </semantics>
</math>

</p>
<dl>
<dd>where:
<dl>
<dd><em>g</em> = the desired signal,
</dd>
<dd><em>g</em>' = a signal that is correlated with the desired signal ''g '',
</dd>
<dd><em>u</em> = an undesired signal that is added to ''g '', but not correlated with ''g '' or ''g' ''
</dd>
<dd>''u' '' = a signal that is correlated with the undesired signal ''u '',but not correlated with ''g '' or ''g' '',
</dd>
<dd>v = an undesired signal (typically random noise) not correlated with ''g '', ''g' '', <em>u</em>, ''u' '' or ''v' '',
</dd>
<dd>v' = an undesired signal (typically random noise) not correlated with ''g '', ''g' '', <em>u</em>, ''u' '' or <em>v</em>.
</dd>
</dl>
</dd>
</dl>

<p>The output signals are defined as follows:</p>

<p>

<math display="block" id="Adaptive_filter:11">
 <semantics>
  <mrow>
   <msub>
    <mi>y</mi>
    <mi>k</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mover accent="true">
      <mi>g</mi>
      <mo stretchy="false">^</mo>
     </mover>
     <mi>k</mi>
    </msub>
    <mo>+</mo>
    <msub>
     <mover accent="true">
      <mi>u</mi>
      <mo stretchy="false">^</mo>
     </mover>
     <mi>k</mi>
    </msub>
    <mo>+</mo>
    <msub>
     <mover accent="true">
      <mi>v</mi>
      <mo stretchy="false">^</mo>
     </mover>
     <mi>k</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <ci>normal-^</ci>
       <ci>g</ci>
      </apply>
      <ci>k</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <ci>normal-^</ci>
       <ci>u</ci>
      </apply>
      <ci>k</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <ci>normal-^</ci>
       <ci>v</ci>
      </apply>
      <ci>k</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{k}=\hat{g}_{k}+\hat{u}_{k}+\hat{v}_{k}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Adaptive_filter:12">
 <semantics>
  <mrow>
   <msub>
    <mi>œµ</mi>
    <mi>k</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>d</mi>
     <mi>k</mi>
    </msub>
    <mo>-</mo>
    <msub>
     <mi>y</mi>
     <mi>k</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>œµ</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>d</ci>
      <ci>k</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <ci>k</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon_{k}=d_{k}-y_{k}
  </annotation>
 </semantics>
</math>

.</p>
<dl>
<dd>where:

<p>

<math display="block" id="Adaptive_filter:13">
 <semantics>
  <mover accent="true">
   <mi>g</mi>
   <mo stretchy="false">^</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-^</ci>
    <ci>g</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{g}
  </annotation>
 </semantics>
</math>

 = the output of the filter if the input was only ''g' '',</p>

<p>

<math display="block" id="Adaptive_filter:14">
 <semantics>
  <mover accent="true">
   <mi>u</mi>
   <mo stretchy="false">^</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-^</ci>
    <ci>u</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{u}
  </annotation>
 </semantics>
</math>

 = the output of the filter if the input was only ''u' '',</p>

<p>

<math display="block" id="Adaptive_filter:15">
 <semantics>
  <mover accent="true">
   <mi>v</mi>
   <mo stretchy="false">^</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-^</ci>
    <ci>v</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{v}
  </annotation>
 </semantics>
</math>

 = the output of the filter if the input was only ''v' ''.</p>
</dd>
</dl>
<h3 id="tapped-delay-line-fir-filter">Tapped delay line FIR filter</h3>

<p>If the variable filter has a tapped delay line <a href="Finite_impulse_response" title="wikilink">Finite Impulse Response (FIR)</a> structure, then the impulse response is equal to the filter coefficients. The output of the filter is given by</p>

<p>

<math display="block" id="Adaptive_filter:16">
 <semantics>
  <mrow>
   <msub>
    <mi>y</mi>
    <mi>k</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">‚àë</mo>
     <mrow>
      <mi>l</mi>
      <mo>=</mo>
      <mn>0</mn>
     </mrow>
     <mi>L</mi>
    </munderover>
    <mrow>
     <mpadded width="+5pt">
      <msub>
       <mi>w</mi>
       <mrow>
        <mi>l</mi>
        <mi>k</mi>
       </mrow>
      </msub>
     </mpadded>
     <msub>
      <mi>x</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>k</mi>
        <mo>-</mo>
        <mi>l</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </msub>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mover accent="true">
      <mi>g</mi>
      <mo stretchy="false">^</mo>
     </mover>
     <mi>k</mi>
    </msub>
    <mo>+</mo>
    <msub>
     <mover accent="true">
      <mi>u</mi>
      <mo stretchy="false">^</mo>
     </mover>
     <mi>k</mi>
    </msub>
    <mo>+</mo>
    <msub>
     <mover accent="true">
      <mi>v</mi>
      <mo stretchy="false">^</mo>
     </mover>
     <mi>k</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <ci>k</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>l</ci>
         <cn type="integer">0</cn>
        </apply>
       </apply>
       <ci>L</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>w</ci>
        <apply>
         <times></times>
         <ci>l</ci>
         <ci>k</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <apply>
         <minus></minus>
         <ci>k</ci>
         <ci>l</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <ci>normal-^</ci>
        <ci>g</ci>
       </apply>
       <ci>k</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <ci>normal-^</ci>
        <ci>u</ci>
       </apply>
       <ci>k</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <ci>normal-^</ci>
        <ci>v</ci>
       </apply>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{k}=\sum_{l=0}^{L}w_{lk}\ x_{(k-l)}=\hat{g}_{k}+\hat{u}_{k}+\hat{v}_{k}
  </annotation>
 </semantics>
</math>

</p>
<dl>
<dd><dl>
<dd>where 

<math display="inline" id="Adaptive_filter:17">
 <semantics>
  <msub>
   <mi>w</mi>
   <mrow>
    <mi>l</mi>
    <mi>k</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>w</ci>
    <apply>
     <times></times>
     <ci>l</ci>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w_{lk}
  </annotation>
 </semantics>
</math>

 refers to the 

<math display="inline" id="Adaptive_filter:18">
 <semantics>
  <mi>l</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>l</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   l
  </annotation>
 </semantics>
</math>

'th weight at k'th time.
</dd>
</dl>
</dd>
</dl>
<h3 id="ideal-case">Ideal case</h3>

<p>In the ideal case 

<math display="inline" id="Adaptive_filter:19">
 <semantics>
  <mrow>
   <mrow>
    <mi>v</mi>
    <mo>‚â°</mo>
    <mn>0</mn>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mrow>
     <msup>
      <mi>v</mi>
      <msup>
       <mi></mi>
       <mo>‚Ä≤</mo>
      </msup>
     </msup>
     <mo>‚â°</mo>
     <mn>0</mn>
    </mrow>
    <mo>,</mo>
    <mrow>
     <msup>
      <mi>g</mi>
      <msup>
       <mi></mi>
       <mo>‚Ä≤</mo>
      </msup>
     </msup>
     <mo>‚â°</mo>
     <mn>0</mn>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <equivalent></equivalent>
     <ci>v</ci>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">formulae-sequence</csymbol>
     <apply>
      <equivalent></equivalent>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>v</ci>
       <apply>
        <ci>normal-‚Ä≤</ci>
       </apply>
      </apply>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <equivalent></equivalent>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>g</ci>
       <apply>
        <ci>normal-‚Ä≤</ci>
       </apply>
      </apply>
      <cn type="integer">0</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v\equiv 0,v^{^{\prime}}\equiv 0,g^{^{\prime}}\equiv 0
  </annotation>
 </semantics>
</math>

. All the undesired signals in 

<math display="inline" id="Adaptive_filter:20">
 <semantics>
  <msub>
   <mi>d</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>d</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d_{k}
  </annotation>
 </semantics>
</math>

 are represented by 

<math display="inline" id="Adaptive_filter:21">
 <semantics>
  <msub>
   <mi>u</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>u</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u_{k}
  </annotation>
 </semantics>
</math>

. 

<math display="inline" id="Adaptive_filter:22">
 <semantics>
  <msub>
   <mpadded lspace="5pt" width="+5pt">
    <mi>x</mi>
   </mpadded>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ x_{k}
  </annotation>
 </semantics>
</math>

 consists entirely of a signal correlated with the undesired signal in 

<math display="inline" id="Adaptive_filter:23">
 <semantics>
  <msub>
   <mi>u</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>u</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u_{k}
  </annotation>
 </semantics>
</math>

.</p>

<p>The output of the variable filter in the ideal case is</p>

<p>

<math display="block" id="Adaptive_filter:24">
 <semantics>
  <mrow>
   <msub>
    <mi>y</mi>
    <mi>k</mi>
   </msub>
   <mo>=</mo>
   <msub>
    <mover accent="true">
     <mi>u</mi>
     <mo stretchy="false">^</mo>
    </mover>
    <mi>k</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <ci>normal-^</ci>
      <ci>u</ci>
     </apply>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{k}=\hat{u}_{k}
  </annotation>
 </semantics>
</math>

 .</p>

<p>The error signal or <a href="Loss_function" title="wikilink">cost function</a> is the difference between 

<math display="inline" id="Adaptive_filter:25">
 <semantics>
  <msub>
   <mi>d</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>d</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d_{k}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Adaptive_filter:26">
 <semantics>
  <msub>
   <mi>y</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>y</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{k}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Adaptive_filter:27">
 <semantics>
  <mrow>
   <msub>
    <mi>œµ</mi>
    <mi>k</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>d</mi>
     <mi>k</mi>
    </msub>
    <mo>-</mo>
    <msub>
     <mi>y</mi>
     <mi>k</mi>
    </msub>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>g</mi>
      <mi>k</mi>
     </msub>
     <mo>+</mo>
     <msub>
      <mi>u</mi>
      <mi>k</mi>
     </msub>
    </mrow>
    <mo>-</mo>
    <msub>
     <mover accent="true">
      <mi>u</mi>
      <mo stretchy="false">^</mo>
     </mover>
     <mi>k</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>œµ</ci>
      <ci>k</ci>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>d</ci>
       <ci>k</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <minus></minus>
      <apply>
       <plus></plus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>g</ci>
        <ci>k</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>u</ci>
        <ci>k</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <ci>normal-^</ci>
        <ci>u</ci>
       </apply>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon_{k}=d_{k}-y_{k}=g_{k}+u_{k}-\hat{u}_{k}
  </annotation>
 </semantics>
</math>

. The desired signal <em>g</em><sub>k</sub> passes through without being changed.</p>

<p>The error signal 

<math display="inline" id="Adaptive_filter:28">
 <semantics>
  <msub>
   <mi>œµ</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>œµ</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon_{k}
  </annotation>
 </semantics>
</math>

 is minimized in the mean square sense when 

<math display="inline" id="Adaptive_filter:29">
 <semantics>
  <mrow>
   <mo stretchy="false">[</mo>
   <mrow>
    <msub>
     <mi>u</mi>
     <mi>k</mi>
    </msub>
    <mo>-</mo>
    <msub>
     <mover accent="true">
      <mi>u</mi>
      <mo stretchy="false">^</mo>
     </mover>
     <mi>k</mi>
    </msub>
   </mrow>
   <mo stretchy="false">]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">delimited-[]</csymbol>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>u</ci>
      <ci>k</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <ci>normal-^</ci>
       <ci>u</ci>
      </apply>
      <ci>k</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [u_{k}-\hat{u}_{k}]
  </annotation>
 </semantics>
</math>

 is minimized. In other words, 

<math display="inline" id="Adaptive_filter:30">
 <semantics>
  <msub>
   <mover accent="true">
    <mi>u</mi>
    <mo stretchy="false">^</mo>
   </mover>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <ci>normal-^</ci>
     <ci>u</ci>
    </apply>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{u}_{k}
  </annotation>
 </semantics>
</math>

 is the best mean square estimate of 

<math display="inline" id="Adaptive_filter:31">
 <semantics>
  <msub>
   <mi>u</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>u</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u_{k}
  </annotation>
 </semantics>
</math>

. In the ideal case, 

<math display="inline" id="Adaptive_filter:32">
 <semantics>
  <mrow>
   <msub>
    <mi>u</mi>
    <mi>k</mi>
   </msub>
   <mo>=</mo>
   <msub>
    <mover accent="true">
     <mi>u</mi>
     <mo stretchy="false">^</mo>
    </mover>
    <mi>k</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>u</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <ci>normal-^</ci>
      <ci>u</ci>
     </apply>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u_{k}=\hat{u}_{k}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Adaptive_filter:33">
 <semantics>
  <mrow>
   <msub>
    <mi>œµ</mi>
    <mi>k</mi>
   </msub>
   <mo>=</mo>
   <msub>
    <mi>g</mi>
    <mi>k</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>œµ</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>g</ci>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon_{k}=g_{k}
  </annotation>
 </semantics>
</math>

, and all that is left after the subtraction is 

<math display="inline" id="Adaptive_filter:34">
 <semantics>
  <mi>g</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>g</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g
  </annotation>
 </semantics>
</math>

 which is the unchanged desired signal with all undesired signals removed.</p>
<h3 id="signal-components-in-the-reference-input">Signal components in the reference input</h3>

<p>In some situations, the reference input <em>x</em>_k includes components of the desired signal. This means g' ‚â† 0.</p>

<p>Perfect cancelation of the undesired interference is not possible in the case, but improvement of the signal to interference ratio is possible. The output will be</p>

<p>

<math display="block" id="Adaptive_filter:35">
 <semantics>
  <mrow>
   <msub>
    <mi>œµ</mi>
    <mi>k</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>d</mi>
     <mi>k</mi>
    </msub>
    <mo>-</mo>
    <msub>
     <mi>y</mi>
     <mi>k</mi>
    </msub>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <msub>
       <mi>g</mi>
       <mi>k</mi>
      </msub>
      <mo>-</mo>
      <msub>
       <mover accent="true">
        <mi>g</mi>
        <mo stretchy="false">^</mo>
       </mover>
       <mi>k</mi>
      </msub>
     </mrow>
     <mo>+</mo>
     <msub>
      <mi>u</mi>
      <mi>k</mi>
     </msub>
    </mrow>
    <mo>-</mo>
    <msub>
     <mover accent="true">
      <mi>u</mi>
      <mo stretchy="false">^</mo>
     </mover>
     <mi>k</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>œµ</ci>
      <ci>k</ci>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>d</ci>
       <ci>k</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <minus></minus>
      <apply>
       <plus></plus>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>g</ci>
         <ci>k</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <apply>
          <ci>normal-^</ci>
          <ci>g</ci>
         </apply>
         <ci>k</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>u</ci>
        <ci>k</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <ci>normal-^</ci>
        <ci>u</ci>
       </apply>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon_{k}=d_{k}-y_{k}=g_{k}-\hat{g}_{k}+u_{k}-\hat{u}_{k}
  </annotation>
 </semantics>
</math>

. The desired signal will be modified (usually decreased).</p>

<p>The output signal to interference ratio has a simple formula referred to as <em>power inversion</em>.</p>

<p>

<math display="block" id="Adaptive_filter:36">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>œÅ</mi>
     <mi>ùóàùóéùóç</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mn>1</mn>
    <mrow>
     <msub>
      <mi>œÅ</mi>
      <mi>ùóãùñæùñø</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>z</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>œÅ</ci>
      <ci>ùóàùóéùóç</ci>
     </apply>
     <ci>z</ci>
    </apply>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>œÅ</ci>
       <ci>ùóãùñæùñø</ci>
      </apply>
      <ci>z</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho_{\mathsf{out}}(z)=\frac{1}{\rho_{\mathsf{ref}}(z)}
  </annotation>
 </semantics>
</math>

.</p>
<dl>
<dd><dl>
<dd>where

<p>

<math display="block" id="Adaptive_filter:37">
 <semantics>
  <mrow>
   <msub>
    <mi>œÅ</mi>
    <mi>ùóàùóéùóç</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>z</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>œÅ</ci>
     <ci>ùóàùóéùóç</ci>
    </apply>
    <ci>z</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho_{\mathsf{out}}(z)
  </annotation>
 </semantics>
</math>

 = output signal to interference ratio.</p>

<p>

<math display="block" id="Adaptive_filter:38">
 <semantics>
  <mrow>
   <msub>
    <mi>œÅ</mi>
    <mi>ùóãùñæùñø</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>z</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>œÅ</ci>
     <ci>ùóãùñæùñø</ci>
    </apply>
    <ci>z</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho_{\mathsf{ref}}(z)
  </annotation>
 </semantics>
</math>

 = reference signal to interference ratio.</p>

<p>

<math display="block" id="Adaptive_filter:39">
 <semantics>
  <mi>z</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>z</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z
  </annotation>
 </semantics>
</math>

 = frequency in the z-domain.</p>
</dd>
</dl>
</dd>
</dl>

<p>This formula means that the output signal to interference ratio at a particular frequency is the reciprocal of the reference signal to interference ratio.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>

<p>Example: A fast food restaurant has a drive-up window. Before getting to the window, customers place their order by speaking into a microphone. The microphone also picks up noise from the engine and the environment. This microphone provides the primary signal. The signal power from the customer‚Äôs voice and the noise power from the engine are equal. It is difficult for the employees in the restaurant to understand the customer. To reduce the amount of interference in the primary microphone, a second microphone is located where it is intended to pick up sounds from the engine. It also picks up the customer‚Äôs voice. This microphone is the source of the reference signal. In this case, the engine noise is 50 times more powerful than the customer‚Äôs voice. Once the canceler has converged, the primary signal to interference ratio will be improved from 1:1 to 50:1.</p>
<h3 id="adaptive-linear-combiner">Adaptive Linear Combiner</h3>
<dl>
<dd>
</dd>
</dl>

<p>The adaptive linear combiner (ALC) resembles the adaptive tapped delay line FIR filter except that there is no assumed relationship between the X values. If the X values were from the outputs of a tapped delay line, then the combination of tapped delay line and ALC would comprise an adaptive filter. However, the X values could be the values of an array of pixels. Or they could be the outputs of multiple tapped delay lines. The ALC finds use as an adaptive beam former for arrays of hydrophones or antennas.</p>

<p>

<math display="block" id="Adaptive_filter:40">
 <semantics>
  <mrow>
   <msub>
    <mi>y</mi>
    <mi>k</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">‚àë</mo>
     <mrow>
      <mi>l</mi>
      <mo>=</mo>
      <mn>0</mn>
     </mrow>
     <mi>L</mi>
    </munderover>
    <mrow>
     <mpadded width="+5pt">
      <msub>
       <mi>w</mi>
       <mrow>
        <mi>l</mi>
        <mi>k</mi>
       </mrow>
      </msub>
     </mpadded>
     <msub>
      <mi>x</mi>
      <mrow>
       <mi>l</mi>
       <mi>k</mi>
      </mrow>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>l</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <ci>L</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>w</ci>
       <apply>
        <times></times>
        <ci>l</ci>
        <ci>k</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <apply>
        <times></times>
        <ci>l</ci>
        <ci>k</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{k}=\sum_{l=0}^{L}w_{lk}\ x_{lk}
  </annotation>
 </semantics>
</math>

</p>
<dl>
<dd><dl>
<dd>where 

<math display="inline" id="Adaptive_filter:41">
 <semantics>
  <msub>
   <mi>w</mi>
   <mrow>
    <mi>l</mi>
    <mi>k</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>w</ci>
    <apply>
     <times></times>
     <ci>l</ci>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w_{lk}
  </annotation>
 </semantics>
</math>

 refers to the 

<math display="inline" id="Adaptive_filter:42">
 <semantics>
  <mi>l</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>l</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   l
  </annotation>
 </semantics>
</math>

'th weight at k'th time.
</dd>
</dl>
</dd>
</dl>
<h3 id="lms-algorithm">LMS algorithm</h3>

<p>If the variable filter has a tapped delay line FIR structure, then the LMS update algorithm is especially simple. Typically, after each sample, the coefficients of the FIR filter are adjusted as follows:<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a>(Widrow)</p>
<dl>
<dd>for 

<math display="inline" id="Adaptive_filter:43">
 <semantics>
  <mrow>
   <mi>l</mi>
   <mo>=</mo>
   <mrow>
    <mn>0</mn>
    <mi mathvariant="normal">‚Ä¶</mi>
    <mi>L</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>l</ci>
    <apply>
     <times></times>
     <cn type="integer">0</cn>
     <ci>normal-‚Ä¶</ci>
     <ci>L</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   l=0\dots L
  </annotation>
 </semantics>
</math>


</dd>
</dl>

<p>

<math display="block" id="Adaptive_filter:44">
 <semantics>
  <mrow>
   <msub>
    <mi>w</mi>
    <mrow>
     <mi>l</mi>
     <mo>,</mo>
     <mrow>
      <mi>k</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>w</mi>
     <mrow>
      <mi>l</mi>
      <mi>k</mi>
     </mrow>
    </msub>
    <mo>+</mo>
    <mrow>
     <mn>2</mn>
     <mpadded width="+5pt">
      <mi>Œº</mi>
     </mpadded>
     <mpadded width="+5pt">
      <msub>
       <mi>œµ</mi>
       <mi>k</mi>
      </msub>
     </mpadded>
     <msub>
      <mi>x</mi>
      <mrow>
       <mi>k</mi>
       <mo>-</mo>
       <mi>l</mi>
      </mrow>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>w</ci>
     <list>
      <ci>l</ci>
      <apply>
       <plus></plus>
       <ci>k</ci>
       <cn type="integer">1</cn>
      </apply>
     </list>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>w</ci>
      <apply>
       <times></times>
       <ci>l</ci>
       <ci>k</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <ci>Œº</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>œµ</ci>
       <ci>k</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <apply>
        <minus></minus>
        <ci>k</ci>
        <ci>l</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w_{l,k+1}=w_{lk}+2\mu\ \epsilon_{k}\ x_{k-l}
  </annotation>
 </semantics>
</math>

</p>
<dl>
<dd><dl>
<dd>Œº is called the <em>convergence factor</em>.
</dd>
</dl>
</dd>
</dl>

<p>The LMS algorithm does not require that the X values have any particular relationship; therefor it can be used to adapt a linear combiner as well as an FIR filter. In this case the update formula is written as:</p>

<p>

<math display="block" id="Adaptive_filter:45">
 <semantics>
  <mrow>
   <msub>
    <mi>w</mi>
    <mrow>
     <mi>l</mi>
     <mo>,</mo>
     <mrow>
      <mi>k</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>w</mi>
     <mrow>
      <mi>l</mi>
      <mi>k</mi>
     </mrow>
    </msub>
    <mo>+</mo>
    <mrow>
     <mn>2</mn>
     <mpadded width="+5pt">
      <mi>Œº</mi>
     </mpadded>
     <mpadded width="+5pt">
      <msub>
       <mi>œµ</mi>
       <mi>k</mi>
      </msub>
     </mpadded>
     <msub>
      <mi>x</mi>
      <mrow>
       <mi>l</mi>
       <mi>k</mi>
      </mrow>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>w</ci>
     <list>
      <ci>l</ci>
      <apply>
       <plus></plus>
       <ci>k</ci>
       <cn type="integer">1</cn>
      </apply>
     </list>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>w</ci>
      <apply>
       <times></times>
       <ci>l</ci>
       <ci>k</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <ci>Œº</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>œµ</ci>
       <ci>k</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <apply>
        <times></times>
        <ci>l</ci>
        <ci>k</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w_{l,k+1}=w_{lk}+2\mu\ \epsilon_{k}\ x_{lk}
  </annotation>
 </semantics>
</math>

</p>

<p>The effect of the LMS algorithm is at each time, k, to make a small change in each weight. The direction of the change is such that it would decrease the error if it had been applied at time k. The magnitude of the change in each weight depends on Œº, the associated X value and the error at time k. The weights making the largest contribution to the output, 

<math display="inline" id="Adaptive_filter:46">
 <semantics>
  <msub>
   <mi>y</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>y</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{k}
  </annotation>
 </semantics>
</math>

, are changed the most. If the error is zero, then there should be no change in the weights. If the associated value of X is zero, then changing the weight makes no difference, so it is not changed.</p>
<h4 id="convergence">Convergence</h4>

<p>Œº controls how fast and how well the algorithm converges to the optimum filter coefficients. If Œº is too large, the algorithm will not converge. If Œº is too small the algorithm converges slowly and may not be able to track changing conditions. If Œº is large but not too large to prevent convergence, the algorithm reaches steady state rapidly but continuously overshoots the optimum weight vector. Sometimes, Œº is made large at first for rapid convergence and then decreased to minimize overshoot.</p>

<p>Widrow and Stearns state in 1985 that they have no knowledge of a proof that the LMS algorithm will converge in all cases.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>

<p>However under certain assumptions about stationarity and independence it can be shown that the algorithm will converge if</p>

<p>

<math display="block" id="Adaptive_filter:47">
 <semantics>
  <mrow>
   <mn>0</mn>
   <mo><</mo>
   <mi>Œº</mi>
   <mo><</mo>
   <mfrac>
    <mn>1</mn>
    <msup>
     <mi>œÉ</mi>
     <mn>2</mn>
    </msup>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <lt></lt>
     <cn type="integer">0</cn>
     <ci>Œº</ci>
    </apply>
    <apply>
     <lt></lt>
     <share href="#.cmml">
     </share>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>œÉ</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0<\mu<\frac{1}{\sigma^{2}}
  </annotation>
 </semantics>
</math>

</p>
<dl>
<dd><dl>
<dd>where

<p>

<math display="block" id="Adaptive_filter:48">
 <semantics>
  <mrow>
   <msup>
    <mi>œÉ</mi>
    <mn>2</mn>
   </msup>
   <mo>=</mo>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">‚àë</mo>
     <mrow>
      <mi>l</mi>
      <mo>=</mo>
      <mn>0</mn>
     </mrow>
     <mi>L</mi>
    </munderover>
    <msubsup>
     <mi>œÉ</mi>
     <mi>l</mi>
     <mn>2</mn>
    </msubsup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>œÉ</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>l</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <ci>L</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>œÉ</ci>
       <ci>l</ci>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma^{2}=\sum_{l=0}^{L}\sigma_{l}^{2}
  </annotation>
 </semantics>
</math>

 = sum of all input power</p>
</dd>
</dl>
</dd>
</dl>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Adaptive_filter:49">
 <semantics>
  <msub>
   <mi>œÉ</mi>
   <mi>l</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>œÉ</ci>
    <ci>l</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma_{l}
  </annotation>
 </semantics>
</math>

 is the RMS value of the 

<math display="inline" id="Adaptive_filter:50">
 <semantics>
  <mi>l</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>l</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   l
  </annotation>
 </semantics>
</math>

'th input
</dd>
</dl>
</dd>
</dl>

<p>In the case of the tapped delay line filter, each input has the same RMS value because they are simply the same values delayed. In this case the total power is</p>

<p>

<math display="block" id="Adaptive_filter:51">
 <semantics>
  <mrow>
   <msup>
    <mi>œÉ</mi>
    <mn>2</mn>
   </msup>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>L</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <msubsup>
     <mi>œÉ</mi>
     <mn>0</mn>
     <mn>2</mn>
    </msubsup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>œÉ</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <times></times>
     <apply>
      <plus></plus>
      <ci>L</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>œÉ</ci>
       <cn type="integer">0</cn>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma^{2}=(L+1)\sigma_{0}^{2}
  </annotation>
 </semantics>
</math>

</p>
<dl>
<dd><dl>
<dd>where

<p>

<math display="block" id="Adaptive_filter:52">
 <semantics>
  <msub>
   <mi>œÉ</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>œÉ</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma_{0}
  </annotation>
 </semantics>
</math>

 is the RMS value of 

<math display="inline" id="Adaptive_filter:53">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{k}
  </annotation>
 </semantics>
</math>

, the input stream.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>
</dd>
</dl>
</dd>
</dl>

<p>This leads to a normalized LMS algorithm:</p>

<p>

<math display="block" id="Adaptive_filter:54">
 <semantics>
  <mrow>
   <msub>
    <mi>w</mi>
    <mrow>
     <mi>l</mi>
     <mo>,</mo>
     <mrow>
      <mi>k</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>w</mi>
     <mrow>
      <mi>l</mi>
      <mi>k</mi>
     </mrow>
    </msub>
    <mo>+</mo>
    <mrow>
     <mrow>
      <mo>(</mo>
      <mfrac>
       <mrow>
        <mn>2</mn>
        <msub>
         <mi>Œº</mi>
         <mi>œÉ</mi>
        </msub>
       </mrow>
       <msup>
        <mi>œÉ</mi>
        <mn>2</mn>
       </msup>
      </mfrac>
      <mo>)</mo>
     </mrow>
     <mpadded width="+5pt">
      <msub>
       <mi>œµ</mi>
       <mi>k</mi>
      </msub>
     </mpadded>
     <msub>
      <mi>x</mi>
      <mrow>
       <mi>k</mi>
       <mo>-</mo>
       <mi>l</mi>
      </mrow>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>w</ci>
     <list>
      <ci>l</ci>
      <apply>
       <plus></plus>
       <ci>k</ci>
       <cn type="integer">1</cn>
      </apply>
     </list>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>w</ci>
      <apply>
       <times></times>
       <ci>l</ci>
       <ci>k</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>Œº</ci>
         <ci>œÉ</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>œÉ</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>œµ</ci>
       <ci>k</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <apply>
        <minus></minus>
        <ci>k</ci>
        <ci>l</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w_{l,k+1}=w_{lk}+\left(\frac{2\mu_{\sigma}}{\sigma^{2}}\right)\epsilon_{k}\ x_%
{k-l}
  </annotation>
 </semantics>
</math>

 in which case the convergence criteria becomes

<math display="block" id="Adaptive_filter:55">
 <semantics>
  <mrow>
   <mn>0</mn>
   <mo><</mo>
   <msub>
    <mi>Œº</mi>
    <mi>œÉ</mi>
   </msub>
   <mo><</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <lt></lt>
     <cn type="integer">0</cn>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Œº</ci>
      <ci>œÉ</ci>
     </apply>
    </apply>
    <apply>
     <lt></lt>
     <share href="#.cmml">
     </share>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0<\mu_{\sigma}<1
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="applications-of-adaptive-filters">Applications of adaptive filters</h2>
<ul>
<li><a href="Noise_cancellation" title="wikilink">Noise cancellation</a></li>
<li><a href="Linear_prediction" title="wikilink">Signal prediction</a></li>
<li><a href="Adaptive_feedback_cancellation" title="wikilink">Adaptive feedback cancellation</a></li>
<li><a href="Echo_cancellation" title="wikilink">Echo cancellation</a></li>
</ul>
<h2 id="filter-implementations">Filter implementations</h2>
<ul>
<li><a href="Least_mean_squares_filter" title="wikilink">Least mean squares filter</a></li>
<li><a href="Recursive_least_squares_filter" title="wikilink">Recursive least squares filter</a></li>
<li><a href="Multidelay_block_frequency_domain_adaptive_filter" title="wikilink">Multidelay block frequency domain adaptive filter</a></li>
</ul>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Kalman_filter" title="wikilink">Kalman filter</a></li>
<li><a href="Wiener_filter" title="wikilink">Wiener filter</a></li>
<li><a href="Linear_prediction" title="wikilink">Linear prediction</a></li>
<li><a href="Filter_(signal_processing)" title="wikilink">Filter (signal processing)</a></li>
<li><a href="Kernel_adaptive_filter" title="wikilink">Kernel adaptive filter</a></li>
<li><a href="Wiener-Hopf_equation" title="wikilink">Wiener-Hopf equation</a></li>
<li><a href="MMSE_estimator" title="wikilink">MMSE estimator</a></li>
</ul>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<ul>
<li></li>
<li></li>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Digital_signal_processing" title="wikilink">Category:Digital signal processing</a> <a href="Category:Nonlinear_filters" title="wikilink">Category:Nonlinear filters</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">‚Ü©</a></li>
<li id="fn2">Widrow p 304<a href="#fnref2">‚Ü©</a></li>
<li id="fn3">Widrow p 212<a href="#fnref3">‚Ü©</a></li>
<li id="fn4">Widrow p 313<a href="#fnref4">‚Ü©</a></li>
<li id="fn5">Widrow p 100<a href="#fnref5">‚Ü©</a></li>
<li id="fn6">Widrow p 103<a href="#fnref6">‚Ü©</a></li>
<li id="fn7"></li>
</ol>
</section>
</body>
</html>
