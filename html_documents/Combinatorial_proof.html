<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="537">Combinatorial proof</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Combinatorial proof</h1>
<hr/>

<p>In <a class="uri" href="mathematics" title="wikilink">mathematics</a>, the term <strong><em>combinatorial proof</em></strong> is often used to mean either of two types of <a href="mathematical_proof" title="wikilink">mathematical proof</a>:</p>
<ul>
<li>A proof by <a href="double_counting_(proof_technique)" title="wikilink">double counting</a>. A <a href="combinatorics" title="wikilink">combinatorial</a> <a href="identity_(mathematics)" title="wikilink">identity</a> is proven by counting the number of elements of some carefully chosen set in two different ways to obtain the different expressions in the identity. Since those expressions count the same objects, they must be equal to each other and thus the identity is established.</li>
</ul>
<ul>
<li>A <a href="bijective_proof" title="wikilink">bijective proof</a>. Two sets are shown to have the same number of members by exhibiting a <a class="uri" href="bijection" title="wikilink">bijection</a>, i.e. a one-to-one correspondence, between them.</li>
</ul>

<p>The term "combinatorial proof" may also be used more broadly to refer to any kind of <a href="elementary_proof" title="wikilink">elementary proof</a> in combinatorics. However, as  writes in his review of  (a book about combinatorial proofs), these two simple techniques are enough to prove many theorems in combinatorics and number theory.</p>
<h2 id="example">Example</h2>

<p>An archetypal double counting proof is for the well known formula for the number 

<math display="inline" id="Combinatorial_proof:0">
 <semantics>
  <mrow>
   <mo>(</mo>
   <mstyle scriptlevel="+1">
    <mtable columnspacing="0.4em" rowspacing="0.2ex">
     <mtr>
      <mtd>
       <mi>n</mi>
      </mtd>
     </mtr>
     <mtr>
      <mtd>
       <mi>k</mi>
      </mtd>
     </mtr>
    </mtable>
   </mstyle>
   <mo>)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">binomial</csymbol>
    <ci>n</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\textstyle\left({{n}\atop{k}}\right)}
  </annotation>
 </semantics>
</math>

 of <em>k</em>-<a href="combination" title="wikilink">combinations</a> (i.e., subsets of size <em>k</em>) of an <em>n</em>-element set:</p>

<p>

<math display="block" id="Combinatorial_proof:1">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>(</mo>
     <mtable columnspacing="0.4em" rowspacing="0.2ex">
      <mtr>
       <mtd>
        <mi>n</mi>
       </mtd>
      </mtr>
      <mtr>
       <mtd>
        <mi>k</mi>
       </mtd>
      </mtr>
     </mtable>
     <mo>)</mo>
    </mrow>
    <mo>=</mo>
    <mfrac>
     <mrow>
      <mi>n</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>n</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi mathvariant="normal">⋯</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mrow>
         <mi>n</mi>
         <mo>-</mo>
         <mi>k</mi>
        </mrow>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mrow>
      <mi>k</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>k</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi mathvariant="normal">⋯</mi>
      <mn>1</mn>
     </mrow>
    </mfrac>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="latexml">binomial</csymbol>
     <ci>n</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <ci>n</ci>
      <apply>
       <minus></minus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-⋯</ci>
      <apply>
       <plus></plus>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <ci>k</ci>
       </apply>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>k</ci>
      <apply>
       <minus></minus>
       <ci>k</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-⋯</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\left({{n}\atop{k}}\right)}=\frac{n(n-1)\cdots(n-k+1)}{k(k-1)\cdots 1}.
  </annotation>
 </semantics>
</math>

 Here a direct bijective proof is not possible: because the right-hand side of the identity is a fraction, there is no set <em>obviously</em> counted by it (it even takes some thought to see that the denominator always evenly divides the numerator). However its numerator counts the <a href="Cartesian_product" title="wikilink">Cartesian product</a> of <em>k</em> finite sets of sizes <em>n</em>, , ..., , while its denominator counts the <a class="uri" href="permutations" title="wikilink">permutations</a> of a <em>k</em>-element set (the set most obviously counted by the denominator would be another Cartesian product <em>k</em> finite sets; if desired one could map permutations to that set by an explicit bijection). Now take <em>S</em> to be the set of sequences of <em>k</em> elements selected from our <em>n</em>-element set without repetition. On one hand, there is an easy bijection of <em>S</em> with the Cartesian product corresponding to the numerator 

<math display="inline" id="Combinatorial_proof:2">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>n</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi mathvariant="normal">⋯</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mrow>
      <mi>n</mi>
      <mo>-</mo>
      <mi>k</mi>
     </mrow>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>n</ci>
    <apply>
     <minus></minus>
     <ci>n</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-⋯</ci>
    <apply>
     <plus></plus>
     <apply>
      <minus></minus>
      <ci>n</ci>
      <ci>k</ci>
     </apply>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n(n-1)\cdots(n-k+1)
  </annotation>
 </semantics>
</math>

, and on the other hand there is a bijection from the set <em>C</em> of pairs of a <em>k</em>-combination and a permutation <em>σ</em> of <em>k</em> to <em>S</em>, by taking the elements of <em>C</em> in increasing order, and then permuting this sequence by <em>σ</em> to obtain an element of <em>S</em>. The two ways of counting give the equation</p>

<p>

<math display="block" id="Combinatorial_proof:3">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>n</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi mathvariant="normal">⋯</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <mi>n</mi>
        <mo>-</mo>
        <mi>k</mi>
       </mrow>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mo>(</mo>
      <mtable columnspacing="0.4em" rowspacing="0.2ex">
       <mtr>
        <mtd>
         <mi>n</mi>
        </mtd>
       </mtr>
       <mtr>
        <mtd>
         <mi>k</mi>
        </mtd>
       </mtr>
      </mtable>
      <mo>)</mo>
     </mrow>
     <mrow>
      <mi>k</mi>
      <mo lspace="0pt" rspace="3.5pt">!</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>n</ci>
     <apply>
      <minus></minus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-⋯</ci>
     <apply>
      <plus></plus>
      <apply>
       <minus></minus>
       <ci>n</ci>
       <ci>k</ci>
      </apply>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="latexml">binomial</csymbol>
      <ci>n</ci>
      <ci>k</ci>
     </apply>
     <apply>
      <factorial></factorial>
      <ci>k</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n(n-1)\cdots(n-k+1)={\left({{n}\atop{k}}\right)}k!,
  </annotation>
 </semantics>
</math>

 and after division by <em>k</em>! this leads to the stated formula for 

<math display="inline" id="Combinatorial_proof:4">
 <semantics>
  <mrow>
   <mo>(</mo>
   <mstyle scriptlevel="+1">
    <mtable columnspacing="0.4em" rowspacing="0.2ex">
     <mtr>
      <mtd>
       <mi>n</mi>
      </mtd>
     </mtr>
     <mtr>
      <mtd>
       <mi>k</mi>
      </mtd>
     </mtr>
    </mtable>
   </mstyle>
   <mo>)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">binomial</csymbol>
    <ci>n</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\textstyle\left({{n}\atop{k}}\right)}
  </annotation>
 </semantics>
</math>

. In general, if the counting formula involves a division, a similar double counting argument (if it exists) gives the most straightforward combinatorial proof of the identity, but double counting arguments are not limited to situations where the formula is of this form.</p>
<h2 id="the-benefit-of-a-combinatorial-proof">The benefit of a combinatorial proof</h2>

<p>gives an example of a <a href="combinatorial_enumeration" title="wikilink">combinatorial enumeration</a> problem (counting the number of sequences of <em>k</em> subsets <em>S</em><sub>1</sub>, <em>S</em><sub>2</sub>, ... <em>S</em><sub><em>k</em></sub>, that can be formed from a set of <em>n</em> items such that the subsets have an empty common intersection) with two different proofs for its solution. The first proof, which is not combinatorial, uses <a href="mathematical_induction" title="wikilink">mathematical induction</a> and <a href="generating_function" title="wikilink">generating functions</a> to find that the number of sequences of this type is (2<sup><em>k</em></sup> −1)<sup><em>n</em></sup>. The second proof is based on the observation that there are 2<sup><em>k</em></sup> −1 <a href="proper_subset" title="wikilink">proper subsets</a> of the set {1, 2, ..., <em>k</em>}, and (2<sup><em>k</em></sup> −1)<sup><em>n</em></sup> functions from the set {1, 2, ..., <em>n</em>} to the family of proper subsets of {1, 2, ..., <em>k</em>}. The sequences to be counted can be placed in one-to-one correspondence with these functions, where the function formed from a given sequence of subsets maps each element <em>i</em> to the set {<em>j</em> | <em>i</em> ∈ <em>S</em><sub><em>j</em></sub>}.</p>

<p>Stanley writes, “Not only is the above combinatorial proof much shorter than our previous proof, but also it makes the reason for the simple answer completely transparent. It is often the case, as occurred here, that the first proof to come to mind turns out to be laborious and inelegant, but that the final answer suggests a simple combinatorial proof.” Due both to their frequent greater elegance than non-combinatorial proofs and the greater insight they provide into the structures they describe, Stanley formulates a general principle that combinatorial proofs are to be preferred over other proofs, and lists as exercises many problems of finding combinatorial proofs for mathematical facts known to be true through other means.</p>
<h2 id="the-difference-between-bijective-and-double-counting-proofs">The difference between bijective and double counting proofs</h2>

<p>Stanley does not clearly distinguish between bijective and double counting proofs, and gives examples of both kinds, but the difference between the two types of combinatorial proof can be seen in an example provided by , of proofs for <a href="Cayley's_formula" title="wikilink">Cayley's formula</a> stating that there are <em>n</em><sup><em>n</em> − 2</sup> different <a href="tree_(graph_theory)" title="wikilink">trees</a> that can be formed from a given set of <em>n</em> nodes. Aigner and Ziegler list four proofs of this theorem, the first of which is bijective and the last of which is a double counting argument. They also mention but do not describe the details of a fifth bijective proof.</p>

<p>The most natural way to find a bijective proof of this formula would be to find a bijection between <em>n</em>-node trees and some collection of objects that has <em>n</em><sup><em>n</em> − 2</sup> members, such as the sequences of <em>n</em> − 2 values each in the range from 1 to <em>n</em>. Such a bijection can be obtained using the <a href="Prüfer_sequence" title="wikilink">Prüfer sequence</a> of each tree. Any tree can be uniquely encoded into a Prüfer sequence, and any Prüfer sequence can be uniquely decoded into a tree; these two results together provide a bijective proof of Cayley's formula.</p>

<p>An alternative bijective proof, given by Aigner and Ziegler and credited by them to <a href="André_Joyal" title="wikilink">André Joyal</a>, involves a bijection between, on the one hand, <em>n</em>-node trees with two designated nodes (that may be the same as each other), and on the other hand, <em>n</em>-node <a href="directed_graph" title="wikilink">directed</a> <a href="pseudoforest" title="wikilink">pseudoforests</a>. If there are <em>T<sub>n</sub></em> <em>n</em>-node trees, then there are <em>n</em><sup>2</sup><em>T<sub>n</sub></em> trees with two designated nodes. And a pseudoforest may be determined by specifying, for each of its nodes, the endpoint of the edge extending outwards from that node; there are <em>n</em> possible choices for the endpoint of a single edge (allowing self-loops) and therefore <em>n<sup>n</sup></em> possible pseudoforests. By finding a bijection between trees with two labeled nodes and pseudoforests, Joyal's proof shows that <em>T<sub>n</sub></em> = <em>n</em><sup><em>n</em> − 2</sup>.</p>

<p>Finally, the fourth proof of Cayley's formula presented by Aigner and Ziegler is a <a href="Double_counting_(proof_technique)#Counting_trees" title="wikilink">double counting proof due to Jim Pitman</a>. In this proof, Pitman considers the sequences of directed edges that may be added to an <em>n</em>-node <a href="empty_graph" title="wikilink">empty graph</a> to form from it a single rooted tree, and counts the number of such sequences in two different ways. By showing how to derive a sequence of this type by choosing a tree, a root for the tree, and an ordering for the edges in the tree, he shows that there are <em>T<sub>n</sub>n</em>! possible sequences of this type. And by counting the number of ways in which a partial sequence can be extended by a single edge, he shows that there are <em>n</em><sup><em>n</em> − 2</sup><em>n</em>! possible sequences. Equating these two different formulas for the size of the same set of edge sequences and cancelling the common factor of <em>n</em>! leads to Cayley's formula.</p>
<h2 id="related-concepts">Related concepts</h2>
<ul>
<li>The principles of double counting and bijection used in combinatorial proofs can be seen as examples of a larger family of <a href="combinatorial_principles" title="wikilink">combinatorial principles</a>, which include also other ideas such as the <a href="pigeonhole_principle" title="wikilink">pigeonhole principle</a>.</li>
<li>Proving an identity combinatorially can be viewed as adding more structure to the identity by replacing numbers by sets; similarly, <a class="uri" href="categorification" title="wikilink">categorification</a> is the replacement of sets by categories.</li>
</ul>
<h2 id="references">References</h2>
<ul>
<li>

<p>.</p></li>
</ul>
<ul>
<li>

<p>.</p></li>
</ul>
<ul>
<li>

<p>.</p></li>
</ul>
<ul>
<li>

<p>.</p></li>
</ul>

<p>"</p>

<p><a href="Category:Enumerative_combinatorics" title="wikilink">Category:Enumerative combinatorics</a> <a href="Category:Mathematical_proofs" title="wikilink">Category:Mathematical proofs</a></p>
</body>
</html>
