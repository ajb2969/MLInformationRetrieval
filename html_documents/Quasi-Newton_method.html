<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1770">Quasi-Newton method</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Quasi-Newton method</h1>
<hr/>

<p><strong>Quasi-Newton methods</strong> are methods used to either find zeroes or local maxima and minima of functions, as an alternative to Newton's method. They can be used if the <a href="Jacobian_matrix" title="wikilink">Jacobian</a> or <a href="Hessian_matrix" title="wikilink">Hessian</a> is unavailable or is too expensive to compute at every iteration. The "full" Newton's method requires the Jacobian in order to search for zeros, or the Hessian for finding extrema.</p>
<h2 id="description-of-the-method">Description of the method</h2>
<h3 id="search-for-zeroes">Search for zeroes</h3>

<p><a href="Newton's_method" title="wikilink">Newton's method</a> to find zeroes of a function 

<math display="inline" id="Quasi-Newton_method:0">
 <semantics>
  <mi>g</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>g</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g
  </annotation>
 </semantics>
</math>

 of multiple variables is given by

<math display="block" id="Quasi-Newton_method:1">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mrow>
     <mi>n</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>x</mi>
     <mi>n</mi>
    </msub>
    <mo>-</mo>
    <mrow>
     <msup>
      <mrow>
       <mo stretchy="false">[</mo>
       <mrow>
        <msub>
         <mi>J</mi>
         <mi>g</mi>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>x</mi>
          <mi>n</mi>
         </msub>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">]</mo>
      </mrow>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msup>
     <mi>g</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mi>n</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <apply>
      <plus></plus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>J</ci>
          <ci>g</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <ci>n</ci>
         </apply>
        </apply>
       </apply>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>g</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{n+1}=x_{n}-[J_{g}(x_{n})]^{-1}g(x_{n})\,\!
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Quasi-Newton_method:2">
 <semantics>
  <msup>
   <mrow>
    <mo stretchy="false">[</mo>
    <mrow>
     <msub>
      <mi>J</mi>
      <mi>g</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mi>n</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
   <mrow>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>J</ci>
       <ci>g</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [J_{g}(x_{n})]^{-1}
  </annotation>
 </semantics>
</math>

 is the <a href="Inverse_element#Matrices" title="wikilink">left inverse</a> of the <a href="Jacobian_matrix" title="wikilink">Jacobian matrix</a> 

<math display="inline" id="Quasi-Newton_method:3">
 <semantics>
  <mrow>
   <msub>
    <mi>J</mi>
    <mi>g</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mi>n</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>J</ci>
     <ci>g</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   J_{g}(x_{n})
  </annotation>
 </semantics>
</math>

 of 

<math display="inline" id="Quasi-Newton_method:4">
 <semantics>
  <mi>g</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>g</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g
  </annotation>
 </semantics>
</math>

 evaluated for 

<math display="inline" id="Quasi-Newton_method:5">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{n}
  </annotation>
 </semantics>
</math>

.</p>

<p>Strictly, any method that replaces the exact Jacobian 

<math display="inline" id="Quasi-Newton_method:6">
 <semantics>
  <mrow>
   <msub>
    <mi>J</mi>
    <mi>g</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mi>n</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>J</ci>
     <ci>g</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   J_{g}(x_{n})
  </annotation>
 </semantics>
</math>

 with an approximation is a quasi-Newton method. The chord method (where 

<math display="inline" id="Quasi-Newton_method:7">
 <semantics>
  <mrow>
   <msub>
    <mi>J</mi>
    <mi>g</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mi>n</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>J</ci>
     <ci>g</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   J_{g}(x_{n})
  </annotation>
 </semantics>
</math>

 is replaced by 

<math display="inline" id="Quasi-Newton_method:8">
 <semantics>
  <mrow>
   <msub>
    <mi>J</mi>
    <mi>g</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mi>o</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>J</ci>
     <ci>g</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>o</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   J_{g}(x_{o})
  </annotation>
 </semantics>
</math>

 for all iterations) for instance is a simple example. The methods given below for <a href="#Search_for_extrema" title="wikilink">optimisation</a> are other examples. Using methods developed to find extrema in order to find zeroes is not always a good idea as the majority of the methods used to find extrema require that the matrix that is used is symmetrical. While this holds in the context of the search for extrema, it rarely holds when searching for zeroes. <a href="Broyden's_method" title="wikilink">Broyden's "good" method</a> and <a href="Broyden's_bad_method" title="wikilink">Broyden's "bad" method</a> are two methods commonly used to find extrema that can also be applied to find zeroes. Other methods that can be used are the <a href="Column_Updating_Method" title="wikilink">Column Updating Method</a>, the <a href="Inverse_Column_Updating_Method" title="wikilink">Inverse Column Updating Method</a>, the <a href="Quasi-Newton_Least_Squares_Method" title="wikilink">Quasi-Newton Least Squares Method</a> and the <a href="Quasi-Newton_Inverse_Least_Squares_Method" title="wikilink">Quasi-Newton Inverse Least Squares Method</a>.</p>

<p>More recently quasi-Newton methods have been applied to find the solution of multiple coupled systems of equations (e.g. fluid-structure interaction problems or interaction problems in physics). They allow the solution to be found by solving each constituent system separately (which is simpler than the global system) in a cyclic, iterative fashion until the solution of the global system is found.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a><a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>
<h3 id="search-for-extrema">Search for extrema</h3>

<p>Noting that the search for a minimum or maximum of a single-valued function is nothing else than the search for the zeroes of the gradient of that function, quasi-Newton methods can be readily applied to find extrema of a function. In other words, if 

<math display="inline" id="Quasi-Newton_method:9">
 <semantics>
  <mi>g</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>g</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g
  </annotation>
 </semantics>
</math>

 is the gradient of 

<math display="inline" id="Quasi-Newton_method:10">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 then searching for the zeroes of the multi-valued function 

<math display="inline" id="Quasi-Newton_method:11">
 <semantics>
  <mi>g</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>g</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g
  </annotation>
 </semantics>
</math>

 corresponds to the search for the extrema of the single-valued function 

<math display="inline" id="Quasi-Newton_method:12">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

; the Jacobian of 

<math display="inline" id="Quasi-Newton_method:13">
 <semantics>
  <mi>g</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>g</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g
  </annotation>
 </semantics>
</math>

 now becomes the Hessian of 

<math display="inline" id="Quasi-Newton_method:14">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

. The main difference is that the Hessian matrix now is a symmetrical matrix, unlike the Jacobian when <a href="#Search_for_zeroes" title="wikilink">searching for zeroes</a>. Most quasi-Newton methods used in optimisation exploit this property.</p>

<p>In <a href="Optimization_(mathematics)" title="wikilink">optimization</a>, <strong>quasi-Newton methods</strong> (a special case of <strong>variable metric methods</strong>) are algorithms for finding local <a href="maxima_and_minima" title="wikilink">maxima and minima</a> of <a href="function_(mathematics)" title="wikilink">functions</a>. Quasi-Newton methods are based on <a href="Newton's_method_in_optimization" title="wikilink">Newton's method</a> to find the <a href="stationary_point" title="wikilink">stationary point</a> of a function, where the <a class="uri" href="gradient" title="wikilink">gradient</a> is 0. Newton's method assumes that the function can be locally approximated as a <a href="quadratic_function" title="wikilink">quadratic</a> in the region around the optimum, and uses the first and second derivatives to find the stationary point. In higher dimensions, Newton's method uses the gradient and the <a href="Hessian_matrix" title="wikilink">Hessian matrix</a> of second <a href="derivative" title="wikilink">derivatives</a> of the function to be minimized.</p>

<p>In quasi-Newton methods the Hessian matrix does not need to be computed. The Hessian is updated by analyzing successive gradient vectors instead. Quasi-Newton methods are a generalization of the <a href="secant_method" title="wikilink">secant method</a> to find the root of the first derivative for multidimensional problems. In multiple dimensions the secant equation is under-determined, and quasi-Newton methods differ in how they constrain the solution, typically by adding a simple low-rank update to the current estimate of the Hessian.</p>

<p>The first quasi-Newton algorithm was proposed by <a href="William_C._Davidon" title="wikilink">William C. Davidon</a>, a physicist working at <a href="Argonne_National_Laboratory" title="wikilink">Argonne National Laboratory</a>. He developed the first quasi-Newton algorithm in 1959: the <a href="DFP_updating_formula" title="wikilink">DFP updating formula</a>, which was later popularized by Fletcher and Powell in 1963, but is rarely used today. The most common quasi-Newton algorithms are currently the <a href="SR1_formula" title="wikilink">SR1 formula</a> (for symmetric rank one), the <a class="uri" href="BHHH" title="wikilink">BHHH</a> method, the widespread <a href="BFGS_method" title="wikilink">BFGS method</a> (suggested independently by Broyden, Fletcher, Goldfarb, and Shanno, in 1970), and its low-memory extension, <a class="uri" href="L-BFGS" title="wikilink">L-BFGS</a>. The Broyden's class is a linear combination of the DFP and BFGS methods.</p>

<p>The SR1 formula does not guarantee the update matrix to maintain <a href="Positive-definite_matrix" title="wikilink">positive-definiteness</a> and can be used for indefinite problems. The <a href="Broyden's_method" title="wikilink">Broyden's method</a> does not require the update matrix to be symmetric and it is used to find the root of a general system of equations (rather than the gradient) by updating the <a href="Jacobian_matrix_and_determinant" title="wikilink">Jacobian</a> (rather than the Hessian).</p>

<p>One of the chief advantages of quasi-Newton methods over <a href="Newton's_method_in_optimization" title="wikilink">Newton's method</a> is that the <a href="Hessian_matrix" title="wikilink">Hessian matrix</a> (or, in the case of quasi-Newton methods, its approximation) 

<math display="inline" id="Quasi-Newton_method:15">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

 does not need to be inverted. Newton's method, and its derivatives such as <a href="interior_point_method" title="wikilink">interior point methods</a>, require the Hessian to be inverted, which is typically implemented by solving a <a href="system_of_linear_equations" title="wikilink">system of linear equations</a> and is often quite costly. In contrast, quasi-Newton methods usually generate an estimate of 

<math display="inline" id="Quasi-Newton_method:16">
 <semantics>
  <msup>
   <mi>B</mi>
   <mrow>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>B</ci>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B^{-1}
  </annotation>
 </semantics>
</math>

 directly.</p>

<p>As in <a href="Newton's_method_in_optimization" title="wikilink">Newton's method</a>, one uses a second order approximation to find the minimum of a function 

<math display="inline" id="Quasi-Newton_method:17">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x)
  </annotation>
 </semantics>
</math>

. The <a href="Taylor_series" title="wikilink">Taylor series</a> of 

<math display="inline" id="Quasi-Newton_method:18">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x)
  </annotation>
 </semantics>
</math>

 around an iterate is:</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Quasi-Newton_method:19">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>x</mi>
        <mi>k</mi>
       </msub>
       <mo>+</mo>
       <mrow>
        <mi mathvariant="normal">Δ</mi>
        <mi>x</mi>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>≈</mo>
    <mrow>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>x</mi>
        <mi>k</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mrow>
       <mo>∇</mo>
       <mi>f</mi>
      </mrow>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>x</mi>
         <mi>k</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
       <mi>T</mi>
      </msup>
      <mi mathvariant="normal">Δ</mi>
      <mi>x</mi>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mfrac>
       <mn>1</mn>
       <mn>2</mn>
      </mfrac>
      <mi mathvariant="normal">Δ</mi>
      <msup>
       <mi>x</mi>
       <mi>T</mi>
      </msup>
      <mpadded width="+1.7pt">
       <mi>B</mi>
      </mpadded>
      <mi mathvariant="normal">Δ</mi>
      <mi>x</mi>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <apply>
     <times></times>
     <ci>f</ci>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>k</ci>
      </apply>
      <apply>
       <times></times>
       <ci>normal-Δ</ci>
       <ci>x</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>f</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>k</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <ci>normal-∇</ci>
       <ci>f</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>k</ci>
       </apply>
       <ci>T</ci>
      </apply>
      <ci>normal-Δ</ci>
      <ci>x</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-Δ</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <ci>T</ci>
      </apply>
      <ci>B</ci>
      <ci>normal-Δ</ci>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x_{k}+\Delta x)\approx f(x_{k})+\nabla f(x_{k})^{T}\Delta x+\frac{1}{2}%
\Delta x^{T}{B}\,\Delta x,
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>where (

<math display="inline" id="Quasi-Newton_method:20">
 <semantics>
  <mrow>
   <mo>∇</mo>
   <mi>f</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-∇</ci>
    <ci>f</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \nabla f
  </annotation>
 </semantics>
</math>

) is the <a class="uri" href="gradient" title="wikilink">gradient</a> and 

<math display="inline" id="Quasi-Newton_method:21">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

 an approximation to the <a href="Hessian_matrix" title="wikilink">Hessian matrix</a>. The gradient of this approximation (with respect to 

<math display="inline" id="Quasi-Newton_method:22">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Δ</mi>
   <mi>x</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Δ</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta x
  </annotation>
 </semantics>
</math>

) is</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Quasi-Newton_method:23">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>∇</mo>
     <mi>f</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>x</mi>
       <mi>k</mi>
      </msub>
      <mo>+</mo>
      <mrow>
       <mi mathvariant="normal">Δ</mi>
       <mi>x</mi>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≈</mo>
   <mrow>
    <mrow>
     <mrow>
      <mo>∇</mo>
      <mi>f</mi>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mi>k</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mpadded width="+1.7pt">
      <mi>B</mi>
     </mpadded>
     <mi mathvariant="normal">Δ</mi>
     <mi>x</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <apply>
     <times></times>
     <apply>
      <ci>normal-∇</ci>
      <ci>f</ci>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>k</ci>
      </apply>
      <apply>
       <times></times>
       <ci>normal-Δ</ci>
       <ci>x</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <ci>normal-∇</ci>
       <ci>f</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>k</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>B</ci>
      <ci>normal-Δ</ci>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \nabla f(x_{k}+\Delta x)\approx\nabla f(x_{k})+B\,\Delta x
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>and setting this gradient to zero (which is the objective of optimisation) provides the Newton step:</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Quasi-Newton_method:24">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi mathvariant="normal">Δ</mi>
     <mi>x</mi>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo>-</mo>
     <mrow>
      <msup>
       <mi>B</mi>
       <mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msup>
      <mrow>
       <mo>∇</mo>
       <mi>f</mi>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>x</mi>
        <mi>k</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>normal-Δ</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>B</ci>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <ci>normal-∇</ci>
       <ci>f</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta x=-B^{-1}\nabla f(x_{k}),\,
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>The Hessian approximation 

<math display="inline" id="Quasi-Newton_method:25">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

 is chosen to satisfy</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Quasi-Newton_method:26">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mo>∇</mo>
      <mi>f</mi>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>x</mi>
        <mi>k</mi>
       </msub>
       <mo>+</mo>
       <mrow>
        <mi mathvariant="normal">Δ</mi>
        <mi>x</mi>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mrow>
       <mo>∇</mo>
       <mi>f</mi>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>x</mi>
        <mi>k</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mpadded width="+1.7pt">
       <mi>B</mi>
      </mpadded>
      <mi mathvariant="normal">Δ</mi>
      <mi>x</mi>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <ci>normal-∇</ci>
      <ci>f</ci>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>k</ci>
      </apply>
      <apply>
       <times></times>
       <ci>normal-Δ</ci>
       <ci>x</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <ci>normal-∇</ci>
       <ci>f</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>k</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>B</ci>
      <ci>normal-Δ</ci>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \nabla f(x_{k}+\Delta x)=\nabla f(x_{k})+B\,\Delta x,
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>which is called the <em>secant equation</em> (the Taylor series of the gradient itself). In more than one dimension 

<math display="inline" id="Quasi-Newton_method:27">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

 is <a href="Underdetermined_system" title="wikilink">underdetermined</a>. In one dimension, solving for 

<math display="inline" id="Quasi-Newton_method:28">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

 and applying the Newton's step with the updated value is equivalent to the <a href="secant_method" title="wikilink">secant method</a>. The various quasi-Newton methods differ in their choice of the solution to the secant equation (in one dimension, all the variants are equivalent). Most methods (but with exceptions, such as <a href="Broyden's_method" title="wikilink">Broyden's method</a>) seek a symmetric solution (

<math display="inline" id="Quasi-Newton_method:29">
 <semantics>
  <mrow>
   <msup>
    <mi>B</mi>
    <mi>T</mi>
   </msup>
   <mo>=</mo>
   <mi>B</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>B</ci>
     <ci>T</ci>
    </apply>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B^{T}=B
  </annotation>
 </semantics>
</math>

); furthermore, the variants listed below can be motivated by finding an update 

<math display="inline" id="Quasi-Newton_method:30">
 <semantics>
  <msub>
   <mi>B</mi>
   <mrow>
    <mi>k</mi>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>B</ci>
    <apply>
     <plus></plus>
     <ci>k</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B_{k+1}
  </annotation>
 </semantics>
</math>

 that is as close as possible to 

<math display="inline" id="Quasi-Newton_method:31">
 <semantics>
  <msub>
   <mi>B</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>B</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B_{k}
  </annotation>
 </semantics>
</math>

 in some <a href="Norm_(mathematics)" title="wikilink">norm</a>; that is, 

<math display="inline" id="Quasi-Newton_method:32">
 <semantics>
  <mrow>
   <msub>
    <mi>B</mi>
    <mrow>
     <mi>k</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mtext>argmin</mtext>
     <mi>B</mi>
    </msub>
    <msub>
     <mrow>
      <mo>∥</mo>
      <mrow>
       <mi>B</mi>
       <mo>-</mo>
       <msub>
        <mi>B</mi>
        <mi>k</mi>
       </msub>
      </mrow>
      <mo>∥</mo>
     </mrow>
     <mi>V</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>B</ci>
     <apply>
      <plus></plus>
      <ci>k</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <mtext>argmin</mtext>
      <ci>B</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="latexml">norm</csymbol>
       <apply>
        <minus></minus>
        <ci>B</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>B</ci>
         <ci>k</ci>
        </apply>
       </apply>
      </apply>
      <ci>V</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B_{k+1}=\textrm{argmin}_{B}\|B-B_{k}\|_{V}
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Quasi-Newton_method:33">
 <semantics>
  <mi>V</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>V</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V
  </annotation>
 </semantics>
</math>

 is some <a href="positive_definite_matrix" title="wikilink">positive definite matrix</a> that defines the norm. An approximate initial value of 

<math display="inline" id="Quasi-Newton_method:34">
 <semantics>
  <mrow>
   <msub>
    <mi>B</mi>
    <mn>0</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <mi>I</mi>
    <mo>*</mo>
    <mi>x</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>B</ci>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <times></times>
     <ci>I</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B_{0}=I*x
  </annotation>
 </semantics>
</math>

 is often sufficient to achieve rapid convergence. Note that 

<math display="inline" id="Quasi-Newton_method:35">
 <semantics>
  <msub>
   <mi>B</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>B</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B_{0}
  </annotation>
 </semantics>
</math>

 should be positive definite. The unknown 

<math display="inline" id="Quasi-Newton_method:36">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{k}
  </annotation>
 </semantics>
</math>

 is updated applying the Newton's step calculated using the current approximate Hessian matrix 

<math display="inline" id="Quasi-Newton_method:37">
 <semantics>
  <msub>
   <mi>B</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>B</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B_{k}
  </annotation>
 </semantics>
</math>

</p>
<ul>
<li>

<math display="inline" id="Quasi-Newton_method:38">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">Δ</mi>
    <msub>
     <mi>x</mi>
     <mi>k</mi>
    </msub>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <mrow>
     <msub>
      <mi>α</mi>
      <mi>k</mi>
     </msub>
     <msubsup>
      <mi>B</mi>
      <mi>k</mi>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msubsup>
     <mrow>
      <mo>∇</mo>
      <mi>f</mi>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mi>k</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>normal-Δ</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>k</ci>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>α</ci>
       <ci>k</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>B</ci>
        <ci>k</ci>
       </apply>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <ci>normal-∇</ci>
       <ci>f</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta x_{k}=-\alpha_{k}B_{k}^{-1}\nabla f(x_{k})
  </annotation>
 </semantics>
</math>

, with 

<math display="inline" id="Quasi-Newton_method:39">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>

 chosen to satisfy the <a href="Wolfe_conditions" title="wikilink">Wolfe conditions</a>;</li>
<li>

<math display="inline" id="Quasi-Newton_method:40">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mrow>
     <mi>k</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>x</mi>
     <mi>k</mi>
    </msub>
    <mo>+</mo>
    <mrow>
     <mi mathvariant="normal">Δ</mi>
     <msub>
      <mi>x</mi>
      <mi>k</mi>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <apply>
      <plus></plus>
      <ci>k</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>k</ci>
     </apply>
     <apply>
      <times></times>
      <ci>normal-Δ</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{k+1}=x_{k}+\Delta x_{k}
  </annotation>
 </semantics>
</math>

;</li>
<li>The gradient computed at the new point 

<math display="inline" id="Quasi-Newton_method:41">
 <semantics>
  <mrow>
   <mrow>
    <mo>∇</mo>
    <mi>f</mi>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mrow>
      <mi>k</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <ci>normal-∇</ci>
     <ci>f</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <apply>
      <plus></plus>
      <ci>k</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \nabla f(x_{k+1})
  </annotation>
 </semantics>
</math>

, and</li>
</ul>

<p>

<math display="block" id="Quasi-Newton_method:42">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>y</mi>
     <mi>k</mi>
    </msub>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mrow>
       <mo>∇</mo>
       <mi>f</mi>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>x</mi>
        <mrow>
         <mi>k</mi>
         <mo>+</mo>
         <mn>1</mn>
        </mrow>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>-</mo>
     <mrow>
      <mrow>
       <mo>∇</mo>
       <mi>f</mi>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>x</mi>
        <mi>k</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <apply>
       <ci>normal-∇</ci>
       <ci>f</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <apply>
        <plus></plus>
        <ci>k</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <ci>normal-∇</ci>
       <ci>f</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{k}=\nabla f(x_{k+1})-\nabla f(x_{k}),
  </annotation>
 </semantics>
</math>

 is used to update the approximate Hessian 

<math display="inline" id="Quasi-Newton_method:43">
 <semantics>
  <msub>
   <mi>B</mi>
   <mrow>
    <mi>k</mi>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>B</ci>
    <apply>
     <plus></plus>
     <ci>k</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle B_{k+1}
  </annotation>
 </semantics>
</math>

, or directly its inverse 

<math display="inline" id="Quasi-Newton_method:44">
 <semantics>
  <mrow>
   <msub>
    <mi>H</mi>
    <mrow>
     <mi>k</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo>=</mo>
   <msubsup>
    <mi>B</mi>
    <mrow>
     <mi>k</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
    <mrow>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msubsup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>H</ci>
     <apply>
      <plus></plus>
      <ci>k</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>B</ci>
      <apply>
       <plus></plus>
       <ci>k</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle H_{k+1}=B_{k+1}^{-1}
  </annotation>
 </semantics>
</math>

 using the <a href="Sherman-Morrison_formula" title="wikilink">Sherman-Morrison formula</a>.</p>
<ul>
<li>A key property of the BFGS and DFP updates is that if 

<math display="inline" id="Quasi-Newton_method:45">
 <semantics>
  <msub>
   <mi>B</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>B</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B_{k}
  </annotation>
 </semantics>
</math>

 is positive definite and 

<math display="inline" id="Quasi-Newton_method:46">
 <semantics>
  <msub>
   <mi>α</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>α</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha_{k}
  </annotation>
 </semantics>
</math>

 is chosen to satisfy the Wolfe conditions then 

<math display="inline" id="Quasi-Newton_method:47">
 <semantics>
  <msub>
   <mi>B</mi>
   <mrow>
    <mi>k</mi>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>B</ci>
    <apply>
     <plus></plus>
     <ci>k</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle B_{k+1}
  </annotation>
 </semantics>
</math>

 is also positive definite.</li>
</ul>

<p>The most popular update formulas are:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>Method</p></th>
<th style="text-align: left;">
<p>

<math display="inline" id="Quasi-Newton_method:48">
 <semantics>
  <mrow>
   <msub>
    <mi>B</mi>
    <mrow>
     <mi>k</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo>=</mo>
   <mi></mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>B</ci>
     <apply>
      <plus></plus>
      <ci>k</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <csymbol cd="latexml">absent</csymbol>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle B_{k+1}=
  </annotation>
 </semantics>
</math>

</p></th>
<th style="text-align: left;">
<p>

<math display="inline" id="Quasi-Newton_method:49">
 <semantics>
  <mrow>
   <msub>
    <mi>H</mi>
    <mrow>
     <mi>k</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo>=</mo>
   <msubsup>
    <mi>B</mi>
    <mrow>
     <mi>k</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
    <mrow>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msubsup>
   <mo>=</mo>
   <mi></mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>H</ci>
      <apply>
       <plus></plus>
       <ci>k</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>B</ci>
       <apply>
        <plus></plus>
        <ci>k</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <csymbol cd="latexml">absent</csymbol>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{k+1}=B_{k+1}^{-1}=
  </annotation>
 </semantics>
</math>

</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p><a href="DFP_updating_formula" title="wikilink">DFP</a></p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Quasi-Newton_method:50">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mi>I</mi>
      <mo>-</mo>
      <mfrac>
       <mrow>
        <mpadded width="+1.7pt">
         <msub>
          <mi>y</mi>
          <mi>k</mi>
         </msub>
        </mpadded>
        <mi mathvariant="normal">Δ</mi>
        <msubsup>
         <mi>x</mi>
         <mi>k</mi>
         <mi>T</mi>
        </msubsup>
       </mrow>
       <mrow>
        <mpadded width="+1.7pt">
         <msubsup>
          <mi>y</mi>
          <mi>k</mi>
          <mi>T</mi>
         </msubsup>
        </mpadded>
        <mi mathvariant="normal">Δ</mi>
        <msub>
         <mi>x</mi>
         <mi>k</mi>
        </msub>
       </mrow>
      </mfrac>
     </mrow>
     <mo>)</mo>
    </mrow>
    <msub>
     <mi>B</mi>
     <mi>k</mi>
    </msub>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mi>I</mi>
      <mo>-</mo>
      <mfrac>
       <mrow>
        <mi mathvariant="normal">Δ</mi>
        <msub>
         <mi>x</mi>
         <mi>k</mi>
        </msub>
        <msubsup>
         <mi>y</mi>
         <mi>k</mi>
         <mi>T</mi>
        </msubsup>
       </mrow>
       <mrow>
        <mpadded width="+1.7pt">
         <msubsup>
          <mi>y</mi>
          <mi>k</mi>
          <mi>T</mi>
         </msubsup>
        </mpadded>
        <mi mathvariant="normal">Δ</mi>
        <msub>
         <mi>x</mi>
         <mi>k</mi>
        </msub>
       </mrow>
      </mfrac>
     </mrow>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>+</mo>
   <mfrac>
    <mrow>
     <msub>
      <mi>y</mi>
      <mi>k</mi>
     </msub>
     <msubsup>
      <mi>y</mi>
      <mi>k</mi>
      <mi>T</mi>
     </msubsup>
    </mrow>
    <mrow>
     <mpadded width="+1.7pt">
      <msubsup>
       <mi>y</mi>
       <mi>k</mi>
       <mi>T</mi>
      </msubsup>
     </mpadded>
     <mi mathvariant="normal">Δ</mi>
     <msub>
      <mi>x</mi>
      <mi>k</mi>
     </msub>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <times></times>
     <apply>
      <minus></minus>
      <ci>I</ci>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>y</ci>
         <ci>k</ci>
        </apply>
        <ci>normal-Δ</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <ci>k</ci>
         </apply>
         <ci>T</ci>
        </apply>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>y</ci>
          <ci>k</ci>
         </apply>
         <ci>T</ci>
        </apply>
        <ci>normal-Δ</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>k</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>B</ci>
      <ci>k</ci>
     </apply>
     <apply>
      <minus></minus>
      <ci>I</ci>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <ci>normal-Δ</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>k</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>y</ci>
          <ci>k</ci>
         </apply>
         <ci>T</ci>
        </apply>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>y</ci>
          <ci>k</ci>
         </apply>
         <ci>T</ci>
        </apply>
        <ci>normal-Δ</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>k</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <ci>k</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <ci>k</ci>
       </apply>
       <ci>T</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <ci>k</ci>
       </apply>
       <ci>T</ci>
      </apply>
      <ci>normal-Δ</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left(I-\frac{y_{k}\,\Delta x_{k}^{T}}{y_{k}^{T}\,\Delta x_{k}}\right)B_{k}%
\left(I-\frac{\Delta x_{k}y_{k}^{T}}{y_{k}^{T}\,\Delta x_{k}}\right)+\frac{y_{%
k}y_{k}^{T}}{y_{k}^{T}\,\Delta x_{k}}
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Quasi-Newton_method:51">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>H</mi>
     <mi>k</mi>
    </msub>
    <mo>+</mo>
    <mfrac>
     <mrow>
      <mi mathvariant="normal">Δ</mi>
      <msub>
       <mi>x</mi>
       <mi>k</mi>
      </msub>
      <mi mathvariant="normal">Δ</mi>
      <msubsup>
       <mi>x</mi>
       <mi>k</mi>
       <mi>T</mi>
      </msubsup>
     </mrow>
     <mrow>
      <mpadded width="+1.7pt">
       <msubsup>
        <mi>y</mi>
        <mi>k</mi>
        <mi>T</mi>
       </msubsup>
      </mpadded>
      <mi mathvariant="normal">Δ</mi>
      <msub>
       <mi>x</mi>
       <mi>k</mi>
      </msub>
     </mrow>
    </mfrac>
   </mrow>
   <mo>-</mo>
   <mfrac>
    <mrow>
     <msub>
      <mi>H</mi>
      <mi>k</mi>
     </msub>
     <msub>
      <mi>y</mi>
      <mi>k</mi>
     </msub>
     <msubsup>
      <mi>y</mi>
      <mi>k</mi>
      <mi>T</mi>
     </msubsup>
     <msubsup>
      <mi>H</mi>
      <mi>k</mi>
      <mi>T</mi>
     </msubsup>
    </mrow>
    <mrow>
     <msubsup>
      <mi>y</mi>
      <mi>k</mi>
      <mi>T</mi>
     </msubsup>
     <msub>
      <mi>H</mi>
      <mi>k</mi>
     </msub>
     <msub>
      <mi>y</mi>
      <mi>k</mi>
     </msub>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>H</ci>
      <ci>k</ci>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <ci>normal-Δ</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>k</ci>
       </apply>
       <ci>normal-Δ</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>k</ci>
        </apply>
        <ci>T</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>y</ci>
         <ci>k</ci>
        </apply>
        <ci>T</ci>
       </apply>
       <ci>normal-Δ</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>k</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>H</ci>
       <ci>k</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <ci>k</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <ci>k</ci>
       </apply>
       <ci>T</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>H</ci>
        <ci>k</ci>
       </apply>
       <ci>T</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <ci>k</ci>
       </apply>
       <ci>T</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>H</ci>
       <ci>k</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{k}+\frac{\Delta x_{k}\Delta x_{k}^{T}}{y_{k}^{T}\,\Delta x_{k}}-\frac{H_{k}%
y_{k}y_{k}^{T}H_{k}^{T}}{y_{k}^{T}H_{k}y_{k}}
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><a href="BFGS_method" title="wikilink">BFGS</a></p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Quasi-Newton_method:52">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>B</mi>
     <mi>k</mi>
    </msub>
    <mo>+</mo>
    <mfrac>
     <mrow>
      <msub>
       <mi>y</mi>
       <mi>k</mi>
      </msub>
      <msubsup>
       <mi>y</mi>
       <mi>k</mi>
       <mi>T</mi>
      </msubsup>
     </mrow>
     <mrow>
      <msubsup>
       <mi>y</mi>
       <mi>k</mi>
       <mi>T</mi>
      </msubsup>
      <mi mathvariant="normal">Δ</mi>
      <msub>
       <mi>x</mi>
       <mi>k</mi>
      </msub>
     </mrow>
    </mfrac>
   </mrow>
   <mo>-</mo>
   <mfrac>
    <mrow>
     <msub>
      <mi>B</mi>
      <mi>k</mi>
     </msub>
     <mi mathvariant="normal">Δ</mi>
     <msub>
      <mi>x</mi>
      <mi>k</mi>
     </msub>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <msub>
         <mi>B</mi>
         <mi>k</mi>
        </msub>
        <mi mathvariant="normal">Δ</mi>
        <msub>
         <mi>x</mi>
         <mi>k</mi>
        </msub>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>T</mi>
     </msup>
    </mrow>
    <mrow>
     <mi mathvariant="normal">Δ</mi>
     <msubsup>
      <mi>x</mi>
      <mi>k</mi>
      <mi>T</mi>
     </msubsup>
     <mpadded width="+1.7pt">
      <msub>
       <mi>B</mi>
       <mi>k</mi>
      </msub>
     </mpadded>
     <mi mathvariant="normal">Δ</mi>
     <msub>
      <mi>x</mi>
      <mi>k</mi>
     </msub>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>B</ci>
      <ci>k</ci>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <ci>k</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>y</ci>
         <ci>k</ci>
        </apply>
        <ci>T</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>y</ci>
         <ci>k</ci>
        </apply>
        <ci>T</ci>
       </apply>
       <ci>normal-Δ</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>k</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>B</ci>
       <ci>k</ci>
      </apply>
      <ci>normal-Δ</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>k</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>B</ci>
         <ci>k</ci>
        </apply>
        <ci>normal-Δ</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>k</ci>
        </apply>
       </apply>
       <ci>T</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>normal-Δ</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>k</ci>
       </apply>
       <ci>T</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>B</ci>
       <ci>k</ci>
      </apply>
      <ci>normal-Δ</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B_{k}+\frac{y_{k}y_{k}^{T}}{y_{k}^{T}\Delta x_{k}}-\frac{B_{k}\Delta x_{k}(B_{%
k}\Delta x_{k})^{T}}{\Delta x_{k}^{T}B_{k}\,\Delta x_{k}}
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Quasi-Newton_method:53">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mrow>
      <mo>(</mo>
      <mrow>
       <mi>I</mi>
       <mo>-</mo>
       <mfrac>
        <mrow>
         <mi mathvariant="normal">Δ</mi>
         <msub>
          <mi>x</mi>
          <mi>k</mi>
         </msub>
         <msubsup>
          <mi>y</mi>
          <mi>k</mi>
          <mi>T</mi>
         </msubsup>
        </mrow>
        <mrow>
         <msubsup>
          <mi>y</mi>
          <mi>k</mi>
          <mi>T</mi>
         </msubsup>
         <mi mathvariant="normal">Δ</mi>
         <msub>
          <mi>x</mi>
          <mi>k</mi>
         </msub>
        </mrow>
       </mfrac>
      </mrow>
      <mo>)</mo>
     </mrow>
     <mi>T</mi>
    </msup>
    <msub>
     <mi>H</mi>
     <mi>k</mi>
    </msub>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mi>I</mi>
      <mo>-</mo>
      <mfrac>
       <mrow>
        <msub>
         <mi>y</mi>
         <mi>k</mi>
        </msub>
        <mi mathvariant="normal">Δ</mi>
        <msubsup>
         <mi>x</mi>
         <mi>k</mi>
         <mi>T</mi>
        </msubsup>
       </mrow>
       <mrow>
        <msubsup>
         <mi>y</mi>
         <mi>k</mi>
         <mi>T</mi>
        </msubsup>
        <mi mathvariant="normal">Δ</mi>
        <msub>
         <mi>x</mi>
         <mi>k</mi>
        </msub>
       </mrow>
      </mfrac>
     </mrow>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>+</mo>
   <mfrac>
    <mrow>
     <mi mathvariant="normal">Δ</mi>
     <msub>
      <mi>x</mi>
      <mi>k</mi>
     </msub>
     <mi mathvariant="normal">Δ</mi>
     <msubsup>
      <mi>x</mi>
      <mi>k</mi>
      <mi>T</mi>
     </msubsup>
    </mrow>
    <mrow>
     <mpadded width="+1.7pt">
      <msubsup>
       <mi>y</mi>
       <mi>k</mi>
       <mi>T</mi>
      </msubsup>
     </mpadded>
     <mi mathvariant="normal">Δ</mi>
     <msub>
      <mi>x</mi>
      <mi>k</mi>
     </msub>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <minus></minus>
       <ci>I</ci>
       <apply>
        <divide></divide>
        <apply>
         <times></times>
         <ci>normal-Δ</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <ci>k</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>y</ci>
           <ci>k</ci>
          </apply>
          <ci>T</ci>
         </apply>
        </apply>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>y</ci>
           <ci>k</ci>
          </apply>
          <ci>T</ci>
         </apply>
         <ci>normal-Δ</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <ci>k</ci>
         </apply>
        </apply>
       </apply>
      </apply>
      <ci>T</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>H</ci>
      <ci>k</ci>
     </apply>
     <apply>
      <minus></minus>
      <ci>I</ci>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>y</ci>
         <ci>k</ci>
        </apply>
        <ci>normal-Δ</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <ci>k</ci>
         </apply>
         <ci>T</ci>
        </apply>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>y</ci>
          <ci>k</ci>
         </apply>
         <ci>T</ci>
        </apply>
        <ci>normal-Δ</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>k</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <ci>normal-Δ</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>k</ci>
      </apply>
      <ci>normal-Δ</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>k</ci>
       </apply>
       <ci>T</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <ci>k</ci>
       </apply>
       <ci>T</ci>
      </apply>
      <ci>normal-Δ</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left(I-\frac{\Delta x_{k}y_{k}^{T}}{y_{k}^{T}\Delta x_{k}}\right)^{T}H_{k}%
\left(I-\frac{y_{k}\Delta x_{k}^{T}}{y_{k}^{T}\Delta x_{k}}\right)+\frac{%
\Delta x_{k}\Delta x_{k}^{T}}{y_{k}^{T}\,\Delta x_{k}}
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><a href="Broyden's_method" title="wikilink">Broyden</a></p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Quasi-Newton_method:54">
 <semantics>
  <mrow>
   <msub>
    <mi>B</mi>
    <mi>k</mi>
   </msub>
   <mo>+</mo>
   <mrow>
    <mpadded width="+1.7pt">
     <mfrac>
      <mrow>
       <msub>
        <mi>y</mi>
        <mi>k</mi>
       </msub>
       <mo>-</mo>
       <mrow>
        <msub>
         <mi>B</mi>
         <mi>k</mi>
        </msub>
        <mi mathvariant="normal">Δ</mi>
        <msub>
         <mi>x</mi>
         <mi>k</mi>
        </msub>
       </mrow>
      </mrow>
      <mrow>
       <mi mathvariant="normal">Δ</mi>
       <mpadded width="+1.7pt">
        <msubsup>
         <mi>x</mi>
         <mi>k</mi>
         <mi>T</mi>
        </msubsup>
       </mpadded>
       <mi mathvariant="normal">Δ</mi>
       <msub>
        <mi>x</mi>
        <mi>k</mi>
       </msub>
      </mrow>
     </mfrac>
    </mpadded>
    <mi mathvariant="normal">Δ</mi>
    <msubsup>
     <mi>x</mi>
     <mi>k</mi>
     <mi>T</mi>
    </msubsup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>B</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <ci>k</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>B</ci>
         <ci>k</ci>
        </apply>
        <ci>normal-Δ</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>k</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>normal-Δ</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>k</ci>
        </apply>
        <ci>T</ci>
       </apply>
       <ci>normal-Δ</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>k</ci>
       </apply>
      </apply>
     </apply>
     <ci>normal-Δ</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>k</ci>
      </apply>
      <ci>T</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B_{k}+\frac{y_{k}-B_{k}\Delta x_{k}}{\Delta x_{k}^{T}\,\Delta x_{k}}\,\Delta x%
_{k}^{T}
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Quasi-Newton_method:55">
 <semantics>
  <mrow>
   <msub>
    <mi>H</mi>
    <mi>k</mi>
   </msub>
   <mo>+</mo>
   <mfrac>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <mi mathvariant="normal">Δ</mi>
        <msub>
         <mi>x</mi>
         <mi>k</mi>
        </msub>
       </mrow>
       <mo>-</mo>
       <mrow>
        <msub>
         <mi>H</mi>
         <mi>k</mi>
        </msub>
        <msub>
         <mi>y</mi>
         <mi>k</mi>
        </msub>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi mathvariant="normal">Δ</mi>
     <msubsup>
      <mi>x</mi>
      <mi>k</mi>
      <mi>T</mi>
     </msubsup>
     <msub>
      <mi>H</mi>
      <mi>k</mi>
     </msub>
    </mrow>
    <mrow>
     <mi mathvariant="normal">Δ</mi>
     <msubsup>
      <mi>x</mi>
      <mi>k</mi>
      <mi>T</mi>
     </msubsup>
     <mpadded width="+1.7pt">
      <msub>
       <mi>H</mi>
       <mi>k</mi>
      </msub>
     </mpadded>
     <msub>
      <mi>y</mi>
      <mi>k</mi>
     </msub>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>H</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <ci>normal-Δ</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>k</ci>
        </apply>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>H</ci>
         <ci>k</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>y</ci>
         <ci>k</ci>
        </apply>
       </apply>
      </apply>
      <ci>normal-Δ</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>k</ci>
       </apply>
       <ci>T</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>H</ci>
       <ci>k</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>normal-Δ</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>k</ci>
       </apply>
       <ci>T</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>H</ci>
       <ci>k</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{k}+\frac{(\Delta x_{k}-H_{k}y_{k})\Delta x_{k}^{T}H_{k}}{\Delta x_{k}^{T}H_%
{k}\,y_{k}}
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Broyden family</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Quasi-Newton_method:56">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mn>1</mn>
        <mo>-</mo>
        <msub>
         <mi>φ</mi>
         <mi>k</mi>
        </msub>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <msubsup>
       <mi>B</mi>
       <mrow>
        <mi>k</mi>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
       <mrow>
        <mi>B</mi>
        <mi>F</mi>
        <mi>G</mi>
        <mi>S</mi>
       </mrow>
      </msubsup>
     </mrow>
     <mo>+</mo>
     <mrow>
      <msub>
       <mi>φ</mi>
       <mi>k</mi>
      </msub>
      <msubsup>
       <mi>B</mi>
       <mrow>
        <mi>k</mi>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
       <mrow>
        <mi>D</mi>
        <mi>F</mi>
        <mi>P</mi>
       </mrow>
      </msubsup>
     </mrow>
    </mrow>
    <mo rspace="22.5pt">,</mo>
    <mi>φ</mi>
   </mrow>
   <mo>∈</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mn>1</mn>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <list>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>φ</ci>
         <ci>k</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>B</ci>
         <apply>
          <plus></plus>
          <ci>k</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <apply>
         <times></times>
         <ci>B</ci>
         <ci>F</ci>
         <ci>G</ci>
         <ci>S</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>φ</ci>
        <ci>k</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>B</ci>
         <apply>
          <plus></plus>
          <ci>k</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <apply>
         <times></times>
         <ci>D</ci>
         <ci>F</ci>
         <ci>P</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <ci>φ</ci>
    </list>
    <interval closure="closed">
     <cn type="integer">0</cn>
     <cn type="integer">1</cn>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (1-\varphi_{k})B_{k+1}^{BFGS}+\varphi_{k}B_{k+1}^{DFP},\qquad\varphi\in[0,1]
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><a href="SR1_formula" title="wikilink">SR1</a></p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Quasi-Newton_method:57">
 <semantics>
  <mrow>
   <msub>
    <mi>B</mi>
    <mi>k</mi>
   </msub>
   <mo>+</mo>
   <mfrac>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>y</mi>
        <mi>k</mi>
       </msub>
       <mo>-</mo>
       <mrow>
        <mpadded width="+1.7pt">
         <msub>
          <mi>B</mi>
          <mi>k</mi>
         </msub>
        </mpadded>
        <mi mathvariant="normal">Δ</mi>
        <msub>
         <mi>x</mi>
         <mi>k</mi>
        </msub>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <msub>
         <mi>y</mi>
         <mi>k</mi>
        </msub>
        <mo>-</mo>
        <mrow>
         <mpadded width="+1.7pt">
          <msub>
           <mi>B</mi>
           <mi>k</mi>
          </msub>
         </mpadded>
         <mi mathvariant="normal">Δ</mi>
         <msub>
          <mi>x</mi>
          <mi>k</mi>
         </msub>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>T</mi>
     </msup>
    </mrow>
    <mrow>
     <mpadded width="+1.7pt">
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <msub>
          <mi>y</mi>
          <mi>k</mi>
         </msub>
         <mo>-</mo>
         <mrow>
          <mpadded width="+1.7pt">
           <msub>
            <mi>B</mi>
            <mi>k</mi>
           </msub>
          </mpadded>
          <mi mathvariant="normal">Δ</mi>
          <msub>
           <mi>x</mi>
           <mi>k</mi>
          </msub>
         </mrow>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mi>T</mi>
      </msup>
     </mpadded>
     <mi mathvariant="normal">Δ</mi>
     <msub>
      <mi>x</mi>
      <mi>k</mi>
     </msub>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>B</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <ci>k</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>B</ci>
         <ci>k</ci>
        </apply>
        <ci>normal-Δ</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>k</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>y</ci>
         <ci>k</ci>
        </apply>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>B</ci>
          <ci>k</ci>
         </apply>
         <ci>normal-Δ</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <ci>k</ci>
         </apply>
        </apply>
       </apply>
       <ci>T</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>y</ci>
         <ci>k</ci>
        </apply>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>B</ci>
          <ci>k</ci>
         </apply>
         <ci>normal-Δ</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <ci>k</ci>
         </apply>
        </apply>
       </apply>
       <ci>T</ci>
      </apply>
      <ci>normal-Δ</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B_{k}+\frac{(y_{k}-B_{k}\,\Delta x_{k})(y_{k}-B_{k}\,\Delta x_{k})^{T}}{(y_{k}%
-B_{k}\,\Delta x_{k})^{T}\,\Delta x_{k}}
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Quasi-Newton_method:58">
 <semantics>
  <mrow>
   <msub>
    <mi>H</mi>
    <mi>k</mi>
   </msub>
   <mo>+</mo>
   <mfrac>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <mi mathvariant="normal">Δ</mi>
        <msub>
         <mi>x</mi>
         <mi>k</mi>
        </msub>
       </mrow>
       <mo>-</mo>
       <mrow>
        <msub>
         <mi>H</mi>
         <mi>k</mi>
        </msub>
        <msub>
         <mi>y</mi>
         <mi>k</mi>
        </msub>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mrow>
         <mi mathvariant="normal">Δ</mi>
         <msub>
          <mi>x</mi>
          <mi>k</mi>
         </msub>
        </mrow>
        <mo>-</mo>
        <mrow>
         <msub>
          <mi>H</mi>
          <mi>k</mi>
         </msub>
         <msub>
          <mi>y</mi>
          <mi>k</mi>
         </msub>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>T</mi>
     </msup>
    </mrow>
    <mrow>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mrow>
         <mi mathvariant="normal">Δ</mi>
         <msub>
          <mi>x</mi>
          <mi>k</mi>
         </msub>
        </mrow>
        <mo>-</mo>
        <mrow>
         <msub>
          <mi>H</mi>
          <mi>k</mi>
         </msub>
         <msub>
          <mi>y</mi>
          <mi>k</mi>
         </msub>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>T</mi>
     </msup>
     <msub>
      <mi>y</mi>
      <mi>k</mi>
     </msub>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>H</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <ci>normal-Δ</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>k</ci>
        </apply>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>H</ci>
         <ci>k</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>y</ci>
         <ci>k</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <ci>normal-Δ</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <ci>k</ci>
         </apply>
        </apply>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>H</ci>
          <ci>k</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>y</ci>
          <ci>k</ci>
         </apply>
        </apply>
       </apply>
       <ci>T</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <ci>normal-Δ</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <ci>k</ci>
         </apply>
        </apply>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>H</ci>
          <ci>k</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>y</ci>
          <ci>k</ci>
         </apply>
        </apply>
       </apply>
       <ci>T</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{k}+\frac{(\Delta x_{k}-H_{k}y_{k})(\Delta x_{k}-H_{k}y_{k})^{T}}{(\Delta x_%
{k}-H_{k}y_{k})^{T}y_{k}}
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
</tbody>
</table>

<p>Other methods are Pearson's method, McCormick's Method, the Powell symmetric Broyden (PSB) method and Greenstadt's method.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>
<h2 id="implementations">Implementations</h2>

<p>Owing to their success, there are implementations of quasi-Newton methods in almost all programming languages. The <a href="NAG_Numerical_Library" title="wikilink">NAG Library</a> contains several routines<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> for minimizing or maximizing a function<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> which use quasi-Newton algorithms.</p>

<p><a class="uri" href="Scipy" title="wikilink">Scipy</a>.optimize has fmin_bfgs.</p>

<p><a href="GNU_Octave" title="wikilink">GNU Octave</a> uses a form of BFGS in its 'fsolve' function, with <a href="trust_region" title="wikilink">trust region</a> extensions.</p>

<p>In MATLAB's <a href="Optimization_Toolbox" title="wikilink">Optimization Toolbox</a>, the <code>[http://www.mathworks.com/help/toolbox/optim/ug/fminunc.html fminunc]</code> function uses (among other methods) the <a class="uri" href="BFGS" title="wikilink">BFGS</a> Quasi-Newton method. Many of the <a href="http://www.mathworks.com/help/toolbox/optim/ug/brnoxzl.html">constrained methods</a> of the Optimization toolbox use <a class="uri" href="BFGS" title="wikilink">BFGS</a> and the variant <a class="uri" href="L-BFGS" title="wikilink">L-BFGS</a>. Many user-contributed quasi-Newton routines are available on MATLAB's <a href="http://www.mathworks.com/matlabcentral/fileexchange/?term=BFGS">file exchange</a>.</p>

<p><a class="uri" href="Mathematica" title="wikilink">Mathematica</a> includes <a href="http://reference.wolfram.com/mathematica/tutorial/UnconstrainedOptimizationQuasiNewtonMethods.html">quasi-Newton solvers</a>. <a href="R_(programming_language)" title="wikilink">R</a>'s <code>optim</code> general-purpose optimizer routine uses the <a class="uri" href="BFGS" title="wikilink">BFGS</a> method by using <code>method="BFGS"</code><cite><a href="http://finzi.psych.upenn.edu/R/library/stats/html/optim.html">1</a></cite>. In the <a class="uri" href="SciPy" title="wikilink">SciPy</a> extension to <a href="Python_(programming_language)" title="wikilink">Python</a>, the <a href="http://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.minimize.html"><code>scipy.optimize.minimize</code></a> function includes, among other methods, a <a class="uri" href="BFGS" title="wikilink">BFGS</a> implementation.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Newton's_method_in_optimization" title="wikilink">Newton's method in optimization</a></li>
<li><a href="Newton's_method" title="wikilink">Newton's method</a></li>
<li><a href="DFP_updating_formula" title="wikilink">DFP updating formula</a></li>
<li><a href="BFGS_method" title="wikilink">BFGS method</a></li>
</ul>

<p>:*<a href="Limited-memory_BFGS" title="wikilink">L-BFGS</a></p>

<p>:*<a href="Orthant-wise_limited-memory_quasi-Newton" title="wikilink">OWL-QN</a></p>
<ul>
<li><a href="SR1_formula" title="wikilink">SR1 formula</a></li>
<li><a href="Broyden's_Method" title="wikilink">Broyden's Method</a></li>
<li><a href="Quasi-Newton_Least_Squares_Method" title="wikilink">Quasi-Newton Least Squares Method</a></li>
</ul>
<h2 id="references">References</h2>
<h2 id="further-reading">Further reading</h2>
<ul>
<li>Bonnans, J. F., Gilbert, J.Ch., <a href="Claude_Lemaréchal" title="wikilink">Lemaréchal, C.</a> and Sagastizábal, C.A. (2006), <em>Numerical optimization, theoretical and numerical aspects.</em> Second edition. Springer. ISBN 978-3-540-35445-1.</li>
<li>William C. Davidon, <a href="http://www.cs.berkeley.edu/~jduchi/papers/Davidon91.pdf">VARIABLE METRIC METHOD FOR MINIMIZATION</a>, SIOPT Volume 1 Issue 1, Pages 1–17, 1991.</li>
<li>

<p>.</p></li>
<li>Nocedal, Jorge &amp; Wright, Stephen J. (1999). Numerical Optimization. Springer-Verlag. ISBN 0-387-98793-2.</li>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Optimization_algorithms_and_methods" title="wikilink">Category:Optimization algorithms and methods</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
</ol>
</section>
</body>
</html>
