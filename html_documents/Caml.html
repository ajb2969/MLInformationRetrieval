<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="573">Caml</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Caml</h1>
<style>
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
<style>
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
</body></html>
<body>
<hr/>

<p><strong>Caml</strong> (originally an acronym for <strong>C</strong>ategorical <strong>A</strong>bstract <strong>M</strong>achine <strong>L</strong>anguage) is a dialect of the <a href="ML_(programming_language)" title="wikilink">ML</a> <a href="programming_language" title="wikilink">programming language</a> family, developed at <a class="uri" href="INRIA" title="wikilink">INRIA</a> and formerly at <a href="École_Normale_Supérieure" title="wikilink">ENS</a>.</p>

<p>Like many descendants of ML, Caml is statically <a href="type_system" title="wikilink">typed</a>, <a href="eager_evaluation" title="wikilink">strictly evaluated</a>, and uses <a href="automatic_memory_management" title="wikilink">automatic memory management</a>.</p>

<p>The first Caml implementation in <a href="Lisp_(programming_language)" title="wikilink">Lisp</a> was nicknamed "Heavy CAML" because of its memory and CPU requirements relative to its successor Caml Light that was implemented in <a href="C_(programming_language)" title="wikilink">C</a> by <a href="Xavier_Leroy" title="wikilink">Xavier Leroy</a> and <a href="Damien_Doligez" title="wikilink">Damien Doligez</a>. In addition to a complete rewriting, <em>CAML Special Light</em> added a powerful (applicative) module system to the core language.</p>

<p>Currently, the main implementation of Caml is <a class="uri" href="OCaml" title="wikilink">OCaml</a>, which adds many new features to the language including an <a href="object-oriented_programming" title="wikilink">object layer</a>.</p>
<h2 id="examples">Examples</h2>

<p>In the following,  represents the OCaml prompt.</p>
<h3 id="hello-world">Hello World</h3>
<div class="sourceCode"><pre class="sourceCode OCaml"><code class="sourceCode ocaml">print_endline <span class="st">"Hello World!"</span>;;</code></pre></div>
<h3 id="factorial-function-recursion-and-purely-functional-programming">Factorial function (recursion and purely functional programming)</h3>

<p>Many mathematical functions, such as factorial, are most naturally represented in a purely functional form. The following recursive, purely functional Caml function implements factorial:</p>
<div class="sourceCode"><pre class="sourceCode OCaml"><code class="sourceCode ocaml"><span class="kw">let</span> <span class="kw">rec</span> fact n = <span class="kw">if</span> n=<span class="dv">0</span> <span class="kw">then</span> <span class="dv">1</span> <span class="kw">else</span> n * fact(n - <span class="dv">1</span>);;</code></pre></div>

<p>The function can be written equivalently using <a href="pattern_matching" title="wikilink">pattern matching</a>:</p>
<div class="sourceCode"><pre class="sourceCode OCaml"><code class="sourceCode ocaml"><span class="kw">let</span> <span class="kw">rec</span> fact = <span class="kw">function</span>
  | <span class="dv">0</span> -&gt; <span class="dv">1</span>
  | n -&gt; n * fact(n - <span class="dv">1</span>);;</code></pre></div>

<p>This latter form is the mathematical definition of factorial as a recurrence relation.</p>

<p>Note that the compiler inferred the type of this function to be , meaning that this function maps ints onto ints. For example, 12! is:</p>
<div class="sourceCode"><pre class="sourceCode OCaml"><code class="sourceCode ocaml"> # fact <span class="dv">12</span>;;
 - : <span class="dt">int</span> = <span class="dv">479001600</span></code></pre></div>
<h3 id="numerical-derivative-higher-order-functions">Numerical derivative (higher-order functions)</h3>

<p>Since OCaml is a <a href="functional_programming_language" title="wikilink">functional programming language</a>, it is easy to create and pass around functions in OCaml programs. This capability has an enormous number of applications. Calculating the numerical derivative of a function is one such application. The following Caml function  computes the numerical derivative of a given function  at a given point :</p>
<div class="sourceCode"><pre class="sourceCode OCaml"><code class="sourceCode ocaml"><span class="kw">let</span> d delta f x =
  (f (x +. delta) -. f (x -. delta)) /. (<span class="fl">2.</span> *. delta);;</code></pre></div>

<p>This function requires a small value . A good choice for delta is the cube root of the <a href="machine_epsilon" title="wikilink">machine epsilon</a>.</p>

<p>The type of the function  indicates that it maps a  onto another function with the type . This allows us to partially apply arguments. This functional style is known as <a class="uri" href="currying" title="wikilink">currying</a>. In this case, it is useful to partially apply the first argument  to , to obtain a more specialised function:</p>
<div class="sourceCode"><pre class="sourceCode OCaml"><code class="sourceCode ocaml"># <span class="kw">let</span> d = d (sqrt epsilon_float);;
<span class="kw">val</span> d : (float -&gt; float) -&gt; float -&gt; float = &lt;<span class="kw">fun</span>&gt;
<!--<span class="kw"-->fun</code></pre></div></body>&gt;

<p>Note that the inferred type indicates that the replacement  is expecting a function with the type  as its first argument. We can compute a numerical approximation to the derivative of 

<math display="inline" id="Caml:0">
 <semantics>
  <mrow>
   <msup>
    <mi>x</mi>
    <mn>3</mn>
   </msup>
   <mo>-</mo>
   <mi>x</mi>
   <mo>-</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <cn type="integer">3</cn>
    </apply>
    <ci>x</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{3}-x-1
  </annotation>
 </semantics>
</math>

 at 

<math display="inline" id="Caml:1">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>=</mo>
   <mn>3</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>x</ci>
    <cn type="integer">3</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x=3
  </annotation>
 </semantics>
</math>

 with:</p>
<div class="sourceCode"><pre class="sourceCode OCaml"><code class="sourceCode ocaml"># d (<span class="kw">fun</span> x -&gt; x *. x *. x -. x -. <span class="fl">1.</span>) <span class="fl">3.</span>;;
- : float = <span class="fl">26.</span></code></pre></div>

<p>The correct answer is 

<math display="inline" id="Caml:2">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>f</mi>
     <mo>′</mo>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mn>3</mn>
     <msup>
      <mi>x</mi>
      <mn>2</mn>
     </msup>
    </mrow>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
   <mo>→</mo>
   <mrow>
    <msup>
     <mi>f</mi>
     <mo>′</mo>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>3</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mn>27</mn>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
   <mo>=</mo>
   <mn>26</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>f</ci>
       <ci>normal-′</ci>
      </apply>
      <ci>x</ci>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <cn type="integer">3</cn>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>x</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>f</ci>
       <ci>normal-′</ci>
      </apply>
      <cn type="integer">3</cn>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <minus></minus>
      <cn type="integer">27</cn>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="integer">26</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f^{\prime}(x)=3x^{2}-1\rightarrow f^{\prime}(3)=27-1=26
  </annotation>
 </semantics>
</math>

.</p>

<p>The function  is called a "higher-order function" because it accepts another function () as an argument.</p>

<p>The concepts of curried and higher-order functions are clearly useful in mathematical programs. In fact, these concepts are equally applicable to most other forms of programming and can be used to factor code much more aggressively, resulting in shorter programs and fewer bugs.</p>
<h3 id="discrete-wavelet-transform-pattern-matching">Discrete wavelet transform (pattern matching)</h3>

<p>The 1D <a href="Haar_wavelet" title="wikilink">Haar wavelet</a> <a href="discrete_wavelet_transform" title="wikilink">transform</a> of an <a class="uri" href="integer" title="wikilink">integer</a>-power-of-two-length list of numbers can be implemented very succinctly in Caml and is an excellent example of the use of pattern matching over lists, taking pairs of elements ( and ) off the front and storing their sums and differences on the lists  and , respectively:</p>
<div class="sourceCode"><pre class="sourceCode OCaml"><code class="sourceCode ocaml"># <span class="kw">let</span> haar l =
   <span class="kw">let</span> <span class="kw">rec</span> aux l s d = 
     <span class="kw">match</span> l, s, d <span class="kw">with</span>
       [s], [], d -&gt; s :: d
     | [], s, d -&gt; aux s [] d
     | h1 :: h2 :: t, s, d -&gt; aux t (h1 + h2 :: s) (h1 - h2 :: d)
     | _ -&gt; invalid_arg <span class="st">"haar"</span> 
     <span class="kw">in</span> aux l [] [];;
<span class="kw">val</span> haar : <span class="dt">int</span> <span class="dt">list</span> -&gt; <span class="dt">int</span> <span class="dt">list</span> = &lt;<span class="kw">fun</span>&gt;
<!--<span class="kw"-->fun</code></pre></div>&gt;

<p>For example:</p>
<div class="sourceCode"><pre class="sourceCode OCaml"><code class="sourceCode ocaml">  # haar [<span class="dv">1</span>; <span class="dv">2</span>; <span class="dv">3</span>; <span class="dv">4</span>; <span class="dv">-4</span>; <span class="dv">-3</span>; <span class="dv">-2</span>; <span class="dv">-1</span>];;
   - : <span class="dt">int</span> <span class="dt">list</span> = [<span class="dv">0</span>; <span class="dv">20</span>; <span class="dv">4</span>; <span class="dv">4</span>; <span class="dv">-1</span>; <span class="dv">-1</span>; <span class="dv">-1</span>; <span class="dv">-1</span>]</code></pre></div>

<p>Pattern matching allows complicated transformations to be represented clearly and succinctly. Moreover, the OCaml compiler turns pattern matches into very efficient code, at times resulting in programs that are shorter and faster than equivalent code written with a case statement(Cardelli 1984, p. 210.).</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Categorical_abstract_machine" title="wikilink">Categorical abstract machine</a></li>
<li><a href="F_Sharp_(programming_language)" title="wikilink">F#</a>, an OCaml-like language for the <a href=".NET_Framework" title="wikilink">.NET Framework</a></li>
<li><a class="uri" href="OCaml" title="wikilink">OCaml</a></li>
<li><a href="Standard_ML" title="wikilink">Standard ML</a></li>
</ul>
<h2 id="references">References</h2>

<p>Cardelli, Luca (1984). <a href="http://dx.doi.org/10.1145/800055.802037">Compiling a functional language</a> <em>ACM Symposium on LISP and functional programming</em>, Association of Computer Machinery.</p>
<h2 id="external-links">External links</h2>
<ul>
<li>

<p>Caml language family</p></li>
</ul>
<h3 id="books">Books</h3>
<ul>
<li><a href="http://pauillac.inria.fr/cousineau-mauny/main.html">The Functional Approach to Programming with Caml</a> by Guy Cousineau and Michel Mauny.</li>
</ul>

<p>"</p>

<p><a href="Category:ML_programming_language_family" title="wikilink">Category:ML programming language family</a> <a href="Category:Programming_languages_created_in_1985" title="wikilink">Category:Programming languages created in 1985</a></p>


