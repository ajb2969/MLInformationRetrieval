<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="774">Nelderâ€“Mead method</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Nelderâ€“Mead method</h1>
<hr/>

<p>{| class="infobox bordered" style="width: 22em; text-align: left; font-size: 95%;" |- |  |- |  <em>'Nelderâ€“Mead simplex search over the <a href="Rosenbrock_function" title="wikilink">Rosenbrock banana function</a> <strong>(above)</strong> and <a href="Himmelblau's_function" title="wikilink">Himmelblau's function</a></em>' (below)<br/>
|- |}</p>
<dl>
<dd><em>See <a href="simplex_algorithm" title="wikilink">simplex algorithm</a> for <a href="George_B._Dantzig" title="wikilink">Dantzig's</a> algorithm for the problem of <a href="linear_programming" title="wikilink">linear optimization</a>.</em>
</dd>
</dl>

<p>The <strong>Nelderâ€“Mead method</strong> or <strong>downhill simplex method</strong> or <strong>amoeba method</strong> is a commonly applied <a href="numerical_method" title="wikilink">numerical method</a> used to find the minimum or maximum of an <a href="objective_function" title="wikilink">objective function</a> in a many-dimensional space. It is applied to nonlinear <a href="Optimization_(mathematics)" title="wikilink">optimization</a> problems for which derivatives may not be known. However, the Nelderâ€“Mead technique is a <a class="uri" href="heuristic" title="wikilink">heuristic</a> search method that can converge to non-stationary points<ref name="PM"></ref></p>
<ul>
<li></li>
<li>

<p>(algorithm summary online).</p></li>
</ul>

<p> on problems that can be solved by alternative methods.<ref name="YKL"></ref></p>
<ul>
<li>Yu, Wen Ci. 1979. â€œPositive basis and a class of direct search techniquesâ€. <em>Scientia Sinica</em> [<em>Zhongguo Kexue</em>]: 53â€”68.</li>
<li>Yu, Wen Ci. 1979. â€œThe convergent property of the simplex evolutionary techniqueâ€. <em>Scientia Sinica</em> [<em>Zhongguo Kexue</em>]: 69â€“77.</li>
<li></li>
<li></li>
</ul>

<p></p>

<p>The Nelderâ€“Mead technique was proposed by <a href="John_Nelder" title="wikilink">John Nelder</a> &amp; Roger Mead (1965).<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>
<h2 id="overview">Overview</h2>

<p>The method uses the concept of a <a class="uri" href="simplex" title="wikilink">simplex</a>, which is a special <a class="uri" href="polytope" title="wikilink">polytope</a> of <em>n</em>Â +Â 1 vertices in <em>n</em> dimensions. Examples of simplices include a line segment on a line, a triangle on a plane, a <a class="uri" href="tetrahedron" title="wikilink">tetrahedron</a> in three-dimensional space and so forth.</p>

<p>The method approximates a local optimum of a problem with <em>n</em> variables when the objective function varies smoothly and is <a class="uri" href="unimodal" title="wikilink">unimodal</a>.</p>

<p>For example, a suspension bridge engineer has to choose how thick each strut, cable, and pier must be. These elements are interdependent, but it is not easy to visualize the impact of changing any specific element. Simulation of such complicated structures is often extremely computationally expensive to run, possibly taking upwards of hours per execution. An engineer may therefore prefer the Nelder-Mead method as it requires fewer evaluations per iteration than other optimization methods.</p>

<p>Nelderâ€“Mead in <em>n</em> dimensions maintains a set of <em>n+1</em> test points arranged as a <a class="uri" href="simplex" title="wikilink">simplex</a>. It then extrapolates the behavior of the objective function measured at each test point, in order to find a new test point and to replace one of the old test points with the new one, and so the technique progresses. The simplest approach is to replace the worst point with a point reflected through the <a class="uri" href="centroid" title="wikilink">centroid</a> of the remaining <em>n</em> points. If this point is better than the best current point, then we can try stretching exponentially out along this line. On the other hand, if this new point isn't much better than the previous value, then we are stepping across a valley, so we shrink the simplex towards a better point. An intuitive explanation of the algorithm is presented in <ref name="NR"></ref></p>
<ul>
<li></li>
</ul>

<p></p>
<blockquote>

<p>The downhill simplex method now takes a series of steps, most steps just moving the point of the simplex where the function is largest (â€œhighest pointâ€) through the opposite face of the simplex to a lower point. These steps are called reflections, and they are constructed to conserve the volume of the simplex (and hence maintain its nondegeneracy). When it can do so, the method expands the simplex in one or another direction to take larger steps. When it reaches a â€œvalley floor,â€ the method contracts itself in the transverse direction and tries to ooze down the valley. If there is a situation where the simplex is trying to â€œpass through the eye of a needle,â€ it contracts itself in all directions, pulling itself in around its lowest (best) point.</p>
</blockquote>

<p>Unlike modern optimization methods, the Nelderâ€“Mead heuristic can converge to a non-stationary point unless the problem satisfies stronger conditions than are necessary for modern methods.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> Modern improvements over the Nelderâ€“Mead heuristic have been known since 1979.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>

<p>Many variations exist depending on the actual nature of the problem being solved. A common variant uses a constant-size, small simplex that roughly follows the gradient direction (which gives <a href="Gradient_descent" title="wikilink">steepest descent</a>). Visualize a small triangle on an elevation map flip-flopping its way down a valley to a local bottom. This method is also known as the Flexible Polyhedron Method. This, however, tends to perform poorly against the method described in this article because it makes small, unnecessary steps in areas of little interest.</p>
<h2 id="one-possible-variation-of-the-nm-algorithm">One possible variation of the NM algorithm</h2>

<p>We are trying to minimize the function 

<math display="inline" id="Nelderâ€“Mead_method:0">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>ğ•©</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>ğ•©</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(\mathbb{x})
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Nelderâ€“Mead_method:1">
 <semantics>
  <mrow>
   <mi>ğ•©</mi>
   <mo>âˆˆ</mo>
   <msup>
    <mi>â„</mi>
    <mi>n</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>ğ•©</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>â„</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{x}\in\mathbb{R}^{n}
  </annotation>
 </semantics>
</math>

. Our current test points are 

<math display="inline" id="Nelderâ€“Mead_method:2">
 <semantics>
  <mrow>
   <msub>
    <mi>ğ•©</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">â€¦</mi>
   <mo>,</mo>
   <msub>
    <mi>ğ•©</mi>
    <mrow>
     <mi>n</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ğ•©</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-â€¦</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ğ•©</ci>
     <apply>
      <plus></plus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{x}_{1},\ldots,\mathbb{x}_{n+1}
  </annotation>
 </semantics>
</math>

.</p>
<ul>
<li><strong>1. Order</strong> according to the values at the vertices:</li>
</ul>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Nelderâ€“Mead_method:3">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mtext>ğ±</mtext>
      <mn>1</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>â‰¤</mo>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mtext>ğ±</mtext>
      <mn>2</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>â‰¤</mo>
   <mi mathvariant="normal">â‹¯</mi>
   <mo>â‰¤</mo>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mtext>ğ±</mtext>
      <mrow>
       <mi>n</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <apply>
      <times></times>
      <ci>f</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <mtext>x</mtext>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <mtext>x</mtext>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <ci>normal-â‹¯</ci>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>f</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <mtext>x</mtext>
       <apply>
        <plus></plus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(\textbf{x}_{1})\leq f(\textbf{x}_{2})\leq\cdots\leq f(\textbf{x}_{n+1})
  </annotation>
 </semantics>
</math>



</dd>
</dl>
</dd>
</dl>
<ul>
<li><strong>2.</strong> Calculate 

<math display="inline" id="Nelderâ€“Mead_method:4">
 <semantics>
  <msub>
   <mtext>ğ±</mtext>
   <mi>o</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <mtext>x</mtext>
    <ci>o</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textbf{x}_{o}
  </annotation>
 </semantics>
</math>

, the <a class="uri" href="centroid" title="wikilink">centroid</a> of all points except 

<math display="inline" id="Nelderâ€“Mead_method:5">
 <semantics>
  <msub>
   <mtext>ğ±</mtext>
   <mrow>
    <mi>n</mi>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <mtext>x</mtext>
    <apply>
     <plus></plus>
     <ci>n</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textbf{x}_{n+1}
  </annotation>
 </semantics>
</math>

.</li>
</ul>
<ul>
<li><strong>3. Reflection</strong></li>
</ul>
<dl>
<dd><dl>
<dd>Compute reflected point 

<math display="inline" id="Nelderâ€“Mead_method:6">
 <semantics>
  <mrow>
   <msub>
    <mtext>ğ±</mtext>
    <mi>r</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mtext>ğ±</mtext>
     <mi>o</mi>
    </msub>
    <mo>+</mo>
    <mrow>
     <mi>Î±</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mtext>ğ±</mtext>
        <mi>o</mi>
       </msub>
       <mo>-</mo>
       <msub>
        <mtext>ğ±</mtext>
        <mrow>
         <mi>n</mi>
         <mo>+</mo>
         <mn>1</mn>
        </mrow>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <mtext>x</mtext>
     <ci>r</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <mtext>x</mtext>
      <ci>o</ci>
     </apply>
     <apply>
      <times></times>
      <ci>Î±</ci>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <mtext>x</mtext>
        <ci>o</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <mtext>x</mtext>
        <apply>
         <plus></plus>
         <ci>n</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textbf{x}_{r}=\textbf{x}_{o}+\alpha(\textbf{x}_{o}-\textbf{x}_{n+1})
  </annotation>
 </semantics>
</math>


</dd>
<dd>If the reflected point is better than the second worst, but not better than the best, i.e.

<math display="block" id="Nelderâ€“Mead_method:7">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mtext>ğ±</mtext>
      <mn>1</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>â‰¤</mo>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mtext>ğ±</mtext>
      <mi>r</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo><</mo>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mtext>ğ±</mtext>
      <mi>n</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <apply>
      <times></times>
      <ci>f</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <mtext>x</mtext>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <mtext>x</mtext>
       <ci>r</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <lt></lt>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>f</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <mtext>x</mtext>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(\textbf{x}_{1})\leq f(\textbf{x}_{r})<f(\textbf{x}_{n})
  </annotation>
 </semantics>
</math>

,
</dd>
<dd>then obtain a new simplex by replacing the worst point 

<math display="inline" id="Nelderâ€“Mead_method:8">
 <semantics>
  <msub>
   <mtext>ğ±</mtext>
   <mrow>
    <mi>n</mi>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <mtext>x</mtext>
    <apply>
     <plus></plus>
     <ci>n</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textbf{x}_{n+1}
  </annotation>
 </semantics>
</math>


 with the reflected point 

<math display="inline" id="Nelderâ€“Mead_method:9">
 <semantics>
  <msub>
   <mtext>ğ±</mtext>
   <mi>r</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <mtext>x</mtext>
    <ci>r</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textbf{x}_{r}
  </annotation>
 </semantics>
</math>

, and go to step 1.
</dd>
</dl>
</dd>
</dl>
<ul>
<li><strong>4. Expansion</strong></li>
</ul>
<dl>
<dd><dl>
<dd>If the reflected point is the best point so far, 

<math display="inline" id="Nelderâ€“Mead_method:10">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mtext>ğ±</mtext>
       <mi>r</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo><</mo>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mtext>ğ±</mtext>
       <mn>1</mn>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <times></times>
     <ci>f</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <mtext>x</mtext>
      <ci>r</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>f</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <mtext>x</mtext>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(\textbf{x}_{r})<f(\textbf{x}_{1}),
  </annotation>
 </semantics>
</math>


</dd>
<dd>then compute the expanded point 

<math display="inline" id="Nelderâ€“Mead_method:11">
 <semantics>
  <mrow>
   <msub>
    <mtext>ğ±</mtext>
    <mi>e</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mtext>ğ±</mtext>
     <mi>o</mi>
    </msub>
    <mo>+</mo>
    <mrow>
     <mi>Î³</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mtext>ğ±</mtext>
        <mi>o</mi>
       </msub>
       <mo>-</mo>
       <msub>
        <mtext>ğ±</mtext>
        <mrow>
         <mi>n</mi>
         <mo>+</mo>
         <mn>1</mn>
        </mrow>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <mtext>x</mtext>
     <ci>e</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <mtext>x</mtext>
      <ci>o</ci>
     </apply>
     <apply>
      <times></times>
      <ci>Î³</ci>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <mtext>x</mtext>
        <ci>o</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <mtext>x</mtext>
        <apply>
         <plus></plus>
         <ci>n</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textbf{x}_{e}=\textbf{x}_{o}+\gamma(\textbf{x}_{o}-\textbf{x}_{n+1})
  </annotation>
 </semantics>
</math>


<dl>
<dd>If the expanded point is better than the reflected point, 

<math display="inline" id="Nelderâ€“Mead_method:12">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mtext>ğ±</mtext>
      <mi>e</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo><</mo>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mtext>ğ±</mtext>
      <mi>r</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <times></times>
     <ci>f</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <mtext>x</mtext>
      <ci>e</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>f</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <mtext>x</mtext>
      <ci>r</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(\textbf{x}_{e})<f(\textbf{x}_{r})
  </annotation>
 </semantics>
</math>


</dd>
<dd>then obtain a new simplex by replacing the worst point 

<math display="inline" id="Nelderâ€“Mead_method:13">
 <semantics>
  <msub>
   <mtext>ğ±</mtext>
   <mrow>
    <mi>n</mi>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <mtext>x</mtext>
    <apply>
     <plus></plus>
     <ci>n</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textbf{x}_{n+1}
  </annotation>
 </semantics>
</math>


 with the expanded point 

<math display="inline" id="Nelderâ€“Mead_method:14">
 <semantics>
  <msub>
   <mtext>ğ±</mtext>
   <mi>e</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <mtext>x</mtext>
    <ci>e</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textbf{x}_{e}
  </annotation>
 </semantics>
</math>

, and go to step 1.
</dd>
<dd>Else obtain a new simplex by replacing the worst point 

<math display="inline" id="Nelderâ€“Mead_method:15">
 <semantics>
  <msub>
   <mtext>ğ±</mtext>
   <mrow>
    <mi>n</mi>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <mtext>x</mtext>
    <apply>
     <plus></plus>
     <ci>n</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textbf{x}_{n+1}
  </annotation>
 </semantics>
</math>

 with the reflected point 

<math display="inline" id="Nelderâ€“Mead_method:16">
 <semantics>
  <msub>
   <mtext>ğ±</mtext>
   <mi>r</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <mtext>x</mtext>
    <ci>r</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textbf{x}_{r}
  </annotation>
 </semantics>
</math>

, and go to step 1.
</dd>
</dl>
</dd>
<dd>Else (i.e. reflected point is not better than second worst) continue at step 5.
</dd>
</dl>
</dd>
</dl>
<ul>
<li><strong>5. Contraction</strong></li>
</ul>
<dl>
<dd><dl>
<dd>Here, it is certain that 

<math display="inline" id="Nelderâ€“Mead_method:17">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mtext>ğ±</mtext>
      <mi>r</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>â‰¥</mo>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mtext>ğ±</mtext>
      <mi>n</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <times></times>
     <ci>f</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <mtext>x</mtext>
      <ci>r</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>f</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <mtext>x</mtext>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(\textbf{x}_{r})\geq f(\textbf{x}_{n})
  </annotation>
 </semantics>
</math>


</dd>
<dd>Compute contracted point 

<math display="inline" id="Nelderâ€“Mead_method:18">
 <semantics>
  <mrow>
   <msub>
    <mtext>ğ±</mtext>
    <mi>c</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mtext>ğ±</mtext>
     <mi>o</mi>
    </msub>
    <mo>+</mo>
    <mrow>
     <mi>Ï</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mtext>ğ±</mtext>
        <mi>o</mi>
       </msub>
       <mo>-</mo>
       <msub>
        <mtext>ğ±</mtext>
        <mrow>
         <mi>n</mi>
         <mo>+</mo>
         <mn>1</mn>
        </mrow>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <mtext>x</mtext>
     <ci>c</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <mtext>x</mtext>
      <ci>o</ci>
     </apply>
     <apply>
      <times></times>
      <ci>Ï</ci>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <mtext>x</mtext>
        <ci>o</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <mtext>x</mtext>
        <apply>
         <plus></plus>
         <ci>n</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textbf{x}_{c}=\textbf{x}_{o}+\rho(\textbf{x}_{o}-\textbf{x}_{n+1})
  </annotation>
 </semantics>
</math>



<dl>
<dd>If the contracted point is better than the worst point, i.e. 

<math display="inline" id="Nelderâ€“Mead_method:19">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mtext>ğ±</mtext>
      <mi>c</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo><</mo>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mtext>ğ±</mtext>
      <mrow>
       <mi>n</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <times></times>
     <ci>f</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <mtext>x</mtext>
      <ci>c</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>f</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <mtext>x</mtext>
      <apply>
       <plus></plus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(\textbf{x}_{c})<f(\textbf{x}_{n+1})
  </annotation>
 </semantics>
</math>


</dd>
<dd>then obtain a new simplex by replacing the worst point 

<math display="inline" id="Nelderâ€“Mead_method:20">
 <semantics>
  <msub>
   <mtext>ğ±</mtext>
   <mrow>
    <mi>n</mi>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <mtext>x</mtext>
    <apply>
     <plus></plus>
     <ci>n</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textbf{x}_{n+1}
  </annotation>
 </semantics>
</math>

 with the contracted point 

<math display="inline" id="Nelderâ€“Mead_method:21">
 <semantics>
  <msub>
   <mtext>ğ±</mtext>
   <mi>c</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <mtext>x</mtext>
    <ci>c</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textbf{x}_{c}
  </annotation>
 </semantics>
</math>

, and go to step 1.
</dd>
</dl>
</dd>
<dd>Else go to step 6.
</dd>
</dl>
</dd>
</dl>
<ul>
<li><strong>6. Reduction</strong></li>
</ul>
<dl>
<dd><dl>
<dd>For all but the best point, replace the point with
</dd>
<dd>

<math display="inline" id="Nelderâ€“Mead_method:22">
 <semantics>
  <mrow>
   <msub>
    <mtext>ğ±</mtext>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mtext>ğ±</mtext>
     <mn>1</mn>
    </msub>
    <mo>+</mo>
    <mrow>
     <mi>Ïƒ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mtext>ğ±</mtext>
        <mi>i</mi>
       </msub>
       <mo>-</mo>
       <msub>
        <mtext>ğ±</mtext>
        <mn>1</mn>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mtext>for all i</mtext>
    </mrow>
   </mrow>
   <mo>âˆˆ</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mn>2</mn>
    <mo>,</mo>
    <mi mathvariant="normal">â€¦</mi>
    <mo>,</mo>
    <mrow>
     <mi>n</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <mtext>x</mtext>
      <ci>i</ci>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <mtext>x</mtext>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <times></times>
       <ci>Ïƒ</ci>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <mtext>x</mtext>
         <ci>i</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <mtext>x</mtext>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <mtext>for all i</mtext>
      </apply>
     </apply>
    </apply>
    <apply>
     <in></in>
     <share href="#.cmml">
     </share>
     <set>
      <cn type="integer">2</cn>
      <ci>normal-â€¦</ci>
      <apply>
       <plus></plus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </set>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textbf{x}_{i}=\textbf{x}_{1}+\sigma(\textbf{x}_{i}-\textbf{x}_{1})\text{ for %
all i }\in\{2,\dots,n+1\}
  </annotation>
 </semantics>
</math>

. go to step 1.
</dd>
</dl>
</dd>
</dl>

<p><strong>Note</strong>

<math display="block" id="Nelderâ€“Mead_method:23">
 <semantics>
  <mi>Î±</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Î±</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Nelderâ€“Mead_method:24">
 <semantics>
  <mi>Î³</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Î³</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gamma
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Nelderâ€“Mead_method:25">
 <semantics>
  <mi>Ï</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Ï</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Nelderâ€“Mead_method:26">
 <semantics>
  <mi>Ïƒ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Ïƒ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma
  </annotation>
 </semantics>
</math>

 are respectively the reflection, the expansion, the contraction and the shrink coefficient. Standard values are 

<math display="inline" id="Nelderâ€“Mead_method:27">
 <semantics>
  <mrow>
   <mi>Î±</mi>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>Î±</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha=1
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Nelderâ€“Mead_method:28">
 <semantics>
  <mrow>
   <mi>Î³</mi>
   <mo>=</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>Î³</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gamma=2
  </annotation>
 </semantics>
</math>


, 

<math display="inline" id="Nelderâ€“Mead_method:29">
 <semantics>
  <mrow>
   <mi>Ï</mi>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <mrow>
     <mn>1</mn>
     <mo>/</mo>
     <mn>2</mn>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>Ï</ci>
    <apply>
     <minus></minus>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho=-1/2
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Nelderâ€“Mead_method:30">
 <semantics>
  <mrow>
   <mi>Ïƒ</mi>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mo>/</mo>
    <mn>2</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>Ïƒ</ci>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma=1/2
  </annotation>
 </semantics>
</math>

.</p>

<p>For the <strong>reflection</strong>, since 

<math display="inline" id="Nelderâ€“Mead_method:31">
 <semantics>
  <msub>
   <mtext>ğ±</mtext>
   <mrow>
    <mi>n</mi>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <mtext>x</mtext>
    <apply>
     <plus></plus>
     <ci>n</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textbf{x}_{n+1}
  </annotation>
 </semantics>
</math>

 is the vertex with the higher associated value among the vertices, we can expect to find a lower value at the reflection of 

<math display="inline" id="Nelderâ€“Mead_method:32">
 <semantics>
  <msub>
   <mtext>ğ±</mtext>
   <mrow>
    <mi>n</mi>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <mtext>x</mtext>
    <apply>
     <plus></plus>
     <ci>n</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textbf{x}_{n+1}
  </annotation>
 </semantics>
</math>

 in the opposite face formed by all vertices point 

<math display="inline" id="Nelderâ€“Mead_method:33">
 <semantics>
  <msub>
   <mtext>ğ±</mtext>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <mtext>x</mtext>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textbf{x}_{i}
  </annotation>
 </semantics>
</math>


 except 

<math display="inline" id="Nelderâ€“Mead_method:34">
 <semantics>
  <msub>
   <mtext>ğ±</mtext>
   <mrow>
    <mi>n</mi>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <mtext>x</mtext>
    <apply>
     <plus></plus>
     <ci>n</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textbf{x}_{n+1}
  </annotation>
 </semantics>
</math>

.</p>

<p>For the <strong>expansion</strong>, if the reflection point 

<math display="inline" id="Nelderâ€“Mead_method:35">
 <semantics>
  <msub>
   <mtext>ğ±</mtext>
   <mi>r</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <mtext>x</mtext>
    <ci>r</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textbf{x}_{r}
  </annotation>
 </semantics>
</math>

 is the new minimum along the vertices we can expect to find interesting values along the direction from 

<math display="inline" id="Nelderâ€“Mead_method:36">
 <semantics>
  <msub>
   <mtext>ğ±</mtext>
   <mi>o</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <mtext>x</mtext>
    <ci>o</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textbf{x}_{o}
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Nelderâ€“Mead_method:37">
 <semantics>
  <msub>
   <mtext>ğ±</mtext>
   <mi>r</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <mtext>x</mtext>
    <ci>r</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textbf{x}_{r}
  </annotation>
 </semantics>
</math>

.</p>

<p>Concerning the <strong>contraction</strong>: If 

<math display="inline" id="Nelderâ€“Mead_method:38">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mtext>ğ±</mtext>
      <mi>r</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>></mo>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mtext>ğ±</mtext>
      <mi>n</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <apply>
     <times></times>
     <ci>f</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <mtext>x</mtext>
      <ci>r</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>f</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <mtext>x</mtext>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(\textbf{x}_{r})>f(\textbf{x}_{n})
  </annotation>
 </semantics>
</math>


 we can expect that a better value will be inside the simplex formed by all the vertices 

<math display="inline" id="Nelderâ€“Mead_method:39">
 <semantics>
  <msub>
   <mtext>ğ±</mtext>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <mtext>x</mtext>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textbf{x}_{i}
  </annotation>
 </semantics>
</math>

.</p>

<p>Finally, the <strong>reduction</strong> handles the rare case that contracting away from the largest point increases 

<math display="inline" id="Nelderâ€“Mead_method:40">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

, something that cannot happen sufficiently close to a non-singular minimum. In that case we contract towards the lowest point in the expectation of finding a simpler landscape.</p>

<p>The initial simplex is important, indeed, a too small initial simplex can lead to a local search, consequently the NM can get more easily stuck. So this simplex should depend on the nature of the problem.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Derivative-free_optimization" title="wikilink">Derivative-free optimization</a></li>
<li><a class="uri" href="COBYLA" title="wikilink">COBYLA</a></li>
<li><a class="uri" href="NEWUOA" title="wikilink">NEWUOA</a></li>
<li><a class="uri" href="LINCOA" title="wikilink">LINCOA</a></li>
<li><a href="Nonlinear_conjugate_gradient_method" title="wikilink">Nonlinear conjugate gradient method</a></li>
<li><a href="Levenbergâ€“Marquardt_algorithm" title="wikilink">Levenbergâ€“Marquardt algorithm</a></li>
<li>Broydenâ€“Fletcherâ€“Goldfarbâ€“Shanno or <a href="BFGS_method" title="wikilink">BFGS method</a></li>
<li><a href="Differential_evolution" title="wikilink">Differential evolution</a></li>
<li><a href="Pattern_search_(optimization)" title="wikilink">Pattern search (optimization)</a></li>
<li><a class="uri" href="CMA-ES" title="wikilink">CMA-ES</a></li>
</ul>
<h2 id="references">References</h2>
<references>
</references>
<h3 id="further-reading">Further reading</h3>
<ul>
<li>Avriel, Mordecai (2003). <em>Nonlinear Programming: Analysis and Methods.</em> Dover Publishing. ISBN 0-486-43227-0.</li>
</ul>
<ul>
<li>Coope, I. D.; C.J. Price, 2002. â€œPositive bases in numerical optimizationâ€, <em>Computational Optimization &amp; Applications</em>, Vol. 21, No. 2, pp.Â 169â€“176, 2002.</li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.boomer.org/c/p3/c11/c1106.html">Nelderâ€“Mead (Simplex) Method</a></li>
<li><a href="http://www.brnt.eu/phd/node10.html#SECTION00622200000000000000">Nelderâ€“Mead (Downhill Simplex) explanation and visualization with the Rosenbrock banana function</a></li>
<li><a href="http://math.fullerton.edu/mathews/n2003/NelderMeadMod.html">Nelderâ€“Mead Search for a Minimum</a></li>
<li><a href="http://people.sc.fsu.edu/~burkardt/m_src/asa047/nelmin.m">John Burkardt: Nelderâ€“Mead code in Matlab</a> - note that a variation of the Nelderâ€“Mead method is also implemented by the Matlab function fminsearch.</li>
<li><a href="http://pricing-option.com/calibration_sabr.aspx">Nelderâ€“Mead online for the calibration of the SABR model</a> - Application in Finance.</li>
<li><a href="http://people.fsv.cvut.cz/~svobodal/sova/">SOVA 1.0 (freeware)</a> - Simplex Optimization for Various Applications</li>
<li><a href="http://www.berkutec.com">1</a> - HillStormer, a practical tool for nonlinear, multivariate and constrained Simplex Optimization by Nelder Mead.</li>
</ul>

<p>"</p>

<p><a href="Category:Optimization_algorithms_and_methods" title="wikilink">Category:Optimization algorithms and methods</a> <a href="Category:Operations_research" title="wikilink">Category:Operations research</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">â†©</a></li>
<li id="fn2"></li>
<li id="fn3"></li>
</ol>
</section>
</body>
</html>
