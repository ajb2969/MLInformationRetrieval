<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1189">Expected marginal seat revenue</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Expected marginal seat revenue</h1>
<hr/>

<p>EMSR stands for Expected Marginal Seat Revenue and is a very popular <a class="uri" href="heuristic" title="wikilink">heuristic</a> in <a href="Revenue_Management" title="wikilink">Revenue Management</a>. There are two versions: EMSRa<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> and EMSRb,<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> both of which were introduced by Belobaba. Both methods are for <em>n</em>-class, static, single-resource problems. Because the models are static some assumptions apply: classes are indexed in such a way that the fare for the highest class, 

<math display="inline" id="Expected_marginal_seat_revenue:0">
 <semantics>
  <msub>
   <mi>r</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>r</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r_{1}
  </annotation>
 </semantics>
</math>

, is higher than the fare for the next highest class, 

<math display="inline" id="Expected_marginal_seat_revenue:1">
 <semantics>
  <msub>
   <mi>r</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>r</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r_{2}
  </annotation>
 </semantics>
</math>

, so 

<math display="inline" id="Expected_marginal_seat_revenue:2">
 <semantics>
  <msub>
   <mi>r</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>r</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r_{1}
  </annotation>
 </semantics>
</math>

 &gt; 

<math display="inline" id="Expected_marginal_seat_revenue:3">
 <semantics>
  <msub>
   <mi>r</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>r</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r_{2}
  </annotation>
 </semantics>
</math>

 &gt; ... &gt; 

<math display="inline" id="Expected_marginal_seat_revenue:4">
 <semantics>
  <msub>
   <mi>r</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>r</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r_{n}
  </annotation>
 </semantics>
</math>

; demand arrives in a strict low to high order in stages that are indexed with <em>j</em> as well; demand for class <em>j</em> is distributed with cdf 

<math display="inline" id="Expected_marginal_seat_revenue:5">
 <semantics>
  <mrow>
   <msub>
    <mi>F</mi>
    <mi>j</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>F</ci>
     <ci>j</ci>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F_{j}(x)
  </annotation>
 </semantics>
</math>

. For simplicity it is also assumed that demand, capacity and the distributions are continuous, although it is not very difficult to drop this assumption.</p>
<h2 id="emsra">EMSRa</h2>

<p>EMSRa is the first version that Belobaba came up with. The idea behind the heuristic is to add the protection limits that are calculated by applying <a href="Littlewood's_rule" title="wikilink">Littlewood's rule</a> to successive classes. Suppose that we are in stage <em>j+1</em> and we want to calculate how much capacity we need to protect for stages <em>j, j-1,..., 1</em>. Then we are actually calculating protection limit 

<math display="inline" id="Expected_marginal_seat_revenue:6">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

<sub>j</sub>. To do so we consider every class in <em>j, j-1,..., 1</em> and compare that class, indexed with <em>k</em>, with <em>j+1</em> in isolation. For every combination of <em>k</em> and <em>j+1</em> we compute the protection level for that class with <a href="Littlewood's_rule" title="wikilink">Littlewood's rule</a>:</p>

<p>

<math display="block" id="Expected_marginal_seat_revenue:7">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>D</mi>
     <mi>k</mi>
    </msub>
    <mo>></mo>
    <msubsup>
     <mi>y</mi>
     <mi>k</mi>
     <mrow>
      <mi>j</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msubsup>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <msub>
     <mi>r</mi>
     <mrow>
      <mi>j</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <msub>
     <mi>r</mi>
     <mi>k</mi>
    </msub>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>D</ci>
      <ci>k</ci>
     </apply>
     <gt></gt>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <ci>k</ci>
      </apply>
      <apply>
       <plus></plus>
       <ci>j</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <divide></divide>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>r</ci>
      <apply>
       <plus></plus>
       <ci>j</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>r</ci>
      <ci>k</ci>
     </apply>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(D_{k}>y_{k}^{j+1})=\frac{r_{j+1}}{r_{k}}
  </annotation>
 </semantics>
</math>

</p>

<p>The idea of EMSRa then is to add all these protection limits to get the protection limit for 

<math display="inline" id="Expected_marginal_seat_revenue:8">
 <semantics>
  <msub>
   <mi>y</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>y</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{j}
  </annotation>
 </semantics>
</math>

.</p>

<p>

<math display="block" id="Expected_marginal_seat_revenue:9">
 <semantics>
  <mrow>
   <msub>
    <mi>y</mi>
    <mi>j</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>k</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>j</mi>
    </munderover>
    <msubsup>
     <mi>y</mi>
     <mi>k</mi>
     <mrow>
      <mi>j</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msubsup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <ci>j</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>k</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>j</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <ci>k</ci>
      </apply>
      <apply>
       <plus></plus>
       <ci>j</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{j}=\sum_{k=1}^{j}y_{k}^{j+1}
  </annotation>
 </semantics>
</math>

</p>

<p>However, there is a problem with this method because it does not take the statistical averaging effect into account. Suppose, for example, that classes <em>1</em> to <em>j</em> have the same fare <em>r</em>, then EMSRa will calculate the protection limit for 

<math display="inline" id="Expected_marginal_seat_revenue:10">
 <semantics>
  <msub>
   <mi>y</mi>
   <mrow>
    <mi>j</mi>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>y</ci>
    <apply>
     <plus></plus>
     <ci>j</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{j+1}
  </annotation>
 </semantics>
</math>

 with</p>

<p>

<math display="block" id="Expected_marginal_seat_revenue:11">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>D</mi>
     <mi>k</mi>
    </msub>
    <mo>></mo>
    <msubsup>
     <mi>y</mi>
     <mi>k</mi>
     <mrow>
      <mi>j</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msubsup>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <msub>
     <mi>r</mi>
     <mrow>
      <mi>j</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mi>r</mi>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>D</ci>
      <ci>k</ci>
     </apply>
     <gt></gt>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <ci>k</ci>
      </apply>
      <apply>
       <plus></plus>
       <ci>j</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <divide></divide>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>r</ci>
      <apply>
       <plus></plus>
       <ci>j</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>r</ci>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(D_{k}>y_{k}^{j+1})=\frac{r_{j+1}}{r}
  </annotation>
 </semantics>
</math>

</p>

<p>However, because the fare for all these classes is the same they should be aggregated. EMSRa will calculate protection limits that are too conservative. In other words, it will reserve too many seats for the higher fares, thereby rejecting too many low fare bookings. Although having equal fares is not realistic this will also happen if the difference between fares is small. Therefore EMSRb was invented.</p>
<h2 id="emsrb">EMSRb</h2>

<p>One of the most widely used RM heuristics is EMSRb. It is simple and produces under certain conditions close to optimal results. Belobaba reports studies in which both EMSRa and EMSRb were compared. He shows that EMSRb is consistently within 0.5 percent of the optimal solution, while EMSRa under certain conditions can deviate more than 1.5 percent from the optimal solution. However, with mixed order of arrival and frequent re-optimization both methods perform well.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> There is also study by Polt that shows mixed results.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>

<p>EMSRb is also based on an approximation that compares two classes, but it does take the statistical averaging effect into account. Instead of aggregating protection levels, as EMSRa does, it aggregates demand. Suppose we are again in stage 

<math display="inline" id="Expected_marginal_seat_revenue:12">
 <semantics>
  <mrow>
   <mi>j</mi>
   <mo>+</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>j</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   j+1
  </annotation>
 </semantics>
</math>

 and we want to calculate the protection limit 

<math display="inline" id="Expected_marginal_seat_revenue:13">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

<sub>j</sub>. Then first all future demand for classes <em>j, j-1,…, 1</em> is aggregated:</p>

<p>

<math display="block" id="Expected_marginal_seat_revenue:14">
 <semantics>
  <mrow>
   <msub>
    <mi>S</mi>
    <mi>j</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>k</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>j</mi>
    </munderover>
    <msub>
     <mi>D</mi>
     <mi>k</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>S</ci>
     <ci>j</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>k</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>j</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>D</ci>
      <ci>k</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{j}=\sum_{k=1}^{j}D_{k}
  </annotation>
 </semantics>
</math>

</p>

<p>and the weighted revenues are calculated:</p>

<p>

<math display="block" id="Expected_marginal_seat_revenue:15">
 <semantics>
  <mrow>
   <msub>
    <mover accent="true">
     <mi>r</mi>
     <mo>¯</mo>
    </mover>
    <mi>j</mi>
   </msub>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <mi>k</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>j</mi>
     </msubsup>
     <mrow>
      <msub>
       <mi>r</mi>
       <mi>k</mi>
      </msub>
      <mo>⋅</mo>
      <msub>
       <mi>D</mi>
       <mi>k</mi>
      </msub>
     </mrow>
    </mrow>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <mi>k</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>j</mi>
     </msubsup>
     <msub>
      <mi>D</mi>
      <mi>k</mi>
     </msub>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <ci>normal-¯</ci>
      <ci>r</ci>
     </apply>
     <ci>j</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>k</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>j</ci>
      </apply>
      <apply>
       <ci>normal-⋅</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>r</ci>
        <ci>k</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>D</ci>
        <ci>k</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>k</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>j</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>D</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \overline{r}_{j}=\frac{\sum_{k=1}^{j}r_{k}\cdot D_{k}}{\sum_{k=1}^{j}D_{k}}
  </annotation>
 </semantics>
</math>

</p>

<p>Then, again with Littlewood’s rule, the protection limit for classes <em>j</em> and higher is calculated such that:</p>

<p>

<math display="block" id="Expected_marginal_seat_revenue:16">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>S</mi>
     <mi>j</mi>
    </msub>
    <mo>></mo>
    <msub>
     <mi>y</mi>
     <mi>j</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <msub>
     <mi>r</mi>
     <mrow>
      <mi>j</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <msub>
     <mover accent="true">
      <mi>r</mi>
      <mo>¯</mo>
     </mover>
     <mi>j</mi>
    </msub>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>S</ci>
      <ci>j</ci>
     </apply>
     <gt></gt>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <ci>j</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <divide></divide>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>r</ci>
      <apply>
       <plus></plus>
       <ci>j</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <ci>normal-¯</ci>
       <ci>r</ci>
      </apply>
      <ci>j</ci>
     </apply>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(S_{j}>y_{j})=\frac{r_{j+1}}{\overline{r}_{j}}
  </annotation>
 </semantics>
</math>

</p>

<p>Rearranging gives:</p>

<p>{\overline{r}_j}) |cellpadding |border |border colour = #50C878 |background colour = #ECFCF4}}</p>

<p>

<math display="inline" id="Expected_marginal_seat_revenue:17">
 <semantics>
  <msubsup>
   <mi>y</mi>
   <mi>j</mi>
   <mo>⋆</mo>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <ci>j</ci>
    </apply>
    <ci>normal-⋆</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{j}^{\star}
  </annotation>
 </semantics>
</math>

 is the optimal protection limit, 

<math display="inline" id="Expected_marginal_seat_revenue:18">
 <semantics>
  <mrow>
   <msub>
    <mi>F</mi>
    <mi>j</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>F</ci>
     <ci>j</ci>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F_{j}(x)
  </annotation>
 </semantics>
</math>

 is a <a href="continuous_distribution" title="wikilink">continuous distribution</a> used to model the demand. Usually demand is considered to be independent and distributed normally with a mean and a variance . Using that the protection limits can be calculated as:</p>

<p>

<math display="block" id="Expected_marginal_seat_revenue:19">
 <semantics>
  <mrow>
   <msub>
    <mi>y</mi>
    <mi>j</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>μ</mi>
     <mi>j</mi>
    </msub>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>z</mi>
      <mi>α</mi>
     </msub>
     <mo>⋅</mo>
     <msub>
      <mi>σ</mi>
      <mi>j</mi>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <ci>j</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>μ</ci>
      <ci>j</ci>
     </apply>
     <apply>
      <ci>normal-⋅</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>z</ci>
       <ci>α</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>σ</ci>
       <ci>j</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{j}=\mu_{j}+z_{\alpha}\cdot\sigma_{j}
  </annotation>
 </semantics>
</math>

</p>

<p>with the mean and variance of the demand to come as 

<math display="inline" id="Expected_marginal_seat_revenue:20">
 <semantics>
  <mrow>
   <msub>
    <mi>μ</mi>
    <mi>j</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∑</mo>
     <mrow>
      <mi>k</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>j</mi>
    </msubsup>
    <msub>
     <mi>μ</mi>
     <mi>k</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>μ</ci>
     <ci>j</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>k</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>j</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>μ</ci>
      <ci>k</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu_{j}=\sum_{k=1}^{j}\mu_{k}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Expected_marginal_seat_revenue:21">
 <semantics>
  <mrow>
   <msubsup>
    <mi>σ</mi>
    <mi>j</mi>
    <mn>2</mn>
   </msubsup>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∑</mo>
     <mrow>
      <mi>k</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>j</mi>
    </msubsup>
    <msubsup>
     <mi>σ</mi>
     <mi>k</mi>
     <mn>2</mn>
    </msubsup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>σ</ci>
      <ci>j</ci>
     </apply>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>k</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>j</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>σ</ci>
       <ci>k</ci>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma_{j}^{2}=\sum_{k=1}^{j}\sigma_{k}^{2}
  </annotation>
 </semantics>
</math>

 respectively. 

<math display="inline" id="Expected_marginal_seat_revenue:22">
 <semantics>
  <msub>
   <mi>z</mi>
   <mi>α</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>z</ci>
    <ci>α</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z_{\alpha}
  </annotation>
 </semantics>
</math>

 is calculated with the inverse of the normal distribution 

<math display="inline" id="Expected_marginal_seat_revenue:23">
 <semantics>
  <mrow>
   <msub>
    <mi>z</mi>
    <mi>α</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>ϕ</mi>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mn>1</mn>
      <mo>-</mo>
      <mfrac>
       <msub>
        <mi>r</mi>
        <mrow>
         <mi>j</mi>
         <mo>+</mo>
         <mn>1</mn>
        </mrow>
       </msub>
       <msub>
        <mover accent="true">
         <mi>r</mi>
         <mo>¯</mo>
        </mover>
        <mi>j</mi>
       </msub>
      </mfrac>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>z</ci>
     <ci>α</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ϕ</ci>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
      <apply>
       <divide></divide>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>r</ci>
        <apply>
         <plus></plus>
         <ci>j</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <ci>normal-¯</ci>
         <ci>r</ci>
        </apply>
        <ci>j</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z_{\alpha}=\phi^{-1}(1-\frac{r_{j+1}}{\overline{r}_{j}})
  </annotation>
 </semantics>
</math>

. This is done for each j, giving the protection limit for every class.</p>
<h2 id="references">References</h2>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Yield_management" title="wikilink">Yield management</a></li>
<li><a href="Littlewood's_rule" title="wikilink">Littlewood's rule</a></li>
</ul>

<p>"</p>

<p><a class="uri" href="Category:Pricing" title="wikilink">Category:Pricing</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Belobaba, P. P., Air Travel Demand and Airline Seat Inventory Management. Flight Transportation Laboratory. Cambridge, MIT. PhD, 1987<a href="#fnref1">↩</a></li>
<li id="fn2">Belobaba, P. P., Optimal vs. heuristic methods for nested seat allocation. Presentation at ORSA/TIMS Joint National Meeting, 1992<a href="#fnref2">↩</a></li>
<li id="fn3">Belobaba, P. P., Optimal vs. heuristic methods for nested seat allocation. Presentation at ORSA/TIMS Joint National Meeting, 1992<a href="#fnref3">↩</a></li>
<li id="fn4">Polt, S., Back to the roots: New results on leg optimization. In 1999 AGIFORS Reservations and Yield Management Study Group Symposium, London, UK, 1999<a href="#fnref4">↩</a></li>
</ol>
</section>
</body>
</html>
