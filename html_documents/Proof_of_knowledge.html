<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="995">Proof of knowledge</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Proof of knowledge</h1>
<hr>In [[cryptography]], a '''proof of knowledge''' is an [[interactive proof system|interactive proof]] in which the prover succeeds 'convincing' a verifier that the prover knows s
<p>omething. What it means for a <a href="abstract_machine" title="wikilink">machine</a> to 'know something' is defined in terms of computation. A machine 'knows something', if this something can be computed, given the machine as an input. As the program of the prover does not necessarily spit out the knowledge itself (as is the case for <a href="zero-knowledge_proofs" title="wikilink">zero-knowledge proofs</a><a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a>) a machine with a different program, called the knowledge extractor is introduced to capture this idea. We are mostly interested in what can be proven by <a href="polynomial_time" title="wikilink">polynomial time</a> bounded machines. In this case the set of knowledge elements is limited to a set of witnesses of some <a href="formal_language" title="wikilink">language</a> in <a href="NP_(complexity)" title="wikilink">NP</a>.</p>

<p>Let 

<math display="inline" id="Proof_of_knowledge:0">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 be a language element of language 

<math display="inline" id="Proof_of_knowledge:1">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

 in NP, and 

<math display="inline" id="Proof_of_knowledge:2">
 <semantics>
  <mrow>
   <mi>W</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>W</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W(x)
  </annotation>
 </semantics>
</math>

 the set of witnesses for x that should be accepted in the proof. This allows us to define the following relation

<math display="block" id="Proof_of_knowledge:3">
 <semantics>
  <mrow>
   <mi>R</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>w</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>:</mo>
    <mrow>
     <mrow>
      <mi>x</mi>
      <mo>∈</mo>
      <mi>L</mi>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mi>w</mi>
      <mo>∈</mo>
      <mrow>
       <mi>W</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>R</ci>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <interval closure="open">
      <ci>x</ci>
      <ci>w</ci>
     </interval>
     <apply>
      <csymbol cd="ambiguous">formulae-sequence</csymbol>
      <apply>
       <in></in>
       <ci>x</ci>
       <ci>L</ci>
      </apply>
      <apply>
       <in></in>
       <ci>w</ci>
       <apply>
        <times></times>
        <ci>W</ci>
        <ci>x</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R=\{(x,w):x\in L,w\in W(x)\}
  </annotation>
 </semantics>
</math>

.</p>

<p>A proof of knowledge for relation 

<math display="inline" id="Proof_of_knowledge:4">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

 with knowledge error 

<math display="inline" id="Proof_of_knowledge:5">
 <semantics>
  <mi>κ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>κ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \kappa
  </annotation>
 </semantics>
</math>

 is a two party protocol with a prover 

<math display="inline" id="Proof_of_knowledge:6">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 and a verifier 

<math display="inline" id="Proof_of_knowledge:7">
 <semantics>
  <mi>V</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>V</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V
  </annotation>
 </semantics>
</math>

 with the following two properties:</p>
<ol>
<li><strong>Completeness</strong>: if 

<math display="inline" id="Proof_of_knowledge:8">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>w</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∈</mo>
   <mi>R</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <interval closure="open">
     <ci>x</ci>
     <ci>w</ci>
    </interval>
    <ci>R</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x,w)\in R
  </annotation>
 </semantics>
</math>


, the prover P who knows witness 

<math display="inline" id="Proof_of_knowledge:9">
 <semantics>
  <mi>w</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>w</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w
  </annotation>
 </semantics>
</math>

 for 

<math display="inline" id="Proof_of_knowledge:10">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 succeeds in convincing the verifier 

<math display="inline" id="Proof_of_knowledge:11">
 <semantics>
  <mi>V</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>V</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V
  </annotation>
 </semantics>
</math>

 of his knowledge. More formally

<math display="block" id="Proof_of_knowledge:12">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mi>r</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>w</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>↔</mo>
    <mi>V</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>→</mo>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <csymbol cd="unknown">r</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">P</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-,</ci>
      <csymbol cd="unknown">w</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-↔</ci>
     <csymbol cd="unknown">V</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-→</ci>
     <cn type="integer">1</cn>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <cn type="integer">1</cn>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Pr(P(x,w)\leftrightarrow V(x)\rightarrow 1)=1
  </annotation>
 </semantics>
</math>

</li>
<li><strong>Validity</strong>: Validity requires that the success probability of a knowledge extractor 

<math display="inline" id="Proof_of_knowledge:13">
 <semantics>
  <mi>E</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>E</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E
  </annotation>
 </semantics>
</math>


 in extracting the witness, given oracle access to a possibly malicious prover 

<math display="inline" id="Proof_of_knowledge:14">
 <semantics>
  <mover accent="true">
   <mi>P</mi>
   <mo stretchy="false">~</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-~</ci>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tilde{P}
  </annotation>
 </semantics>
</math>

, must be at least as high as the success probability of the prover 

<math display="inline" id="Proof_of_knowledge:15">
 <semantics>
  <mover accent="true">
   <mi>P</mi>
   <mo stretchy="false">~</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-~</ci>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tilde{P}
  </annotation>
 </semantics>
</math>

 in convincing the verifier. This Property guarantees that no prover that doesn't know the witness can succeed in convincing the verifier.</li>
</ol>
<h2 id="details-on-the-definition">Details on the definition</h2>

<p>This is a more rigorous definition of <strong>Validity</strong>:<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>

<p>Let 

<math display="inline" id="Proof_of_knowledge:16">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

 be a witness relation, 

<math display="inline" id="Proof_of_knowledge:17">
 <semantics>
  <mrow>
   <mi>W</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>W</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W(x)
  </annotation>
 </semantics>
</math>

 the set of all witnesses for public value 

<math display="inline" id="Proof_of_knowledge:18">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>


, and 

<math display="inline" id="Proof_of_knowledge:19">
 <semantics>
  <mi>κ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>κ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \kappa
  </annotation>
 </semantics>
</math>

 the knowledge error. A proof of knowledge is 

<math display="inline" id="Proof_of_knowledge:20">
 <semantics>
  <mi>κ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>κ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \kappa
  </annotation>
 </semantics>
</math>

-valid if there exists a polynomial-time machine 

<math display="inline" id="Proof_of_knowledge:21">
 <semantics>
  <mi>E</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>E</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E
  </annotation>
 </semantics>
</math>

, given oracle access to 

<math display="inline" id="Proof_of_knowledge:22">
 <semantics>
  <mover accent="true">
   <mi>P</mi>
   <mo stretchy="false">~</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-~</ci>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tilde{P}
  </annotation>
 </semantics>
</math>

, such that for every 

<math display="inline" id="Proof_of_knowledge:23">
 <semantics>
  <mover accent="true">
   <mi>P</mi>
   <mo stretchy="false">~</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-~</ci>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tilde{P}
  </annotation>
 </semantics>
</math>


, it is the case that 

<math display="inline" id="Proof_of_knowledge:24">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>E</mi>
     <mrow>
      <mover accent="true">
       <mi>P</mi>
       <mo stretchy="false">~</mo>
      </mover>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>∈</mo>
   <mrow>
    <mrow>
     <mi>W</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>∪</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mo>⊥</mo>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>E</ci>
      <apply>
       <times></times>
       <apply>
        <ci>normal-~</ci>
        <ci>P</ci>
       </apply>
       <ci>x</ci>
      </apply>
     </apply>
     <ci>x</ci>
    </apply>
    <apply>
     <union></union>
     <apply>
      <times></times>
      <ci>W</ci>
      <ci>x</ci>
     </apply>
     <set>
      <csymbol cd="latexml">bottom</csymbol>
     </set>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E^{\tilde{P}(x)}(x)\in W(x)\cup\{\bot\}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Proof_of_knowledge:25">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>Pr</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <msup>
         <mi>E</mi>
         <mrow>
          <mover accent="true">
           <mi>P</mi>
           <mo stretchy="false">~</mo>
          </mover>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>x</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
        </msup>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>x</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>∈</mo>
       <mrow>
        <mi>W</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>x</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>≥</mo>
    <mrow>
     <mrow>
      <mi>Pr</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mrow>
         <mover accent="true">
          <mi>P</mi>
          <mo stretchy="false">~</mo>
         </mover>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>x</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>↔</mo>
        <mrow>
         <mrow>
          <mi>V</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>x</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo>→</mo>
         <mn>1</mn>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>-</mo>
     <mrow>
      <mi>κ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <ci>Pr</ci>
     <apply>
      <in></in>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>E</ci>
        <apply>
         <times></times>
         <apply>
          <ci>normal-~</ci>
          <ci>P</ci>
         </apply>
         <ci>x</ci>
        </apply>
       </apply>
       <ci>x</ci>
      </apply>
      <apply>
       <times></times>
       <ci>W</ci>
       <ci>x</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <ci>Pr</ci>
      <apply>
       <ci>normal-↔</ci>
       <apply>
        <times></times>
        <apply>
         <ci>normal-~</ci>
         <ci>P</ci>
        </apply>
        <ci>x</ci>
       </apply>
       <apply>
        <ci>normal-→</ci>
        <apply>
         <times></times>
         <ci>V</ci>
         <ci>x</ci>
        </apply>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>κ</ci>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Pr(E^{\tilde{P}(x)}(x)\in W(x))\geq\Pr(\tilde{P}(x)\leftrightarrow V(x)%
\rightarrow 1)-\kappa(x).
  </annotation>
 </semantics>
</math>

</p>

<p>The result 

<math display="inline" id="Proof_of_knowledge:26">
 <semantics>
  <mo>⊥</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">bottom</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bot
  </annotation>
 </semantics>
</math>

 signifies that the Turing machine 

<math display="inline" id="Proof_of_knowledge:27">
 <semantics>
  <mi>E</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>E</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E
  </annotation>
 </semantics>
</math>

 did not come to a conclusion.</p>

<p>The knowledge error 

<math display="inline" id="Proof_of_knowledge:28">
 <semantics>
  <mrow>
   <mi>κ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>κ</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \kappa(x)
  </annotation>
 </semantics>
</math>


 denotes the probability that the verifier 

<math display="inline" id="Proof_of_knowledge:29">
 <semantics>
  <mi>V</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>V</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V
  </annotation>
 </semantics>
</math>

 might accept 

<math display="inline" id="Proof_of_knowledge:30">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

, even though the prover does in fact not know a witness 

<math display="inline" id="Proof_of_knowledge:31">
 <semantics>
  <mi>w</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>w</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w
  </annotation>
 </semantics>
</math>

. The knowledge extractor 

<math display="inline" id="Proof_of_knowledge:32">
 <semantics>
  <mi>E</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>E</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E
  </annotation>
 </semantics>
</math>

 is used to express what is meant by the knowledge of a <a href="Turing_machine" title="wikilink">Turing machine</a>. If 

<math display="inline" id="Proof_of_knowledge:33">
 <semantics>
  <mi>E</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>E</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E
  </annotation>
 </semantics>
</math>


 can extract 

<math display="inline" id="Proof_of_knowledge:34">
 <semantics>
  <mi>w</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>w</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w
  </annotation>
 </semantics>
</math>

 from 

<math display="inline" id="Proof_of_knowledge:35">
 <semantics>
  <mover accent="true">
   <mi>P</mi>
   <mo stretchy="false">~</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-~</ci>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tilde{P}
  </annotation>
 </semantics>
</math>

, we say that 

<math display="inline" id="Proof_of_knowledge:36">
 <semantics>
  <mover accent="true">
   <mi>P</mi>
   <mo stretchy="false">~</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-~</ci>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tilde{P}
  </annotation>
 </semantics>
</math>

 knows the value of 

<math display="inline" id="Proof_of_knowledge:37">
 <semantics>
  <mi>w</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>w</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w
  </annotation>
 </semantics>
</math>

.</p>

<p>This definition of the validity property is a combination of the validity and strong validity properties in.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> For small knowledge errors 

<math display="inline" id="Proof_of_knowledge:38">
 <semantics>
  <mrow>
   <mi>κ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>κ</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \kappa(x)
  </annotation>
 </semantics>
</math>


, such as e.g. 

<math display="inline" id="Proof_of_knowledge:39">
 <semantics>
  <msup>
   <mn>2</mn>
   <mrow>
    <mo>-</mo>
    <mn>80</mn>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <apply>
     <minus></minus>
     <cn type="integer">80</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{-80}
  </annotation>
 </semantics>
</math>

 or 

<math display="inline" id="Proof_of_knowledge:40">
 <semantics>
  <mrow>
   <mrow>
    <mn>1</mn>
    <mo>/</mo>
    <mi>poly</mi>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">|</mo>
     <mi>x</mi>
     <mo stretchy="false">|</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <ci>poly</ci>
    </apply>
    <apply>
     <abs></abs>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1/\mathrm{poly}(|x|)
  </annotation>
 </semantics>
</math>

 it can be seen as being stronger than the <strong><a href="Soundness_(interactive_proof)" title="wikilink">soundness</a></strong> of ordinary <a href="Interactive_proof_system" title="wikilink">interactive proofs</a>.</p>
<h2 id="relation-to-general-interactive-proofs">Relation to general interactive proofs</h2>

<p>In order to define a specific proof of knowledge, one need not only define the language, but also the witnesses the verifier should know. In some cases proving membership in a language may be easy, while computing a specific witness may be hard. This is best explained using an example:</p>

<p>Let 

<math display="inline" id="Proof_of_knowledge:41">
 <semantics>
  <mrow>
   <mo stretchy="false">⟨</mo>
   <mi>g</mi>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">delimited-⟨⟩</csymbol>
    <ci>g</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle g\rangle
  </annotation>
 </semantics>
</math>

 be a <a href="cyclic_group" title="wikilink">cyclic group</a> with generator 

<math display="inline" id="Proof_of_knowledge:42">
 <semantics>
  <mi>g</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>g</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g
  </annotation>
 </semantics>
</math>

 in which solving the <a href="discrete_logarithm" title="wikilink">discrete logarithm</a> problem is believed to be hard. Deciding membership of the language 

<math display="inline" id="Proof_of_knowledge:43">
 <semantics>
  <mrow>
   <mi>L</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mi>x</mi>
    <mo stretchy="false">|</mo>
    <mrow>
     <msup>
      <mi>g</mi>
      <mi>w</mi>
     </msup>
     <mo>=</mo>
     <mi>x</mi>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>L</ci>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <ci>x</ci>
     <apply>
      <eq></eq>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>g</ci>
       <ci>w</ci>
      </apply>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L=\{x|g^{w}=x\}
  </annotation>
 </semantics>
</math>


 is trivial, as every 

<math display="inline" id="Proof_of_knowledge:44">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 is in 

<math display="inline" id="Proof_of_knowledge:45">
 <semantics>
  <mrow>
   <mo stretchy="false">⟨</mo>
   <mi>g</mi>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">delimited-⟨⟩</csymbol>
    <ci>g</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle g\rangle
  </annotation>
 </semantics>
</math>

. However, finding the witness 

<math display="inline" id="Proof_of_knowledge:46">
 <semantics>
  <mi>w</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>w</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Proof_of_knowledge:47">
 <semantics>
  <mrow>
   <msup>
    <mi>g</mi>
    <mi>w</mi>
   </msup>
   <mo>=</mo>
   <mi>x</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>g</ci>
     <ci>w</ci>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g^{w}=x
  </annotation>
 </semantics>
</math>

 holds corresponds to solving the discrete logarithm problem.</p>
<h2 id="protocols">Protocols</h2>
<h3 id="schnorr-protocol">Schnorr protocol</h3>

<p>One of the simplest and frequently used proofs of knowledge, the <em>proof of knowledge of a <a href="discrete_logarithm" title="wikilink">discrete logarithm</a></em>, is due to Schnorr.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> The protocol is defined for a <a href="cyclic_group" title="wikilink">cyclic group</a> 

<math display="inline" id="Proof_of_knowledge:48">
 <semantics>
  <msub>
   <mi>G</mi>
   <mi>q</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>G</ci>
    <ci>q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G_{q}
  </annotation>
 </semantics>
</math>


 of order 

<math display="inline" id="Proof_of_knowledge:49">
 <semantics>
  <mi>q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q
  </annotation>
 </semantics>
</math>

 with generator 

<math display="inline" id="Proof_of_knowledge:50">
 <semantics>
  <mi>g</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>g</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g
  </annotation>
 </semantics>
</math>

.</p>

<p>In order to prove knowledge of 

<math display="inline" id="Proof_of_knowledge:51">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>log</mi>
     <mi>g</mi>
    </msub>
    <mi>y</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>x</ci>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <log></log>
      <ci>g</ci>
     </apply>
     <ci>y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x=\log_{g}y
  </annotation>
 </semantics>
</math>

, the prover interacts with the verifier as follows:</p>
<ol>
<li>In the first round the prover commits herself to randomness 

<math display="inline" id="Proof_of_knowledge:52">
 <semantics>
  <mi>r</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>r</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r
  </annotation>
 </semantics>
</math>

; therefore the first message 

<math display="inline" id="Proof_of_knowledge:53">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mo>=</mo>
   <msup>
    <mi>g</mi>
    <mi>r</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>t</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>g</ci>
     <ci>r</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t=g^{r}
  </annotation>
 </semantics>
</math>


 is also called <em>commitment</em>.</li>
<li>The verifier replies with a <em>challenge</em> 

<math display="inline" id="Proof_of_knowledge:54">
 <semantics>
  <mi>c</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>c</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c
  </annotation>
 </semantics>
</math>

 chosen at random.</li>
<li>After receiving 

<math display="inline" id="Proof_of_knowledge:55">
 <semantics>
  <mi>c</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>c</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c
  </annotation>
 </semantics>
</math>

, the prover sends the third and last message (the <em>response</em>) 

<math display="inline" id="Proof_of_knowledge:56">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mo>=</mo>
   <mrow>
    <mi>r</mi>
    <mo>+</mo>
    <mrow>
     <mi>c</mi>
     <mi>x</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>s</ci>
    <apply>
     <plus></plus>
     <ci>r</ci>
     <apply>
      <times></times>
      <ci>c</ci>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s=r+cx
  </annotation>
 </semantics>
</math>

.</li>
</ol>

<p>The verifier accepts, if 

<math display="inline" id="Proof_of_knowledge:57">
 <semantics>
  <mrow>
   <msup>
    <mi>g</mi>
    <mi>s</mi>
   </msup>
   <mo>=</mo>
   <mrow>
    <mi>t</mi>
    <msup>
     <mi>y</mi>
     <mi>c</mi>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>g</ci>
     <ci>s</ci>
    </apply>
    <apply>
     <times></times>
     <ci>t</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>y</ci>
      <ci>c</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g^{s}=ty^{c}
  </annotation>
 </semantics>
</math>

.</p>
<h3 id="sigma-protocols">Sigma protocols</h3>

<p>Protocols which have the above three-move structure (commitment, challenge and response) are called <em>sigma protocols</em>. The Greek letter 

<math display="inline" id="Proof_of_knowledge:58">
 <semantics>
  <mi mathvariant="normal">Σ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma
  </annotation>
 </semantics>
</math>


 visualizes the flow of the protocol. Sigma protocols exist for proving various statements, such as those pertaining to discrete logarithms. Using these proofs, the prover can not only prove the knowledge of the discrete logarithm, but also that the discrete logarithm is of a specific form. For instance, it is possible to prove that two logarithms of 

<math display="inline" id="Proof_of_knowledge:59">
 <semantics>
  <msub>
   <mi>y</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>y</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{1}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Proof_of_knowledge:60">
 <semantics>
  <msub>
   <mi>y</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>y</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{2}
  </annotation>
 </semantics>
</math>

 with respect to bases 

<math display="inline" id="Proof_of_knowledge:61">
 <semantics>
  <msub>
   <mi>g</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>g</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g_{1}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Proof_of_knowledge:62">
 <semantics>
  <msub>
   <mi>g</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>g</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g_{2}
  </annotation>
 </semantics>
</math>

 are equal or fulfill some other <a class="uri" href="linear" title="wikilink">linear</a> <a href="Relation_(mathematics)" title="wikilink">relation</a>. For <em>a</em> and <em>b</em> elements of 

<math display="inline" id="Proof_of_knowledge:63">
 <semantics>
  <msub>
   <mi>Z</mi>
   <mi>q</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>Z</ci>
    <ci>q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z_{q}
  </annotation>
 </semantics>
</math>


, we say that the prover proves knowledge of 

<math display="inline" id="Proof_of_knowledge:64">
 <semantics>
  <msub>
   <mi>x</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Proof_of_knowledge:65">
 <semantics>
  <msub>
   <mi>x</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{2}
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Proof_of_knowledge:66">
 <semantics>
  <mrow>
   <msub>
    <mi>y</mi>
    <mn>1</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mi>g</mi>
     <mn>1</mn>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
    </msubsup>
    <mo>∧</mo>
    <msub>
     <mi>y</mi>
     <mn>2</mn>
    </msub>
   </mrow>
   <mo>=</mo>
   <msubsup>
    <mi>g</mi>
    <mn>2</mn>
    <msub>
     <mi>x</mi>
     <mn>2</mn>
    </msub>
   </msubsup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <and></and>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>g</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>g</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{1}=g_{1}^{x_{1}}\land y_{2}=g_{2}^{x_{2}}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Proof_of_knowledge:67">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mn>2</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>a</mi>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
    </mrow>
    <mo>+</mo>
    <mi>b</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>a</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>b</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{2}=ax_{1}+b
  </annotation>
 </semantics>
</math>

. Equality corresponds to the special case where <em>a</em> = 1 and <em>b</em> = 0. As 

<math display="inline" id="Proof_of_knowledge:68">
 <semantics>
  <msub>
   <mi>x</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{2}
  </annotation>
 </semantics>
</math>


 can be <a href="trivial_(mathematics)" title="wikilink">trivially</a> computed from 

<math display="inline" id="Proof_of_knowledge:69">
 <semantics>
  <msub>
   <mi>x</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1}
  </annotation>
 </semantics>
</math>

 this is equivalent to proving knowledge of an <em>x</em> such that 

<math display="inline" id="Proof_of_knowledge:70">
 <semantics>
  <mrow>
   <msub>
    <mi>y</mi>
    <mn>1</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mi>g</mi>
     <mn>1</mn>
     <mi>x</mi>
    </msubsup>
    <mo>∧</mo>
    <msub>
     <mi>y</mi>
     <mn>2</mn>
    </msub>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <msubsup>
       <mi>g</mi>
       <mn>2</mn>
       <mi>a</mi>
      </msubsup>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>x</mi>
    </msup>
    <msubsup>
     <mi>g</mi>
     <mn>2</mn>
     <mi>b</mi>
    </msubsup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <and></and>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>g</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>x</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>g</ci>
         <cn type="integer">2</cn>
        </apply>
        <ci>a</ci>
       </apply>
       <ci>x</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>g</ci>
        <cn type="integer">2</cn>
       </apply>
       <ci>b</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{1}=g_{1}^{x}\land y_{2}={(g_{2}^{a})}^{x}g_{2}^{b}
  </annotation>
 </semantics>
</math>

.</p>

<p>This is the intuition behind the following notation, which is commonly used to express what exactly is proven by a proof of knowledge.</p>

<p>

<math display="block" id="Proof_of_knowledge:71">
 <semantics>
  <mrow>
   <mrow>
    <mi>P</mi>
    <mi>K</mi>
    <mrow>
     <mo stretchy="false">{</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>:</mo>
     <mrow>
      <msub>
       <mi>y</mi>
       <mn>1</mn>
      </msub>
      <mo>=</mo>
      <mrow>
       <msubsup>
        <mi>g</mi>
        <mn>1</mn>
        <mi>x</mi>
       </msubsup>
       <mo>∧</mo>
       <msub>
        <mi>y</mi>
        <mn>2</mn>
       </msub>
      </mrow>
      <mo>=</mo>
      <mrow>
       <msup>
        <mrow>
         <mo stretchy="false">(</mo>
         <msubsup>
          <mi>g</mi>
          <mn>2</mn>
          <mi>a</mi>
         </msubsup>
         <mo stretchy="false">)</mo>
        </mrow>
        <mi>x</mi>
       </msup>
       <msubsup>
        <mi>g</mi>
        <mn>2</mn>
        <mi>b</mi>
       </msubsup>
      </mrow>
     </mrow>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <ci>K</ci>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <ci>x</ci>
     <apply>
      <and></and>
      <apply>
       <eq></eq>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <and></and>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>g</ci>
          <cn type="integer">1</cn>
         </apply>
         <ci>x</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>y</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </apply>
      <apply>
       <eq></eq>
       <share href="#.cmml">
       </share>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>g</ci>
           <cn type="integer">2</cn>
          </apply>
          <ci>a</ci>
         </apply>
         <ci>x</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>g</ci>
          <cn type="integer">2</cn>
         </apply>
         <ci>b</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   PK\{(x):y_{1}=g_{1}^{x}\land y_{2}={(g_{2}^{a})}^{x}g_{2}^{b}\},
  </annotation>
 </semantics>
</math>

</p>

<p>states that the prover knows an <em>x</em> that fulfills the relation above.</p>
<h2 id="applications">Applications</h2>

<p>Proofs of knowledge are useful tool for the construction of identification protocols, and in their non-interactive variant, signature schemes. Such schemes are:</p>
<ul>
<li><a href="Schnorr_signature" title="wikilink">Schnorr signature</a></li>
</ul>

<p>They are also used in the construction of <a href="group_signature" title="wikilink">group signature</a> and <a href="digital_credential" title="wikilink">anonymous digital credential</a> systems.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Cryptographic_protocol" title="wikilink">Cryptographic protocol</a></li>
<li><a href="Zero-knowledge_proof" title="wikilink">Zero-knowledge proof</a></li>
<li><a href="interactive_proof_system" title="wikilink">interactive proof system</a></li>
<li><a href="Topics_in_cryptography" title="wikilink">Topics in cryptography</a></li>
<li><a href="Zero-knowledge_password_proof" title="wikilink">Zero-knowledge password proof</a></li>
<li><a href="Soundness_(interactive_proof)" title="wikilink">Soundness (interactive proof)</a></li>
</ul>
<h2 id="references">References</h2>
<references>
</references>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.cs.ut.ee/~lipmaa/crypto/link/zeroknowledge/pok.php">Helger Lipmaa's cryptology pointers</a></li>
</ul>

<p>"</p>

<p><a href="Category:Cryptographic_protocols" title="wikilink">Category:Cryptographic protocols</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="Shafi_Goldwasser" title="wikilink">Shafi Goldwasser</a>, <a href="Silvio_Micali" title="wikilink">Silvio Micali</a>, and <a href="Charles_Rackoff" title="wikilink">Charles Rackoff</a>. <a href="http://portal.acm.org/citation.cfm?id=63434">The knowledge complexity of interactive proof-systems</a>. <em>Proceedings of 17th Symposium on the Theory of Computation</em>, Providence, Rhode Island. 1985. Draft. <a href="http://theory.lcs.mit.edu/~cis/pubs/shafi/1985-stoc.pdf">Extended abstract</a><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="Mihir_Bellare" title="wikilink">Mihir Bellare</a>, Oded Goldreich: <a href="http://www-cse.ucsd.edu/~mihir/papers/pok.ps">On Defining Proofs of Knowledge</a>. <a class="uri" href="CRYPTO" title="wikilink">CRYPTO</a> 1992: 390–420<a href="#fnref2">↩</a></li>
<li id="fn3"></li>
<li id="fn4"><a href="Claus_P._Schnorr" title="wikilink">C P Schnorr</a>, Efficient identification and signatures for smart cards, in G Brassard, ed. Advances in Cryptology – <a class="uri" href="Crypto" title="wikilink">Crypto</a> '89, 239–252, <a class="uri" href="Springer-Verlag" title="wikilink">Springer-Verlag</a>, 1990. Lecture Notes in Computer Science, nr 435<a href="#fnref4">↩</a></li>
</ol>
</section>
</hr></body>
</html>
