<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1208">Drift plus penalty</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Drift plus penalty</h1>
<hr/>

<p>This article describes the drift-plus-penalty method for optimization of queueing networks and other stochastic systems.</p>
<h2 id="introduction-to-the-drift-plus-penalty-method">Introduction to the drift-plus-penalty method</h2>

<p>The drift-plus-penalty method refers to a technique for stabilizing a queueing network while also minimizing the time average of a network penalty function. It can be used to optimize performance objectives such as time average power, throughput, and throughput utility. <a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> <a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> In the special case when there is no penalty to be minimized, and when the goal is to design a stable routing policy in a multi-hop network, the method reduces to <a href="backpressure_routing" title="wikilink">backpressure routing</a>. <a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> <a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> The drift-plus-penalty method can also be used to minimize the time average of a <a href="stochastic_process" title="wikilink">stochastic process</a> subject to time average constraints on a collection of other stochastic processes. <a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> This is done by defining an appropriate set of <a href="#Virtual_queues" title="wikilink">virtual queues</a>. It can also be used to produce time averaged solutions to <a href="convex_optimization" title="wikilink">convex optimization</a> problems. <a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> <a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>
<h3 id="methodology">Methodology</h3>

<p>The drift-plus-penalty method applies to queueing systems that operate in discrete time with time slots t in {0, 1, 2, ...}. First, a non-negative function L(t) is defined as a scalar measure of the state of all queues at time t. The function L(t) is typically defined as the sum of the squares of all queue sizes at time t, and is called a <a href="Lyapunov_optimization" title="wikilink">Lyapunov function</a>. The <em>Lyapunov drift</em> is defined:</p>

<p>

<math display="inline" id="Drift_plus_penalty:0">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">Δ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>L</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>t</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mi>L</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>normal-Δ</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>L</ci>
      <apply>
       <plus></plus>
       <ci>t</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>L</ci>
      <ci>t</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta(t)=L(t+1)-L(t)
  </annotation>
 </semantics>
</math>

</p>

<p>Every slot t, the current queue state is observed and control actions are taken to greedily minimize a bound on the following <em>drift-plus-penalty expression</em>:</p>

<p>

<math display="inline" id="Drift_plus_penalty:1">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi mathvariant="normal">Δ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>V</mi>
     <mi>p</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <times></times>
     <ci>normal-Δ</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <times></times>
     <ci>V</ci>
     <ci>p</ci>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta(t)+Vp(t),
  </annotation>
 </semantics>
</math>

</p>

<p>where p(t) is the penalty function and V is a non-negative weight. The V parameter can be chosen to ensure the time average of p(t) is arbitrarily close to optimal, with a corresponding tradeoff in average queue size. Like <a href="backpressure_routing" title="wikilink">backpressure routing</a>, this method typically does not require knowledge of the probability distributions for job arrivals and network mobility.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></p>
<h3 id="origins-and-applications">Origins and applications</h3>

<p>When V=0, the method reduces to greedily minimizing the Lyapunov drift. This results in the <a href="backpressure_routing" title="wikilink">backpressure routing</a> algorithm originally developed by Tassiulas and Ephremides (also called the <em>max-weight algorithm</em>).<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> <a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> The Vp(t) term was added to the drift expression by Neely <a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> and Neely, Modiano, Li <a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> for stabilizing a network while also maximizing a throughput utility function. For this, the penalty p(t) was defined as -1 times a reward earned on slot t. This drift-plus-penalty technique was later used to minimize average power<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> and optimize other penalty and reward metrics.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a><a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a></p>

<p>The theory was developed primarily for optimizing communication networks, including wireless networks, ad-hoc mobile networks, and other computer networks. However, the mathematical techniques can be applied to optimization and control for other stochastic systems, including renewable energy allocation in <a href="Smart_grid" title="wikilink">smart power grids</a> <a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a> <a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a> <a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a> and <a href="inventory_control" title="wikilink">inventory control</a> for product assembly systems. <a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a></p>
<h2 id="how-it-works">How it works</h2>

<p>This section shows how to use the drift-plus-penalty method to minimize the time average of a function p(t) subject to time average constraints on a collection of other functions. The analysis below is based on the material in.<a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a></p>
<h3 id="the-stochastic-optimization-problem">The stochastic optimization problem</h3>

<p>Consider a discrete time system that evolves over normalized time slots t in {0, 1, 2, ...}. Define p(t) as a function whose time average should be minimized, called a <em>penalty function</em>. Suppose that minimization of the time average of p(t) must be done subject to time-average constraints on a collection of K other functions:</p>
<ul>
<li><math></math></li>
</ul>

<p>p(t) = \text{penalty function whose time average must be minimized} </p>
<ul>
<li><math></math></li>
</ul>

<p>y_1(t), y_2(t), ..., y_K(t) =\text{other functions whose time averages must be non-positive} </p>

<p>Every slot t, the network controller observes a new random event. It then makes a control action based on knowledge of this event. The values of p(t) and y_i(t) are determined as functions of the random event and the control action on slot t:</p>
<ul>
<li><math></math></li>
</ul>

<p>\omega(t) = \text{random event on slot t (assumed i.i.d. over slots)} </p>
<ul>
<li><math></math></li>
</ul>

<p>\alpha(t) = \text{control action on slot t (chosen after observing } \omega(t) \text{)} </p>
<ul>
<li><math></math></li>
</ul>

<p><code>p(t) = P(\alpha(t), \omega(t)) \text{ (a deterministic function of } \alpha(t), \omega(t) \text{)} </code></p>

<p></p>
<ul>
<li><math></math></li>
</ul>

<p><code>y_i(t) = Y_i(\alpha(t), \omega(t))   \text{ }  \forall i \in \{1, ..., K\} \text{ (deterministic functions of }  \alpha(t), \omega(t) \text{)} </code></p>

<p></p>

<p>The small case notation p(t), y_i(t) and upper case notation P(), Y_i() is used to distinguish the penalty values from the function that determines these values based on the random event and control action for slot t. The random event 

<math display="inline" id="Drift_plus_penalty:2">
 <semantics>
  <mrow>
   <mi>ω</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>ω</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \omega(t)
  </annotation>
 </semantics>
</math>

 is assumed to take values in some abstract set of events 

<math display="inline" id="Drift_plus_penalty:3">
 <semantics>
  <mi mathvariant="normal">Ω</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Ω</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Omega
  </annotation>
 </semantics>
</math>

. The control action 

<math display="inline" id="Drift_plus_penalty:4">
 <semantics>
  <mrow>
   <mi>α</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>α</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha(t)
  </annotation>
 </semantics>
</math>

 is assumed to be chosen within some abstract set 

<math display="inline" id="Drift_plus_penalty:5">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 that contains the control options. The sets 

<math display="inline" id="Drift_plus_penalty:6">
 <semantics>
  <mi mathvariant="normal">Ω</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Ω</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Omega
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Drift_plus_penalty:7">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 are arbitrary and can be either finite or infinite. For example, 

<math display="inline" id="Drift_plus_penalty:8">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 could be a finite list of abstract elements, an uncountably infinite (and possibly non-convex) collection of real-valued vectors, and so on. The functions P(), Y_i() are also arbitrary and do not require continuity or convexity assumptions.</p>

<p>As an example in the context of communication networks, the random event 

<math display="inline" id="Drift_plus_penalty:9">
 <semantics>
  <mrow>
   <mi>ω</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>ω</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \omega(t)
  </annotation>
 </semantics>
</math>

 can be a vector that contains the slot t arrival information for each node and the slot t channel state information for each link. The control action 

<math display="inline" id="Drift_plus_penalty:10">
 <semantics>
  <mrow>
   <mi>α</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>α</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha(t)
  </annotation>
 </semantics>
</math>

 can be a vector that contains the routing and transmission decisions for each node. The functions P() and Y_i() can represent power expenditures or throughputs associated with the control action and channel condition for slot t.</p>

<p>For simplicity of exposition, assume the P() and Y_i() functions are bounded. Further assume the random event process 

<math display="inline" id="Drift_plus_penalty:11">
 <semantics>
  <mrow>
   <mi>ω</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>ω</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \omega(t)
  </annotation>
 </semantics>
</math>

 is <a href="Independent_and_identically_distributed_random_variables" title="wikilink">independent and identically distributed (i.i.d.)</a> over slots t with some possibly unknown probability distribution. The goal is to design a policy for making control actions over time to solve the following problem:</p>

<p>

<math display="inline" id="Drift_plus_penalty:12">
 <semantics>
  <mrow>
   <mtext>Minimize:</mtext>
   <mrow>
    <msub>
     <mo>lim</mo>
     <mrow>
      <mi>t</mi>
      <mo>→</mo>
      <mi mathvariant="normal">∞</mi>
     </mrow>
    </msub>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <mi>t</mi>
     </mfrac>
     <mrow>
      <msubsup>
       <mo largeop="true" symmetric="true">∑</mo>
       <mrow>
        <mi>τ</mi>
        <mo>=</mo>
        <mn>0</mn>
       </mrow>
       <mrow>
        <mi>t</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msubsup>
      <mrow>
       <mi>E</mi>
       <mrow>
        <mo stretchy="false">[</mo>
        <mrow>
         <mi>p</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>τ</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo stretchy="false">]</mo>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <mtext>Minimize:</mtext>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <limit></limit>
      <apply>
       <ci>normal-→</ci>
       <ci>t</ci>
       <infinity></infinity>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <ci>t</ci>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <ci>τ</ci>
          <cn type="integer">0</cn>
         </apply>
        </apply>
        <apply>
         <minus></minus>
         <ci>t</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <times></times>
        <ci>E</ci>
        <apply>
         <csymbol cd="latexml">delimited-[]</csymbol>
         <apply>
          <times></times>
          <ci>p</ci>
          <ci>τ</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{Minimize: }\lim_{t\rightarrow\infty}\frac{1}{t}\sum_{\tau=0}^{t-1}E[p(%
\tau)]
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Drift_plus_penalty:13">
 <semantics>
  <mrow>
   <mrow>
    <mtext>Subject to:</mtext>
    <mrow>
     <msub>
      <mo>lim</mo>
      <mrow>
       <mi>t</mi>
       <mo>→</mo>
       <mi mathvariant="normal">∞</mi>
      </mrow>
     </msub>
     <mrow>
      <mfrac>
       <mn>1</mn>
       <mi>t</mi>
      </mfrac>
      <mrow>
       <msubsup>
        <mo largeop="true" symmetric="true">∑</mo>
        <mrow>
         <mi>τ</mi>
         <mo>=</mo>
         <mn>0</mn>
        </mrow>
        <mrow>
         <mi>t</mi>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
       </msubsup>
       <mrow>
        <mi>E</mi>
        <mrow>
         <mo stretchy="false">[</mo>
         <mrow>
          <msub>
           <mi>y</mi>
           <mi>i</mi>
          </msub>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>τ</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo stretchy="false">]</mo>
        </mrow>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mn>0</mn>
    <mrow></mrow>
    <mrow>
     <mo>∀</mo>
     <mi>i</mi>
    </mrow>
   </mrow>
   <mo>∈</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mn>1</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mi>K</mi>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <apply>
      <times></times>
      <mtext>Subject to:</mtext>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <limit></limit>
        <apply>
         <ci>normal-→</ci>
         <ci>t</ci>
         <infinity></infinity>
        </apply>
       </apply>
       <apply>
        <times></times>
        <apply>
         <divide></divide>
         <cn type="integer">1</cn>
         <ci>t</ci>
        </apply>
        <apply>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <sum></sum>
           <apply>
            <eq></eq>
            <ci>τ</ci>
            <cn type="integer">0</cn>
           </apply>
          </apply>
          <apply>
           <minus></minus>
           <ci>t</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
         <apply>
          <times></times>
          <ci>E</ci>
          <apply>
           <csymbol cd="latexml">delimited-[]</csymbol>
           <apply>
            <times></times>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <ci>y</ci>
             <ci>i</ci>
            </apply>
            <ci>τ</ci>
           </apply>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">0</cn>
      <mtext></mtext>
      <apply>
       <csymbol cd="latexml">for-all</csymbol>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <in></in>
     <share href="#.cmml">
     </share>
     <set>
      <cn type="integer">1</cn>
      <ci>normal-…</ci>
      <ci>K</ci>
     </set>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{Subject to: }\lim_{t\rightarrow\infty}\frac{1}{t}\sum_{\tau=0}^{t-1}E[y_%
{i}(\tau)]\leq 0\text{ }\forall i\in\{1,...,K\}
  </annotation>
 </semantics>
</math>

</p>

<p>It is assumed throughout that this problem is <em>feasible</em>. That is, it is assumed that there exists an algorithm that can satisfy all of the K desired constraints.</p>

<p>The above problem poses each constraint in the <em>standard form</em> of a time average expectation of an abstract process y_i(t) being non-positive. There is no loss of generality with this approach. For example, suppose one desires the time average expectation of some process a(t) to be less than or equal to a given constant c. Then a new penalty function y(t) = a(t) - c can be defined, and the desired constraint is equivalent to the time average expectation of y(t) being non-positive. Likewise, suppose there are two processes a(t) and b(t) and one desires the time average expectation of a(t) to be less than or equal to that of b(t). This constraint is written in standard form by defining a new penalty function y(t) = a(t) - b(t). The above problem seeks to <em>minimize</em> the time average of an abstract penalty function p(t). This can be used to <em>maximize</em> the time average of some desirable <em>reward function</em> r(t) by defining p(t) = -r(t).</p>
<h3 id="virtual-queues">Virtual queues</h3>

<p>For each constraint i in {1, ..., K}, define a <em>virtual queue</em> with dynamics over slots t in {0, 1, 2, ...} as follows:</p>

<p>

<math display="inline" id="Drift_plus_penalty:14">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>E</mi>
      <mi>q</mi>
      <mn>.1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow></mrow>
    <msub>
     <mi>Q</mi>
     <mi>i</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>t</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>max</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mrow>
       <msub>
        <mi>Q</mi>
        <mi>i</mi>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>t</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>+</mo>
      <mrow>
       <msub>
        <mi>y</mi>
        <mi>i</mi>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>t</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mn>0</mn>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <times></times>
      <ci>E</ci>
      <ci>q</ci>
      <cn type="float">.1</cn>
     </apply>
     <mtext></mtext>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Q</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <plus></plus>
      <ci>t</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <max></max>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Q</ci>
        <ci>i</ci>
       </apply>
       <ci>t</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <ci>i</ci>
       </apply>
       <ci>t</ci>
      </apply>
     </apply>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (Eq.1)\text{ }Q_{i}(t+1)=\max[Q_{i}(t)+y_{i}(t),0]
  </annotation>
 </semantics>
</math>

</p>

<p>Initialize Q_i(0)=0 for all i in {1, ..., K}. This update equation is identical to that of a <em>virtual</em> discrete time queue with backlog Q_i(t) and with y_i(t) being the difference between new arrivals and new service opportunities on slot t. Intuitively, stabilizing these virtual queues ensures the time averages of the constraint functions are less than or equal to zero, so the desired constraints are satisfied. To see this precisely, note that (Eq. 1) implies:</p>

<p>

<math display="inline" id="Drift_plus_penalty:15">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>Q</mi>
     <mi>i</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>t</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≥</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>Q</mi>
      <mi>i</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>y</mi>
      <mi>i</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Q</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <plus></plus>
      <ci>t</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Q</ci>
       <ci>i</ci>
      </apply>
      <ci>t</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <ci>i</ci>
      </apply>
      <ci>t</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q_{i}(t+1)\geq Q_{i}(t)+y_{i}(t)
  </annotation>
 </semantics>
</math>

</p>

<p>Therefore:</p>

<p>

<math display="inline" id="Drift_plus_penalty:16">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>y</mi>
     <mi>i</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>Q</mi>
      <mi>i</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>t</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <msub>
      <mi>Q</mi>
      <mi>i</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <ci>i</ci>
     </apply>
     <ci>t</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Q</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <plus></plus>
       <ci>t</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Q</ci>
       <ci>i</ci>
      </apply>
      <ci>t</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{i}(t)\leq Q_{i}(t+1)-Q_{i}(t)
  </annotation>
 </semantics>
</math>

</p>

<p>Summing the above over the first t slots and using the law of telescoping sums implies:</p>

<p>

<math display="inline" id="Drift_plus_penalty:17">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∑</mo>
     <mrow>
      <mi>τ</mi>
      <mo>=</mo>
      <mn>0</mn>
     </mrow>
     <mrow>
      <mi>t</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msubsup>
    <mrow>
     <msub>
      <mi>y</mi>
      <mi>i</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>τ</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>Q</mi>
      <mi>i</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <msub>
      <mi>Q</mi>
      <mi>i</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>0</mn>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>Q</mi>
     <mi>i</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>τ</ci>
         <cn type="integer">0</cn>
        </apply>
       </apply>
       <apply>
        <minus></minus>
        <ci>t</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <ci>i</ci>
       </apply>
       <ci>τ</ci>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Q</ci>
        <ci>i</ci>
       </apply>
       <ci>t</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Q</ci>
        <ci>i</ci>
       </apply>
       <cn type="integer">0</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Q</ci>
       <ci>i</ci>
      </apply>
      <ci>t</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{\tau=0}^{t-1}y_{i}(\tau)\leq Q_{i}(t)-Q_{i}(0)=Q_{i}(t)
  </annotation>
 </semantics>
</math>

</p>

<p>Dividing by t and taking expectations implies:</p>

<p>

<math display="inline" id="Drift_plus_penalty:18">
 <semantics>
  <mrow>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mi>t</mi>
    </mfrac>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <mi>τ</mi>
       <mo>=</mo>
       <mn>0</mn>
      </mrow>
      <mrow>
       <mi>t</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msubsup>
     <mrow>
      <mi>E</mi>
      <mrow>
       <mo stretchy="false">[</mo>
       <mrow>
        <msub>
         <mi>y</mi>
         <mi>i</mi>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>τ</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">]</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mfrac>
    <mrow>
     <mi>E</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mrow>
       <msub>
        <mi>Q</mi>
        <mi>i</mi>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>t</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mi>t</mi>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <ci>t</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>τ</ci>
         <cn type="integer">0</cn>
        </apply>
       </apply>
       <apply>
        <minus></minus>
        <ci>t</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>E</ci>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>y</ci>
          <ci>i</ci>
         </apply>
         <ci>τ</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <ci>E</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>Q</ci>
         <ci>i</ci>
        </apply>
        <ci>t</ci>
       </apply>
      </apply>
     </apply>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{1}{t}\sum_{\tau=0}^{t-1}E[y_{i}(\tau)]\leq\frac{E[Q_{i}(t)]}{t}
  </annotation>
 </semantics>
</math>

</p>

<p>Therefore, the desired constraints of the problem are satisfied whenever the following holds for all i in {1, ..., K}:</p>

<p>

<math display="inline" id="Drift_plus_penalty:19">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mo>lim</mo>
     <mrow>
      <mi>t</mi>
      <mo>→</mo>
      <mi mathvariant="normal">∞</mi>
     </mrow>
    </msub>
    <mfrac>
     <mrow>
      <mi>E</mi>
      <mrow>
       <mo stretchy="false">[</mo>
       <mrow>
        <msub>
         <mi>Q</mi>
         <mi>i</mi>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>t</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">]</mo>
      </mrow>
     </mrow>
     <mi>t</mi>
    </mfrac>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <limit></limit>
      <apply>
       <ci>normal-→</ci>
       <ci>t</ci>
       <infinity></infinity>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <ci>E</ci>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>Q</ci>
          <ci>i</ci>
         </apply>
         <ci>t</ci>
        </apply>
       </apply>
      </apply>
      <ci>t</ci>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lim_{t\rightarrow\infty}\frac{E[Q_{i}(t)]}{t}=0
  </annotation>
 </semantics>
</math>

</p>

<p>A queue Q_i(t) that satisfies the above limit equation is said to be <em>mean rate stable</em>.<a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a></p>
<h3 id="the-drift-plus-penalty-expression">The drift-plus-penalty expression</h3>

<p>To stabilize the queues, define the Lyapunov function L(t) as a measure of the total queue backlog on slot t:</p>

<p>

<math display="inline" id="Drift_plus_penalty:20">
 <semantics>
  <mrow>
   <mrow>
    <mi>L</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mn>2</mn>
    </mfrac>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>K</mi>
     </msubsup>
     <mrow>
      <msub>
       <mi>Q</mi>
       <mi>i</mi>
      </msub>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>t</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <mn>2</mn>
      </msup>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>L</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>K</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Q</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>t</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L(t)=\frac{1}{2}\sum_{i=1}^{K}Q_{i}(t)^{2}
  </annotation>
 </semantics>
</math>

</p>

<p>Squaring the queueing equation (Eq. 1) results in the following bound for each queue i in {1, ..., K}:</p>

<p>

<math display="inline" id="Drift_plus_penalty:21">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>Q</mi>
     <mi>i</mi>
    </msub>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>t</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mn>2</mn>
    </msup>
   </mrow>
   <mo>≤</mo>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <msub>
        <mi>Q</mi>
        <mi>i</mi>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>t</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>+</mo>
      <mrow>
       <msub>
        <mi>y</mi>
        <mi>i</mi>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>t</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mn>2</mn>
   </msup>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>Q</mi>
      <mi>i</mi>
     </msub>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mn>2</mn>
     </msup>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>y</mi>
      <mi>i</mi>
     </msub>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mn>2</mn>
     </msup>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mn>2</mn>
     <msub>
      <mi>Q</mi>
      <mi>i</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <msub>
      <mi>y</mi>
      <mi>i</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Q</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <plus></plus>
        <ci>t</ci>
        <cn type="integer">1</cn>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <plus></plus>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>Q</ci>
         <ci>i</ci>
        </apply>
        <ci>t</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>y</ci>
         <ci>i</ci>
        </apply>
        <ci>t</ci>
       </apply>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Q</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>t</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>t</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Q</ci>
        <ci>i</ci>
       </apply>
       <ci>t</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <ci>i</ci>
       </apply>
       <ci>t</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q_{i}(t+1)^{2}\leq(Q_{i}(t)+y_{i}(t))^{2}=Q_{i}(t)^{2}+y_{i}(t)^{2}+2Q_{i}(t)y%
_{i}(t)
  </annotation>
 </semantics>
</math>

</p>

<p>Therefore,</p>

<p>

<math display="inline" id="Drift_plus_penalty:22">
 <semantics>
  <mrow>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mn>2</mn>
    </mfrac>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>K</mi>
     </msubsup>
     <mrow>
      <msub>
       <mi>Q</mi>
       <mi>i</mi>
      </msub>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>t</mi>
         <mo>+</mo>
         <mn>1</mn>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mn>2</mn>
      </msup>
     </mrow>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <mn>2</mn>
     </mfrac>
     <mrow>
      <msubsup>
       <mo largeop="true" symmetric="true">∑</mo>
       <mrow>
        <mi>i</mi>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <mi>K</mi>
      </msubsup>
      <mrow>
       <msub>
        <mi>Q</mi>
        <mi>i</mi>
       </msub>
       <msup>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>t</mi>
         <mo stretchy="false">)</mo>
        </mrow>
        <mn>2</mn>
       </msup>
      </mrow>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <mn>2</mn>
     </mfrac>
     <mrow>
      <msubsup>
       <mo largeop="true" symmetric="true">∑</mo>
       <mrow>
        <mi>i</mi>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <mi>K</mi>
      </msubsup>
      <mrow>
       <msub>
        <mi>y</mi>
        <mi>i</mi>
       </msub>
       <msup>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>t</mi>
         <mo stretchy="false">)</mo>
        </mrow>
        <mn>2</mn>
       </msup>
      </mrow>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>K</mi>
     </msubsup>
     <mrow>
      <msub>
       <mi>Q</mi>
       <mi>i</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <msub>
       <mi>y</mi>
       <mi>i</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>K</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Q</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <plus></plus>
         <ci>t</ci>
         <cn type="integer">1</cn>
        </apply>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <ci>i</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>K</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>Q</ci>
         <ci>i</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>t</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <ci>i</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>K</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>y</ci>
         <ci>i</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>t</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>K</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Q</ci>
        <ci>i</ci>
       </apply>
       <ci>t</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <ci>i</ci>
       </apply>
       <ci>t</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{1}{2}\sum_{i=1}^{K}Q_{i}(t+1)^{2}\leq\frac{1}{2}\sum_{i=1}^{K}Q_{i}(t)^{%
2}+\frac{1}{2}\sum_{i=1}^{K}y_{i}(t)^{2}+\sum_{i=1}^{K}Q_{i}(t)y_{i}(t)
  </annotation>
 </semantics>
</math>

</p>

<p>It follows that</p>

<p>

<math display="inline" id="Drift_plus_penalty:23">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">Δ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>L</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>t</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mi>L</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <mn>2</mn>
     </mfrac>
     <mrow>
      <msubsup>
       <mo largeop="true" symmetric="true">∑</mo>
       <mrow>
        <mi>i</mi>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <mi>k</mi>
      </msubsup>
      <mrow>
       <msub>
        <mi>y</mi>
        <mi>i</mi>
       </msub>
       <msup>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>t</mi>
         <mo stretchy="false">)</mo>
        </mrow>
        <mn>2</mn>
       </msup>
      </mrow>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>K</mi>
     </msubsup>
     <mrow>
      <msub>
       <mi>Q</mi>
       <mi>i</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <msub>
       <mi>y</mi>
       <mi>i</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>normal-Δ</ci>
      <ci>t</ci>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>L</ci>
       <apply>
        <plus></plus>
        <ci>t</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>L</ci>
       <ci>t</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <sum></sum>
          <apply>
           <eq></eq>
           <ci>i</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
         <ci>k</ci>
        </apply>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>y</ci>
          <ci>i</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>t</ci>
          <cn type="integer">2</cn>
         </apply>
        </apply>
       </apply>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <ci>i</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>K</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>Q</ci>
         <ci>i</ci>
        </apply>
        <ci>t</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>y</ci>
         <ci>i</ci>
        </apply>
        <ci>t</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta(t)=L(t+1)-L(t)\leq\frac{1}{2}\sum_{i=1}^{k}y_{i}(t)^{2}+\sum_{i=1}^{K}Q%
_{i}(t)y_{i}(t)
  </annotation>
 </semantics>
</math>

</p>

<p>Now define B as a positive constant that upper bounds the first term on the right-hand-side of the above inequality. Such a constant exists because the y_i(t) values are bounded. Then:</p>

<p>

<math display="inline" id="Drift_plus_penalty:24">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">Δ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mi>B</mi>
    <mo>+</mo>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>K</mi>
     </msubsup>
     <mrow>
      <msub>
       <mi>Q</mi>
       <mi>i</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <msub>
       <mi>y</mi>
       <mi>i</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <times></times>
     <ci>normal-Δ</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <plus></plus>
     <ci>B</ci>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>K</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Q</ci>
        <ci>i</ci>
       </apply>
       <ci>t</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <ci>i</ci>
       </apply>
       <ci>t</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta(t)\leq B+\sum_{i=1}^{K}Q_{i}(t)y_{i}(t)
  </annotation>
 </semantics>
</math>

</p>

<p>Adding Vp(t) to both sides results in the following bound on the drift-plus-penalty expression:</p>

<p>

<math display="inline" id="Drift_plus_penalty:25">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>E</mi>
       <mi>q</mi>
       <mn>.2</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow></mrow>
     <mi mathvariant="normal">Δ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>V</mi>
     <mi>p</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mi>B</mi>
    <mo>+</mo>
    <mrow>
     <mi>V</mi>
     <mi>p</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>K</mi>
     </msubsup>
     <mrow>
      <msub>
       <mi>Q</mi>
       <mi>i</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <msub>
       <mi>y</mi>
       <mi>i</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <times></times>
       <ci>E</ci>
       <ci>q</ci>
       <cn type="float">.2</cn>
      </apply>
      <mtext></mtext>
      <ci>normal-Δ</ci>
      <ci>t</ci>
     </apply>
     <apply>
      <times></times>
      <ci>V</ci>
      <ci>p</ci>
      <ci>t</ci>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <ci>B</ci>
     <apply>
      <times></times>
      <ci>V</ci>
      <ci>p</ci>
      <ci>t</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>K</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Q</ci>
        <ci>i</ci>
       </apply>
       <ci>t</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <ci>i</ci>
       </apply>
       <ci>t</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (Eq.2)\text{ }\Delta(t)+Vp(t)\leq B+Vp(t)+\sum_{i=1}^{K}Q_{i}(t)y_{i}(t)
  </annotation>
 </semantics>
</math>

</p>

<p>The drift-plus-penalty algorithm (defined below) makes control actions every slot t that greedily minimize the right-hand-side of the above inequality. Intuitively, taking an action that minimizes the drift alone would be beneficial in terms of queue stability but would not minimize time average penalty. Taking an action that minimizes the penalty alone would not necessarily stabilize the queues. Thus, taking an action to minimize the weighted sum incorporates both objectives of queue stability and penalty minimization. The weight V can be tuned to place more or less emphasis on penalty minimization, which results in a performance tradeoff.<a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a></p>
<h3 id="drift-plus-penalty-algorithm">Drift-plus-penalty algorithm</h3>

<p>Let 

<math display="inline" id="Drift_plus_penalty:26">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 be the abstract set of all possible control actions. Every slot t, observe the random event and the current queue values:</p>

<p>

<math display="inline" id="Drift_plus_penalty:27">
 <semantics>
  <mrow>
   <mrow>
    <mtext>Observe:</mtext>
    <mi>ω</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mrow>
    <msub>
     <mi>Q</mi>
     <mn>1</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <mrow>
    <msub>
     <mi>Q</mi>
     <mi>K</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <times></times>
     <mtext>Observe:</mtext>
     <ci>ω</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Q</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>t</ci>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Q</ci>
      <ci>K</ci>
     </apply>
     <ci>t</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{Observe: }\omega(t),Q_{1}(t),...,Q_{K}(t)
  </annotation>
 </semantics>
</math>

</p>

<p>Given these observations for slot t, greedily choose a control action 

<math display="inline" id="Drift_plus_penalty:28">
 <semantics>
  <mrow>
   <mrow>
    <mi>α</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>∈</mo>
   <mi>A</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <times></times>
     <ci>α</ci>
     <ci>t</ci>
    </apply>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha(t)\in A
  </annotation>
 </semantics>
</math>

 to minimize the following expression (breaking ties arbitrarily):</p>

<p>

<math display="inline" id="Drift_plus_penalty:29">
 <semantics>
  <mrow>
   <mrow>
    <mi>V</mi>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>α</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mi>ω</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>+</mo>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∑</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>K</mi>
    </msubsup>
    <mrow>
     <msub>
      <mi>Q</mi>
      <mi>i</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <msub>
      <mi>Y</mi>
      <mi>i</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>α</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>t</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>,</mo>
      <mrow>
       <mi>ω</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>t</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <times></times>
     <ci>V</ci>
     <ci>P</ci>
     <interval closure="open">
      <apply>
       <times></times>
       <ci>α</ci>
       <ci>t</ci>
      </apply>
      <apply>
       <times></times>
       <ci>ω</ci>
       <ci>t</ci>
      </apply>
     </interval>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>K</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Q</ci>
       <ci>i</ci>
      </apply>
      <ci>t</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Y</ci>
       <ci>i</ci>
      </apply>
      <interval closure="open">
       <apply>
        <times></times>
        <ci>α</ci>
        <ci>t</ci>
       </apply>
       <apply>
        <times></times>
        <ci>ω</ci>
        <ci>t</ci>
       </apply>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   VP(\alpha(t),\omega(t))+\sum_{i=1}^{K}Q_{i}(t)Y_{i}(\alpha(t),\omega(t))
  </annotation>
 </semantics>
</math>

</p>

<p>Then update the queues for each i in {1, ..., K} according to (Eq. 1). Repeat this procedure for slot t+1.<a class="footnoteRef" href="#fn23" id="fnref23"><sup>23</sup></a></p>

<p>Note that the random event and queue backlogs observed on slot t act as given constants when selecting the control action for the slot t minimization. Thus, each slot involves a deterministic search for the minimizing control action over the set <em>A</em>. A key feature of this algorithm is that it does not require knowledge of the probability distribution of the random event process.</p>
<h3 id="approximate-scheduling">Approximate scheduling</h3>

<p>The above algorithm involves finding a minimum of a function over an abstract set <em>A</em>. In general cases, the minimum might not exist, or might be difficult to find. Thus, it is useful to assume the algorithm is implemented in an approximate manner as follows: Define <em>C</em> as a non-negative constant, and assume that for all slots t, the control action 

<math display="inline" id="Drift_plus_penalty:30">
 <semantics>
  <mrow>
   <mi>α</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>α</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha(t)
  </annotation>
 </semantics>
</math>

 is chosen in the set <em>A</em> to satisfy:</p>

<p>

<math display="inline" id="Drift_plus_penalty:31">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>V</mi>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>α</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>t</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>,</mo>
      <mrow>
       <mi>ω</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>t</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>K</mi>
     </msubsup>
     <mrow>
      <msub>
       <mi>Q</mi>
       <mi>i</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <msub>
       <mi>Y</mi>
       <mi>i</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>α</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>t</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>,</mo>
       <mrow>
        <mi>ω</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>t</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mi>C</mi>
    <mo>+</mo>
    <mrow>
     <msub>
      <mo>inf</mo>
      <mrow>
       <mi>α</mi>
       <mo>∈</mo>
       <mi>A</mi>
      </mrow>
     </msub>
     <mrow>
      <mo stretchy="false">[</mo>
      <mrow>
       <mrow>
        <mi>V</mi>
        <mi>P</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>α</mi>
         <mo>,</mo>
         <mrow>
          <mi>ω</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>t</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>+</mo>
       <mrow>
        <msubsup>
         <mo largeop="true" symmetric="true">∑</mo>
         <mrow>
          <mi>i</mi>
          <mo>=</mo>
          <mn>1</mn>
         </mrow>
         <mi>K</mi>
        </msubsup>
        <mrow>
         <msub>
          <mi>Q</mi>
          <mi>i</mi>
         </msub>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>t</mi>
          <mo stretchy="false">)</mo>
         </mrow>
         <msub>
          <mi>Y</mi>
          <mi>i</mi>
         </msub>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>α</mi>
          <mo>,</mo>
          <mrow>
           <mi>ω</mi>
           <mrow>
            <mo stretchy="false">(</mo>
            <mi>t</mi>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
      </mrow>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>V</ci>
      <ci>P</ci>
      <interval closure="open">
       <apply>
        <times></times>
        <ci>α</ci>
        <ci>t</ci>
       </apply>
       <apply>
        <times></times>
        <ci>ω</ci>
        <ci>t</ci>
       </apply>
      </interval>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>K</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Q</ci>
        <ci>i</ci>
       </apply>
       <ci>t</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Y</ci>
        <ci>i</ci>
       </apply>
       <interval closure="open">
        <apply>
         <times></times>
         <ci>α</ci>
         <ci>t</ci>
        </apply>
        <apply>
         <times></times>
         <ci>ω</ci>
         <ci>t</ci>
        </apply>
       </interval>
      </apply>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <ci>C</ci>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <csymbol cd="latexml">infimum</csymbol>
       <apply>
        <in></in>
        <ci>α</ci>
        <ci>A</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <plus></plus>
        <apply>
         <times></times>
         <ci>V</ci>
         <ci>P</ci>
         <interval closure="open">
          <ci>α</ci>
          <apply>
           <times></times>
           <ci>ω</ci>
           <ci>t</ci>
          </apply>
         </interval>
        </apply>
        <apply>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <sum></sum>
           <apply>
            <eq></eq>
            <ci>i</ci>
            <cn type="integer">1</cn>
           </apply>
          </apply>
          <ci>K</ci>
         </apply>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>Q</ci>
           <ci>i</ci>
          </apply>
          <ci>t</ci>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>Y</ci>
           <ci>i</ci>
          </apply>
          <interval closure="open">
           <ci>α</ci>
           <apply>
            <times></times>
            <ci>ω</ci>
            <ci>t</ci>
           </apply>
          </interval>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   VP(\alpha(t),\omega(t))+\sum_{i=1}^{K}Q_{i}(t)Y_{i}(\alpha(t),\omega(t))\leq C%
+\inf_{\alpha\in A}[VP(\alpha,\omega(t))+\sum_{i=1}^{K}Q_{i}(t)Y_{i}(\alpha,%
\omega(t))]
  </annotation>
 </semantics>
</math>

</p>

<p>Such a control action is called a <em>C-additive approximation</em>.<a class="footnoteRef" href="#fn24" id="fnref24"><sup>24</sup></a> The case <em>C</em> = 0 corresponds to exact minimization of the desired expression on every slot t.</p>
<h2 id="performance-analysis">Performance analysis</h2>

<p>This section shows the algorithm results in a time average penalty that is within O(1/V) of optimality, with a corresponding O(V) tradeoff in average queue size.<a class="footnoteRef" href="#fn25" id="fnref25"><sup>25</sup></a></p>
<h3 id="average-penalty-analysis">Average penalty analysis</h3>

<p>Define an <em>

<math display="inline" id="Drift_plus_penalty:32">
 <semantics>
  <mi>ω</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ω</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \omega
  </annotation>
 </semantics>
</math>

-only policy</em> to be a stationary and randomized policy for choosing the control action 

<math display="inline" id="Drift_plus_penalty:33">
 <semantics>
  <mrow>
   <mi>α</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>α</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha(t)
  </annotation>
 </semantics>
</math>

 based on the observed 

<math display="inline" id="Drift_plus_penalty:34">
 <semantics>
  <mrow>
   <mi>ω</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>ω</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \omega(t)
  </annotation>
 </semantics>
</math>

 only. That is, an 

<math display="inline" id="Drift_plus_penalty:35">
 <semantics>
  <mi>ω</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ω</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \omega
  </annotation>
 </semantics>
</math>

-only policy specifies, for each possible random event 

<math display="inline" id="Drift_plus_penalty:36">
 <semantics>
  <mrow>
   <mi>ω</mi>
   <mo>∈</mo>
   <mi mathvariant="normal">Ω</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>ω</ci>
    <ci>normal-Ω</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \omega\in\Omega
  </annotation>
 </semantics>
</math>

, a conditional probability distribution for selecting a control action 

<math display="inline" id="Drift_plus_penalty:37">
 <semantics>
  <mrow>
   <mrow>
    <mi>α</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>∈</mo>
   <mi>A</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <times></times>
     <ci>α</ci>
     <ci>t</ci>
    </apply>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha(t)\in A
  </annotation>
 </semantics>
</math>

 given that 

<math display="inline" id="Drift_plus_penalty:38">
 <semantics>
  <mrow>
   <mrow>
    <mi>ω</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>ω</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>ω</ci>
     <ci>t</ci>
    </apply>
    <ci>ω</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \omega(t)=\omega
  </annotation>
 </semantics>
</math>

. Such a policy makes decisions independent of current queue backlog. Assume there exists an 

<math display="inline" id="Drift_plus_penalty:39">
 <semantics>
  <mi>ω</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ω</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \omega
  </annotation>
 </semantics>
</math>

-only policy 

<math display="inline" id="Drift_plus_penalty:40">
 <semantics>
  <mrow>
   <msup>
    <mi>α</mi>
    <mo>*</mo>
   </msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>α</ci>
     <times></times>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha^{*}(t)
  </annotation>
 </semantics>
</math>

 that satisfies the following:</p>

<p>

<math display="inline" id="Drift_plus_penalty:41">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>E</mi>
      <mi>q</mi>
      <mn>.3</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow></mrow>
    <mi>E</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mi>P</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <msup>
         <mi>α</mi>
         <mo>*</mo>
        </msup>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>t</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>,</mo>
       <mrow>
        <mi>ω</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>t</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msup>
    <mi>p</mi>
    <mo>*</mo>
   </msup>
   <mo>=</mo>
   <mtext>optimal time average penalty for the problem</mtext>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <times></times>
       <ci>E</ci>
       <ci>q</ci>
       <cn type="float">.3</cn>
      </apply>
      <mtext></mtext>
      <ci>E</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <times></times>
        <ci>P</ci>
        <interval closure="open">
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>α</ci>
           <times></times>
          </apply>
          <ci>t</ci>
         </apply>
         <apply>
          <times></times>
          <ci>ω</ci>
          <ci>t</ci>
         </apply>
        </interval>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>p</ci>
      <times></times>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <mtext>optimal time average penalty for the problem</mtext>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (Eq.3)\text{ }E[P(\alpha^{*}(t),\omega(t))]=p^{*}=\text{ optimal time average %
penalty for the problem}
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Drift_plus_penalty:42">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>E</mi>
      <mi>q</mi>
      <mn>.4</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow></mrow>
    <mi>E</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <msub>
       <mi>Y</mi>
       <mi>i</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <msup>
         <mi>α</mi>
         <mo>*</mo>
        </msup>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>t</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>,</mo>
       <mrow>
        <mi>ω</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>t</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mn>0</mn>
    <mrow></mrow>
    <mrow>
     <mo>∀</mo>
     <mi>i</mi>
    </mrow>
   </mrow>
   <mo>∈</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mn>1</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mi>K</mi>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <apply>
      <times></times>
      <apply>
       <times></times>
       <ci>E</ci>
       <ci>q</ci>
       <cn type="float">.4</cn>
      </apply>
      <mtext></mtext>
      <ci>E</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>Y</ci>
         <ci>i</ci>
        </apply>
        <interval closure="open">
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>α</ci>
           <times></times>
          </apply>
          <ci>t</ci>
         </apply>
         <apply>
          <times></times>
          <ci>ω</ci>
          <ci>t</ci>
         </apply>
        </interval>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">0</cn>
      <mtext></mtext>
      <apply>
       <csymbol cd="latexml">for-all</csymbol>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <in></in>
     <share href="#.cmml">
     </share>
     <set>
      <cn type="integer">1</cn>
      <ci>normal-…</ci>
      <ci>K</ci>
     </set>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (Eq.4)\text{ }E[Y_{i}(\alpha^{*}(t),\omega(t))]\leq 0\text{ }\forall i\in\{1,.%
..,K\}
  </annotation>
 </semantics>
</math>

</p>

<p>The expectations above are with respect to the random variable 

<math display="inline" id="Drift_plus_penalty:43">
 <semantics>
  <mrow>
   <mi>ω</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>ω</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \omega(t)
  </annotation>
 </semantics>
</math>

 for slot t, and the random control action 

<math display="inline" id="Drift_plus_penalty:44">
 <semantics>
  <mrow>
   <mi>α</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>α</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha(t)
  </annotation>
 </semantics>
</math>

 chosen on slot t after observing 

<math display="inline" id="Drift_plus_penalty:45">
 <semantics>
  <mrow>
   <mi>ω</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>ω</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \omega(t)
  </annotation>
 </semantics>
</math>

. Such a policy 

<math display="inline" id="Drift_plus_penalty:46">
 <semantics>
  <mrow>
   <msup>
    <mi>α</mi>
    <mo>*</mo>
   </msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>α</ci>
     <times></times>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha^{*}(t)
  </annotation>
 </semantics>
</math>

 can be shown to exist whenever the desired control problem is feasible and the event space for 

<math display="inline" id="Drift_plus_penalty:47">
 <semantics>
  <mrow>
   <mi>ω</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>ω</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \omega(t)
  </annotation>
 </semantics>
</math>

 and action space for 

<math display="inline" id="Drift_plus_penalty:48">
 <semantics>
  <mrow>
   <mi>α</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>α</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha(t)
  </annotation>
 </semantics>
</math>

 are finite, or when mild closure properties are satisfied.<a class="footnoteRef" href="#fn26" id="fnref26"><sup>26</sup></a></p>

<p>Let 

<math display="inline" id="Drift_plus_penalty:49">
 <semantics>
  <mrow>
   <mi>α</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>α</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha(t)
  </annotation>
 </semantics>
</math>

 represent the action taken by a C-additive approximation of the drift-plus-penalty algorithm of the previous section, for some non-negative constant C. To simplify terminology, we call this action the <em>drift-plus-penalty action</em>, rather than the <em>C-additive approximate drift-plus-penalty action</em>. Let 

<math display="inline" id="Drift_plus_penalty:50">
 <semantics>
  <mrow>
   <msup>
    <mi>α</mi>
    <mo>*</mo>
   </msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>α</ci>
     <times></times>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha^{*}(t)
  </annotation>
 </semantics>
</math>

 represent the 

<math display="inline" id="Drift_plus_penalty:51">
 <semantics>
  <mi>ω</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ω</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \omega
  </annotation>
 </semantics>
</math>

-only decision:</p>
<ul>
<li><math></math></li>
</ul>

<p>\alpha(t) = \text{drift-plus-penalty action for slot t} </p>
<ul>
<li><math></math></li>
</ul>

<p>\alpha^*(t) = \omega\text{-only action that satisfies (Eq.3)-(Eq.4)} </p>

<p>Assume the drift-plus-penalty action 

<math display="inline" id="Drift_plus_penalty:52">
 <semantics>
  <mrow>
   <mi>α</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>α</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha(t)
  </annotation>
 </semantics>
</math>

 is used on each and every slot. By (Eq. 2), the drift-plus-penalty expression under this 

<math display="inline" id="Drift_plus_penalty:53">
 <semantics>
  <mrow>
   <mi>α</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>α</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha(t)
  </annotation>
 </semantics>
</math>

 action satisfies the following for each slot t:</p>

<p>

<math display="inline" id="Drift_plus_penalty:54">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">Δ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>+</mo>
   <mrow>
    <mi>V</mi>
    <mi>p</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <times></times>
     <ci>normal-Δ</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <times></times>
     <ci>V</ci>
     <ci>p</ci>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta(t)+Vp(t)
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Drift_plus_penalty:55">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>≤</mo>
   <mrow>
    <mi>B</mi>
    <mo>+</mo>
    <mrow>
     <mi>V</mi>
     <mi>p</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>K</mi>
     </msubsup>
     <mrow>
      <msub>
       <mi>Q</mi>
       <mi>i</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <msub>
       <mi>y</mi>
       <mi>i</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <csymbol cd="latexml">absent</csymbol>
    <apply>
     <plus></plus>
     <ci>B</ci>
     <apply>
      <times></times>
      <ci>V</ci>
      <ci>p</ci>
      <ci>t</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>K</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Q</ci>
        <ci>i</ci>
       </apply>
       <ci>t</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <ci>i</ci>
       </apply>
       <ci>t</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \leq B+Vp(t)+\sum_{i=1}^{K}Q_{i}(t)y_{i}(t)
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Drift_plus_penalty:56">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>=</mo>
   <mrow>
    <mi>B</mi>
    <mo>+</mo>
    <mrow>
     <mi>V</mi>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>α</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>t</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>,</mo>
      <mrow>
       <mi>ω</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>t</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>K</mi>
     </msubsup>
     <mrow>
      <msub>
       <mi>Q</mi>
       <mi>i</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <msub>
       <mi>Y</mi>
       <mi>i</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>α</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>t</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>,</mo>
       <mrow>
        <mi>ω</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>t</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <csymbol cd="latexml">absent</csymbol>
    <apply>
     <plus></plus>
     <ci>B</ci>
     <apply>
      <times></times>
      <ci>V</ci>
      <ci>P</ci>
      <interval closure="open">
       <apply>
        <times></times>
        <ci>α</ci>
        <ci>t</ci>
       </apply>
       <apply>
        <times></times>
        <ci>ω</ci>
        <ci>t</ci>
       </apply>
      </interval>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>K</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Q</ci>
        <ci>i</ci>
       </apply>
       <ci>t</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Y</ci>
        <ci>i</ci>
       </apply>
       <interval closure="open">
        <apply>
         <times></times>
         <ci>α</ci>
         <ci>t</ci>
        </apply>
        <apply>
         <times></times>
         <ci>ω</ci>
         <ci>t</ci>
        </apply>
       </interval>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =B+VP(\alpha(t),\omega(t))+\sum_{i=1}^{K}Q_{i}(t)Y_{i}(\alpha(t),\omega(t))
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Drift_plus_penalty:57">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>≤</mo>
   <mrow>
    <mi>B</mi>
    <mo>+</mo>
    <mi>C</mi>
    <mo>+</mo>
    <mrow>
     <mi>V</mi>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msup>
        <mi>α</mi>
        <mo>*</mo>
       </msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>t</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>,</mo>
      <mrow>
       <mi>ω</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>t</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>K</mi>
     </msubsup>
     <mrow>
      <msub>
       <mi>Q</mi>
       <mi>i</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <msub>
       <mi>Y</mi>
       <mi>i</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <msup>
         <mi>α</mi>
         <mo>*</mo>
        </msup>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>t</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>,</mo>
       <mrow>
        <mi>ω</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>t</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <csymbol cd="latexml">absent</csymbol>
    <apply>
     <plus></plus>
     <ci>B</ci>
     <ci>C</ci>
     <apply>
      <times></times>
      <ci>V</ci>
      <ci>P</ci>
      <interval closure="open">
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>α</ci>
         <times></times>
        </apply>
        <ci>t</ci>
       </apply>
       <apply>
        <times></times>
        <ci>ω</ci>
        <ci>t</ci>
       </apply>
      </interval>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>K</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Q</ci>
        <ci>i</ci>
       </apply>
       <ci>t</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Y</ci>
        <ci>i</ci>
       </apply>
       <interval closure="open">
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>α</ci>
          <times></times>
         </apply>
         <ci>t</ci>
        </apply>
        <apply>
         <times></times>
         <ci>ω</ci>
         <ci>t</ci>
        </apply>
       </interval>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \leq B+C+VP(\alpha^{*}(t),\omega(t))+\sum_{i=1}^{K}Q_{i}(t)Y_{i}(\alpha^{*}(t)%
,\omega(t))
  </annotation>
 </semantics>
</math>

</p>

<p>where the last inequality follows because action 

<math display="inline" id="Drift_plus_penalty:58">
 <semantics>
  <mrow>
   <mi>α</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>α</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha(t)
  </annotation>
 </semantics>
</math>

 comes within an additive constant C of minimizing the preceding expression over all other actions in the set A, including 

<math display="inline" id="Drift_plus_penalty:59">
 <semantics>
  <mrow>
   <msup>
    <mi>α</mi>
    <mo>*</mo>
   </msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>α</ci>
     <times></times>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha^{*}(t)
  </annotation>
 </semantics>
</math>

. Taking expectations of the above inequality gives:</p>

<p>

<math display="inline" id="Drift_plus_penalty:60">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mrow>
     <mrow>
      <mi mathvariant="normal">Δ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mi>V</mi>
      <mi>p</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>E</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>normal-Δ</ci>
       <ci>t</ci>
      </apply>
      <apply>
       <times></times>
       <ci>V</ci>
       <ci>p</ci>
       <ci>t</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E[\Delta(t)+Vp(t)]
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Drift_plus_penalty:61">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>≤</mo>
   <mrow>
    <mi>B</mi>
    <mo>+</mo>
    <mi>C</mi>
    <mo>+</mo>
    <mrow>
     <mi>V</mi>
     <mi>E</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mrow>
       <mi>P</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <msup>
          <mi>α</mi>
          <mo>*</mo>
         </msup>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>t</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>,</mo>
        <mrow>
         <mi>ω</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>t</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>K</mi>
     </msubsup>
     <mrow>
      <mi>E</mi>
      <mrow>
       <mo stretchy="false">[</mo>
       <mrow>
        <msub>
         <mi>Q</mi>
         <mi>i</mi>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>t</mi>
         <mo stretchy="false">)</mo>
        </mrow>
        <msub>
         <mi>Y</mi>
         <mi>i</mi>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <msup>
           <mi>α</mi>
           <mo>*</mo>
          </msup>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>t</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo>,</mo>
         <mrow>
          <mi>ω</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>t</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">]</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <csymbol cd="latexml">absent</csymbol>
    <apply>
     <plus></plus>
     <ci>B</ci>
     <ci>C</ci>
     <apply>
      <times></times>
      <ci>V</ci>
      <ci>E</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <times></times>
        <ci>P</ci>
        <interval closure="open">
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>α</ci>
           <times></times>
          </apply>
          <ci>t</ci>
         </apply>
         <apply>
          <times></times>
          <ci>ω</ci>
          <ci>t</ci>
         </apply>
        </interval>
       </apply>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>K</ci>
      </apply>
      <apply>
       <times></times>
       <ci>E</ci>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>Q</ci>
          <ci>i</ci>
         </apply>
         <ci>t</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>Y</ci>
          <ci>i</ci>
         </apply>
         <interval closure="open">
          <apply>
           <times></times>
           <apply>
            <csymbol cd="ambiguous">superscript</csymbol>
            <ci>α</ci>
            <times></times>
           </apply>
           <ci>t</ci>
          </apply>
          <apply>
           <times></times>
           <ci>ω</ci>
           <ci>t</ci>
          </apply>
         </interval>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \leq B+C+VE[P(\alpha^{*}(t),\omega(t))]+\sum_{i=1}^{K}E[Q_{i}(t)Y_{i}(\alpha^{%
*}(t),\omega(t))]
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Drift_plus_penalty:62">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>=</mo>
   <mrow>
    <mi>B</mi>
    <mo>+</mo>
    <mi>C</mi>
    <mo>+</mo>
    <mrow>
     <mi>V</mi>
     <mi>E</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mrow>
       <mi>P</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <msup>
          <mi>α</mi>
          <mo>*</mo>
         </msup>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>t</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>,</mo>
        <mrow>
         <mi>ω</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>t</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>K</mi>
     </msubsup>
     <mrow>
      <mi>E</mi>
      <mrow>
       <mo stretchy="false">[</mo>
       <mrow>
        <msub>
         <mi>Q</mi>
         <mi>i</mi>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>t</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">]</mo>
      </mrow>
      <mi>E</mi>
      <mrow>
       <mo stretchy="false">[</mo>
       <mrow>
        <msub>
         <mi>Y</mi>
         <mi>i</mi>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <msup>
           <mi>α</mi>
           <mo>*</mo>
          </msup>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>t</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo>,</mo>
         <mrow>
          <mi>ω</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>t</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">]</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <csymbol cd="latexml">absent</csymbol>
    <apply>
     <plus></plus>
     <ci>B</ci>
     <ci>C</ci>
     <apply>
      <times></times>
      <ci>V</ci>
      <ci>E</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <times></times>
        <ci>P</ci>
        <interval closure="open">
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>α</ci>
           <times></times>
          </apply>
          <ci>t</ci>
         </apply>
         <apply>
          <times></times>
          <ci>ω</ci>
          <ci>t</ci>
         </apply>
        </interval>
       </apply>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>K</ci>
      </apply>
      <apply>
       <times></times>
       <ci>E</ci>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>Q</ci>
          <ci>i</ci>
         </apply>
         <ci>t</ci>
        </apply>
       </apply>
       <ci>E</ci>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>Y</ci>
          <ci>i</ci>
         </apply>
         <interval closure="open">
          <apply>
           <times></times>
           <apply>
            <csymbol cd="ambiguous">superscript</csymbol>
            <ci>α</ci>
            <times></times>
           </apply>
           <ci>t</ci>
          </apply>
          <apply>
           <times></times>
           <ci>ω</ci>
           <ci>t</ci>
          </apply>
         </interval>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =B+C+VE[P(\alpha^{*}(t),\omega(t))]+\sum_{i=1}^{K}E[Q_{i}(t)]E[Y_{i}(\alpha^{*%
}(t),\omega(t))]
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Drift_plus_penalty:63">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>≤</mo>
   <mrow>
    <mi>B</mi>
    <mo>+</mo>
    <mi>C</mi>
    <mo>+</mo>
    <mrow>
     <mi>V</mi>
     <msup>
      <mi>p</mi>
      <mo>*</mo>
     </msup>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <csymbol cd="latexml">absent</csymbol>
    <apply>
     <plus></plus>
     <ci>B</ci>
     <ci>C</ci>
     <apply>
      <times></times>
      <ci>V</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>p</ci>
       <times></times>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \leq B+C+Vp^{*}
  </annotation>
 </semantics>
</math>

</p>

<p>where the second-to-last equality follows because 

<math display="inline" id="Drift_plus_penalty:64">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>α</mi>
     <mo>*</mo>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>ω</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>α</ci>
      <times></times>
     </apply>
     <ci>t</ci>
    </apply>
    <apply>
     <times></times>
     <ci>ω</ci>
     <ci>t</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha^{*}(t),\omega(t)
  </annotation>
 </semantics>
</math>

 are independent of 

<math display="inline" id="Drift_plus_penalty:65">
 <semantics>
  <mrow>
   <msub>
    <mi>Q</mi>
    <mi>i</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Q</ci>
     <ci>i</ci>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q_{i}(t)
  </annotation>
 </semantics>
</math>

, and the last inequality follows by (Eq.3)-(Eq.4). Notice that the 

<math display="inline" id="Drift_plus_penalty:66">
 <semantics>
  <mrow>
   <msup>
    <mi>α</mi>
    <mo>*</mo>
   </msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>α</ci>
     <times></times>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha^{*}(t)
  </annotation>
 </semantics>
</math>

 action was never actually implemented. Its existence was used only for comparison purposes to reach the final inequality. Summing the above inequality over the first t&gt;0 slots gives:</p>

<p>

<math display="inline" id="Drift_plus_penalty:67">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∑</mo>
     <mrow>
      <mi>τ</mi>
      <mo>=</mo>
      <mn>0</mn>
     </mrow>
     <mrow>
      <mi>t</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msubsup>
    <mrow>
     <mi>E</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mrow>
       <mrow>
        <mi mathvariant="normal">Δ</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>τ</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>+</mo>
       <mrow>
        <mi>V</mi>
        <mi>p</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>τ</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>B</mi>
      <mo>+</mo>
      <mi>C</mi>
      <mo>+</mo>
      <mrow>
       <mi>V</mi>
       <msup>
        <mi>p</mi>
        <mo>*</mo>
       </msup>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>t</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>τ</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <apply>
       <minus></minus>
       <ci>t</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>E</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <plus></plus>
        <apply>
         <times></times>
         <ci>normal-Δ</ci>
         <ci>τ</ci>
        </apply>
        <apply>
         <times></times>
         <ci>V</ci>
         <ci>p</ci>
         <ci>τ</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <plus></plus>
      <ci>B</ci>
      <ci>C</ci>
      <apply>
       <times></times>
       <ci>V</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>p</ci>
        <times></times>
       </apply>
      </apply>
     </apply>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{\tau=0}^{t-1}E[\Delta(\tau)+Vp(\tau)]\leq(B+C+Vp^{*})t
  </annotation>
 </semantics>
</math>

</p>

<p>Using the fact that 

<math display="inline" id="Drift_plus_penalty:68">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">Δ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>τ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>L</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>τ</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mi>L</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>τ</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>normal-Δ</ci>
     <ci>τ</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>L</ci>
      <apply>
       <plus></plus>
       <ci>τ</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>L</ci>
      <ci>τ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta(\tau)=L(\tau+1)-L(\tau)
  </annotation>
 </semantics>
</math>

 together with the law of <a href="Telescoping_series" title="wikilink">telescoping sums</a> gives:</p>

<p>

<math display="inline" id="Drift_plus_penalty:69">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mi>E</mi>
      <mrow>
       <mo stretchy="false">[</mo>
       <mrow>
        <mi>L</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>t</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">]</mo>
      </mrow>
     </mrow>
     <mo>-</mo>
     <mrow>
      <mi>E</mi>
      <mrow>
       <mo stretchy="false">[</mo>
       <mrow>
        <mi>L</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mn>0</mn>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">]</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>V</mi>
     <mrow>
      <msubsup>
       <mo largeop="true" symmetric="true">∑</mo>
       <mrow>
        <mi>τ</mi>
        <mo>=</mo>
        <mn>0</mn>
       </mrow>
       <mrow>
        <mi>t</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msubsup>
      <mrow>
       <mi>E</mi>
       <mrow>
        <mo stretchy="false">[</mo>
        <mrow>
         <mi>p</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>τ</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo stretchy="false">]</mo>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>B</mi>
      <mo>+</mo>
      <mi>C</mi>
      <mo>+</mo>
      <mrow>
       <mi>V</mi>
       <msup>
        <mi>p</mi>
        <mo>*</mo>
       </msup>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>t</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <plus></plus>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>E</ci>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <apply>
         <times></times>
         <ci>L</ci>
         <ci>t</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>E</ci>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <apply>
         <times></times>
         <ci>L</ci>
         <cn type="integer">0</cn>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>V</ci>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <ci>τ</ci>
          <cn type="integer">0</cn>
         </apply>
        </apply>
        <apply>
         <minus></minus>
         <ci>t</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <times></times>
        <ci>E</ci>
        <apply>
         <csymbol cd="latexml">delimited-[]</csymbol>
         <apply>
          <times></times>
          <ci>p</ci>
          <ci>τ</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <plus></plus>
      <ci>B</ci>
      <ci>C</ci>
      <apply>
       <times></times>
       <ci>V</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>p</ci>
        <times></times>
       </apply>
      </apply>
     </apply>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E[L(t)]-E[L(0)]+V\sum_{\tau=0}^{t-1}E[p(\tau)]\leq(B+C+Vp^{*})t
  </annotation>
 </semantics>
</math>

</p>

<p>Using the fact that L(t) is non-negative and assuming L(0) is identically zero gives:</p>

<p>

<math display="inline" id="Drift_plus_penalty:70">
 <semantics>
  <mrow>
   <mrow>
    <mi>V</mi>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <mi>τ</mi>
       <mo>=</mo>
       <mn>0</mn>
      </mrow>
      <mrow>
       <mi>t</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msubsup>
     <mrow>
      <mi>E</mi>
      <mrow>
       <mo stretchy="false">[</mo>
       <mrow>
        <mi>p</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>τ</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">]</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>B</mi>
      <mo>+</mo>
      <mi>C</mi>
      <mo>+</mo>
      <mrow>
       <mi>V</mi>
       <msup>
        <mi>p</mi>
        <mo>*</mo>
       </msup>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>t</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <times></times>
     <ci>V</ci>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>τ</ci>
         <cn type="integer">0</cn>
        </apply>
       </apply>
       <apply>
        <minus></minus>
        <ci>t</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>E</ci>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <apply>
         <times></times>
         <ci>p</ci>
         <ci>τ</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <plus></plus>
      <ci>B</ci>
      <ci>C</ci>
      <apply>
       <times></times>
       <ci>V</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>p</ci>
        <times></times>
       </apply>
      </apply>
     </apply>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V\sum_{\tau=0}^{t-1}E[p(\tau)]\leq(B+C+Vp^{*})t
  </annotation>
 </semantics>
</math>

</p>

<p>Dividing the above by Vt yields the following result, which holds for all slots t&gt;0:</p>

<p>

<math display="inline" id="Drift_plus_penalty:71">
 <semantics>
  <mrow>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mi>t</mi>
    </mfrac>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <mi>τ</mi>
       <mo>=</mo>
       <mn>0</mn>
      </mrow>
      <mrow>
       <mi>t</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msubsup>
     <mrow>
      <mi>E</mi>
      <mrow>
       <mo stretchy="false">[</mo>
       <mrow>
        <mi>p</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>τ</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">]</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <msup>
     <mi>p</mi>
     <mo>*</mo>
    </msup>
    <mo>+</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>B</mi>
       <mo>+</mo>
       <mi>C</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>/</mo>
     <mi>V</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <ci>t</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>τ</ci>
         <cn type="integer">0</cn>
        </apply>
       </apply>
       <apply>
        <minus></minus>
        <ci>t</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>E</ci>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <apply>
         <times></times>
         <ci>p</ci>
         <ci>τ</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>p</ci>
      <times></times>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <plus></plus>
       <ci>B</ci>
       <ci>C</ci>
      </apply>
      <ci>V</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{1}{t}\sum_{\tau=0}^{t-1}E[p(\tau)]\leq p^{*}+(B+C)/V
  </annotation>
 </semantics>
</math>

</p>

<p>Thus, the time average expected penalty can be made arbitrarily close to the optimal value p* by choosing V suitably large. It can be shown that all virtual queues are mean rate stable, and so all desired constraints are satisfied.<a class="footnoteRef" href="#fn27" id="fnref27"><sup>27</sup></a> The parameter V affects the size of the queues, which determines the speed at which the time average constraint functions converge to a non-positive number. A more detailed analysis on the size of the queues is given in the next subsection.</p>
<h3 id="average-queue-size-analysis">Average queue size analysis</h3>

<p>Assume now there exists an 

<math display="inline" id="Drift_plus_penalty:72">
 <semantics>
  <mi>ω</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ω</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \omega
  </annotation>
 </semantics>
</math>

-only policy 

<math display="inline" id="Drift_plus_penalty:73">
 <semantics>
  <mrow>
   <msup>
    <mi>α</mi>
    <mo>*</mo>
   </msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>α</ci>
     <times></times>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha^{*}(t)
  </annotation>
 </semantics>
</math>

, possibly different from the one that satisfies (Eq. 3)-(Eq.4), that satisfies the following for some 

<math display="inline" id="Drift_plus_penalty:74">
 <semantics>
  <mrow>
   <mi>ϵ</mi>
   <mo>></mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <ci>ϵ</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon>0
  </annotation>
 </semantics>
</math>

:</p>

<p>

<math display="inline" id="Drift_plus_penalty:75">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>E</mi>
      <mi>q</mi>
      <mn>.5</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow></mrow>
    <mi>E</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <msub>
       <mi>Y</mi>
       <mi>i</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <msup>
         <mi>α</mi>
         <mo>*</mo>
        </msup>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>t</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>,</mo>
       <mrow>
        <mi>ω</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>t</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mo>-</mo>
    <mrow>
     <mi>ϵ</mi>
     <mrow></mrow>
     <mrow>
      <mo>∀</mo>
      <mi>i</mi>
     </mrow>
    </mrow>
   </mrow>
   <mo>∈</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mn>1</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mi>K</mi>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <apply>
      <times></times>
      <apply>
       <times></times>
       <ci>E</ci>
       <ci>q</ci>
       <cn type="float">.5</cn>
      </apply>
      <mtext></mtext>
      <ci>E</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>Y</ci>
         <ci>i</ci>
        </apply>
        <interval closure="open">
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>α</ci>
           <times></times>
          </apply>
          <ci>t</ci>
         </apply>
         <apply>
          <times></times>
          <ci>ω</ci>
          <ci>t</ci>
         </apply>
        </interval>
       </apply>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>ϵ</ci>
       <mtext></mtext>
       <apply>
        <csymbol cd="latexml">for-all</csymbol>
        <ci>i</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <in></in>
     <share href="#.cmml">
     </share>
     <set>
      <cn type="integer">1</cn>
      <ci>normal-…</ci>
      <ci>K</ci>
     </set>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (Eq.5)\text{ }E[Y_{i}(\alpha^{*}(t),\omega(t))]\leq-\epsilon\text{ }\forall i%
\in\{1,...,K\}
  </annotation>
 </semantics>
</math>

</p>

<p>An argument similar to the one in the previous section shows:</p>

<p>

<math display="inline" id="Drift_plus_penalty:76">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi mathvariant="normal">Δ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>V</mi>
     <mi>p</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mi>B</mi>
    <mo>+</mo>
    <mi>C</mi>
    <mo>+</mo>
    <mrow>
     <mi>V</mi>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msup>
        <mi>α</mi>
        <mo>*</mo>
       </msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>t</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>,</mo>
      <mrow>
       <mi>ω</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>t</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>K</mi>
     </msubsup>
     <mrow>
      <msub>
       <mi>Q</mi>
       <mi>i</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <msub>
       <mi>Y</mi>
       <mi>i</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <msup>
         <mi>α</mi>
         <mo>*</mo>
        </msup>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>t</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>,</mo>
       <mrow>
        <mi>ω</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>t</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>normal-Δ</ci>
      <ci>t</ci>
     </apply>
     <apply>
      <times></times>
      <ci>V</ci>
      <ci>p</ci>
      <ci>t</ci>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <ci>B</ci>
     <ci>C</ci>
     <apply>
      <times></times>
      <ci>V</ci>
      <ci>P</ci>
      <interval closure="open">
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>α</ci>
         <times></times>
        </apply>
        <ci>t</ci>
       </apply>
       <apply>
        <times></times>
        <ci>ω</ci>
        <ci>t</ci>
       </apply>
      </interval>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>K</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Q</ci>
        <ci>i</ci>
       </apply>
       <ci>t</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Y</ci>
        <ci>i</ci>
       </apply>
       <interval closure="open">
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>α</ci>
          <times></times>
         </apply>
         <ci>t</ci>
        </apply>
        <apply>
         <times></times>
         <ci>ω</ci>
         <ci>t</ci>
        </apply>
       </interval>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta(t)+Vp(t)\leq B+C+VP(\alpha^{*}(t),\omega(t))+\sum_{i=1}^{K}Q_{i}(t)Y_{i%
}(\alpha^{*}(t),\omega(t))
  </annotation>
 </semantics>
</math>

</p>

<p>Now assume there are upper and lower bounds on the penalty function P(), so that:</p>

<p>

<math display="inline" id="Drift_plus_penalty:77">
 <semantics>
  <mrow>
   <msub>
    <mi>p</mi>
    <mrow>
     <mi>m</mi>
     <mi>i</mi>
     <mi>n</mi>
    </mrow>
   </msub>
   <mo>≤</mo>
   <mrow>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mo>⋅</mo>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <msub>
    <mi>p</mi>
    <mrow>
     <mi>m</mi>
     <mi>a</mi>
     <mi>x</mi>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>p</ci>
      <apply>
       <times></times>
       <ci>m</ci>
       <ci>i</ci>
       <ci>n</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>P</ci>
      <ci>normal-⋅</ci>
     </apply>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>p</ci>
      <apply>
       <times></times>
       <ci>m</ci>
       <ci>a</ci>
       <ci>x</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{min}\leq P(\cdot)\leq p_{max}
  </annotation>
 </semantics>
</math>

</p>

<p>Then the above inequality reduces to:</p>

<p>

<math display="inline" id="Drift_plus_penalty:78">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi mathvariant="normal">Δ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>V</mi>
     <msub>
      <mi>p</mi>
      <mrow>
       <mi>m</mi>
       <mi>i</mi>
       <mi>n</mi>
      </mrow>
     </msub>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mi>B</mi>
    <mo>+</mo>
    <mi>C</mi>
    <mo>+</mo>
    <mrow>
     <mi>V</mi>
     <msub>
      <mi>p</mi>
      <mrow>
       <mi>m</mi>
       <mi>a</mi>
       <mi>x</mi>
      </mrow>
     </msub>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>K</mi>
     </msubsup>
     <mrow>
      <msub>
       <mi>Q</mi>
       <mi>i</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <msub>
       <mi>Y</mi>
       <mi>i</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <msup>
         <mi>α</mi>
         <mo>*</mo>
        </msup>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>t</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>,</mo>
       <mrow>
        <mi>ω</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>t</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>normal-Δ</ci>
      <ci>t</ci>
     </apply>
     <apply>
      <times></times>
      <ci>V</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <apply>
        <times></times>
        <ci>m</ci>
        <ci>i</ci>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <ci>B</ci>
     <ci>C</ci>
     <apply>
      <times></times>
      <ci>V</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <apply>
        <times></times>
        <ci>m</ci>
        <ci>a</ci>
        <ci>x</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>K</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Q</ci>
        <ci>i</ci>
       </apply>
       <ci>t</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Y</ci>
        <ci>i</ci>
       </apply>
       <interval closure="open">
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>α</ci>
          <times></times>
         </apply>
         <ci>t</ci>
        </apply>
        <apply>
         <times></times>
         <ci>ω</ci>
         <ci>t</ci>
        </apply>
       </interval>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta(t)+Vp_{min}\leq B+C+Vp_{max}+\sum_{i=1}^{K}Q_{i}(t)Y_{i}(\alpha^{*}(t),%
\omega(t))
  </annotation>
 </semantics>
</math>

</p>

<p>Taking expectations of the above and using (Eq. 5) gives:</p>

<p>

<math display="inline" id="Drift_plus_penalty:79">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>E</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mrow>
       <mi mathvariant="normal">Δ</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>t</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>V</mi>
     <msub>
      <mi>p</mi>
      <mrow>
       <mi>m</mi>
       <mi>i</mi>
       <mi>n</mi>
      </mrow>
     </msub>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mi>B</mi>
    <mo>+</mo>
    <mi>C</mi>
    <mo>+</mo>
    <mrow>
     <mi>V</mi>
     <msub>
      <mi>p</mi>
      <mrow>
       <mi>m</mi>
       <mi>a</mi>
       <mi>x</mi>
      </mrow>
     </msub>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>K</mi>
     </msubsup>
     <mrow>
      <mi>E</mi>
      <mrow>
       <mo stretchy="false">[</mo>
       <mrow>
        <msub>
         <mi>Q</mi>
         <mi>i</mi>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>t</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">]</mo>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mo>-</mo>
        <mi>ϵ</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>E</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <times></times>
        <ci>normal-Δ</ci>
        <ci>t</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>V</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <apply>
        <times></times>
        <ci>m</ci>
        <ci>i</ci>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <ci>B</ci>
     <ci>C</ci>
     <apply>
      <times></times>
      <ci>V</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <apply>
        <times></times>
        <ci>m</ci>
        <ci>a</ci>
        <ci>x</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>K</ci>
      </apply>
      <apply>
       <times></times>
       <ci>E</ci>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>Q</ci>
          <ci>i</ci>
         </apply>
         <ci>t</ci>
        </apply>
       </apply>
       <apply>
        <minus></minus>
        <ci>ϵ</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E[\Delta(t)]+Vp_{min}\leq B+C+Vp_{max}+\sum_{i=1}^{K}E[Q_{i}(t)](-\epsilon)
  </annotation>
 </semantics>
</math>

</p>

<p>A telescoping series argument similar to the one in the previous section can thus be used to show the following for all t&gt;0:<a class="footnoteRef" href="#fn28" id="fnref28"><sup>28</sup></a> 

<math display="inline" id="Drift_plus_penalty:80">
 <semantics>
  <mrow>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mi>t</mi>
    </mfrac>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <mi>τ</mi>
       <mo>=</mo>
       <mn>0</mn>
      </mrow>
      <mrow>
       <mi>t</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msubsup>
     <mrow>
      <msubsup>
       <mo largeop="true" symmetric="true">∑</mo>
       <mrow>
        <mi>i</mi>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <mi>K</mi>
      </msubsup>
      <mrow>
       <mi>E</mi>
       <mrow>
        <mo stretchy="false">[</mo>
        <mrow>
         <msub>
          <mi>Q</mi>
          <mi>i</mi>
         </msub>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>τ</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo stretchy="false">]</mo>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mfrac>
    <mrow>
     <mi>B</mi>
     <mo>+</mo>
     <mi>C</mi>
     <mo>+</mo>
     <mrow>
      <mi>V</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <msub>
         <mi>p</mi>
         <mrow>
          <mi>m</mi>
          <mi>a</mi>
          <mi>x</mi>
         </mrow>
        </msub>
        <mo>-</mo>
        <msub>
         <mi>p</mi>
         <mrow>
          <mi>m</mi>
          <mi>i</mi>
          <mi>n</mi>
         </mrow>
        </msub>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mi>ϵ</mi>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <ci>t</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>τ</ci>
         <cn type="integer">0</cn>
        </apply>
       </apply>
       <apply>
        <minus></minus>
        <ci>t</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <ci>i</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>K</ci>
       </apply>
       <apply>
        <times></times>
        <ci>E</ci>
        <apply>
         <csymbol cd="latexml">delimited-[]</csymbol>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>Q</ci>
           <ci>i</ci>
          </apply>
          <ci>τ</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <plus></plus>
      <ci>B</ci>
      <ci>C</ci>
      <apply>
       <times></times>
       <ci>V</ci>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>p</ci>
         <apply>
          <times></times>
          <ci>m</ci>
          <ci>a</ci>
          <ci>x</ci>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>p</ci>
         <apply>
          <times></times>
          <ci>m</ci>
          <ci>i</ci>
          <ci>n</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
     <ci>ϵ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{1}{t}\sum_{\tau=0}^{t-1}\sum_{i=1}^{K}E[Q_{i}(\tau)]\leq\frac{B+C+V(p_{%
max}-p_{min})}{\epsilon}
  </annotation>
 </semantics>
</math>

</p>

<p>This shows that average queue size is indeed O(V).</p>
<h3 id="probability-1-convergence">Probability 1 convergence</h3>

<p>The above analysis considers time average expectations. Related probability 1 performance bounds for infinite horizon time average queue size and penalty can be derived using the drift-plus-penalty method together with <a href="Martingale_(probability_theory)" title="wikilink">martingale theory</a>.<a class="footnoteRef" href="#fn29" id="fnref29"><sup>29</sup></a></p>
<h3 id="treatment-of-queueing-systems">Treatment of queueing systems</h3>

<p>The above analysis considers constrained optimization of time averages in a stochastic system that did not have any explicit queues. Each time average inequality constraint was mapped to a virtual queue according to (Eq. 1). In the case of optimizing a queueing network, the virtual queue equations in (Eq. 1) are replaced by the actual queueing equations.</p>
<h3 id="convex-functions-of-time-averages">Convex functions of time averages</h3>

<p>A related problem is the minimization of a convex function of time averages subject to constraints, such as:</p>

<p>

<math display="inline" id="Drift_plus_penalty:81">
 <semantics>
  <mrow>
   <mtext>Minimize:</mtext>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mover accent="true">
      <mi>y</mi>
      <mo>¯</mo>
     </mover>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mover accent="true">
      <mi>y</mi>
      <mo>¯</mo>
     </mover>
     <mn>2</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mover accent="true">
      <mi>y</mi>
      <mo>¯</mo>
     </mover>
     <mi>K</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <mtext>Minimize:</mtext>
    <ci>f</ci>
    <vector>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <ci>normal-¯</ci>
       <ci>y</ci>
      </apply>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <ci>normal-¯</ci>
       <ci>y</ci>
      </apply>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <ci>normal-¯</ci>
       <ci>y</ci>
      </apply>
      <ci>K</ci>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{Minimize: }f(\overline{y}_{1},\overline{y}_{2},...,\overline{y}_{K})
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Drift_plus_penalty:82">
 <semantics>
  <mrow>
   <mrow>
    <mtext>Subject to:</mtext>
    <msub>
     <mi>g</mi>
     <mi>i</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mover accent="true">
       <mi>y</mi>
       <mo>¯</mo>
      </mover>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mover accent="true">
       <mi>y</mi>
       <mo>¯</mo>
      </mover>
      <mn>2</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <msub>
      <mover accent="true">
       <mi>y</mi>
       <mo>¯</mo>
      </mover>
      <mi>K</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mn>0</mn>
    <mrow></mrow>
    <mrow>
     <mo>∀</mo>
     <mi>i</mi>
    </mrow>
   </mrow>
   <mo>∈</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mn>1</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mi>N</mi>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <apply>
      <times></times>
      <mtext>Subject to:</mtext>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>g</ci>
       <ci>i</ci>
      </apply>
      <vector>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <ci>normal-¯</ci>
         <ci>y</ci>
        </apply>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <ci>normal-¯</ci>
         <ci>y</ci>
        </apply>
        <cn type="integer">2</cn>
       </apply>
       <ci>normal-…</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <ci>normal-¯</ci>
         <ci>y</ci>
        </apply>
        <ci>K</ci>
       </apply>
      </vector>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">0</cn>
      <mtext></mtext>
      <apply>
       <csymbol cd="latexml">for-all</csymbol>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <in></in>
     <share href="#.cmml">
     </share>
     <set>
      <cn type="integer">1</cn>
      <ci>normal-…</ci>
      <ci>N</ci>
     </set>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{Subject to: }g_{i}(\overline{y}_{1},\overline{y}_{2},...,\overline{y}_{K%
})\leq 0\text{ }\forall i\in\{1,...,N\}
  </annotation>
 </semantics>
</math>

</p>

<p>where f() and g_i() are <a href="convex_function" title="wikilink">convex functions</a>, and where the time averages are defined:</p>

<p>

<math display="inline" id="Drift_plus_penalty:83">
 <semantics>
  <mrow>
   <msub>
    <mover accent="true">
     <mi>y</mi>
     <mo>¯</mo>
    </mover>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mo>lim</mo>
     <mrow>
      <mi>t</mi>
      <mo>→</mo>
      <mi mathvariant="normal">∞</mi>
     </mrow>
    </msub>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <mi>t</mi>
     </mfrac>
     <mrow>
      <msubsup>
       <mo largeop="true" symmetric="true">∑</mo>
       <mrow>
        <mi>τ</mi>
        <mo>=</mo>
        <mn>0</mn>
       </mrow>
       <mrow>
        <mi>t</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msubsup>
      <mrow>
       <mi>E</mi>
       <mrow>
        <mo stretchy="false">[</mo>
        <mrow>
         <msub>
          <mi>y</mi>
          <mi>i</mi>
         </msub>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>τ</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo stretchy="false">]</mo>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <ci>normal-¯</ci>
      <ci>y</ci>
     </apply>
     <ci>i</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <limit></limit>
      <apply>
       <ci>normal-→</ci>
       <ci>t</ci>
       <infinity></infinity>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <ci>t</ci>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <ci>τ</ci>
          <cn type="integer">0</cn>
         </apply>
        </apply>
        <apply>
         <minus></minus>
         <ci>t</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <times></times>
        <ci>E</ci>
        <apply>
         <csymbol cd="latexml">delimited-[]</csymbol>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>y</ci>
           <ci>i</ci>
          </apply>
          <ci>τ</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \overline{y}_{i}=\lim_{t\rightarrow\infty}\frac{1}{t}\sum_{\tau=0}^{t-1}E[y_{i%
}(\tau)]
  </annotation>
 </semantics>
</math>

</p>

<p>Such problems of optimizing convex functions of time averages can be transformed into problems of optimizing time averages of functions via <em>auxiliary variables</em> (see Chapter 5 of the Neely textbook).<a class="footnoteRef" href="#fn30" id="fnref30"><sup>30</sup></a><a class="footnoteRef" href="#fn31" id="fnref31"><sup>31</sup></a> The latter problems can then be solved by the drift-plus-penalty method as described in previous subsections. An alternative <em>primal-dual</em> method makes decisions similar to drift-plus-penalty decisions, but uses a penalty defined by partial derivatives of the objective function f().<a class="footnoteRef" href="#fn32" id="fnref32"><sup>32</sup></a> <a class="footnoteRef" href="#fn33" id="fnref33"><sup>33</sup></a> <a class="footnoteRef" href="#fn34" id="fnref34"><sup>34</sup></a> The primal-dual approach can also be used to find local optimums in cases when the function f() is non-convex.<a class="footnoteRef" href="#fn35" id="fnref35"><sup>35</sup></a></p>
<h2 id="delay-tradeoffs-and-related-work">Delay tradeoffs and related work</h2>

<p>The mathematical analysis in the previous section shows that the drift-plus-penalty method produces a time average penalty that is within O(1/V) of optimality, with a corresponding O(V) tradeoff in average queue size. This method, together with the O(1/V), O(V) tradeoff, was developed in Neely<a class="footnoteRef" href="#fn36" id="fnref36"><sup>36</sup></a> and Neely, Modiano, Li <a class="footnoteRef" href="#fn37" id="fnref37"><sup>37</sup></a> in the context of maximizing network utility subject to stability.</p>

<p>A related algorithm for maximizing network utility was developed by Eryilmaz and Srikant. <a class="footnoteRef" href="#fn38" id="fnref38"><sup>38</sup></a> The Eryilmaz and Srikant work resulted in an algorithm very similar to the drift-plus-penalty algorithm, but used a different analytical technique. That technique was based on <a href="Lagrange_multipliers" title="wikilink">Lagrange multipliers</a>. A direct use of the Lagrange multiplier technique results in a worse tradeoff of O(1/V), O(V^2). However, the Lagrange multiplier analysis was later strengthened by Huang and Neely to recover the original O(1/V), O(V) tradeoffs, while showing that queue sizes are tightly clustered around the Lagrange multiplier of a corresponding deterministic optimization problem. <a class="footnoteRef" href="#fn39" id="fnref39"><sup>39</sup></a> This clustering result can be used to modify the drift-plus-penalty algorithm to enable improved O(1/V), O(log^2(V)) tradeoffs. The modifications can use either <em>place-holder backlog</em><a class="footnoteRef" href="#fn40" id="fnref40"><sup>40</sup></a> or <a href="LIFO_(computing)" title="wikilink">Last-in-First-Out (LIFO)</a> scheduling. <a class="footnoteRef" href="#fn41" id="fnref41"><sup>41</sup></a> <a class="footnoteRef" href="#fn42" id="fnref42"><sup>42</sup></a></p>

<p>When implemented for non-stochastic functions, the drift-plus-penalty method is similar to the <a href="Subgradient_method" title="wikilink">dual subgradient method</a> of <a href="Convex_optimization" title="wikilink">convex optimization theory</a>, with the exception that its output is a time average of <a href="#Drift-plus-penalty_algorithm_for_convex_programming" title="wikilink">primal variables</a>, rather than the primal variables themselves.<a class="footnoteRef" href="#fn43" id="fnref43"><sup>43</sup></a><a class="footnoteRef" href="#fn44" id="fnref44"><sup>44</sup></a> A related <em>primal-dual technique</em> for maximizing utility in a stochastic queueing network was developed by Stolyar using a fluid model analysis. <a class="footnoteRef" href="#fn45" id="fnref45"><sup>45</sup></a> <a class="footnoteRef" href="#fn46" id="fnref46"><sup>46</sup></a> The Stolyar analysis does not provide analytical results for a performance tradeoff between utility and queue size. A later analysis of the primal-dual method for stochastic networks proves a similar O(1/V), O(V) utility and queue size tradeoff, and also shows local optimality results for minimizing non-convex functions of time averages, under an additional convergence assumption.<a class="footnoteRef" href="#fn47" id="fnref47"><sup>47</sup></a> However, this analysis does not specify how much time is required for the time averages to converge to something close to their infinite horizon limits. Related primal-dual algorithms for utility maximization without queues were developed by Agrawal and Subramanian <a class="footnoteRef" href="#fn48" id="fnref48"><sup>48</sup></a> and Kushner and Whiting <a class="footnoteRef" href="#fn49" id="fnref49"><sup>49</sup></a> .</p>
<h2 id="extensions-to-non-i.i.d.-event-processes">Extensions to non-i.i.d. event processes</h2>

<p>The drift-plus-penalty algorithm is known to ensure similar performance guarantees for more general ergodic processes 

<math display="inline" id="Drift_plus_penalty:84">
 <semantics>
  <mrow>
   <mi>ω</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>ω</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \omega(t)
  </annotation>
 </semantics>
</math>

, so that the i.i.d. assumption is not crucial to the analysis. The algorithm can be shown to be robust to non-ergodic changes in the probabilities for 

<math display="inline" id="Drift_plus_penalty:85">
 <semantics>
  <mrow>
   <mi>ω</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>ω</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \omega(t)
  </annotation>
 </semantics>
</math>

. In certain scenarios, it can be shown to provide desirable analytical guarantees, called <em>universal scheduling guarantees</em>, for arbitrary 

<math display="inline" id="Drift_plus_penalty:86">
 <semantics>
  <mrow>
   <mi>ω</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>ω</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \omega(t)
  </annotation>
 </semantics>
</math>

 processes.<a class="footnoteRef" href="#fn50" id="fnref50"><sup>50</sup></a></p>
<h2 id="extensions-to-variable-frame-length-systems">Extensions to variable frame length systems</h2>

<p>The drift-plus-penalty method can be extended to treat systems that operate over variable size frames.<a class="footnoteRef" href="#fn51" id="fnref51"><sup>51</sup></a> <a class="footnoteRef" href="#fn52" id="fnref52"><sup>52</sup></a> In that case, the frames are labeled with indices r in {0, 1, 2, ...} and the frame durations are denoted {T[0], T[1], T[2], ...}, where T[r] is a non-negative real number for each frame r. Let 

<math display="inline" id="Drift_plus_penalty:87">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Δ</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>r</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Δ</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>r</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta[r]
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Drift_plus_penalty:88">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>r</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>p</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>r</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p[r]
  </annotation>
 </semantics>
</math>

 be the drift between frame r and r+1, and the total penalty incurred during frame r, respectively. The extended algorithm takes a control action over each frame r to minimize a bound on the following ratio of conditional expectations:</p>

<p>

<math display="inline" id="Drift_plus_penalty:89">
 <semantics>
  <mfrac>
   <mrow>
    <mi>E</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi mathvariant="normal">Δ</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>r</mi>
      <mo stretchy="false">]</mo>
     </mrow>
     <mo>+</mo>
     <mi>V</mi>
     <mi>p</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>r</mi>
      <mo stretchy="false">]</mo>
     </mrow>
     <mo stretchy="false">|</mo>
     <mi>Q</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>r</mi>
      <mo stretchy="false">]</mo>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mrow>
    <mi>E</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>T</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>r</mi>
      <mo stretchy="false">]</mo>
     </mrow>
     <mo stretchy="false">|</mo>
     <mi>Q</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>r</mi>
      <mo stretchy="false">]</mo>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <csymbol cd="unknown">E</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-[</ci>
      <csymbol cd="unknown">Δ</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-[</ci>
       <csymbol cd="unknown">r</csymbol>
       <ci>normal-]</ci>
      </cerror>
      <plus></plus>
      <csymbol cd="unknown">V</csymbol>
      <csymbol cd="unknown">p</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-[</ci>
       <csymbol cd="unknown">r</csymbol>
       <ci>normal-]</ci>
      </cerror>
      <ci>normal-|</ci>
      <csymbol cd="unknown">Q</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-[</ci>
       <csymbol cd="unknown">r</csymbol>
       <ci>normal-]</ci>
      </cerror>
      <ci>normal-]</ci>
     </cerror>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <csymbol cd="unknown">E</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-[</ci>
      <csymbol cd="unknown">T</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-[</ci>
       <csymbol cd="unknown">r</csymbol>
       <ci>normal-]</ci>
      </cerror>
      <ci>normal-|</ci>
      <csymbol cd="unknown">Q</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-[</ci>
       <csymbol cd="unknown">r</csymbol>
       <ci>normal-]</ci>
      </cerror>
      <ci>normal-]</ci>
     </cerror>
    </cerror>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{E[\Delta[r]+Vp[r]|Q[r]]}{E[T[r]|Q[r]]}
  </annotation>
 </semantics>
</math>

</p>

<p>where Q[r] is the vector of queue backlogs at the beginning of frame r. In the special case when all frames are the same size and are normalized to 1 slot length, so that T[r]=1 for all r, the above minimization reduces to the standard drift-plus-penalty technique. This frame-based method can be used for constrained optimization of <a href="Markov_decision_process" title="wikilink">Markov decision problems (MDPs)</a> and for other problems involving systems that experience <a href="Renewal_theory" title="wikilink">renewals</a>. <a class="footnoteRef" href="#fn53" id="fnref53"><sup>53</sup></a> <a class="footnoteRef" href="#fn54" id="fnref54"><sup>54</sup></a></p>
<h2 id="application-to-convex-programming">Application to convex programming</h2>

<p>Let x = (x_1, ..., x_N) be an N-dimensinal vector of real numbers, and define the hyper-rectangle A by:</p>

<p>

<math display="inline" id="Drift_plus_penalty:90">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mn>1</mn>
      </msub>
      <mo>,</mo>
      <msub>
       <mi>x</mi>
       <mn>2</mn>
      </msub>
      <mo>,</mo>
      <mi mathvariant="normal">…</mi>
      <mo>,</mo>
      <msub>
       <mi>x</mi>
       <mi>N</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow></mrow>
    </mrow>
    <mo stretchy="false">|</mo>
    <mrow>
     <mrow>
      <mrow></mrow>
      <msub>
       <mi>x</mi>
       <mrow>
        <mrow>
         <mi>m</mi>
         <mi>i</mi>
         <mi>n</mi>
        </mrow>
        <mo>,</mo>
        <mi>i</mi>
       </mrow>
      </msub>
     </mrow>
     <mo>≤</mo>
     <msub>
      <mi>x</mi>
      <mi>i</mi>
     </msub>
     <mo>≤</mo>
     <mrow>
      <msub>
       <mi>x</mi>
       <mrow>
        <mrow>
         <mi>m</mi>
         <mi>a</mi>
         <mi>x</mi>
        </mrow>
        <mo>,</mo>
        <mi>i</mi>
       </mrow>
      </msub>
      <mrow></mrow>
      <mrow>
       <mo>∀</mo>
       <mi>i</mi>
      </mrow>
     </mrow>
     <mo>∈</mo>
     <mrow>
      <mo stretchy="false">{</mo>
      <mn>1</mn>
      <mo>,</mo>
      <mi mathvariant="normal">…</mi>
      <mo>,</mo>
      <mi>N</mi>
      <mo stretchy="false">}</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>A</ci>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <apply>
      <times></times>
      <vector>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <cn type="integer">2</cn>
       </apply>
       <ci>normal-…</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>N</ci>
       </apply>
      </vector>
      <mtext></mtext>
     </apply>
     <apply>
      <and></and>
      <apply>
       <leq></leq>
       <apply>
        <times></times>
        <mtext></mtext>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <list>
          <apply>
           <times></times>
           <ci>m</ci>
           <ci>i</ci>
           <ci>n</ci>
          </apply>
          <ci>i</ci>
         </list>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>i</ci>
       </apply>
      </apply>
      <apply>
       <leq></leq>
       <share href="#.cmml">
       </share>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <list>
          <apply>
           <times></times>
           <ci>m</ci>
           <ci>a</ci>
           <ci>x</ci>
          </apply>
          <ci>i</ci>
         </list>
        </apply>
        <mtext></mtext>
        <apply>
         <csymbol cd="latexml">for-all</csymbol>
         <ci>i</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <in></in>
       <share href="#.cmml">
       </share>
       <set>
        <cn type="integer">1</cn>
        <ci>normal-…</ci>
        <ci>N</ci>
       </set>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A=\{(x_{1},x_{2},...,x_{N})\text{ }|\text{ }x_{min,i}\leq x_{i}\leq x_{max,i}%
\text{ }\forall i\in\{1,...,N\}\}
  </annotation>
 </semantics>
</math>

</p>

<p>where x_{min, i}, x_{max, i} are given real numbers that satisfy 

<math display="inline" id="Drift_plus_penalty:91">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mrow>
     <mrow>
      <mi>m</mi>
      <mi>i</mi>
      <mi>n</mi>
     </mrow>
     <mo>,</mo>
     <mi>i</mi>
    </mrow>
   </msub>
   <mo><</mo>
   <msub>
    <mi>x</mi>
    <mrow>
     <mrow>
      <mi>m</mi>
      <mi>a</mi>
      <mi>x</mi>
     </mrow>
     <mo>,</mo>
     <mi>i</mi>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <list>
      <apply>
       <times></times>
       <ci>m</ci>
       <ci>i</ci>
       <ci>n</ci>
      </apply>
      <ci>i</ci>
     </list>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <list>
      <apply>
       <times></times>
       <ci>m</ci>
       <ci>a</ci>
       <ci>x</ci>
      </apply>
      <ci>i</ci>
     </list>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{min,i}<x_{max,i}
  </annotation>
 </semantics>
</math>

 for all i. Let P(x) and 

<math display="inline" id="Drift_plus_penalty:92">
 <semantics>
  <mrow>
   <msub>
    <mi>Y</mi>
    <mi>i</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Y</ci>
     <ci>i</ci>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y_{i}(x)
  </annotation>
 </semantics>
</math>

 for i in {1, ..., K} be continuous and <a href="convex_function" title="wikilink">convex functions</a> of the x vector over all x in A. Consider the following <a href="Convex_optimization" title="wikilink">convex programming</a> problem:</p>

<p>

<math display="inline" id="Drift_plus_penalty:93">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>E</mi>
     <mi>q</mi>
     <mn>.6</mn>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mtext>Minimize:</mtext>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <times></times>
     <ci>E</ci>
     <ci>q</ci>
     <cn type="float">.6</cn>
    </apply>
    <mtext>Minimize:</mtext>
    <ci>P</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (Eq.6)\text{ }\text{Minimize: }P(x)
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Drift_plus_penalty:94">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>E</mi>
       <mi>q</mi>
       <mn>.7</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mtext>Subject to:</mtext>
     <msub>
      <mi>Y</mi>
      <mi>i</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>≤</mo>
    <mrow>
     <mn>0</mn>
     <mrow></mrow>
     <mrow>
      <mo>∀</mo>
      <mi>i</mi>
     </mrow>
    </mrow>
    <mo>∈</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">{</mo>
      <mn>1</mn>
      <mo>,</mo>
      <mi mathvariant="normal">…</mi>
      <mo>,</mo>
      <mi>K</mi>
      <mo stretchy="false">}</mo>
     </mrow>
     <mrow></mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mrow>
     <mrow></mrow>
     <mi>x</mi>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <msub>
      <mi>x</mi>
      <mi>N</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∈</mo>
    <mi>A</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <and></and>
     <apply>
      <leq></leq>
      <apply>
       <times></times>
       <apply>
        <times></times>
        <ci>E</ci>
        <ci>q</ci>
        <cn type="float">.7</cn>
       </apply>
       <mtext>Subject to:</mtext>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Y</ci>
        <ci>i</ci>
       </apply>
       <ci>x</ci>
      </apply>
      <apply>
       <times></times>
       <cn type="integer">0</cn>
       <mtext></mtext>
       <apply>
        <csymbol cd="latexml">for-all</csymbol>
        <ci>i</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <in></in>
      <share href="#.cmml">
      </share>
      <apply>
       <times></times>
       <set>
        <cn type="integer">1</cn>
        <ci>normal-…</ci>
        <ci>K</ci>
       </set>
       <mtext></mtext>
      </apply>
     </apply>
    </apply>
    <apply>
     <and></and>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <mtext></mtext>
       <ci>x</ci>
      </apply>
      <vector>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>normal-…</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>N</ci>
       </apply>
      </vector>
     </apply>
     <apply>
      <in></in>
      <share href="#.cmml">
      </share>
      <ci>A</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (Eq.7)\text{ }\text{Subject to: }Y_{i}(x)\leq 0\text{ }\forall i\in\{1,...,K\}%
\text{ },\text{ }x=(x_{1},...,x_{N})\in A
  </annotation>
 </semantics>
</math>

</p>

<p>This can be solved by the drift-plus-penalty method as follows: Consider the special case of a deterministic system with no random event process 

<math display="inline" id="Drift_plus_penalty:95">
 <semantics>
  <mrow>
   <mi>ω</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>ω</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \omega(t)
  </annotation>
 </semantics>
</math>

. Define the control action 

<math display="inline" id="Drift_plus_penalty:96">
 <semantics>
  <mrow>
   <mi>α</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>α</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha(t)
  </annotation>
 </semantics>
</math>

 as:</p>

<p>

<math display="inline" id="Drift_plus_penalty:97">
 <semantics>
  <mrow>
   <mrow>
    <mi>α</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>x</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>,</mo>
    <mrow>
     <msub>
      <mi>x</mi>
      <mn>2</mn>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mrow>
     <msub>
      <mi>x</mi>
      <mi>N</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>α</ci>
      <ci>t</ci>
     </apply>
     <apply>
      <times></times>
      <ci>x</ci>
      <ci>t</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <vector>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>t</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <cn type="integer">2</cn>
       </apply>
       <ci>t</ci>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>N</ci>
       </apply>
       <ci>t</ci>
      </apply>
     </vector>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha(t)=x(t)=(x_{1}(t),x_{2}(t),...,x_{N}(t))
  </annotation>
 </semantics>
</math>

</p>

<p>and define the action space as the N-dimensional hyper-rectangle A. Define penalty and constraint functions as:</p>
<ul>
<li><math></math></li>
</ul>

<p>p(t) = P(x_1(t), ..., x_N(t)) </p>
<ul>
<li><math></math></li>
</ul>

<p>y_i(t) = Y_i(x_1(t), ..., x_N(t)) \text{ } \forall i \in \{1, \ldots, K\} </p>

<p>Define the following time averages:</p>
<ul>
<li><math></math></li>
</ul>

<p>\overline{x}(t) = \frac{1}{t}\sum_{\tau=0}^{t-1} (x_1(\tau), ..., x_N(\tau)) </p>
<ul>
<li><math></math></li>
</ul>

<p>\overline{P}(t) = \frac{1}{t}\sum_{\tau=0}^{t-1}P(x_1(\tau), ..., x_N(\tau)) </p>
<ul>
<li><math></math></li>
</ul>

<p>\overline{Y}_i(t) = \frac{1}{t}\sum_{\tau=0}^{t-1}Y_i(x_1(\tau), ..., x_N(\tau)) </p>

<p>Now consider the following time average optimization problem:</p>

<p>

<math display="inline" id="Drift_plus_penalty:98">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>E</mi>
     <mi>q</mi>
     <mn>.8</mn>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mtext>Minimize:</mtext>
   <mrow>
    <msub>
     <mo>lim</mo>
     <mrow>
      <mi>t</mi>
      <mo>→</mo>
      <mi mathvariant="normal">∞</mi>
     </mrow>
    </msub>
    <mrow>
     <mover accent="true">
      <mi>P</mi>
      <mo>¯</mo>
     </mover>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <times></times>
     <ci>E</ci>
     <ci>q</ci>
     <cn type="float">.8</cn>
    </apply>
    <mtext>Minimize:</mtext>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <limit></limit>
      <apply>
       <ci>normal-→</ci>
       <ci>t</ci>
       <infinity></infinity>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <ci>normal-¯</ci>
       <ci>P</ci>
      </apply>
      <ci>t</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (Eq.8)\text{ }\text{Minimize: }\lim_{t\rightarrow\infty}\overline{P}(t)
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Drift_plus_penalty:99">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>E</mi>
      <mi>q</mi>
      <mn>.9</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mtext>Subject to:</mtext>
    <mrow>
     <msub>
      <mo>lim</mo>
      <mrow>
       <mi>t</mi>
       <mo>→</mo>
       <mi mathvariant="normal">∞</mi>
      </mrow>
     </msub>
     <mrow>
      <msub>
       <mover accent="true">
        <mi>Y</mi>
        <mo>¯</mo>
       </mover>
       <mi>i</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mn>0</mn>
    <mrow></mrow>
    <mrow>
     <mo>∀</mo>
     <mi>i</mi>
    </mrow>
   </mrow>
   <mo>∈</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mn>1</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mi>K</mi>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <apply>
      <times></times>
      <apply>
       <times></times>
       <ci>E</ci>
       <ci>q</ci>
       <cn type="float">.9</cn>
      </apply>
      <mtext>Subject to:</mtext>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <limit></limit>
        <apply>
         <ci>normal-→</ci>
         <ci>t</ci>
         <infinity></infinity>
        </apply>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <apply>
          <ci>normal-¯</ci>
          <ci>Y</ci>
         </apply>
         <ci>i</ci>
        </apply>
        <ci>t</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">0</cn>
      <mtext></mtext>
      <apply>
       <csymbol cd="latexml">for-all</csymbol>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <in></in>
     <share href="#.cmml">
     </share>
     <set>
      <cn type="integer">1</cn>
      <ci>normal-…</ci>
      <ci>K</ci>
     </set>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (Eq.9)\text{ }\text{Subject to: }\lim_{t\rightarrow\infty}\overline{Y}_{i}(t)%
\leq 0\text{ }\forall i\in\{1,...,K\}
  </annotation>
 </semantics>
</math>

</p>

<p>By <a href="Jensen's_inequality" title="wikilink">Jensen's inequality</a> the following holds for all slots t&gt;0:</p>

<p>

<math display="inline" id="Drift_plus_penalty:100">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mover accent="true">
        <mi>x</mi>
        <mo>¯</mo>
       </mover>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>t</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>≤</mo>
    <mrow>
     <mover accent="true">
      <mi>P</mi>
      <mo>¯</mo>
     </mover>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow></mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mrow>
     <mrow></mrow>
     <msub>
      <mi>Y</mi>
      <mi>i</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mover accent="true">
        <mi>x</mi>
        <mo>¯</mo>
       </mover>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>t</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>≤</mo>
    <mrow>
     <msub>
      <mover accent="true">
       <mi>Y</mi>
       <mo>¯</mo>
      </mover>
      <mi>i</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow></mrow>
     <mrow>
      <mo>∀</mo>
      <mi>i</mi>
     </mrow>
    </mrow>
    <mo>∈</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mn>1</mn>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <mi>K</mi>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <leq></leq>
     <apply>
      <times></times>
      <ci>P</ci>
      <apply>
       <times></times>
       <apply>
        <ci>normal-¯</ci>
        <ci>x</ci>
       </apply>
       <ci>t</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <ci>normal-¯</ci>
       <ci>P</ci>
      </apply>
      <ci>t</ci>
      <mtext></mtext>
     </apply>
    </apply>
    <apply>
     <and></and>
     <apply>
      <leq></leq>
      <apply>
       <times></times>
       <mtext></mtext>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Y</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <ci>normal-¯</ci>
         <ci>x</ci>
        </apply>
        <ci>t</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <ci>normal-¯</ci>
         <ci>Y</ci>
        </apply>
        <ci>i</ci>
       </apply>
       <ci>t</ci>
       <mtext></mtext>
       <apply>
        <csymbol cd="latexml">for-all</csymbol>
        <ci>i</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <in></in>
      <share href="#.cmml">
      </share>
      <set>
       <cn type="integer">1</cn>
       <ci>normal-…</ci>
       <ci>K</ci>
      </set>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(\overline{x}(t))\leq\overline{P}(t)\text{ },\text{ }Y_{i}(\overline{x}(t))%
\leq\overline{Y}_{i}(t)\text{ }\forall i\in\{1,...,K\}
  </annotation>
 </semantics>
</math>

</p>

<p>From this, it can be shown that an optimal solution to the time-average problem (Eq. 8)-(Eq. 9) can be achieved by solutions of the type x(t) = x* for all slots t, where x* is a vector that solves the convex program (Eq. 6)-(Eq. 7). Further, any time-averaged vector 

<math display="inline" id="Drift_plus_penalty:101">
 <semantics>
  <mrow>
   <msub>
    <mo>lim</mo>
    <mrow>
     <mi>t</mi>
     <mo>→</mo>
     <mi mathvariant="normal">∞</mi>
    </mrow>
   </msub>
   <mrow>
    <mover accent="true">
     <mi>x</mi>
     <mo>¯</mo>
    </mover>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <limit></limit>
     <apply>
      <ci>normal-→</ci>
      <ci>t</ci>
      <infinity></infinity>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <ci>normal-¯</ci>
      <ci>x</ci>
     </apply>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lim_{t\rightarrow\infty}\overline{x}(t)
  </annotation>
 </semantics>
</math>

 corresponding to a solution of the time-average problem (Eq. 8)-(Eq. 9) must solve the convex program (Eq. 6)-(Eq. 7). Therefore, the original convex program (Eq. 6)-(Eq. 7) can be solved (to within any desired accuracy) by taking the time average of the decisions made when the drift-plus-penalty algorithm is applied to the corresponding time-averaged problem (Eq. 8)-(Eq. 9). The drift-plus-penalty algorithm for problem (Eq. 8)-(Eq. 9) reduces to the following:</p>
<h3 id="drift-plus-penalty-algorithm-for-convex-programming">Drift-plus-penalty algorithm for convex programming</h3>

<p>Every slot t, choose vector 

<math display="inline" id="Drift_plus_penalty:102">
 <semantics>
  <mrow>
   <mrow>
    <mi>x</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mrow>
     <msub>
      <mi>x</mi>
      <mi>N</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∈</mo>
   <mi>A</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>x</ci>
      <ci>t</ci>
     </apply>
     <vector>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>t</ci>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>N</ci>
       </apply>
       <ci>t</ci>
      </apply>
     </vector>
    </apply>
    <apply>
     <in></in>
     <share href="#.cmml">
     </share>
     <ci>A</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x(t)=(x_{1}(t),...,x_{N}(t))\in A
  </annotation>
 </semantics>
</math>

 to minimize the expression:</p>

<p>

<math display="inline" id="Drift_plus_penalty:103">
 <semantics>
  <mrow>
   <mrow>
    <mi>V</mi>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>x</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>+</mo>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∑</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>K</mi>
    </msubsup>
    <mrow>
     <msub>
      <mi>Q</mi>
      <mi>i</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <msub>
      <mi>Y</mi>
      <mi>i</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>x</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>t</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <times></times>
     <ci>V</ci>
     <ci>P</ci>
     <apply>
      <times></times>
      <ci>x</ci>
      <ci>t</ci>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>K</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Q</ci>
       <ci>i</ci>
      </apply>
      <ci>t</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Y</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <times></times>
       <ci>x</ci>
       <ci>t</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   VP(x(t))+\sum_{i=1}^{K}Q_{i}(t)Y_{i}(x(t))
  </annotation>
 </semantics>
</math>

</p>

<p>Then update the queues according to:</p>

<p>

<math display="inline" id="Drift_plus_penalty:104">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>Q</mi>
     <mi>i</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>t</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>max</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mrow>
       <mrow>
        <msub>
         <mi>Q</mi>
         <mi>i</mi>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>t</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>+</mo>
       <mrow>
        <msub>
         <mi>Y</mi>
         <mi>i</mi>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mi>x</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>t</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
      <mo>,</mo>
      <mn>0</mn>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mrow></mrow>
    <mrow>
     <mo>∀</mo>
     <mi>i</mi>
    </mrow>
   </mrow>
   <mo>∈</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mn>1</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mi>K</mi>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Q</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <plus></plus>
       <ci>t</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <max></max>
       <apply>
        <plus></plus>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>Q</ci>
          <ci>i</ci>
         </apply>
         <ci>t</ci>
        </apply>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>Y</ci>
          <ci>i</ci>
         </apply>
         <apply>
          <times></times>
          <ci>x</ci>
          <ci>t</ci>
         </apply>
        </apply>
       </apply>
       <cn type="integer">0</cn>
      </apply>
      <mtext></mtext>
      <apply>
       <csymbol cd="latexml">for-all</csymbol>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <in></in>
     <share href="#.cmml">
     </share>
     <set>
      <cn type="integer">1</cn>
      <ci>normal-…</ci>
      <ci>K</ci>
     </set>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q_{i}(t+1)=\max[Q_{i}(t)+Y_{i}(x(t)),0]\text{ }\forall i\in\{1,...,K\}
  </annotation>
 </semantics>
</math>

</p>

<p>The time average vector 

<math display="inline" id="Drift_plus_penalty:105">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>x</mi>
    <mo>¯</mo>
   </mover>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <ci>normal-¯</ci>
     <ci>x</ci>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \overline{x}(t)
  </annotation>
 </semantics>
</math>

 converges to an O(1/V) approximation to the convex program.<a class="footnoteRef" href="#fn55" id="fnref55"><sup>55</sup></a></p>

<p>This algorithm is similar to the standard <em>dual subgradient algorithm</em> of optimization theory, using a fixed stepsize of 1/V. <a class="footnoteRef" href="#fn56" id="fnref56"><sup>56</sup></a> However, a key difference is that the dual subgradient algorithm is typically analyzed under restrictive strict convexity assumptions that are needed for the <em>primal variables</em> x(t) to converge. There are many important cases where these variables do not converge to the optimal solution, and never even get near the optimal solution (this is the case for most <a href="Linear_programming" title="wikilink">linear programs</a>, as shown below). On the other hand, the drift-plus-penalty algorithm does not require strict convexity assumptions. It ensures that the <em>time averages</em> of the primals converge to a solution that is within O(1/V) of optimality, with O(V) bounds on queue sizes (it can be shown that this translates into an O(V^2) bound on convergence time).<a class="footnoteRef" href="#fn57" id="fnref57"><sup>57</sup></a></p>
<h3 id="drift-plus-penalty-algorithm-for-linear-programming">Drift-plus-penalty algorithm for linear programming</h3>

<p>Consider the special case of a <a href="Linear_programming" title="wikilink">linear program</a>. Specifically, suppose:</p>
<ul>
<li><math></math></li>
</ul>

<p>P(x(t)) = \sum_{n=1}^Nc_nx_n(t) </p>
<ul>
<li><math></math></li>
</ul>

<p>Y_i(x(t)) = \sum_{n=1}^Na_{in}x_n(t) - b_i \text{ } \forall i \in \{1, ..., K\} </p>

<p>for given real-valued constants (c_1, …, c_N), (a_{in}), (b_1, …, b_K). Then the above algorithm reduces to the following: Every slot t and for each variable n in {1, …, N}, choose x_n(t) in [x_{min,n}, x_{max,n}] to minimize the expression:</p>

<p>

<math display="inline" id="Drift_plus_penalty:106">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mrow>
     <mrow>
      <mi>V</mi>
      <msub>
       <mi>c</mi>
       <mi>n</mi>
      </msub>
     </mrow>
     <mo>+</mo>
     <mrow>
      <msubsup>
       <mo largeop="true" symmetric="true">∑</mo>
       <mrow>
        <mi>i</mi>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <mi>K</mi>
      </msubsup>
      <mrow>
       <msub>
        <mi>Q</mi>
        <mi>i</mi>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>t</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <msub>
        <mi>a</mi>
        <mrow>
         <mi>i</mi>
         <mi>n</mi>
        </mrow>
       </msub>
      </mrow>
     </mrow>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
   <msub>
    <mi>x</mi>
    <mi>n</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>V</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>c</ci>
        <ci>n</ci>
       </apply>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <ci>i</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>K</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>Q</ci>
         <ci>i</ci>
        </apply>
        <ci>t</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>a</ci>
         <apply>
          <times></times>
          <ci>i</ci>
          <ci>n</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>n</ci>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [Vc_{n}+\sum_{i=1}^{K}Q_{i}(t)a_{in}]x_{n}(t)
  </annotation>
 </semantics>
</math>

</p>

<p>Then update queues Q_i(t) as before. This amounts to choosing each variable x_i(t) according to the simple <em>bang-bang</em> control policy:</p>

<p>

<math display="inline" id="Drift_plus_penalty:107">
 <semantics>
  <mrow>
   <mrow>
    <mtext>Choose</mtext>
    <msub>
     <mi>x</mi>
     <mi>i</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>x</mi>
      <mrow>
       <mrow>
        <mi>m</mi>
        <mi>i</mi>
        <mi>n</mi>
       </mrow>
       <mo>,</mo>
       <mi>i</mi>
      </mrow>
     </msub>
     <mtext>if</mtext>
     <mi>V</mi>
     <msub>
      <mi>c</mi>
      <mi>n</mi>
     </msub>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>K</mi>
     </msubsup>
     <mrow>
      <msub>
       <mi>Q</mi>
       <mi>i</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <msub>
       <mi>a</mi>
       <mrow>
        <mi>i</mi>
        <mi>n</mi>
       </mrow>
      </msub>
     </mrow>
    </mrow>
   </mrow>
   <mo>≥</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <mtext>Choose</mtext>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>i</ci>
      </apply>
      <ci>t</ci>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <list>
         <apply>
          <times></times>
          <ci>m</ci>
          <ci>i</ci>
          <ci>n</ci>
         </apply>
         <ci>i</ci>
        </list>
       </apply>
       <mtext>if</mtext>
       <ci>V</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>c</ci>
        <ci>n</ci>
       </apply>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <ci>i</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>K</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>Q</ci>
         <ci>i</ci>
        </apply>
        <ci>t</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>a</ci>
         <apply>
          <times></times>
          <ci>i</ci>
          <ci>n</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <geq></geq>
     <share href="#.cmml">
     </share>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{Choose }x_{i}(t)=x_{min,i}\text{ if }Vc_{n}+\sum_{i=1}^{K}Q_{i}(t)a_{in}\geq
0
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Drift_plus_penalty:108">
 <semantics>
  <mrow>
   <mrow>
    <mtext>Choose</mtext>
    <msub>
     <mi>x</mi>
     <mi>i</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>x</mi>
      <mrow>
       <mrow>
        <mi>m</mi>
        <mi>a</mi>
        <mi>x</mi>
       </mrow>
       <mo>,</mo>
       <mi>i</mi>
      </mrow>
     </msub>
     <mtext>if</mtext>
     <mi>V</mi>
     <msub>
      <mi>c</mi>
      <mi>n</mi>
     </msub>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>K</mi>
     </msubsup>
     <mrow>
      <msub>
       <mi>Q</mi>
       <mi>i</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <msub>
       <mi>a</mi>
       <mrow>
        <mi>i</mi>
        <mi>n</mi>
       </mrow>
      </msub>
     </mrow>
    </mrow>
   </mrow>
   <mo><</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <mtext>Choose</mtext>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>i</ci>
      </apply>
      <ci>t</ci>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <list>
         <apply>
          <times></times>
          <ci>m</ci>
          <ci>a</ci>
          <ci>x</ci>
         </apply>
         <ci>i</ci>
        </list>
       </apply>
       <mtext>if</mtext>
       <ci>V</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>c</ci>
        <ci>n</ci>
       </apply>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <ci>i</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>K</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>Q</ci>
         <ci>i</ci>
        </apply>
        <ci>t</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>a</ci>
         <apply>
          <times></times>
          <ci>i</ci>
          <ci>n</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <lt></lt>
     <share href="#.cmml">
     </share>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{Choose }x_{i}(t)=x_{max,i}\text{ if }Vc_{n}+\sum_{i=1}^{K}Q_{i}(t)a_{in}<0
  </annotation>
 </semantics>
</math>

</p>

<p>Since the primal variables x_i(t) are always either x_{min,i} or x_{max,i}, they can never converge to the optimal solution if the optimal solution is not a vertex point of the hyper-rectangle A. However, the <em>time-averages</em> of these bang-bang decisions indeed converge to an O(1/V) approximation of the optimal solution. For example, suppose that x_{min,1}=0, x_{max,1}=1, and suppose that all optimal solutions to the linear program have x_1 = 3/4. Then roughly 3/4 of the time the bang-bang decision for the first variable will be x_1(t)=1, and the remaining time it will be x_1(t) = 0.<a class="footnoteRef" href="#fn58" id="fnref58"><sup>58</sup></a></p>
<h2 id="related-links">Related links</h2>
<ul>
<li><a href="Backpressure_routing" title="wikilink">Backpressure routing</a></li>
<li><a href="Lyapunov_optimization" title="wikilink">Lyapunov optimization</a></li>
<li><a href="Convex_optimization" title="wikilink">Convex optimization</a></li>
<li><a href="Linear_programming" title="wikilink">Linear programming</a></li>
</ul>
<h2 id="references">References</h2>
<h2 id="primary-sources">Primary Sources</h2>
<ul>
<li>M. J. Neely. <em>Stochastic Network Optimization with Application to Communication and Queueing Systems</em>, Morgan &amp; Claypool, 2010.</li>
</ul>

<p>"</p>

<p><a href="Category:Networking_algorithms" title="wikilink">Category:Networking algorithms</a> <a href="Category:Queueing_theory" title="wikilink">Category:Queueing theory</a> <a href="Category:Stochastic_processes" title="wikilink">Category:Stochastic processes</a> <a href="Category:Scheduling_algorithms" title="wikilink">Category:Scheduling algorithms</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">M. J. Neely, "Energy Optimal Control for Time Varying Wireless Networks," IEEE Transactions on Information Theory, vol. 52, no. 7, pp. 2915-2934, July 2006.<a href="#fnref1">↩</a></li>
<li id="fn2">M. J. Neely, E. Modiano, and C. Li, "Fairness and Optimal Stochastic Control for Heterogeneous Networks," Proc. IEEE INFOCOM, March 2005.<a href="#fnref2">↩</a></li>
<li id="fn3">L. Tassiulas and A. Ephremides, "Stability Properties of Constrained Queueing Systems and Scheduling Policies for Maximum Throughput in Multihop Radio Networks, <em>IEEE Transactions on Automatic Control</em>, vol. 37, no. 12, pp. 1936-1948, Dec. 1992.<a href="#fnref3">↩</a></li>
<li id="fn4">L. Georgiadis, M. J. Neely, and L. Tassiulas, "Resource Allocation and Cross-Layer Control in Wireless Networks," <em>Foundations and Trends in Networking</em>, vol. 1, no. 1, pp. 1-149, 2006.<a href="#fnref4">↩</a></li>
<li id="fn5">M. J. Neely. <em>Stochastic Network Optimization with Application to Communication and Queueing Systems,</em> Morgan &amp; Claypool, 2010.<a href="#fnref5">↩</a></li>
<li id="fn6">M. J. Neely, "Distributed and Secure Computation of Convex Programs over a Network of Connected Processors," DCDIS Conf, Guelph, Ontario, July 2005<a href="#fnref6">↩</a></li>
<li id="fn7">S. Supittayapornpong and M. J. Neely, "Quality of Information Maximization for Wireless Networks via a Fully Separable Quadratic Policy," arXiv:1211.6162v2, Nov. 2012.<a href="#fnref7">↩</a></li>
<li id="fn8"></li>
<li id="fn9"></li>
<li id="fn10">L. Tassiulas and A. Ephremides, "Dynamic Server Allocation to Parallel Queues with Randomly Varying Connectivity," IEEE Transactions on Information Theory, vol. 39, no. 2, pp. 466-478, March 1993.<a href="#fnref10">↩</a></li>
<li id="fn11">M. J. Neely. Dynamic Power Allocation and Routing for Satellite and Wireless Networks with Time Varying Channels. Ph.D. Dissertation, Massachusetts Institute of Technology, LIDS. November 2003.<a href="#fnref11">↩</a></li>
<li id="fn12"></li>
<li id="fn13"></li>
<li id="fn14"></li>
<li id="fn15"></li>
<li id="fn16">R. Urgaonkar, B. Urgaonkar, M. J. Neely, A. Sivasubramaniam, "Optimal Power Cost Management Using Stored Energy in Data Centers," Proc. SIGMETRICS 2011.<a href="#fnref16">↩</a></li>
<li id="fn17">M. Baghaie, S. Moeller, B. Krishnamachari, "Energy Routing on the Future Grid: A Stochastic Network Optimization Approach," Proc. International Conf. on Power System Technology (POWERCON), Oct. 2010.<a href="#fnref17">↩</a></li>
<li id="fn18">M. J. Neely, A. S. Tehrani, and A. G. Dimakis, "Efficient Algorithms for Renewable Energy Allocation to Delay Tolerant Consumers," 1st IEEE International Conf. on Smart Grid Communications, 2010.<a href="#fnref18">↩</a></li>
<li id="fn19">M. J. Neely and L. Huang, "Dynamic Product Assembly and Inventory Control for Maximum Profit," Proc. IEEE Conf. on Decision and Control, Atlanta, GA, Dec. 2010.<a href="#fnref19">↩</a></li>
<li id="fn20"></li>
<li id="fn21"></li>
<li id="fn22"></li>
<li id="fn23"></li>
<li id="fn24"></li>
<li id="fn25"></li>
<li id="fn26"></li>
<li id="fn27"></li>
<li id="fn28"></li>
<li id="fn29">M. J. Neely, "Queue Stability and Probability 1 Convergence via Lyapunov Optimization," Journal of Applied Mathematics, vol. 2012, <a class="uri" href="doi:10.1155/2012/831909">doi:10.1155/2012/831909</a>.<a href="#fnref29">↩</a></li>
<li id="fn30"></li>
<li id="fn31"></li>
<li id="fn32"></li>
<li id="fn33">A. Stolyar, "Maximizing Queueing Network Utility subject to Stability: Greedy Primal-Dual Algorithm," <em>Queueing Systems</em>, vol. 50, no. 4, pp. 401-457, 2005.<a href="#fnref33">↩</a></li>
<li id="fn34">A. Stolyar, "Greedy Primal-Dual Algorithm for Dynamic Resource Allocation in Complex Networks," Queueing Systems, vol. 54, no. 3, pp. 203-220, 2006.<a href="#fnref34">↩</a></li>
<li id="fn35"></li>
<li id="fn36"></li>
<li id="fn37"></li>
<li id="fn38">A. Eryilmaz and R. Srikant, "Fair Resource Allocation in Wireless Networks using Queue-Length-Based Scheduling and Congestion Control," Proc. IEEE INFOCOM, March 2005.<a href="#fnref38">↩</a></li>
<li id="fn39">L. Huang and M. J. Neely, "Delay Reduction via Lagrange Multipliers in Stochastic Network Optimization," IEEE Trans. on Automatic Contro, vol. 56, no. 4, pp. 842-857, April 2011.<a href="#fnref39">↩</a></li>
<li id="fn40"></li>
<li id="fn41">S. Moeller, A. Sridharan, B. Krishnamachari, and O. Gnawali, "Routing without Routes: The Backpressure Collection Protocol," Proc. IPSN 2010.<a href="#fnref41">↩</a></li>
<li id="fn42">L. Huang, S. Moeller, M. J. Neely, and B. Krishnamachari, "LIFO-Backpressure Achieves Near Optimal Utility-Delay Tradeoff," IEEE/ACM Transactions on Networking, to appear.<a href="#fnref42">↩</a></li>
<li id="fn43"></li>
<li id="fn44"></li>
<li id="fn45"></li>
<li id="fn46"></li>
<li id="fn47"></li>
<li id="fn48">R. Agrawal and V. Subramanian, "Optimality of certain channel aware scheduling policies," Proc. 40th Annual Allerton Conf. on Communication, Control, and Computing, Monticello, IL, Oct. 2002.<a href="#fnref48">↩</a></li>
<li id="fn49">H. Kushner and P. Whiting, "Asymptotic Properties of Proportional-Fair Sharing Algorithms," Proc. 40th Annual Allerton Conf. on Communication, Control, and Computing, Monticello, IL, Oct. 2002.<a href="#fnref49">↩</a></li>
<li id="fn50"></li>
<li id="fn51">C. Li and M. J. Neely, "Network utility maximization over partially observable Markovian channels," Performance Evaluation, dx.doi.org/10.1016/j.peva.2012.10.003.<a href="#fnref51">↩</a></li>
<li id="fn52">M. J. Neely, "Dynamic Optimization and Learning for Renewal Systems," IEEE Transactions on Automatic Control, vol. 58, no. 1, pp. 32-46, Jan. 2013.<a href="#fnref52">↩</a></li>
<li id="fn53"></li>
<li id="fn54"></li>
<li id="fn55"></li>
<li id="fn56">D. P. Bertsekas and A. Nedic and A. E. Ozdaglar. <em>Convex Analysis and Optimization</em>, Boston: Athena Scientific, 2003.<a href="#fnref56">↩</a></li>
<li id="fn57"></li>
<li id="fn58"></li>
</ol>
</section>
</body>
</html>
