<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1444">Smooth number</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Smooth number</h1>
<hr/>

<p>In <a href="number_theory" title="wikilink">number theory</a>, a <strong>smooth (or friable) number</strong> is an <a class="uri" href="integer" title="wikilink">integer</a> which <a href="integer_factorization" title="wikilink">factors</a> completely into small <a href="prime_number" title="wikilink">prime numbers</a>. The term seems to have been coined by <a href="Leonard_Adleman" title="wikilink">Leonard Adleman</a>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> Smooth numbers are especially important in <a class="uri" href="cryptography" title="wikilink">cryptography</a> relying on factorization. The 2-smooth numbers are just the <a href="Power_of_two" title="wikilink">powers of 2</a>.</p>
<h2 id="definition">Definition</h2>

<p>A <a href="negative_and_positive_numbers" title="wikilink">positive</a> <a class="uri" href="integer" title="wikilink">integer</a> is called <var>B</var>-<strong>smooth</strong> if none of its <a href="prime_factor" title="wikilink">prime factors</a> is greater than <var>B</var>. For example, 1,620 has prime factorization 2<sup>2</sup> × 3<sup>4</sup> × 5; therefore 1,620 is 5-smooth because none of its prime factors are greater than 5. This definition includes numbers that lack some of the smaller prime factors; for example, both 10 and 12 are 5-smooth, despite the fact that they miss out prime factors 3 and 5 respectively. 5-smooth numbers are also called <em><a href="regular_number" title="wikilink">regular numbers</a></em> or <em>Hamming numbers</em>; 7-smooth numbers are also called <em>humble</em>, and sometimes called <em>highly composite</em>[<a class="uri" href="http://oeis.org/search?q=humble+number&amp;sort">http://oeis.org/search?q=humble+number&amp;sort;</a>;=&amp;language;=&amp;go;=Search], although this conflicts with <a href="highly_composite_number" title="wikilink">another meaning of that term</a>.</p>

<p>Note that <var>B</var> does not have to be a prime factor. If the largest prime factor of a number is <var>p</var> then the number is <var>B</var>-smooth for any <var>B</var> ≥ <var>p</var>. Usually <var>B</var> is given as a prime, but <a href="composite_number" title="wikilink">composite numbers</a> work as well. A number is <var>B</var>-smooth <a href="if_and_only_if" title="wikilink">if and only if</a> it is <var>p</var>-smooth, where <var>p</var> is the largest prime less than or equal to <var>B</var>.</p>
<h2 id="applications">Applications</h2>

<p>An important practical application of smooth numbers is for <a href="fast_Fourier_transform" title="wikilink">fast Fourier transform</a> (FFT) algorithms such as the <a href="Cooley–Tukey_FFT_algorithm" title="wikilink">Cooley–Tukey FFT algorithm</a> that operate by recursively breaking down a problem of a given size <em>n</em> into problems the size of its factors. By using <em>B</em>-smooth numbers, one ensures that the base cases of this recursion are small primes, for which efficient algorithms exist. (Large prime sizes require less-efficient algorithms such as <a href="Bluestein's_FFT_algorithm" title="wikilink">Bluestein's FFT algorithm</a>.)</p>

<p>5-smooth or <a href="regular_number" title="wikilink">regular numbers</a> play a special role in <a href="Babylonian_mathematics" title="wikilink">Babylonian mathematics</a>.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> They are also important in <a href="music_theory" title="wikilink">music theory</a>,<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> (see <a href="Limit_(music)" title="wikilink">Limit (music)</a>) and the problem of generating these numbers efficiently has been used as a test problem for <a href="functional_programming" title="wikilink">functional programming</a>.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>

<p>Smooth numbers have a number of applications to cryptography.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> Although most applications involve <a class="uri" href="cryptanalysis" title="wikilink">cryptanalysis</a> (e.g. the fastest known <a href="integer_factorization" title="wikilink">integer factorization</a> algorithms), the <a href="Very_smooth_hash" title="wikilink">VSH</a> hash function is one example of a constructive use of smoothness to obtain a <a href="Provably_secure_cryptographic_hash_function" title="wikilink">provably secure design</a>.</p>
<h2 id="distribution">Distribution</h2>

<p>Let 

<math display="inline" id="Smooth_number:0">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Ψ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Ψ</ci>
    <interval closure="open">
     <ci>x</ci>
     <ci>y</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle\Psi(x,y)
  </annotation>
 </semantics>
</math>

 denote the number of <em>y</em>-smooth integers less than or equal to <em>x</em> (the de Bruijn function).</p>

<p>If the smoothness bound <em>B</em> is fixed and small, there is a good estimate for 

<math display="inline" id="Smooth_number:1">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Ψ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>B</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Ψ</ci>
    <interval closure="open">
     <ci>x</ci>
     <ci>B</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle\Psi(x,B)
  </annotation>
 </semantics>
</math>

:</p>

<p>

<math display="block" id="Smooth_number:2">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi mathvariant="normal">Ψ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mi>B</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>∼</mo>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <mrow>
       <mi>π</mi>
       <mrow>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>B</mi>
         <mo stretchy="false">)</mo>
        </mrow>
        <mo lspace="0pt" rspace="3.5pt">!</mo>
       </mrow>
      </mrow>
     </mfrac>
     <mrow>
      <munder>
       <mo largeop="true" movablelimits="false" symmetric="true">∏</mo>
       <mrow>
        <mi>p</mi>
        <mo>≤</mo>
        <mi>B</mi>
       </mrow>
      </munder>
      <mfrac>
       <mrow>
        <mi>log</mi>
        <mi>x</mi>
       </mrow>
       <mrow>
        <mi>log</mi>
        <mi>p</mi>
       </mrow>
      </mfrac>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">similar-to</csymbol>
    <apply>
     <times></times>
     <ci>normal-Ψ</ci>
     <interval closure="open">
      <ci>x</ci>
      <ci>B</ci>
     </interval>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <times></times>
       <ci>π</ci>
       <apply>
        <factorial></factorial>
        <ci>B</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <csymbol cd="latexml">product</csymbol>
       <apply>
        <leq></leq>
        <ci>p</ci>
        <ci>B</ci>
       </apply>
      </apply>
      <apply>
       <divide></divide>
       <apply>
        <log></log>
        <ci>x</ci>
       </apply>
       <apply>
        <log></log>
        <ci>p</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Psi(x,B)\sim\frac{1}{\pi(B)!}\prod_{p\leq B}\frac{\log x}{\log p}.
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Smooth_number:3">
 <semantics>
  <mrow>
   <mi>π</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>B</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>π</ci>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle{\pi(B)}
  </annotation>
 </semantics>
</math>

 denotes the number of primes less than or equal to 

<math display="inline" id="Smooth_number:4">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle B
  </annotation>
 </semantics>
</math>

.</p>

<p>Otherwise, define the parameter <em>u</em> as <em>u</em> = log <em>x</em> / log <em>y</em>: that is, <em>x</em> = <em>y</em><sup><em>u</em></sup>. Then,</p>

<p>

<math display="block" id="Smooth_number:5">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">Ψ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <mi>x</mi>
      <mo>⋅</mo>
      <mi>ρ</mi>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>u</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>O</mi>
     <mrow>
      <mo>(</mo>
      <mfrac>
       <mi>x</mi>
       <mrow>
        <mi>log</mi>
        <mi>y</mi>
       </mrow>
      </mfrac>
      <mo>)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>normal-Ψ</ci>
     <interval closure="open">
      <ci>x</ci>
      <ci>y</ci>
     </interval>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <ci>normal-⋅</ci>
       <ci>x</ci>
       <ci>ρ</ci>
      </apply>
      <ci>u</ci>
     </apply>
     <apply>
      <times></times>
      <ci>O</ci>
      <apply>
       <divide></divide>
       <ci>x</ci>
       <apply>
        <log></log>
        <ci>y</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Psi(x,y)=x\cdot\rho(u)+O\left(\frac{x}{\log y}\right)
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Smooth_number:6">
 <semantics>
  <mrow>
   <mi>ρ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>u</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>ρ</ci>
    <ci>u</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle\rho(u)
  </annotation>
 </semantics>
</math>

 is the <a href="Dickman_function" title="wikilink">Dickman function</a>.</p>
<h2 id="powersmooth-numbers">Powersmooth numbers</h2>

<p>Further, <em>m</em> is called <em>B</em>-<strong>powersmooth</strong> (or <em>B</em>-<strong>ultrafriable</strong>) if all prime <em>powers</em> 

<math display="inline" id="Smooth_number:7">
 <semantics>
  <msup>
   <mi>p</mi>
   <mi>ν</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>p</ci>
    <ci>ν</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle p^{\nu}
  </annotation>
 </semantics>
</math>

 dividing <em>m</em> satisfy:</p>

<p>

<math display="block" id="Smooth_number:8">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>p</mi>
     <mi>ν</mi>
    </msup>
    <mo>≤</mo>
    <mi>B</mi>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>p</ci>
     <ci>ν</ci>
    </apply>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p^{\nu}\leq B.\,
  </annotation>
 </semantics>
</math>

</p>

<p>For example, 2<sup>4</sup>3<sup>2</sup>5<sup>1</sup> is 5-smooth but is not 5-powersmooth (because there are several prime powers greater than 5, <em>e.g.</em>, 

<math display="inline" id="Smooth_number:9">
 <semantics>
  <mrow>
   <msup>
    <mn>3</mn>
    <mn>2</mn>
   </msup>
   <mo>=</mo>
   <mn>9</mn>
   <mo>≰</mo>
   <mn>5</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">3</cn>
      <cn type="integer">2</cn>
     </apply>
     <cn type="integer">9</cn>
    </apply>
    <apply>
     <csymbol cd="latexml">not-less-than-nor-greater-than</csymbol>
     <share href="#.cmml">
     </share>
     <cn type="integer">5</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   3^{2}=9\nleq 5
  </annotation>
 </semantics>
</math>

 or 

<math display="inline" id="Smooth_number:10">
 <semantics>
  <mrow>
   <msup>
    <mn>2</mn>
    <mn>3</mn>
   </msup>
   <mo>></mo>
   <mn>5</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <cn type="integer">3</cn>
    </apply>
    <cn type="integer">5</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{3}>5
  </annotation>
 </semantics>
</math>

). It is 16-powersmooth since its greatest prime factor power is 2<sup>4</sup> = 16. The number is also 17-powersmooth, 18-powersmooth, etc.</p>

<p><em>B</em>-smooth and <em>B</em>-powersmooth numbers have applications in number theory, such as in <a href="Pollard's_p_−_1_algorithm" title="wikilink">Pollard's <em>p</em> − 1 algorithm</a>. Such applications are often said to work with "smooth numbers," with no <em>B</em> specified; this means the numbers involved must be <em>B</em>-powersmooth for some unspecified small number <em>B</em>; as <em>B</em> increases, the performance of the algorithm or method in question degrades rapidly. For example, the <a href="Pohlig–Hellman_algorithm" title="wikilink">Pohlig–Hellman algorithm</a> for computing <a href="discrete_logarithm" title="wikilink">discrete logarithms</a> has a running time of <a href="asymptotic_notation" title="wikilink">O</a>(<em>B</em><sup>1/2</sup>) for <a href="group_(mathematics)" title="wikilink">groups</a> of <em>B</em>-smooth order.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Rough_number" title="wikilink">Rough number</a></li>
<li><a href="Størmer's_theorem" title="wikilink">Størmer's theorem</a></li>
<li><a href="Highly_composite_number" title="wikilink">Highly composite number</a></li>
</ul>
<h2 id="notes">Notes</h2>
<references>
</references>
<h2 id="references">References</h2>
<ul>
<li>G. Tenenbaum, <em>Introduction to analytic and probabilistic number theory</em>, (CUP, 1995) ISBN 0-521-41261-7</li>
<li><a href="A._Granville" title="wikilink">A. Granville</a>, <a href="http://www.dms.umontreal.ca/~andrew/PDF/msrire.pdf"><em>Smooth numbers: Computational number theory and beyond</em></a>, Proc. of MSRI workshop, 2008</li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li></li>
</ul>

<p>The <a href="On-Line_Encyclopedia_of_Integer_Sequences" title="wikilink">On-Line Encyclopedia of Integer Sequences</a> (OEIS) lists <em>B</em>-smooth numbers for small <em>B</em>s:</p>
<ul>
<li>2-smooth numbers: <a href="OEIS:A000079" title="wikilink">A000079</a> (2<sup><em>i</em></sup>)</li>
<li>3-smooth numbers: <a href="OEIS:A003586" title="wikilink">A003586</a> (2<sup><em>i</em></sup>3<sup><em>j</em></sup>)</li>
<li>5-smooth numbers: <a href="OEIS:A051037" title="wikilink">A051037</a> (2<sup><em>i</em></sup>3<sup><em>j</em></sup>5<sup><em>k</em></sup>)</li>
<li>7-smooth numbers: <a href="OEIS:A002473" title="wikilink">A002473</a> (2<sup><em>i</em></sup>3<sup><em>j</em></sup>5<sup><em>k</em></sup>7<sup><em>l</em></sup>)</li>
<li>11-smooth numbers: <a href="OEIS:A051038" title="wikilink">A051038</a> (etc...)</li>
<li>13-smooth numbers: <a href="OEIS:A080197" title="wikilink">A080197</a></li>
<li>17-smooth numbers: <a href="OEIS:A080681" title="wikilink">A080681</a></li>
<li>19-smooth numbers: <a href="OEIS:A080682" title="wikilink">A080682</a></li>
<li>23-smooth numbers: <a href="OEIS:A080683" title="wikilink">A080683</a></li>
</ul>

<p>"</p>

<p><a href="Category:Analytic_number_theory" title="wikilink">Category:Analytic number theory</a> <a href="Category:Integer_sequences" title="wikilink">Category:Integer sequences</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">M. E. Hellman, J. M. Reyneri, "Fast computation of discrete logarithms in GF (q)", in <em>Advances in Cryptology: Proceedings of CRYPTO '82</em> (eds. D. Chaum, R. Rivest, A. Sherman), New York: Plenum Press, 1983, p. 3–13, <a href="http://scholar.google.com/scholar?q=%22Adleman+refers+to+integers+which+factor+completely+into+small+primes+as+smooth+numbers.%22">online quote</a> at <a href="Google_Scholar" title="wikilink">Google Scholar</a>: "Adleman refers to integers which factor completely into small primes as “smooth” numbers."<a href="#fnref1">↩</a></li>
<li id="fn2">.<a href="#fnref2">↩</a></li>
<li id="fn3">.<a href="#fnref3">↩</a></li>
<li id="fn4">.<a href="#fnref4">↩</a></li>
<li id="fn5">David Naccache, Igor Shparlinski, "Divisibility, Smoothness and Cryptographic Applications", <a class="uri" href="http://eprint.iacr.org/2008/437.pdf">http://eprint.iacr.org/2008/437.pdf</a><a href="#fnref5">↩</a></li>
</ol>
</section>
</body>
</html>
