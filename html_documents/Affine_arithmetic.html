<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="426">Affine arithmetic</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Affine arithmetic</h1>
<hr/>

<p><strong>Affine arithmetic</strong> (<strong>AA</strong>) is a model for <a href="self-validated_computation" title="wikilink">self-validated</a> <a href="numerical_analysis" title="wikilink">numerical analysis</a>. In AA, the quantities of interest are represented as <a href="affine_combination" title="wikilink">affine combinations</a> (<strong>affine forms</strong>) of certain primitive variables, which stand for sources of uncertainty in the data or approximations made during the computation.</p>

<p>Affine arithmetic is meant to be an improvement on <a href="interval_arithmetic" title="wikilink">interval arithmetic</a> (IA), and is similar to <a href="generalized_interval_arithmetic" title="wikilink">generalized interval arithmetic</a>, first-order <a href="Taylor_arithmetic" title="wikilink">Taylor arithmetic</a>, the <a href="center-slope_model" title="wikilink">center-slope model</a>, and <a href="ellipsoid_calculus" title="wikilink">ellipsoid calculus</a> — in the sense that it is an automatic method to derive first-order guaranteed approximations to general formulas.</p>

<p>Affine arithmetic is potentially useful in every numeric problem where one needs guaranteed enclosures to smooth functions, such as solving <a href="equation_system" title="wikilink">systems</a> of non-linear equations, analyzing <a href="dynamical_system" title="wikilink">dynamical systems</a>, <a href="integral" title="wikilink">integrating</a> functions <a href="differential_equation" title="wikilink">differential equations</a>, etc. Applications include <a href="ray_tracing_(graphics)" title="wikilink">ray tracing</a>, <a href="2D_computer_graphics" title="wikilink">plotting</a> <a href="curve" title="wikilink">curves</a>, intersecting <a href="implicit_surface" title="wikilink">implicit</a> and <a href="parametric_surface" title="wikilink">parametric surfaces</a>, <a href="error_analysis_(mathematics)" title="wikilink">error analysis (mathematics)</a>, <a href="process_control" title="wikilink">process control</a>, worst-case analysis of <a href="electric_circuit" title="wikilink">electric circuits</a>, and more.</p>
<h2 id="definition">Definition</h2>

<p>In affine arithmetic, each input or computed quantity <em>x</em> is represented by a formula 

<math display="inline" id="Affine_arithmetic:0">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>x</mi>
     <mn>0</mn>
    </msub>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <msub>
      <mi>ϵ</mi>
      <mn>1</mn>
     </msub>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mrow>
      <msub>
       <mi>x</mi>
       <mn>2</mn>
      </msub>
      <msub>
       <mi>ϵ</mi>
       <mn>2</mn>
      </msub>
     </mrow>
     <mo>+</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>x</ci>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ϵ</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">limit-from</csymbol>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ϵ</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <plus></plus>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x=x_{0}+x_{1}\epsilon_{1}+x_{2}\epsilon_{2}+{}
  </annotation>
 </semantics>
</math>



<math display="inline" id="Affine_arithmetic:1">
 <semantics>
  <mi mathvariant="normal">⋯</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-⋯</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \cdots
  </annotation>
 </semantics>
</math>



<math display="inline" id="Affine_arithmetic:2">
 <semantics>
  <mrow>
   <mo>+</mo>
   <mrow>
    <msub>
     <mi>x</mi>
     <mi>n</mi>
    </msub>
    <msub>
     <mi>ϵ</mi>
     <mi>n</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ϵ</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {}+x_{n}\epsilon_{n}
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Affine_arithmetic:3">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>x</mi>
     <mn>0</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>x</mi>
     <mn>2</mn>
    </msub>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">2</cn>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{0},x_{1},x_{2},
  </annotation>
 </semantics>
</math>



<math display="inline" id="Affine_arithmetic:4">
 <semantics>
  <mrow>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-…</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \dots,
  </annotation>
 </semantics>
</math>



<math display="inline" id="Affine_arithmetic:5">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{n}
  </annotation>
 </semantics>
</math>

 are known floating-point numbers, and 

<math display="inline" id="Affine_arithmetic:6">
 <semantics>
  <mrow>
   <msub>
    <mi>ϵ</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>ϵ</mi>
    <mn>2</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>ϵ</mi>
    <mi>n</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ϵ</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ϵ</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ϵ</ci>
     <ci>n</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon_{1},\epsilon_{2},\epsilon_{n}
  </annotation>
 </semantics>
</math>

 are symbolic variables whose values are only known to lie in the range [-1,+1].</p>

<p>Thus, for example, a quantity <em>X</em> which is known to lie in the range [3,7] can be represented by the affine form 

<math display="inline" id="Affine_arithmetic:7">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>=</mo>
   <mrow>
    <mn>5</mn>
    <mo>+</mo>
    <mrow>
     <mn>2</mn>
     <msub>
      <mi>ϵ</mi>
      <mi>k</mi>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>x</ci>
    <apply>
     <plus></plus>
     <cn type="integer">5</cn>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ϵ</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x=5+2\epsilon_{k}
  </annotation>
 </semantics>
</math>

, for some <em>k</em>. Conversely, the form 

<math display="inline" id="Affine_arithmetic:8">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mn>10</mn>
     <mo>+</mo>
     <mrow>
      <mn>2</mn>
      <msub>
       <mi>ϵ</mi>
       <mn>3</mn>
      </msub>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mn>5</mn>
     <msub>
      <mi>ϵ</mi>
      <mn>8</mn>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>x</ci>
    <apply>
     <minus></minus>
     <apply>
      <plus></plus>
      <cn type="integer">10</cn>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ϵ</ci>
        <cn type="integer">3</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">5</cn>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ϵ</ci>
       <cn type="integer">8</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x=10+2\epsilon_{3}-5\epsilon_{8}
  </annotation>
 </semantics>
</math>

 implies that the corresponding quantity <em>X</em> lies in the range [3,17].</p>

<p>The sharing of a symbol 

<math display="inline" id="Affine_arithmetic:9">
 <semantics>
  <msub>
   <mi>ϵ</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ϵ</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon_{j}
  </annotation>
 </semantics>
</math>

 among two affine forms 

<math display="inline" id="Affine_arithmetic:10">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Affine_arithmetic:11">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

 implies that the corresponding quantities <em>X</em>, <em>Y</em> are partially dependent, in the sense that their joint range is smaller than the <a href="Cartesian_product" title="wikilink">Cartesian product</a> of their separate ranges. For example, if 

<math display="inline" id="Affine_arithmetic:12">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mn>10</mn>
     <mo>+</mo>
     <mrow>
      <mn>2</mn>
      <msub>
       <mi>ϵ</mi>
       <mn>3</mn>
      </msub>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mn>6</mn>
     <msub>
      <mi>ϵ</mi>
      <mn>8</mn>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>x</ci>
    <apply>
     <minus></minus>
     <apply>
      <plus></plus>
      <cn type="integer">10</cn>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ϵ</ci>
        <cn type="integer">3</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">6</cn>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ϵ</ci>
       <cn type="integer">8</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x=10+2\epsilon_{3}-6\epsilon_{8}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Affine_arithmetic:13">
 <semantics>
  <mrow>
   <mi>y</mi>
   <mo>=</mo>
   <mrow>
    <mn>20</mn>
    <mo>+</mo>
    <mrow>
     <mn>3</mn>
     <msub>
      <mi>ϵ</mi>
      <mn>4</mn>
     </msub>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mn>4</mn>
     <msub>
      <mi>ϵ</mi>
      <mn>8</mn>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>y</ci>
    <apply>
     <plus></plus>
     <cn type="integer">20</cn>
     <apply>
      <times></times>
      <cn type="integer">3</cn>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ϵ</ci>
       <cn type="integer">4</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">4</cn>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ϵ</ci>
       <cn type="integer">8</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y=20+3\epsilon_{4}+4\epsilon_{8}
  </annotation>
 </semantics>
</math>

, then the individual ranges of <em>X</em> and <em>Y</em> are [2,18] and [13,27], but the joint range of the pair (<em>X</em>,<em>Y</em>) is the <a class="uri" href="hexagon" title="wikilink">hexagon</a> with corners (2,27), (6,27), (18,19), (18,13), (14,13), (2,21) — which is a proper subset of the <a class="uri" href="rectangle" title="wikilink">rectangle</a> [2,18]×[13,27].</p>
<h2 id="affine-arithmetic-operations">Affine arithmetic operations</h2>

<p>Affine forms can be combined with the standard arithmetic operations or elementary functions, to obtain guaranteed approximations to formulas.</p>
<h3 id="affine-operations">Affine operations</h3>

<p>For example, given affine forms 

<math display="inline" id="Affine_arithmetic:14">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>,</mo>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>x</ci>
    <ci>y</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x,y
  </annotation>
 </semantics>
</math>

 for <em>X</em> and <em>Y</em>, one can obtain an affine form 

<math display="inline" id="Affine_arithmetic:15">
 <semantics>
  <mi>z</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>z</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z
  </annotation>
 </semantics>
</math>

 for <em>Z</em> = <em>X</em> + <em>Y</em> simply by adding the forms — that is, setting 

<math display="inline" id="Affine_arithmetic:16">
 <semantics>
  <msub>
   <mi>z</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>z</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z_{j}
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Affine_arithmetic:17">
 <semantics>
  <mo>←</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-←</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \leftarrow
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Affine_arithmetic:18">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mi>j</mi>
   </msub>
   <mo>+</mo>
   <msub>
    <mi>y</mi>
    <mi>j</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>j</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <ci>j</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{j}+y_{j}
  </annotation>
 </semantics>
</math>

 for every <em>j</em>. Similarly, one can compute an affine form 

<math display="inline" id="Affine_arithmetic:19">
 <semantics>
  <mi>z</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>z</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z
  </annotation>
 </semantics>
</math>

 for <em>Z</em> = 

<math display="inline" id="Affine_arithmetic:20">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>

<em>X</em>, where 

<math display="inline" id="Affine_arithmetic:21">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>

 is a known constant, by setting 

<math display="inline" id="Affine_arithmetic:22">
 <semantics>
  <msub>
   <mi>z</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>z</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z_{j}
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Affine_arithmetic:23">
 <semantics>
  <mo>←</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-←</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \leftarrow
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Affine_arithmetic:24">
 <semantics>
  <mrow>
   <mi>α</mi>
   <msub>
    <mi>x</mi>
    <mi>j</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>α</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>j</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha x_{j}
  </annotation>
 </semantics>
</math>

 for every <em>j</em>. This generalizes to arbitrary affine operations like <em>Z</em> = 

<math display="inline" id="Affine_arithmetic:25">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>

<em>X</em> + 

<math display="inline" id="Affine_arithmetic:26">
 <semantics>
  <mi>β</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>β</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta
  </annotation>
 </semantics>
</math>

<em>Y</em> + 

<math display="inline" id="Affine_arithmetic:27">
 <semantics>
  <mi>γ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>γ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gamma
  </annotation>
 </semantics>
</math>

.</p>
<h3 id="non-affine-operations">Non-affine operations</h3>

<p>A non-affine operation 

<math display="inline" id="Affine_arithmetic:28">
 <semantics>
  <mi>Z</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Z</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Affine_arithmetic:29">
 <semantics>
  <mo>←</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-←</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \leftarrow
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Affine_arithmetic:30">
 <semantics>
  <mrow>
   <mi>F</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo>,</mo>
    <mi>Y</mi>
    <mo>,</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">F</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">X</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">Y</csymbol>
     <ci>normal-,</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F(X,Y,
  </annotation>
 </semantics>
</math>



<math display="inline" id="Affine_arithmetic:31">
 <semantics>
  <mi mathvariant="normal">…</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-…</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \dots
  </annotation>
 </semantics>
</math>



<math display="inline" id="Affine_arithmetic:32">
 <semantics>
  <mo stretchy="false">)</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-)</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   )
  </annotation>
 </semantics>
</math>

, like multiplication 

<math display="inline" id="Affine_arithmetic:33">
 <semantics>
  <mi>Z</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Z</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Affine_arithmetic:34">
 <semantics>
  <mo>←</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-←</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \leftarrow
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Affine_arithmetic:35">
 <semantics>
  <mrow>
   <mi>X</mi>
   <mi>Y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>X</ci>
    <ci>Y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   XY
  </annotation>
 </semantics>
</math>

 or 

<math display="inline" id="Affine_arithmetic:36">
 <semantics>
  <mi>Z</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Z</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Affine_arithmetic:37">
 <semantics>
  <mo>←</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-←</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \leftarrow
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Affine_arithmetic:38">
 <semantics>
  <mrow>
   <mi>sin</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <sin></sin>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sin(X)
  </annotation>
 </semantics>
</math>

, cannot be performed exactly, since the result would not be an affine form of the 

<math display="inline" id="Affine_arithmetic:39">
 <semantics>
  <msub>
   <mi>ϵ</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ϵ</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon_{i}
  </annotation>
 </semantics>
</math>

. In that case, one should take a suitable affine function <em>G</em> that approximates <em>F</em> to first order, in the ranges implied by 

<math display="inline" id="Affine_arithmetic:40">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Affine_arithmetic:41">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

; and compute 

<math display="inline" id="Affine_arithmetic:42">
 <semantics>
  <mi>z</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>z</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Affine_arithmetic:43">
 <semantics>
  <mo>←</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-←</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \leftarrow
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Affine_arithmetic:44">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>y</mi>
    <mo>,</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">G</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-,</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G(x,y,
  </annotation>
 </semantics>
</math>



<math display="inline" id="Affine_arithmetic:45">
 <semantics>
  <mi mathvariant="normal">…</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-…</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \dots
  </annotation>
 </semantics>
</math>



<math display="inline" id="Affine_arithmetic:46">
 <semantics>
  <mrow>
   <mo stretchy="false">)</mo>
   <mo>+</mo>
   <mi>z</mi>
   <msub>
    <mi></mi>
    <mi>k</mi>
   </msub>
   <mi>ϵ</mi>
   <msub>
    <mi></mi>
    <mi>k</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-)</ci>
    <plus></plus>
    <csymbol cd="unknown">z</csymbol>
    <apply>
     <ci>k</ci>
    </apply>
    <csymbol cd="unknown">ϵ</csymbol>
    <apply>
     <ci>k</ci>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   )+z_{k}\epsilon_{k}
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Affine_arithmetic:47">
 <semantics>
  <msub>
   <mi>z</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>z</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z_{k}
  </annotation>
 </semantics>
</math>

 is an upper bound for the absolute error 

<math display="inline" id="Affine_arithmetic:48">
 <semantics>
  <mrow>
   <mo stretchy="false">|</mo>
   <mrow>
    <mi>F</mi>
    <mo>-</mo>
    <mi>G</mi>
   </mrow>
   <mo stretchy="false">|</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <abs></abs>
    <apply>
     <minus></minus>
     <ci>F</ci>
     <ci>G</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |F-G|
  </annotation>
 </semantics>
</math>

 in that range, and 

<math display="inline" id="Affine_arithmetic:49">
 <semantics>
  <msub>
   <mi>ϵ</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ϵ</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon_{k}
  </annotation>
 </semantics>
</math>

 is a new symbolic variable not occurring in any previous form.</p>

<p>The form 

<math display="inline" id="Affine_arithmetic:50">
 <semantics>
  <mi>z</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>z</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z
  </annotation>
 </semantics>
</math>

 then gives a guaranteed enclosure for the quantity <em>Z</em>; moreover, the affine forms 

<math display="inline" id="Affine_arithmetic:51">
 <semantics>
  <mrow>
   <mrow>
    <mi>x</mi>
    <mo>,</mo>
    <mi>y</mi>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>x</ci>
    <ci>y</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x,y,
  </annotation>
 </semantics>
</math>



<math display="inline" id="Affine_arithmetic:52">
 <semantics>
  <mi mathvariant="normal">…</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-…</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \dots
  </annotation>
 </semantics>
</math>



<math display="inline" id="Affine_arithmetic:53">
 <semantics>
  <mrow>
   <mo>,</mo>
   <mi>z</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-,</ci>
    <csymbol cd="unknown">z</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ,z
  </annotation>
 </semantics>
</math>

 jointly provide a guaranteed enclosure for the point (<em>X</em>,<em>Y</em>,...,<em>Z</em>), which is often much smaller than the Cartesian product of the ranges of the individual forms.</p>
<h3 id="chaining-operations">Chaining operations</h3>

<p>Systematic use of this method allows arbitrary computations on given quantities to be replaced by equivalent computations on their affine forms, while preserving first-order correlations between the input and output and guaranteeing the complete enclosure of the joint range. One simply replaces each arithmetic operation or elementary function call in the formula by a call to the corresponding AA library routine.</p>

<p>For smooth functions, the approximation errors made at each step are proportional to the square <em>h</em><sup>2</sup> of the width <em>h</em> of the input intervals. For this reason, affine arithmetic will often yield much tighter bounds than standard interval arithmetic (whose errors are proportional to <em>h</em>).</p>
<h3 id="roundoff-errors">Roundoff errors</h3>

<p>In order to provide guaranteed enclosure, affine arithmetic operations must account for the roundoff errors in the computation of the resulting coefficients 

<math display="inline" id="Affine_arithmetic:54">
 <semantics>
  <msub>
   <mi>z</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>z</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z_{j}
  </annotation>
 </semantics>
</math>

. This cannot be done by rounding each 

<math display="inline" id="Affine_arithmetic:55">
 <semantics>
  <msub>
   <mi>z</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>z</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z_{j}
  </annotation>
 </semantics>
</math>

 in a specific direction, because any such rounding would falsify the dependencies between affine forms that share the symbol 

<math display="inline" id="Affine_arithmetic:56">
 <semantics>
  <msub>
   <mi>ϵ</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ϵ</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon_{j}
  </annotation>
 </semantics>
</math>

. Instead, one must compute an upper bound 

<math display="inline" id="Affine_arithmetic:57">
 <semantics>
  <msub>
   <mi>δ</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>δ</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta_{j}
  </annotation>
 </semantics>
</math>

 to the roundoff error of each 

<math display="inline" id="Affine_arithmetic:58">
 <semantics>
  <msub>
   <mi>z</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>z</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z_{j}
  </annotation>
 </semantics>
</math>

, and add all those 

<math display="inline" id="Affine_arithmetic:59">
 <semantics>
  <msub>
   <mi>δ</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>δ</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta_{j}
  </annotation>
 </semantics>
</math>

 to the coefficient 

<math display="inline" id="Affine_arithmetic:60">
 <semantics>
  <msub>
   <mi>z</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>z</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z_{k}
  </annotation>
 </semantics>
</math>

 of the new symbol 

<math display="inline" id="Affine_arithmetic:61">
 <semantics>
  <msub>
   <mi>ϵ</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ϵ</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon_{k}
  </annotation>
 </semantics>
</math>

 (rounding up). Thus, because of roundoff errors, even affine operations like <em>Z</em> = 

<math display="inline" id="Affine_arithmetic:62">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>

<em>X</em> and <em>Z</em> = <em>X</em> + <em>Y</em> will add the extra term 

<math display="inline" id="Affine_arithmetic:63">
 <semantics>
  <mrow>
   <msub>
    <mi>z</mi>
    <mi>k</mi>
   </msub>
   <msub>
    <mi>ϵ</mi>
    <mi>k</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>z</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ϵ</ci>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z_{k}\epsilon_{k}
  </annotation>
 </semantics>
</math>

.</p>

<p>The handling of roundoff errors increases the code complexity and execution time of AA operations. In applications where those errors are known to be unimportant (because they are dominated by uncertainties in the input data and/or by the linearization errors), one may use a simplified AA library that does not implement roundoff error control.</p>
<h2 id="affine-projection-model">Affine projection model</h2>

<p>Affine arithmetic can be viewed in matrix form as follows. Let 

<math display="inline" id="Affine_arithmetic:64">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>X</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>X</mi>
     <mn>2</mn>
    </msub>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <cn type="integer">2</cn>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{1},X_{2},
  </annotation>
 </semantics>
</math>



<math display="inline" id="Affine_arithmetic:65">
 <semantics>
  <mrow>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-…</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \dots,
  </annotation>
 </semantics>
</math>



<math display="inline" id="Affine_arithmetic:66">
 <semantics>
  <msub>
   <mi>X</mi>
   <mi>m</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>X</ci>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{m}
  </annotation>
 </semantics>
</math>

 be all input and computed quantities in use at some point during a computation. The affine forms for those quantities can be represented by a single coefficient matrix <em>A</em> and a vector <em>b</em>, where element 

<math display="inline" id="Affine_arithmetic:67">
 <semantics>
  <msub>
   <mi>A</mi>
   <mrow>
    <mi>i</mi>
    <mo>,</mo>
    <mi>j</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>A</ci>
    <list>
     <ci>i</ci>
     <ci>j</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{i,j}
  </annotation>
 </semantics>
</math>

 is the coefficient of symbol 

<math display="inline" id="Affine_arithmetic:68">
 <semantics>
  <msub>
   <mi>ϵ</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ϵ</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon_{j}
  </annotation>
 </semantics>
</math>

 in the affine form of <em>

<math display="inline" id="Affine_arithmetic:69">
 <semantics>
  <msub>
   <mi>X</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>X</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{i}
  </annotation>
 </semantics>
</math>

</em>; and 

<math display="inline" id="Affine_arithmetic:70">
 <semantics>
  <msub>
   <mi>b</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>b</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b_{i}
  </annotation>
 </semantics>
</math>

 is the independent term of that form. Then the joint range of the quantities — that is, the range of the point 

<math display="inline" id="Affine_arithmetic:71">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msub>
    <mi>X</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>X</mi>
    <mn>2</mn>
   </msub>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-(</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-,</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>normal-,</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (X_{1},X_{2},
  </annotation>
 </semantics>
</math>



<math display="inline" id="Affine_arithmetic:72">
 <semantics>
  <mrow>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-…</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \dots,
  </annotation>
 </semantics>
</math>



<math display="inline" id="Affine_arithmetic:73">
 <semantics>
  <mrow>
   <msub>
    <mi>X</mi>
    <mi>m</mi>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <ci>m</ci>
    </apply>
    <ci>normal-)</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{m})
  </annotation>
 </semantics>
</math>

 — is the image of the hypercube 

<math display="inline" id="Affine_arithmetic:74">
 <semantics>
  <mrow>
   <msup>
    <mi>U</mi>
    <mi>n</mi>
   </msup>
   <mo>=</mo>
   <msup>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
    <mi>n</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>U</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <interval closure="closed">
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <plus></plus>
       <cn type="integer">1</cn>
      </apply>
     </interval>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U^{n}=[-1,+1]^{n}
  </annotation>
 </semantics>
</math>

 by the affine map from 

<math display="inline" id="Affine_arithmetic:75">
 <semantics>
  <msup>
   <mi>U</mi>
   <mi>n</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>U</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U^{n}
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Affine_arithmetic:76">
 <semantics>
  <msup>
   <mi>R</mi>
   <mi>m</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>R</ci>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R^{m}
  </annotation>
 </semantics>
</math>

 defined by 

<math display="inline" id="Affine_arithmetic:77">
 <semantics>
  <mi>ϵ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϵ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Affine_arithmetic:78">
 <semantics>
  <mo>→</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-→</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \to
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Affine_arithmetic:79">
 <semantics>
  <mrow>
   <mrow>
    <mi>A</mi>
    <mi>ϵ</mi>
   </mrow>
   <mo>+</mo>
   <mi>b</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <times></times>
     <ci>A</ci>
     <ci>ϵ</ci>
    </apply>
    <ci>b</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\epsilon+b
  </annotation>
 </semantics>
</math>

.</p>

<p>The range of this affine map is a <a class="uri" href="zonotope" title="wikilink">zonotope</a> bounding the joint range of the quantities 

<math display="inline" id="Affine_arithmetic:80">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>X</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>X</mi>
     <mn>2</mn>
    </msub>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <cn type="integer">2</cn>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{1},X_{2},
  </annotation>
 </semantics>
</math>



<math display="inline" id="Affine_arithmetic:81">
 <semantics>
  <mrow>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-…</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \dots,
  </annotation>
 </semantics>
</math>



<math display="inline" id="Affine_arithmetic:82">
 <semantics>
  <msub>
   <mi>X</mi>
   <mi>m</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>X</ci>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{m}
  </annotation>
 </semantics>
</math>

. Thus one could say that AA is a "zonotope arithmetic". Each step of AA usually entails adding one more row and one more column to the matrix <em>A</em>.</p>
<h2 id="affine-form-simplification">Affine form simplification</h2>

<p>Since each AA operation generally creates a new symbol 

<math display="inline" id="Affine_arithmetic:83">
 <semantics>
  <msub>
   <mi>ϵ</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ϵ</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon_{k}
  </annotation>
 </semantics>
</math>

, the number of terms in an affine form may be proportional to the number of operations used to compute it. Thus, it is often necessary to apply "symbol condensation" steps, where two or more symbols 

<math display="inline" id="Affine_arithmetic:84">
 <semantics>
  <msub>
   <mi>ϵ</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ϵ</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon_{k}
  </annotation>
 </semantics>
</math>

 are replaced by a smaller set of new symbols. Geometrically, this means replacing a complicated zonotope <em>P</em> by a simpler zonotope <em>Q</em> that encloses it. This operation can be done without destroying the first-order approximation property of the final zonotope.</p>
<h2 id="implementation">Implementation</h2>
<h3 id="matrix-implementation">Matrix implementation</h3>

<p>Affine arithmetic can be implemented by a global array <em>A</em> and a global vector <em>b</em>, as described above. This approach is reasonably adequate when the set of quantities to be computed is small and known in advance. In this approach, the programmer must maintain externally the correspondence between the row indices and the quantities of interest. Global variables hold the number <em>m</em> of affine forms (rows) computed so far, and the number <em>n</em> of symbols (columns) used so far; these are automatically updated at each AA operation.</p>
<h3 id="vector-implementation">Vector implementation</h3>

<p>Alternatively, each affine form can be implemented as a separate vector of coefficients. This approach is more convenient for programming, especially when there are calls to library procedures that may use AA internally. Each affine form can be given a mnemonic name; it can be allocated when needed, be passed to procedures, and reclaimed when no longer needed. The AA code then looks much closer to the original formula. A global variable holds the number <em>n</em> of symbols used so far.</p>
<h3 id="sparse-vector-implementation">Sparse vector implementation</h3>

<p>On fairly long computations, the set of "live" quantities (that will be used in future computations) is much smaller than the set of all computed quantities; and ditto for the set of "live" symbols 

<math display="inline" id="Affine_arithmetic:85">
 <semantics>
  <msub>
   <mi>ϵ</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ϵ</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon_{j}
  </annotation>
 </semantics>
</math>

. In this situation, the matrix and vector implementations are too wasteful of time and space.</p>

<p>In such situations, one should use a <a href="sparse_array" title="wikilink">sparse</a> implementation. Namely, each affine form is stored as a list of pairs (j,

<math display="inline" id="Affine_arithmetic:86">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{j}
  </annotation>
 </semantics>
</math>

), containing only the terms with non-zero coefficient 

<math display="inline" id="Affine_arithmetic:87">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{j}
  </annotation>
 </semantics>
</math>

. For efficiency, the terms should be sorted in order of <em>j</em>. This representation makes the AA operations somewhat more complicated; however, the cost of each operation becomes proportional to the number of nonzero terms appearing in the operands, instead of the number of total symbols used so far.</p>

<p>This is the representation used by LibAffa.</p>
<h2 id="references">References</h2>
<ul>
<li>L. H. de Figueiredo and J. Stolfi (2004) "Affine arithmetic: concepts and applications." <em>Numerical Algorithms</em> <strong>37</strong> (1–4), 147–158.</li>
<li>J. L. D. Comba and J. Stolfi (1993), "Affine arithmetic and its applications to computer graphics". <em>Proc. SIBGRAPI'93 — VI Simpósio Brasileiro de Computação Gráfica e Processamento de Imagens (Recife, BR)</em>, 9–18.</li>
<li>L. H. de Figueiredo and J. Stolfi (1996), "Adaptive enumeration of implicit surfaces with affine arithmetic". <em>Computer Graphics Forum</em>, <strong>15</strong> <em>5</em>, 287–296.</li>
<li>W. Heidrich (1997), "A compilation of affine arithmetic versions of common math library functions". Technical Report 1997-3, Universität Erlangen-Nürnberg.</li>
<li>M. Kashiwagi (1998), "An all solution algorithm using affine arithmetic". <em>NOLTA'98 — 1998 International Symposium on Nonlinear Theory and its Applications (Crans-Montana, Switzerland)</em>, 14–17.</li>
<li>L. Egiziano, N. Femia, and G. Spagnuolo (1998), "New approaches to the true worst-case evaluation in circuit tolerance and sensitivity analysis — Part II: Calculation of the outer solution using affine arithmetic". <em>Proc. COMPEL'98 — 6th Workshop on Computer in Power Electronics (Villa Erba, Italy)</em>, 19–22.</li>
<li>W. Heidrich, Ph. Slusallek, and H.-P. Seidel (1998), "Sampling procedural shaders using affine arithmetic". <em>ACM Transactions on Graphics (TOG)</em>, <strong>17</strong> <em>3</em>, 158–176.</li>
<li>F. Messine and A. Mahfoudi (1998), "Use of affine arithmetic in interval optimization algorithms to solve multidimensional scaling problems". <em>Proc. SCAN'98 — IMACS/GAMM International Symposium on Scientific Computing, Computer Arithmetic and Validated Numerics (Budapest, Hungary)</em>, 22–25.</li>
<li>A. de Cusatis Jr., L. H. Figueiredo, and M. Gattass (1999), "Interval methods for ray casting surfaces with affine arithmetic". <em>Proc. SIBGRAPI'99 — 12th Brazilian Symposium on Computer Graphics and Image Processing</em>, 65–71.</li>
<li>K. Bühler and W. Barth (2000), "A new intersection algorithm for parametric surfaces based on linear interval estimations". <em>Proc. SCAN 2000 / Interval 2000 — 9th GAMM-IMACS International Symposium on Scientific Computing, Computer Arithmetic, and Validated Numerics</em>, ???–???.</li>
<li>I. Voiculescu, J. Berchtold, A. Bowyer, R. R. Martin, and Q. Zhang (2000), "Interval and affine arithmetic for surface location of power- and Bernstein-form polynomials". <em>Proc. Mathematics of Surfaces IX</em>, 410–423. Springer, ISBN 1-85233-358-8.</li>
<li>Q. Zhang and R. R. Martin (2000), "Polynomial evaluation using affine arithmetic for curve drawing". <em>Proc. of Eurographics UK 2000 Conference</em>, 49–56. ISBN 0-9521097-9-4.</li>
<li>D. Michelucci (2000), "Reliable computations for dynamic systems". <em>Proc. SCAN 2000 / Interval 2000 — 9th GAMM-IMACS International Symposium on Scientific Computing, Computer Arithmetic, and Validated Numerics</em>, ???–???.</li>
<li>N. Femia and G. Spagnuolo (2000), "True worst-case circuit tolerance analysis using genetic algorithm and affine arithmetic — Part I". <em>IEEE Transactions on Circuits and Systems</em>, <strong>47</strong> <em>9</em>, 1285–1296.</li>
<li>R. Martin, H. Shou, I. Voiculescu, and G. Wang (2001), "A comparison of Bernstein hull and affine arithmetic methods for algebraic curve drawing". <em>Proc. Uncertainty in Geometric Computations</em>, 143–154. Kluwer Academic Publishers, ISBN 0-7923-7309-X.</li>
<li>A. Bowyer, R. Martin, H. Shou, and I. Voiculescu (2001), "Affine intervals in a CSG geometric modeller". <em>Proc. Uncertainty in Geometric Computations</em>, 1–14. Kluwer Academic Publishers, ISBN 0-7923-7309-X.</li>
<li>T. Kikuchi and M. Kashiwagi (2001), "Elimination of non-existence regions of the solution of nonlinear equations using affine arithmetic". <em>Proc. NOLTA'01 — 2001 International Symposium on Nonlinear Theory and its Applications</em>.</li>
<li>T. Miyata and M. Kashiwagi (2001), "On range evaluation of polynomials of affine arithmetic". <em>Proc. NOLTA'01 - 2001 International Symposium on Nonlinear Theory and its Applications</em>.</li>
<li>Y. Kanazawa and S. Oishi (2002), "A numerical method of proving the existence of solutions for nonlinear ODEs using affine arithmetic". <em>Proc. SCAN'02 — 10th GAMM-IMACS International Symposium on Scientific Computing, Computer Arithmetic, and Validated Numerics</em>.</li>
<li>H. Shou, R. R.Martin, I. Voiculescu, A. Bowyer, and G. Wang (2002), "Affine arithmetic in matrix form for polynomial evaluation and algebraic curve drawing". <em>Progress in Natural Science</em>, <strong>12</strong> <em>1</em>, 77–81.</li>
<li>A. Lemke, L. Hedrich, and E. Barke (2002), "Analog circuit sizing based on formal methods using affine arithmetic". <em>Proc. ICCAD-2002 — International Conference on Computer Aided Design</em>, 486–489.</li>
<li>F. Messine (2002), "Extensions of affine arithmetic: Application to unconstrained global optimization". <em>Journal of Universal Computer Science</em>, <strong>8</strong> <em>11</em>, 992–1015.</li>
<li>K. Bühler (2002), "Implicit linear interval estimations". <em>Proc. 18th Spring Conference on Computer Graphics (Budmerice, Slovakia)</em>, 123–132. ACM Press, ISBN 1-58113-608-0.</li>
<li>L. H. de Figueiredo, J. Stolfi, and L. Velho (2003), "Approximating parametric curves with strip trees using affine arithmetic". <em>Computer Graphics Forum</em>, <strong>22</strong> <em>2</em>, 171–179.</li>
<li>C. F. Fang, T. Chen, and R. Rutenbar (2003), "Floating-point error analysis based on affine arithmetic". <em>Proc. 2003 International Conf. on Acoustic, Speech and Signal Processing</em>.</li>
<li>A. Paiva, L. H. de Figueiredo, and J. Stolfi (2006), "Robust visualization of strange attractors using affine arithmetic". <em>Computers &amp; Graphics</em>, <strong>30</strong> <em>6</em>, 1020– 1026.</li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.ic.unicamp.br/~stolfi/EXPORT/projects/affine-arith/Welcome.html">1</a> Stolfi's page on AA.</li>
<li><a href="http://savannah.nongnu.org/projects/libaffa">2</a> LibAffa, an LGPL implementation of affine arithmetic.</li>
<li><a href="http://sourceforge.net/projects/asol/">3</a> ASOL, a branch-and-prune method to find all solutions to systems of nonlinear equations using affine arithmetic</li>
</ul>

<p>"</p>

<p><a href="Category:Numerical_analysis" title="wikilink">Category:Numerical analysis</a> <a href="Category:Affine_geometry" title="wikilink">Category:Affine geometry</a></p>
</body>
</html>
