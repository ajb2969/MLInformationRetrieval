<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1462">Closest string</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Closest string</h1>
<hr/>

<p>In theoretical computer science, <strong>closest string</strong> is the name of an <a class="uri" href="NP-hard" title="wikilink">NP-hard</a> computational problem,<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> which tries to find the geometrical center of a set of input strings.</p>

<p>To understand the word "center" it is necessary to define a distance between two strings. Usually, this problem is studied with the <a href="Hamming_distance" title="wikilink">Hamming distance</a> in mind.</p>
<h2 id="formal-definition">Formal definition</h2>

<p>More formally, given <em>n</em> length-<em>m</em> strings <em>s</em><sub>1</sub>, <em>s</em><sub>2</sub>, ..., <em>s</em><sub><em>n</em></sub>, the closest string problem seeks for a new length-<em>m</em> string <em>s</em> such that <em>d</em>(<em>s</em>,<em>s</em><sub><em>i</em></sub>) ≤ <em>k</em> for all <em>i</em>, where <em>d</em> denotes the <a href="Hamming_distance" title="wikilink">Hamming distance</a>, and where <em>k</em> is as small as possible.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> A <a href="decision_problem" title="wikilink">decision problem</a> version of the closest string problem, which is <a class="uri" href="NP-complete" title="wikilink">NP-complete</a>, instead takes <em>k</em> as another input and asks for any string that is within Hamming distance <em>k</em> of all the input strings.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>

<p>The closest string problem can be seen as an instance of the <a href="1-center_problem" title="wikilink">1-center problem</a> in which the distances between elements are measured using Hamming distance.</p>
<h2 id="motivation">Motivation</h2>

<p>In <a class="uri" href="bioinformatics" title="wikilink">bioinformatics</a>, the closest string problem is an intensively studied facet of the problem of finding signals in <a class="uri" href="DNA" title="wikilink">DNA</a>.</p>
<h2 id="simplifications-and-data-reductions">Simplifications and data reductions</h2>

<p>Instances of closest string may contain information that is not essential to the problem. In some sense, the usual input of closest string contains information, that does not contribute to the hardness of the problem. For example, if some strings contain the character <em>a</em>, but none contains the character <em>z</em>, replacing all <em>a</em>s with <em>z</em>s would yield an essentially equivalent instance, that is: from a solution of the modified instance, the original solution can be restored, and vice versa.</p>
<h3 id="normalizing-the-input">Normalizing the input</h3>

<p>When all input strings that share the same length are written on top of each other, they form a matrix. Certain row types have essentially the same implications to the solution. For example, replacing a column with entries (<em>a</em>,<em>a</em>,<em>b</em>) with another column (<em>x</em>,<em>x</em>,<em>y</em>) might lead to a different solution string, but cannot affect solvability, because both columns express the same structure, viz. the first two entries being equal, but different from the third one.</p>

<p>An input instance can be <em>normalized</em> by replacing, in each column, the character that occurs the most often with <em>a</em>, the character that occurs the second most often with <em>b</em>, and so forth. Given a solution to the normalized instance, the original instance can be found by remapping the characters of the solution to its original version in every column.</p>

<p>The order of the columns does not contribute to the hardness of the problem. That means, if we permute all input strings according to a certain permutation π and obtain a solution string <em>s</em> to that modified instance, then π<sup>−1</sup>(<em>s</em>) will be a solution to the original instance.</p>
<h4 id="example">Example</h4>

<p> Given an instance with three input strings <em>uvwx</em>, <em>xuwv</em>, and <em>xvwu</em>. This could be written as a matrix like this:</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p><em>u</em></p></td>
<td style="text-align: left;">
<p><em>v</em></p></td>
<td style="text-align: left;">
<p><em>w</em></p></td>
<td style="text-align: left;">
<p><em>x</em></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><em>x</em></p></td>
<td style="text-align: left;">
<p><em>u</em></p></td>
<td style="text-align: left;">
<p><em>w</em></p></td>
<td style="text-align: left;">
<p><em>v</em></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><em>x</em></p></td>
<td style="text-align: left;">
<p><em>v</em></p></td>
<td style="text-align: left;">
<p><em>w</em></p></td>
<td style="text-align: left;">
<p><em>u</em></p></td>
</tr>
</tbody>
</table>

<p>The first column has the values (<em>u</em>,<em>x</em>,<em>x</em>). As <em>x</em> is the character that appears the most often, we replace it by <em>a</em>, and we replace <em>u</em>, the second most often character, by <em>b</em>, obtaining the new first column (<em>b</em>,<em>a</em>,<em>a</em>). Doing the same with all columns gives the normalized instance</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p><em>b</em></p></td>
<td style="text-align: left;">
<p><em>a</em></p></td>
<td style="text-align: left;">
<p><em>a</em></p></td>
<td style="text-align: left;">
<p><em>a</em></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><em>a</em></p></td>
<td style="text-align: left;">
<p><em>b</em></p></td>
<td style="text-align: left;">
<p><em>a</em></p></td>
<td style="text-align: left;">
<p><em>b</em></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><em>a</em></p></td>
<td style="text-align: left;">
<p><em>a</em></p></td>
<td style="text-align: left;">
<p><em>a</em></p></td>
<td style="text-align: left;">
<p><em>c</em></p></td>
</tr>
</tbody>
</table>
<h4 id="data-reduction-obtained-from-normalization">Data reduction obtained from normalization</h4>

<p>Normalizing the input reduces the alphabet size to at most the number of input strings. This can be useful for algorithms whose running times depend on the alphabet size.</p>
<h2 id="approximability">Approximability</h2>

<p>Li et al. evolved a <a href="polynomial-time_approximation_scheme" title="wikilink">polynomial-time approximation scheme</a><a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> which is practically unusable because of the large hidden constants.</p>
<h2 id="fixed-parameter-tractability">Fixed-parameter tractability</h2>

<p>Closest String can be solved in 

<math display="inline" id="Closest_string:0">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mrow>
      <mi>k</mi>
      <mi>L</mi>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mrow>
       <mi>k</mi>
       <mi>d</mi>
      </mrow>
      <mo>⋅</mo>
      <msup>
       <mi>d</mi>
       <mi>d</mi>
      </msup>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>k</ci>
      <ci>L</ci>
     </apply>
     <apply>
      <ci>normal-⋅</ci>
      <apply>
       <times></times>
       <ci>k</ci>
       <ci>d</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>d</ci>
       <ci>d</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(kL+kd\cdot d^{d})
  </annotation>
 </semantics>
</math>

, where <em>k</em> is the number of input strings, <em>L</em> is the length of all strings and <em>d</em> is the desired maximum distance from the solution string to any input string.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>
<h2 id="relations-to-other-problems">Relations to other problems</h2>

<p>Closest string is a special case of the more general <a href="closest_substring" title="wikilink">closest substring</a> problem, which is strictly more difficult. While closest string turns out to be <a href="fixed-parameter_tractable" title="wikilink">fixed-parameter tractable</a> in a number of ways, closest substring is [[Parameterized complexity#W hierarchy|W[1]-hard]] with regard to these parameters.</p>
<h2 id="references">References</h2>
<references>
</references>

<p>"</p>

<p><a href="Category:NP-complete_problems" title="wikilink">Category:NP-complete problems</a> <a href="Category:Formal_languages" title="wikilink">Category:Formal languages</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
</ol>
</section>
</body>
</html>
