<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="179">Quantum operation</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Quantum operation</h1>
<hr/>

<p>In <a href="quantum_mechanics" title="wikilink">quantum mechanics</a>, a <strong>quantum operation</strong> (also known as <strong>quantum dynamical map</strong> or <strong><a href="quantum_process" title="wikilink">quantum process</a></strong>) is a mathematical formalism used to describe a broad class of transformations that a quantum mechanical system can undergo. This was first discussed as a general stochastic transformation for a density matrix by <a href="George_Sudarshan" title="wikilink">George Sudarshan</a>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> The quantum operation formalism describes not only unitary time evolution or symmetry transformations of isolated systems, but also the effects of measurement and transient interactions with an environment. In the context of <a href="quantum_computation" title="wikilink">quantum computation</a>, a quantum operation is called a <a href="quantum_channel" title="wikilink">quantum channel</a>.</p>

<p>Note that some authors use the term "quantum operation" to refer specifically to <a href="completely_positive" title="wikilink">completely positive</a> (CP) and non-trace-increasing maps on the space of density matricies, and the term "<a href="quantum_channel" title="wikilink">quantum channel</a>" to refer to the subset of those that are strictly trace-preserving.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>

<p>Quantum operations are formulated in terms of the <a href="density_matrix" title="wikilink">density operator</a> description of a quantum mechanical system. Rigorously, a quantum operation is a <a class="uri" href="linear" title="wikilink">linear</a>, <a href="completely_positive" title="wikilink">completely positive</a> map from the set of density operators into itself.</p>

<p>Some <a href="quantum_process" title="wikilink">quantum processes</a> cannot be captured within the quantum operation formalism;<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> in principle, the density matrix of a quantum system can undergo completely arbitrary time evolution. Quantum operations are generalized by <a href="quantum_instrument" title="wikilink">quantum instruments</a>, which capture the classical information obtained during measurements, in addition to the <a href="quantum_information" title="wikilink">quantum information</a>.</p>
<h2 id="background">Background</h2>

<p>The <a href="Schrödinger_picture" title="wikilink">Schrödinger picture</a> provides a satisfactory account of <a href="time_evolution" title="wikilink">time evolution</a> of state for a quantum mechanical system under certain assumptions. These assumptions include</p>
<ul>
<li>The system is non-relativistic</li>
<li>The system is isolated.</li>
</ul>

<p>The Schrödinger picture for time evolution has several mathematically equivalent formulations. One such formulation expresses the <a href="derivative" title="wikilink">time rate of change</a> of the state via the <a href="Schrödinger_equation" title="wikilink">Schrödinger equation</a>. A more suitable formulation for this exposition is expressed as follows:</p>
<dl>
<dd>The effect of the passage of <em>t</em> units of time on the state of an isolated system <strong>S</strong> is given by a unitary operator <em>U</em><sub><em>t</em></sub> on the Hilbert space <em>H</em> associated to <strong>S</strong>.
</dd>
</dl>

<p>This means that if the system is in a state corresponding to <em>v</em> ∈ <em>H</em> at an instant of time <em>s</em>, then the state after <em>t</em> units of time will be <em>U</em><sub><em>t</em></sub> <em>v</em>. For <a href="Special_relativity" title="wikilink">relativistic</a> systems, there is no universal time parameter, but we can still formulate the effect of certain reversible transformations on the quantum mechanical system. For instance, state transformations relating observers in different frames of reference are given by unitary transformations. In any case, these state transformations carry pure states into pure states; this is often formulated by saying that in this idealized framework, there is no <a class="uri" href="decoherence" title="wikilink">decoherence</a>.</p>

<p>For interacting (or open) systems, such as those undergoing measurement, the situation is entirely different. To begin with, the state changes experienced by such systems cannot be accounted for exclusively by a transformation on the set of pure states (that is, those associated to vectors of norm 1 in <em>H</em>). After such an interaction, a system in a pure state φ may no longer be in the pure state φ. In general it will be in a statistical mix of a sequence of pure states φ<sub>1</sub>,..., φ<sub><em>k</em></sub> with respective probabilities λ<sub>1</sub>,..., λ<sub><em>k</em></sub>. The transition from a pure state to a mixed state is known as decoherence.</p>

<p>Numerous mathematical formalisms have been established to handle the case of an interacting system. The quantum operation formalism emerged around 1983 from work of <a href="Karl_Kraus_(physicist)" title="wikilink">Karl Kraus</a>, who relied on the earlier mathematical work of <a href="Man-Duen_Choi" title="wikilink">Man-Duen Choi</a>. It has the advantage that it expresses operations such as measurement as a mapping from density states to density states. In particular, the effect of quantum operations stays within the set of density states.</p>
<h2 id="definition">Definition</h2>

<p>Recall that a <a href="density_operator" title="wikilink">density operator</a> is a non-negative operator on a <a href="Hilbert_space" title="wikilink">Hilbert space</a> with unit trace.</p>

<p>Mathematically, a quantum operation is a <a href="linear_map" title="wikilink">linear map</a> Φ between spaces of <a href="trace_class" title="wikilink">trace class</a> operators on Hilbert spaces <em>H</em> and <em>G</em> such that</p>
<ul>
<li>If <em>S</em> is a density operator, Tr(Φ(<em>S</em>)) ≤ 1.</li>
<li>Φ is <a href="Choi's_theorem_on_completely_positive_maps" title="wikilink">completely positive</a>, that is for any natural number <em>n</em>, and any square matrix of size <em>n</em> whose entries are trace-class operators</li>
</ul>

<p>

<math display="block" id="Quantum_operation:0">
 <semantics>
  <mrow>
   <mo>[</mo>
   <mtable displaystyle="true">
    <mtr>
     <mtd columnalign="center">
      <msub>
       <mi>S</mi>
       <mn>11</mn>
      </msub>
     </mtd>
     <mtd columnalign="center">
      <mi mathvariant="normal">⋯</mi>
     </mtd>
     <mtd columnalign="center">
      <msub>
       <mi>S</mi>
       <mrow>
        <mn>1</mn>
        <mi>n</mi>
       </mrow>
      </msub>
     </mtd>
    </mtr>
    <mtr>
     <mtd columnalign="center">
      <mi mathvariant="normal">⋮</mi>
     </mtd>
     <mtd columnalign="center">
      <mi mathvariant="normal">⋱</mi>
     </mtd>
     <mtd columnalign="center">
      <mi mathvariant="normal">⋮</mi>
     </mtd>
    </mtr>
    <mtr>
     <mtd columnalign="center">
      <msub>
       <mi>S</mi>
       <mrow>
        <mi>n</mi>
        <mn>1</mn>
       </mrow>
      </msub>
     </mtd>
     <mtd columnalign="center">
      <mi mathvariant="normal">⋯</mi>
     </mtd>
     <mtd columnalign="center">
      <msub>
       <mi>S</mi>
       <mrow>
        <mi>n</mi>
        <mi>n</mi>
       </mrow>
      </msub>
     </mtd>
    </mtr>
   </mtable>
   <mo>]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>S</ci>
      <cn type="integer">11</cn>
     </apply>
     <ci>normal-⋯</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>S</ci>
      <apply>
       <times></times>
       <cn type="integer">1</cn>
       <ci>n</ci>
      </apply>
     </apply>
    </matrixrow>
    <matrixrow>
     <ci>normal-⋮</ci>
     <ci>normal-⋱</ci>
     <ci>normal-⋮</ci>
    </matrixrow>
    <matrixrow>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>S</ci>
      <apply>
       <times></times>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>normal-⋯</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>S</ci>
      <apply>
       <times></times>
       <ci>n</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{bmatrix}S_{11}&\cdots&S_{1n}\\
\vdots&\ddots&\vdots\\
S_{n1}&\cdots&S_{nn}\end{bmatrix}
  </annotation>
 </semantics>
</math>

 and which is non-negative, then</p>

<p>

<math display="block" id="Quantum_operation:1">
 <semantics>
  <mrow>
   <mo>[</mo>
   <mtable displaystyle="true">
    <mtr>
     <mtd columnalign="center">
      <mrow>
       <mi mathvariant="normal">Φ</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>S</mi>
         <mn>11</mn>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mtd>
     <mtd columnalign="center">
      <mi mathvariant="normal">⋯</mi>
     </mtd>
     <mtd columnalign="center">
      <mrow>
       <mi mathvariant="normal">Φ</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>S</mi>
         <mrow>
          <mn>1</mn>
          <mi>n</mi>
         </mrow>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mtd>
    </mtr>
    <mtr>
     <mtd columnalign="center">
      <mi mathvariant="normal">⋮</mi>
     </mtd>
     <mtd columnalign="center">
      <mi mathvariant="normal">⋱</mi>
     </mtd>
     <mtd columnalign="center">
      <mi mathvariant="normal">⋮</mi>
     </mtd>
    </mtr>
    <mtr>
     <mtd columnalign="center">
      <mrow>
       <mi mathvariant="normal">Φ</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>S</mi>
         <mrow>
          <mi>n</mi>
          <mn>1</mn>
         </mrow>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mtd>
     <mtd columnalign="center">
      <mi mathvariant="normal">⋯</mi>
     </mtd>
     <mtd columnalign="center">
      <mrow>
       <mi mathvariant="normal">Φ</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>S</mi>
         <mrow>
          <mi>n</mi>
          <mi>n</mi>
         </mrow>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mtd>
    </mtr>
   </mtable>
   <mo>]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <apply>
      <times></times>
      <ci>normal-Φ</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>S</ci>
       <cn type="integer">11</cn>
      </apply>
     </apply>
     <ci>normal-⋯</ci>
     <apply>
      <times></times>
      <ci>normal-Φ</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>S</ci>
       <apply>
        <times></times>
        <cn type="integer">1</cn>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
    </matrixrow>
    <matrixrow>
     <ci>normal-⋮</ci>
     <ci>normal-⋱</ci>
     <ci>normal-⋮</ci>
    </matrixrow>
    <matrixrow>
     <apply>
      <times></times>
      <ci>normal-Φ</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>S</ci>
       <apply>
        <times></times>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
     <ci>normal-⋯</ci>
     <apply>
      <times></times>
      <ci>normal-Φ</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>S</ci>
       <apply>
        <times></times>
        <ci>n</ci>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{bmatrix}\Phi(S_{11})&\cdots&\Phi(S_{1n})\\
\vdots&\ddots&\vdots\\
\Phi(S_{n1})&\cdots&\Phi(S_{nn})\end{bmatrix}
  </annotation>
 </semantics>
</math>

 is also non-negative. In other words, Φ is completely positive if 

<math display="inline" id="Quantum_operation:2">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Φ</mi>
   <mo>⊗</mo>
   <msub>
    <mi>I</mi>
    <mi>n</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">tensor-product</csymbol>
    <ci>normal-Φ</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>I</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Phi\otimes I_{n}
  </annotation>
 </semantics>
</math>

 is positive for all <em>n</em>, where 

<math display="inline" id="Quantum_operation:3">
 <semantics>
  <msub>
   <mi>I</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>I</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I_{n}
  </annotation>
 </semantics>
</math>

 denotes the identity map on the <a class="uri" href="C*-algebra" title="wikilink">C*-algebra</a> of 

<math display="inline" id="Quantum_operation:4">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>×</mo>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>n</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n\times n
  </annotation>
 </semantics>
</math>

 matrices.</p>

<p>Note that, by the first condition, quantum operations may not preserve the normalization property of statistical ensembles. In probabilistic terms, quantum operations may be <a class="uri" href="sub-Markovian" title="wikilink">sub-Markovian</a>. In order that a quantum operation preserve the set of density matrices, we need the additional assumption that it is trace-preserving.</p>

<p>In the context of <a href="quantum_information" title="wikilink">quantum information</a>, the quantum operations defined here, i.e. completely positive maps that do not increase the trace, are also called <a href="quantum_channel" title="wikilink">quantum channels</a> or <em>stochastic maps</em>. The formulation here is confined to channels between quantum states; however, it can be extended to include classical states as well, therefore allowing quantum and classical information to be handled simultaneously.</p>
<h2 id="kraus-operators">Kraus operators</h2>

<p>Kraus' theorem characterizes maps that model quantum operations between density operators of quantum state:</p>

<p><strong>Theorem</strong>.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> Let <em>H</em> and <em>G</em> be Hilbert spaces of dimension <em>n</em> and <em>m</em> respectively, and Φ be a quantum operation taking the density matrices acting on <em>H</em> to those acting on <em>G</em>. Then there are matrices</p>

<p>

<math display="block" id="Quantum_operation:5">
 <semantics>
  <msub>
   <mrow>
    <mo stretchy="false">{</mo>
    <msub>
     <mi>B</mi>
     <mi>i</mi>
    </msub>
    <mo stretchy="false">}</mo>
   </mrow>
   <mrow>
    <mn>1</mn>
    <mo>≤</mo>
    <mi>i</mi>
    <mo>≤</mo>
    <mrow>
     <mi>n</mi>
     <mi>m</mi>
    </mrow>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <set>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>B</ci>
      <ci>i</ci>
     </apply>
    </set>
    <apply>
     <and></and>
     <apply>
      <leq></leq>
      <cn type="integer">1</cn>
      <ci>i</ci>
     </apply>
     <apply>
      <leq></leq>
      <share href="#.cmml">
      </share>
      <apply>
       <times></times>
       <ci>n</ci>
       <ci>m</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{B_{i}\}_{1\leq i\leq nm}
  </annotation>
 </semantics>
</math>

 mapping <em>G</em> to <em>H</em>, such that</p>

<p>

<math display="block" id="Quantum_operation:6">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi mathvariant="normal">Φ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>S</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mi>i</mi>
     </munder>
     <mrow>
      <msubsup>
       <mi>B</mi>
       <mi>i</mi>
       <mo>*</mo>
      </msubsup>
      <mi>S</mi>
      <msub>
       <mi>B</mi>
       <mi>i</mi>
      </msub>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>normal-Φ</ci>
     <ci>S</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <ci>i</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>B</ci>
        <times></times>
       </apply>
       <ci>i</ci>
      </apply>
      <ci>S</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>B</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Phi(S)=\sum_{i}B^{*}_{i}SB_{i}.
  </annotation>
 </semantics>
</math>

 Conversely, any map Φ of this form is a quantum operation provided</p>

<p>

<math display="block" id="Quantum_operation:7">
 <semantics>
  <mrow>
   <mrow>
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mi>i</mi>
    </munder>
    <mrow>
     <msub>
      <mi>B</mi>
      <mi>i</mi>
     </msub>
     <msubsup>
      <mi>B</mi>
      <mi>i</mi>
      <mo>*</mo>
     </msubsup>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mn>1.</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <ci>i</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>B</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>B</ci>
        <times></times>
       </apply>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
    <cn type="float">1.</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{i}B_{i}B^{*}_{i}\leq 1.
  </annotation>
 </semantics>
</math>

</p>

<p>The matrices 

<math display="inline" id="Quantum_operation:8">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <msub>
    <mi>B</mi>
    <mi>i</mi>
   </msub>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>B</ci>
     <ci>i</ci>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{B_{i}\}
  </annotation>
 </semantics>
</math>

 are called <em>Kraus operators</em>. (Sometimes they are known as <em>noise operators</em> or <em>error operators</em>, especially in the context <a href="quantum_information_processing" title="wikilink">quantum information processing</a> where the quantum operation represents the noisy, error-producing effects of the environment.) The <a href="Stinespring_factorization_theorem" title="wikilink">Stinespring factorization theorem</a> extends the above result to arbitrary separable Hilbert spaces <em>H</em> and <em>G</em>. There, <em>S</em> is replaced by a trace class operator and 

<math display="inline" id="Quantum_operation:9">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <msub>
    <mi>B</mi>
    <mi>i</mi>
   </msub>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>B</ci>
     <ci>i</ci>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{B_{i}\}
  </annotation>
 </semantics>
</math>

 by a sequence of bounded operators.</p>
<h3 id="unitary-equivalence">Unitary equivalence</h3>

<p>Kraus matrices are not uniquely determined by the quantum operation Φ in general. For example, different <a href="Cholesky_factorization" title="wikilink">Cholesky factorizations</a> of the Choi matrix might give different sets of Kraus operators. The following theorem states that all systems of Kraus matrices which represent the same quantum operation are related by a unitary transformation:</p>

<p><strong>Theorem</strong>. Let Φ be a (not necessarily trace preserving) quantum operation on a finite-dimensional Hilbert space <em>H</em> with two representing sequences of Kraus matrices {<em>B</em><sub><em>i</em></sub>}<sub><em>i</em>≤ N</sub> and {<em>C</em><sub><em>i</em></sub>}<sub><em>i</em>≤ N</sub>. Then there is a unitary operator matrix 

<math display="inline" id="Quantum_operation:10">
 <semantics>
  <msub>
   <mrow>
    <mo lspace="5.3pt" stretchy="false">(</mo>
    <msub>
     <mi>u</mi>
     <mrow>
      <mi>i</mi>
      <mi>j</mi>
     </mrow>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mi>i</mi>
    <mi>j</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>u</ci>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>j</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>i</ci>
     <ci>j</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \;(u_{ij})_{ij}
  </annotation>
 </semantics>
</math>

 such that</p>

<p>

<math display="block" id="Quantum_operation:11">
 <semantics>
  <mrow>
   <msub>
    <mi>C</mi>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <munder>
    <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
    <mi>j</mi>
   </munder>
   <msub>
    <mi>u</mi>
    <mrow>
     <mi>i</mi>
     <mi>j</mi>
    </mrow>
   </msub>
   <msub>
    <mi>B</mi>
    <mi>j</mi>
   </msub>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <ci>i</ci>
    </apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <sum></sum>
     <ci>j</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>u</ci>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>j</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>B</ci>
     <ci>j</ci>
    </apply>
    <ci>normal-.</ci>
    <ci></ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{i}=\sum_{j}u_{ij}B_{j}.\quad
  </annotation>
 </semantics>
</math>

</p>

<p>In the infinite-dimensional case, this generalizes to a relationship between two <a href="Stinespring_factorization_theorem" title="wikilink">minimal Stinespring representations</a>.</p>

<p>It is a consequence of Stinespring's theorem that all quantum operations can be implemented via unitary evolution after coupling a suitable <a href="ancilla_(quantum_computing)" title="wikilink">ancilla</a> to the original system.</p>
<h3 id="remarks">Remarks</h3>

<p>These results can be also derived from <a href="Choi's_theorem_on_completely_positive_maps" title="wikilink">Choi's theorem on completely positive maps</a>, characterizing a completely positive finite-dimensional map by a unique Hermitian-positive density operator (<a href="Choi_matrix" title="wikilink">Choi matrix</a>) with respect to the trace. Among all possible Kraus representations of a given <a href="quantum_channel" title="wikilink">channel</a>, there exists a canonical form distinguished by the orthogonality relation of Kraus operators, 

<math display="inline" id="Quantum_operation:12">
 <semantics>
  <mrow>
   <mrow>
    <mi>Tr</mi>
    <msubsup>
     <mi>A</mi>
     <mi>i</mi>
     <mo>†</mo>
    </msubsup>
    <msub>
     <mi>A</mi>
     <mi>j</mi>
    </msub>
   </mrow>
   <mo>∼</mo>
   <msub>
    <mi>δ</mi>
    <mrow>
     <mi>i</mi>
     <mi>j</mi>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">similar-to</csymbol>
    <apply>
     <times></times>
     <ci>Tr</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>A</ci>
       <ci>normal-†</ci>
      </apply>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <ci>j</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>δ</ci>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>j</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\rm Tr}A^{\dagger}_{i}A_{j}\sim\delta_{ij}
  </annotation>
 </semantics>
</math>

. Such a canonical set of orthogonal Kraus operators can be obtained by diagonalising the corresponding Choi matrix and reshaping its eigenvectors into square matrices.</p>

<p>There also exists an infinite-dimensional algebraic generalization of Choi's theorem, known as 'Belavkin's Radon-Nikodym theorem for completely positive maps', which defines a density operator as a "Radon-Nikodym derivative" of a <a href="quantum_channel" title="wikilink">quantum channel</a> with respect to a dominating completely positive map (reference channel). It is used for defining the relative fidelities and mutual informations for quantum channels.</p>
<h2 id="dynamics">Dynamics</h2>

<p>For a non-relativistic quantum mechanical system, its <a href="time_evolution" title="wikilink">time evolution</a> is described by a <a href="one-parameter_group" title="wikilink">one-parameter group</a> of automorphisms {α<sub><em>t</em></sub>}<sub><em>t</em></sub> of <em>Q</em>. This can be narrowed to unitary transformations: under certain weak technical conditions (see the article on <a href="quantum_logic" title="wikilink">quantum logic</a> and the Varadarajan reference), there is a strongly continuous one-parameter group {<em>U</em><sub><em>t</em></sub>}<sub><em>t</em></sub> of unitary transformations of the underlying Hilbert space such that the elements <em>E</em> of <em>Q</em> evolve according to the formula</p>

<p>

<math display="block" id="Quantum_operation:13">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>α</mi>
      <mi>t</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>E</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msubsup>
      <mi>U</mi>
      <mi>t</mi>
      <mo>*</mo>
     </msubsup>
     <mi>E</mi>
     <msub>
      <mi>U</mi>
      <mi>t</mi>
     </msub>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>α</ci>
      <ci>t</ci>
     </apply>
     <ci>E</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>U</ci>
       <times></times>
      </apply>
      <ci>t</ci>
     </apply>
     <ci>E</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>U</ci>
      <ci>t</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha_{t}(E)=U^{*}_{t}EU_{t}.
  </annotation>
 </semantics>
</math>

 The system time evolution can also be regarded dually as time evolution of the statistical state space. The evolution of the statistical state is given by a family of operators {β<sub><em>t</em></sub>}<sub><em>t</em></sub> such that</p>

<p>

<math display="block" id="Quantum_operation:14">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>Tr</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>β</mi>
        <mi>t</mi>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>S</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <mi>E</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo>Tr</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>S</mi>
       <msub>
        <mi>α</mi>
        <mrow>
         <mo>-</mo>
         <mi>t</mi>
        </mrow>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>E</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo>Tr</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>S</mi>
       <msub>
        <mi>U</mi>
        <mi>t</mi>
       </msub>
       <mi>E</mi>
       <msubsup>
        <mi>U</mi>
        <mi>t</mi>
        <mo>*</mo>
       </msubsup>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo>Tr</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msubsup>
        <mi>U</mi>
        <mi>t</mi>
        <mo>*</mo>
       </msubsup>
       <mi>S</mi>
       <msub>
        <mi>U</mi>
        <mi>t</mi>
       </msub>
       <mi>E</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <ci>Tr</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>β</ci>
        <ci>t</ci>
       </apply>
       <ci>S</ci>
       <ci>E</ci>
      </apply>
     </apply>
     <apply>
      <ci>Tr</ci>
      <apply>
       <times></times>
       <ci>S</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>α</ci>
        <apply>
         <minus></minus>
         <ci>t</ci>
        </apply>
       </apply>
       <ci>E</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <ci>Tr</ci>
      <apply>
       <times></times>
       <ci>S</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>U</ci>
        <ci>t</ci>
       </apply>
       <ci>E</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>U</ci>
         <times></times>
        </apply>
        <ci>t</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <ci>Tr</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>U</ci>
         <times></times>
        </apply>
        <ci>t</ci>
       </apply>
       <ci>S</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>U</ci>
        <ci>t</ci>
       </apply>
       <ci>E</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{Tr}(\beta_{t}(S)E)=\operatorname{Tr}(S\alpha_{-t}(E))=%
\operatorname{Tr}(SU_{t}EU^{*}_{t})=\operatorname{Tr}(U^{*}_{t}SU_{t}E).
  </annotation>
 </semantics>
</math>

</p>

<p>Clearly, for each value of <em>t</em>, <em>S</em> → <em>U</em>*<sub><em>t</em></sub> <em>S</em> <em>U</em><sub><em>t</em></sub> is a quantum operation. Moreover, this operation is <em>reversible</em>.</p>

<p>This can be easily generalized: If <em>G</em> is a connected <a href="Lie_group" title="wikilink">Lie group</a> of symmetries of <em>Q</em> satisfying the same weak continuity conditions, then the <a href="group_action" title="wikilink">action</a> of any element <em>g</em> of <em>G</em> is given by a unitary operator <em>U</em>:</p>

<p>

<math display="block" id="Quantum_operation:15">
 <semantics>
  <mrow>
   <mi>g</mi>
   <mo>⋅</mo>
   <mi>E</mi>
   <mo>=</mo>
   <msub>
    <mi>U</mi>
    <mi>g</mi>
   </msub>
   <mi>E</mi>
   <msubsup>
    <mi>U</mi>
    <mi>g</mi>
    <mo>*</mo>
   </msubsup>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">g</csymbol>
    <ci>normal-⋅</ci>
    <csymbol cd="unknown">E</csymbol>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>U</ci>
     <ci>g</ci>
    </apply>
    <csymbol cd="unknown">E</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>U</ci>
      <ci>g</ci>
     </apply>
     <times></times>
    </apply>
    <ci>normal-.</ci>
    <ci></ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g\cdot E=U_{g}EU_{g}^{*}.\quad
  </annotation>
 </semantics>
</math>

 This mapping <em>g</em> → <em>U</em><sub><em>g</em></sub> is known as a <a href="projective_representation" title="wikilink">projective representation</a> of <em>G</em>. The mappings <em>S</em> → <em>U</em>*<sub><em>g</em></sub> <em>S</em> <em>U</em><sub><em>g</em></sub> are reversible quantum operations.</p>
<h2 id="quantum-measurement">Quantum measurement</h2>

<p>Quantum operations can be used to describe the process of <a href="quantum_measurement" title="wikilink">quantum measurement</a>. The presentation below describes measurement in terms of self-adjoint projections on a separable complex Hilbert space <em>H</em>, that is, in terms of a PVM (<a class="uri" href="Projection-valued_measure" title="wikilink">Projection-valued_measure</a>). In the general case, measurements can be made using non-orthogonal operators, via the notions of <a class="uri" href="POVM" title="wikilink">POVM</a>. The non-orthogonal case is interesting, as it can improve the overall efficiency of the <a href="quantum_instrument" title="wikilink">quantum instrument</a>.</p>
<h3 id="binary-measurements">Binary measurements</h3>

<p>Quantum systems may be measured by applying a series of <em>yes–no questions</em>. This set of questions can be understood to be chosen from an <a href="orthocomplemented_lattice" title="wikilink">orthocomplemented lattice</a> <em>Q</em> of propositions in <a href="quantum_logic" title="wikilink">quantum logic</a>. The lattice is equivalent to the space of self-adjoint projections on a separable complex Hilbert space <em>H</em>.</p>

<p>Consider a system in some state <em>S</em>, with the goal of determining whether it has some property <em>E</em>, where <em>E</em> is an element of the lattice of quantum <em>yes-no</em> questions. Measurement, in this context, means submitting the system to some procedure to determine whether the state satisfies the property. The reference to system state, in this discussion, can be given an <a href="operational_definition" title="wikilink">operational meaning</a> by considering a <a href="statistical_ensemble" title="wikilink">statistical ensemble</a> of systems. Each measurement yields some definite value 0 or 1; moreover application of the measurement process to the ensemble results in a predictable change of the statistical state. This transformation of the statistical state is given by the quantum operation</p>

<p>

<math display="block" id="Quantum_operation:16">
 <semantics>
  <mrow>
   <mrow>
    <mi>S</mi>
    <mo>↦</mo>
    <mrow>
     <mrow>
      <mi>E</mi>
      <mi>S</mi>
      <mi>E</mi>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>I</mi>
        <mo>-</mo>
        <mi>E</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>S</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>I</mi>
        <mo>-</mo>
        <mi>E</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">maps-to</csymbol>
    <ci>S</ci>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>E</ci>
      <ci>S</ci>
      <ci>E</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <minus></minus>
       <ci>I</ci>
       <ci>E</ci>
      </apply>
      <ci>S</ci>
      <apply>
       <minus></minus>
       <ci>I</ci>
       <ci>E</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S\mapsto ESE+(I-E)S(I-E).
  </annotation>
 </semantics>
</math>

 Here <em>E</em> can be understood to be a <a href="projection_operator" title="wikilink">projection operator</a>.</p>
<h3 id="general-case">General case</h3>

<p>In the general case, measurements are made on observables taking on more than two values.</p>

<p>When an observable <em>A</em> has a <a href="Self-adjoint_operator#Pure_point_spectrum" title="wikilink">pure point spectrum</a>, it can be written in terms of an <a class="uri" href="orthonormal" title="wikilink">orthonormal</a> basis of eigenvectors. That is, <em>A</em> has a spectral decomposition</p>

<p>

<math display="block" id="Quantum_operation:17">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>=</mo>
   <mrow>
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mi>λ</mi>
    </munder>
    <mrow>
     <mi>λ</mi>
     <mrow>
      <msub>
       <mo>E</mo>
       <mi>A</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>λ</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>A</ci>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <ci>λ</ci>
     </apply>
     <apply>
      <times></times>
      <ci>λ</ci>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>normal-E</ci>
        <ci>A</ci>
       </apply>
       <ci>λ</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A=\sum_{\lambda}\lambda\operatorname{E}_{A}(\lambda)
  </annotation>
 </semantics>
</math>

 where E<sub><em>A</em></sub>(λ) is a family of pairwise orthogonal <a href="Orthographic_projection" title="wikilink">projections</a>, each onto the respective eigenspace of <em>A</em> associated with the measurement value λ.</p>

<p>Measurement of the observable <em>A</em> yields an eigenvalue of <em>A</em>. Repeated measurements, made on a <a href="statistical_ensemble" title="wikilink">statistical ensemble</a> <em>S</em> of systems, results in a probability distribution over the eigenvalue spectrum of <em>A</em>. It is a <a href="discrete_probability_distribution" title="wikilink">discrete probability distribution</a>, and is given by</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Quantum_operation:18">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>Pr</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>λ</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo>Tr</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>S</mi>
       <mrow>
        <msub>
         <mo>E</mo>
         <mi>A</mi>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>λ</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>Pr</ci>
     <ci>λ</ci>
    </apply>
    <apply>
     <ci>Tr</ci>
     <apply>
      <times></times>
      <ci>S</ci>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>normal-E</ci>
        <ci>A</ci>
       </apply>
       <ci>λ</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{Pr}(\lambda)=\operatorname{Tr}(S\operatorname{E}_{A}(\lambda)).
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>Measurement of the statisical state <em>S</em> is given by the map</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Quantum_operation:19">
 <semantics>
  <mrow>
   <mrow>
    <mi>S</mi>
    <mo>↦</mo>
    <mrow>
     <msub>
      <mo largeop="true" symmetric="true">∑</mo>
      <mi>λ</mi>
     </msub>
     <mrow>
      <mrow>
       <mrow>
        <msub>
         <mo>E</mo>
         <mi>A</mi>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>λ</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mi>S</mi>
      </mrow>
      <mrow>
       <msub>
        <mo>E</mo>
        <mi>A</mi>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>λ</mi>
        <mo rspace="7.5pt" stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">maps-to</csymbol>
    <ci>S</ci>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <ci>λ</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>normal-E</ci>
         <ci>A</ci>
        </apply>
        <ci>λ</ci>
       </apply>
       <ci>S</ci>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>normal-E</ci>
        <ci>A</ci>
       </apply>
       <ci>λ</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S\mapsto\sum_{\lambda}\operatorname{E}_{A}(\lambda)S\operatorname{E}_{A}(%
\lambda)\ .
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>That is, immediately after measurement, the statistical state is a classical distribution over the eigenspaces associated with the possible values λ of the observable: <em>S</em> is a <a href="mixed_state_(physics)" title="wikilink">mixed state</a>.</p>
<h2 id="non-completely-positive-maps">Non-completely positive maps</h2>

<p>Shaji and <a href="George_Sudarshan" title="wikilink">Sudarshan</a> argued in a Physics Letters A paper that, upon close examination, complete positivity is not a requirement for a good representation of open quantum evolution. Their calculations show that, when starting with some fixed initial correlations between the observed system and the environment, the map restricted to the system itself is not necessarily even positive. However, it is not positive only for those states that do not satisfy the assumption about the form of initial correlations. Thus, they show that to get a full understanding of quantum evolution, non completely-positive maps should be considered as well.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a><a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Quantum_dynamical_semigroup" title="wikilink">Quantum dynamical semigroup</a></li>
</ul>
<h2 id="references">References</h2>
<references>
</references>
<ul>
<li>M. Nielsen and I. Chuang, <em>Quantum Computation and Quantum Information</em>, Cambridge University Press, 2000</li>
</ul>
<ul>
<li>M. Choi, <em>Completely Positive Linear Maps on Complex matrices</em>, Linear Algebra and Its Applications, 285–290, 1975</li>
</ul>
<ul>
<li>E. C. G. Sudarshan et al. <em>Stochastic Dynamics of Quantum-Mechanical Systems</em>, Phys. Rev. 121, 920–924, 1961.</li>
</ul>
<ul>
<li>V. P. Belavkin, P. Staszewski, Radon–Nikodym Theorem for Completely Positive Maps, Reports on Mathematical Physics, v.24, No 1, 49–55, 1986.</li>
</ul>
<ul>
<li>K. Kraus, <em>States, Effects and Operations: Fundamental Notions of Quantum Theory</em>, Springer Verlag 1983</li>
</ul>
<ul>
<li>W. F. Stinespring, <em>Positive Functions on C*-algebras</em>, Proceedings of the American Mathematical Society, 211–216, 1955</li>
</ul>
<ul>
<li>V. Varadarajan, <em>The Geometry of Quantum Mechanics</em> vols 1 and 2, Springer-Verlag 1985</li>
</ul>
<ul>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Quantum_mechanics" title="wikilink">Category:Quantum mechanics</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="http://prola.aps.org/abstract/PR/v121/i3/p920_1">"Stochastic Dynamics of Quantum-Mechanical Systems"</a> .<a href="#fnref1">↩</a></li>
<li id="fn2">C. Weedbrook at al., <a href="http://journals.aps.org/rmp/abstract/10.1103/RevModPhys.84.621">"Gaussian quantum information"</a>, <em>Rev. Mod. Phys.</em> <strong>84</strong>, 621 (2012).<a href="#fnref2">↩</a></li>
<li id="fn3">Philip Pechukas, <a href="http://prl.aps.org/abstract/PRL/v73/i8/p1060_1">"Reduced Dynamics Need Not Be Completely Positive"</a>, <em>Phys. Rev. Lett.</em> <strong>73</strong>, 1060 (1994).<a href="#fnref3">↩</a></li>
<li id="fn4">This theorem is proved in the Nielsen and Chuang reference, Theorems 8.1 and 8.3.<a href="#fnref4">↩</a></li>
<li id="fn5"></li>
<li id="fn6">Anil Shaji and E.C.G. Sudarshan <a href="http://www.sciencedirect.com/science/article/pii/S0375960105005748">"Who's Afraid of not Completely Positive Maps?"</a>, <em>Physics Letters A</em> Volume <strong>341</strong>, 20 June 2005, Pages 48–54<a href="#fnref6">↩</a></li>
</ol>
</section>
</body>
</html>
