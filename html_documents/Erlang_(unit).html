<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="368">Erlang (unit)</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Erlang (unit)</h1>
<hr/>

<p>The <strong>erlang</strong> (symbol <strong>E</strong><a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a>) is a <a href="dimensionless_unit" title="wikilink">dimensionless unit</a> that is used in <a class="uri" href="telephony" title="wikilink">telephony</a> as a measure of <a href="offered_load" title="wikilink">offered load</a> or carried load on service-providing elements such as telephone circuits or telephone switching equipment. For example, a single <a href="cord_circuit" title="wikilink">cord circuit</a> has the capacity to be used for 60 minutes in one hour. If one hundred six-minute calls are received on a group of such circuits, then assuming no other calls are placed for the rest of the hour, the total traffic in that hour will be six hundred minutes, or 10 erlangs.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>

<p>In 1946, the <a class="uri" href="CCITT" title="wikilink">CCITT</a> named the international unit of telephone traffic the erlang in honor of <a href="Agner_Krarup_Erlang" title="wikilink">Agner Krarup Erlang</a>.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>
<h2 id="traffic-measurements-of-a-telephone-circuit">Traffic measurements of a telephone circuit</h2>

<p>When used to represent <strong>carried traffic</strong>, a value (which can be a non-integer such as 43.5) followed by “erlangs” represents the average number of concurrent calls carried by the circuits (or other service-providing elements), where that average is calculated over some reasonable period of time. The period over which the average is calculated is often one hour, but shorter periods (e.g., 15 minutes) may be used where it is known that there are short spurts of demand and a traffic measurement is desired that does not mask these spurts. One erlang of carried traffic refers to a single resource being in continuous use, or two channels each being in use fifty percent of the time, and so on. For example, if an office has two telephone operators who are both busy all the time, that would represent two erlangs (2 E) of traffic; or a radio channel that is occupied for one hour continuously is said to have a load of 1 erlang.</p>

<p>When used to describe <strong>offered traffic</strong>, a value followed by “erlangs” represents the average number of concurrent calls that would have been carried if there were an unlimited number of circuits (that is, if the call-attempts that were made when all circuits were in use had not been rejected). The relationship between offered traffic and carried traffic depends on the design of the system and user behavior. Three common models are (a) callers whose call-attempts are rejected go away and never come back, (b) callers whose call-attempts are rejected try again within a fairly short space of time, and (c) the system allows users to wait in queue until a circuit becomes available.</p>

<p>A third measurement of traffic is <strong>instantaneous traffic</strong>, expressed as a certain number of erlangs, meaning the exact number of calls taking place at a point in time. In this case the number is an integer. Traffic-level-recording devices, such as moving-pen recorders, plot instantaneous traffic.</p>

<p>The concepts and mathematics introduced by <a href="A._K._Erlang" title="wikilink">Agner Krarup Erlang</a> have broad applicability beyond telephony. They apply wherever users arrive more or less at random to receive exclusive service from any one of a group of service-providing elements without prior reservation, for example, where the service-providing elements are ticket-sales windows, toilets on an airplane, or motel rooms. (Erlang’s models do not apply where the server-providing elements are shared between several concurrent users or different amounts of service are consumed by different users, for instance, on circuits carrying data traffic.)</p>

<p>Offered traffic (in erlangs) is related to the <strong>call arrival rate</strong>, λ, and the <strong>average call-holding time</strong>, <em>h</em>, by:</p>

<p>

<math display="block" id="Erlang_(unit):0">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mo>=</mo>
   <mrow>
    <mi>λ</mi>
    <mi>h</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>E</ci>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>h</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E=\lambda h
  </annotation>
 </semantics>
</math>

</p>

<p>provided that <em>h</em> and λ are expressed using the same units of time (seconds and calls per second, or minutes and calls per minute).</p>

<p>The practical measurement of traffic is typically based on continuous observations over several days or weeks, during which the instantaneous traffic is recorded at regular, short intervals (such as every few seconds). These measurements are then used to calculate a single result, most commonly the <strong>busy hour traffic</strong> (in erlangs). This is the average number of concurrent calls during a given one-hour period of the day, where that period is selected to give the highest result. (This result is called the time-consistent busy hour traffic). An alternative is to calculate a busy hour traffic value separately for each day (which may correspond to slightly different times each day) and take the average of these values. This generally gives a slightly higher value than the time-consistent busy hour value.</p>

<p>The goal of Erlang’s traffic theory is to determine exactly how many service-providing elements should be provided in order to satisfy users, without wasteful over-provisioning. To do this, a target is set for the <a href="grade_of_service" title="wikilink">grade of service</a> (GoS) or <a href="quality_of_service" title="wikilink">quality of service</a> (QoS). For example, in a system where there is no queuing, the GoS may be that no more than 1 call in 100 is blocked (i.e., rejected) due to all circuits being in use (a GoS of 0.01), which becomes the target probability of call blocking, <em>P<sub>b</sub></em>, when using the Erlang B formula.</p>

<p>There are several Erlang formulae, including Erlang B, Erlang C and the related Engset formula, based on different models of user behavior and system operation. These are discussed below, and may each be derived by means of a special case of <a href="continuous-time_Markov_process" title="wikilink">continuous-time Markov processes</a> known as a <a href="birth-death_process" title="wikilink">birth-death process</a>.</p>

<p>Where the existing busy-hour carried traffic, <em>E</em><sub>c</sub>, is measured on an already-overloaded system, with a significant level of blocking, it is necessary to take account of the blocked calls in estimating the busy-hour offered traffic <em>E</em><sub>o</sub> (which is the traffic value to be used in the Erlang formula). The offered traffic can be estimated by <em>E</em><sub>o</sub> = <em>E</em><sub>c</sub>/(1 − <em>P</em><sub>b</sub>). For this purpose, where the system includes a means of counting blocked calls and successful calls, <em>P</em><sub>b</sub> can be estimated directly from the proportion of calls that are blocked. Failing that, <em>P</em><sub>b</sub> can be estimated by using <em>E</em><sub>c</sub> in place of <em>E</em><sub>o</sub> in the Erlang formula and the resulting estimate of <em>P</em><sub>b</sub> can then be used in <em>E</em><sub>o</sub> = <em>E</em><sub>c</sub>/(1 − <em>P</em><sub>b</sub>) to estimate <em>E</em><sub>o</sub>. Another method of estimating <em>E</em><sub>o</sub> in an overloaded system is to measure the busy-hour call arrival rate, <em>λ</em> (counting successful calls and blocked calls), and the average call-holding time (for successful calls), <em>h</em>, and then estimate <em>E<sub>o</sub></em> using the formula <em>E</em> = <em>λh</em>.</p>

<p>For a situation where the traffic to be handled is completely new traffic, the only choice is to try to model expected user behavior, estimating active user population, <em>N</em>, expected level of use, <em>U</em> (number of calls/transactions per user per day), busy-hour concentration factor, <em>C</em> (proportion of daily activity that will fall in the busy hour), and average holding time/service time, <em>h</em> (expressed in minutes). A projection of busy-hour offered traffic would then be <em>E</em><sub>o</sub> = (NUC/60)<em>h</em> erlangs. (The division by 60 translates the busy-hour call/transaction arrival rate into a per-minute value, to match the units in which <em>h</em> is expressed.)</p>
<h2 id="erlang-b-formula">Erlang B formula</h2>

<p><strong>Erlang-B</strong> (sometimes also written without the hyphen <strong>Erlang B</strong>), also known as the <strong>Erlang loss formula</strong>, is a formula for the <strong>blocking probability</strong> that describes the probability of call losses for a group of identical parallel resources (telephone lines, circuits, traffic channels, or equivalent), sometimes referred to as an <a href="M/M/c_queue#Finite_capacity" title="wikilink">M/M/c/c queue</a>.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> It is, for example, used to dimension a telephone network's links. The formula was derived by <a href="Agner_Krarup_Erlang" title="wikilink">Agner Krarup Erlang</a> and is not limited to telephone networks, since it describes a probability in a queuing system (albeit a special case with a number of servers but no queueing space for incoming calls to wait for a free server). Hence, the formula is also used in certain inventory systems with lost sales.</p>

<p>The formula applies under the condition that an unsuccessful call, because the line is busy, is not queued or retried, but instead really vanishes forever. It is assumed that call attempts arrive following a <a href="Poisson_process" title="wikilink">Poisson process</a>, so call arrival instants are independent. Further, it is assumed that the message lengths (holding times) are exponentially distributed (Markovian system), although the formula turns out to apply under general holding time distributions.</p>

<p>The Erlang B formula assumes an infinite population of sources (such as telephone subscribers), which jointly offer traffic to <em>N</em> servers (such as telephone lines). The rate expressing the frequency at that new calls arrive, λ, (birth rate, traffic intensity, etc.) is constant, and does <em>not</em> depend on the number of active sources. The total number of sources is assumed to be infinite. The Erlang B formula calculates the blocking probability of a buffer-less loss system, where a request that is not served immediately is aborted, causing that no requests become queued. Blocking occurs when a new request arrives at a time where all available servers are currently busy. The formula also assumes that blocked traffic is cleared and does not return.</p>

<p>The formula provides the GoS (<a href="grade_of_service" title="wikilink">grade of service</a>) which is the probability <em>P<sub>b</sub></em> that a new call arriving to the resources group is rejected because all resources (servers, lines, circuits) are busy: <em>B</em>(<em>E</em>, <em>m</em>) where <em>E</em> is the total offered traffic in erlang, offered to <em>m</em> identical parallel resources (servers, communication channels, traffic lanes).</p>

<p>

<math display="block" id="Erlang_(unit):1">
 <semantics>
  <mrow>
   <msub>
    <mi>P</mi>
    <mi>b</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mi>B</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>E</mi>
     <mo>,</mo>
     <mi>m</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mfrac>
     <msup>
      <mi>E</mi>
      <mi>m</mi>
     </msup>
     <mrow>
      <mi>m</mi>
      <mo lspace="0pt" rspace="3.5pt">!</mo>
     </mrow>
    </mfrac>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>0</mn>
      </mrow>
      <mi>m</mi>
     </msubsup>
     <mfrac>
      <msup>
       <mi>E</mi>
       <mi>i</mi>
      </msup>
      <mrow>
       <mi>i</mi>
       <mo lspace="0pt" rspace="3.5pt">!</mo>
      </mrow>
     </mfrac>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>P</ci>
      <ci>b</ci>
     </apply>
     <apply>
      <times></times>
      <ci>B</ci>
      <interval closure="open">
       <ci>E</ci>
       <ci>m</ci>
      </interval>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <divide></divide>
      <apply>
       <divide></divide>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>E</ci>
        <ci>m</ci>
       </apply>
       <apply>
        <factorial></factorial>
        <ci>m</ci>
       </apply>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <ci>i</ci>
          <cn type="integer">0</cn>
         </apply>
        </apply>
        <ci>m</ci>
       </apply>
       <apply>
        <divide></divide>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>E</ci>
         <ci>i</ci>
        </apply>
        <apply>
         <factorial></factorial>
         <ci>i</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{b}=B(E,m)=\frac{\frac{E^{m}}{m!}}{\sum_{i=0}^{m}\frac{E^{i}}{i!}}
  </annotation>
 </semantics>
</math>

</p>

<p>where:</p>
<ul>
<li>

<math display="inline" id="Erlang_(unit):2">
 <semantics>
  <msub>
   <mi>P</mi>
   <mi>b</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>P</ci>
    <ci>b</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{b}
  </annotation>
 </semantics>
</math>

 is the probability of blocking</li>
<li><em>m</em> is the number of identical parallel resources such as servers, telephone lines, etc.</li>
<li><em>E</em> = <em>λh</em> is the normalised ingress load (offered traffic stated in erlang).</li>
</ul>

<p>Note: The <em>erlang</em> is a dimensionless load unit calculated as the mean arrival rate, λ, multiplied by the mean call holding time, <em>h</em>. See <a href="Little's_law" title="wikilink">Little's law</a> to prove that the erlang unit has to be dimensionless for Little's Law to be dimensionally sane.</p>

<p>This may be expressed recursively<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> as follows, in a form that is used to simplify the calculation of tables of the Erlang B formula:</p>

<p>

<math display="block" id="Erlang_(unit):3">
 <semantics>
  <mrow>
   <mrow>
    <mi>B</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>E</mi>
     <mo>,</mo>
     <mn>0</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mpadded width="+1.7pt">
    <mn>1.</mn>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>B</ci>
     <interval closure="open">
      <ci>E</ci>
      <cn type="integer">0</cn>
     </interval>
    </apply>
    <cn type="float">1.</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B(E,0)=1.\,
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Erlang_(unit):4">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mi>B</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>E</mi>
       <mo>,</mo>
       <mi>j</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>=</mo>
     <mrow>
      <mpadded width="+5pt">
       <mfrac>
        <mrow>
         <mi>E</mi>
         <mi>B</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>E</mi>
          <mo>,</mo>
          <mrow>
           <mi>j</mi>
           <mo>-</mo>
           <mn>1</mn>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mrow>
         <mrow>
          <mi>E</mi>
          <mi>B</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>E</mi>
           <mo>,</mo>
           <mrow>
            <mi>j</mi>
            <mo>-</mo>
            <mn>1</mn>
           </mrow>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo>+</mo>
         <mi>j</mi>
        </mrow>
       </mfrac>
      </mpadded>
      <mrow>
       <mo>∀</mo>
       <mi>j</mi>
      </mrow>
     </mrow>
     <mo>=</mo>
     <mn>1</mn>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mn>2</mn>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <mi>m</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <and></and>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <ci>B</ci>
       <interval closure="open">
        <ci>E</ci>
        <ci>j</ci>
       </interval>
      </apply>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <apply>
         <times></times>
         <ci>E</ci>
         <ci>B</ci>
         <interval closure="open">
          <ci>E</ci>
          <apply>
           <minus></minus>
           <ci>j</ci>
           <cn type="integer">1</cn>
          </apply>
         </interval>
        </apply>
        <apply>
         <plus></plus>
         <apply>
          <times></times>
          <ci>E</ci>
          <ci>B</ci>
          <interval closure="open">
           <ci>E</ci>
           <apply>
            <minus></minus>
            <ci>j</ci>
            <cn type="integer">1</cn>
           </apply>
          </interval>
         </apply>
         <ci>j</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="latexml">for-all</csymbol>
        <ci>j</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <eq></eq>
      <share href="#.cmml">
      </share>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <list>
     <cn type="integer">2</cn>
     <ci>normal-…</ci>
     <ci>m</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B(E,j)=\frac{EB(E,j-1)}{EB(E,j-1)+j}\ \forall{j}=1,2,\ldots,m.
  </annotation>
 </semantics>
</math>

</p>

<p>Typically, instead of <em>B</em>(<em>E</em>, <em>m</em>) the inverse 1/<em>B</em>(<em>E</em>, <em>m</em>) is calculated in numerical computation in order to ensure <a href="numerical_stability" title="wikilink">numerical stability</a>:</p>

<p>

<math display="block" id="Erlang_(unit):5">
 <semantics>
  <mrow>
   <mfrac>
    <mn>1</mn>
    <mrow>
     <mi>B</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>E</mi>
      <mo>,</mo>
      <mn>0</mn>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mfrac>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <apply>
      <times></times>
      <ci>B</ci>
      <interval closure="open">
       <ci>E</ci>
       <cn type="integer">0</cn>
      </interval>
     </apply>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{1}{B(E,0)}=1
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Erlang_(unit):6">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <mrow>
       <mi>B</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>E</mi>
        <mo>,</mo>
        <mi>j</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mfrac>
     <mo>=</mo>
     <mrow>
      <mn>1</mn>
      <mo>+</mo>
      <mrow>
       <mfrac>
        <mi>j</mi>
        <mi>E</mi>
       </mfrac>
       <mpadded width="+5pt">
        <mfrac>
         <mn>1</mn>
         <mrow>
          <mi>B</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>E</mi>
           <mo>,</mo>
           <mrow>
            <mi>j</mi>
            <mo>-</mo>
            <mn>1</mn>
           </mrow>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
        </mfrac>
       </mpadded>
       <mrow>
        <mo>∀</mo>
        <mi>j</mi>
       </mrow>
      </mrow>
     </mrow>
     <mo>=</mo>
     <mn>1</mn>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mn>2</mn>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <mi>m</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <and></and>
     <apply>
      <eq></eq>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <apply>
        <times></times>
        <ci>B</ci>
        <interval closure="open">
         <ci>E</ci>
         <ci>j</ci>
        </interval>
       </apply>
      </apply>
      <apply>
       <plus></plus>
       <cn type="integer">1</cn>
       <apply>
        <times></times>
        <apply>
         <divide></divide>
         <ci>j</ci>
         <ci>E</ci>
        </apply>
        <apply>
         <divide></divide>
         <cn type="integer">1</cn>
         <apply>
          <times></times>
          <ci>B</ci>
          <interval closure="open">
           <ci>E</ci>
           <apply>
            <minus></minus>
            <ci>j</ci>
            <cn type="integer">1</cn>
           </apply>
          </interval>
         </apply>
        </apply>
        <apply>
         <csymbol cd="latexml">for-all</csymbol>
         <ci>j</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <eq></eq>
      <share href="#.cmml">
      </share>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <list>
     <cn type="integer">2</cn>
     <ci>normal-…</ci>
     <ci>m</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{1}{B(E,j)}=1+\frac{j}{E}\frac{1}{B(E,j-1)}\ \forall{j}=1,2,\ldots,m.
  </annotation>
 </semantics>
</math>

</p>
<pre class="vb"><code> Function ErlangB (E As Double, m As Integer) As Double
 Dim InvB As Double
 Dim j As Integer
 
   InvB = 1.0
   For j = 1 To m
     InvB = 1.0 + InvB * j / E 
   Next j
   ErlangB = 1.0 / InvB
 End Function</code></pre>

<p>The Erlang B formula is decreasing and <a href="convex_function" title="wikilink">convex</a> in <em>m</em>.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> It requires that call arrivals can be modeled by a <a href="Poisson_process" title="wikilink">Poisson process</a>, which not always is a good match, but it is valid for any statistical distribution of call holding times with finite mean. It applies to traffic transmission systems that do not buffer traffic. More modern examples compared to <a href="Plain_old_telephone_service" title="wikilink">POTS</a> where Erlang B is still applicable, are <a href="optical_burst_switching" title="wikilink">optical burst switching</a> (OBS) and several current approaches to <a href="optical_packet_switching" title="wikilink">optical packet switching</a> (OPS). Erlang B was developed as a trunk sizing tool for telephone networks with holding times in the minutes range, but being a mathematical equation it applies on any time-scale.</p>
<h3 id="extended-erlang-b">Extended Erlang B</h3>

<p>Extended Erlang B is an <a href="iteration" title="wikilink">iterative calculation</a>, rather than a formula, that adds an extra parameter, the recall factor, which defines the recall attempts.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>

<p>The steps in the process are as follows:<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></p>

<p>1. Calculate</p>

<p>

<math display="block" id="Erlang_(unit):7">
 <semantics>
  <mrow>
   <msub>
    <mi>P</mi>
    <mi>b</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mi>B</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>E</mi>
     <mo>,</mo>
     <mi>m</mi>
     <mo rspace="4.2pt" stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>P</ci>
     <ci>b</ci>
    </apply>
    <apply>
     <times></times>
     <ci>B</ci>
     <interval closure="open">
      <ci>E</ci>
      <ci>m</ci>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{b}=B(E,m)\,
  </annotation>
 </semantics>
</math>

 as above for Erlang B.</p>

<p>2. Calculate the probable number of blocked calls</p>

<p>

<math display="block" id="Erlang_(unit):8">
 <semantics>
  <mrow>
   <msub>
    <mi>B</mi>
    <mi>e</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mi>E</mi>
    <mpadded width="+1.7pt">
     <msub>
      <mi>P</mi>
      <mi>b</mi>
     </msub>
    </mpadded>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>B</ci>
     <ci>e</ci>
    </apply>
    <apply>
     <times></times>
     <ci>E</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>P</ci>
      <ci>b</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B_{e}=EP_{b}\,
  </annotation>
 </semantics>
</math>

</p>

<p>3. Calculate the number of recalls, 

<math display="inline" id="Erlang_(unit):9">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

 assuming a Recall Factor, 

<math display="inline" id="Erlang_(unit):10">
 <semantics>
  <msub>
   <mi>R</mi>
   <mi>f</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>R</ci>
    <ci>f</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{f}
  </annotation>
 </semantics>
</math>

:</p>

<p>

<math display="block" id="Erlang_(unit):11">
 <semantics>
  <mrow>
   <mi>R</mi>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>B</mi>
     <mi>e</mi>
    </msub>
    <mpadded width="+1.7pt">
     <msub>
      <mi>R</mi>
      <mi>f</mi>
     </msub>
    </mpadded>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>R</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>B</ci>
      <ci>e</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>R</ci>
      <ci>f</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R=B_{e}R_{f}\,
  </annotation>
 </semantics>
</math>

</p>

<p>4. Calculate the new offered traffic</p>

<p>

<math display="block" id="Erlang_(unit):12">
 <semantics>
  <mrow>
   <msub>
    <mi>E</mi>
    <mrow>
     <mi>i</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>E</mi>
     <mn>0</mn>
    </msub>
    <mo>+</mo>
    <mpadded width="+1.7pt">
     <mi>R</mi>
    </mpadded>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>E</ci>
     <apply>
      <plus></plus>
      <ci>i</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>E</ci>
      <cn type="integer">0</cn>
     </apply>
     <ci>R</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E_{i+1}=E_{0}+R\,
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Erlang_(unit):13">
 <semantics>
  <msub>
   <mi>E</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>E</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E_{0}
  </annotation>
 </semantics>
</math>

 is the initial (baseline) level of traffic.</p>

<p>5. Return to step 1 and iterate until a stable value of 

<math display="inline" id="Erlang_(unit):14">
 <semantics>
  <mi>E</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>E</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E
  </annotation>
 </semantics>
</math>

 is obtained.</p>
<h2 id="erlang-c-formula">Erlang C formula</h2>

<p>The <strong>Erlang C formula</strong> expresses the probability that an arriving customer will need to queue (as opposed to immediately being served).<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> Just as the Erlang B formula, Erlang C assumes an infinite population of sources, which jointly offer traffic of <em>A</em> erlangs to <em>N</em> servers. However, if all the servers are busy when a request arrives from a source, the request is queued. An unlimited number of requests may be held in the queue in this way simultaneously. This formula calculates the probability of queuing offered traffic, assuming that blocked calls stay in the system until they can be handled. This formula is used to determine the number of agents or customer service representatives needed to staff a <a href="call_centre" title="wikilink">call centre</a>, for a specified desired probability of queuing. However, the Erlang C formula assumes that callers never hang up while in queue, that all calls begin and end in the same time period being considered, and that callers never try to call back after having hung up while in queue. These deficiencies make the formula predict that more agents should be used than are really needed to maintain a desired service level.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> )</p>

<p>

<math display="block" id="Erlang_(unit):15">
 <semantics>
  <mrow>
   <msub>
    <mi>P</mi>
    <mi>W</mi>
   </msub>
   <mo>=</mo>
   <mpadded width="+1.7pt">
    <mfrac>
     <mrow>
      <mfrac>
       <msup>
        <mi>A</mi>
        <mi>N</mi>
       </msup>
       <mrow>
        <mi>N</mi>
        <mo lspace="0pt" rspace="3.5pt">!</mo>
       </mrow>
      </mfrac>
      <mfrac>
       <mi>N</mi>
       <mrow>
        <mi>N</mi>
        <mo>-</mo>
        <mi>A</mi>
       </mrow>
      </mfrac>
     </mrow>
     <mrow>
      <mrow>
       <mo>(</mo>
       <mrow>
        <munderover>
         <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
         <mrow>
          <mi>i</mi>
          <mo>=</mo>
          <mn>0</mn>
         </mrow>
         <mrow>
          <mi>N</mi>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
        </munderover>
        <mfrac>
         <msup>
          <mi>A</mi>
          <mi>i</mi>
         </msup>
         <mrow>
          <mi>i</mi>
          <mo lspace="0pt" rspace="3.5pt">!</mo>
         </mrow>
        </mfrac>
       </mrow>
       <mo>)</mo>
      </mrow>
      <mo>+</mo>
      <mrow>
       <mfrac>
        <msup>
         <mi>A</mi>
         <mi>N</mi>
        </msup>
        <mrow>
         <mi>N</mi>
         <mo lspace="0pt" rspace="3.5pt">!</mo>
        </mrow>
       </mfrac>
       <mfrac>
        <mi>N</mi>
        <mrow>
         <mi>N</mi>
         <mo>-</mo>
         <mi>A</mi>
        </mrow>
       </mfrac>
      </mrow>
     </mrow>
    </mfrac>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>P</ci>
     <ci>W</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>A</ci>
        <ci>N</ci>
       </apply>
       <apply>
        <factorial></factorial>
        <ci>N</ci>
       </apply>
      </apply>
      <apply>
       <divide></divide>
       <ci>N</ci>
       <apply>
        <minus></minus>
        <ci>N</ci>
        <ci>A</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <ci>i</ci>
          <cn type="integer">0</cn>
         </apply>
        </apply>
        <apply>
         <minus></minus>
         <ci>N</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <divide></divide>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>A</ci>
         <ci>i</ci>
        </apply>
        <apply>
         <factorial></factorial>
         <ci>i</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>A</ci>
         <ci>N</ci>
        </apply>
        <apply>
         <factorial></factorial>
         <ci>N</ci>
        </apply>
       </apply>
       <apply>
        <divide></divide>
        <ci>N</ci>
        <apply>
         <minus></minus>
         <ci>N</ci>
         <ci>A</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{W}={{\frac{A^{N}}{N!}\frac{N}{N-A}}\over\left(\sum\limits_{i=0}^{N-1}\frac{%
A^{i}}{i!}\right)+\frac{A^{N}}{N!}\frac{N}{N-A}}\,
  </annotation>
 </semantics>
</math>

</p>

<p>where:</p>
<ul>
<li><em>A</em> is the total traffic offered in units of erlangs</li>
<li><em>N</em> is the number of servers</li>
<li><em>P</em><sub><em>W</em></sub> is the probability that a customer has to wait for service.</li>
</ul>

<p>It is assumed that the call arrivals can be modeled by a <a href="Poisson_process" title="wikilink">Poisson process</a> and that call holding times are described by a negative exponential distribution.</p>
<h2 id="engset-formula">Engset formula</h2>

<p>The <strong>Engset calculation</strong> is a related formula, named after its developer, <a href="T._O._Engset" title="wikilink">T. O. Engset</a>, used to determine the probability of congestion occurring within a <a class="uri" href="telephony" title="wikilink">telephony</a> <a href="trunking" title="wikilink">circuit group</a>. It deals with a finite population of <em>S</em> sources rather than the infinite population of sources that Erlang assumes. The formula requires that the user knows the expected peak traffic, the number of sources (callers) and the number of circuits in the network.</p>
<h3 id="example-application">Example application</h3>

<p>A business installing a <a class="uri" href="PABX" title="wikilink">PABX</a> needs to know the minimum number of <a href="Telecommunication_circuit" title="wikilink">voice circuits</a> it needs to have to and from the <a href="PSTN" title="wikilink">telephone network</a>. An approximate approach is to use the <a class="uri" href="Erlang-B" title="wikilink">Erlang-B</a> formula. However, if the business has a small number of <a href="extension_(telephone)" title="wikilink">extensions</a>, then it should instead use the more exact Engset calculation, which reflects the fact that extensions already in use will not make additional simultaneous calls. (For a large user population, the Engset and the Erlang-B calculations give the same result.)</p>
<h3 id="technical-details">Technical details</h3>

<p>Engset's equation is similar to the Erlang-B formula, but has one major difference: Erlang's equation assumes an infinite source of calls, yielding a <a href="Markovian_arrival_processes" title="wikilink">Poisson arrival process</a>, while Engset specifies a finite number of callers.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a><a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> Thus Engset's equation should be used when the source population is small (say less than 200 users, extensions or customers).</p>

<p>

<math display="block" id="Erlang_(unit):16">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>P</mi>
     <mi>b</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>N</mi>
     <mo>,</mo>
     <mi>A</mi>
     <mo>,</mo>
     <mi>S</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <msup>
      <mi>A</mi>
      <mi>N</mi>
     </msup>
     <mrow>
      <mo>(</mo>
      <mtable>
       <mtr>
        <mtd columnalign="center">
         <mi>S</mi>
        </mtd>
       </mtr>
       <mtr>
        <mtd columnalign="center">
         <mi>N</mi>
        </mtd>
       </mtr>
      </mtable>
      <mo>)</mo>
     </mrow>
    </mrow>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>0</mn>
      </mrow>
      <mi>N</mi>
     </msubsup>
     <mrow>
      <msup>
       <mi>A</mi>
       <mi>i</mi>
      </msup>
      <mrow>
       <mo>(</mo>
       <mtable>
        <mtr>
         <mtd columnalign="center">
          <mi>S</mi>
         </mtd>
        </mtr>
        <mtr>
         <mtd columnalign="center">
          <mi>i</mi>
         </mtd>
        </mtr>
       </mtable>
       <mo>)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>P</ci>
      <ci>b</ci>
     </apply>
     <vector>
      <ci>N</ci>
      <ci>A</ci>
      <ci>S</ci>
     </vector>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>A</ci>
       <ci>N</ci>
      </apply>
      <matrix>
       <matrixrow>
        <ci>S</ci>
       </matrixrow>
       <matrixrow>
        <ci>N</ci>
       </matrixrow>
      </matrix>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">0</cn>
        </apply>
       </apply>
       <ci>N</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>A</ci>
        <ci>i</ci>
       </apply>
       <matrix>
        <matrixrow>
         <ci>S</ci>
        </matrixrow>
        <matrixrow>
         <ci>i</ci>
        </matrixrow>
       </matrix>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{b}(N,A,S)=\frac{A^{N}{\left(\begin{array}[]{c}S\\
N\end{array}\right)}}{\sum_{i=0}^{N}A^{i}{\left(\begin{array}[]{c}S\\
i\end{array}\right)}}
  </annotation>
 </semantics>
</math>

</p>

<p>where</p>
<dl>
<dd><em>A</em> = offered traffic intensity in erlangs, from all sources
</dd>
<dd><em>S</em> = number of sources of traffic
</dd>
<dd><em>N</em> = number of circuits in group
</dd>
<dd>P(<em>b</em>) = <a class="uri" href="probability" title="wikilink">probability</a> of blocking or congestion.
</dd>
</dl>

<p>In practice, like Erlang's equations, Engset's formula requires recursion to solve for the blocking or congestion probability. There are several recursions that could be used.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> One way to determine this probability, is to first determine an initial estimate. This initial estimate is substituted into the equation and the equation then is solved. The answer to this initial calculation is then substituted back into the equation, resulting in a new answer which is again substituted. This <a class="uri" href="iterative" title="wikilink">iterative</a> process continues until the equation <a href="Limit_of_a_sequence" title="wikilink">converges</a> to a stable result.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a><a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a></p>

<p>Engset's equation:<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a></p>

<p>

<math display="block" id="Erlang_(unit):17">
 <semantics>
  <mrow>
   <mrow>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>b</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mrow>
      <mo>[</mo>
      <mfrac>
       <mrow>
        <mrow>
         <mo>(</mo>
         <mrow>
          <mi>S</mi>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
         <mo>)</mo>
        </mrow>
        <mo lspace="0pt" rspace="3.5pt">!</mo>
       </mrow>
       <mrow>
        <mrow>
         <mi>N</mi>
         <mo lspace="0pt" rspace="3.5pt">!</mo>
        </mrow>
        <mo>⋅</mo>
        <mrow>
         <mrow>
          <mo>(</mo>
          <mrow>
           <mi>S</mi>
           <mo>-</mo>
           <mn>1</mn>
           <mo>-</mo>
           <mi>N</mi>
          </mrow>
          <mo>)</mo>
         </mrow>
         <mo lspace="0pt" rspace="3.5pt">!</mo>
        </mrow>
       </mrow>
      </mfrac>
      <mo>]</mo>
     </mrow>
     <mo>⋅</mo>
     <msup>
      <mi>M</mi>
      <mi>N</mi>
     </msup>
    </mrow>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <mi>X</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>N</mi>
     </msubsup>
     <mrow>
      <mrow>
       <mo>[</mo>
       <mfrac>
        <mrow>
         <mrow>
          <mo>(</mo>
          <mrow>
           <mi>S</mi>
           <mo>-</mo>
           <mn>1</mn>
          </mrow>
          <mo>)</mo>
         </mrow>
         <mo lspace="0pt" rspace="3.5pt">!</mo>
        </mrow>
        <mrow>
         <mrow>
          <mi>X</mi>
          <mo lspace="0pt" rspace="3.5pt">!</mo>
         </mrow>
         <mo>⋅</mo>
         <mrow>
          <mrow>
           <mo>(</mo>
           <mrow>
            <mi>S</mi>
            <mo>-</mo>
            <mn>1</mn>
            <mo>-</mo>
            <mi>X</mi>
           </mrow>
           <mo>)</mo>
          </mrow>
          <mo lspace="0pt" rspace="3.5pt">!</mo>
         </mrow>
        </mrow>
       </mfrac>
       <mo>]</mo>
      </mrow>
      <mo>⋅</mo>
      <msup>
       <mi>M</mi>
       <mi>X</mi>
      </msup>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>P</ci>
     <ci>b</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <ci>normal-⋅</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <divide></divide>
        <apply>
         <factorial></factorial>
         <apply>
          <minus></minus>
          <ci>S</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <apply>
         <ci>normal-⋅</ci>
         <apply>
          <factorial></factorial>
          <ci>N</ci>
         </apply>
         <apply>
          <factorial></factorial>
          <apply>
           <minus></minus>
           <ci>S</ci>
           <cn type="integer">1</cn>
           <ci>N</ci>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>M</ci>
       <ci>N</ci>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>X</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>N</ci>
      </apply>
      <apply>
       <ci>normal-⋅</ci>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <apply>
         <divide></divide>
         <apply>
          <factorial></factorial>
          <apply>
           <minus></minus>
           <ci>S</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
         <apply>
          <ci>normal-⋅</ci>
          <apply>
           <factorial></factorial>
           <ci>X</ci>
          </apply>
          <apply>
           <factorial></factorial>
           <apply>
            <minus></minus>
            <ci>S</ci>
            <cn type="integer">1</cn>
            <ci>X</ci>
           </apply>
          </apply>
         </apply>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>M</ci>
        <ci>X</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(b)=\frac{\left[\frac{\left(S-1\right)!}{N!\cdot\left(S-1-N\right)!}\right]%
\cdot M^{N}}{\sum_{X=1}^{N}\left[\frac{\left(S-1\right)!}{X!\cdot\left(S-1-X%
\right)!}\right]\cdot M^{X}}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Erlang_(unit):18">
 <semantics>
  <mrow>
   <mrow>
    <mi>M</mi>
    <mo>=</mo>
    <mfrac>
     <mi>A</mi>
     <mrow>
      <mi>S</mi>
      <mo>-</mo>
      <mrow>
       <mi>A</mi>
       <mo>⋅</mo>
       <mrow>
        <mo>(</mo>
        <mrow>
         <mn>1</mn>
         <mo>-</mo>
         <mrow>
          <mi>P</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>b</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
        </mrow>
        <mo>)</mo>
       </mrow>
      </mrow>
     </mrow>
    </mfrac>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>M</ci>
    <apply>
     <divide></divide>
     <ci>A</ci>
     <apply>
      <minus></minus>
      <ci>S</ci>
      <apply>
       <ci>normal-⋅</ci>
       <ci>A</ci>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
        <apply>
         <times></times>
         <ci>P</ci>
         <ci>b</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M=\frac{A}{S-A\cdot\left(1-P(b)\right)}.
  </annotation>
 </semantics>
</math>

</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Spectral_efficiency#System_spectral_efficiency" title="wikilink">System spectral efficiency</a> (discussing cellular network capacity in Erlang/MHz/cell)</li>
<li><a href="Agner_Krarup_Erlang" title="wikilink">A. K. Erlang</a></li>
<li><a href="Call_centre" title="wikilink">Call centre</a></li>
<li><a href="Discrete_event_simulation" title="wikilink">Discrete event simulation</a></li>
<li><a href="Erlang_programming_language" title="wikilink">Erlang programming language</a></li>
<li><a href="Erlang_distribution" title="wikilink">Erlang distribution</a></li>
<li><a href="Poisson_distribution" title="wikilink">Poisson distribution</a></li>
<li><a href="Traffic_mix" title="wikilink">Traffic mix</a></li>
</ul>
<h2 id="references">References</h2>
<h2 id="tools">Tools</h2>
<ul>
<li><a href="http://www.math.vu.nl/~koole/ccmath/ErlangC/index.php">Online Erlang C Calculator from Vrije University, Netherlands</a></li>
<li><a href="http://www.cs.usyd.edu.au/~dcorbett/erlang.cgi">Online Erlang B Calculator with source code in </a><a href="C_(programming_language)" title="wikilink">C</a> and <a class="uri" href="JavaScript" title="wikilink">JavaScript</a></li>
<li><a href="http://www.cas.mcmaster.ca/~qiao/publications/erlang/newerlang.html">A Robust Erlang B Calculator from McMaster University, Canada</a></li>
<li><a href="http://www.mitan.co.uk/mainerlg_spsh.htm">Erlang C using spreadsheets from Mitan Ltd.</a></li>
<li><a href="http://www.portagecommunications.com">Call Center Designer Erlang C tool from Portage Communications, Inc.</a></li>
<li><a href="http://www.had2know.com/technology/extended-erlang-b-calculator-formula.html">Extended Erlang B Calculator with equation, Had2Know Technology</a></li>
<li><a href="http://comp.plansis.nl">Public Web based Erlang Calculator from Plansis – Innovators in planning</a></li>
<li><a href="http://www.agenses.com/489/free_erlang_c_calculator/">Erlang C Calculator from Agenses – including average waiting time</a></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.EasyErlang.com/papers/Traffic_Modeling.htm">Traffic Modeling and Resource Allocation in Call Centers by Diagnostic Strategies (definitions and formulae)</a></li>
<li><a href="http://www.pccl.demon.co.uk/spreadsheets/">Erlang-B and Erlang-C spreadsheets</a></li>
<li><a href="http://oldwww.com.dtu.dk/teletraffic/erlangbook/pps138-155.pdf">Erlang's original paper</a></li>
</ul>

<p>"</p>

<p><a href="Category:Network_performance" title="wikilink">Category:Network performance</a> <a href="Category:Units_of_measurement" title="wikilink">Category:Units of measurement</a> <a class="uri" href="Category:Teletraffic" title="wikilink">Category:Teletraffic</a> <a href="Category:Queueing_theory" title="wikilink">Category:Queueing theory</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="http://www.unc.edu/~rowlett/units/dictE.html">How Many? A Dictionary of Units of Measurement</a><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6">Messerli, E.J., 1972. 'Proof of a convexity property of the Erlang B formula'. Bell System Technical Journal 51, 951–953.<a href="#fnref6">↩</a></li>
<li id="fn7">'Designing optimal voice networks for businesses, government, and telephone companies' by J. Jewett, J. Shrago, B. Yomtov, TelCo Research, Chicago, 1980.<a href="#fnref7">↩</a></li>
<li id="fn8">Inayatullah, M., Ullah, F.K., Khan., A.N., 'An Automated Grade Of Service Measuring System', IEEE—ICET 2006, 2nd International Conference on Emerging Technologies, Peshawar, Pakistan 13–14 November 2006, pp. 230–237<a href="#fnref8">↩</a></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
<li id="fn10">[<a class="uri" href="http://www.portagecommunications.com/index.php?option=com_content&amp;task">http://www.portagecommunications.com/index.php?option=com_content&amp;task;</a>;=blogcategory&amp;id;=16&amp;Itemid;=37 A Primer on Call Center Staffing Methods]<a href="#fnref10">↩</a></li>
<li id="fn11"><a href="#fnref11">↩</a></li>
<li id="fn12"><a href="#fnref12">↩</a></li>
<li id="fn13"></li>
<li id="fn14"></li>
<li id="fn15"><a href="#fnref15">↩</a></li>
<li id="fn16"></li>
</ol>
</section>
</body>
</html>
