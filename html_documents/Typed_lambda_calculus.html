<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="401">Typed lambda calculus</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Typed lambda calculus</h1>
<hr/>

<p>A <strong>typed <a href="lambda_calculus" title="wikilink">lambda calculus</a></strong> is a typed <a href="formalism_(mathematics)" title="wikilink">formalism</a> that uses the lambda-symbol (

<math display="inline" id="Typed_lambda_calculus:0">
 <semantics>
  <mi>λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda
  </annotation>
 </semantics>
</math>

) to denote anonymous function abstraction. In this context, types are usually objects of a syntactic nature that are assigned to lambda terms; the exact nature of a type depends on the calculus considered (see kinds below). From a certain point of view, typed lambda calculi can be seen as refinements of the <a href="untyped_lambda_calculus" title="wikilink">untyped lambda calculus</a> but from another point of view, they can also be considered the more fundamental theory and <em>untyped lambda calculus</em> a special case with only one type.</p>

<p>Typed lambda calculi are foundational <a href="programming_languages" title="wikilink">programming languages</a> and are the base of typed <a href="functional_programming_languages" title="wikilink">functional programming languages</a> such as <a href="ML_programming_language" title="wikilink">ML</a> and <a href="Haskell_(programming_language)" title="wikilink">Haskell</a> and, more indirectly, typed <a href="imperative_programming" title="wikilink">imperative programming languages</a>. Typed lambda calculi play an important role in the design of <a href="type_systems" title="wikilink">type systems</a> for programming languages; here typability usually captures desirable properties of the program, e.g. the program will not cause a memory access violation.</p>

<p>Typed lambda calculi are closely related to <a href="mathematical_logic" title="wikilink">mathematical logic</a> and <a href="proof_theory" title="wikilink">proof theory</a> via the <a href="Curry–Howard_isomorphism" title="wikilink">Curry–Howard isomorphism</a> and they can be considered as the <a href="internal_language" title="wikilink">internal language</a> of classes of <a href="category_theory" title="wikilink">categories</a>, e.g. the <a href="simply_typed_lambda_calculus" title="wikilink">simply typed lambda calculus</a> is the language of <a href="cartesian_closed_category" title="wikilink">Cartesian closed categories</a> (CCCs).</p>
<h2 id="kinds-of-typed-lambda-calculi">Kinds of typed lambda calculi</h2>

<p>Various typed lambda calculi have been studied. The simply typed lambda calculus has only one <a href="type_constructor" title="wikilink">type constructor</a>, the arrow 

<math display="inline" id="Typed_lambda_calculus:1">
 <semantics>
  <mo>→</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-→</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \to
  </annotation>
 </semantics>
</math>

, and its only types are <a href="basic_type" title="wikilink">basic types</a> and <a href="function_type" title="wikilink">function types</a> 

<math display="inline" id="Typed_lambda_calculus:2">
 <semantics>
  <mrow>
   <mi>σ</mi>
   <mo>→</mo>
   <mi>τ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>σ</ci>
    <ci>τ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma\to\tau
  </annotation>
 </semantics>
</math>

. <a href="Dialectica_interpretation" title="wikilink">System T</a> extends the simply typed lambda calculus with a type of natural numbers and higher order primitive recursion; in this system all functions provably recursive in <a href="Peano_arithmetic" title="wikilink">Peano arithmetic</a> are definable. <a href="System_F" title="wikilink">System F</a> allows polymorphism by using universal quantification over all types; from a logical perspective it can describe all functions that are provably total in <a href="second-order_logic" title="wikilink">second-order logic</a>. Lambda calculi with <a href="dependent_types" title="wikilink">dependent types</a> are the base of <a href="intuitionistic_type_theory" title="wikilink">intuitionistic type theory</a>, the <a href="calculus_of_constructions" title="wikilink">calculus of constructions</a> and the <a href="LF_(logical_framework)" title="wikilink">logical framework</a> (LF), a pure lambda calculus with dependent types. Based on work by Berardi on <a href="pure_type_system" title="wikilink">pure type systems</a>, <a href="Henk_Barendregt" title="wikilink">Henk Barendregt</a> proposed the <a href="Lambda_cube" title="wikilink">Lambda cube</a> to systematize the relations of pure typed lambda calculi (including simply typed lambda calculus, System F, LF and the calculus of constructions).</p>

<p>Some typed lambda calculi introduce a notion of <em><a href="subtype" title="wikilink">subtyping</a></em>, i.e. if 

<math display="inline" id="Typed_lambda_calculus:3">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>


 is a subtype of 

<math display="inline" id="Typed_lambda_calculus:4">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

, then all terms of type 

<math display="inline" id="Typed_lambda_calculus:5">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 also have type 

<math display="inline" id="Typed_lambda_calculus:6">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

. Typed lambda calculi with subtyping are the simply typed lambda calculus with conjunctive types and <a href="System_F-sub" title="wikilink">System F<sub>&lt;:&gt;<!--:--></sub></a>.</p>

<p>All the systems mentioned so far, with the exception of the untyped lambda calculus, are <em><a href="strongly_normalizing" title="wikilink">strongly normalizing</a></em>: all computations terminate. As a consequence they are consistent as a logic, i.e. there are uninhabited types. There exist, however, typed lambda calculi that are not strongly normalizing. For example the dependently typed lambda calculus with a type of all types (Type : Type) is not normalizing due to <a href="Girard's_paradox" title="wikilink">Girard's paradox</a>. This system is also the simplest pure type system, a formalism which generalizes the Lambda cube. Systems with explicit recursion combinators, such as <a href="Gordon_Plotkin" title="wikilink">Plotkin's</a> PCF, are not normalizing, but they are not intended to be interpreted as a logic. Indeed, <a href="Programming_language_for_Computable_Functions" title="wikilink">PCF</a> (for Programming language for Computable Functions) is a prototypical, typed functional programming language, where types are used to ensure that programs are well-behaved but not necessarily terminating.</p>
<h2 id="applications-to-programming-languages">Applications to programming languages</h2>

<p>In <a href="computer_programming" title="wikilink">computer programming</a>, the routines (functions, procedures, methods) of <a href="strongly_typed_programming_language" title="wikilink">strongly typed programming languages</a> closely correspond to typed lambda expressions. <a href="Eiffel_(programming_language)" title="wikilink">Eiffel</a> has a notion of "inline agent" that makes it possible to define and manipulate typed lambda expressions directly, through such expressions as <strong>agent</strong> (p: PERSON): STRING <strong>do Result</strong> := p.spouse.name <strong>end</strong>, denoting an object that represents a function which returns a person's spouse's name.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Kappa_calculus" title="wikilink">Kappa calculus</a>—an analogue of typed lambda calculus which excludes higher-order functions</li>
</ul>
<h2 id="notes">Notes</h2>
<references>
</references>
<h2 id="references">References</h2>
<h2 id="further-reading">Further reading</h2>
<ul>
<li>Henk Barendregt, <a href="ftp://ftp.cs.ru.nl/pub/CompMath.Found/HBK.ps">Lambda Calculi with Types</a>, Handbook of Logic in Computer Science, Volume II, Oxford University Press, pp. 117–309.</li>
</ul>

<p>"</p>

<p><a href="Category:Lambda_calculus" title="wikilink">Category:Lambda calculus</a> <a href="Category:Logic_in_computer_science" title="wikilink">Category:Logic in computer science</a> <a href="Category:Theory_of_computation" title="wikilink">Category:Theory of computation</a> <a href="Category:Type_theory" title="wikilink">Category:Type theory</a></p>
</body>
</html>
