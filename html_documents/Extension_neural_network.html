<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="891">Extension neural network</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Extension neural network</h1>
<hr/>

<p><strong>Extension neural network</strong> is a pattern recognition method found by M. H. Wang and C. P. Hung in 2003 to classify instances of data sets. Extension neural network is composed of <a href="artificial_neural_network" title="wikilink">artificial neural network</a> and extension theory concepts. It uses the fast and adaptive learning capability of neural network and correlation estimation property of extension theory by calculating extension distance.<br/>
ENN was used in:</p>
<ul>
<li>Failure detection in machinery.</li>
<li>Tissue classification through MRI.</li>
<li>Fault recognition in automotive engine.</li>
<li>State of charge estimation in lead-acid battery.</li>
<li>Classification with incomplete survey data.</li>
</ul>
<h2 id="extension-theory">Extension Theory</h2>

<p>Extension theory was first proposed by Cai in 1983 to solve contradictory problems. While classical mathematic is familiar with quantity and forms of objects, extension theory transforms these objects to matter-element model.<br/>
<mtpl></mtpl><br/>
where in matter 

<math display="inline" id="Extension_neural_network:0">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>


, 

<math display="inline" id="Extension_neural_network:1">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

 is the name or type, 

<math display="inline" id="Extension_neural_network:2">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

 is its characteristics and 

<math display="inline" id="Extension_neural_network:3">
 <semantics>
  <mi>V</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>V</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V
  </annotation>
 </semantics>
</math>

 is the corresponding value for the characteristic. There is a corresponding example in equation 2.<br/>
</p>

<p>where 

<math display="inline" id="Extension_neural_network:4">
 <semantics>
  <mrow>
   <mi>H</mi>
   <mi>e</mi>
   <mi>i</mi>
   <mi>g</mi>
   <mi>h</mi>
   <mi>t</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>H</ci>
    <ci>e</ci>
    <ci>i</ci>
    <ci>g</ci>
    <ci>h</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Height
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Extension_neural_network:5">
 <semantics>
  <mrow>
   <mi>W</mi>
   <mi>e</mi>
   <mi>i</mi>
   <mi>g</mi>
   <mi>h</mi>
   <mi>t</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>W</ci>
    <ci>e</ci>
    <ci>i</ci>
    <ci>g</ci>
    <ci>h</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Weight
  </annotation>
 </semantics>
</math>


 characteristics form extension sets. These extension sets are defined by the 

<math display="inline" id="Extension_neural_network:6">
 <semantics>
  <mi>V</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>V</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V
  </annotation>
 </semantics>
</math>

 values which are range values for corresponding characteristics. Extension theory concerns with the extension correlation function between matter-element models like shown in equation 2 and extension sets. Extension correlation function is used to define extension space which is composed of pairs of elements and their extension correlation functions. The extension space formula is shown in equation 3.<br/>
<br/>
where, 

<math display="inline" id="Extension_neural_network:7">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 is the extension space, 

<math display="inline" id="Extension_neural_network:8">
 <semantics>
  <mi>U</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>U</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U
  </annotation>
 </semantics>
</math>

 is the object space, 

<math display="inline" id="Extension_neural_network:9">
 <semantics>
  <mi>K</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>K</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K
  </annotation>
 </semantics>
</math>

 is the extension correlation function, 

<math display="inline" id="Extension_neural_network:10">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>


 is an element from the object space and 

<math display="inline" id="Extension_neural_network:11">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

 is the corresponding extension correlation function output of element 

<math display="inline" id="Extension_neural_network:12">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

. 

<math display="inline" id="Extension_neural_network:13">
 <semantics>
  <mrow>
   <mi>K</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>K</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K(x)
  </annotation>
 </semantics>
</math>

 maps 

<math display="inline" id="Extension_neural_network:14">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 to a membership interval 

<math display="inline" id="Extension_neural_network:15">
 <semantics>
  <mrow>
   <mo>[</mo>
   <mrow>
    <mo>-</mo>
    <merror class="ltx_ERROR undefined undefined">
     <mtext>\infin</mtext>
    </merror>
   </mrow>
   <mo>,</mo>
   <merror class="ltx_ERROR undefined undefined">
    <mtext>\infin</mtext>
   </merror>
   <mo>]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="closed">
    <apply>
     <minus></minus>
     <mtext>\infin</mtext>
    </apply>
    <mtext>\infin</mtext>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left[-\infin,\infin\right]
  </annotation>
 </semantics>
</math>


. Negative region represents an element not belonging membership degree to a class and positive region vice versa. If 

<math display="inline" id="Extension_neural_network:16">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 is mapped to 

<math display="inline" id="Extension_neural_network:17">
 <semantics>
  <mrow>
   <mo>[</mo>
   <mn>0</mn>
   <mo>,</mo>
   <mn>1</mn>
   <mo>]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="closed">
    <cn type="integer">0</cn>
    <cn type="integer">1</cn>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left[0,1\right]
  </annotation>
 </semantics>
</math>

, extension theory acts like <a href="fuzzy_set" title="wikilink">fuzzy set</a> theory. The correlation function can be shown with the equation 4.<br/>
<br/>
where, 

<math display="inline" id="Extension_neural_network:18">
 <semantics>
  <msub>
   <mi>X</mi>
   <mrow>
    <mi>i</mi>
    <mi>n</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>X</ci>
    <apply>
     <times></times>
     <ci>i</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{in}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Extension_neural_network:19">
 <semantics>
  <msub>
   <mi>X</mi>
   <mrow>
    <mi>o</mi>
    <mi>u</mi>
    <mi>t</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>X</ci>
    <apply>
     <times></times>
     <ci>o</ci>
     <ci>u</ci>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{out}
  </annotation>
 </semantics>
</math>

 are called concerned and neighborhood domain and their intervals are (a,b) and (c,d) respectively. The extended correlation function used for estimation of membership degree between 

<math display="inline" id="Extension_neural_network:20">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>


 and 

<math display="inline" id="Extension_neural_network:21">
 <semantics>
  <msub>
   <mi>X</mi>
   <mrow>
    <mi>i</mi>
    <mi>n</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>X</ci>
    <apply>
     <times></times>
     <ci>i</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{in}
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Extension_neural_network:22">
 <semantics>
  <msub>
   <mi>X</mi>
   <mrow>
    <mi>o</mi>
    <mi>u</mi>
    <mi>t</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>X</ci>
    <apply>
     <times></times>
     <ci>o</ci>
     <ci>u</ci>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{out}
  </annotation>
 </semantics>
</math>

 is shown in equation 5.<br/>
 \\ \frac{\rho(x,X_{in})}{\rho(x,X_{out})-\rho(x,X_{in})} &amp;x;\not \in{X_{in}} \end{cases}  |<mtpl><eqref>5<eqref></eqref></eqref></mtpl>}}<br/>
</p>
<h2 id="extension-neural-network">Extension Neural Network</h2>

<p>Extension neural network has a neural network like appearance. Weight vector resides between the input nodes and output nodes. Output nodes are the representation of input nodes by passing them through the weight vector.</p>

<p>There are total number of input and output nodes are represented by 

<math display="inline" id="Extension_neural_network:23">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Extension_neural_network:24">
 <semantics>
  <msub>
   <mi>n</mi>
   <mi>c</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>n</ci>
    <ci>c</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n_{c}
  </annotation>
 </semantics>
</math>

, respectively. These numbers depend on the number of characteristics and classes. Rather than using one weight value between two layer nodes as in <a href="neural_network" title="wikilink">neural network</a>, extension neural network architecture has two weight values. In extension neural network architecture, for instance 

<math display="inline" id="Extension_neural_network:25">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>


, 

<math display="inline" id="Extension_neural_network:26">
 <semantics>
  <msubsup>
   <mi>x</mi>
   <mrow>
    <mi>i</mi>
    <mi>j</mi>
   </mrow>
   <mi>p</mi>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <ci>p</ci>
    </apply>
    <apply>
     <times></times>
     <ci>i</ci>
     <ci>j</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{p}_{ij}
  </annotation>
 </semantics>
</math>

 is the input which belongs to class 

<math display="inline" id="Extension_neural_network:27">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Extension_neural_network:28">
 <semantics>
  <msub>
   <mi>o</mi>
   <mrow>
    <mi>i</mi>
    <mi>k</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>o</ci>
    <apply>
     <times></times>
     <ci>i</ci>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   o_{ik}
  </annotation>
 </semantics>
</math>

 is the corresponding output for class 

<math display="inline" id="Extension_neural_network:29">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

. The output 

<math display="inline" id="Extension_neural_network:30">
 <semantics>
  <msub>
   <mi>o</mi>
   <mrow>
    <mi>i</mi>
    <mi>k</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>o</ci>
    <apply>
     <times></times>
     <ci>i</ci>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   o_{ik}
  </annotation>
 </semantics>
</math>


 is calculated by using extension distance as shown in equation 6.</p>

<p>{|\frac{w_{kj}^U-w_{kj}^L}{2}|}+1 \right)  

<math display="inline" id="Extension_neural_network:31">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>=</mo>
   <mn>1</mn>
   <mo>,</mo>
   <mn>2</mn>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>.</mo>
   <mo>,</mo>
   <msub>
    <mi>n</mi>
    <mi>c</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">k</csymbol>
    <eq></eq>
    <cn type="integer">1</cn>
    <ci>normal-,</ci>
    <cn type="integer">2</cn>
    <ci>normal-,</ci>
    <ci>normal-…</ci>
    <ci>normal-.</ci>
    <ci>normal-,</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>n</ci>
     <ci>c</ci>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k=1,2,....,n_{c}
  </annotation>
 </semantics>
</math>

 |<mtpl><eqref>6<eqref></eqref></eqref></mtpl>}}</p>

<p>Estimated class is found through searching for the minimum extension distance among the calculated extension distance for all classes as summarized in equation 7, where 

<math display="inline" id="Extension_neural_network:32">
 <semantics>
  <msup>
   <mi>k</mi>
   <mo>*</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>k</ci>
    <times></times>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k^{*}
  </annotation>
 </semantics>
</math>

 is the estimated class.</p>
<h3 id="learning-algorithm">Learning Algorithm</h3>

<p>Each class is composed of ranges of characteristics. These characteristics are the input types or names which come from matter-element model. Weight values in extension neural network represent these ranges. In the learning algorithm, first weights are initialized by searching for the maximum and minimum values of inputs for each class as shown in equation 8</p>

<p>where, 

<math display="inline" id="Extension_neural_network:33">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

 is the instance number and 

<math display="inline" id="Extension_neural_network:34">
 <semantics>
  <mi>j</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>j</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   j
  </annotation>
 </semantics>
</math>

 is represents number of input. This initialization provides classes' ranges according to given training data.</p>

<p>After maintaining weights, center of clusters are found through the equation 9.</p>

<p>Before learning process begins, predefined learning performance rate is given as shown in equation 10</p>

<p>where, 

<math display="inline" id="Extension_neural_network:35">
 <semantics>
  <msub>
   <mi>N</mi>
   <mi>m</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>N</ci>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N_{m}
  </annotation>
 </semantics>
</math>


 is the misclassified instances and 

<math display="inline" id="Extension_neural_network:36">
 <semantics>
  <msub>
   <mi>N</mi>
   <mi>p</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>N</ci>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N_{p}
  </annotation>
 </semantics>
</math>

 is the total number of instances. Initialized parameters are used to classify instances with using equation 6. If the initialization is not sufficient due to the learning performance rate, training is required. In the training step weights are adjusted to classify training data more accurately, therefore reducing learning performance rate is aimed. In each iteration, 

<math display="inline" id="Extension_neural_network:37">
 <semantics>
  <msub>
   <mi>E</mi>
   <mi>τ</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>E</ci>
    <ci>τ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E_{\tau}
  </annotation>
 </semantics>
</math>

 is checked to control if required learning performance is reached. In each iteration every training instance is used for training.<br/>
Instance 

<math display="inline" id="Extension_neural_network:38">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

, belongs to class 

<math display="inline" id="Extension_neural_network:39">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 is shown by:</p>

<p>

<math display="inline" id="Extension_neural_network:40">
 <semantics>
  <mrow>
   <msubsup>
    <mi>X</mi>
    <mi>i</mi>
    <mi>p</mi>
   </msubsup>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <msubsup>
     <mi>x</mi>
     <mrow>
      <mi>i</mi>
      <mn>1</mn>
     </mrow>
     <mi>p</mi>
    </msubsup>
    <mo>,</mo>
    <msubsup>
     <mi>x</mi>
     <mrow>
      <mi>i</mi>
      <mn>2</mn>
     </mrow>
     <mi>p</mi>
    </msubsup>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msubsup>
     <mi>x</mi>
     <mrow>
      <mi>i</mi>
      <mi>n</mi>
     </mrow>
     <mi>p</mi>
    </msubsup>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <ci>i</ci>
     </apply>
     <ci>p</ci>
    </apply>
    <set>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <apply>
        <times></times>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>p</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <apply>
        <times></times>
        <ci>i</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <ci>p</ci>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <apply>
        <times></times>
        <ci>i</ci>
        <ci>n</ci>
       </apply>
      </apply>
      <ci>p</ci>
     </apply>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{i}^{p}=\{x_{i1}^{p},x_{i2}^{p},...,x_{in}^{p}\}
  </annotation>
 </semantics>
</math>


 

<math display="inline" id="Extension_neural_network:41">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>≤</mo>
   <mi>p</mi>
   <mo>≤</mo>
   <msub>
    <mi>n</mi>
    <mi>c</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <cn type="integer">1</cn>
     <ci>p</ci>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>n</ci>
      <ci>c</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1\leq p\leq n_{c}
  </annotation>
 </semantics>
</math>

</p>

<p>Every input data point of 

<math display="inline" id="Extension_neural_network:42">
 <semantics>
  <msubsup>
   <mi>X</mi>
   <mi>i</mi>
   <mi>p</mi>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <ci>i</ci>
    </apply>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{i}^{p}
  </annotation>
 </semantics>
</math>

 is used in extension distance calculation to estimate the class of 

<math display="inline" id="Extension_neural_network:43">
 <semantics>
  <msubsup>
   <mi>X</mi>
   <mi>i</mi>
   <mi>p</mi>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <ci>i</ci>
    </apply>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{i}^{p}
  </annotation>
 </semantics>
</math>

. If the estimated class 

<math display="inline" id="Extension_neural_network:44">
 <semantics>
  <mrow>
   <msup>
    <mi>k</mi>
    <mo>*</mo>
   </msup>
   <mo>=</mo>
   <mi>p</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>k</ci>
     <times></times>
    </apply>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k^{*}=p
  </annotation>
 </semantics>
</math>

 then update is not needed. Whereas, if 

<math display="inline" id="Extension_neural_network:45">
 <semantics>
  <mrow>
   <msup>
    <mi>k</mi>
    <mo>*</mo>
   </msup>
   <mo>≠</mo>
   <mi>p</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <neq></neq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>k</ci>
     <times></times>
    </apply>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k^{*}\neq p
  </annotation>
 </semantics>
</math>


 then update is done. In update case, separators which show the relationship between inputs and classes, are shifted proportional to the distance between the center of clusters and the data points.<br/>
The update formula:</p>

<p>

<math display="inline" id="Extension_neural_network:46">
 <semantics>
  <mrow>
   <msubsup>
    <mi>z</mi>
    <mrow>
     <mi>p</mi>
     <mi>j</mi>
    </mrow>
    <mrow>
     <mi>n</mi>
     <mi>e</mi>
     <mi>w</mi>
    </mrow>
   </msubsup>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mi>z</mi>
     <mrow>
      <mi>p</mi>
      <mi>j</mi>
     </mrow>
     <mrow>
      <mi>o</mi>
      <mi>l</mi>
      <mi>d</mi>
     </mrow>
    </msubsup>
    <mo>+</mo>
    <mrow>
     <mi>η</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msubsup>
        <mi>x</mi>
        <mrow>
         <mi>i</mi>
         <mi>j</mi>
        </mrow>
        <mi>p</mi>
       </msubsup>
       <mo>-</mo>
       <msubsup>
        <mi>z</mi>
        <mrow>
         <mi>p</mi>
         <mi>j</mi>
        </mrow>
        <mrow>
         <mi>o</mi>
         <mi>l</mi>
         <mi>d</mi>
        </mrow>
       </msubsup>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>z</ci>
      <apply>
       <times></times>
       <ci>p</ci>
       <ci>j</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>n</ci>
      <ci>e</ci>
      <ci>w</ci>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>z</ci>
       <apply>
        <times></times>
        <ci>p</ci>
        <ci>j</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>o</ci>
       <ci>l</ci>
       <ci>d</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>η</ci>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <apply>
          <times></times>
          <ci>i</ci>
          <ci>j</ci>
         </apply>
        </apply>
        <ci>p</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>z</ci>
         <apply>
          <times></times>
          <ci>p</ci>
          <ci>j</ci>
         </apply>
        </apply>
        <apply>
         <times></times>
         <ci>o</ci>
         <ci>l</ci>
         <ci>d</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z_{pj}^{new}=z_{pj}^{old}+\eta(x_{ij}^{p}-z_{pj}^{old})
  </annotation>
 </semantics>
</math>

<br/>


<math display="inline" id="Extension_neural_network:47">
 <semantics>
  <mrow>
   <msubsup>
    <mi>z</mi>
    <mrow>
     <msup>
      <mi>k</mi>
      <mo>*</mo>
     </msup>
     <mi>j</mi>
    </mrow>
    <mrow>
     <mi>n</mi>
     <mi>e</mi>
     <mi>w</mi>
    </mrow>
   </msubsup>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mi>z</mi>
     <mrow>
      <msup>
       <mi>k</mi>
       <mo>*</mo>
      </msup>
      <mi>j</mi>
     </mrow>
     <mrow>
      <mi>o</mi>
      <mi>l</mi>
      <mi>d</mi>
     </mrow>
    </msubsup>
    <mo>-</mo>
    <mrow>
     <mi>η</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msubsup>
        <mi>x</mi>
        <mrow>
         <mi>i</mi>
         <mi>j</mi>
        </mrow>
        <mi>p</mi>
       </msubsup>
       <mo>-</mo>
       <msubsup>
        <mi>z</mi>
        <mrow>
         <msup>
          <mi>k</mi>
          <mo>*</mo>
         </msup>
         <mi>j</mi>
        </mrow>
        <mrow>
         <mi>o</mi>
         <mi>l</mi>
         <mi>d</mi>
        </mrow>
       </msubsup>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>z</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>k</ci>
        <times></times>
       </apply>
       <ci>j</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>n</ci>
      <ci>e</ci>
      <ci>w</ci>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>z</ci>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>k</ci>
         <times></times>
        </apply>
        <ci>j</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>o</ci>
       <ci>l</ci>
       <ci>d</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>η</ci>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <apply>
          <times></times>
          <ci>i</ci>
          <ci>j</ci>
         </apply>
        </apply>
        <ci>p</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>z</ci>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>k</ci>
           <times></times>
          </apply>
          <ci>j</ci>
         </apply>
        </apply>
        <apply>
         <times></times>
         <ci>o</ci>
         <ci>l</ci>
         <ci>d</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z_{k^{*}j}^{new}=z_{k^{*}j}^{old}-\eta(x_{ij}^{p}-z_{k^{*}j}^{old})
  </annotation>
 </semantics>
</math>

<br/>


<math display="inline" id="Extension_neural_network:48">
 <semantics>
  <mrow>
   <msubsup>
    <mi>w</mi>
    <mrow>
     <mi>p</mi>
     <mi>j</mi>
    </mrow>
    <mrow>
     <mi>L</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>n</mi>
       <mi>e</mi>
       <mi>w</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </msubsup>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mi>w</mi>
     <mrow>
      <mi>p</mi>
      <mi>j</mi>
     </mrow>
     <mrow>
      <mi>L</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>o</mi>
        <mi>l</mi>
        <mi>d</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </msubsup>
    <mo>+</mo>
    <mrow>
     <mi>η</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msubsup>
        <mi>x</mi>
        <mrow>
         <mi>i</mi>
         <mi>j</mi>
        </mrow>
        <mi>p</mi>
       </msubsup>
       <mo>-</mo>
       <msubsup>
        <mi>z</mi>
        <mrow>
         <mi>p</mi>
         <mi>j</mi>
        </mrow>
        <mrow>
         <mi>o</mi>
         <mi>l</mi>
         <mi>d</mi>
        </mrow>
       </msubsup>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>w</ci>
      <apply>
       <times></times>
       <ci>p</ci>
       <ci>j</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>L</ci>
      <apply>
       <times></times>
       <ci>n</ci>
       <ci>e</ci>
       <ci>w</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>w</ci>
       <apply>
        <times></times>
        <ci>p</ci>
        <ci>j</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>L</ci>
       <apply>
        <times></times>
        <ci>o</ci>
        <ci>l</ci>
        <ci>d</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>η</ci>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <apply>
          <times></times>
          <ci>i</ci>
          <ci>j</ci>
         </apply>
        </apply>
        <ci>p</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>z</ci>
         <apply>
          <times></times>
          <ci>p</ci>
          <ci>j</ci>
         </apply>
        </apply>
        <apply>
         <times></times>
         <ci>o</ci>
         <ci>l</ci>
         <ci>d</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w_{pj}^{L(new)}=w_{pj}^{L(old)}+\eta(x_{ij}^{p}-z_{pj}^{old})
  </annotation>
 </semantics>
</math>

<br/>


<math display="inline" id="Extension_neural_network:49">
 <semantics>
  <mrow>
   <msubsup>
    <mi>w</mi>
    <mrow>
     <mi>p</mi>
     <mi>j</mi>
    </mrow>
    <mrow>
     <mi>U</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>n</mi>
       <mi>e</mi>
       <mi>w</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </msubsup>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mi>w</mi>
     <mrow>
      <mi>p</mi>
      <mi>j</mi>
     </mrow>
     <mrow>
      <mi>U</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>o</mi>
        <mi>l</mi>
        <mi>d</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </msubsup>
    <mo>+</mo>
    <mrow>
     <mi>η</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msubsup>
        <mi>x</mi>
        <mrow>
         <mi>i</mi>
         <mi>j</mi>
        </mrow>
        <mi>p</mi>
       </msubsup>
       <mo>-</mo>
       <msubsup>
        <mi>z</mi>
        <mrow>
         <mi>p</mi>
         <mi>j</mi>
        </mrow>
        <mrow>
         <mi>o</mi>
         <mi>l</mi>
         <mi>d</mi>
        </mrow>
       </msubsup>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>w</ci>
      <apply>
       <times></times>
       <ci>p</ci>
       <ci>j</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>U</ci>
      <apply>
       <times></times>
       <ci>n</ci>
       <ci>e</ci>
       <ci>w</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>w</ci>
       <apply>
        <times></times>
        <ci>p</ci>
        <ci>j</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>U</ci>
       <apply>
        <times></times>
        <ci>o</ci>
        <ci>l</ci>
        <ci>d</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>η</ci>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <apply>
          <times></times>
          <ci>i</ci>
          <ci>j</ci>
         </apply>
        </apply>
        <ci>p</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>z</ci>
         <apply>
          <times></times>
          <ci>p</ci>
          <ci>j</ci>
         </apply>
        </apply>
        <apply>
         <times></times>
         <ci>o</ci>
         <ci>l</ci>
         <ci>d</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w_{pj}^{U(new)}=w_{pj}^{U(old)}+\eta(x_{ij}^{p}-z_{pj}^{old})
  </annotation>
 </semantics>
</math>

<br/>


<math display="inline" id="Extension_neural_network:50">
 <semantics>
  <mrow>
   <msubsup>
    <mi>w</mi>
    <mrow>
     <msup>
      <mi>k</mi>
      <mo>*</mo>
     </msup>
     <mi>j</mi>
    </mrow>
    <mrow>
     <mi>L</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>n</mi>
       <mi>e</mi>
       <mi>w</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </msubsup>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mi>w</mi>
     <mrow>
      <msup>
       <mi>k</mi>
       <mo>*</mo>
      </msup>
      <mi>j</mi>
     </mrow>
     <mrow>
      <mi>L</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>o</mi>
        <mi>l</mi>
        <mi>d</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </msubsup>
    <mo>-</mo>
    <mrow>
     <mi>η</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msubsup>
        <mi>x</mi>
        <mrow>
         <mi>i</mi>
         <mi>j</mi>
        </mrow>
        <mi>p</mi>
       </msubsup>
       <mo>-</mo>
       <msubsup>
        <mi>z</mi>
        <mrow>
         <msup>
          <mi>k</mi>
          <mo>*</mo>
         </msup>
         <mi>j</mi>
        </mrow>
        <mrow>
         <mi>o</mi>
         <mi>l</mi>
         <mi>d</mi>
        </mrow>
       </msubsup>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>w</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>k</ci>
        <times></times>
       </apply>
       <ci>j</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>L</ci>
      <apply>
       <times></times>
       <ci>n</ci>
       <ci>e</ci>
       <ci>w</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>w</ci>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>k</ci>
         <times></times>
        </apply>
        <ci>j</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>L</ci>
       <apply>
        <times></times>
        <ci>o</ci>
        <ci>l</ci>
        <ci>d</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>η</ci>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <apply>
          <times></times>
          <ci>i</ci>
          <ci>j</ci>
         </apply>
        </apply>
        <ci>p</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>z</ci>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>k</ci>
           <times></times>
          </apply>
          <ci>j</ci>
         </apply>
        </apply>
        <apply>
         <times></times>
         <ci>o</ci>
         <ci>l</ci>
         <ci>d</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w_{k^{*}j}^{L(new)}=w_{k^{*}j}^{L(old)}-\eta(x_{ij}^{p}-z_{k^{*}j}^{old})
  </annotation>
 </semantics>
</math>


<br/>


<math display="inline" id="Extension_neural_network:51">
 <semantics>
  <mrow>
   <msubsup>
    <mi>w</mi>
    <mrow>
     <msup>
      <mi>k</mi>
      <mo>*</mo>
     </msup>
     <mi>j</mi>
    </mrow>
    <mrow>
     <mi>U</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>n</mi>
       <mi>e</mi>
       <mi>w</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </msubsup>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mi>w</mi>
     <mrow>
      <msup>
       <mi>k</mi>
       <mo>*</mo>
      </msup>
      <mi>j</mi>
     </mrow>
     <mrow>
      <mi>U</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>o</mi>
        <mi>l</mi>
        <mi>d</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </msubsup>
    <mo>-</mo>
    <mrow>
     <mi>η</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msubsup>
        <mi>x</mi>
        <mrow>
         <mi>i</mi>
         <mi>j</mi>
        </mrow>
        <mi>p</mi>
       </msubsup>
       <mo>-</mo>
       <msubsup>
        <mi>z</mi>
        <mrow>
         <msup>
          <mi>k</mi>
          <mo>*</mo>
         </msup>
         <mi>j</mi>
        </mrow>
        <mrow>
         <mi>o</mi>
         <mi>l</mi>
         <mi>d</mi>
        </mrow>
       </msubsup>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>w</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>k</ci>
        <times></times>
       </apply>
       <ci>j</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>U</ci>
      <apply>
       <times></times>
       <ci>n</ci>
       <ci>e</ci>
       <ci>w</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>w</ci>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>k</ci>
         <times></times>
        </apply>
        <ci>j</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>U</ci>
       <apply>
        <times></times>
        <ci>o</ci>
        <ci>l</ci>
        <ci>d</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>η</ci>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <apply>
          <times></times>
          <ci>i</ci>
          <ci>j</ci>
         </apply>
        </apply>
        <ci>p</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>z</ci>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>k</ci>
           <times></times>
          </apply>
          <ci>j</ci>
         </apply>
        </apply>
        <apply>
         <times></times>
         <ci>o</ci>
         <ci>l</ci>
         <ci>d</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w_{k^{*}j}^{U(new)}=w_{k^{*}j}^{U(old)}-\eta(x_{ij}^{p}-z_{k^{*}j}^{old})
  </annotation>
 </semantics>
</math>

</p>

<p>To classify the instance 

<math display="inline" id="Extension_neural_network:52">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

 accurately, separator of class 

<math display="inline" id="Extension_neural_network:53">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 for input 

<math display="inline" id="Extension_neural_network:54">
 <semantics>
  <mi>j</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>j</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   j
  </annotation>
 </semantics>
</math>

 moves close to data-point of instance 

<math display="inline" id="Extension_neural_network:55">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>


, whereas separator of class 

<math display="inline" id="Extension_neural_network:56">
 <semantics>
  <msup>
   <mi>k</mi>
   <mo>*</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>k</ci>
    <times></times>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k^{*}
  </annotation>
 </semantics>
</math>

 for input 

<math display="inline" id="Extension_neural_network:57">
 <semantics>
  <mi>j</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>j</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   j
  </annotation>
 </semantics>
</math>

 moves far away. In the above image, an update example is given. Assume that instance 

<math display="inline" id="Extension_neural_network:58">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

 belongs to class A, whereas it is classified to class B because extension distance calculation gives out 

<math display="inline" id="Extension_neural_network:59">
 <semantics>
  <mrow>
   <mrow>
    <mi>E</mi>
    <msub>
     <mi>D</mi>
     <mi>A</mi>
    </msub>
   </mrow>
   <mo>></mo>
   <mrow>
    <mi>E</mi>
    <msub>
     <mi>D</mi>
     <mi>B</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <apply>
     <times></times>
     <ci>E</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>D</ci>
      <ci>A</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>E</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>D</ci>
      <ci>B</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ED_{A}>ED_{B}
  </annotation>
 </semantics>
</math>

. After the update, separator of class A moves close to the data-point of instance 

<math display="inline" id="Extension_neural_network:60">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>


 whereas separator of class B moves far away. Consequently, extension distance gives out 

<math display="inline" id="Extension_neural_network:61">
 <semantics>
  <mrow>
   <mrow>
    <mi>E</mi>
    <msub>
     <mi>D</mi>
     <mi>B</mi>
    </msub>
   </mrow>
   <mo>></mo>
   <mrow>
    <mi>E</mi>
    <msub>
     <mi>D</mi>
     <mi>A</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <apply>
     <times></times>
     <ci>E</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>D</ci>
      <ci>B</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>E</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>D</ci>
      <ci>A</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ED_{B}>ED_{A}
  </annotation>
 </semantics>
</math>

, therefore after update instance 

<math display="inline" id="Extension_neural_network:62">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

 is classified to class A.</p>
<h2 id="references">References</h2>
<ol>
<li></li>
<li>Kuei-Hsiang Chao, Meng-Hui Wang, and Chia-Chang Hsu. A novel residual capacity estimation method based on extension neural network for lead-acid batteries. International Symposium on Neural Networks, pages 1145–1154, 2007</li>
<li>Kuei-Hsiang Chao, Meng-Hui Wang, Wen-Tsai Sung, and Guan-Jie Huang. Using enn-1 for fault recognition of automotive engine. Expert Systems with Applications, 37(4):29432947, 2010</li>
<li></li>
<li></li>
<li>Juncai Zhang, Xu Qian, Yu Zhou, and Ai Deng. Condition monitoring method of the equipment based on extension neural network. Chinese Control and Decision Conference, pages 1735–1740, 2010</li>
<li></li>
</ol>

<p>"</p>

<p><a href="Category:Artificial_neural_networks" title="wikilink">Category:Artificial neural networks</a></p>
</body>
</html>
