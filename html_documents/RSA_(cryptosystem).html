<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="880">RSA (cryptosystem)</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>RSA (cryptosystem)</h1>
<hr/>

<p><strong>RSA</strong> is one of the first practical <a href="public-key_cryptography" title="wikilink">public-key cryptosystems</a> and is widely used for secure data transmission. In such a <a class="uri" href="cryptosystem" title="wikilink">cryptosystem</a>, the <a href="encryption_key" title="wikilink">encryption key</a> is public and differs from the <a href="decryption_key" title="wikilink">decryption key</a> which is kept secret. In RSA, this asymmetry is based on the practical difficulty of <a href="Factorization" title="wikilink">factoring</a> the product of two large <a href="prime_number" title="wikilink">prime numbers</a>, the <a href="factoring_problem" title="wikilink">factoring problem</a>. RSA is made of the initial letters of the surnames of <a href="Ron_Rivest" title="wikilink">Ron Rivest</a>, <a href="Adi_Shamir" title="wikilink">Adi Shamir</a>, and <a href="Leonard_Adleman" title="wikilink">Leonard Adleman</a>, who first publicly described the algorithm in 1977. <a href="Clifford_Cocks" title="wikilink">Clifford Cocks</a>, an English mathematician, had developed an equivalent system in 1973, but it was not <a href="Classified_information" title="wikilink">declassified</a> until 1997.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>

<p>A user of RSA creates and then publishes a public key based on two large <a href="prime_number" title="wikilink">prime numbers</a>, along with an auxiliary value. The prime numbers must be kept secret. Anyone can use the public key to encrypt a message, but with currently published methods, if the public key is large enough, only someone with knowledge of the prime numbers can feasibly decode the message.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> Breaking RSA <a class="uri" href="encryption" title="wikilink">encryption</a> is known as the <a href="RSA_problem" title="wikilink">RSA problem</a>; whether it is as hard as the factoring problem remains an open question.</p>
<h2 id="history">History</h2>

<p> The idea of an asymmetric public-private key cryptosystem is attributed to <a href="Whitfield_Diffie" title="wikilink">Diffie</a> and <a href="Martin_Hellman" title="wikilink">Hellman</a>, who published the concept in 1976. The same two also introduced digital signatures and attempted to apply number theory. Their formulation used a shared secret key created from exponentiation of some number, modulo a prime number. However, they left open the problem of realizing a one-way function, possibly because the difficulty of factoring was not well studied at the time.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>

<p><a href="Ron_Rivest" title="wikilink">Ron Rivest</a>, <a href="Adi_Shamir" title="wikilink">Adi Shamir</a>, and <a href="Leonard_Adleman" title="wikilink">Leonard Adleman</a> at <a href="Massachusetts_Institute_of_Technology" title="wikilink">MIT</a> made several attempts over the course of a year to create a one-way function that is hard to inverse. Rivest and Shamir, as computer scientists, proposed many potential functions while Adleman, as a mathematician, was responsible for finding their weaknesses. They tried many approaches including "knapsack-based" and "permutation polynomials". At a time they thought it was impossible for what they wanted to achieve due to contradictory requirements.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> In April 1977, they spent <a class="uri" href="Passover" title="wikilink">Passover</a> at the house of a student and drank a good deal of <a class="uri" href="Manischewitz" title="wikilink">Manischewitz</a> wine before returning to their home at around midnight.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> Rivest, unable to sleep, lay on the couch with a math textbook and started thinking about their one-way function. He spent the rest of the night formalizing his idea and had much of the paper ready by daybreak. The algorithm is now known as RSA - the initials of their surnames in same order as their paper.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>

<p><a href="Clifford_Cocks" title="wikilink">Clifford Cocks</a>, an English <a class="uri" href="mathematician" title="wikilink">mathematician</a> working for the <a href="United_Kingdom" title="wikilink">UK</a> intelligence agency <a href="Government_Communications_Headquarters" title="wikilink">GCHQ</a>, described an equivalent system in an internal document in 1973. However, given the relatively expensive computers needed to implement it at the time, it was mostly considered a curiosity and, as far as is publicly known, was never deployed. His discovery, however, was not revealed until 1997 due to its top-secret classification.</p>
<h2 id="patent">Patent</h2>

<p><a href="Massachusetts_Institute_of_Technology" title="wikilink">MIT</a> was granted  for a "Cryptographic communications system and method" that used the algorithm, on September 20, 1983. Though the patent was going to expire on September 21, 2000 (the <a href="term_of_patent" title="wikilink">term of patent</a> was 17 years at the time), the algorithm was released to the public domain by <a href="RSA_Security" title="wikilink">RSA Security</a> on September 6, 2000, two weeks earlier.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> Since a paper describing the algorithm had been published in August 1977,<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> prior to the December 1977 <a href="filing_date" title="wikilink">filing date</a> of the <a href="patent_application" title="wikilink">patent application</a>, regulations in much of the rest of the world precluded <a href="patent" title="wikilink">patents</a> elsewhere and only the <a href="United_States" title="wikilink">US</a> patent was granted. Had Cocks' work been publicly known, a patent in the US would not have been possible either.</p>

<p>From the <a href="Derwent_World_Patent_Index" title="wikilink">DWPI</a>'s abstract of the patent, </p>
<h2 id="operation">Operation</h2>

<p>The RSA algorithm involves three steps: <a href="Key_(cryptography)" title="wikilink">key</a> generation, encryption and decryption.</p>
<h3 id="key-generation">Key generation</h3>

<p>RSA involves a <em>public key</em> and a <em><a href="private_key" title="wikilink">private key</a>.</em> The public key can be known by everyone and is used for encrypting messages. Messages encrypted with the public key can only be decrypted in a reasonable amount of time using the private key. The keys for the RSA algorithm are generated the following way:</p>
<ol>
<li>Choose two distinct <a href="prime_number" title="wikilink">prime numbers</a> <em>p</em> and <em>q</em>.
<ul>
<li>For security purposes, the integers <em>p</em> and <em>q</em> should be chosen at random, and should be of similar bit-length. Prime integers can be efficiently found using a <a href="primality_test" title="wikilink">primality test</a>.</li>
</ul></li>
<li>Compute .
<ul>
<li><em>n</em> is used as the <a href="Modular_arithmetic" title="wikilink">modulus</a> for both the public and private keys. Its length, usually expressed in bits, is the <a href="key_length" title="wikilink">key length</a>.</li>
</ul></li>
<li>Compute , where φ is <a href="Euler's_totient_function" title="wikilink">Euler's totient function</a>. This value is kept private.</li>
<li>Choose an integer <em>e</em> such that  and ; i.e., <em>e</em> and φ(<em>n</em>) are <a class="uri" href="coprime" title="wikilink">coprime</a>.
<ul>
<li><em>e</em> is released as the public key exponent.</li>
<li><em>e</em> having a short <a class="uri" href="bit-length" title="wikilink">bit-length</a> and small <a href="Hamming_weight" title="wikilink">Hamming weight</a> results in more efficient encryption – most commonly <mtpl></mtpl>. However, much smaller values of <em>e</em> (such as 3) have been shown to be less secure in some settings.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></li>
</ul></li>
<li>Determine <em>d</em> as <mtpl></mtpl>; i.e., <em>d</em> is the <a href="modular_multiplicative_inverse" title="wikilink">modular multiplicative inverse</a> of <em>e</em> (modulo φ(<em>n</em>)).</li>
</ol>

<p>::*This is more clearly stated as: solve for <em>d</em> given </p>

<p>::*This is often computed using the <a href="extended_Euclidean_algorithm" title="wikilink">extended Euclidean algorithm</a>. Using the pseudocode in the <a href="extended_Euclidean_algorithm#Modular_integers" title="wikilink"><em>Modular integers</em></a> section, inputs <em>a</em> and <em>n</em> correspond to <em>e</em> and <em>φ(</em>n<em>)</em>, respectively.</p>

<p>::*<em>d</em> is kept as the private key exponent.</p>

<p>The <em>public key</em> consists of the modulus <em>n</em> and the public (or encryption) exponent <em>e</em>. The <em>private key</em> consists of the modulus <em>n</em> and the private (or decryption) exponent <em>d</em>, which must be kept secret. <em>p</em>, <em>q</em>, and φ(<em>n</em>) must also be kept secret because they can be used to calculate <em>d</em>.</p>
<ul>
<li>An alternative, used by <a href="PKCS1" title="wikilink">PKCS#1</a>, is to choose <em>d</em> matching  with , where lcm is the <a href="least_common_multiple" title="wikilink">least common multiple</a>. Using λ instead of φ(<em>n</em>) allows more choices for <em>d</em>. λ can also be defined using the <a href="Carmichael_function" title="wikilink">Carmichael function</a>, λ(<em>n</em>).</li>
</ul>
<h3 id="encryption">Encryption</h3>

<p><a href="Alice_and_Bob" title="wikilink">Alice</a> transmits her public key 

<math display="inline" id="RSA_(cryptosystem):0">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>n</mi>
   <mo>,</mo>
   <mi>e</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>n</ci>
    <ci>e</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (n,e)
  </annotation>
 </semantics>
</math>

 to <a href="Alice_and_Bob" title="wikilink">Bob</a> and keeps the private key 

<math display="inline" id="RSA_(cryptosystem):1">
 <semantics>
  <mi>d</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>d</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d
  </annotation>
 </semantics>
</math>

 secret. Bob then wishes to send message 

<math display="inline" id="RSA_(cryptosystem):2">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 to Alice.</p>

<p>He first turns 

<math display="inline" id="RSA_(cryptosystem):3">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>


 into an integer 

<math display="inline" id="RSA_(cryptosystem):4">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

, such that 

<math display="inline" id="RSA_(cryptosystem):5">
 <semantics>
  <mi>c</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>c</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="inline" id="RSA_(cryptosystem):7">
 <semantics>
  <mi>c</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>c</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c
  </annotation>
 </semantics>
</math>

</p>

<p>This can be done efficiently, even for 500-bit numbers, using <a href="Modular_exponentiation" title="wikilink">Modular exponentiation</a>. Bob then transmits 

<math display="inline" id="RSA_(cryptosystem):8">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>


 to Alice.</p>

<p>Note that at least nine values of 

<math display="inline" id="RSA_(cryptosystem):9">
 <semantics>
  <mi>c</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>c</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c
  </annotation>
 </semantics>
</math>

 will yield a ciphertext 

<math display="inline" id="RSA_(cryptosystem):10">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

 equal to 

<math display="inline" id="RSA_(cryptosystem):11">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

,<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a></p>
<h3 id="decryption">Decryption</h3>

<p>Alice can recover 

<math display="inline" id="RSA_(cryptosystem):12">
 <semantics>
  <mi>c</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>c</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c
  </annotation>
 </semantics>
</math>

 from 

<math display="inline" id="RSA_(cryptosystem):13">
 <semantics>
  <mi>d</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>d</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d
  </annotation>
 </semantics>
</math>


 by using her private key exponent 

<math display="block" id="RSA_(cryptosystem):14">
 <semantics>
  <mrow>
   <mi>m</mi>
   <mo>≡</mo>
   <mrow>
    <msup>
     <mi>c</mi>
     <mi>d</mi>
    </msup>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mrow>
     <mo lspace="8.1pt" stretchy="false">(</mo>
     <mrow>
      <mo>mod</mo>
      <mi>n</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <ci>m</ci>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>c</ci>
      <ci>d</ci>
     </apply>
     <apply>
      <ci>pmod</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m\equiv c^{d}\;\;(\mathop{{\rm mod}}n)
  </annotation>
 </semantics>
</math>

 via computing</p>

<p>

<math display="inline" id="RSA_(cryptosystem):15">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

</p>

<p>Given 

<math display="inline" id="RSA_(cryptosystem):16">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

, she can recover the original message 

<math display="block" id="RSA_(cryptosystem):17">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mo>=</mo>
   <mn>61</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>p</ci>
    <cn type="integer">61</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p=61
  </annotation>
 </semantics>
</math>

 by reversing the padding scheme.</p>

<p>(In practice, there are more efficient methods of calculating <em>c</em><sup><em>d</em></sup> using the precomputed values <a href="#Using_the_Chinese_remainder_algorithm" title="wikilink">below</a>.)</p>
<h3 id="a-worked-example">A worked example</h3>

<p>Here is an example of RSA encryption and decryption. The parameters used here are artificially small, but one can also <a href="b:Cryptography/Generate_a_keypair_using_OpenSSL" title="wikilink">use OpenSSL to generate and examine a real keypair</a>.</p>
<ol>
<li>Choose two distinct prime numbers, such as

<p>

<math display="inline" id="RSA_(cryptosystem):18">
 <semantics>
  <mrow>
   <mi>q</mi>
   <mo>=</mo>
   <mn>53</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>q</ci>
    <cn type="integer">53</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q=53
  </annotation>
 </semantics>
</math>


 and 

<math display="block" id="RSA_(cryptosystem):19">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>=</mo>
   <mrow>
    <mn>61</mn>
    <mo>×</mo>
    <mn>53</mn>
   </mrow>
   <mo>=</mo>
   <mn>3233</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>n</ci>
     <apply>
      <times></times>
      <cn type="integer">61</cn>
      <cn type="integer">53</cn>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="integer">3233</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n=61\times 53=3233
  </annotation>
 </semantics>
</math>

</p></li>
<li>Compute  giving

<p>

<math display="block" id="RSA_(cryptosystem):20">
 <semantics>
  <mrow>
   <mrow>
    <mi>φ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>3233</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mn>61</mn>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mn>53</mn>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>3120</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>φ</ci>
      <cn type="integer">3233</cn>
     </apply>
     <apply>
      <times></times>
      <apply>
       <minus></minus>
       <cn type="integer">61</cn>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <minus></minus>
       <cn type="integer">53</cn>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="integer">3120</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varphi(3233)=(61-1)(53-1)=3120
  </annotation>
 </semantics>
</math>

</p></li>
<li>Compute the <a class="uri" href="totient" title="wikilink">totient</a> of the product as  giving

<p>

<math display="inline" id="RSA_(cryptosystem):21">
 <semantics>
  <mrow>
   <mi>e</mi>
   <mo>=</mo>
   <mn>17</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>e</ci>
    <cn type="integer">17</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e=17
  </annotation>
 </semantics>
</math>

</p></li>
<li>Choose any number  that is <a class="uri" href="coprime" title="wikilink">coprime</a> to 3120. Choosing a prime number for <em>e</em> leaves us only to check that <em>e</em> is not a divisor of 3120.
<dl>
<dd>Let 

<math display="block" id="RSA_(cryptosystem):22">
 <semantics>
  <mrow>
   <mi>d</mi>
   <mo>=</mo>
   <mn>2753</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>d</ci>
    <cn type="integer">2753</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d=2753
  </annotation>
 </semantics>
</math>


</dd>
</dl></li>
<li>Compute <em>d</em>, the <a href="modular_multiplicative_inverse" title="wikilink">modular multiplicative inverse</a> of  yielding,

<p>

<math display="inline" id="RSA_(cryptosystem):23">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>e</mi>
     <mo>×</mo>
     <mpadded width="+2.8pt">
      <mi>d</mi>
     </mpadded>
    </mrow>
    <mrow>
     <mo rspace="5.3pt">mod</mo>
     <mi>φ</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <times></times>
      <ci>e</ci>
      <ci>d</ci>
     </apply>
     <apply>
      <ci>mod</ci>
      <ci>φ</ci>
     </apply>
     <ci>n</ci>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e\times d\;\operatorname{mod}\;\varphi(n)=1
  </annotation>
 </semantics>
</math>


</p>
<dl>
<dd>Worked example for the modular multiplicative inverse:
</dd>
<dd>

<math display="inline" id="RSA_(cryptosystem):24">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mn>17</mn>
     <mo>×</mo>
     <mpadded width="+2.8pt">
      <mn>2753</mn>
     </mpadded>
    </mrow>
    <mrow>
     <mo>mod</mo>
     <mn>3120</mn>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <times></times>
      <cn type="integer">17</cn>
      <cn type="integer">2753</cn>
     </apply>
     <apply>
      <ci>mod</ci>
      <cn type="float">3120</cn>
     </apply>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   17\times 2753\;\operatorname{mod}\;3120=1
  </annotation>
 </semantics>
</math>


</dd>
<dd>

<math display="block" id="RSA_(cryptosystem):25">
 <semantics>
  <mrow>
   <mrow>
    <mi>c</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>m</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mpadded width="+2.8pt">
     <msup>
      <mi>m</mi>
      <mn>17</mn>
     </msup>
    </mpadded>
    <mrow>
     <mo>mod</mo>
     <mn>3233</mn>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>c</ci>
     <ci>m</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>m</ci>
      <cn type="integer">17</cn>
     </apply>
     <apply>
      <ci>mod</ci>
      <cn type="float">3233</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c(m)=m^{17}\;\operatorname{mod}\;3233
  </annotation>
 </semantics>
</math>


</dd>
</dl></li>
</ol>

<p>The <strong>public key</strong> is (, ). For a padded <a class="uri" href="plaintext" title="wikilink">plaintext</a> message <em>m</em>, the encryption function is</p>

<p>

<math display="block" id="RSA_(cryptosystem):26">
 <semantics>
  <mrow>
   <mrow>
    <mi>m</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>c</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mpadded width="+2.8pt">
     <msup>
      <mi>c</mi>
      <mn>2753</mn>
     </msup>
    </mpadded>
    <mrow>
     <mo>mod</mo>
     <mn>3233</mn>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>m</ci>
     <ci>c</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>c</ci>
      <cn type="integer">2753</cn>
     </apply>
     <apply>
      <ci>mod</ci>
      <cn type="float">3233</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m(c)=c^{2753}\;\operatorname{mod}\;3233
  </annotation>
 </semantics>
</math>

</p>

<p>The <strong>private key</strong> is (). For an encrypted <a class="uri" href="ciphertext" title="wikilink">ciphertext</a> <em>c</em>, the decryption function is</p>

<p>

<math display="block" id="RSA_(cryptosystem):27">
 <semantics>
  <mrow>
   <mi>c</mi>
   <mo>=</mo>
   <mrow>
    <mpadded width="+2.8pt">
     <msup>
      <mn>65</mn>
      <mn>17</mn>
     </msup>
    </mpadded>
    <mrow>
     <mo>mod</mo>
     <mn>3233</mn>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>2790</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>c</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">65</cn>
       <cn type="integer">17</cn>
      </apply>
      <apply>
       <ci>mod</ci>
       <cn type="float">3233</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="integer">2790</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c=65^{17}\;\operatorname{mod}\;3233=2790
  </annotation>
 </semantics>
</math>

</p>

<p>For instance, in order to encrypt , we calculate</p>

<p>

<math display="block" id="RSA_(cryptosystem):28">
 <semantics>
  <mrow>
   <mi>m</mi>
   <mo>=</mo>
   <mrow>
    <mpadded width="+2.8pt">
     <msup>
      <mn>2790</mn>
      <mn>2753</mn>
     </msup>
    </mpadded>
    <mrow>
     <mo>mod</mo>
     <mn>3233</mn>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>65</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>m</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">2790</cn>
       <cn type="integer">2753</cn>
      </apply>
      <apply>
       <ci>mod</ci>
       <cn type="float">3233</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="integer">65</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m=2790^{2753}\;\operatorname{mod}\;3233=65
  </annotation>
 </semantics>
</math>

</p>

<p>To decrypt , we calculate</p>

<p>

<math display="inline" id="RSA_(cryptosystem):29">
 <semantics>
  <msub>
   <mi>d</mi>
   <mi>p</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>d</ci>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle d_{p}
  </annotation>
 </semantics>
</math>


</p>

<p>Both of these calculations can be computed efficiently using the <a href="square-and-multiply_algorithm" title="wikilink">square-and-multiply algorithm</a> for <a href="modular_exponentiation" title="wikilink">modular exponentiation</a>. In real-life situations the primes selected would be much larger; in our example it would be trivial to factor <em>n</em>, 3233 (obtained from the freely available public key) back to the primes <em>p</em> and <em>q</em>. Given <em>e</em>, also from the public key, we could then compute <em>d</em> and so acquire the private key.</p>

<p>Practical implementations use the <a href="Chinese_remainder_theorem" title="wikilink">Chinese remainder theorem</a> to speed up the calculation using modulus of factors (mod <em>pq</em> using mod <em>p</em> and mod <em>q</em>).</p>

<p>The values <em>d</em><sub><em>p</em></sub>, <em>d</em><sub><em>q</em></sub> and <em>q</em><sub>inv</sub>, which are part of the private key are computed as follows:</p>

<p>

<math display="inline" id="RSA_(cryptosystem):30">
 <semantics>
  <msub>
   <mi>m</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>m</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle m_{1}
  </annotation>
 </semantics>
</math>


</p>

<p>Here is how <em>d</em><sub><em>p</em></sub>, <em>d</em><sub><em>q</em></sub> and <em>q</em><sub>inv</sub> are used for efficient decryption. (Encryption is efficient by choice of public exponent <em>e</em>)</p>

<p>

<math display="block" id="RSA_(cryptosystem):31">
 <semantics>
  <mrow>
   <msup>
    <mi>a</mi>
    <mrow>
     <mi>p</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msup>
   <mo>≡</mo>
   <mrow>
    <mn>1</mn>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mrow>
     <mo lspace="8.1pt" stretchy="false">(</mo>
     <mrow>
      <mo>mod</mo>
      <mi>p</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>a</ci>
     <apply>
      <minus></minus>
      <ci>p</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <cn type="integer">1</cn>
     <apply>
      <ci>pmod</ci>
      <ci>p</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a^{p-1}\equiv 1\;\;(\mathop{{\rm mod}}p)
  </annotation>
 </semantics>
</math>

</p>
<h3 id="signing-messages">Signing messages</h3>

<p>Suppose <a href="Alice_and_Bob" title="wikilink">Alice</a> uses <a href="Alice_and_Bob" title="wikilink">Bob</a>'s public key to send him an encrypted message. In the message, she can claim to be Alice but Bob has no way of verifying that the message was actually from Alice since anyone can use Bob's public key to send him encrypted messages. In order to verify the origin of a message, RSA can also be used to <a href="digital_signature" title="wikilink">sign</a> a message.</p>

<p>Suppose Alice wishes to send a signed message to Bob. She can use her own private key to do so. She produces a <a href="cryptographic_hash_function" title="wikilink">hash value</a> of the message, raises it to the power of <em>d</em> (modulo <em>n</em>) (as she does when decrypting a message), and attaches it as a "signature" to the message. When Bob receives the signed message, he uses the same hash algorithm in conjunction with Alice's public key. He raises the signature to the power of <em>e</em> (modulo <em>n</em>) (as he does when encrypting a message), and compares the resulting hash value with the message's actual hash value. If the two agree, he knows that the author of the message was in possession of Alice's private key, and that the message has not been tampered with since.</p>
<h2 id="proofs-of-correctness">Proofs of correctness</h2>
<h3 id="proof-using-fermats-little-theorem">Proof using Fermat's little theorem</h3>

<p>The proof of the correctness of RSA is based on <a href="Fermat's_little_theorem" title="wikilink">Fermat's little theorem</a>. This theorem states that if <em>p</em> is prime and <em>p</em> does not divide an integer <em>a</em> then</p>

<p>

<math display="block" id="RSA_(cryptosystem):32">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>e</mi>
     <mi>d</mi>
    </mrow>
    <mo>≡</mo>
    <mrow>
     <mn>1</mn>
     <mspace width="veryverythickmathspace">
     </mspace>
     <mrow>
      <mo lspace="8.1pt" stretchy="false">(</mo>
      <mrow>
       <mo>mod</mo>
       <mrow>
        <mi>ϕ</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mi>p</mi>
          <mi>q</mi>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <times></times>
     <ci>e</ci>
     <ci>d</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <cn type="integer">1</cn>
     <apply>
      <ci>pmod</ci>
      <apply>
       <times></times>
       <ci>ϕ</ci>
       <apply>
        <times></times>
        <ci>p</ci>
        <ci>q</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ed\equiv 1\;\;(\mathop{{\rm mod}}\phi(pq)).
  </annotation>
 </semantics>
</math>

</p>

<p>We want to show that <mtpl></mtpl> for every integer <em>m</em> when <em>p</em> and <em>q</em> are distinct prime numbers and <em>e</em> and <em>d</em> are positive integers satisfying</p>

<p>

<math display="inline" id="RSA_(cryptosystem):33">
 <semantics>
  <mrow>
   <mrow>
    <mi>ϕ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>p</mi>
      <mi>q</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>p</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>q</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>ϕ</ci>
     <apply>
      <times></times>
      <ci>p</ci>
      <ci>q</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <minus></minus>
      <ci>p</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <minus></minus>
      <ci>q</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi(pq)=(p-1)(q-1)
  </annotation>
 </semantics>
</math>

</p>

<p>Since 

<math display="block" id="RSA_(cryptosystem):34">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>e</mi>
     <mi>d</mi>
    </mrow>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>h</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>p</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>q</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>e</ci>
      <ci>d</ci>
     </apply>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <times></times>
     <ci>h</ci>
     <apply>
      <minus></minus>
      <ci>p</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <minus></minus>
      <ci>q</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ed-1=h(p-1)(q-1)
  </annotation>
 </semantics>
</math>

, we can write</p>

<p>

<math display="block" id="RSA_(cryptosystem):35">
 <semantics>
  <mrow>
   <msup>
    <mi>m</mi>
    <mrow>
     <mi>e</mi>
     <mi>d</mi>
    </mrow>
   </msup>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>m</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <mi>e</mi>
        <mi>d</mi>
       </mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </msup>
    <mi>m</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>m</mi>
     <mrow>
      <mi>h</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>p</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>q</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </msup>
    <mi>m</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msup>
     <mrow>
      <mo>(</mo>
      <msup>
       <mi>m</mi>
       <mrow>
        <mi>p</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msup>
      <mo>)</mo>
     </mrow>
     <mrow>
      <mi>h</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>q</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </msup>
    <mi>m</mi>
   </mrow>
   <mo>≡</mo>
   <mrow>
    <msup>
     <mn>1</mn>
     <mrow>
      <mi>h</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>q</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </msup>
    <mi>m</mi>
   </mrow>
   <mo>≡</mo>
   <mrow>
    <mi>m</mi>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mrow>
     <mo lspace="8.1pt" stretchy="false">(</mo>
     <mrow>
      <mo>mod</mo>
      <mi>p</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>m</ci>
      <apply>
       <times></times>
       <ci>e</ci>
       <ci>d</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>m</ci>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <ci>e</ci>
         <ci>d</ci>
        </apply>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>m</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>m</ci>
       <apply>
        <times></times>
        <ci>h</ci>
        <apply>
         <minus></minus>
         <ci>p</ci>
         <cn type="integer">1</cn>
        </apply>
        <apply>
         <minus></minus>
         <ci>q</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
      <ci>m</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>m</ci>
        <apply>
         <minus></minus>
         <ci>p</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <times></times>
        <ci>h</ci>
        <apply>
         <minus></minus>
         <ci>q</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
      <ci>m</ci>
     </apply>
    </apply>
    <apply>
     <equivalent></equivalent>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">1</cn>
       <apply>
        <times></times>
        <ci>h</ci>
        <apply>
         <minus></minus>
         <ci>q</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
      <ci>m</ci>
     </apply>
    </apply>
    <apply>
     <equivalent></equivalent>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="latexml">annotated</csymbol>
      <ci>m</ci>
      <apply>
       <ci>pmod</ci>
       <ci>p</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m^{ed}=m^{(ed-1)}m=m^{h(p-1)(q-1)}m=\left(m^{p-1}\right)^{h(q-1)}m\equiv 1^{h(%
q-1)}m\equiv m\;\;(\mathop{{\rm mod}}p)
  </annotation>
 </semantics>
</math>

</p>

<p>for some nonnegative integer <em>h</em>.</p>

<p>To check whether two numbers, like <em>m<sup>ed</sup></em> and <em>m</em>, are congruent mod <em>pq</em> it suffices (and in fact is equivalent) to check they are congruent mod <em>p</em> and mod <em>q</em> separately. (This is part of the <a href="Chinese_remainder_theorem" title="wikilink">Chinese remainder theorem</a>, although it is not the significant part of that theorem.) To show <mtpl></mtpl>, we consider two cases:  and <mtpl></mtpl>.</p>

<p>In the first case <em>m<sup>ed</sup></em> is a multiple of <em>p</em>, so <mtpl></mtpl>. In the second case</p>

<p>

<math display="inline" id="RSA_(cryptosystem):36">
 <semantics>
  <mrow>
   <mrow>
    <mi>e</mi>
    <mi>d</mi>
   </mrow>
   <mo>≡</mo>
   <mrow>
    <mn>1</mn>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mrow>
     <mo lspace="8.1pt" stretchy="false">(</mo>
     <mrow>
      <mo>mod</mo>
      <mrow>
       <mi>ϕ</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>p</mi>
         <mi>q</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <times></times>
     <ci>e</ci>
     <ci>d</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <cn type="integer">1</cn>
     <apply>
      <ci>pmod</ci>
      <apply>
       <times></times>
       <ci>ϕ</ci>
       <apply>
        <times></times>
        <ci>p</ci>
        <ci>q</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ed\equiv 1\;\;(\mathop{{\rm mod}}\phi(pq))
  </annotation>
 </semantics>
</math>


</p>

<p>where we used <a href="Fermat's_little_theorem" title="wikilink">Fermat's little theorem</a> to replace <em>m</em><sup><em>p</em>−1</sup> mod <em>p</em> with 1.</p>

<p>The verification that <mtpl></mtpl> proceeds in a similar way, treating separately the cases  and <mtpl></mtpl>, using Fermat's little theorem for modulus <em>q</em> in the second case.</p>

<p>This completes the proof that, for any integer <em>m</em>, and integers <em>e</em>, <em>d</em> such that 

<math display="block" id="RSA_(cryptosystem):37">
 <semantics>
  <mrow>
   <msup>
    <mrow>
     <mo>(</mo>
     <msup>
      <mi>m</mi>
      <mi>e</mi>
     </msup>
     <mo>)</mo>
    </mrow>
    <mi>d</mi>
   </msup>
   <mo>≡</mo>
   <mrow>
    <mi>m</mi>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mrow>
     <mo lspace="8.1pt" stretchy="false">(</mo>
     <mrow>
      <mo>mod</mo>
      <mrow>
       <mi>p</mi>
       <mi>q</mi>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>m</ci>
      <ci>e</ci>
     </apply>
     <ci>d</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <ci>m</ci>
     <apply>
      <ci>pmod</ci>
      <apply>
       <times></times>
       <ci>p</ci>
       <ci>q</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left(m^{e}\right)^{d}\equiv m\;\;(\mathop{{\rm mod}}pq)
  </annotation>
 </semantics>
</math>

,</p>

<p>

<math display="block" id="RSA_(cryptosystem):38">
 <semantics>
  <mrow>
   <msup>
    <mi>m</mi>
    <mrow>
     <mi>e</mi>
     <mi>d</mi>
    </mrow>
   </msup>
   <mo>=</mo>
   <msup>
    <mi>m</mi>
    <mrow>
     <mn>1</mn>
     <mo>+</mo>
     <mrow>
      <mi>h</mi>
      <mi>φ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>n</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </msup>
   <mo>=</mo>
   <mrow>
    <mi>m</mi>
    <msup>
     <mrow>
      <mo>(</mo>
      <msup>
       <mi>m</mi>
       <mrow>
        <mi>φ</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>n</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </msup>
      <mo>)</mo>
     </mrow>
     <mi>h</mi>
    </msup>
   </mrow>
   <mo>≡</mo>
   <mrow>
    <mi>m</mi>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>1</mn>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>h</mi>
    </msup>
   </mrow>
   <mo>≡</mo>
   <mrow>
    <mi>m</mi>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mrow>
     <mo lspace="8.1pt" stretchy="false">(</mo>
     <mrow>
      <mo>mod</mo>
      <mi>n</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>m</ci>
      <apply>
       <times></times>
       <ci>e</ci>
       <ci>d</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>m</ci>
      <apply>
       <plus></plus>
       <cn type="integer">1</cn>
       <apply>
        <times></times>
        <ci>h</ci>
        <ci>φ</ci>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>m</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>m</ci>
        <apply>
         <times></times>
         <ci>φ</ci>
         <ci>n</ci>
        </apply>
       </apply>
       <ci>h</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <equivalent></equivalent>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>m</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">1</cn>
       <ci>h</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <equivalent></equivalent>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="latexml">annotated</csymbol>
      <ci>m</ci>
      <apply>
       <ci>pmod</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m^{ed}=m^{1+h\varphi(n)}=m\left(m^{\varphi(n)}\right)^{h}\equiv m(1)^{h}\equiv
m%
\;\;(\mathop{{\rm mod}}n)
  </annotation>
 </semantics>
</math>

</p>
<h3 id="proof-using-eulers-theorem">Proof using Euler's theorem</h3>

<p>Although the original paper of Rivest, Shamir, and Adleman used Fermat's little theorem to explain why RSA works, it is common to find proofs that rely instead on <a href="Euler's_theorem" title="wikilink">Euler's theorem</a>.</p>

<p>We want to show that <mtpl></mtpl>, where  is a product of two different prime numbers and <em>e</em> and <em>d</em> are positive integers satisfying . Since <em>e</em> and <em>d</em> are positive, we can write  for some non-negative integer <em>h</em>. <em>Assuming</em> that <em>m</em> is relatively prime to <em>n</em>, we have</p>

<p>

<math display="inline" id="RSA_(cryptosystem):39">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

</p>

<p>where the second-last congruence follows from <a href="Euler's_theorem" title="wikilink">Euler's theorem</a>.</p>

<p>When <em>m</em> is not relatively prime to <em>n</em>, the argument just given is invalid. This is highly improbable (only a proportion of  numbers have this property), but even in this case the desired congruence is still true. Either  or , and these cases can be treated using the previous proof.</p>
<h2 id="padding">Padding</h2>
<h3 id="attacks-against-plain-rsa">Attacks against plain RSA</h3>

<p>There are a number of attacks against plain RSA as described below.</p>
<ul>
<li>When encrypting with low encryption exponents (e.g., ) and small values of the <em>m</em>, (i.e., <mtpl></mtpl>) the result of <mtpl></mtpl> is strictly less than the modulus <em>n</em>. In this case, ciphertexts can be easily decrypted by taking the <em>e</em>th root of the ciphertext over the integers.</li>
<li>If the same clear text message is sent to <em>e</em> or more recipients in an encrypted way, and the receivers share the same exponent <em>e</em>, but different <em>p</em>, <em>q</em>, and therefore <em>n</em>, then it is easy to decrypt the original clear text message via the <a href="Chinese_remainder_theorem" title="wikilink">Chinese remainder theorem</a>. <a href="Johan_Håstad" title="wikilink">Johan Håstad</a> noticed that this attack is possible even if the cleartexts are not equal, but the attacker knows a linear relation between them.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> This attack was later improved by <a href="Don_Coppersmith" title="wikilink">Don Coppersmith</a>.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a></li>
</ul>
<ul>
<li>Because RSA encryption is a <a href="Deterministic_algorithm" title="wikilink">deterministic encryption algorithm</a> (i.e., has no random component) an attacker can successfully launch a <a href="chosen_plaintext_attack" title="wikilink">chosen plaintext attack</a> against the cryptosystem, by encrypting likely plaintexts under the public key and test if they are equal to the ciphertext. A cryptosystem is called <a href="semantically_secure" title="wikilink">semantically secure</a> if an attacker cannot distinguish two encryptions from each other even if the attacker knows (or has chosen) the corresponding plaintexts. As described above, RSA without padding is not semantically secure. </li>
<li>RSA has the property that the product of two ciphertexts is equal to the encryption of the product of the respective plaintexts. That is <mtpl></mtpl>. Because of this multiplicative property a <a href="chosen-ciphertext_attack" title="wikilink">chosen-ciphertext attack</a> is possible. E.g., an attacker, who wants to know the decryption of a ciphertext <mtpl></mtpl> may ask the holder of the private key to decrypt an unsuspicious-looking ciphertext <mtpl></mtpl> for some value <em>r</em> chosen by the attacker. Because of the multiplicative property <em>c</em>′ is the encryption of . Hence, if the attacker is successful with the attack, he will learn  from which he can derive the message <em>m</em> by multiplying <em>mr</em> with the modular inverse of <em>r</em> modulo <em>n</em>.</li>
</ul>
<h3 id="padding-schemes">Padding schemes</h3>

<p>To avoid these problems, practical RSA implementations typically embed some form of structured, randomized <a href="Padding_(cryptography)" title="wikilink">padding</a> into the value <em>m</em> before encrypting it. This padding ensures that <em>m</em> does not fall into the range of insecure plaintexts, and that a given message, once padded, will encrypt to one of a large number of different possible ciphertexts.</p>

<p>Standards such as <a href="PKCS1" title="wikilink">PKCS#1</a> have been carefully designed to securely pad messages prior to RSA encryption. Because these schemes pad the plaintext <em>m</em> with some number of additional bits, the size of the un-padded message <em>M</em> must be somewhat smaller. RSA padding schemes must be carefully designed so as to prevent sophisticated attacks which may be facilitated by a predictable message structure. Early versions of the PKCS#1 standard (up to version 1.5) used a construction that appears to make RSA semantically secure. However, at Eurocrypt 2000, Coron et al. showed that for some types of messages, this padding does not provide a high enough level of security. Furthermore, at Crypto 1998, Bleichenbacher showed that this version is vulnerable to a practical <a href="adaptive_chosen_ciphertext_attack" title="wikilink">adaptive chosen ciphertext attack</a>. Later versions of the standard include <a href="Optimal_Asymmetric_Encryption_Padding" title="wikilink">Optimal Asymmetric Encryption Padding</a> (OAEP), which prevents these attacks. As such, OAEP should be used in any new application, and PKCS#1 v1.5 padding should be replaced wherever possible. The PKCS#1 standard also incorporates processing schemes designed to provide additional security for RSA signatures (e.g., the Probabilistic Signature Scheme for RSA/<a class="uri" href="RSA-PSS" title="wikilink">RSA-PSS</a>).</p>

<p>Secure padding schemes such as <a class="uri" href="RSA-PSS" title="wikilink">RSA-PSS</a> are as essential for the security of message signing as they are for message encryption. Two US patents on PSS were granted (USPTO 6266771 and USPTO 70360140); however, these patents expired on 24 July 2009 and 25 April 2010, respectively. Use of PSS no longer seems to be encumbered by patents. Note that using different RSA key-pairs for encryption and signing is potentially more secure.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a><a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a></p>
<h2 id="security-and-practical-considerations">Security and practical considerations</h2>
<h3 id="using-the-chinese-remainder-algorithm">Using the Chinese remainder algorithm</h3>

<p>For efficiency many popular crypto libraries (like <a class="uri" href="OpenSSL" title="wikilink">OpenSSL</a>, <a href="Java_(programming_language)" title="wikilink">Java</a> and <a class="uri" href=".NET" title="wikilink">.NET</a>) use the following optimization for decryption and signing based on the <a href="Chinese_remainder_theorem" title="wikilink">Chinese remainder theorem</a>. The following values are precomputed and stored as part of the private key:</p>
<ul>
<li>

<math display="inline" id="RSA_(cryptosystem):40">
 <semantics>
  <mi>q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="RSA_(cryptosystem):41">
 <semantics>
  <mrow>
   <msub>
    <mi>d</mi>
    <mi>P</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>d</mi>
     <mtext>(mod</mtext>
     <mi>p</mi>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mn>1</mn>
     <mtext>)</mtext>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>d</ci>
     <ci>P</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>d</ci>
      <mtext>(mod</mtext>
      <ci>p</ci>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">1</cn>
      <mtext>)</mtext>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d_{P}=d\text{ (mod }p-1\text{)}
  </annotation>
 </semantics>
</math>


: the primes from the key generation,</li>
<li>

<math display="inline" id="RSA_(cryptosystem):42">
 <semantics>
  <mrow>
   <msub>
    <mi>d</mi>
    <mi>Q</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>d</mi>
     <mtext>(mod</mtext>
     <mi>q</mi>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mn>1</mn>
     <mtext>)</mtext>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>d</ci>
     <ci>Q</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>d</ci>
      <mtext>(mod</mtext>
      <ci>q</ci>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">1</cn>
      <mtext>)</mtext>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d_{Q}=d\text{ (mod }q-1\text{)}
  </annotation>
 </semantics>
</math>

,</li>
<li>

<math display="inline" id="RSA_(cryptosystem):43">
 <semantics>
  <mrow>
   <msub>
    <mi>q</mi>
    <mtext>inv</mtext>
   </msub>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>q</mi>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <mtext>(mod</mtext>
    <mi>p</mi>
    <mtext>)</mtext>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>q</ci>
     <mtext>inv</mtext>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>q</ci>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <mtext>(mod</mtext>
     <ci>p</ci>
     <mtext>)</mtext>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q_{\text{inv}}=q^{-1}\text{ (mod }p\text{)}
  </annotation>
 </semantics>
</math>

 and</li>
<li>

<math display="inline" id="RSA_(cryptosystem):44">
 <semantics>
  <mrow>
   <msub>
    <mi>m</mi>
    <mn>1</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>c</mi>
     <msub>
      <mi>d</mi>
      <mi>P</mi>
     </msub>
    </msup>
    <mtext>(mod</mtext>
    <mi>p</mi>
    <mtext>)</mtext>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>m</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>c</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>d</ci>
       <ci>P</ci>
      </apply>
     </apply>
     <mtext>(mod</mtext>
     <ci>p</ci>
     <mtext>)</mtext>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m_{1}=c^{d_{P}}\text{ (mod }p\text{)}
  </annotation>
 </semantics>
</math>

.</li>
</ul>

<p>These values allow the recipient to compute the exponentiation <mtpl></mtpl> more efficiently as follows:</p>
<ul>
<li>

<math display="inline" id="RSA_(cryptosystem):45">
 <semantics>
  <mrow>
   <msub>
    <mi>m</mi>
    <mn>2</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>c</mi>
     <msub>
      <mi>d</mi>
      <mi>Q</mi>
     </msub>
    </msup>
    <mtext>(mod</mtext>
    <mi>q</mi>
    <mtext>)</mtext>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>m</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>c</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>d</ci>
       <ci>Q</ci>
      </apply>
     </apply>
     <mtext>(mod</mtext>
     <ci>q</ci>
     <mtext>)</mtext>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m_{2}=c^{d_{Q}}\text{ (mod }q\text{)}
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="RSA_(cryptosystem):46">
 <semantics>
  <mrow>
   <mi>h</mi>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>q</mi>
     <mtext>inv</mtext>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>m</mi>
       <mn>1</mn>
      </msub>
      <mo>-</mo>
      <msub>
       <mi>m</mi>
       <mn>2</mn>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mtext>(mod</mtext>
    <mi>p</mi>
    <mtext>)</mtext>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>h</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>q</ci>
      <mtext>inv</mtext>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>m</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>m</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <mtext>(mod</mtext>
     <ci>p</ci>
     <mtext>)</mtext>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h=q_{\text{inv}}(m_{1}-m_{2})\text{ (mod }p\text{)}
  </annotation>
 </semantics>
</math>


</li>
<li>

<math display="inline" id="RSA_(cryptosystem):47">
 <semantics>
  <mrow>
   <msub>
    <mi>m</mi>
    <mn>1</mn>
   </msub>
   <mo><</mo>
   <msub>
    <mi>m</mi>
    <mn>2</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>m</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>m</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m_{1}<m_{2}
  </annotation>
 </semantics>
</math>

 (if 

<math display="inline" id="RSA_(cryptosystem):48">
 <semantics>
  <mrow>
   <msub>
    <mi>q</mi>
    <mtext>inv</mtext>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>m</mi>
        <mn>1</mn>
       </msub>
       <mo>+</mo>
       <mrow>
        <mrow>
         <mo>⌈</mo>
         <mrow>
          <mi>q</mi>
          <mo>/</mo>
          <mi>p</mi>
         </mrow>
         <mo>⌉</mo>
        </mrow>
        <mi>p</mi>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>-</mo>
     <msub>
      <mi>m</mi>
      <mn>2</mn>
     </msub>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mtext>(mod</mtext>
   <mi>p</mi>
   <mtext>)</mtext>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>q</ci>
     <mtext>inv</mtext>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>m</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <times></times>
       <apply>
        <ceiling></ceiling>
        <apply>
         <divide></divide>
         <ci>q</ci>
         <ci>p</ci>
        </apply>
       </apply>
       <ci>p</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>m</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <mtext>(mod</mtext>
    <ci>p</ci>
    <mtext>)</mtext>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q_{\text{inv}}((m_{1}+\left\lceil q/p\right\rceil p)-m_{2})\text{ (mod }p\text%
{)}
  </annotation>
 </semantics>
</math>

 then some libraries compute <em>h</em> as 

<math display="inline" id="RSA_(cryptosystem):49">
 <semantics>
  <mrow>
   <mi>m</mi>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>m</mi>
     <mn>2</mn>
    </msub>
    <mo>+</mo>
    <mrow>
     <mi>h</mi>
     <mpadded width="+1.7pt">
      <mi>q</mi>
     </mpadded>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>m</ci>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>m</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <times></times>
      <ci>h</ci>
      <ci>q</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m=m_{2}+hq\,
  </annotation>
 </semantics>
</math>

)</li>
<li>

<math display="inline" id="RSA_(cryptosystem):50">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

</li>
</ul>

<p>This is more efficient than computing <mtpl></mtpl> even though two modular exponentiations have to be computed. The reason is that these two modular exponentiations both use a smaller exponent and a smaller modulus.</p>
<h3 id="integer-factorization-and-rsa-problem">Integer factorization and RSA problem</h3>

<p>The security of the RSA cryptosystem is based on two mathematical problems: the problem of <a href="integer_factorization" title="wikilink">factoring large numbers</a> and the <a href="RSA_problem" title="wikilink">RSA problem</a>. Full decryption of an RSA ciphertext is thought to be infeasible on the assumption that both of these problems are hard, i.e., no efficient algorithm exists for solving them. Providing security against <em>partial</em> decryption may require the addition of a secure <a href="padding_(cryptography)" title="wikilink">padding scheme</a>.</p>

<p>The <a href="RSA_problem" title="wikilink">RSA problem</a> is defined as the task of taking <em>e</em>th roots modulo a composite <em>n</em>: recovering a value <em>m</em> such that <mtpl></mtpl>, where  is an RSA public key and <em>c</em> is an RSA ciphertext. Currently the most promising approach to solving the RSA problem is to factor the modulus <em>n</em>. With the ability to recover prime factors, an attacker can compute the secret exponent <em>d</em> from a public key , then decrypt <em>c</em> using the standard procedure. To accomplish this, an attacker factors <em>n</em> into <em>p</em> and <em>q</em>, and computes  which allows the determination of <em>d</em> from <em>e</em>. No polynomial-time method for factoring large integers on a classical computer has yet been found, but it has not been proven that none exists. <em>See <a href="integer_factorization" title="wikilink">integer factorization</a> for a discussion of this problem</em>.</p>

<p>Multiple polynomial quadratic sieve (MPQS) can be used to factor the public modulus <em>n</em>. The time taken to factor 128-bit and 256-bit <em>n</em> on a desktop computer  are respectively 2 seconds and 35 minutes.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>Bits</p></th>
<th style="text-align: left;">
<p>Time</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>128</p></td>
<td style="text-align: left;">
<p>Less than 2 seconds</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>192</p></td>
<td style="text-align: left;">
<p>16 seconds</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>256</p></td>
<td style="text-align: left;">
<p>35 minutes</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>260</p></td>
<td style="text-align: left;">
<p>1 hour</p></td>
</tr>
</tbody>
</table>

<p><a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a></p>

<p>A tool called yafu can be used to optimize this process.The automation within YAFU is state-of-the-art, combining factorization algorithms in an intelligent and adaptive methodology that minimizes the time to find the factors of arbitrary input integers. Most algorithm implementations are multi-threaded, allowing YAFU to fully utilize multi- or many-core processors (including SNFS, GNFS, SIQS, and ECM). YAFU is primarily a command-line driven tool.<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a> The time taken to factor <em>n</em> using yafu on the same computer was reduced to 103.1746 seconds. Yafu requires the GGNFS binaries to factor N that are 320 bits or larger. This is a very complicated software that requires a certain amount of technical skill to install and configure. It took about 5720s to factor <em>320bit-N</em> on the same computer.<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a></p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>Bits</p></th>
<th style="text-align: left;">
<p>Time</p></th>
<th style="text-align: left;">
<p>Memory used</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>128</p></td>
<td style="text-align: left;">
<p>0.4886 seconds</p></td>
<td style="text-align: left;">
<p>0.1 MiB</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>192</p></td>
<td style="text-align: left;">
<p>3.9979 seconds</p></td>
<td style="text-align: left;">
<p>0.5 MiB</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>256</p></td>
<td style="text-align: left;">
<p>103.1746 seconds</p></td>
<td style="text-align: left;">
<p>3 MiB</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>300</p></td>
<td style="text-align: left;">
<p>1175.7826 seconds</p></td>
<td style="text-align: left;">
<p>10.9 MiB</p></td>
</tr>
</tbody>
</table>

<p><a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a></p>

<p>In 2009, Benjamin Moody has factored an RSA-512 bit key in 73 days using only public software (GGNFS) and his desktop computer (dual-core Athlon64 at 1,900 MHz). Just under 5 gigabytes of disk was required and about 2.5 gigabytes of RAM for the sieving process. The first RSA-512 factorization in 1999 required the equivalent of 8,400 MIPS years over an elapsed time of about 7 months.<a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a></p>

<p>Rivest, Shamir and Adleman note<a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a> that Miller has shown that – assuming the <a href="Generalized_Riemann_hypothesis" title="wikilink">Extended Riemann Hypothesis</a> – finding <em>d</em> from <em>n</em> and <em>e</em> is as hard as factoring <em>n</em> into <em>p</em> and <em>q</em> (up to a polynomial time difference).<a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a> However, Rivest, Shamir and Adleman note (in section IX / D of their paper) that they have not found a proof that inverting RSA is equally hard as factoring.</p>

<p>, the largest factored <a href="RSA_number" title="wikilink">RSA number</a> was 768 bits long (232 decimal digits, see <a class="uri" href="RSA-768" title="wikilink">RSA-768</a>). Its factorization, by a state-of-the-art distributed implementation, took around fifteen hundred CPU years (two years of real time, on many hundreds of computers). No larger RSA key is publically known to have been factored. In practice, RSA keys are typically 1024 to 4096 bits long. Some experts believe that 1024-bit keys may become breakable in the near future or may already be breakable by a sufficiently well-funded attacker (though this is disputed); few see any way that 4096-bit keys could be broken in the foreseeable future. Therefore, it is generally presumed that RSA is secure if <em>n</em> is sufficiently large. If <em>n</em> is 300 <a href="bit" title="wikilink">bits</a> or shorter, it can be factored in a few hours on a <a href="personal_computer" title="wikilink">personal computer</a>, using software already freely available. Keys of 512 bits have been shown to be practically breakable in 1999 when <a class="uri" href="RSA-155" title="wikilink">RSA-155</a> was factored by using several hundred computers and are now factored in a few weeks using common hardware.<a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a> Exploits using 512-bit code-signing certificates that may have been factored were reported in 2011.<a class="footnoteRef" href="#fn23" id="fnref23"><sup>23</sup></a> A theoretical hardware device named <a class="uri" href="TWIRL" title="wikilink">TWIRL</a> and described by Shamir and Tromer in 2003 called into question the security of 1024 bit keys. It is currently recommended that <em>n</em> be at least 2048 bits long.<a class="footnoteRef" href="#fn24" id="fnref24"><sup>24</sup></a></p>

<p>In 1994, <a href="Peter_Shor" title="wikilink">Peter Shor</a> showed that a <a href="quantum_computer" title="wikilink">quantum computer</a> (if one could ever be practically created for the purpose) would be able to factor in <a href="polynomial_time" title="wikilink">polynomial time</a>, breaking RSA; see <a href="Shor's_algorithm" title="wikilink">Shor's algorithm</a>.</p>
<h3 id="faulty-key-generation">Faulty key generation</h3>

<p>Finding the large primes <em>p</em> and <em>q</em> is usually done by testing random numbers of the right size with probabilistic <a href="primality_test" title="wikilink">primality tests</a> which quickly eliminate virtually all non-primes.</p>

<p>Numbers <em>p</em> and <em>q</em> should not be 'too close', lest the <a href="Fermat_factorization" title="wikilink">Fermat factorization</a> for <em>n</em> be successful, if <em>p</em> − <em>q</em>, for instance is less than 2<em>n</em><sup>1/4</sup> (which for even small 1024-bit values of <em>n</em> is ) solving for <em>p</em> and <em>q</em> is trivial. Furthermore, if either <em>p</em> − 1 or <em>q</em> − 1 has only small prime factors, <em>n</em> can be factored quickly by <a href="Pollard's_p_−_1_algorithm" title="wikilink">Pollard's <em>p</em> − 1 algorithm</a>, and these values of <em>p</em> or <em>q</em> should therefore be discarded as well.</p>

<p>It is important that the private key <em>d</em> be large enough. <a href="Michael_J._Wiener" title="wikilink">Michael J. Wiener</a> showed<a class="footnoteRef" href="#fn25" id="fnref25"><sup>25</sup></a> that if <em>p</em> is between <em>q</em> and 2<em>q</em> (which is quite typical) and <mtpl></mtpl>, then <em>d</em> can be computed efficiently from <em>n</em> and <em>e</em>.</p>

<p>There is no known attack against small public exponents such as , provided that proper padding is used. <a href="Coppersmith's_Attack" title="wikilink">Coppersmith's Attack</a> has many applications in attacking RSA specifically if the public exponent <em>e</em> is small and if the encrypted message is short and not padded. <a class="uri" href="65537" title="wikilink">65537</a> is a commonly used value for <em>e</em>; this value can be regarded as a compromise between avoiding potential small exponent attacks and still allowing efficient encryptions (or signature verification). The NIST Special Publication on Computer Security (SP 800-78 Rev 1 of August 2007) does not allow public exponents <em>e</em> smaller than 65537, but does not state a reason for this restriction.</p>
<h3 id="importance-of-strong-random-number-generation">Importance of strong random number generation</h3>

<p>A cryptographically strong <a href="random_number_generator" title="wikilink">random number generator</a>, which has been properly seeded with adequate entropy, must be used to generate the primes <em>p</em> and <em>q</em>. An analysis comparing millions of public keys gathered from the Internet was carried out in early 2012 by Arjen K. Lenstra, James P. Hughes, Maxime Augier, Joppe W. Bos, Thorsten Kleinjung and Christophe Wachter. They were able to factor 0.2% of the keys using only <a href="Euclid's_algorithm" title="wikilink">Euclid's algorithm</a>.<a class="footnoteRef" href="#fn26" id="fnref26"><sup>26</sup></a><a class="footnoteRef" href="#fn27" id="fnref27"><sup>27</sup></a></p>

<p>They exploited a weakness unique to cryptosystems based on integer factorization. If  is one public key and  is another, then if by chance  (but q is not equal to q'), then a simple computation of  factors both <em>n</em> and <em>n</em>′, totally compromising both keys. Lenstra et al. note that this problem can be minimized by using a strong random seed of bit-length twice the intended security level, or by employing a deterministic function to choose <em>q</em> given <em>p</em>, instead of choosing <em>p</em> and <em>q</em> independently.</p>

<p><a href="Nadia_Heninger" title="wikilink">Nadia Heninger</a> was part of a group that did a similar experiment. They used an idea of <a href="Daniel_J._Bernstein" title="wikilink">Daniel J. Bernstein</a> to compute the GCD of each RSA key <em>n</em> against the product of all the other keys <em>n</em>′ they had found (a 729 million digit number), instead of computing each gcd(<em>n</em>,<em>n</em>′) separately, thereby achieving a very significant speedup since after one large division the GCD problem is of normal size.</p>

<p>Heninger says in her blog that the bad keys occurred almost entirely in embedded applications, including "firewalls, routers, VPN devices, remote server administration devices, printers, projectors, and VOIP phones" from over 30 manufacturers. Heninger explains that the one-shared-prime problem uncovered by the two groups results from situations where the pseudorandom number generator is poorly seeded initially and then reseeded between the generation of the first and second primes. Using seeds of sufficiently high entropy obtained from key stroke timings or electronic diode noise or <a href="atmospheric_noise" title="wikilink">atmospheric noise</a> from a radio receiver tuned between stations should solve the problem.<a class="footnoteRef" href="#fn28" id="fnref28"><sup>28</sup></a></p>

<p>Strong random number generation is important throughout every phase of public key cryptography. For instance, if a weak generator is used for the symmetric keys that are being distributed by RSA, then an eavesdropper could bypass the RSA and guess the symmetric keys directly.</p>
<h3 id="timing-attacks">Timing attacks</h3>

<p><a href="Paul_Kocher" title="wikilink">Kocher</a> described a new attack on RSA in 1995: if the attacker Eve knows Alice's hardware in sufficient detail and is able to measure the decryption times for several known ciphertexts, she can deduce the decryption key <em>d</em> quickly. This attack can also be applied against the RSA signature scheme. In 2003, <a href="Dan_Boneh" title="wikilink">Boneh</a> and <a href="David_Brumley" title="wikilink">Brumley</a> demonstrated a more practical attack capable of recovering RSA factorizations over a network connection (e.g., from a <a href="Secure_Socket_Layer" title="wikilink">Secure Socket Layer</a> (SSL)-enabled webserver)<a class="footnoteRef" href="#fn29" id="fnref29"><sup>29</sup></a> This attack takes advantage of information leaked by the <a href="Chinese_remainder_theorem" title="wikilink">Chinese remainder theorem</a> optimization used by many RSA implementations.</p>

<p>One way to thwart these attacks is to ensure that the decryption operation takes a constant amount of time for every ciphertext. However, this approach can significantly reduce performance. Instead, most RSA implementations use an alternate technique known as <a href="blinding_(cryptography)" title="wikilink">cryptographic blinding</a>. RSA blinding makes use of the multiplicative property of RSA. Instead of computing <mtpl></mtpl>, Alice first chooses a secret random value <em>r</em> and computes <mtpl></mtpl>. The result of this computation after applying <a href="Euler's_Theorem" title="wikilink">Euler's Theorem</a> is <mtpl></mtpl> and so the effect of <em>r</em> can be removed by multiplying by its inverse. A new value of <em>r</em> is chosen for each ciphertext. With blinding applied, the decryption time is no longer correlated to the value of the input ciphertext and so the timing attack fails.</p>
<h3 id="adaptive-chosen-ciphertext-attacks">Adaptive chosen ciphertext attacks</h3>

<p>In 1998, <a href="Daniel_Bleichenbacher" title="wikilink">Daniel Bleichenbacher</a> described the first practical <a href="adaptive_chosen_ciphertext_attack" title="wikilink">adaptive chosen ciphertext attack</a>, against RSA-encrypted messages using the PKCS #1 v1 <a href="Padding_(cryptography)" title="wikilink">padding scheme</a> (a padding scheme randomizes and adds structure to an RSA-encrypted message, so it is possible to determine whether a decrypted message is valid). Due to flaws with the PKCS #1 scheme, Bleichenbacher was able to mount a practical attack against RSA implementations of the <a href="Secure_Socket_Layer" title="wikilink">Secure Socket Layer</a> protocol, and to recover session keys. As a result of this work, cryptographers now recommend the use of provably secure padding schemes such as <a href="Optimal_Asymmetric_Encryption_Padding" title="wikilink">Optimal Asymmetric Encryption Padding</a>, and RSA Laboratories has released new versions of PKCS #1 that are not vulnerable to these attacks.</p>
<h3 id="side-channel-analysis-attacks">Side-channel analysis attacks</h3>

<p>A side-channel attack using branch prediction analysis (BPA) has been described. Many processors use a <a href="branch_predictor" title="wikilink">branch predictor</a> to determine whether a conditional branch in the instruction flow of a program is likely to be taken or not. Often these processors also implement <a href="simultaneous_multithreading" title="wikilink">simultaneous multithreading</a> (SMT). Branch prediction analysis attacks use a spy process to discover (statistically) the private key when processed with these processors.</p>

<p>Simple Branch Prediction Analysis (SBPA) claims to improve BPA in a non-statistical way. In their paper, "On the Power of Simple Branch Prediction Analysis",<a class="footnoteRef" href="#fn30" id="fnref30"><sup>30</sup></a> the authors of SBPA (<a href="Onur_Aciicmez" title="wikilink">Onur Aciicmez</a> and <a href="Cetin_Kaya_Koc" title="wikilink">Cetin Kaya Koc</a>) claim to have discovered 508 out of 512 bits of an RSA key in 10 iterations.</p>

<p>A power fault attack on RSA implementations has been described in 2010.<a class="footnoteRef" href="#fn31" id="fnref31"><sup>31</sup></a> The authors recovered the key by varying the CPU power voltage outside limits; this caused multiple power faults on the server.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Trapdoor_function" title="wikilink">Trapdoor function</a></li>
<li><a href="Public-key_cryptography" title="wikilink">Public-key cryptography</a></li>
<li><a href="Key_exchange" title="wikilink">Key exchange</a></li>
<li><a href="Diffie–Hellman_key_exchange" title="wikilink">Diffie–Hellman key exchange</a></li>
<li><a href="Key_management" title="wikilink">Key management</a></li>
<li><a href="Cryptographic_key_length" title="wikilink">Cryptographic key length</a></li>
<li><a href="Computational_complexity_theory" title="wikilink">Computational complexity theory</a></li>
<li><a href="Acoustic_cryptanalysis" title="wikilink">Acoustic cryptanalysis</a></li>
</ul>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<h2 id="further-reading">Further reading</h2>
<ul>
<li></li>
<li></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li>The Original RSA Patent as filed with the U.S. Patent Office by Rivest; Ronald L. (Belmont, MA), Shamir; Adi (Cambridge, MA), Adleman; Leonard M. (Arlington, MA), December 14, 1977, <strong></strong>.</li>
<li><a href="http://www.emc.com/emc-plus/rsa-labs/standards-initiatives/pkcs-rsa-cryptography-standard.htm">PKCS #1: RSA Cryptography Standard</a> (<a href="RSA_Laboratories" title="wikilink">RSA Laboratories</a> website)
<ul>
<li>The <em><a class="uri" href="PKCS" title="wikilink">PKCS</a> #1</em> <a href="standardization" title="wikilink">standard</a> <em>"provides recommendations for the implementation of <a href="public-key_cryptography" title="wikilink">public-key cryptography</a> based on the <strong>RSA</strong> algorithm, covering the following aspects: cryptographic <a href="Primitive_type" title="wikilink">primitives</a>; <a class="uri" href="encryption" title="wikilink">encryption</a> schemes; <a href="Digital_signature" title="wikilink">signature</a> schemes with appendix; <a class="uri" href="ASN.1" title="wikilink">ASN.1</a> syntax for representing keys and for identifying the schemes"</em>.</li>
</ul></li>
<li></li>
<li><a href="http://www.di-mgt.com.au/rsa_alg.html">Thorough walk through of RSA</a></li>
<li><a href="http://www.muppetlabs.com/~breadbox/txt/rsa.html">Prime Number Hide-And-Seek: How the RSA Cipher Works</a></li>
<li><a href="http://eprint.iacr.org/2006/351">Onur Aciicmez, Cetin Kaya Koc, Jean-Pierre Seifert: <em>On the Power of Simple Branch Prediction Analysis</em></a></li>
<li><a href="http://blog.cacert.org/2006/11/193.html">A New Vulnerability In RSA Cryptography, CAcert NEWS Blog</a></li>
<li><a href="http://polarssl.org/source_code">Example of an RSA implementation with PKCS#1 padding (GPL source code)</a></li>
<li><a href="http://www.cryptography.com/resources/whitepapers/TimingAttacks.pdf">Kocher's article about timing attacks</a></li>
<li><a href="http://www.cryptool.org/images/ct1/presentations/RSA/RSA-Flash-en/player.html">An animated explanation of RSA with its mathematical background by CrypTool</a></li>
<li><a href="https://docs.google.com/spreadsheet/ccc?key=0AmFN4Z5iIFsHdHdFMGxXZkZCd2RnQWZBQnZqSUp4UVE#gid=0">A spreadsheet implementing RSA</a></li>
<li><a href="http://inventwithpython.com/hacking"><em>Hacking Secret Ciphers with Python</em></a>, <a href="http://inventwithpython.com/hacking/chapter24.html">Chapter 24, Public Key Cryptography and the RSA Cipher</a></li>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Public-key_encryption_schemes" title="wikilink">Category:Public-key encryption schemes</a> <a href="Category:Digital_signature_schemes" title="wikilink">Category:Digital signature schemes</a> <a class="uri" href="Category:E-commerce" title="wikilink">Category:E-commerce</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
<li id="fn8"></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
<li id="fn10">Namely, the values of 

<math display="inline" id="RSA_(cryptosystem):51">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>


 which are equal to −1, 0, or 1 modulo 

<math display="inline" id="RSA_(cryptosystem):52">
 <semantics>
  <mi>q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q
  </annotation>
 </semantics>
</math>

 while also equal to −1, 0, or 1 modulo 

<math display="inline" id="RSA_(cryptosystem):53">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

. There will be more values of 

<math display="inline" id="RSA_(cryptosystem):54">
 <semantics>
  <mrow>
   <mi>c</mi>
   <mo>=</mo>
   <mi>m</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>c</ci>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c=m
  </annotation>
 </semantics>
</math>

 having 

<math display="inline" id="RSA_(cryptosystem):55">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mi mathvariant="normal">−</mi>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>p</ci>
    <ci>normal-−</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p−1
  </annotation>
 </semantics>
</math>

 if 

<math display="inline" id="RSA_(cryptosystem):56">
 <semantics>
  <mrow>
   <mi>q</mi>
   <mi mathvariant="normal">−</mi>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>q</ci>
    <ci>normal-−</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q−1
  </annotation>
 </semantics>
</math>


 or 

<math display="inline" id="RSA_(cryptosystem):57">
 <semantics>
  <mrow>
   <mi>e</mi>
   <mi mathvariant="normal">−</mi>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>e</ci>
    <ci>normal-−</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e−1
  </annotation>
 </semantics>
</math>

 has other divisors in common with 

<math display="inline" id="RSA_(cryptosystem):58">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

 besides 2 because this gives more values of 

<math display="inline" id="RSA_(cryptosystem):59">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>m</mi>
     <mrow>
      <mi>e</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <mtext>(mod</mtext>
    <mi>p</mi>
    <mtext>)</mtext>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>m</ci>
      <apply>
       <minus></minus>
       <ci>e</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <mtext>(mod</mtext>
     <ci>p</ci>
     <mtext>)</mtext>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m^{e-1}\text{ (mod }p\text{)}=1
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="RSA_(cryptosystem):60">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>m</mi>
     <mrow>
      <mi>e</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <mtext>(mod</mtext>
    <mi>q</mi>
    <mtext>)</mtext>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>m</ci>
      <apply>
       <minus></minus>
       <ci>e</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <mtext>(mod</mtext>
     <ci>q</ci>
     <mtext>)</mtext>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m^{e-1}\text{ (mod }q\text{)}=1
  </annotation>
 </semantics>
</math>

 or <span class="LaTeX">$m^{e - 1}\text{ (mod }q\text{)} = 1$</span> respectively.<a href="#fnref10">↩</a></li>
<li id="fn11"><a href="#fnref11">↩</a></li>
<li id="fn12"><a href="#fnref12">↩</a></li>
<li id="fn13"><a class="uri" href="http://stackoverflow.com/questions/5133246/what-is-the-purpose-of-using-separate-key-pairs-for-signing-and-encryption">http://stackoverflow.com/questions/5133246/what-is-the-purpose-of-using-separate-key-pairs-for-signing-and-encryption</a><a href="#fnref13">↩</a></li>
<li id="fn14"><a class="uri" href="http://www.di-mgt.com.au/rsa_alg.html#weaknesses">http://www.di-mgt.com.au/rsa_alg.html#weaknesses</a><a href="#fnref14">↩</a></li>
<li id="fn15"><a class="uri" href="http://iamnirosh.blogspot.com/2015/02/factoring-rsa-keys.html">http://iamnirosh.blogspot.com/2015/02/factoring-rsa-keys.html</a><a href="#fnref15">↩</a></li>
<li id="fn16"><a class="uri" href="http://yafu.sourceforge.net/">http://yafu.sourceforge.net/</a><a href="#fnref16">↩</a></li>
<li id="fn17"></li>
<li id="fn18"></li>
<li id="fn19"><a class="uri" href="http://lukenotricks.blogspot.se/2009/08/solo-desktop-factorization-of-rsa-512.html">http://lukenotricks.blogspot.se/2009/08/solo-desktop-factorization-of-rsa-512.html</a><a href="#fnref19">↩</a></li>
<li id="fn20"></li>
<li id="fn21"><a href="http://www.cs.cmu.edu/~glmiller/Publications/Papers/Mi75.pdf">Gary L. Miller, "Riemann's Hypothesis and Tests for Primality"</a><a href="#fnref21">↩</a></li>
<li id="fn22"><a href="http://www.mersenneforum.org/showthread.php?t=9787">518-bit GNFS with msieve</a><a href="#fnref22">↩</a></li>
<li id="fn23"><a href="http://blog.fox-it.com/2011/11/21/rsa-512-certificates-abused-in-the-wild/">RSA-512 certificates abused in-the-wild</a><a href="#fnref23">↩</a></li>
<li id="fn24"><a href="http://www.emc.com/emc-plus/rsa-labs/historical/has-the-rsa-algorithm-been-compromised.htm">Has the RSA algorithm been compromised as a result of Bernstein's Paper?</a> What key size should I be using?<a href="#fnref24">↩</a></li>
<li id="fn25"><a href="#fnref25">↩</a></li>
<li id="fn26"><a href="#fnref26">↩</a></li>
<li id="fn27"><a href="#fnref27">↩</a></li>
<li id="fn28"><a class="uri" href="https://freedom-to-tinker.com/blog/nadiah/new-research-theres-no-need-panic-over-factorable-keys-just-mind-your-ps-and-qs">https://freedom-to-tinker.com/blog/nadiah/new-research-theres-no-need-panic-over-factorable-keys-just-mind-your-ps-and-qs</a><a href="#fnref28">↩</a></li>
<li id="fn29"><a href="http://crypto.stanford.edu/~dabo/papers/ssl-timing.pdf">Remote timing attacks are practical.</a>. SSYM'03 Proceedings of the 12th conference on USENIX Security Symposium.<a href="#fnref29">↩</a></li>
<li id="fn30"><a class="uri" href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.80.1438&amp;rep">http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.80.1438&amp;rep;</a>;=rep1&amp;type;=pdf<a href="#fnref30">↩</a></li>
<li id="fn31"><a href="http://www.eecs.umich.edu/~valeria/research/publications/DATE10RSA.pdf">FaultBased Attack of RSA Authentication</a><a href="#fnref31">↩</a></li>
</ol>
</section>
</body>
</html>
