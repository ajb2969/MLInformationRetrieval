<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="207">Random walk closeness centrality</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Random walk closeness centrality</h1>
<hr/>

<p><strong>Random walk closeness centrality</strong> is a measure of <a class="uri" href="centrality" title="wikilink">centrality</a> in a <a href="Graph_(mathematics)" title="wikilink">network</a>, which describes the average speed with which randomly walking processes reach a node from other nodes of the network. The concept was first proposed by Noh and Rieger (2004).<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>
<h2 id="intuition">Intuition</h2>

<p>Consider a network with a finite number of nodes and a random walk process that starts in a certain node and proceeds from node to node along the edges. From each node, it chooses randomly the edge to be followed. In an unweighted network, the probability of choosing a certain edge is equal across all available edges, while in a weighted network it is proportional to the edge weights. A node is considered to be close to other nodes, if the random walk process initiated from any node of the network arrives to this particular node in relatively few steps on average.</p>
<h2 id="definition">Definition</h2>

<p>Consider a weighted network – either directed or undirected – with n nodes denoted by j=1, …, n; and a random walk process on this network with a transition matrix M. The 

<math display="inline" id="Random_walk_closeness_centrality:0">
 <semantics>
  <msub>
   <mi>m</mi>
   <mrow>
    <mi>j</mi>
    <mi>k</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>m</ci>
    <apply>
     <times></times>
     <ci>j</ci>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m_{jk}
  </annotation>
 </semantics>
</math>

 element of M describes the probability of the random walker that has reached node i, proceeds directly to node j. These probabilities are defined in the following way.</p>

<p>

<math display="block" id="Random_walk_closeness_centrality:1">
 <semantics>
  <mrow>
   <mrow>
    <mi>M</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>i</mi>
     <mo>,</mo>
     <mi>j</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <msub>
     <mi>a</mi>
     <mrow>
      <mi>i</mi>
      <mi>j</mi>
     </mrow>
    </msub>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <mi>j</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>n</mi>
     </msubsup>
     <msub>
      <mi>a</mi>
      <mrow>
       <mi>i</mi>
       <mi>j</mi>
      </mrow>
     </msub>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>M</ci>
     <interval closure="open">
      <ci>i</ci>
      <ci>j</ci>
     </interval>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <apply>
       <times></times>
       <ci>i</ci>
       <ci>j</ci>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>j</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>n</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <apply>
        <times></times>
        <ci>i</ci>
        <ci>j</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M(i,j)=\frac{a_{ij}}{\sum_{j=1}^{n}a_{ij}}
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Random_walk_closeness_centrality:2">
 <semantics>
  <msub>
   <mi>a</mi>
   <mrow>
    <mi>i</mi>
    <mi>j</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>a</ci>
    <apply>
     <times></times>
     <ci>i</ci>
     <ci>j</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{ij}
  </annotation>
 </semantics>
</math>

 is the (i,j)th element of the weighting matrix A of the network. When there is no edge between two nodes, the corresponding element of the A matrix is zero.</p>

<p>The random walk closeness centrality of a node i is the inverse of the average mean first passage time to that node:</p>

<p>

<math display="block" id="Random_walk_closeness_centrality:3">
 <semantics>
  <mrow>
   <msubsup>
    <mi>C</mi>
    <mi>i</mi>
    <mrow>
     <mi>R</mi>
     <mi>W</mi>
     <mi>C</mi>
    </mrow>
   </msubsup>
   <mo>=</mo>
   <mfrac>
    <mi>n</mi>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <mi>j</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>n</mi>
     </msubsup>
     <mrow>
      <mi>H</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>j</mi>
       <mo>,</mo>
       <mi>i</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>C</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <times></times>
      <ci>R</ci>
      <ci>W</ci>
      <ci>C</ci>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <ci>n</ci>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>j</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>n</ci>
      </apply>
      <apply>
       <times></times>
       <ci>H</ci>
       <interval closure="open">
        <ci>j</ci>
        <ci>i</ci>
       </interval>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{i}^{RWC}=\frac{n}{\sum_{j=1}^{n}H(j,i)}
  </annotation>
 </semantics>
</math>

</p>
<h3 id="mean-first-passage-time">Mean first passage time</h3>

<p>The mean first passage time from node i to node j is the expected number of steps it takes for the process to reach node j from node i for the first time:</p>

<p>

<math display="block" id="Random_walk_closeness_centrality:4">
 <semantics>
  <mrow>
   <mrow>
    <mi>H</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>i</mi>
     <mo>,</mo>
     <mi>j</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>r</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi mathvariant="normal">∞</mi>
    </munderover>
    <mrow>
     <mi>r</mi>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>i</mi>
      <mo>,</mo>
      <mi>j</mi>
      <mo>,</mo>
      <mi>r</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>H</ci>
     <interval closure="open">
      <ci>i</ci>
      <ci>j</ci>
     </interval>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>r</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <infinity></infinity>
     </apply>
     <apply>
      <times></times>
      <ci>r</ci>
      <ci>P</ci>
      <vector>
       <ci>i</ci>
       <ci>j</ci>
       <ci>r</ci>
      </vector>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H(i,j)=\sum_{r=1}^{\infty}rP(i,j,r)
  </annotation>
 </semantics>
</math>

</p>

<p>where P(i,j,r) denotes the probability that it takes exactly r steps to reach j from i for the first time. To calculate these probabilities of reaching a node for the first time in r steps, it is useful to regard the target node as an absorbing one, and introduce a transformation of M by deleting its j-th row and column and denoting it by 

<math display="inline" id="Random_walk_closeness_centrality:5">
 <semantics>
  <msub>
   <mi>M</mi>
   <mrow>
    <mo>-</mo>
    <mi>j</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>M</ci>
    <apply>
     <minus></minus>
     <ci>j</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M_{-j}
  </annotation>
 </semantics>
</math>

. As the probability of a process starting at i and being in k after r-1 steps is simply given by the (i,k)th element of 

<math display="inline" id="Random_walk_closeness_centrality:6">
 <semantics>
  <msubsup>
   <mi>M</mi>
   <mrow>
    <mo>-</mo>
    <mi>j</mi>
   </mrow>
   <mrow>
    <mi>r</mi>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>M</ci>
     <apply>
      <minus></minus>
      <ci>j</ci>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <ci>r</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M_{-j}^{r-1}
  </annotation>
 </semantics>
</math>

, P(i,j,r) can be expressed as</p>

<p>

<math display="block" id="Random_walk_closeness_centrality:7">
 <semantics>
  <mrow>
   <mrow>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>i</mi>
     <mo>,</mo>
     <mi>j</mi>
     <mo>,</mo>
     <mi>r</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>k</mi>
      <mo>≠</mo>
      <mi>j</mi>
     </mrow>
    </munder>
    <mrow>
     <msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mo stretchy="false">(</mo>
        <msubsup>
         <mi>M</mi>
         <mrow>
          <mo>-</mo>
          <mi>j</mi>
         </mrow>
         <mrow>
          <mi>r</mi>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
        </msubsup>
        <mo stretchy="false">)</mo>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mrow>
       <mi>i</mi>
       <mi>k</mi>
      </mrow>
     </msub>
     <msub>
      <mi>m</mi>
      <mrow>
       <mi>k</mi>
       <mi>j</mi>
      </mrow>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>P</ci>
     <vector>
      <ci>i</ci>
      <ci>j</ci>
      <ci>r</ci>
     </vector>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <neq></neq>
       <ci>k</ci>
       <ci>j</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>M</ci>
         <apply>
          <minus></minus>
          <ci>j</ci>
         </apply>
        </apply>
        <apply>
         <minus></minus>
         <ci>r</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <times></times>
        <ci>i</ci>
        <ci>k</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>m</ci>
       <apply>
        <times></times>
        <ci>k</ci>
        <ci>j</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(i,j,r)=\sum_{k\neq j}((M_{-j}^{r-1}))_{ik}m_{kj}
  </annotation>
 </semantics>
</math>

</p>

<p>Substituting this into the expression for mean first passage time yields</p>

<p>

<math display="block" id="Random_walk_closeness_centrality:8">
 <semantics>
  <mrow>
   <mrow>
    <mi>H</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>i</mi>
     <mo>,</mo>
     <mi>j</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>r</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi mathvariant="normal">∞</mi>
    </munderover>
    <mrow>
     <mi>r</mi>
     <mrow>
      <munder>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mrow>
        <mi>k</mi>
        <mo>≠</mo>
        <mi>j</mi>
       </mrow>
      </munder>
      <mrow>
       <msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mo stretchy="false">(</mo>
          <msubsup>
           <mi>M</mi>
           <mrow>
            <mo>-</mo>
            <mi>j</mi>
           </mrow>
           <mrow>
            <mi>r</mi>
            <mo>-</mo>
            <mn>1</mn>
           </mrow>
          </msubsup>
          <mo stretchy="false">)</mo>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
        <mrow>
         <mi>i</mi>
         <mi>k</mi>
        </mrow>
       </msub>
       <msub>
        <mi>m</mi>
        <mrow>
         <mi>k</mi>
         <mi>j</mi>
        </mrow>
       </msub>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>H</ci>
     <interval closure="open">
      <ci>i</ci>
      <ci>j</ci>
     </interval>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>r</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <infinity></infinity>
     </apply>
     <apply>
      <times></times>
      <ci>r</ci>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <neq></neq>
         <ci>k</ci>
         <ci>j</ci>
        </apply>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>M</ci>
           <apply>
            <minus></minus>
            <ci>j</ci>
           </apply>
          </apply>
          <apply>
           <minus></minus>
           <ci>r</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
         <apply>
          <times></times>
          <ci>i</ci>
          <ci>k</ci>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>m</ci>
         <apply>
          <times></times>
          <ci>k</ci>
          <ci>j</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H(i,j)=\sum_{r=1}^{\infty}r\sum_{k\neq j}((M_{-j}^{r-1}))_{ik}m_{kj}
  </annotation>
 </semantics>
</math>

</p>

<p>Using the formula for the summation of <a href="geometric_series" title="wikilink">geometric series</a> for matrices yields</p>

<p>

<math display="block" id="Random_walk_closeness_centrality:9">
 <semantics>
  <mrow>
   <mrow>
    <mi>H</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>i</mi>
     <mo>,</mo>
     <mi>j</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>k</mi>
      <mo>≠</mo>
      <mi>j</mi>
     </mrow>
    </munder>
    <mrow>
     <msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <msup>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mi>I</mi>
          <mo>-</mo>
          <msub>
           <mi>M</mi>
           <mrow>
            <mo>-</mo>
            <mi>j</mi>
           </mrow>
          </msub>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
        <mrow>
         <mo>-</mo>
         <mn>2</mn>
        </mrow>
       </msup>
       <mo stretchy="false">)</mo>
      </mrow>
      <mrow>
       <mi>i</mi>
       <mi>k</mi>
      </mrow>
     </msub>
     <msub>
      <mi>m</mi>
      <mrow>
       <mi>k</mi>
       <mi>j</mi>
      </mrow>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>H</ci>
     <interval closure="open">
      <ci>i</ci>
      <ci>j</ci>
     </interval>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <neq></neq>
       <ci>k</ci>
       <ci>j</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <minus></minus>
         <ci>I</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>M</ci>
          <apply>
           <minus></minus>
           <ci>j</ci>
          </apply>
         </apply>
        </apply>
        <apply>
         <minus></minus>
         <cn type="integer">2</cn>
        </apply>
       </apply>
       <apply>
        <times></times>
        <ci>i</ci>
        <ci>k</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>m</ci>
       <apply>
        <times></times>
        <ci>k</ci>
        <ci>j</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H(i,j)=\sum_{k\neq j}((I-M_{-j})^{-2})_{ik}m_{kj}
  </annotation>
 </semantics>
</math>

</p>

<p>where I is the n-1 dimensional <a href="identity_matrix" title="wikilink">identity matrix</a>.</p>

<p>For computational convenience, this expression can be vectorized as</p>

<p>

<math display="block" id="Random_walk_closeness_centrality:10">
 <semantics>
  <mrow>
   <mi>H</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>.</mo>
    <mo>,</mo>
    <mi>j</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>I</mi>
     <mo>-</mo>
     <msub>
      <mi>M</mi>
      <mrow>
       <mo>-</mo>
       <mi>j</mi>
      </mrow>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msup>
   <mi>e</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">H</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <ci>normal-.</ci>
     <ci>normal-,</ci>
     <csymbol cd="unknown">j</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">I</csymbol>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>M</ci>
       <apply>
        <minus></minus>
        <ci>j</ci>
       </apply>
      </apply>
      <ci>normal-)</ci>
     </cerror>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <csymbol cd="unknown">e</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H(.,j)=(I-M_{-j})^{-1}e
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Random_walk_closeness_centrality:11">
 <semantics>
  <mrow>
   <mi>H</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>.</mo>
    <mo>,</mo>
    <mi>j</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">H</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <ci>normal-.</ci>
     <ci>normal-,</ci>
     <csymbol cd="unknown">j</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H(.,j)
  </annotation>
 </semantics>
</math>

 is the vector for first passage times for a walk ending at node j, and e is an n-1 dimensional vector of ones.</p>

<p>Mean first passage time is not symmetric, even for undirected graphs.</p>
<h2 id="random-walk-closeness-centrality-in-model-networks">Random walk closeness centrality in model networks</h2>

<p>According to simulations performed by Noh and Rieger (2004), the distribution of random walk closeness centrality in a <a href="Barabási-Albert_model" title="wikilink">Barabási-Albert model</a> is mainly determined by the <a href="degree_distribution" title="wikilink">degree distribution</a>. In such a network, the random walk closeness centrality of a node is roughly proportional to, but does not increase monotonically with its degree.</p>
<h2 id="applications-for-real-networks">Applications for real networks</h2>

<p>Random walk closeness centrality is more relevant measure than the simple <a href="closeness_centrality" title="wikilink">closeness centrality</a> in case of applications where the concept of shortest paths is not meaningful or is very restrictive for a reasonable assessment of the nature of the system. This is the case for example when the analyzed process evolves in the network without any specific intention to reach a certain point, or without the ability of finding the shortest path to reach its target. One example for a random walk in a network is the way a certain coin circulates in an economy: it is passed from one person to another through transactions, without any intention of reaching a specific individual. Another example where the concept of shortest paths is not very useful is a densely connected network. Furthermore, as shortest paths are not influenced by <a href="Loop_(graph_theory)" title="wikilink">self-loops</a>, random walk closeness centrality is more a more adequate measure than <a href="closeness_centrality" title="wikilink">closeness centrality</a> when analyzing networks where <a href="Loop_(graph_theory)" title="wikilink">self-loops</a> are important.</p>

<p>An important application on the field of economics is the analysis of the <a href="input-output_model" title="wikilink">input-output model</a> of an economy, which is represented by a densely connected weighted network with important <a href="Loop_(graph_theory)" title="wikilink">self-loops</a>.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>

<p>The concept is widely used in natural sciences as well. One biological application is the analysis of <a href="protein-protein_interactions" title="wikilink">protein-protein interactions</a>.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>
<h2 id="random-walk-betweenness-centrality">Random walk betweenness centrality</h2>

<p>A related concept, proposed by Newman,<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> is random walk betweenness centrality. Just as random walk closeness centrality is a random walk counterpart of closeness centrality, random walk betweenness centrality is, similarly, the random walk counterpart of <a href="betweenness_centrality" title="wikilink">betweenness centrality</a>. Unlike the usual betweenness centrality measure, it does not only count shortest paths passing through the given node, but all possible paths crossing it.</p>

<p>Formally, the random walk betweenness centrality of a node is</p>

<p>

<math display="block" id="Random_walk_closeness_centrality:12">
 <semantics>
  <mrow>
   <msubsup>
    <mi>C</mi>
    <mi>i</mi>
    <mrow>
     <mi>R</mi>
     <mi>W</mi>
     <mi>B</mi>
    </mrow>
   </msubsup>
   <mo>=</mo>
   <mrow>
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>j</mi>
      <mo>≠</mo>
      <mi>i</mi>
      <mo>≠</mo>
      <mi>k</mi>
     </mrow>
    </munder>
    <msub>
     <mi>r</mi>
     <mrow>
      <mi>j</mi>
      <mi>k</mi>
     </mrow>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>C</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <times></times>
      <ci>R</ci>
      <ci>W</ci>
      <ci>B</ci>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <and></and>
       <apply>
        <neq></neq>
        <ci>j</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <neq></neq>
        <share href="#.cmml">
        </share>
        <ci>k</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>r</ci>
      <apply>
       <times></times>
       <ci>j</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{i}^{RWB}=\sum_{j\neq i\neq k}r_{jk}
  </annotation>
 </semantics>
</math>

</p>

<p>where the 

<math display="inline" id="Random_walk_closeness_centrality:13">
 <semantics>
  <msub>
   <mi>r</mi>
   <mrow>
    <mi>j</mi>
    <mi>k</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>r</ci>
    <apply>
     <times></times>
     <ci>j</ci>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r_{jk}
  </annotation>
 </semantics>
</math>

 element of matrix R contains the probability of a random walk starting at node j with absorbing node k, passing through node i.</p>

<p>Calculating random walk betweenness in large networks is computationally very intensive.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a class="uri" href="Centrality" title="wikilink">Centrality</a></li>
</ul>
<h2 id="references">References</h2>
<references>
</references>

<p>"</p>

<p><a href="Category:Graph_theory" title="wikilink">Category:Graph theory</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">J.-D. Noh and H. Rieger. Random walks on complex networks. Phys. Rev. Lett. 92, 118701 <a href="http://www.uni-saarland.de/fak7/rieger/Paper/PRL92.118701.pdf">1</a><a href="#fnref1">↩</a></li>
<li id="fn2">Blöchl F, Theis FJ, Vega-Redondo F, and Fisher E: Vertex Centralities in Input-Output Networks Reveal the Structure of Modern Economies, Physical Review E, 83(4):046127, 2011. <a href="http://www.eui.eu/Personal/fvega/Articulos-Propios/VertexCentrality.pdf">2</a><a href="#fnref2">↩</a></li>
<li id="fn3">Aidong, Zhang: Protein Interaction Networks: Computational Analysis (Cambridge University Press) 2007 <a href="http://download.bioon.com.cn/upload/201112/22125825_1810.pdf">3</a><a href="#fnref3">↩</a></li>
<li id="fn4">Newman, M.E. J.: A measure of betweenness centrality based on random walks. Social Networks, Volume 27, Issue 1, January 2005, Pages 39–54<a href="#fnref4">↩</a></li>
<li id="fn5">Kang, U., Papadimitriou, S., Sun, J., and Tong, H.: Centralities in Large Networks: Algorithms and Observations. SIAM International Conference on Data Mining 2011, Mesa, Arizona, USA. <a href="http://www.cs.cmu.edu/~ukang/papers/CentralitySDM2011.pdf">4</a><a href="#fnref5">↩</a></li>
</ol>
</section>
</body>
</html>
