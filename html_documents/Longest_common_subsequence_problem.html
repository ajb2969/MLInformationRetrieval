<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1295">Longest common subsequence problem</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Longest common subsequence problem</h1>
<hr/>

<p>The <strong>longest common subsequence</strong> (<strong>LCS</strong>) <strong>problem</strong> is the problem of finding the longest <a class="uri" href="subsequence" title="wikilink">subsequence</a> common to all sequences in a set of sequences (often just two sequences). It differs from problems of finding common <a href="substring" title="wikilink">substrings</a>: unlike substrings, subsequences are not required to occupy consecutive positions within the original sequences. The longest common subsequence problem is a classic <a href="computer_science" title="wikilink">computer science</a> problem, the basis of <a href="data_comparison" title="wikilink">data comparison</a> programs such as the <a href="diff_utility" title="wikilink"><code>diff</code> utility</a>, and has applications in <a class="uri" href="bioinformatics" title="wikilink">bioinformatics</a>. It is also widely used by <a href="Revision_control" title="wikilink">revision control systems</a> such as <a href="Git_(software)" title="wikilink">Git</a> for <a href="Merge_(revision_control)" title="wikilink">reconciling</a> multiple changes made to a revision-controlled collection of files.</p>
<h2 id="complexity">Complexity</h2>

<p>For the general case of an arbitrary number of input sequences, the problem is <a class="uri" href="NP-hard" title="wikilink">NP-hard</a>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> When the number of sequences is constant, the problem is solvable in polynomial time by <a href="dynamic_programming" title="wikilink">dynamic programming</a> (see <em>Solution</em> below). Assume you have 

<math display="inline" id="Longest_common_subsequence_problem:0">
<semantics>
<mi>N</mi>
<annotation-xml encoding="MathML-Content">
<ci>N</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   N
  </annotation>
</semantics>
</math>

 sequences of lengths 

<math display="inline" id="Longest_common_subsequence_problem:1">
<semantics>
<mrow>
<msub>
<mi>n</mi>
<mn>1</mn>
</msub>
<mo>,</mo>
<mi mathvariant="normal">…</mi>
<mo>,</mo>
<msub>
<mi>n</mi>
<mi>N</mi>
</msub>
</mrow>
<annotation-xml encoding="MathML-Content">
<list>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>n</ci>
<cn type="integer">1</cn>
</apply>
<ci>normal-…</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>n</ci>
<ci>N</ci>
</apply>
</list>
</annotation-xml>
<annotation encoding="application/x-tex">
   n_{1},...,n_{N}
  </annotation>
</semantics>
</math>

. A naive search would test each of the 

<math display="inline" id="Longest_common_subsequence_problem:2">
<semantics>
<msup>
<mn>2</mn>
<msub>
<mi>n</mi>
<mn>1</mn>
</msub>
</msup>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<cn type="integer">2</cn>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>n</ci>
<cn type="integer">1</cn>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   2^{n_{1}}
  </annotation>
</semantics>
</math>

 subsequences of the first sequence to determine whether they are also subsequences of the remaining sequences; each subsequence may be tested in time linear in the lengths of the remaining sequences, so the time for this algorithm would be</p>

<p>
<math display="block" id="Longest_common_subsequence_problem:3">
<semantics>
<mrow>
<mrow>
<mi>O</mi>
<mrow>
<mo>(</mo>
<mrow>
<msup>
<mn>2</mn>
<msub>
<mi>n</mi>
<mn>1</mn>
</msub>
</msup>
<mrow>
<munder>
<mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
<mrow>
<mi>i</mi>
<mo>&gt;</mo>
<mn>1</mn>
</mrow>
</munder>
<msub>
<mi>n</mi>
<mi>i</mi>
</msub>
</mrow>
</mrow>
<mo>)</mo>
</mrow>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<ci>O</ci>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<cn type="integer">2</cn>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>n</ci>
<cn type="integer">1</cn>
</apply>
</apply>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<sum></sum>
<apply>
<gt></gt>
<ci>i</ci>
<cn type="integer">1</cn>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>n</ci>
<ci>i</ci>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   O\left(2^{n_{1}}\sum_{i&gt;1}n_{i}\right).
  </annotation>
</semantics>
</math>
</p>

<p>For the case of two sequences of <em>n</em> and <em>m</em> elements, the running time of the dynamic programming approach is <a href="Big_O_notation" title="wikilink">O</a>(<em>n</em> × <em>m</em>). For an arbitrary number of input sequences, the dynamic programming approach gives a solution in</p>

<p>
<math display="block" id="Longest_common_subsequence_problem:4">
<semantics>
<mrow>
<mrow>
<mi>O</mi>
<mrow>
<mo>(</mo>
<mrow>
<mi>N</mi>
<mrow>
<munderover>
<mo largeop="true" movablelimits="false" symmetric="true">∏</mo>
<mrow>
<mi>i</mi>
<mo>=</mo>
<mn>1</mn>
</mrow>
<mi>N</mi>
</munderover>
<msub>
<mi>n</mi>
<mi>i</mi>
</msub>
</mrow>
</mrow>
<mo>)</mo>
</mrow>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<ci>O</ci>
<apply>
<times></times>
<ci>N</ci>
<apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<csymbol cd="latexml">product</csymbol>
<apply>
<eq></eq>
<ci>i</ci>
<cn type="integer">1</cn>
</apply>
</apply>
<ci>N</ci>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>n</ci>
<ci>i</ci>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   O\left(N\prod_{i=1}^{N}n_{i}\right).
  </annotation>
</semantics>
</math>
</p>

<p>There exist methods with lower complexity,<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> which often depend on the length of the LCS, the size of the alphabet, or both.</p>

<p>Notice that the LCS is not necessarily unique; for example the LCS of "ABC" and "ACB" is both "AB" and "AC". Indeed the LCS problem is often defined to be finding <em>all</em> common subsequences of a maximum length. This problem inherently has higher complexity, as the number of such subsequences is exponential in the worst case,<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> even for only two input strings.</p>
<h2 id="solution-for-two-sequences">Solution for two sequences</h2>

<p>The LCS problem has an <a href="optimal_substructure" title="wikilink">optimal substructure</a>: the problem can be broken down into smaller, simple "subproblems", which can be broken down into yet simpler subproblems, and so on, until, finally, the solution becomes trivial. The LCS problem also has <a href="overlapping_subproblems" title="wikilink">overlapping subproblems</a>: the solution to high-level subproblems often reuse lower level subproblems. Problems with these two properties—optimal substructure and overlapping subproblems—can be approached by a problem-solving technique called <a href="dynamic_programming" title="wikilink">dynamic programming</a>, in which subproblem solutions are memoized rather than computed over and over. The procedure requires <a class="uri" href="memoization" title="wikilink">memoization</a>—saving the solutions to one level of subproblem in a table (analogous to writing them to a <em>memo</em>, hence the name) so that the solutions are available to the next level of subproblems. This method is illustrated here.</p>
<h3 id="prefixes">Prefixes</h3>

<p>The subproblems become simpler as the sequences become shorter. Shorter sequences are conveniently described using the term <em>prefix</em>. A prefix of a sequence is the sequence with the end cut off. Let <em>S</em> be the sequence (AGCA). Then, the sequence (AG) is one of the prefixes of <em>S</em>. Prefixes are denoted with the name of the sequence, followed by a subscript to indicate how many characters the prefix contains.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> The prefix (AG) is denoted <em>S</em><sub>2</sub>, since it contains the first 2 elements of <em>S</em>. The possible prefixes of <em>S</em> are</p>
<dl>
<dd><em>S</em><sub>1</sub> = (A)
</dd>
<dd><em>S</em><sub>2</sub> = (AG)
</dd>
<dd><em>S</em><sub>3</sub> = (AGC)
</dd>
<dd><em>S</em><sub>4</sub> = (AGCA).
</dd>
</dl>

<p>The solution to the LCS problem for two arbitrary sequences, <em>X</em> and <em>Y</em>, amounts to construct some function, <em>LCS</em>(<em>X</em>, <em>Y</em>), that gives the longest subsequences common to <em>X</em> and <em>Y</em>. That function relies on the following two properties.</p>
<h3 id="first-property">First property</h3>

<p>Suppose that two sequences both end in the same element. To find their LCS, shorten each sequence by removing the last element, find the LCS of the shortened sequences, and to that LCS append the removed element.</p>
<dl>
<dd>For example, here are two sequences having the same last element: (BANANA) and (ATANA).
</dd>
<dd>Remove the same last element. Repeat the procedure until you find no common last element. The removed sequence will be (ANA).
</dd>
<dd>The sequences now under consideration: (BAN) and (AT)
</dd>
<dd>The LCS of these last two sequences is, by inspection, (A).
</dd>
<dd>Append the removed element, (ANA), giving (AANA), which, by inspection, is the LCS of the original sequences.
</dd>
</dl>

<p>In general, for any sequences <em>X</em> and <em>Y</em> of length <em>n</em> and <em>m</em>, if we denote their elements <em>x<sub>1</sub></em> to <em>x<sub>n</sub></em> and <em>y<sub>1</sub></em> to <em>y<sub>m</sub></em> and their prefixes <em>X<sub>1</sub></em> to <em>X<sub>n-1</sub></em> and <em>Y<sub>1</sub></em> to <em>Y<sub>m-1</sub></em>, then we can say this:</p>
<dl>
<dd>If: <em>x<sub>n</sub></em>=<em>y<sub>m</sub></em>
</dd>
<dd>then: <em>LCS</em>(<em>X<sub>n</sub></em>, <em>Y<sub>m</sub></em>) = <em>LCS</em>( ''X<sub>n''-1</sub>, ''Y<sub>m''-1</sub>) ^ <em>x<sub>n</sub></em>
</dd>
</dl>

<p>where the caret ^ indicates that the following element, <em>x<sub>n</sub></em>, is appended to the sequence. Note that the LCS for <em>X<sub>n</sub></em> and <em>Y<sub>m</sub></em> involves determining the LCS of the shorter sequences, ''X<sub>n''-1</sub> and ''Y<sub>m''-1</sub>.</p>
<h3 id="second-property">Second property</h3>

<p>Suppose that the two sequences X and Y do not end in the same symbol. Then the LCS of X and Y is the longer of the two sequences LCS(X<sub>n</sub>,Y<sub>m-1</sub>) and LCS(X<sub>n-1</sub>,Y<sub>m</sub>).</p>

<p>To understand this property, consider the two following sequences :</p>

<p>sequence X: ABCDEFG (n elements)<br/>
sequence Y: BCDGK (m elements)</p>

<p>The LCS of these two sequences either ends with a G (the last element of sequence X) or does not.</p>

<p><strong>Case 1: the LCS ends with a G</strong><br/>
Then it cannot end with a K. Thus it does not hurt to remove the K from sequence Y: if K were in the LCS, it would be its last character; as a consequence K is not in the LCS. We can then write: LCS(X<sub>n</sub>,Y<sub>m</sub>) = LCS(X<sub>n</sub>, Y<sub>m-1</sub>).</p>

<p><strong>Case 2: the LCS does not end with a G</strong><br/>
Then it does not hurt to remove the G from the sequence X (for the same reason as above). And then we can write: LCS(X<sub>n</sub>,Y<sub>m</sub>) = LCS(X<sub>n-1</sub>, Y<sub>m</sub>).</p>

<p>In any case, the LCS we are looking for is one of LCS(X<sub>n</sub>, Y<sub>m-1</sub>) or LCS(X<sub>n-1</sub>, Y<sub>m</sub>). Those two last LCS are both common subsequences to X and Y. LCS(X,Y) is the longest. Thus its value is the longest sequence of LCS(X<sub>n</sub>, Y<sub>m-1</sub>) and LCS(X<sub>n-1</sub>, Y<sub>m</sub>).</p>
<h3 id="lcs-function-defined"><em>LCS</em> function defined</h3>

<p>Let two sequences be defined as follows: <em>X</em> = (<em>x</em><sub>1</sub>, <em>x</em><sub>2</sub>...<em>x</em><sub>m</sub>) and <em>Y</em> = (<em>y</em><sub>1</sub>, <em>y</em><sub>2</sub>...<em>y</em><sub>n</sub>). The prefixes of <em>X</em> are <em>X</em><sub>1, 2,...m</sub>; the prefixes of <em>Y</em> are <em>Y</em><sub>1, 2,...n</sub>. Let <em>LCS</em>(<em>X</em><sub><em>i</em></sub>, <em>Y</em><sub><em>j</em></sub>) represent the set of longest common subsequence of prefixes <em>X<sub>i</sub></em> and <em>Y<sub>j</sub></em>. This set of sequences is given by the following.</p>

<p>
<math display="block" id="Longest_common_subsequence_problem:5">
<semantics>
<mrow>
<mrow>
<mi>L</mi>
<mi>C</mi>
<mi>S</mi>
<mrow>
<mo>(</mo>
<msub>
<mi>X</mi>
<mi>i</mi>
</msub>
<mo>,</mo>
<msub>
<mi>Y</mi>
<mi>j</mi>
</msub>
<mo>)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<mo>{</mo>
<mtable displaystyle="true">
<mtr>
<mtd columnalign="left">
<mi></mi>
</mtd>
<mtd columnalign="left">
<mrow>
<mrow>
<mpadded width="+5pt">
<mtext>if</mtext>
</mpadded>
<mi>i</mi>
</mrow>
<mo>=</mo>
<mrow>
<mn>0</mn>
<mtext>or</mtext>
<mi>j</mi>
</mrow>
<mo>=</mo>
<mn>0</mn>
</mrow>
</mtd>
</mtr>
<mtr>
<mtd columnalign="left">
<mrow>
<mrow>
<mrow></mrow>
<mi>L</mi>
<mi>C</mi>
<mi>S</mi>
<mrow>
<mo>(</mo>
<msub>
<mi>X</mi>
<mrow>
<mi>i</mi>
<mo>-</mo>
<mn>1</mn>
</mrow>
</msub>
<mo>,</mo>
<msub>
<mi>Y</mi>
<mrow>
<mi>j</mi>
<mo>-</mo>
<mn>1</mn>
</mrow>
</msub>
<mo>)</mo>
</mrow>
</mrow>
<mo>⌢</mo>
<msub>
<mi>x</mi>
<mi>i</mi>
</msub>
</mrow>
</mtd>
<mtd columnalign="left">
<mrow>
<mrow>
<mtext>if</mtext>
<msub>
<mi>x</mi>
<mi>i</mi>
</msub>
</mrow>
<mo>=</mo>
<msub>
<mi>y</mi>
<mi>j</mi>
</msub>
</mrow>
</mtd>
</mtr>
<mtr>
<mtd columnalign="left">
<mrow>
<mtext>longest</mtext>
<mrow>
<mo>(</mo>
<mrow>
<mi>L</mi>
<mi>C</mi>
<mi>S</mi>
<mrow>
<mo>(</mo>
<msub>
<mi>X</mi>
<mi>i</mi>
</msub>
<mo>,</mo>
<msub>
<mi>Y</mi>
<mrow>
<mi>j</mi>
<mo>-</mo>
<mn>1</mn>
</mrow>
</msub>
<mo>)</mo>
</mrow>
</mrow>
<mo>,</mo>
<mrow>
<mi>L</mi>
<mi>C</mi>
<mi>S</mi>
<mrow>
<mo>(</mo>
<msub>
<mi>X</mi>
<mrow>
<mi>i</mi>
<mo>-</mo>
<mn>1</mn>
</mrow>
</msub>
<mo>,</mo>
<msub>
<mi>Y</mi>
<mi>j</mi>
</msub>
<mo>)</mo>
</mrow>
</mrow>
<mo>)</mo>
</mrow>
</mrow>
</mtd>
<mtd columnalign="left">
<mrow>
<mrow>
<mtext>if</mtext>
<msub>
<mi>x</mi>
<mi>i</mi>
</msub>
</mrow>
<mo>≠</mo>
<msub>
<mi>y</mi>
<mi>j</mi>
</msub>
</mrow>
</mtd>
</mtr>
</mtable>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<times></times>
<ci>L</ci>
<ci>C</ci>
<ci>S</ci>
<interval closure="open">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>X</ci>
<ci>i</ci>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>Y</ci>
<ci>j</ci>
</apply>
</interval>
</apply>
<apply>
<csymbol cd="latexml">cases</csymbol>
<csymbol cd="latexml">absent</csymbol>
<apply>
<and></and>
<apply>
<eq></eq>
<apply>
<times></times>
<mtext>if</mtext>
<ci>i</ci>
</apply>
<apply>
<times></times>
<cn type="integer">0</cn>
<mtext>or</mtext>
<ci>j</ci>
</apply>
</apply>
<apply>
<eq></eq>
<share href="#.cmml">
</share>
<cn type="integer">0</cn>
</apply>
</apply>
<apply>
<ci>normal-⌢</ci>
<apply>
<times></times>
<mtext></mtext>
<ci>L</ci>
<ci>C</ci>
<ci>S</ci>
<interval closure="open">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>X</ci>
<apply>
<minus></minus>
<ci>i</ci>
<cn type="integer">1</cn>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>Y</ci>
<apply>
<minus></minus>
<ci>j</ci>
<cn type="integer">1</cn>
</apply>
</apply>
</interval>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<ci>i</ci>
</apply>
</apply>
<apply>
<eq></eq>
<apply>
<times></times>
<mtext>if</mtext>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<ci>i</ci>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>y</ci>
<ci>j</ci>
</apply>
</apply>
<apply>
<times></times>
<mtext>longest</mtext>
<interval closure="open">
<apply>
<times></times>
<ci>L</ci>
<ci>C</ci>
<ci>S</ci>
<interval closure="open">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>X</ci>
<ci>i</ci>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>Y</ci>
<apply>
<minus></minus>
<ci>j</ci>
<cn type="integer">1</cn>
</apply>
</apply>
</interval>
</apply>
<apply>
<times></times>
<ci>L</ci>
<ci>C</ci>
<ci>S</ci>
<interval closure="open">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>X</ci>
<apply>
<minus></minus>
<ci>i</ci>
<cn type="integer">1</cn>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>Y</ci>
<ci>j</ci>
</apply>
</interval>
</apply>
</interval>
</apply>
<apply>
<neq></neq>
<apply>
<times></times>
<mtext>if</mtext>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<ci>i</ci>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>y</ci>
<ci>j</ci>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   LCS\left(X_{i},Y_{j}\right)=\begin{cases}&amp;\mbox{ if }\ i=0\mbox{ or }j=0\\
\textrm{ }LCS\left(X_{i-1},Y_{j-1}\right)\frown x_{i}&amp;\mbox{ if }x_{i}=y_{j}\\
\mbox{longest}\left(LCS\left(X_{i},Y_{j-1}\right),LCS\left(X_{i-1},Y_{j}\right%
)\right)&amp;\mbox{ if }x_{i}\neq y_{j}\\
\end{cases}
  </annotation>
</semantics>
</math>
</p>

<p>To find the longest subsequences common to <em>X<sub>i</sub></em> and <em>Y<sub>j</sub></em>, compare the elements <em>x<sub>i</sub></em> and <em>y<sub>j</sub></em>. If they are equal, then the sequence <em>LCS</em>(<em>X</em><sub><em>i</em>-1</sub>, <em>Y</em><sub><em>j</em>-1</sub>) is extended by that element, <em>x<sub>i</sub></em>. If they are not equal, then the longer of the two sequences, <em>LCS</em>(<em>X</em><sub><em>i</em></sub>, <em>Y</em><sub><em>j</em>-1</sub>), and <em>LCS</em>(<em>X</em><sub><em>i</em>-1</sub>, <em>Y</em><sub><em>j</em></sub>), is retained. (If they are both the same length, but not identical, then both are retained.) Notice that the subscripts are reduced by 1 in these formulas. That can result in a subscript of 0. Since the sequence elements are defined to start at 1, it was necessary to add the requirement that the LCS is empty when a subscript is zero.</p>
<h3 id="worked-example">Worked example</h3>

<p>The longest subsequence common to <em>C</em> = (AGCAT), and <em>R</em> = (GAC) will be found. Because the <em>LCS</em> function uses a "zeroth" element, it is convenient to define zero prefixes that are empty for these sequences: <em>C</em><sub>0</sub> = Ø; and <em>R</em><sub>0</sub> = Ø. All the prefixes are placed in a table with <em>C</em> in the first row (making it a <u>c</u>olumn header) and <em>R</em> in the first column (making it a <u>r</u>ow header).</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">

<p>LCS Strings</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">

<p>0</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">

<p>G</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">

<p>A</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">

<p>C</p></td>
</tr>
<tr class="odd">
</tr>
</tbody>
</table>

<p>This table is used to store the LCS sequence for each step of the calculation. The second column and second row have been filled in with Ø, because when an empty sequence is compared with a non-empty sequence, the longest common subsequence is always an empty sequence.</p>

<p><em>LCS</em>(<em>R</em><sub>1</sub>, <em>C</em><sub>1</sub>) is determined by comparing the first elements in each sequence. G and A are not the same, so this LCS gets (using the "second property") the longest of the two sequences, <em>LCS</em>(<em>R</em><sub>1</sub>, <em>C</em><sub>0</sub>) and <em>LCS</em>(<em>R</em><sub>0</sub>, <em>C</em><sub>1</sub>). According to the table, both of these are empty, so <em>LCS</em>(<em>R</em><sub>1</sub>, <em>C</em><sub>1</sub>) is also empty, as shown in the table below. The arrows indicate that the sequence comes from both the cell above, <em>LCS</em>(<em>R</em><sub>0</sub>, <em>C</em><sub>1</sub>) and the cell on the left, <em>LCS</em>(<em>R</em><sub>1</sub>, <em>C</em><sub>0</sub>).</p>

<p><em>LCS</em>(<em>R</em><sub>1</sub>, <em>C</em><sub>2</sub>) is determined by comparing G and G. They match, so G is appended to the upper left sequence, <em>LCS</em>(<em>R</em><sub>0</sub>, <em>C</em><sub>1</sub>), which is (Ø), giving (ØG), which is (G).</p>

<p>For <em>LCS</em>(<em>R</em><sub>1</sub>, <em>C</em><sub>3</sub>), G and C do not match. The sequence above is empty; the one to the left contains one element, G. Selecting the longest of these, <em>LCS</em>(<em>R</em><sub>1</sub>, <em>C</em><sub>3</sub>) is (G). The arrow points to the left, since that is the longest of the two sequences.</p>

<p><em>LCS</em>(<em>R</em><sub>1</sub>, <em>C</em><sub>4</sub>), likewise, is (G).</p>

<p><em>LCS</em>(<em>R</em><sub>1</sub>, <em>C</em><sub>5</sub>), likewise, is (G).</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">

<p>"G" Row Completed</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">

<p>Ø</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">

<p>G</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">

<p>A</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">

<p>C</p></td>
</tr>
<tr class="odd">
</tr>
</tbody>
</table>

<p>For <em>LCS</em>(<em>R</em><sub>2</sub>, <em>C</em><sub>1</sub>), A is compared with A. The two elements match, so A is appended to Ø, giving (A).</p>

<p>For <em>LCS</em>(<em>R</em><sub>2</sub>, <em>C</em><sub>2</sub>), A and G do not match, so the longest of <em>LCS</em>(<em>R</em><sub>1</sub>, <em>C</em><sub>2</sub>), which is (G), and <em>LCS</em>(<em>R</em><sub>2</sub>, <em>C</em><sub>1</sub>), which is (A), is used. In this case, they each contain one element, so this LCS is given two subsequences: (A) and (G).</p>

<p>For <em>LCS</em>(<em>R</em><sub>2</sub>, <em>C</em><sub>3</sub>), A does not match C. <em>LCS</em>(<em>R</em><sub>2</sub>, <em>C</em><sub>2</sub>) contains sequences (A) and (G); LCS(<em>R</em><sub>1</sub>, <em>C</em><sub>3</sub>) is (G), which is already contained in <em>LCS</em>(<em>R</em><sub>2</sub>, <em>C</em><sub>2</sub>). The result is that <em>LCS</em>(<em>R</em><sub>2</sub>, <em>C</em><sub>3</sub>) also contains the two subsequences, (A) and (G).</p>

<p>For <em>LCS</em>(<em>R</em><sub>2</sub>, <em>C</em><sub>4</sub>), A matches A, which is appended to the upper left cell, giving (GA).</p>

<p>For <em>LCS</em>(<em>R</em><sub>2</sub>, <em>C</em><sub>5</sub>), A does not match T. Comparing the two sequences, (GA) and (G), the longest is (GA), so <em>LCS</em>(<em>R</em><sub>2</sub>, <em>C</em><sub>5</sub>) is (GA).</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">

<p>"G" &amp; "A" Rows Completed</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">

<p>Ø</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">

<p>G</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">

<p>A</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">

<p>C</p></td>
</tr>
<tr class="odd">
</tr>
</tbody>
</table>

<p>For <em>LCS</em>(<em>R</em><sub>3</sub>, <em>C</em><sub>1</sub>), C and A do not match, so <em>LCS</em>(<em>R</em><sub>3</sub>, <em>C</em><sub>1</sub>) gets the longest of the two sequences, (A).</p>

<p>For <em>LCS</em>(<em>R</em><sub>3</sub>, <em>C</em><sub>2</sub>), C and G do not match. Both <em>LCS</em>(<em>R</em><sub>3</sub>, <em>C</em><sub>1</sub>) and <em>LCS</em>(<em>R</em><sub>2</sub>, <em>C</em><sub>2</sub>) have one element. The result is that <em>LCS</em>(<em>R</em><sub>3</sub>, <em>C</em><sub>2</sub>) contains the two subsequences, (A) and (G).</p>

<p>For <em>LCS</em>(<em>R</em><sub>3</sub>, <em>C</em><sub>3</sub>), C and C match, so C is appended to <em>LCS</em>(<em>R</em><sub>2</sub>, <em>C</em><sub>2</sub>), which contains the two subsequences, (A) and (G), giving (AC) and (GC).</p>

<p>For <em>LCS</em>(<em>R</em><sub>3</sub>, <em>C</em><sub>4</sub>), C and A do not match. Combining <em>LCS</em>(<em>R</em><sub>3</sub>, <em>C</em><sub>3</sub>), which contains (AC) and (GC), and <em>LCS</em>(<em>R</em><sub>2</sub>, <em>C</em><sub>4</sub>), which contains (GA), gives a total of three sequences: (AC), (GC), and (GA).</p>

<p>Finally, for <em>LCS</em>(<em>R</em><sub>3</sub>, <em>C</em><sub>5</sub>), C and T do not match. The result is that <em>LCS</em>(<em>R</em><sub>3</sub>, <em>C</em><sub>5</sub>) also contains the three sequences, (AC), (GC), and (GA).</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">

<p>Completed LCS Table</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">

<p>Ø</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">

<p>G</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">

<p>A</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">

<p>C</p></td>
</tr>
<tr class="odd">
</tr>
</tbody>
</table>

<p>The final result is that the last cell contains all the longest subsequences common to (AGCAT) and (GAC); these are (AC), (GC), and (GA). The table also shows the longest common subsequences for every possible pair of prefixes. For example, for (AGC) and (GA), the longest common subsequence are (A) and (G).</p>
<h3 id="traceback-approach">Traceback approach</h3>

<p>Calculating the LCS of a row of the LCS table requires only the solutions to the current row and the previous row. Still, for long sequences, these sequences can get numerous and long, requiring a lot of storage space. Storage space can be saved by saving not the actual subsequences, but the length of the subsequence and the direction of the arrows, as in the table below.</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">

<p>Storing length, rather than sequences</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">

<p>Ø</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">

<p>G</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">

<p>A</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">

<p>C</p></td>
</tr>
<tr class="odd">
</tr>
</tbody>
</table>

<p>The actual subsequences are deduced in a "traceback" procedure that follows the arrows backwards, starting from the last cell in the table. When the length decreases, the sequences must have had a common element. Several paths are possible when two arrows are shown in a cell. Below is the table for such an analysis, with numbers colored in cells where the length is about to decrease. The bold numbers trace out the sequence, (GA).<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">

<p>Traceback example</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">

<p>Ø</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">

<p>G</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">

<p>A</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">

<p>C</p></td>
</tr>
<tr class="odd">
</tr>
</tbody>
</table>
<h2 id="relation-to-other-problems">Relation to other problems</h2>

<p>For two strings 

<math display="inline" id="Longest_common_subsequence_problem:6">
<semantics>
<msub>
<mi>X</mi>
<mrow>
<mn>1</mn>
<mi mathvariant="normal">…</mi>
<mi>m</mi>
</mrow>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>X</ci>
<apply>
<times></times>
<cn type="integer">1</cn>
<ci>normal-…</ci>
<ci>m</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   X_{1\dots m}
  </annotation>
</semantics>
</math>

 and 

<math display="inline" id="Longest_common_subsequence_problem:7">
<semantics>
<msub>
<mi>Y</mi>
<mrow>
<mn>1</mn>
<mi mathvariant="normal">…</mi>
<mi>n</mi>
</mrow>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>Y</ci>
<apply>
<times></times>
<cn type="integer">1</cn>
<ci>normal-…</ci>
<ci>n</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   Y_{1\dots n}
  </annotation>
</semantics>
</math>

, the length of the <a href="shortest_common_supersequence_problem" title="wikilink">shortest common supersequence</a> is related to the length of the LCS by<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>

<p>
<math display="block" id="Longest_common_subsequence_problem:8">
<semantics>
<mrow>
<mrow>
<mrow>
<mo>|</mo>
<mrow>
<mi>S</mi>
<mi>C</mi>
<mi>S</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>X</mi>
<mo>,</mo>
<mi>Y</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>|</mo>
</mrow>
<mo>=</mo>
<mrow>
<mrow>
<mi>n</mi>
<mo>+</mo>
<mi>m</mi>
</mrow>
<mo>-</mo>
<mrow>
<mo>|</mo>
<mrow>
<mi>L</mi>
<mi>C</mi>
<mi>S</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>X</mi>
<mo>,</mo>
<mi>Y</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>|</mo>
</mrow>
</mrow>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<abs></abs>
<apply>
<times></times>
<ci>S</ci>
<ci>C</ci>
<ci>S</ci>
<interval closure="open">
<ci>X</ci>
<ci>Y</ci>
</interval>
</apply>
</apply>
<apply>
<minus></minus>
<apply>
<plus></plus>
<ci>n</ci>
<ci>m</ci>
</apply>
<apply>
<abs></abs>
<apply>
<times></times>
<ci>L</ci>
<ci>C</ci>
<ci>S</ci>
<interval closure="open">
<ci>X</ci>
<ci>Y</ci>
</interval>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \left|SCS(X,Y)\right|=n+m-\left|LCS(X,Y)\right|.
  </annotation>
</semantics>
</math>
</p>

<p>The <a href="Levenshtein_distance" title="wikilink">edit distance</a> when only insertion and deletion is allowed (no substitution), or when the cost of the substitution is the double of the cost of an insertion or deletion, is:</p>

<p>
<math display="block" id="Longest_common_subsequence_problem:9">
<semantics>
<mrow>
<mrow>
<mrow>
<msup>
<mi>d</mi>
<mo>′</mo>
</msup>
<mrow>
<mo stretchy="false">(</mo>
<mi>X</mi>
<mo>,</mo>
<mi>Y</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<mrow>
<mi>n</mi>
<mo>+</mo>
<mi>m</mi>
</mrow>
<mo>-</mo>
<mrow>
<mn>2</mn>
<mo>⋅</mo>
<mrow>
<mo>|</mo>
<mrow>
<mi>L</mi>
<mi>C</mi>
<mi>S</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>X</mi>
<mo>,</mo>
<mi>Y</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>|</mo>
</mrow>
</mrow>
</mrow>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>d</ci>
<ci>normal-′</ci>
</apply>
<interval closure="open">
<ci>X</ci>
<ci>Y</ci>
</interval>
</apply>
<apply>
<minus></minus>
<apply>
<plus></plus>
<ci>n</ci>
<ci>m</ci>
</apply>
<apply>
<ci>normal-⋅</ci>
<cn type="integer">2</cn>
<apply>
<abs></abs>
<apply>
<times></times>
<ci>L</ci>
<ci>C</ci>
<ci>S</ci>
<interval closure="open">
<ci>X</ci>
<ci>Y</ci>
</interval>
</apply>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   d^{\prime}(X,Y)=n+m-2\cdot\left|LCS(X,Y)\right|.
  </annotation>
</semantics>
</math>
</p>
<h2 id="code-for-the-dynamic-programming-solution">Code for the dynamic programming solution</h2>
<h3 id="computing-the-length-of-the-lcs">Computing the length of the LCS</h3>

<p>The function below takes as input sequences <code>X[1..m]</code> and <code>Y[1..n]</code> computes the LCS between <code>X[1..i]</code> and <code>Y[1..j]</code> for all <code>1 ≤ i ≤ m</code> and <code>1 ≤ j ≤ n</code>, and stores it in <code>C[i,j]</code>. <code>C[m,n]</code> will contain the length of the LCS of <code>X</code> and <code>Y</code>.</p>

<p><strong><code>function</code></strong><code> LCSLength(X[1..m], Y[1..n])</code><br/>
<code>    C = array(0..m, 0..n)</code><br/>
<code>    </code><strong><code>for</code></strong><code> i := 0..m</code><br/>
<code>       C[i,0] = 0</code><br/>
<code>    </code><strong><code>for</code></strong><code> j := 0..n</code><br/>
<code>       C[0,j] = 0</code><br/>
<code>    </code><strong><code>for</code></strong><code> i := 1..m</code><br/>
<code>        </code><strong><code>for</code></strong><code> j := 1..n</code><br/>
<code>            </code><strong><code>if</code></strong><code> X[i] = Y[j]</code><br/>
<code>                C[i,j] := C[i-1,j-1] + 1</code><br/>
<code>            </code><strong><code>else</code></strong><br/>
<code>                C[i,j] := max(C[i,j-1], C[i-1,j])</code><br/>
<code>    </code><strong><code>return</code></strong><code> C[m,n]</code></p>

<p>Alternatively, <a class="uri" href="memoization" title="wikilink">memoization</a> could be used.</p>
<h3 id="reading-out-an-lcs">Reading out an LCS</h3>

<p>The following function <a href="backtracking" title="wikilink">backtracks</a> the choices taken when computing the <code>C</code> table. If the last characters in the prefixes are equal, they must be in an LCS. If not, check what gave the largest LCS of keeping 

<math display="inline" id="Longest_common_subsequence_problem:10">
<semantics>
<msub>
<mi>x</mi>
<mi>i</mi>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<ci>i</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   x_{i}
  </annotation>
</semantics>
</math>

 and 

<math display="inline" id="Longest_common_subsequence_problem:11">
<semantics>
<msub>
<mi>y</mi>
<mi>j</mi>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>y</ci>
<ci>j</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   y_{j}
  </annotation>
</semantics>
</math>

, and make the same choice. Just choose one if they were equally long. Call the function with <code>i=m</code> and <code>j=n</code>.</p>

<p><strong><code>function</code></strong><code> backtrack(C[0..m,0..n], X[1..m], Y[1..n], i, j)</code><br/>
<code>    </code><strong><code>if</code></strong><code> i = 0 </code><strong><code>or</code></strong><code> j = 0</code><br/>
<code>        </code><strong><code>return</code></strong><code> ""</code><br/>
<code>    '''else if ''' X[i] = Y[j]</code><br/>
<code>        </code><strong><code>return</code></strong><code> backtrack(C, X, Y, i-1, j-1) + X[i]</code><br/>
<code>    </code><strong><code>else</code></strong><br/>
<code>        </code><strong><code>if</code></strong><code> C[i,j-1] &gt; C[i-1,j]</code><br/>
<code>            </code><strong><code>return</code></strong><code> backtrack(C, X, Y, i, j-1)</code><br/>
<code>        </code><strong><code>else</code></strong><br/>
<code>            </code><strong><code>return</code></strong><code> backtrack(C, X, Y, i-1, j)</code></p>
<h3 id="reading-out-all-lcss">Reading out all LCSs</h3>

<p>If choosing 

<math display="inline" id="Longest_common_subsequence_problem:12">
<semantics>
<msub>
<mi>x</mi>
<mi>i</mi>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<ci>i</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   x_{i}
  </annotation>
</semantics>
</math>

 and 

<math display="inline" id="Longest_common_subsequence_problem:13">
<semantics>
<msub>
<mi>y</mi>
<mi>j</mi>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>y</ci>
<ci>j</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   y_{j}
  </annotation>
</semantics>
</math>

 would give an equally long result, read out both resulting subsequences. This is returned as a set by this function. Notice that this function is not polynomial, as it might branch in almost every step if the strings are similar.</p>

<p><strong><code>function</code></strong><code> backtrackAll(C[0..m,0..n], X[1..m], Y[1..n], i, j)</code><br/>
<code>    </code><strong><code>if</code></strong><code> i = 0 </code><strong><code>or</code></strong><code> j = 0</code><br/>
<code>        </code><strong><code>return</code></strong><code> {""}</code><br/>
<code>    </code><strong><code>else</code> <code>if</code></strong><code> X[i] = Y[j]</code><br/>
<code>        </code><strong><code>return</code></strong><code> {Z + X[i] </code><strong><code>for</code> <code>all</code></strong><code> Z </code><strong><code>in</code></strong><code> backtrackAll(C, X, Y, i-1, j-1)}</code><br/>
<code>    </code><strong><code>else</code></strong><br/>
<code>        R := {}</code><br/>
<code>        </code><strong><code>if</code></strong><code> C[i,j-1] ≥ C[i-1,j]</code><br/>
<code>            R := R ∪ backtrackAll(C, X, Y, i, j-1)</code><br/>
<code>        </code><strong><code>if</code></strong><code> C[i-1,j] ≥ C[i,j-1]</code><br/>
<code>            R := R ∪ backtrackAll(C, X, Y, i-1, j)</code><br/>
<code>        </code><strong><code>return</code></strong><code> R</code></p>
<h3 id="print-the-diff">Print the diff</h3>

<p>This function will backtrack through the C matrix, and print the <a class="uri" href="diff" title="wikilink">diff</a> between the two sequences. Notice that you will get a different answer if you exchange <code>≥</code> and <code>, with <code>&gt;</code> and <code>≤</code> below.</code></p>

<p><strong><code>function</code></strong><code> printDiff(C[0..m,0..n], X[1..m], Y[1..n], i, j)</code><br/>
<code>    </code><strong><code>if</code></strong><code> i &gt; 0 </code><strong><code>and</code></strong><code> j &gt; 0 </code><strong><code>and</code></strong><code> X[i] = Y[j]</code><br/>
<code>        printDiff(C, X, Y, i-1, j-1)</code><br/>
<code>        print "  " + X[i]</code><br/>
<code>    </code><strong><code>else</code> <code>if</code></strong><code> j &gt; 0 </code><strong><code>and</code></strong><code> (i = 0 </code><strong><code>or</code></strong><code> C[i,j-1] ≥ C[i-1,j])</code><br/>
<code>        printDiff(C, X, Y, i, j-1)</code><br/>
<code>        print "+ " + Y[j]</code><br/>
<code>    </code><strong><code>else</code> <code>if</code></strong><code> i &gt; 0 </code><strong><code>and</code></strong><code> (j = 0 </code><strong><code>or</code></strong><code> C[i,j-1] </code><code>X</code><code> be “</code><code>XMJYAUZ</code><code>” and </code>
<math display="inline" id="Longest_common_subsequence_problem:14">
<semantics>
<mi>Y</mi>
<annotation-xml encoding="MathML-Content">
<ci>Y</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   Y
  </annotation>
</semantics>
</math>
<code> be “</code><code>MZJAWXU</code><code>”. The longest common subsequence between </code>
<math display="inline" id="Longest_common_subsequence_problem:15">
<semantics>
<mi>X</mi>
<annotation-xml encoding="MathML-Content">
<ci>X</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   X
  </annotation>
</semantics>
</math>
<code> and </code>
<math display="inline" id="Longest_common_subsequence_problem:16">
<semantics>
<mi>Y</mi>
<annotation-xml encoding="MathML-Content">
<ci>Y</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   Y
  </annotation>
</semantics>
</math>
<code> is “</code><code>MJAU</code><code>”. The table </code><code>C</code><code> shown below, which is generated by the function </code><code>LCSLength</code><code>, shows the lengths of the longest common subsequences between prefixes of </code>
<math display="inline" id="Longest_common_subsequence_problem:17">
<semantics>
<mi>X</mi>
<annotation-xml encoding="MathML-Content">
<ci>X</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   X
  </annotation>
</semantics>
</math>
<code> and </code>
<math display="inline" id="Longest_common_subsequence_problem:18">
<semantics>
<mi>Y</mi>
<annotation-xml encoding="MathML-Content">
<ci>Y</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   Y
  </annotation>
</semantics>
</math>
<code>. The </code>
<math display="inline" id="Longest_common_subsequence_problem:19">
<semantics>
<mi>i</mi>
<annotation-xml encoding="MathML-Content">
<ci>i</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   i
  </annotation>
</semantics>
</math>
<code>th row and </code>
<math display="inline" id="Longest_common_subsequence_problem:20">
<semantics>
<mi>j</mi>
<annotation-xml encoding="MathML-Content">
<ci>j</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   j
  </annotation>
</semantics>
</math>
<code>th column shows the length of the LCS between </code>
<math display="inline" id="Longest_common_subsequence_problem:21">
<semantics>
<msub>
<mi>X</mi>
<mrow>
<mn>1..</mn>
<mi>i</mi>
</mrow>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>X</ci>
<apply>
<times></times>
<cn type="float">1..</cn>
<ci>i</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   X_{1..i}
  </annotation>
</semantics>
</math>
<code> and </code>
<math display="inline" id="Longest_common_subsequence_problem:22">
<semantics>
<msub>
<mi>Y</mi>
<mrow>
<mn>1..</mn>
<mi>j</mi>
</mrow>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>Y</ci>
<apply>
<times></times>
<cn type="float">1..</cn>
<ci>j</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   Y_{1..j}
  </annotation>
</semantics>
</math>
<code>.</code></p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;"></th>
<th style="text-align: left;">

<p>0</p></th>
<th style="text-align: left;">

<p>1</p></th>
<th style="text-align: left;">

<p>2</p></th>
<th style="text-align: left;">

<p>3</p></th>
<th style="text-align: left;">

<p>4</p></th>
<th style="text-align: left;">

<p>5</p></th>
<th style="text-align: left;">

<p>6</p></th>
<th style="text-align: left;">

<p>7</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">

<p>Ø</p></td>
<td style="text-align: left;">

<p>M</p></td>
<td style="text-align: left;">

<p>Z</p></td>
<td style="text-align: left;">

<p>J</p></td>
<td style="text-align: left;">

<p>A</p></td>
<td style="text-align: left;">

<p>W</p></td>
<td style="text-align: left;">

<p>X</p></td>
<td style="text-align: left;">

<p>U</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">

<p>0</p></td>
<td style="text-align: left;">

<p>Ø</p></td>
<td style="text-align: left;">

<p><strong>0</strong></p></td>
<td style="text-align: left;">

<p>0</p></td>
<td style="text-align: left;">

<p>0</p></td>
<td style="text-align: left;">

<p>0</p></td>
<td style="text-align: left;">

<p>0</p></td>
<td style="text-align: left;">

<p>0</p></td>
<td style="text-align: left;">

<p>0</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">

<p>1</p></td>
<td style="text-align: left;">

<p>X</p></td>
<td style="text-align: left;">

<p>0</p></td>
<td style="text-align: left;">

<p>0</p></td>
<td style="text-align: left;">

<p>0</p></td>
<td style="text-align: left;">

<p>0</p></td>
<td style="text-align: left;">

<p>0</p></td>
<td style="text-align: left;">

<p>0</p></td>
<td style="text-align: left;">

<p>1</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">

<p>2</p></td>
<td style="text-align: left;">

<p>M</p></td>
<td style="text-align: left;">

<p>0</p></td>
<td style="text-align: left;">

<p><strong>1</strong></p></td>
<td style="text-align: left;">

<p>1</p></td>
<td style="text-align: left;">

<p>1</p></td>
<td style="text-align: left;">

<p>1</p></td>
<td style="text-align: left;">

<p>1</p></td>
<td style="text-align: left;">

<p>1</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">

<p>3</p></td>
<td style="text-align: left;">

<p>J</p></td>
<td style="text-align: left;">

<p>0</p></td>
<td style="text-align: left;">

<p>1</p></td>
<td style="text-align: left;">

<p>1</p></td>
<td style="text-align: left;">

<p><strong>2</strong></p></td>
<td style="text-align: left;">

<p>2</p></td>
<td style="text-align: left;">

<p>2</p></td>
<td style="text-align: left;">

<p>2</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">

<p>4</p></td>
<td style="text-align: left;">

<p>Y</p></td>
<td style="text-align: left;">

<p>0</p></td>
<td style="text-align: left;">

<p>1</p></td>
<td style="text-align: left;">

<p>1</p></td>
<td style="text-align: left;">

<p>2</p></td>
<td style="text-align: left;">

<p>2</p></td>
<td style="text-align: left;">

<p>2</p></td>
<td style="text-align: left;">

<p>2</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">

<p>5</p></td>
<td style="text-align: left;">

<p>A</p></td>
<td style="text-align: left;">

<p>0</p></td>
<td style="text-align: left;">

<p>1</p></td>
<td style="text-align: left;">

<p>1</p></td>
<td style="text-align: left;">

<p>2</p></td>
<td style="text-align: left;">

<p><strong>3</strong></p></td>
<td style="text-align: left;">

<p>3</p></td>
<td style="text-align: left;">

<p>3</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">

<p>6</p></td>
<td style="text-align: left;">

<p>U</p></td>
<td style="text-align: left;">

<p>0</p></td>
<td style="text-align: left;">

<p>1</p></td>
<td style="text-align: left;">

<p>1</p></td>
<td style="text-align: left;">

<p>2</p></td>
<td style="text-align: left;">

<p>3</p></td>
<td style="text-align: left;">

<p>3</p></td>
<td style="text-align: left;">

<p>3</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">

<p>7</p></td>
<td style="text-align: left;">

<p>Z</p></td>
<td style="text-align: left;">

<p>0</p></td>
<td style="text-align: left;">

<p>1</p></td>
<td style="text-align: left;">

<p>2</p></td>
<td style="text-align: left;">

<p>2</p></td>
<td style="text-align: left;">

<p>3</p></td>
<td style="text-align: left;">

<p>3</p></td>
<td style="text-align: left;">

<p>3</p></td>
</tr>
</tbody>
</table>

<p>The <span style="background: yellow">highlighted</span> numbers show the path the function <code>backtrack</code> would follow from the bottom right to the top left corner, when reading out an LCS. If the current symbols in 

<math display="inline" id="Longest_common_subsequence_problem:23">
<semantics>
<mi>X</mi>
<annotation-xml encoding="MathML-Content">
<ci>X</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   X
  </annotation>
</semantics>
</math>

 and 

<math display="inline" id="Longest_common_subsequence_problem:24">
<semantics>
<mi>Y</mi>
<annotation-xml encoding="MathML-Content">
<ci>Y</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   Y
  </annotation>
</semantics>
</math>

 are equal, they are part of the LCS, and we go both up and left (shown in <strong>bold</strong>). If not, we go up or left, depending on which cell has a higher number. This corresponds to either taking the LCS between 

<math display="inline" id="Longest_common_subsequence_problem:25">
<semantics>
<msub>
<mi>X</mi>
<mrow>
<mrow>
<mn>1..</mn>
<mi>i</mi>
</mrow>
<mo>-</mo>
<mn>1</mn>
</mrow>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>X</ci>
<apply>
<minus></minus>
<apply>
<times></times>
<cn type="float">1..</cn>
<ci>i</ci>
</apply>
<cn type="integer">1</cn>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   X_{1..i-1}
  </annotation>
</semantics>
</math>

 and 

<math display="inline" id="Longest_common_subsequence_problem:26">
<semantics>
<msub>
<mi>Y</mi>
<mrow>
<mn>1..</mn>
<mi>j</mi>
</mrow>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>Y</ci>
<apply>
<times></times>
<cn type="float">1..</cn>
<ci>j</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   Y_{1..j}
  </annotation>
</semantics>
</math>

, or 

<math display="inline" id="Longest_common_subsequence_problem:27">
<semantics>
<msub>
<mi>X</mi>
<mrow>
<mn>1..</mn>
<mi>i</mi>
</mrow>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>X</ci>
<apply>
<times></times>
<cn type="float">1..</cn>
<ci>i</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   X_{1..i}
  </annotation>
</semantics>
</math>

 and 

<math display="inline" id="Longest_common_subsequence_problem:28">
<semantics>
<msub>
<mi>Y</mi>
<mrow>
<mrow>
<mn>1..</mn>
<mi>j</mi>
</mrow>
<mo>-</mo>
<mn>1</mn>
</mrow>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>Y</ci>
<apply>
<minus></minus>
<apply>
<times></times>
<cn type="float">1..</cn>
<ci>j</ci>
</apply>
<cn type="integer">1</cn>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   Y_{1..j-1}
  </annotation>
</semantics>
</math>

.</p>
<h2 id="code-optimization">Code optimization</h2>

<p>Several optimizations can be made to the algorithm above to speed it up for real-world cases.</p>
<h3 id="reduce-the-problem-set">Reduce the problem set</h3>

<p>The C matrix in the naive algorithm <a href="quadratic_growth" title="wikilink">grows quadratically</a> with the lengths of the sequences. For two 100-item sequences, a 10,000-item matrix would be needed, and 10,000 comparisons would need to be done. In most real-world cases, especially source code diffs and patches, the beginnings and ends of files rarely change, and almost certainly not both at the same time. If only a few items have changed in the middle of the sequence, the beginning and end can be eliminated. This reduces not only the memory requirements for the matrix, but also the number of comparisons that must be done.</p>

<p><strong><code>function</code></strong><code> LCS(X[1..m], Y[1..n])</code><br/>
<code>    start := 1</code><br/>
<code>    m_end := m</code><br/>
<code>    n_end := n</code><br/>
<code>    </code><em><code>trim</code> <code>off</code> <code>the</code> <code>matching</code> <code>items</code> <code>at</code> <code>the</code> <code>beginning</code></em><br/>
<code>    </code><strong><code>while</code></strong><code> start ≤ m_end </code><strong><code>and</code></strong><code> start ≤ n_end </code><strong><code>and</code></strong><code> X[start] = Y[start]</code><br/>
<code>        start := start + 1</code><br/>
<code>    </code><em><code>trim</code> <code>off</code> <code>the</code> <code>matching</code> <code>items</code> <code>at</code> <code>the</code> <code>end</code></em><br/>
<code>    </code><strong><code>while</code></strong><code> start ≤ m_end </code><strong><code>and</code></strong><code> start ≤ n_end </code><strong><code>and</code></strong><code> X[m_end] = Y[n_end]</code><br/>
<code>        m_end := m_end - 1</code><br/>
<code>        n_end := n_end - 1</code><br/>
<code>    C = array(start-1..m_end, start-1..n_end)</code><br/>
<code>    </code><em><code>only</code> <code>loop</code> <code>over</code> <code>the</code> <code>items</code> <code>that</code> <code>have</code> <code>changed</code></em><br/>
<code>    </code><strong><code>for</code></strong><code> i := start..m_end</code><br/>
<code>        </code><strong><code>for</code></strong><code> j := start..n_end</code><br/>
<code>            </code><em><code>the</code> <code>algorithm</code> <code>continues</code> <code>as</code> <code>before</code> <code>...</code></em></p>

<p>In the best-case scenario, a sequence with no changes, this optimization would completely eliminate the need for the C matrix. In the worst-case scenario, a change to the very first and last items in the sequence, only two additional comparisons are performed.</p>
<h3 id="reduce-the-comparison-time">Reduce the comparison time</h3>

<p>Most of the time taken by the naive algorithm is spent performing comparisons between items in the sequences. For textual sequences such as source code, you want to view lines as the sequence elements instead of single characters. This can mean comparisons of relatively long strings for each step in the algorithm. Two optimizations can be made that can help to reduce the time these comparisons consume.</p>
<h3 id="reduce-strings-to-hashes">Reduce strings to hashes</h3>

<p>A <a href="hash_function" title="wikilink">hash function</a> or <a class="uri" href="checksum" title="wikilink">checksum</a> can be used to reduce the size of the strings in the sequences. That is, for source code where the average line is 60 or more characters long, the hash or checksum for that line might be only 8 to 40 characters long. Additionally, the randomized nature of hashes and checksums would guarantee that comparisons would short-circuit faster, as lines of source code will rarely be changed at the beginning.</p>

<p>There are three primary drawbacks to this optimization. First, an amount of time needs to be spent beforehand to precompute the hashes for the two sequences. Second, additional memory needs to be allocated for the new hashed sequences. However, in comparison to the naive algorithm used here, both of these drawbacks are relatively minimal.</p>

<p>The third drawback is that of <a href="hash_collision" title="wikilink">collisions</a>. Since the checksum or hash is not guaranteed to be unique, there is a small chance that two different items could be reduced to the same hash. This is unlikely in source code, but it is possible. A cryptographic hash would therefore be far better suited for this optimization, as its entropy is going to be significantly greater than that of a simple checksum. However, the benefits may not be worth the setup and computational requirements of a cryptographic hash for small sequence lengths.</p>
<h3 id="reduce-the-required-space">Reduce the required space</h3>

<p>If only the length of the LCS is required, the matrix can be reduced to a 

<math display="inline" id="Longest_common_subsequence_problem:29">
<semantics>
<mrow>
<mn>2</mn>
<mo>×</mo>
<mrow>
<mi>min</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>n</mi>
<mo>,</mo>
<mi>m</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<cn type="integer">2</cn>
<apply>
<min></min>
<ci>n</ci>
<ci>m</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   2\times\min(n,m)
  </annotation>
</semantics>
</math>

 matrix with ease, or to a 

<math display="inline" id="Longest_common_subsequence_problem:30">
<semantics>
<mrow>
<mrow>
<mi>min</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>m</mi>
<mo>,</mo>
<mi>n</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>+</mo>
<mn>1</mn>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<plus></plus>
<apply>
<min></min>
<ci>m</ci>
<ci>n</ci>
</apply>
<cn type="integer">1</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \min(m,n)+1
  </annotation>
</semantics>
</math>

 vector (smarter) as the dynamic programming approach only needs the current and previous columns of the matrix. <a href="Hirschberg's_algorithm" title="wikilink">Hirschberg's algorithm</a> allows the construction of the optimal sequence itself in the same quadratic time and linear space bounds.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>
<h3 id="further-optimized-algorithms">Further optimized algorithms</h3>

<p>Several algorithms exist that are worst-case faster than the presented dynamic programming approach.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> For problems with a bounded alphabet size, the <a href="Method_of_Four_Russians" title="wikilink">Method of Four Russians</a> can be used to reduce the running time of the dynamic programming algorithm by a logarithmic factor.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> For 

<math display="inline" id="Longest_common_subsequence_problem:31">
<semantics>
<mi>r</mi>
<annotation-xml encoding="MathML-Content">
<ci>r</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   r
  </annotation>
</semantics>
</math>

 (and 

<math display="inline" id="Longest_common_subsequence_problem:32">
<semantics>
<mrow>
<mi>n</mi>
<mo>&gt;</mo>
<mi>m</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<gt></gt>
<ci>n</ci>
<ci>m</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   n&gt;m
  </annotation>
</semantics>
</math>

), the number of matches between the two sequences, there is an algorithm that performs in 

<math display="inline" id="Longest_common_subsequence_problem:33">
<semantics>
<mrow>
<mi>O</mi>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>n</mi>
<mo>+</mo>
<mi>r</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mrow>
<mi>log</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>n</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<ci>O</ci>
<apply>
<times></times>
<apply>
<plus></plus>
<ci>n</ci>
<ci>r</ci>
</apply>
<apply>
<log></log>
<ci>n</ci>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   O((n+r)\log(n))
  </annotation>
</semantics>
</math>

 time.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a></p>
<h2 id="behavior-on-random-strings">Behavior on random strings</h2>

<p>Beginning with ,<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> a number of researchers have investigated the behavior of the longest common subsequence length when the two given strings are drawn randomly from the same alphabet. When the alphabet size is constant, the expected length of the LCS is proportional to the length of the two strings, and the constants of proportionality (depending on alphabet size) are known as the <a href="Chvátal–Sankoff_constants" title="wikilink">Chvátal–Sankoff constants</a>. Their exact values are not known, but upper and lower bounds on their values have been proven,<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> and it is known that they grow inversely proportionally to the square root of the alphabet size.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> Simplified mathematical models of the longest common subsequence problem have been shown to be controlled by the <a href="Tracy–Widom_distribution" title="wikilink">Tracy–Widom distribution</a>.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Longest_increasing_subsequence" title="wikilink">Longest increasing subsequence</a></li>
<li><a href="Longest_alternating_subsequence" title="wikilink">Longest alternating subsequence</a></li>
<li><a href="Levenshtein_distance" title="wikilink">Levenshtein distance</a></li>
</ul>
<h2 id="references">References</h2>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://nist.gov/dads/HTML/longestCommonSubsequence.html">Dictionary of Algorithms and Data Structures: longest common subsequence</a></li>
<li><a href="http://rosettacode.org/wiki/Longest_common_subsequence">A collection of implementations of the longest common subsequence in many programming languages</a></li>
</ul>

<p>"</p>

<p><a href="Category:Problems_on_strings" title="wikilink">Category:Problems on strings</a> <a class="uri" href="Category:Combinatorics" title="wikilink">Category:Combinatorics</a> <a href="Category:Dynamic_programming" title="wikilink">Category:Dynamic programming</a> <a href="Category:Polynomial-time_problems" title="wikilink">Category:Polynomial-time problems</a> <a href="Category:NP-complete_problems" title="wikilink">Category:NP-complete problems</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
<li id="fn8"><a class="uri" href="http://books.google.com/books?id=mFd_grFyiT4C&amp;pg">http://books.google.com/books?id=mFd_grFyiT4C&amp;pg;</a>;=PA132&amp;lpg;=PA132&amp;dq;=hunt+szymanski+algorithm&amp;source;=bl&amp;ots;=sMc-HtvNTQ&amp;sig;=FtrZ_b5JdJ25Ighwc1-XOfysaf8&amp;hl;=en&amp;sa;=X&amp;ei;=-BU9VPK7OpS7ggT0gYEQ&amp;ved;=0CDsQ6AEwAw#v=onepage&amp;q;&amp;f;=false<a href="#fnref8">↩</a></li>
<li id="fn9">.<a href="#fnref9">↩</a></li>
<li id="fn10"><a class="uri" href="http://www.cs.bgu.ac.il/~dpaa111/wiki.files/HuntSzymanski.pdf">http://www.cs.bgu.ac.il/~dpaa111/wiki.files/HuntSzymanski.pdf</a><a href="#fnref10">↩</a></li>
<li id="fn11">.<a href="#fnref11">↩</a></li>
<li id="fn12">.<a href="#fnref12">↩</a></li>
<li id="fn13">.<a href="#fnref13">↩</a></li>
<li id="fn14">.<a href="#fnref14">↩</a></li>
</ol>
</section>
</body>
</html>
