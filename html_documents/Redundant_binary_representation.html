<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="893">Redundant binary representation</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Redundant binary representation</h1>
<hr>A '''redundant binary representation (RBR)''' is a [[numeral system]] that uses more bits than needed to represent a single binary [[Numerical digit|digit]] so that most numbers have several representations. A RBR is unlike usual [[binary num
<p>eral system]]s, including <a href="two's_complement" title="wikilink">two's complement</a>, which use a single bit for each digit. Many of a RBR's properties differ from those of regular binary representation systems. Most importantly, a RBR allows addition without using a typical carry.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> When compared to non-redundant representation, a RBR makes <a href="bitwise_operation" title="wikilink">bitwise logical operation</a> slower, but <a href="arithmetic_operation#Arithmetic_operations" title="wikilink">arithmetic operations</a> are faster when a greater bit width is used.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> Usually, each digit has its own sign that is not necessarily the same as the sign of the number represented. When digits have signs, that RBR is also a <a href="signed-digit_representation" title="wikilink">signed-digit representation</a>.</p>
<h2 id="conversion-from-rbr">Conversion from RBR</h2>

<p>A RBR is a <a href="positional_notation" title="wikilink">place-value notation system</a>. In a RBR, <a href="Numerical_digit" title="wikilink">digits</a> are <em>pairs</em> of bits, that is, for every place, a RBR uses a pair of bits. The value represented by an RBR digit can be found using a translation table. This table indicates the mathematical value of each possible pair of bits.</p>

<p>As in conventional binary representation, the <a class="uri" href="integer" title="wikilink">integer</a> value of a given representation is a weighted sum of the values of the digits. The weight starts at 1 for the rightmost position and goes up by a factor of 2 for each next position. Usually, a RBR allows negative values. There is no single sign bit that tells if a RBR represented number is positive or negative. Most integers have several possible representations in an RBR.</p>

<p>Often one of the several possible representations of an integer is chosen as the "canonical" form, so each integer has only one possible "canonical" representation -- <a href="non-adjacent_form" title="wikilink">non-adjacent form</a> and two's complement are a popular choices for that canonical form.</p>

<p>An <a class="uri" href="integer" title="wikilink">integer</a> value can be converted back from a RBR using the following formula, where <em>n</em> is the number of digit and <em>d<sub>k</sub></em> is the interpreted value of the <em>k</em>-th digit, where <em>k</em> starts at 0 at the rightmost position:</p>

<p>

<math display="block" id="Redundant_binary_representation:0">
 <semantics>
  <mrow>
   <munderover>
    <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
    <mrow>
     <mi>k</mi>
     <mo>=</mo>
     <mn>0</mn>
    </mrow>
    <mrow>
     <mi>n</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </munderover>
   <mrow>
    <msub>
     <mi>d</mi>
     <mi>k</mi>
    </msub>
    <msup>
     <mn>2</mn>
     <mi>k</mi>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <eq></eq>
       <ci>k</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>d</ci>
      <ci>k</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <ci>k</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{k=0}^{n-1}d_{k}2^{k}
  </annotation>
 </semantics>
</math>

</p>

<p>The conversion from a RBR to two's complement can be done in O(log(n)) using <a href="prefix_adder" title="wikilink">prefix adder</a> where <em>n</em> is the number of digit.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>
<h2 id="example-of-redundant-binary-representation">Example of redundant binary representation</h2>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>Example of translation table for a digit</p></td>
<td style="text-align: left;">
<p>Digit</p></td>
<td style="text-align: left;">
<p>Interpreted value</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>00</p></td>
<td style="text-align: left;">
<p>−1</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>01</p></td>
<td style="text-align: left;">
<p> 0</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>10</p></td>
<td style="text-align: left;">
<p> 0</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>11</p></td>
<td style="text-align: left;">
<p> 1</p></td>
</tr>
</tbody>
</table>

<p>Not all RBR have the same properties. For example, using the translation table on the right, the number 1 can be represented in this RBR in many ways: "01·01·01·11", "01·01·10·11", "01·01·11·00", "11·00·00·00". Also, for this translation table, flipping all bits (<a href="NOT_gate" title="wikilink">NOT gate</a>) corresponds to finding the <a href="additive_inverse" title="wikilink">additive inverse</a> (<a class="uri" href="multiplication" title="wikilink">multiplication</a> by <a class="uri" href="−1" title="wikilink">−1</a>) of the integer represented.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>

<p>In this case

<math display="block" id="Redundant_binary_representation:1">
 <semantics>
  <mrow>
   <msub>
    <mi>d</mi>
    <mi>k</mi>
   </msub>
   <merror class="ltx_ERROR undefined undefined">
    <mtext>\isin</mtext>
   </merror>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
    <mo>,</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mn>1</mn>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>d</ci>
     <ci>k</ci>
    </apply>
    <mtext>\isin</mtext>
    <set>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
     <cn type="integer">0</cn>
     <cn type="integer">1</cn>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d_{k}\isin\{-1,0,1\}
  </annotation>
 </semantics>
</math>

</p>
<h2 id="arithmetic-operations">Arithmetic operations</h2>

<p>A RBR is used by particular <a href="arithmetic_logic_unit" title="wikilink">arithmetic logic units</a>.</p>

<p>In particular, a <a href="carry-save_adder" title="wikilink">carry-save adder</a> uses a RBR.</p>
<h3 id="addition">Addition</h3>

<p> The addition operation in all RBRs is carry-free, which means that the carry does not have to propagate through all the width of the addition unit. In effect, the addition in all RBRs is a constant-time operation. The addition will always take the same amount of time independently of the bit-width of the <a href="operand" title="wikilink">operands</a>. This does not imply that the addition is always faster in a RBR than is <a href="two's_complement" title="wikilink">two's complement</a> representation, but that the addition will eventually be faster in a RBR with increasing bit width because the two's complement addition unit's delay is proportional to log(<em>n</em>) (where <em>n</em> is the bit width).<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> The addition in a RBR takes a constant time because each digit of the result can be calculated independently of one another, implying that each digit of the result can be calculated in parallel. A few of the adders can be found here <a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>
<h3 id="subtraction">Subtraction</h3>

<p>Subtraction is the same as the addition except that the <a href="additive_inverse" title="wikilink">additive inverse</a> of the second operand needs to be computed first. The <a href="additive_inverse" title="wikilink">additive inverse</a> is usually found using a translation table.</p>
<h2 id="logical-operations">Logical operations</h2>

<p>Implementing logical operations in a RBR using <a href="digital_logic" title="wikilink">digital logic</a> is more complicated than in usual representations. For example, the expected result of the bitwise <a href="AND_gate" title="wikilink">AND</a> operation on a pair of representations of 1 is expected to have value 1 in usual representations. Since there are many ways to represent 1 in a RBR, it is not possible to simply use the basic logic gate <a href="AND_gate" title="wikilink">AND</a> between every digit. The same problem apply to the <a href="logical_disjunction" title="wikilink">OR</a> and <a class="uri" href="XOR" title="wikilink">XOR</a> operations. While it is possible to do <a href="bitwise_operation" title="wikilink">bitwise operations</a> directly on the underlying bits inside a RBR, it is not clear that this is a meaningful operation. Assuming one wants the result to represent the same integer value as if the operation had been carried out using a standard non-redundant binary representation, it is necessary to convert the two operands first to non-redundant representations. Consequently, logical operations are slower in a RBR. More precisely, they take a time proportional to log(<em>n</em>) (where <em>n</em> is the number of digit) compared to a constant-time in <a href="two's_complement" title="wikilink">two's complement</a>.</p>
<h2 id="references">References</h2>
<ul>
<li><a href="http://www.louif.com/rbin/">Fast Arithmetic on FPGA Using Redundant Binary Apparatus</a></li>
</ul>

<p>"</p>

<p><a href="Category:Binary_arithmetic" title="wikilink">Category:Binary arithmetic</a> <a href="Category:Non-standard_positional_numeral_systems" title="wikilink">Category:Non-standard positional numeral systems</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Dhananjay Phatak, I. Koren, <em>Hybrid Signed-Digit Number Systems: A Unified Framework for Redundant Number Representations with Bounded Carry Propagation Chains</em>, 1994, <a href="http://citeseer.ist.psu.edu/phatak94hybrid.html">1</a><a href="#fnref1">↩</a></li>
<li id="fn2">Louis-Philippe Lessard, <em>Fast Arithmetic on FPGA Using Redundant Binary Apparatus</em>, 2008, <a href="http://www.louif.com/rbin/">2</a><a href="#fnref2">↩</a></li>
<li id="fn3">Sreehari Veeramachaneni, M.Kirthi Krishna, Lingamneni Avinash, Sreekanth Reddy P, M.B. Srinivas, <em>Novel High-Speed Redundant Binary to Binary converter using Prefix Networks</em>, 2007, [<a class="uri" href="http://ieeexplore.ieee.org/iel5/4252534/4252535/04253377.pdf?isnumber=4252535">http://ieeexplore.ieee.org/iel5/4252534/4252535/04253377.pdf?isnumber=4252535</a>∏=CNF&amp;arnumber;=4253377]<a href="#fnref3">↩</a></li>
<li id="fn4">Marcel Lapointe, Huu Tue Huynh, Paul Fortier. <em>Systematic Design of Pipelined Recursive Filters</em>. s.l. : IEEE TRANSACTIONS ON COMPUTERS, 1993. [<a class="uri" href="http://ieeexplore.ieee.org/xpls/abs_all.jsp?tp">http://ieeexplore.ieee.org/xpls/abs_all.jsp?tp</a>=&amp;arnumber;=214688&amp;isnumber;=5602]<a href="#fnref4">↩</a></li>
<li id="fn5"><a href="http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=1409882">Yu-Ting Pai, Yu-Kumg Chen, <em>The fastest carry lookahead adder</em>, 2004</a><a href="#fnref5">↩</a></li>
<li id="fn6">Bijoy Jose and Damu Radhakrishnan, <em>Delay Optimized Redundant Binary Adders</em> <a href="http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=4263416">3</a><a href="#fnref6">↩</a></li>
</ol>
</section>
</hr></body>
</html>
