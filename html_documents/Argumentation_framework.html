<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="63">Argumentation framework</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Argumentation framework</h1>
<hr/>

<p>An <strong>argumentation framework</strong>, or <strong>argumentation system</strong>, is a way to deal with contentious information and draw conclusions from it.</p>

<p>In an abstract argumentation framework,<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> entry-level information is a set of abstract arguments that, for instance, represent data or a proposition. Conflicts between arguments are represented by a <a href="binary_relation" title="wikilink">binary relation</a> on the set of arguments. In concrete terms, you represent an argumentation framework with a <a href="directed_graph" title="wikilink">directed graph</a> such that the nodes are the arguments, and the arrows represent the attack relation. There exist some extensions of the Dung's framework, like the logic-based argumentation frameworks<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> or the value-based argumentation frameworks.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>
<h2 id="abstract-argumentation-frameworks">Abstract argumentation frameworks</h2>
<h3 id="formal-framework">Formal framework</h3>

<p>Abstract argumentation frameworks, also called argumentation frameworks <em>à la Dung</em>, are defined formally as a pair:</p>
<ul>
<li>A set of abstract elements called <em>arguments</em>, denoted 

<math display="inline" id="Argumentation_framework:0">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

</li>
<li>A binary relation on 

<math display="inline" id="Argumentation_framework:1">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

, called <em>attack relation</em>, denoted 

<math display="inline" id="Argumentation_framework:2">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

</li>
</ul>

<p><a href="Image:Argumentation_Framework.png" title="wikilink">thumb|left|upright=1|The graph built from the system 

<math display="inline" id="Argumentation_framework:3">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

.</a> For instance, the argumentation system 

<math display="inline" id="Argumentation_framework:4">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mi>A</mi>
    <mo>,</mo>
    <mi>R</mi>
    <mo stretchy="false">⟩</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>S</ci>
    <list>
     <ci>A</ci>
     <ci>R</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S=\langle A,R\rangle
  </annotation>
 </semantics>
</math>

 with 

<math display="inline" id="Argumentation_framework:5">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mi>a</mi>
    <mo>,</mo>
    <mi>b</mi>
    <mo>,</mo>
    <mi>c</mi>
    <mo>,</mo>
    <mi>d</mi>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>A</ci>
    <set>
     <ci>a</ci>
     <ci>b</ci>
     <ci>c</ci>
     <ci>d</ci>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A=\{a,b,c,d\}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Argumentation_framework:6">
 <semantics>
  <mrow>
   <mi>R</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>a</mi>
     <mo>,</mo>
     <mi>b</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>b</mi>
     <mo>,</mo>
     <mi>c</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>d</mi>
     <mo>,</mo>
     <mi>c</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>R</ci>
    <set>
     <interval closure="open">
      <ci>a</ci>
      <ci>b</ci>
     </interval>
     <interval closure="open">
      <ci>b</ci>
      <ci>c</ci>
     </interval>
     <interval closure="open">
      <ci>d</ci>
      <ci>c</ci>
     </interval>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R=\{(a,b),(b,c),(d,c)\}
  </annotation>
 </semantics>
</math>

 contains four arguments (

<math display="inline" id="Argumentation_framework:7">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo>,</mo>
   <mi>b</mi>
   <mo>,</mo>
   <mi>c</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>a</ci>
    <ci>b</ci>
    <ci>c</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a,b,c
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Argumentation_framework:8">
 <semantics>
  <mi>d</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>d</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d
  </annotation>
 </semantics>
</math>

) and three attacks (

<math display="inline" id="Argumentation_framework:9">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 attacks 

<math display="inline" id="Argumentation_framework:10">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Argumentation_framework:11">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>

 attacks 

<math display="inline" id="Argumentation_framework:12">
 <semantics>
  <mi>c</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>c</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Argumentation_framework:13">
 <semantics>
  <mi>d</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>d</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d
  </annotation>
 </semantics>
</math>

 attacks 

<math display="inline" id="Argumentation_framework:14">
 <semantics>
  <mi>c</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>c</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c
  </annotation>
 </semantics>
</math>

).</p>

<p>Dung defines some notions :</p>
<ul>
<li>an argument 

<math display="inline" id="Argumentation_framework:15">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo>∈</mo>
   <mi>A</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>a</ci>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a\in A
  </annotation>
 </semantics>
</math>

 is acceptable with respect to 

<math display="inline" id="Argumentation_framework:16">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mo>⊆</mo>
   <mi>A</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <ci>E</ci>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E\subseteq A
  </annotation>
 </semantics>
</math>

 if and only if 

<math display="inline" id="Argumentation_framework:17">
 <semantics>
  <mi>E</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>E</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E
  </annotation>
 </semantics>
</math>

 defends 

<math display="inline" id="Argumentation_framework:18">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

, that is 

<math display="inline" id="Argumentation_framework:19">
 <semantics>
  <mrow>
   <mrow>
    <mo>∀</mo>
    <mi>b</mi>
   </mrow>
   <mo>∈</mo>
   <mi>A</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="latexml">for-all</csymbol>
     <ci>b</ci>
    </apply>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall b\in A
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Argumentation_framework:20">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>b</mi>
     <mo>,</mo>
     <mi>a</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∈</mo>
    <mi>R</mi>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mrow>
     <mo>∃</mo>
     <mi>c</mi>
    </mrow>
    <mo>∈</mo>
    <mi>E</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <in></in>
     <interval closure="open">
      <ci>b</ci>
      <ci>a</ci>
     </interval>
     <ci>R</ci>
    </apply>
    <apply>
     <in></in>
     <apply>
      <exists></exists>
      <ci>c</ci>
     </apply>
     <ci>E</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (b,a)\in R,\exists c\in E
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Argumentation_framework:21">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>c</mi>
    <mo>,</mo>
    <mi>b</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∈</mo>
   <mi>R</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <interval closure="open">
     <ci>c</ci>
     <ci>b</ci>
    </interval>
    <ci>R</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (c,b)\in R
  </annotation>
 </semantics>
</math>

,</li>
<li>a set of arguments 

<math display="inline" id="Argumentation_framework:22">
 <semantics>
  <mi>E</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>E</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E
  </annotation>
 </semantics>
</math>

 is conflict-free if there is no attack between its arguments, formally 

<math display="block" id="Argumentation_framework:23">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mo>∀</mo>
      <mi>a</mi>
     </mrow>
     <mo>,</mo>
     <mi>b</mi>
    </mrow>
    <mo>∈</mo>
    <mi>E</mi>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>a</mi>
     <mo>,</mo>
     <mi>b</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∉</mo>
    <mi>R</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <in></in>
     <list>
      <apply>
       <csymbol cd="latexml">for-all</csymbol>
       <ci>a</ci>
      </apply>
      <ci>b</ci>
     </list>
     <ci>E</ci>
    </apply>
    <apply>
     <notin></notin>
     <interval closure="open">
      <ci>a</ci>
      <ci>b</ci>
     </interval>
     <ci>R</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall a,b\in E,(a,b)\not\in R
  </annotation>
 </semantics>
</math>

,</li>
<li>a set of arguments 

<math display="inline" id="Argumentation_framework:24">
 <semantics>
  <mi>E</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>E</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E
  </annotation>
 </semantics>
</math>

 is admissible if and only if it is conflict-free and all its arguments are acceptables with respect to 

<math display="inline" id="Argumentation_framework:25">
 <semantics>
  <mi>E</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>E</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E
  </annotation>
 </semantics>
</math>

.</li>
</ul>
<h3 id="different-semantics-of-acceptance">Different semantics of acceptance</h3>
<h4 id="extensions">Extensions</h4>

<p>To decide if an argument can be accepted or not, or if several arguments can be accepted together, Dung defines several semantics of acceptance that allow, given an argumentation system, to compute sets of arguments, called <em>extensions</em>. For instance, given 

<math display="inline" id="Argumentation_framework:26">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mi>A</mi>
    <mo>,</mo>
    <mi>R</mi>
    <mo stretchy="false">⟩</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>S</ci>
    <list>
     <ci>A</ci>
     <ci>R</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S=\langle A,R\rangle
  </annotation>
 </semantics>
</math>

,</p>
<ul>
<li>

<math display="inline" id="Argumentation_framework:27">
 <semantics>
  <mi>E</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>E</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E
  </annotation>
 </semantics>
</math>

 is a complete extension of 

<math display="inline" id="Argumentation_framework:28">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 only if it is an admissible set and every acceptable argument with respect to 

<math display="inline" id="Argumentation_framework:29">
 <semantics>
  <mi>E</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>E</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E
  </annotation>
 </semantics>
</math>

 belongs to 

<math display="inline" id="Argumentation_framework:30">
 <semantics>
  <mi>E</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>E</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E
  </annotation>
 </semantics>
</math>

,</li>
<li>

<math display="inline" id="Argumentation_framework:31">
 <semantics>
  <mi>E</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>E</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E
  </annotation>
 </semantics>
</math>

 is a preferred extension of 

<math display="inline" id="Argumentation_framework:32">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 only if it is a maximal element (with respect to the set-theoretical inclusion) among the admissible sets with respect to 

<math display="inline" id="Argumentation_framework:33">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

,</li>
<li>

<math display="inline" id="Argumentation_framework:34">
 <semantics>
  <mi>E</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>E</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E
  </annotation>
 </semantics>
</math>

 is a stable extension of 

<math display="inline" id="Argumentation_framework:35">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 only if it is a conflict-free set that attacks every argument that does not belong in 

<math display="inline" id="Argumentation_framework:36">
 <semantics>
  <mi>E</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>E</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E
  </annotation>
 </semantics>
</math>

 (formally, 

<math display="inline" id="Argumentation_framework:37">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>∀</mo>
     <mi>a</mi>
    </mrow>
    <mo>∈</mo>
    <mrow>
     <mi>A</mi>
     <mo>\</mo>
     <mi>E</mi>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mrow>
     <mo>∃</mo>
     <mi>b</mi>
    </mrow>
    <mo>∈</mo>
    <mi>S</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <in></in>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <ci>a</ci>
     </apply>
     <apply>
      <ci>normal-\</ci>
      <ci>A</ci>
      <ci>E</ci>
     </apply>
    </apply>
    <apply>
     <in></in>
     <apply>
      <exists></exists>
      <ci>b</ci>
     </apply>
     <ci>S</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall a\in A\backslash E,\exists b\in S
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Argumentation_framework:38">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>b</mi>
    <mo>,</mo>
    <mi>a</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∈</mo>
   <mi>R</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <interval closure="open">
     <ci>b</ci>
     <ci>a</ci>
    </interval>
    <ci>R</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (b,a)\in R
  </annotation>
 </semantics>
</math>

,</li>
<li>

<math display="inline" id="Argumentation_framework:39">
 <semantics>
  <mi>E</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>E</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E
  </annotation>
 </semantics>
</math>

 is the (unique) grounded extension of 

<math display="inline" id="Argumentation_framework:40">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 only if it is the smallest element (with respect to set inclusion) among the complete extensions of 

<math display="inline" id="Argumentation_framework:41">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

.</li>
</ul>

<p>There exists some inclusions between the sets of extensions built with these semantics :</p>
<ul>
<li>Every stable extension is preferred,</li>
<li>Every preferred extension is complete,</li>
<li>The grounded extension is complete,</li>
<li>If the system is well founded (there exists no infinite sequence 

<math display="inline" id="Argumentation_framework:42">
 <semantics>
  <mrow>
   <msub>
    <mi>a</mi>
    <mn>0</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>a</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>a</mi>
    <mi>n</mi>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <ci>n</ci>
    </apply>
    <ci>normal-…</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{0},a_{1},\dots,a_{n},\dots
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Argumentation_framework:43">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>∀</mo>
     <mi>i</mi>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>a</mi>
      <mi>i</mi>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>a</mi>
      <mrow>
       <mi>i</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>∈</mo>
   <mi>R</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <list>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <ci>i</ci>
     </apply>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <apply>
        <plus></plus>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </interval>
    </list>
    <ci>R</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall i,(a_{i},a_{i+1})\in R
  </annotation>
 </semantics>
</math>

), all these semantics coincide—only one extension is grounded, stable, preferred, and complete.</li>
</ul>

<p>Some other semantics have been defined.<ref>For instance,</ref></p>
<ul>
<li><em>Ideal</em> : see Dung, Mancarella and Toni (2006)</li>
<li><em>Eager</em> : see Caminada (2007)</li>
</ul>

<p>One introduce the notation 

<math display="inline" id="Argumentation_framework:44">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mi>x</mi>
   <msub>
    <mi>t</mi>
    <mi>σ</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>S</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>E</ci>
    <ci>x</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>t</ci>
     <ci>σ</ci>
    </apply>
    <ci>S</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Ext_{\sigma}(S)
  </annotation>
 </semantics>
</math>

 to note the set of 

<math display="inline" id="Argumentation_framework:45">
 <semantics>
  <mi>σ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma
  </annotation>
 </semantics>
</math>

-extensions of the system 

<math display="inline" id="Argumentation_framework:46">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

.</p>

<p>In the case of the system 

<math display="inline" id="Argumentation_framework:47">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 in the figure above, 

<math display="inline" id="Argumentation_framework:48">
 <semantics>
  <mrow>
   <mrow>
    <mi>E</mi>
    <mi>x</mi>
    <msub>
     <mi>t</mi>
     <mi>σ</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>S</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mi>a</mi>
     <mo>,</mo>
     <mi>d</mi>
     <mo stretchy="false">}</mo>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>E</ci>
     <ci>x</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>t</ci>
      <ci>σ</ci>
     </apply>
     <ci>S</ci>
    </apply>
    <set>
     <set>
      <ci>a</ci>
      <ci>d</ci>
     </set>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Ext_{\sigma}(S)=\{\{a,d\}\}
  </annotation>
 </semantics>
</math>

 for every Dung's semantic—the system is well-founded. That explains why the semantics coincide, and the accepted arguments are

<math display="block" id="Argumentation_framework:49">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Argumentation_framework:50">
 <semantics>
  <mi>d</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>d</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d
  </annotation>
 </semantics>
</math>

.</p>
<h4 id="labellings">Labellings</h4>

<p>Labellings are a more expressive way than extensions to express the acceptance of the arguments. Concretely, a labelling is a mapping that associates every argument with a label <em>in</em> (the argument is accepted), <em>out</em> (the argument is rejected), or <em>undec</em> (the argument is undefined—not accepted or refused). One can also note a labelling as a set of pairs 

<math display="inline" id="Argumentation_framework:51">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>𝑎𝑟𝑔𝑢𝑚𝑒𝑛𝑡</mi>
   <mo>,</mo>
   <mi>𝑙𝑎𝑏𝑒𝑙</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>𝑎𝑟𝑔𝑢𝑚𝑒𝑛𝑡</ci>
    <ci>𝑙𝑎𝑏𝑒𝑙</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\mathit{argument},\mathit{label})
  </annotation>
 </semantics>
</math>

.</p>

<p>Such a mapping does not make sense without additional constraint. The notion of reinstatement labelling guarantees the sense of the mapping. 

<math display="inline" id="Argumentation_framework:52">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

 is a reinstatement labelling on the system 

<math display="inline" id="Argumentation_framework:53">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mi>A</mi>
    <mo>,</mo>
    <mi>R</mi>
    <mo stretchy="false">⟩</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>S</ci>
    <list>
     <ci>A</ci>
     <ci>R</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S=\langle A,R\rangle
  </annotation>
 </semantics>
</math>

 if and only if :</p>
<ul>
<li>

<math display="inline" id="Argumentation_framework:54">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>∀</mo>
     <mi>a</mi>
    </mrow>
    <mo>∈</mo>
    <mi>A</mi>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mrow>
     <mi>L</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>a</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mi>𝑖𝑛</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <in></in>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <ci>a</ci>
     </apply>
     <ci>A</ci>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>L</ci>
      <ci>a</ci>
     </apply>
     <ci>𝑖𝑛</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall a\in A,L(a)=\mathit{in}
  </annotation>
 </semantics>
</math>

 if and only if 

<math display="inline" id="Argumentation_framework:55">
 <semantics>
  <mrow>
   <mrow>
    <mo>∀</mo>
    <mi>b</mi>
   </mrow>
   <mo>∈</mo>
   <mi>A</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="latexml">for-all</csymbol>
     <ci>b</ci>
    </apply>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall b\in A
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Argumentation_framework:56">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>b</mi>
     <mo>,</mo>
     <mi>a</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∈</mo>
    <mi>R</mi>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mrow>
     <mi>L</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>b</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mi>𝑜𝑢𝑡</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <in></in>
     <interval closure="open">
      <ci>b</ci>
      <ci>a</ci>
     </interval>
     <ci>R</ci>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>L</ci>
      <ci>b</ci>
     </apply>
     <ci>𝑜𝑢𝑡</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (b,a)\in R,L(b)=\mathit{out}
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="Argumentation_framework:57">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>∀</mo>
     <mi>a</mi>
    </mrow>
    <mo>∈</mo>
    <mi>A</mi>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mrow>
     <mi>L</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>a</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mi>𝑜𝑢𝑡</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <in></in>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <ci>a</ci>
     </apply>
     <ci>A</ci>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>L</ci>
      <ci>a</ci>
     </apply>
     <ci>𝑜𝑢𝑡</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall a\in A,L(a)=\mathit{out}
  </annotation>
 </semantics>
</math>

 if and only if 

<math display="inline" id="Argumentation_framework:58">
 <semantics>
  <mrow>
   <mrow>
    <mo>∃</mo>
    <mi>b</mi>
   </mrow>
   <mo>∈</mo>
   <mi>A</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <exists></exists>
     <ci>b</ci>
    </apply>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \exists b\in A
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Argumentation_framework:59">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>b</mi>
    <mo>,</mo>
    <mi>a</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∈</mo>
   <mi>R</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <interval closure="open">
     <ci>b</ci>
     <ci>a</ci>
    </interval>
    <ci>R</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (b,a)\in R
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Argumentation_framework:60">
 <semantics>
  <mrow>
   <mrow>
    <mi>L</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>b</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>𝑖𝑛</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>L</ci>
     <ci>b</ci>
    </apply>
    <ci>𝑖𝑛</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L(b)=\mathit{in}
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="Argumentation_framework:61">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>∀</mo>
     <mi>a</mi>
    </mrow>
    <mo>∈</mo>
    <mi>A</mi>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mrow>
     <mi>L</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>a</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mi>𝑢𝑛𝑑𝑒𝑐</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <in></in>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <ci>a</ci>
     </apply>
     <ci>A</ci>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>L</ci>
      <ci>a</ci>
     </apply>
     <ci>𝑢𝑛𝑑𝑒𝑐</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall a\in A,L(a)=\mathit{undec}
  </annotation>
 </semantics>
</math>

 if and only if 

<math display="inline" id="Argumentation_framework:62">
 <semantics>
  <mrow>
   <mrow>
    <mi>L</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>a</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≠</mo>
   <mi>𝑖𝑛</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <neq></neq>
    <apply>
     <times></times>
     <ci>L</ci>
     <ci>a</ci>
    </apply>
    <ci>𝑖𝑛</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L(a)\neq\mathit{in}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Argumentation_framework:63">
 <semantics>
  <mrow>
   <mrow>
    <mi>L</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>a</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≠</mo>
   <mi>𝑜𝑢𝑡</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <neq></neq>
    <apply>
     <times></times>
     <ci>L</ci>
     <ci>a</ci>
    </apply>
    <ci>𝑜𝑢𝑡</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L(a)\neq\mathit{out}
  </annotation>
 </semantics>
</math>

</li>
</ul>

<p>One can convert every extension into a reinstatement labelling: the arguments of the extension are <em>in</em>, those attacked by an argument of the extension are <em>out</em>, and the others are <em>undec</em>. Conversely, one can build an extension from a reinstatement labelling just by keeping the arguments <em>in</em>. Indeed, Caminada<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> proved that the reinstatement labellings and the complete extensions can be mapped in a <a href="Bijection" title="wikilink">bijective</a> way. Moreover, the other Datung's semantics can be associated to some particular sets of reinstatement labellings.</p>

<p>Reinstatement labellings distinguish arguments not accepted because they are attacked by accepted arguments from undefined arguments—that is, those that are not defended cannot defend themselves. An argument is <em>undec</em> if it is attacked by at least another <em>undec</em>. If it is attacked only by arguments <em>out</em>, it must be <em>in</em>, and if it is attacked only by arguments <em>in</em>, then it is <em>out</em>.</p>

<p>The unique reinstatement labelling that corresponds to the system 

<math display="inline" id="Argumentation_framework:64">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 above is 

<math display="inline" id="Argumentation_framework:65">
 <semantics>
  <mrow>
   <mi>L</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>a</mi>
     <mo>,</mo>
     <mi>𝑖𝑛</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>b</mi>
     <mo>,</mo>
     <mi>𝑜𝑢𝑡</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>c</mi>
     <mo>,</mo>
     <mi>𝑜𝑢𝑡</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>d</mi>
     <mo>,</mo>
     <mi>𝑖𝑛</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>L</ci>
    <set>
     <interval closure="open">
      <ci>a</ci>
      <ci>𝑖𝑛</ci>
     </interval>
     <interval closure="open">
      <ci>b</ci>
      <ci>𝑜𝑢𝑡</ci>
     </interval>
     <interval closure="open">
      <ci>c</ci>
      <ci>𝑜𝑢𝑡</ci>
     </interval>
     <interval closure="open">
      <ci>d</ci>
      <ci>𝑖𝑛</ci>
     </interval>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L=\{(a,\mathit{in}),(b,\mathit{out}),(c,\mathit{out}),(d,\mathit{in})\}
  </annotation>
 </semantics>
</math>

.</p>
<h3 id="inference-from-an-argumentation-system">Inference from an argumentation system</h3>

<p>In the general case when several extensions are computed for a given semantic 

<math display="inline" id="Argumentation_framework:66">
 <semantics>
  <mi>σ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma
  </annotation>
 </semantics>
</math>

, the agent that reasons from the system can use several mechanism to infer information:<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>
<ul>
<li><em>Credulous inference</em>: the agent accepts an argument if it belongs to at least one of the 

<math display="inline" id="Argumentation_framework:67">
 <semantics>
  <mi>σ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma
  </annotation>
 </semantics>
</math>

-extensions—in which case, the agent risks accepting some arguments that are not acceptable together (

<math display="inline" id="Argumentation_framework:68">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 attacks 

<math display="inline" id="Argumentation_framework:69">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="Argumentation_framework:70">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Argumentation_framework:71">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>

 each belongs to an extension)</li>
<li><em>Skeptical inference</em>: the agent accepts an argument only if it belongs to every 

<math display="inline" id="Argumentation_framework:72">
 <semantics>
  <mi>σ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma
  </annotation>
 </semantics>
</math>

-extension. In this case, the agent risks deducing too little information (if the intersection of the extensions is empty or has a very small cardinal).</li>
</ul>

<p>For these two methods to infer information, one can identify the set of accepted arguments, respectively 

<math display="inline" id="Argumentation_framework:73">
 <semantics>
  <mrow>
   <mi>C</mi>
   <msub>
    <mi>r</mi>
    <mi>σ</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>S</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>C</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>r</ci>
     <ci>σ</ci>
    </apply>
    <ci>S</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Cr_{\sigma}(S)
  </annotation>
 </semantics>
</math>

 the set of the arguments credulously accepted under the semantic 

<math display="inline" id="Argumentation_framework:74">
 <semantics>
  <mi>σ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="Argumentation_framework:75">
 <semantics>
  <mrow>
   <mi>S</mi>
   <msub>
    <mi>c</mi>
    <mi>σ</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>S</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>S</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>c</ci>
     <ci>σ</ci>
    </apply>
    <ci>S</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Sc_{\sigma}(S)
  </annotation>
 </semantics>
</math>

 the set of arguments accepted skeptically under the semantic 

<math display="inline" id="Argumentation_framework:76">
 <semantics>
  <mi>σ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma
  </annotation>
 </semantics>
</math>

 (the 

<math display="inline" id="Argumentation_framework:77">
 <semantics>
  <mi>σ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma
  </annotation>
 </semantics>
</math>

 can be missed if there is no possible ambiguity about the semantic).</p>

<p>Of course, when there is only one extension (for instance, when the system is well-founded), this problem is very simple: the agent accepts arguments of the unique extension and rejects others.</p>

<p>The same reasoning can be done with labellings that correspond to the chosen semantic : an argument can be accepted if it is <em>in</em> for each labelling and refused if it is <em>out</em> for each labelling, the others being in an undecided state (the status of the arguments can remind the epistemic states of a belief in the AGM framework for dynamic of beliefs<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a>).</p>
<h3 id="equivalence-between-argumentation-frameworks">Equivalence between argumentation frameworks</h3>

<p>There exists several criterions of equivalence between argumentation frameworks. Most of those criterions concern the sets of extensions or the set of accepted arguments. Formally, given a semantic 

<math display="inline" id="Argumentation_framework:78">
 <semantics>
  <mi>σ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma
  </annotation>
 </semantics>
</math>

 :</p>
<ul>
<li>

<math display="inline" id="Argumentation_framework:79">
 <semantics>
  <msub>
   <mi>𝐸𝑄</mi>
   <mn mathvariant="italic">1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝐸𝑄</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathit{EQ_{1}}
  </annotation>
 </semantics>
</math>

 : two argumentation frameworks are equivalent if they have the same set of 

<math display="inline" id="Argumentation_framework:80">
 <semantics>
  <mi>σ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma
  </annotation>
 </semantics>
</math>

-extensions, that is 

<math display="inline" id="Argumentation_framework:81">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>S</mi>
     <mn>1</mn>
    </msub>
    <msub>
     <mo>≡</mo>
     <mn>1</mn>
    </msub>
    <msub>
     <mi>S</mi>
     <mn>2</mn>
    </msub>
   </mrow>
   <mo>⇔</mo>
   <mrow>
    <mrow>
     <mi>E</mi>
     <mi>x</mi>
     <msub>
      <mi>t</mi>
      <mi>σ</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>S</mi>
       <mn>1</mn>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>E</mi>
     <mi>x</mi>
     <msub>
      <mi>t</mi>
      <mi>σ</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>S</mi>
       <mn>2</mn>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-⇔</ci>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <equivalent></equivalent>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>S</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>S</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>E</ci>
      <ci>x</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>t</ci>
       <ci>σ</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>S</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>E</ci>
      <ci>x</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>t</ci>
       <ci>σ</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>S</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{1}\equiv_{1}S_{2}\Leftrightarrow Ext_{\sigma}(S_{1})=Ext_{\sigma}(S_{2})
  </annotation>
 </semantics>
</math>

 ;</li>
<li>

<math display="inline" id="Argumentation_framework:82">
 <semantics>
  <msub>
   <mi>𝐸𝑄</mi>
   <mn mathvariant="italic">2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝐸𝑄</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathit{EQ_{2}}
  </annotation>
 </semantics>
</math>

 : two argumentation frameworks are equivalent if they accept skeptically the same arguments, that is 

<math display="inline" id="Argumentation_framework:83">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>S</mi>
     <mn>1</mn>
    </msub>
    <msub>
     <mo>≡</mo>
     <mn>2</mn>
    </msub>
    <msub>
     <mi>S</mi>
     <mn>2</mn>
    </msub>
   </mrow>
   <mo>⇔</mo>
   <mrow>
    <mrow>
     <mi>S</mi>
     <msub>
      <mi>c</mi>
      <mi>σ</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>S</mi>
       <mn>1</mn>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>S</mi>
     <msub>
      <mi>c</mi>
      <mi>σ</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>S</mi>
       <mn>2</mn>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-⇔</ci>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <equivalent></equivalent>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>S</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>S</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>S</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>c</ci>
       <ci>σ</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>S</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>S</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>c</ci>
       <ci>σ</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>S</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{1}\equiv_{2}S_{2}\Leftrightarrow Sc_{\sigma}(S_{1})=Sc_{\sigma}(S_{2})
  </annotation>
 </semantics>
</math>

 ;</li>
<li>

<math display="inline" id="Argumentation_framework:84">
 <semantics>
  <msub>
   <mi>𝐸𝑄</mi>
   <mn mathvariant="italic">2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝐸𝑄</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathit{EQ_{2}}
  </annotation>
 </semantics>
</math>

 : two argumentation frameworks are equivalent if they accept credulously the same arguments, that is 

<math display="inline" id="Argumentation_framework:85">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>S</mi>
     <mn>1</mn>
    </msub>
    <msub>
     <mo>≡</mo>
     <mn>3</mn>
    </msub>
    <msub>
     <mi>S</mi>
     <mn>2</mn>
    </msub>
   </mrow>
   <mo>⇔</mo>
   <mrow>
    <mrow>
     <mi>C</mi>
     <msub>
      <mi>r</mi>
      <mi>σ</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>S</mi>
       <mn>1</mn>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>C</mi>
     <msub>
      <mi>r</mi>
      <mi>σ</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>S</mi>
       <mn>2</mn>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-⇔</ci>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <equivalent></equivalent>
      <cn type="integer">3</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>S</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>S</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>C</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>r</ci>
       <ci>σ</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>S</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>C</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>r</ci>
       <ci>σ</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>S</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{1}\equiv_{3}S_{2}\Leftrightarrow Cr_{\sigma}(S_{1})=Cr_{\sigma}(S_{2})
  </annotation>
 </semantics>
</math>

.</li>
</ul>

<p>The strong equivalence<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> says that two systems 

<math display="inline" id="Argumentation_framework:86">
 <semantics>
  <msub>
   <mi>S</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>S</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{1}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Argumentation_framework:87">
 <semantics>
  <msub>
   <mi>S</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>S</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{2}
  </annotation>
 </semantics>
</math>

 are equivalent if and only if for all other system 

<math display="inline" id="Argumentation_framework:88">
 <semantics>
  <msub>
   <mi>S</mi>
   <mn>3</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>S</ci>
    <cn type="integer">3</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{3}
  </annotation>
 </semantics>
</math>

, the union of 

<math display="inline" id="Argumentation_framework:89">
 <semantics>
  <msub>
   <mi>S</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>S</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{1}
  </annotation>
 </semantics>
</math>

 with 

<math display="inline" id="Argumentation_framework:90">
 <semantics>
  <msub>
   <mi>S</mi>
   <mn>3</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>S</ci>
    <cn type="integer">3</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{3}
  </annotation>
 </semantics>
</math>

 is equivalent (for a given criterion) with the union of 

<math display="inline" id="Argumentation_framework:91">
 <semantics>
  <msub>
   <mi>S</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>S</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{2}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Argumentation_framework:92">
 <semantics>
  <msub>
   <mi>S</mi>
   <mn>3</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>S</ci>
    <cn type="integer">3</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{3}
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></p>
<h2 id="other-kind-of-argumentation-frameworks">Other kind of argumentation frameworks</h2>

<p>The abstract framework of Dung has been instantiated to several particular cases.</p>
<h3 id="logic-based-argumentation-frameworks">Logic-based argumentation frameworks</h3>

<p>In the case of logic-based argumentation frameworks, an argument is not an abstract entity, but a pair, where the first part is a minimal consistent set of formulae enough to prove the formula for the second part of the argument. Formally, an argument is a pair 

<math display="inline" id="Argumentation_framework:93">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi mathvariant="normal">Φ</mi>
   <mo>,</mo>
   <mi>α</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>normal-Φ</ci>
    <ci>α</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\Phi,\alpha)
  </annotation>
 </semantics>
</math>

 such that</p>
<ul>
<li>

<math display="inline" id="Argumentation_framework:94">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Φ</mi>
   <mo>⊬</mo>
   <mo>⊥</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">not-proves</csymbol>
    <ci>normal-Φ</ci>
    <csymbol cd="latexml">bottom</csymbol>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Phi\nvdash\bot
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="Argumentation_framework:95">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Φ</mi>
   <mo>⊢</mo>
   <mi>α</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">proves</csymbol>
    <ci>normal-Φ</ci>
    <ci>α</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Phi\vdash\alpha
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="Argumentation_framework:96">
 <semantics>
  <mi mathvariant="normal">Φ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Φ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Phi
  </annotation>
 </semantics>
</math>

 is a minimal set of 

<math display="inline" id="Argumentation_framework:97">
 <semantics>
  <mi mathvariant="normal">Δ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Δ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta
  </annotation>
 </semantics>
</math>

 satisfying 

<math display="inline" id="Argumentation_framework:98">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Argumentation_framework:99">
 <semantics>
  <mi mathvariant="normal">Δ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Δ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta
  </annotation>
 </semantics>
</math>

 is a set of formulae used by the agent to reason.</li>
</ul>

<p>One calls 

<math display="inline" id="Argumentation_framework:100">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>

 a consequence of 

<math display="inline" id="Argumentation_framework:101">
 <semantics>
  <mi mathvariant="normal">Φ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Φ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Phi
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="Argumentation_framework:102">
 <semantics>
  <mi mathvariant="normal">Φ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Φ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Phi
  </annotation>
 </semantics>
</math>

 a support of 

<math display="inline" id="Argumentation_framework:103">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>

.</p>

<p>In this case, the attack relation is not given in an explicit way, as a subset of the Cartesian product 

<math display="inline" id="Argumentation_framework:104">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>×</mo>
   <mi>A</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>A</ci>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\times A
  </annotation>
 </semantics>
</math>

, but as a property that indicates if an argument attacks another. For instance,</p>
<ul>
<li>Relation <em>defeater</em> 

<math display="block" id="Argumentation_framework:105">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi mathvariant="normal">Ψ</mi>
   <mo>,</mo>
   <mi>β</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>normal-Ψ</ci>
    <ci>β</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\Psi,\beta)
  </annotation>
 </semantics>
</math>

 attacks 

<math display="inline" id="Argumentation_framework:106">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi mathvariant="normal">Φ</mi>
   <mo>,</mo>
   <mi>α</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>normal-Φ</ci>
    <ci>α</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\Phi,\alpha)
  </annotation>
 </semantics>
</math>

 if and only if 

<math display="inline" id="Argumentation_framework:107">
 <semantics>
  <mrow>
   <mi>β</mi>
   <mo>⊢</mo>
   <mrow>
    <mi mathvariant="normal">¬</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>ϕ</mi>
       <mn>1</mn>
      </msub>
      <mo>∧</mo>
      <mi mathvariant="normal">…</mi>
      <mo>∧</mo>
      <msub>
       <mi>ϕ</mi>
       <mi>n</mi>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">proves</csymbol>
    <ci>β</ci>
    <apply>
     <not></not>
     <apply>
      <and></and>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ϕ</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ϕ</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta\vdash\neg(\phi_{1}\wedge\dots\wedge\phi_{n})
  </annotation>
 </semantics>
</math>

 for 

<math display="inline" id="Argumentation_framework:108">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">{</mo>
    <msub>
     <mi>ϕ</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>ϕ</mi>
     <mi>n</mi>
    </msub>
    <mo stretchy="false">}</mo>
   </mrow>
   <mo>⊆</mo>
   <mi mathvariant="normal">Φ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <set>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ϕ</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ϕ</ci>
      <ci>n</ci>
     </apply>
    </set>
    <ci>normal-Φ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{\phi_{1},\dots,\phi_{n}\}\subseteq\Phi
  </annotation>
 </semantics>
</math>

</li>
<li>Relation <em>undercut</em> 

<math display="block" id="Argumentation_framework:109">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi mathvariant="normal">Ψ</mi>
   <mo>,</mo>
   <mi>β</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>normal-Ψ</ci>
    <ci>β</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\Psi,\beta)
  </annotation>
 </semantics>
</math>

 attacks 

<math display="inline" id="Argumentation_framework:110">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi mathvariant="normal">Φ</mi>
   <mo>,</mo>
   <mi>α</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>normal-Φ</ci>
    <ci>α</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\Phi,\alpha)
  </annotation>
 </semantics>
</math>

 if and only if 

<math display="inline" id="Argumentation_framework:111">
 <semantics>
  <mrow>
   <mi>β</mi>
   <mo>=</mo>
   <mrow>
    <mi mathvariant="normal">¬</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>ϕ</mi>
       <mn>1</mn>
      </msub>
      <mo>∧</mo>
      <mi mathvariant="normal">…</mi>
      <mo>∧</mo>
      <msub>
       <mi>ϕ</mi>
       <mi>n</mi>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>β</ci>
    <apply>
     <not></not>
     <apply>
      <and></and>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ϕ</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ϕ</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta=\neg(\phi_{1}\wedge\dots\wedge\phi_{n})
  </annotation>
 </semantics>
</math>

 for 

<math display="inline" id="Argumentation_framework:112">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">{</mo>
    <msub>
     <mi>ϕ</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>ϕ</mi>
     <mi>n</mi>
    </msub>
    <mo stretchy="false">}</mo>
   </mrow>
   <mo>⊆</mo>
   <mi mathvariant="normal">Φ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <set>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ϕ</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ϕ</ci>
      <ci>n</ci>
     </apply>
    </set>
    <ci>normal-Φ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{\phi_{1},\dots,\phi_{n}\}\subseteq\Phi
  </annotation>
 </semantics>
</math>

</li>
<li>Relation <em>rebuttal</em> 

<math display="block" id="Argumentation_framework:113">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi mathvariant="normal">Ψ</mi>
   <mo>,</mo>
   <mi>β</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>normal-Ψ</ci>
    <ci>β</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\Psi,\beta)
  </annotation>
 </semantics>
</math>

 attacks 

<math display="inline" id="Argumentation_framework:114">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi mathvariant="normal">Φ</mi>
   <mo>,</mo>
   <mi>α</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>normal-Φ</ci>
    <ci>α</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\Phi,\alpha)
  </annotation>
 </semantics>
</math>

 if and only if 

<math display="inline" id="Argumentation_framework:115">
 <semantics>
  <mrow>
   <mi>β</mi>
   <mo>⇔</mo>
   <mrow>
    <mi mathvariant="normal">¬</mi>
    <mi>α</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-⇔</ci>
    <ci>β</ci>
    <apply>
     <times></times>
     <not></not>
     <ci>α</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta\Leftrightarrow\neg\alpha
  </annotation>
 </semantics>
</math>

 is a tautology</li>
</ul>

<p>Given a particular attack relation, one can build a graph and reason in a similar way to the abstract argumentation frameworks (use of semantics to build extension, skeptical or credulous inference), the difference is that the information inferred from a logic based argumentation framework is a set of formulae (the consequences of the accepted arguments).</p>
<h3 id="value-based-argumentation-frameworks">Value-based argumentation frameworks</h3>

<p>The value-based argumentation frameworks come from the idea that during an exchange of arguments, some can be <em>stronger</em> than others with respect to a certain value they advance, and so the success of an attack between arguments depends of the difference of these values.</p>

<p>Formally, a value-based argumentation framework is a tuple 

<math display="inline" id="Argumentation_framework:116">
 <semantics>
  <mrow>
   <mrow>
    <mi>V</mi>
    <mi>A</mi>
    <mi>F</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mi>A</mi>
    <mo>,</mo>
    <mi>R</mi>
    <mo>,</mo>
    <mi>V</mi>
    <mo>,</mo>
    <mrow>
     <mi>v</mi>
     <mi>a</mi>
     <mi>l</mi>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mi>v</mi>
     <mi>a</mi>
     <mi>l</mi>
     <mi>p</mi>
     <mi>r</mi>
     <mi>e</mi>
     <mi>f</mi>
     <mi>s</mi>
    </mrow>
    <mo stretchy="false">⟩</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>V</ci>
     <ci>A</ci>
     <ci>F</ci>
    </apply>
    <list>
     <ci>A</ci>
     <ci>R</ci>
     <ci>V</ci>
     <apply>
      <times></times>
      <ci>v</ci>
      <ci>a</ci>
      <ci>l</ci>
     </apply>
     <apply>
      <times></times>
      <ci>v</ci>
      <ci>a</ci>
      <ci>l</ci>
      <ci>p</ci>
      <ci>r</ci>
      <ci>e</ci>
      <ci>f</ci>
      <ci>s</ci>
     </apply>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   VAF=\langle A,R,V,val,valprefs\rangle
  </annotation>
 </semantics>
</math>

 with 

<math display="inline" id="Argumentation_framework:117">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Argumentation_framework:118">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

 similar to the standard framework (a set of arguments and a binary relation on this set), 

<math display="inline" id="Argumentation_framework:119">
 <semantics>
  <mi>V</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>V</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V
  </annotation>
 </semantics>
</math>

 is a non empty set of values, 

<math display="inline" id="Argumentation_framework:120">
 <semantics>
  <mrow>
   <mi>v</mi>
   <mi>a</mi>
   <mi>l</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>v</ci>
    <ci>a</ci>
    <ci>l</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   val
  </annotation>
 </semantics>
</math>

 is a mapping that associates each element from 

<math display="inline" id="Argumentation_framework:121">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 to an element from 

<math display="inline" id="Argumentation_framework:122">
 <semantics>
  <mi>V</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>V</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="Argumentation_framework:123">
 <semantics>
  <mrow>
   <mi>v</mi>
   <mi>a</mi>
   <mi>l</mi>
   <mi>p</mi>
   <mi>r</mi>
   <mi>e</mi>
   <mi>f</mi>
   <mi>s</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>v</ci>
    <ci>a</ci>
    <ci>l</ci>
    <ci>p</ci>
    <ci>r</ci>
    <ci>e</ci>
    <ci>f</ci>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   valprefs
  </annotation>
 </semantics>
</math>

 is a preference relation (transitive, irreflexive and asymmetric) on 

<math display="inline" id="Argumentation_framework:124">
 <semantics>
  <mrow>
   <mi>V</mi>
   <mo>×</mo>
   <mi>V</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>V</ci>
    <ci>V</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V\times V
  </annotation>
 </semantics>
</math>

.</p>

<p>In this framework, an argument 

<math display="inline" id="Argumentation_framework:125">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 defeats another argument 

<math display="inline" id="Argumentation_framework:126">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>

 if and only if</p>
<ul>
<li>

<math display="inline" id="Argumentation_framework:127">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 attacks 

<math display="inline" id="Argumentation_framework:128">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>

 in the "standard" meaning

<math display="block" id="Argumentation_framework:129">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>a</mi>
    <mo>,</mo>
    <mi>b</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∈</mo>
   <mi>R</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <interval closure="open">
     <ci>a</ci>
     <ci>b</ci>
    </interval>
    <ci>R</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (a,b)\in R
  </annotation>
 </semantics>
</math>

 ;</li>
<li>and 

<math display="inline" id="Argumentation_framework:130">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>v</mi>
     <mi>a</mi>
     <mi>l</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>b</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mi>v</mi>
     <mi>a</mi>
     <mi>l</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>a</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∉</mo>
   <mrow>
    <mi>v</mi>
    <mi>a</mi>
    <mi>l</mi>
    <mi>p</mi>
    <mi>r</mi>
    <mi>e</mi>
    <mi>f</mi>
    <mi>s</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <notin></notin>
    <interval closure="open">
     <apply>
      <times></times>
      <ci>v</ci>
      <ci>a</ci>
      <ci>l</ci>
      <ci>b</ci>
     </apply>
     <apply>
      <times></times>
      <ci>v</ci>
      <ci>a</ci>
      <ci>l</ci>
      <ci>a</ci>
     </apply>
    </interval>
    <apply>
     <times></times>
     <ci>v</ci>
     <ci>a</ci>
     <ci>l</ci>
     <ci>p</ci>
     <ci>r</ci>
     <ci>e</ci>
     <ci>f</ci>
     <ci>s</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (val(b),val(a))\not\in valprefs
  </annotation>
 </semantics>
</math>

, that is the value advanced by 

<math display="inline" id="Argumentation_framework:131">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>

 is not preferred to the one advanced by 

<math display="inline" id="Argumentation_framework:132">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

.</li>
</ul>

<p>One remarks that an attack succeeds if both arguments are associated to the same value, or if there is no preference between their respective values.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Knowledge_representation_and_reasoning" title="wikilink">Knowledge representation and reasoning</a></li>
<li><a class="uri" href="Argumentation" title="wikilink">Argumentation</a></li>
</ul>
<h2 id="notes">Notes</h2>
<references>
</references>
<h2 id="references">References</h2>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Artificial_intelligence" title="wikilink">Category:Artificial intelligence</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">See Dung (1995)<a href="#fnref1">↩</a></li>
<li id="fn2">See Besnard and Hunter (2001)<a href="#fnref2">↩</a></li>
<li id="fn3">see Bench-Capon (2002)<a href="#fnref3">↩</a></li>
<li id="fn4">see Caminada (2006)<a href="#fnref4">↩</a></li>
<li id="fn5">see Touretzky et al.<a href="#fnref5">↩</a></li>
<li id="fn6">see Gärdenfors (1988)<a href="#fnref6">↩</a></li>
<li id="fn7">see Oikarinen and Woltran (2001)<a href="#fnref7">↩</a></li>
<li id="fn8">the union of two systems represents here the system built from the union of the sets of arguments and the union of the attack relations<a href="#fnref8">↩</a></li>
</ol>
</section>
</body>
</html>
