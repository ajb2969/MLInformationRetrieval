<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="722">Numerical continuation</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Numerical continuation</h1>
<hr/>

<p><strong>Numerical continuation</strong> is a method of computing approximate solutions of a system of parameterized nonlinear equations,</p>

<p>

<math display="block" id="Numerical_continuation:0">
 <semantics>
  <mrow>
   <mrow>
    <mi>F</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>𝐮</mi>
     <mo>,</mo>
     <mi>λ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>F</ci>
     <interval closure="open">
      <ci>𝐮</ci>
      <ci>λ</ci>
     </interval>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F(\mathbf{u},\lambda)=0
  </annotation>
 </semantics>
</math>

</p>

<p>The <em>parameter</em> 

<math display="inline" id="Numerical_continuation:1">
 <semantics>
  <mi>λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda
  </annotation>
 </semantics>
</math>

 is usually a real <a href="scalar_(mathematics)" title="wikilink">scalar</a>, and the <em>solution</em> an <a href="n-tuple" title="wikilink"><em>n</em>-vector</a>. For a fixed <em>parameter value</em> 

<math display="inline" id="Numerical_continuation:2">
 <semantics>
  <mi>λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Numerical_continuation:3">
 <semantics>
  <mrow>
   <mi>F</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>∗</mo>
    <mo>,</mo>
    <mi>λ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>F</ci>
    <interval closure="open">
     <ci>normal-∗</ci>
     <ci>λ</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F(\ast,\lambda)
  </annotation>
 </semantics>
</math>

 maps <a href="Euclidean_n-space" title="wikilink">Euclidean n-space</a> into itself.</p>

<p>Often the original mapping 

<math display="inline" id="Numerical_continuation:4">
 <semantics>
  <mi>F</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>F</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F
  </annotation>
 </semantics>
</math>

 is from a <a href="Banach_space" title="wikilink">Banach space</a> into itself, and the <a href="Euclidean_n-space" title="wikilink">Euclidean n-space</a> is a finite-dimensional approximation to the Banach space.</p>

<p>A <a href="steady_state" title="wikilink">steady state</a>, or <a href="fixed_point_(mathematics)" title="wikilink">fixed point</a>, of a <a href="parameterized_family" title="wikilink">parameterized family</a> of <a href="flow_(mathematics)" title="wikilink">flows</a> or <a href="map_(mathematics)" title="wikilink">maps</a> are of this form, and by <a href="discretization" title="wikilink">discretizing</a> trajectories of a flow or iterating a map, <a href="periodic_orbit" title="wikilink">periodic orbits</a> and <a href="heteroclinic_orbit" title="wikilink">heteroclinic orbits</a> can also be posed as a solution of 

<math display="inline" id="Numerical_continuation:5">
 <semantics>
  <mrow>
   <mi>F</mi>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>F</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F=0
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="other-forms">Other forms</h2>

<p>In some nonlinear systems, parameters are explicit. In others they are implicit, and the system of nonlinear equations is written</p>

<p>

<math display="block" id="Numerical_continuation:6">
 <semantics>
  <mrow>
   <mrow>
    <mi>F</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>𝐮</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>F</ci>
     <ci>𝐮</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F(\mathbf{u})=0
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Numerical_continuation:7">
 <semantics>
  <mi>𝐮</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐮</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{u}
  </annotation>
 </semantics>
</math>

 is an <em>n</em>-vector, and its image 

<math display="inline" id="Numerical_continuation:8">
 <semantics>
  <mrow>
   <mi>F</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>𝐮</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>F</ci>
    <ci>𝐮</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F(\mathbf{u})
  </annotation>
 </semantics>
</math>

 is an <em>n-1</em> vector.</p>

<p>This formulation, without an explicit parameter space is not usually suitable for the formulations in the following sections, because they refer to parameterized autonomous nonlinear <a href="dynamical_systems" title="wikilink">dynamical systems</a> of the form:</p>

<p>

<math display="block" id="Numerical_continuation:9">
 <semantics>
  <mrow>
   <msup>
    <mi>𝐮</mi>
    <mo>′</mo>
   </msup>
   <mo>=</mo>
   <mrow>
    <mi>F</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>𝐮</mi>
     <mo>,</mo>
     <mi>λ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>𝐮</ci>
     <ci>normal-′</ci>
    </apply>
    <apply>
     <times></times>
     <ci>F</ci>
     <interval closure="open">
      <ci>𝐮</ci>
      <ci>λ</ci>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{u}^{\prime}=F(\mathbf{u},\lambda)
  </annotation>
 </semantics>
</math>

</p>

<p>However, in an algebraic system there is no distinction between unknowns 

<math display="inline" id="Numerical_continuation:10">
 <semantics>
  <mi>𝐮</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐮</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{u}
  </annotation>
 </semantics>
</math>

 and the parameters.</p>
<h2 id="periodic-motions">Periodic motions</h2>

<p>A <a href="periodic_motion" title="wikilink">periodic motion</a> is a closed curve in phase space. That is, for some <em>period</em> 

<math display="inline" id="Numerical_continuation:11">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

.</p>

<p>

<math display="block" id="Numerical_continuation:12">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>𝐮</mi>
     <mo>′</mo>
    </msup>
    <mo>=</mo>
    <mrow>
     <mi>F</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>𝐮</mi>
      <mo>,</mo>
      <mi>λ</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo rspace="4.2pt">,</mo>
   <mrow>
    <mrow>
     <mi>𝐮</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>0</mn>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>𝐮</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>T</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>𝐮</ci>
      <ci>normal-′</ci>
     </apply>
     <apply>
      <times></times>
      <ci>F</ci>
      <interval closure="open">
       <ci>𝐮</ci>
       <ci>λ</ci>
      </interval>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>𝐮</ci>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <times></times>
      <ci>𝐮</ci>
      <ci>T</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{u}^{\prime}=F(\mathbf{u},\lambda),\,\mathbf{u}(0)=\mathbf{u}(T)
  </annotation>
 </semantics>
</math>

</p>

<p>The textbook example of a periodic motion is the undamped <a class="uri" href="pendulum" title="wikilink">pendulum</a>.</p>

<p>If the <a href="phase_space" title="wikilink">phase space</a> is periodic in one or more coordinates, say 

<math display="inline" id="Numerical_continuation:13">
 <semantics>
  <mrow>
   <mrow>
    <mi>𝐮</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>𝐮</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>t</mi>
      <mo>+</mo>
      <mi mathvariant="normal">Ω</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>𝐮</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <times></times>
     <ci>𝐮</ci>
     <apply>
      <plus></plus>
      <ci>t</ci>
      <ci>normal-Ω</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{u}(t)=\mathbf{u}(t+\Omega)
  </annotation>
 </semantics>
</math>

, with 

<math display="inline" id="Numerical_continuation:14">
 <semantics>
  <mi mathvariant="normal">Ω</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Ω</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Omega
  </annotation>
 </semantics>
</math>

 a vector, then there is a second kind of periodic motions defined by</p>

<p>

<math display="block" id="Numerical_continuation:15">
 <semantics>
  <mrow>
   <msup>
    <mi>𝐮</mi>
    <mo>′</mo>
   </msup>
   <mo>=</mo>
   <mi>𝐅</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>𝐮</mi>
    <mo>,</mo>
    <mi>λ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo rspace="4.2pt">,</mo>
   <mi>𝐮</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>0</mn>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mi>𝐮</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>T</mi>
    <mo>+</mo>
    <mi>N</mi>
    <mo>.</mo>
    <mi mathvariant="normal">Ω</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>𝐮</ci>
     <ci>normal-′</ci>
    </apply>
    <eq></eq>
    <csymbol cd="unknown">F</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">u</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">λ</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-,</ci>
    <csymbol cd="unknown">u</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cn type="integer">0</cn>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">u</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">T</csymbol>
     <plus></plus>
     <csymbol cd="unknown">N</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">Ω</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{u}^{\prime}=\mathbf{F}(\mathbf{u},\lambda),\,\mathbf{u}(0)=\mathbf{u}(%
T+N.\Omega)
  </annotation>
 </semantics>
</math>

</p>

<p>Here 

<math display="inline" id="Numerical_continuation:16">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

 is a <a href="diagonal_matrix" title="wikilink">diagonal matrix</a> of integers that serves as an index of these periodic motions of the second kind.</p>
<center>

<p></p>
</center>

<p>The first step in writing an implicit system for a periodic motion is to move the period 

<math display="inline" id="Numerical_continuation:17">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

 from the boundary conditions to the <a href="Ordinary_differential_equation" title="wikilink">ODE</a>:</p>

<p>

<math display="block" id="Numerical_continuation:18">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msup>
      <mi>𝐮</mi>
      <mo>′</mo>
     </msup>
     <mo>=</mo>
     <mrow>
      <mi>T</mi>
      <mi>𝐅</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>𝐮</mi>
       <mo>,</mo>
       <mi>λ</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo rspace="4.2pt">,</mo>
    <mrow>
     <mrow>
      <mi>𝐮</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mn>0</mn>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>=</mo>
     <mrow>
      <mrow>
       <mi>𝐮</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mn>1</mn>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>+</mo>
      <mi>N</mi>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mi mathvariant="normal">Ω</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <csymbol cd="ambiguous">formulae-sequence</csymbol>
     <apply>
      <eq></eq>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>𝐮</ci>
       <ci>normal-′</ci>
      </apply>
      <apply>
       <times></times>
       <ci>T</ci>
       <ci>𝐅</ci>
       <interval closure="open">
        <ci>𝐮</ci>
        <ci>λ</ci>
       </interval>
      </apply>
     </apply>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <ci>𝐮</ci>
       <cn type="integer">0</cn>
      </apply>
      <apply>
       <plus></plus>
       <apply>
        <times></times>
        <ci>𝐮</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>N</ci>
      </apply>
     </apply>
    </apply>
    <ci>normal-Ω</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{u}^{\prime}=T\mathbf{F}(\mathbf{u},\lambda),\,\mathbf{u}(0)=\mathbf{u}%
(1)+N.\Omega
  </annotation>
 </semantics>
</math>

</p>

<p>The second step is to add an additional equation, a <em>phase constraint</em>, that can be thought of as determining the period. This is necessary because any solution of the above boundary value problem can be shifted in time by an arbitrary amount (time does not appear in the defining equations—the dynamical system is called autonomous).</p>

<p>There are several choices for the phase constraint. If 

<math display="inline" id="Numerical_continuation:19">
 <semantics>
  <mrow>
   <msub>
    <mi>𝐮</mi>
    <mn>0</mn>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝐮</ci>
     <cn type="integer">0</cn>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{u}_{0}(t)
  </annotation>
 </semantics>
</math>

 is a known periodic orbit at a parameter value 

<math display="inline" id="Numerical_continuation:20">
 <semantics>
  <msub>
   <mi>λ</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>λ</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda_{0}
  </annotation>
 </semantics>
</math>

 near 

<math display="inline" id="Numerical_continuation:21">
 <semantics>
  <mi>λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda
  </annotation>
 </semantics>
</math>

, then, Poincaré used</p>

<p>:<math> = 0</math></p>

<p>which states that 

<math display="inline" id="Numerical_continuation:22">
 <semantics>
  <mi>𝐮</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐮</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{u}
  </annotation>
 </semantics>
</math>

 lies in a plane which is orthogonal to the tangent vector of the closed curve. This plane is called a <em><a href="Poincaré_section" title="wikilink">Poincaré section</a></em>.</p>
<center>
<figure><b>(Figure)</b>
<figcaption>PoincareSection.gif</figcaption>
</figure>
</center>

<p>For a general problem a better phase constraint is an integral constraint introduced by Eusebius Doedel, which chooses the phase so that the distance between the known and unknown orbits is minimized:</p>

<p>

<math display="block" id="Numerical_continuation:23">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∫</mo>
     <mn>0</mn>
     <mn>1</mn>
    </msubsup>
    <mo><</mo>
    <mrow>
     <mrow>
      <mi>𝐮</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>-</mo>
     <mrow>
      <msub>
       <mi>𝐮</mi>
       <mn>0</mn>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mrow>
     <mi>𝐅</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>𝐮</mi>
        <mn>0</mn>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>t</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>,</mo>
      <msub>
       <mi>λ</mi>
       <mn>0</mn>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo rspace="4.2pt">></mo>
    <mrow>
     <mi>d</mi>
     <mi>t</mi>
    </mrow>
    <mo>=</mo>
    <mn>0</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <lt></lt>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <int></int>
       <cn type="integer">0</cn>
      </apply>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>𝐮</ci>
       <ci>t</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>𝐮</ci>
        <cn type="integer">0</cn>
       </apply>
       <ci>t</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <and></and>
     <apply>
      <gt></gt>
      <apply>
       <times></times>
       <ci>𝐅</ci>
       <interval closure="open">
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>𝐮</ci>
          <cn type="integer">0</cn>
         </apply>
         <ci>t</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>λ</ci>
         <cn type="integer">0</cn>
        </apply>
       </interval>
      </apply>
      <apply>
       <times></times>
       <ci>d</ci>
       <ci>t</ci>
      </apply>
     </apply>
     <apply>
      <eq></eq>
      <share href="#.cmml">
      </share>
      <cn type="integer">0</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \int_{0}^{1}<\mathbf{u}(t)-\mathbf{u}_{0}(t),\mathbf{F}(\mathbf{u}_{0}(t),%
\lambda_{0})>\,dt=0
  </annotation>
 </semantics>
</math>

</p>
<h2 id="homoclinic-and-heteroclinic-motions">Homoclinic and heteroclinic motions</h2>
<center>

<p></p>
</center>
<h2 id="definitions">Definitions</h2>
<h3 id="solution-component">Solution component</h3>

<p>A solution component 

<math display="inline" id="Numerical_continuation:24">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Γ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>𝐮</mi>
     <mn>0</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>λ</mi>
     <mn>0</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Γ</ci>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐮</ci>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>λ</ci>
      <cn type="integer">0</cn>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Gamma(\mathbf{u}_{0},\lambda_{0})
  </annotation>
 </semantics>
</math>

 of the nonlinear system 

<math display="inline" id="Numerical_continuation:25">
 <semantics>
  <mi>F</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>F</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F
  </annotation>
 </semantics>
</math>

 is a set of points 

<math display="inline" id="Numerical_continuation:26">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>𝐮</mi>
   <mo>,</mo>
   <mi>λ</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>𝐮</ci>
    <ci>λ</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\mathbf{u},\lambda)
  </annotation>
 </semantics>
</math>

 which satisfy 

<math display="inline" id="Numerical_continuation:27">
 <semantics>
  <mrow>
   <mrow>
    <mi>F</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>𝐮</mi>
     <mo>,</mo>
     <mi>λ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>F</ci>
     <interval closure="open">
      <ci>𝐮</ci>
      <ci>λ</ci>
     </interval>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F(\mathbf{u},\lambda)=0
  </annotation>
 </semantics>
</math>

 and are <em>connected</em> to the initial solution 

<math display="inline" id="Numerical_continuation:28">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msub>
    <mi>𝐮</mi>
    <mn>0</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>λ</mi>
    <mn>0</mn>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝐮</ci>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>λ</ci>
     <cn type="integer">0</cn>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\mathbf{u}_{0},\lambda_{0})
  </annotation>
 </semantics>
</math>

 by a path of solutions 

<math display="inline" id="Numerical_continuation:29">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi>𝐮</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>s</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>λ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>s</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <apply>
     <times></times>
     <ci>𝐮</ci>
     <ci>s</ci>
    </apply>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>s</ci>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\mathbf{u}(s),\lambda(s))
  </annotation>
 </semantics>
</math>

 for which 

<math display="inline" id="Numerical_continuation:30">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>𝐮</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mn>0</mn>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mi>λ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mn>0</mn>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>𝐮</mi>
      <mn>0</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>λ</mi>
      <mn>0</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo rspace="4.2pt">,</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>𝐮</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mn>1</mn>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mi>λ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mn>1</mn>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>𝐮</mi>
     <mo>,</mo>
     <mi>λ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <interval closure="open">
      <apply>
       <times></times>
       <ci>𝐮</ci>
       <cn type="integer">0</cn>
      </apply>
      <apply>
       <times></times>
       <ci>λ</ci>
       <cn type="integer">0</cn>
      </apply>
     </interval>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐮</ci>
       <cn type="integer">0</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>λ</ci>
       <cn type="integer">0</cn>
      </apply>
     </interval>
    </apply>
    <apply>
     <eq></eq>
     <interval closure="open">
      <apply>
       <times></times>
       <ci>𝐮</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <times></times>
       <ci>λ</ci>
       <cn type="integer">1</cn>
      </apply>
     </interval>
     <interval closure="open">
      <ci>𝐮</ci>
      <ci>λ</ci>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\mathbf{u}(0),\lambda(0))=(\mathbf{u}_{0},\lambda_{0}),\,(\mathbf{u}(1),%
\lambda(1))=(\mathbf{u},\lambda)
  </annotation>
 </semantics>
</math>

</p>

<p>and 

<math display="inline" id="Numerical_continuation:31">
 <semantics>
  <mrow>
   <mrow>
    <mi>F</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>𝐮</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>s</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mi>λ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>s</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>F</ci>
     <interval closure="open">
      <apply>
       <times></times>
       <ci>𝐮</ci>
       <ci>s</ci>
      </apply>
      <apply>
       <times></times>
       <ci>λ</ci>
       <ci>s</ci>
      </apply>
     </interval>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F(\mathbf{u}(s),\lambda(s))=0
  </annotation>
 </semantics>
</math>

.</p>
<center>
<figure><b>(Figure)</b>
<figcaption>Numerical Continuation components.png</figcaption>
</figure>
</center>
<center>

<p>This figure shows two solution components, one red and the other blue. Note that these two components may be connected outside the region of interest.</p>
</center>
<h3 id="numerical-continuation">Numerical continuation</h3>

<p>A numerical continuation is an algorithm which takes as input a system of parametrized nonlinear equations and an initial solution 

<math display="inline" id="Numerical_continuation:32">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msub>
    <mi>𝐮</mi>
    <mn>0</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>λ</mi>
    <mn>0</mn>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝐮</ci>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>λ</ci>
     <cn type="integer">0</cn>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\mathbf{u}_{0},\lambda_{0})
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Numerical_continuation:33">
 <semantics>
  <mrow>
   <mrow>
    <mi>F</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>𝐮</mi>
      <mn>0</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>λ</mi>
      <mn>0</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>F</ci>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐮</ci>
       <cn type="integer">0</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>λ</ci>
       <cn type="integer">0</cn>
      </apply>
     </interval>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F(\mathbf{u}_{0},\lambda_{0})=0
  </annotation>
 </semantics>
</math>

, and produces a set of points on the solution component 

<math display="inline" id="Numerical_continuation:34">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Γ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>𝐮</mi>
     <mn>0</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>λ</mi>
     <mn>0</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Γ</ci>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐮</ci>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>λ</ci>
      <cn type="integer">0</cn>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Gamma(\mathbf{u}_{0},\lambda_{0})
  </annotation>
 </semantics>
</math>

.</p>
<h3 id="regular-point">Regular point</h3>

<p>A regular point of 

<math display="inline" id="Numerical_continuation:35">
 <semantics>
  <mi>F</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>F</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F
  </annotation>
 </semantics>
</math>

 is a point 

<math display="inline" id="Numerical_continuation:36">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>𝐮</mi>
   <mo>,</mo>
   <mi>λ</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>𝐮</ci>
    <ci>λ</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\mathbf{u},\lambda)
  </annotation>
 </semantics>
</math>

 at which the <a href="Jacobian_matrix_and_determinant" title="wikilink">Jacobian</a> of 

<math display="inline" id="Numerical_continuation:37">
 <semantics>
  <mi>F</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>F</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F
  </annotation>
 </semantics>
</math>

 is full rank 

<math display="inline" id="Numerical_continuation:38">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>n</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (n)
  </annotation>
 </semantics>
</math>

.</p>

<p>Near a regular point the solution component is an isolated curve passing through the regular point (the <a href="implicit_function_theorem" title="wikilink">implicit function theorem</a>). In the figure above the point 

<math display="inline" id="Numerical_continuation:39">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msub>
    <mi>𝐮</mi>
    <mn>0</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>λ</mi>
    <mn>0</mn>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝐮</ci>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>λ</ci>
     <cn type="integer">0</cn>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\mathbf{u}_{0},\lambda_{0})
  </annotation>
 </semantics>
</math>

 is a regular point.</p>
<h3 id="singular-point">Singular point</h3>

<p>A singular point of 

<math display="inline" id="Numerical_continuation:40">
 <semantics>
  <mi>F</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>F</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F
  </annotation>
 </semantics>
</math>

 is a point 

<math display="inline" id="Numerical_continuation:41">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>𝐮</mi>
   <mo>,</mo>
   <mi>λ</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>𝐮</ci>
    <ci>λ</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\mathbf{u},\lambda)
  </annotation>
 </semantics>
</math>

 at which the <a href="Jacobian_matrix_and_determinant" title="wikilink">Jacobian</a> of F is not full rank.</p>

<p>Near a singular point the solution component may not be an isolated curve passing through the regular point. The local structure is determined by higher derivatives of 

<math display="inline" id="Numerical_continuation:42">
 <semantics>
  <mi>F</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>F</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F
  </annotation>
 </semantics>
</math>

. In the figure above the point where the two blue curves cross is a singular point.</p>

<p>In general solution components 

<math display="inline" id="Numerical_continuation:43">
 <semantics>
  <mi mathvariant="normal">Γ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Γ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Gamma
  </annotation>
 </semantics>
</math>

 are <a href="branched_curves" title="wikilink">branched curves</a>. The branch points are singular points. Finding the solution curves leaving a singular point is called branch switching, and uses techniques from <a href="bifurcation_theory" title="wikilink">bifurcation theory</a> (<a href="singularity_theory" title="wikilink">singularity theory</a>, <a href="catastrophe_theory" title="wikilink">catastrophe theory</a>).</p>

<p>For finite-dimensional systems (as defined above) the Lyapunov-Schmidt decomposition may be used to produce two systems to which the Implicit Function Theorem applies. The Lyapunov-Schmidt decomposition uses the restriction of the system to the complement of the null space of the Jacobian and the range of the Jacobian.</p>

<p>If the columns of the matrix 

<math display="inline" id="Numerical_continuation:44">
 <semantics>
  <mi mathvariant="normal">Φ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Φ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Phi
  </annotation>
 </semantics>
</math>

 are an orthonormal basis for the null space of 

<math display="inline" id="Numerical_continuation:45">
 <semantics>
  <mrow>
   <mi>J</mi>
   <mo>=</mo>
   <mrow>
    <mo>[</mo>
    <mtable>
     <mtr>
      <mtd columnalign="center">
       <msub>
        <mi>F</mi>
        <mi>x</mi>
       </msub>
      </mtd>
      <mtd columnalign="center">
       <msub>
        <mi>F</mi>
        <mi>λ</mi>
       </msub>
      </mtd>
     </mtr>
    </mtable>
    <mo rspace="4.2pt">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>J</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <matrix>
      <matrixrow>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>F</ci>
        <ci>x</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>F</ci>
        <ci>λ</ci>
       </apply>
      </matrixrow>
     </matrix>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   J=\left[\begin{array}[]{cc}F_{x}&F_{\lambda}\\
\end{array}\right]\,
  </annotation>
 </semantics>
</math>

 and the columns of the matrix 

<math display="inline" id="Numerical_continuation:46">
 <semantics>
  <mi mathvariant="normal">Ψ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Ψ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Psi
  </annotation>
 </semantics>
</math>

 are an orthonormal basis for the left null space of 

<math display="inline" id="Numerical_continuation:47">
 <semantics>
  <mi>J</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>J</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   J
  </annotation>
 </semantics>
</math>

, then the system 

<math display="inline" id="Numerical_continuation:48">
 <semantics>
  <mrow>
   <mrow>
    <mi>F</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>λ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>F</ci>
     <interval closure="open">
      <ci>x</ci>
      <ci>λ</ci>
     </interval>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F(x,\lambda)=0
  </annotation>
 </semantics>
</math>

 can be rewritten as 

<math display="inline" id="Numerical_continuation:49">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>[</mo>
     <mtable>
      <mtr>
       <mtd columnalign="left">
        <mrow>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <mi>I</mi>
           <mo>-</mo>
           <mrow>
            <mi mathvariant="normal">Ψ</mi>
            <msup>
             <mi mathvariant="normal">Ψ</mi>
             <mi>T</mi>
            </msup>
           </mrow>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
         <mi>F</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <mi>x</mi>
           <mo>+</mo>
           <mrow>
            <mi mathvariant="normal">Φ</mi>
            <mi>ξ</mi>
           </mrow>
           <mo>+</mo>
           <mi>η</mi>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="left">
        <mrow>
         <msup>
          <mi mathvariant="normal">Ψ</mi>
          <mi>T</mi>
         </msup>
         <mi>F</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <mi>x</mi>
           <mo>+</mo>
           <mrow>
            <mi mathvariant="normal">Φ</mi>
            <mi>ξ</mi>
           </mrow>
           <mo>+</mo>
           <mi>η</mi>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mtd>
      </mtr>
     </mtable>
     <mo>]</mo>
    </mrow>
    <mo>=</mo>
    <mn>0</mn>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <matrix>
      <matrixrow>
       <apply>
        <times></times>
        <apply>
         <minus></minus>
         <ci>I</ci>
         <apply>
          <times></times>
          <ci>normal-Ψ</ci>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>normal-Ψ</ci>
           <ci>T</ci>
          </apply>
         </apply>
        </apply>
        <ci>F</ci>
        <apply>
         <plus></plus>
         <ci>x</ci>
         <apply>
          <times></times>
          <ci>normal-Φ</ci>
          <ci>ξ</ci>
         </apply>
         <ci>η</ci>
        </apply>
       </apply>
      </matrixrow>
      <matrixrow>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>normal-Ψ</ci>
         <ci>T</ci>
        </apply>
        <ci>F</ci>
        <apply>
         <plus></plus>
         <ci>x</ci>
         <apply>
          <times></times>
          <ci>normal-Φ</ci>
          <ci>ξ</ci>
         </apply>
         <ci>η</ci>
        </apply>
       </apply>
      </matrixrow>
     </matrix>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left[\begin{array}[]{l}(I-\Psi\Psi^{T})F(x+\Phi\xi+\eta)\\
\Psi^{T}F(x+\Phi\xi+\eta)\\
\end{array}\right]=0,
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Numerical_continuation:50">
 <semantics>
  <mi>η</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>η</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \eta
  </annotation>
 </semantics>
</math>

 is in the complement of the null space of 

<math display="inline" id="Numerical_continuation:51">
 <semantics>
  <mi>J</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>J</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   J
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Numerical_continuation:52">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mrow>
     <mpadded width="+1.7pt">
      <msup>
       <mi mathvariant="normal">Φ</mi>
       <mi>T</mi>
      </msup>
     </mpadded>
     <mi>η</mi>
    </mrow>
    <mo>=</mo>
    <mn>0</mn>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>normal-Φ</ci>
      <ci>T</ci>
     </apply>
     <ci>η</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\Phi^{T}\,\eta=0)
  </annotation>
 </semantics>
</math>

.</p>

<p>In the first equation, which is parametrized by the null space of the Jacobian (

<math display="inline" id="Numerical_continuation:53">
 <semantics>
  <mi>ξ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ξ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \xi
  </annotation>
 </semantics>
</math>

), the Jacobian with respect to 

<math display="inline" id="Numerical_continuation:54">
 <semantics>
  <mi>η</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>η</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \eta
  </annotation>
 </semantics>
</math>

 is non-singular. So the implicit function theorem states that there is a mapping 

<math display="inline" id="Numerical_continuation:55">
 <semantics>
  <mrow>
   <mi>η</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>ξ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>η</ci>
    <ci>ξ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \eta(\xi)
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Numerical_continuation:56">
 <semantics>
  <mrow>
   <mrow>
    <mi>η</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>0</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>η</ci>
     <cn type="integer">0</cn>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \eta(0)=0
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Numerical_continuation:57">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>I</mi>
    <mo>-</mo>
    <mi mathvariant="normal">Ψ</mi>
    <msup>
     <mi mathvariant="normal">Ψ</mi>
     <mi>T</mi>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi>F</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>+</mo>
    <mi mathvariant="normal">Φ</mi>
    <mi>ξ</mi>
    <mo>+</mo>
    <mi>η</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>ξ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">I</csymbol>
     <minus></minus>
     <csymbol cd="unknown">Ψ</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>normal-Ψ</ci>
      <ci>T</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">F</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <plus></plus>
     <csymbol cd="unknown">Φ</csymbol>
     <csymbol cd="unknown">ξ</csymbol>
     <plus></plus>
     <csymbol cd="unknown">η</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">ξ</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <cn type="integer">0</cn>
    <ci>normal-)</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (I-\Psi\Psi^{T})F(x+\Phi\xi+\eta(\xi))=0)
  </annotation>
 </semantics>
</math>

. The second equation (with 

<math display="inline" id="Numerical_continuation:58">
 <semantics>
  <mrow>
   <mi>η</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>ξ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>η</ci>
    <ci>ξ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \eta(\xi)
  </annotation>
 </semantics>
</math>

 substituted) is called the bifurcation equation (though it may be a system of equations).</p>

<p>The bifurcation equation has a Taylor expansion which lacks the constant and linear terms. By scaling the equations and the null space of the Jacobian of the original system a system can be found with non-singular Jacobian. The constant term in the Taylor series of the scaled bifurcation equation is called the algebraic bifurcation equation, and the implicit function theorem applied the bifurcation equations states that for each isolated solution of the algebraic bifurcation equation there is a branch of solutions of the original problem which passes through the singular point.</p>

<p>Another type of singular point is a <a href="turning_point_bifurcation" title="wikilink">turning point bifurcation</a>, or <a href="saddle-node_bifurcation" title="wikilink">saddle-node bifurcation</a>, where the direction of the parameter 

<math display="inline" id="Numerical_continuation:59">
 <semantics>
  <mi>λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda
  </annotation>
 </semantics>
</math>

 reverses as the curve is followed. The red curve in the figure above illustrates a turning point.</p>
<h2 id="particular-algorithms">Particular algorithms</h2>
<h3 id="natural-parameter-continuation">Natural parameter continuation</h3>

<p>Most methods of solution of nonlinear systems of equations are iterative methods. For a particular parameter value 

<math display="inline" id="Numerical_continuation:60">
 <semantics>
  <msub>
   <mi>λ</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>λ</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda_{0}
  </annotation>
 </semantics>
</math>

 a mapping is repeatedly applied to an initial guess 

<math display="inline" id="Numerical_continuation:61">
 <semantics>
  <msub>
   <mi>𝐮</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝐮</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{u}_{0}
  </annotation>
 </semantics>
</math>

. If the method converges, and is consistent, then in the limit the iteration approaches a solution of 

<math display="inline" id="Numerical_continuation:62">
 <semantics>
  <mrow>
   <mrow>
    <mi>F</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>𝐮</mi>
     <mo>,</mo>
     <msub>
      <mi>λ</mi>
      <mn>0</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>F</ci>
     <interval closure="open">
      <ci>𝐮</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>λ</ci>
       <cn type="integer">0</cn>
      </apply>
     </interval>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F(\mathbf{u},\lambda_{0})=0
  </annotation>
 </semantics>
</math>

.</p>

<p><em>Natural parameter continuation</em> is a very simple adaptation of the iterative solver to a parametrized problem. The solution at one value of 

<math display="inline" id="Numerical_continuation:63">
 <semantics>
  <mi>λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda
  </annotation>
 </semantics>
</math>

 is used as the initial guess for the solution at 

<math display="inline" id="Numerical_continuation:64">
 <semantics>
  <mrow>
   <mi>λ</mi>
   <mo>+</mo>
   <mrow>
    <mi mathvariant="normal">Δ</mi>
    <mi>λ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>λ</ci>
    <apply>
     <times></times>
     <ci>normal-Δ</ci>
     <ci>λ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda+\Delta\lambda
  </annotation>
 </semantics>
</math>

. With 

<math display="inline" id="Numerical_continuation:65">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Δ</mi>
   <mi>λ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Δ</ci>
    <ci>λ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta\lambda
  </annotation>
 </semantics>
</math>

 sufficiently small the iteration applied to the initial guess should converge.</p>
<center>
<figure><b>(Figure)</b>
<figcaption>NaturalParameter.gif</figcaption>
</figure>
</center>

<p>One advantage of natural parameter continuation is that is uses the solution method for the problem as a black box. All that is required is that an initial solution can be given (some solvers used to always start at a fixed initial guess). There has been a lot of work in the area of large scale continuation on applying more sophisticated algorithms to black box solvers. (see e.g. LOCA).</p>

<p>However, natural parameter continuation fails at turning points, where the branch of solutions turns round. So for problems with turning points, a more sophisticated method such as pseudo-arclength continuation must be used (see below).</p>
<h3 id="simplicial-or-piecewise-linear-continuation">Simplicial or piecewise linear continuation</h3>

<p>Simplicial Continuation, or Piecewise Linear Continuation (Allgower and Georg) is based on three basic results.</p>

<p>The first is</p>
<center>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>If F(x) maps IR^n into IR^(n-1), there is a unique linear interpolant on an (n-1)-dimensional <a class="uri" href="simplex" title="wikilink">simplex</a> which agrees with the function values at the vertices of the simplex.</p></td>
</tr>
</tbody>
</table>
</center>

<p>The second result is:</p>
<center>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>An (n-1)-dimensional simplex can be tested to determine if the unique linear interpolant takes on the value 0 inside the simplex.</p></td>
</tr>
</tbody>
</table>
</center>

<p>Please see the article on <a href="piecewise_linear_continuation" title="wikilink">piecewise linear continuation</a> for details.</p>

<p>With these two operations this continuation algorithm is easy to state (although of course an efficient implementation requires a more sophisticated approach. See [B1]). An initial simplex is assumed to be given, from a reference simplicial decomposition of IR^n. The initial simplex must have at least one face which contains a zero of the unique linear interpolant on that face. The other faces of the simplex are then tested, and typically there will be one additional face with an interior zero. The initial simplex is then replaced by the simplex which lies across either face containing zero, and the process is repeated.<br/>
</p>
<center>
<figure><b>(Figure)</b>
<figcaption>Simplicial.gif</figcaption>
</figure>
</center>

<p>References: Allgower and Georg [B1] provides a crisp, clear description of the algotihm.</p>
<h3 id="pseudo-arclength-continuation">Pseudo-arclength continuation</h3>

<p>This method is based on the observation that the "ideal" parameterization of a curve is arclength. Pseudo-arclength is an approximation of the arclength in the tangent space of the curve. The resulting modified natural continuation method makes a step in pseudo-arclength (rather than 

<math display="inline" id="Numerical_continuation:66">
 <semantics>
  <mi>λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda
  </annotation>
 </semantics>
</math>

). The iterative solver is required to find a point at the given pseudo-arclength, which requires appending an additional constraint (the pseudo-arclength constraint) to the n by n+1 Jacobian. It produces a square Jacobian, and if the stepsize is sufficiently small the modified Jacobian is full rank.</p>

<p>Pseudo-arclength continuation was independently developed by Edward Riks and Gerald Wempner for finite element applications in the late 1960s, and published in journals in the early 1970s by H.B. Keller. A detailed account of these early developments is provided in the textbook by M. A. Crisfield: Nonlinear Finite Element Analysis of Solids and Structures, Vol 1: Basic Concepts, Wiley, 1991. Crisfield was one of the most active developers of this class of methods, which are by now standard procedures of commercial nonlinear finite element programs.</p>
<center>
<figure><b>(Figure)</b>
<figcaption>PseudoArclength.gif</figcaption>
</figure>
</center>

<p>The algorithm is a predictor-corrector method. The prediction step finds the point (in IR^(n+1) ) which is a step 

<math display="inline" id="Numerical_continuation:67">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Δ</mi>
   <mi>s</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Δ</ci>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta s
  </annotation>
 </semantics>
</math>

 along the tangent vector at the current pointer. The corrector is usually Newton's method, or some variant, to solve the nonlinear system</p>
<center>

<p>

<math display="inline" id="Numerical_continuation:68">
 <semantics>
  <mpadded width="+1.7pt">
   <mtable>
    <mtr>
     <mtd columnalign="left">
      <mrow>
       <mrow>
        <mi>F</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>u</mi>
         <mo>,</mo>
         <mi>λ</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>=</mo>
       <mn>0</mn>
      </mrow>
     </mtd>
    </mtr>
    <mtr>
     <mtd columnalign="left">
      <mrow>
       <mrow>
        <mrow>
         <msubsup>
          <mover accent="true">
           <mi>u</mi>
           <mo>˙</mo>
          </mover>
          <mn>0</mn>
          <mo>*</mo>
         </msubsup>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <mi>u</mi>
           <mo>-</mo>
           <msub>
            <mi>u</mi>
            <mn>0</mn>
           </msub>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>+</mo>
        <mrow>
         <msub>
          <mover accent="true">
           <mi>λ</mi>
           <mo>˙</mo>
          </mover>
          <mn>0</mn>
         </msub>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <mi>λ</mi>
           <mo>-</mo>
           <msub>
            <mi>λ</mi>
            <mn>0</mn>
           </msub>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
       <mo>=</mo>
       <mrow>
        <mi mathvariant="normal">Δ</mi>
        <mi>s</mi>
       </mrow>
      </mrow>
     </mtd>
    </mtr>
   </mtable>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <ci>F</ci>
       <interval closure="open">
        <ci>u</ci>
        <ci>λ</ci>
       </interval>
      </apply>
      <cn type="integer">0</cn>
     </apply>
    </matrixrow>
    <matrixrow>
     <apply>
      <eq></eq>
      <apply>
       <plus></plus>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <ci>normal-˙</ci>
           <ci>u</ci>
          </apply>
          <times></times>
         </apply>
         <cn type="integer">0</cn>
        </apply>
        <apply>
         <minus></minus>
         <ci>u</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>u</ci>
          <cn type="integer">0</cn>
         </apply>
        </apply>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <apply>
          <ci>normal-˙</ci>
          <ci>λ</ci>
         </apply>
         <cn type="integer">0</cn>
        </apply>
        <apply>
         <minus></minus>
         <ci>λ</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>λ</ci>
          <cn type="integer">0</cn>
         </apply>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>normal-Δ</ci>
       <ci>s</ci>
      </apply>
     </apply>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{array}[]{l}F(u,\lambda)=0\\
\dot{u}^{*}_{0}(u-u_{0})+\dot{\lambda}_{0}(\lambda-\lambda_{0})=\Delta s\\
\end{array}\,
  </annotation>
 </semantics>
</math>

</p>
</center>

<p>where 

<math display="inline" id="Numerical_continuation:69">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msub>
    <mover accent="true">
     <mi>u</mi>
     <mo>˙</mo>
    </mover>
    <mn>0</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mover accent="true">
     <mi>λ</mi>
     <mo>˙</mo>
    </mover>
    <mn>0</mn>
   </msub>
   <mo rspace="4.2pt" stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <ci>normal-˙</ci>
      <ci>u</ci>
     </apply>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <ci>normal-˙</ci>
      <ci>λ</ci>
     </apply>
     <cn type="integer">0</cn>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\dot{u}_{0},\dot{\lambda}_{0})\,
  </annotation>
 </semantics>
</math>

 is the tangent vector at 

<math display="inline" id="Numerical_continuation:70">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msub>
    <mi>u</mi>
    <mn>0</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>λ</mi>
    <mn>0</mn>
   </msub>
   <mo rspace="4.2pt" stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>u</ci>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>λ</ci>
     <cn type="integer">0</cn>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (u_{0},\lambda_{0})\,
  </annotation>
 </semantics>
</math>

. The Jacobian of this system is the bordered matrix</p>
<center>

<p>

<math display="inline" id="Numerical_continuation:71">
 <semantics>
  <mrow>
   <mo>[</mo>
   <mtable>
    <mtr>
     <mtd columnalign="center">
      <msub>
       <mi>F</mi>
       <mi>u</mi>
      </msub>
     </mtd>
     <mtd columnalign="center">
      <msub>
       <mi>F</mi>
       <mi>λ</mi>
      </msub>
     </mtd>
    </mtr>
    <mtr>
     <mtd columnalign="center">
      <msup>
       <mover accent="true">
        <mi>u</mi>
        <mo>˙</mo>
       </mover>
       <mo>*</mo>
      </msup>
     </mtd>
     <mtd columnalign="center">
      <mover accent="true">
       <mi>λ</mi>
       <mo>˙</mo>
      </mover>
     </mtd>
    </mtr>
   </mtable>
   <mo rspace="4.2pt">]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">delimited-[]</csymbol>
    <matrix>
     <matrixrow>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>F</ci>
       <ci>u</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>F</ci>
       <ci>λ</ci>
      </apply>
     </matrixrow>
     <matrixrow>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <ci>normal-˙</ci>
        <ci>u</ci>
       </apply>
       <times></times>
      </apply>
      <apply>
       <ci>normal-˙</ci>
       <ci>λ</ci>
      </apply>
     </matrixrow>
    </matrix>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left[\begin{array}[]{cc}F_{u}&F_{\lambda}\\
\dot{u}^{*}&\dot{\lambda}\\
\end{array}\right]\,
  </annotation>
 </semantics>
</math>

</p>
</center>

<p>At regular points, where the unmodified Jacobian is full rank, the tangent vector spans the null space of the top row of this new Jacobian. Appending the tangent vector as the last row can be seen as determining the coefficient of the null vector in the general solution of the Newton system (particular solution plus an arbitrary multiple of the null vector).</p>
<h3 id="gaussnewton-continuation">Gauss–Newton continuation</h3>

<p>This method is a variant of pseudo-arclength continuation. Instead of using the tangent at the initial point in the arclength constraint, the tangent at the current solution is used. This is equivalent to using the pseudo-inverse of the Jacobian in Newton's method, and allows longer steps to be made. [B17]</p>
<h2 id="continuation-in-more-than-one-parameter">Continuation in more than one parameter</h2>

<p>The parameter 

<math display="inline" id="Numerical_continuation:72">
 <semantics>
  <mi>λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda
  </annotation>
 </semantics>
</math>

 in the algorithms described above is a real scalar. Most physical and design problems generally have many more than one parameter. Higher-dimensional continuation refers to the case when 

<math display="inline" id="Numerical_continuation:73">
 <semantics>
  <mi>λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda
  </annotation>
 </semantics>
</math>

 is a k-vector.</p>

<p>The same terminology applies. A regular solution is a solution at which the Jacobian is full rank 

<math display="inline" id="Numerical_continuation:74">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>n</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (n)
  </annotation>
 </semantics>
</math>

. A singular solution is a solution at which the Jacobian is less than full rank.</p>

<p>A regular solution lies on a k-dimensional surface, which can be parameterized by a point in the tangent space (the null space of the Jacobian). This is again a straightforward application of the Implicit Function Theorem.</p>
<h2 id="applications-of-numerical-continuation-techniques">Applications of numerical continuation techniques</h2>

<p>Numerical continuation techniques have found a great degree of acceptance in the study of chaotic dynamical systems and various other systems which belong to the realm of <a href="catastrophe_theory" title="wikilink">catastrophe theory</a>. The reason for such usage stems from the fact that various non-linear dynamical systems behave in a deterministic and predictable manner within a range of parameters which are included in the equations of the system. However, for a certain parameter value the system starts behaving chaotically and hence it become necessary to follow the parameter in order to be able to decipher the occurrences of when the system starts being non-predictable, and what exactly (theoretically) makes the system become unstable.</p>

<p>Analysis of parameter continuation can lead to more insights about stable/critical point bifurcations. Study of saddle-node, transcritical, pitch-fork, period doubling, Hopf, secondary Hopf (Neimark) bifurcations of stable solutions allows for a theoretical discussion of the circumstances and occurrences which arise at the critical points. Parameter continuation also gives a more dependable system to analyze a dynamical system as it is more stable than more interactive, time-stepped numerical solutions. Especially in cases where the dynamical system is prone to blow-up at certain parameter values (or combination of values for multiple parameters).</p>

<p>It is extremely insightful as to the presence of stable solutions (attracting or repelling) in the study of <a class="uri" href="Nonlinear" title="wikilink">Nonlinear</a> <a href="Partial_Differential_Equations" title="wikilink">Partial Differential Equations</a> where times stepping in the form of the Crank Nicolson algorithm is extremely time consuming as well as unstable in cases of nonlinear growth of the dependent variables in the system. The study of turbulence is another field where the Numerical Continuation techniques have been used to study the advent of <a class="uri" href="turbulence" title="wikilink">turbulence</a> in a system starting at low Reynolds numbers. Also, research using these techniques has provided the possibility of finding stable manifolds and bifurcations to invariant-tori in the case of the <a href="restricted_three_body_problem" title="wikilink">restricted three body problem</a> in Newtonian gravity and have also given interesting and deep insights into the behaviour of systems such as the <a href="Lorenz_equations" title="wikilink">Lorenz equations</a>.</p>
<h2 id="software">Software</h2>

<p>(Under Construction) See also The SIAM Activity Group on Dynamical Systems' list <a href="http://www.dynamicalsystems.org/sw/sw/"></a><a class="uri" href="http://www.dynamicalsystems.org/sw/sw/">http://www.dynamicalsystems.org/sw/sw/</a></p>
<ul>
<li>AUTO: Computation of the solutions of Two Point Boundary Value Problems (TPBVPs) with integral constraints. <a href="https://sourceforge.net/projects/auto-07p/"></a><a class="uri" href="https://sourceforge.net/projects/auto-07p/">https://sourceforge.net/projects/auto-07p/</a> Available on SourceForge.</li>
<li>HOMCONT: Computation of homoclinic and heteroclinic orbits. Included in AUTO</li>
<li>MATCONT: Matlab toolbox for numerical continuation and bifurcation <a href="http://www.matcont.ugent.be/">1</a></li>
<li>DDEBIFTOOL: Computation of solutions of Delay Differential Equations. A MATLAB package. Available from the K. U. Leuven <a href="http://www.cs.kuleuven.be/cwis/research/twr/research/software/delay/ddebiftool.shtml">Available from K. U. Leuven</a></li>
<li>PyCont: A Python toolbox for numerical continuation and bifurcation. Native python algorithms for fixed point continuation, sophisticated interface to AUTO for other types of problem. Included as part of <a href="http://pydstool.sourceforge.net">PyDSTool</a></li>
<li>CANDYS/QA: <a href="http://www.agnld.uni-potsdam.de/~wolfgang/ca-ov.html">Available from the Universität Potsdam</a> [A16]</li>
<li>MANPAK: <a href="http://netlib.org/contin/manpak/">Available from Netlib</a> [A15]</li>
<li>PDDE-CONT: <a href="http://seis.bris.ac.uk/~rs1909/pdde/"></a><a class="uri" href="http://seis.bris.ac.uk/~rs1909/pdde/">http://seis.bris.ac.uk/~rs1909/pdde/</a></li>
<li>multifario: <a href="http://multifario.sourceforge.net/"></a><a class="uri" href="http://multifario.sourceforge.net/">http://multifario.sourceforge.net/</a></li>
<li>LOCA: <a href="http://trilinos.sandia.gov/packages/nox/"></a><a class="uri" href="http://trilinos.sandia.gov/packages/nox/">http://trilinos.sandia.gov/packages/nox/</a></li>
<li>ENTWIFE: <a href="http://www.sercoassurance.com/entwife/"></a><a class="uri" href="http://www.sercoassurance.com/entwife/">http://www.sercoassurance.com/entwife/</a></li>
<li>DSTool</li>
<li>GAIO</li>
<li>OSCILL8: Oscill8 is a dynamical systems tool that allows a user to explore high-dimensional parameter space of nonlinear ODEs using bifurcation analytic techniques. <a href="http://sourceforge.net/projects/oscill8">Available from SourceForge</a>.</li>
</ul>
<h2 id="examples">Examples</h2>

<p>This problem, of finding the points which <em>F</em> maps into the origin appears in <a href="computer_graphics" title="wikilink">computer graphics</a> as the problems of drawing <a href="contour_maps" title="wikilink">contour maps</a> (n=2), or <a class="uri" href="isosurface" title="wikilink">isosurface</a>(n=3). The contour with value <em>h</em> is the set of all solution components of <em>F-h=0</em></p>
<h2 id="references">References</h2>
<h3 id="books">Books</h3>

<p>[B1] "<em>Introduction to Numerical Continuation Methods</em>", Eugene L. Allgower and Kurt Georg, SIAM Classics in Applied Mathematics 45. 2003.</p>

<p>[B2] "<em>Numerical Methods for Bifurcations of Dynamical Equilibria</em>", Willy J. F. Govaerts, SIAM 2000.</p>

<p>[B3] "<em>Lyapunov-Schmidt Methods in Nonlinear Analysis and Applications</em>", Nikolay Sidorov, Boris Loginov, Aleksandr Sinitsyn, and Michail Falaleev, Kluwer Academic Publishers, 2002.</p>

<p>[B4] "<em>Methods of Bifurcation Theory</em>", Shui-Nee Chow and Jack K. Hale, Springer-Verlag 1982.</p>

<p>[B5] "<em>Elements of Applied Bifurcation Theory</em>", Yuri A. Kunetsov, Springer-Verlag Applied Mathematical Sciences 112, 1995.</p>

<p>[B6] "Nonlinear Oscillations, Dynamical Systems, and Bifurcations of Vector Fields", <a href="John_Guckenheimer" title="wikilink">John Guckenheimer</a> and <a href="Philip_Holmes" title="wikilink">Philip Holmes</a>, Springer-Verlag Applied Mathematical Sciences 42, 1983.</p>

<p>[B7] "<em>Elementary Stability and Bifurcation Theory</em>", Gerard Iooss and Daniel D. Joseph, Springer-Verlag Undergraduate Texts in Mathematics, 1980.</p>

<p>[B8] "<em>Singularity Theory and an Introduction to Catastrophe Theory</em>", Yung-Chen Lu, Springer-Verlag, 1976.</p>

<p>[B9] "<em>Global Bifurcations and Chaos, Analytic Methods</em>", S. Wiggins, Springer-Verlag Applied Mathematical Sciences 73, 1988.</p>

<p>[B10] "<em>Singularities and Groups in Bifurcation Theory, volume I</em>", <a href="Marty_Golubitsky" title="wikilink">Martin Golubitsky</a> and David G. Schaeffer, Springer-Verlag Applied Mathematical Sciences 51, 1985.</p>

<p>[B11] "<em>Singularities and Groups in Bifurcation Theory, volume II</em>", <a href="Marty_Golubitsky" title="wikilink">Martin Golubitsky</a>, Ian Stewart and David G. Schaeffer, Springer-Verlag Applied Mathematical Sciences 69, 1988.</p>

<p>[B12] "<em>Solving Polynomial Systems Using Continuation for Engineering and Scientific Problems</em>", Alexander Morgan, Prentice-Hall, Englewood Cliffs, N.J. 1987.</p>

<p>[B13] "<em>Pathways to Solutions, Fixed Points and Equilibria</em>", C. B. Garcia and W. I. Zangwill, Prentice-Hall, 1981.</p>

<p>[B14] "<em>The Implicit Function Theorem: History, Theory and Applications</em>", Steven G. Krantz and <a href="Harold_R._Parks" title="wikilink">Harold R. Parks</a>, Birkhauser, 2002.</p>

<p>[B15] "<em>Nonlinear Functional Analysis</em>", J. T. Schwartz, Gordon and Breach Science Publishers, Notes on Mathematics and its Applications, 1969.</p>

<p>[B16] "<em>Topics in Nonlinear Functional Analysis</em>", Louis Nirenberg (notes by Ralph A. Artino), AMS Courant Lecture Notes in Mathematics 6, 1974.</p>

<p>[B17] "<em>Newton Methods for Nonlinear Problems -- Affine Invariance and Adaptive Algorithms</em>", P. Deuflhard, Series Computational Mathematics 35, Springer, 2006.</p>
<h3 id="journal-articles">Journal articles</h3>

<p>[A1] "<em>An Algorithm for Piecewise Linear Approximation of Implicitly Defined Two-Dimensional Surfaces</em>", Eugene L. Allgower and Stefan Gnutzmann, SIAM Journal on Numerical Analysis, Volume 24, Number 2, 452—469, 1987.</p>

<p>[A2] "<em>Simplicial and Continuation Methods for Approximations, Fixed Points and Solutions to Systems of Equations</em>", E. L. Allgower and K. Georg, SIAM Review, Volume 22, 28—85, 1980.</p>

<p>[A3] "<em>An Algorithm for Piecewise-Linear Approximation of an Implicitly Defined Manifold</em>", Eugene L. Allgower and Phillip H. Schmidt, SIAM Journal on Numerical Analysis, Volume 22, Number 2, 322—346, April 1985.</p>

<p>[A4] "<em>Contour Tracing by Piecewise Linear Approximations</em>", <a href="David_P._Dobkin" title="wikilink">David P. Dobkin</a>, Silvio V. F. Levy, <a href="William_Thurston" title="wikilink">William P. Thurston</a> and Allan R. Wilks, ACM Transactions on Graphics, 9(4) 389-423, 1990.</p>

<p>[A5] "<em>Numerical Solution of Bifurcation and Nonlinear Eigenvalue Problems</em>", H. B. Keller, in "Applications of Bifurcation Theory", P. Rabinowitz ed., Academic Press, 1977.</p>

<p>[A6] "<em>A Locally Parameterized Continuation Process</em>", W.C. Rheinboldt and J.V. Burkardt, ACM Transactions on Mathematical Software, Volume 9, 236—246, 1983.</p>

<p>[A7] "<em>Nonlinear Numerics</em>" E. Doedel, <a href="International_Journal_of_Bifurcation_and_Chaos" title="wikilink">International Journal of Bifurcation and Chaos</a>, 7(9):2127-2143, 1997.</p>

<p>[A8] "<em>Nonlinear Computation</em>", R. Seydel, <a href="International_Journal_of_Bifurcation_and_Chaos" title="wikilink">International Journal of Bifurcation and Chaos</a>, 7(9):2105-2126, 1997.</p>

<p>[A9] "<em>On a Moving Frame Algorithm and the Triangulation of Equilibrium Manifolds</em>", W.C. Rheinboldt, In T. Kuper, R. Seydel, and H. Troger eds. "ISNM79: Bifurcation: Analysis, Algorithms, Applications", pages 256-267. Birkhauser, 1987.</p>

<p>[A10] "<em>On the Computation of Multi-Dimensional Solution Manifolds of Parameterized Equations</em>", W.C. Rheinboldt, Numerishe Mathematik, 53, 1988, pages 165-181.</p>

<p>[A11] "<em>On the Simplicial Approximation of Implicitly Defined Two-Dimensional Manifolds</em>", M. L. Brodzik and W.C. Rheinboldt, Computers and Mathematics with Applications, 28(9): 9-21, 1994.</p>

<p>[A12] "<em>The Computation of Simplicial Approximations of Implicitly Defined p-Manifolds</em>", M. L. Brodzik, Computers and Mathematics with Applications, 36(6):93-113, 1998.</p>

<p>[A13] "<em>New Algorithm for Two-Dimensional Numerical Continuation</em>", R. Melville and D. S. Mackey, Computers and Mathematics with Applications, 30(1):31-46, 1995.</p>

<p>[A14] "<em>Multiple Parameter Continuation: Computing Implicitly Defined k-manifolds</em>", M. E. Henderson, IJBC 12[3]:451-76, 2003.</p>

<p>[A15] "<em>MANPACK: a set of algorithms for computations on implicitly defined manifolds</em>", W. C. Rheinboldt, Comput. Math. Applic. 27 pages 15–9, 1996.</p>

<p>[A16] "<em>CANDYS/QA - A Software System For Qualitative Analysis Of Nonlinear Dynamical Systems</em>", Feudel, U. and W. Jansen, Int. J. Bifurcation and Chaos, vol. 2 no. 4, pp. 773–794, World Scientific, 1992.</p>

<p>"</p>

<p><a href="Category:Numerical_analysis" title="wikilink">Category:Numerical analysis</a> <a href="Category:Dynamical_systems" title="wikilink">Category:Dynamical systems</a></p>
</body>
</html>
