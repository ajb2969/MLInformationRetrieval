<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1027">Montgomery modular multiplication</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Montgomery modular multiplication</h1>
<hr/>

<p>In modular arithmetic computation, <strong>Montgomery modular multiplication</strong>, more commonly referred to as <strong>Montgomery multiplication</strong>, is a method for performing fast modular multiplication, introduced in 1985 by the American mathematician <a href="Peter_Montgomery_(mathematician)" title="wikilink">Peter L. Montgomery</a>. <a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> <a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> Given two numbers <em>a</em> and <em>b</em> modulo a positive integer <em>N</em>, Montgomery multiplication computes</p>

<p>

<math display="block" id="Montgomery_modular_multiplication:0">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>a</mi>
     <mi>b</mi>
    </mrow>
    <mo lspace="2.5pt" rspace="2.5pt">mod</mo>
    <mi>N</mi>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">modulo</csymbol>
    <apply>
     <times></times>
     <ci>a</ci>
     <ci>b</ci>
    </apply>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ab\bmod N.
  </annotation>
 </semantics>
</math>

 Montgomery multiplication requires converting <em>a</em> and <em>b</em> into a special representation called Montgomery form. Because of the overhead involved in the conversion, computing a single product by Montgomery multiplication is slower than computing the product in the integers and performing a modular reduction by division or <a href="Barrett_reduction" title="wikilink">Barrett reduction</a>. However, when many products are required, as in <a href="modular_exponentiation" title="wikilink">modular exponentiation</a>, the conversion to Montgomery form becomes a negligible fraction of the time of the computation, and performing the computation by Montgomery multiplication is faster than the available alternatives. Many important cryptosystems such as <a href="RSA_(cryptosystem)" title="wikilink">RSA</a> and <a href="Diffie–Hellman_key_exchange" title="wikilink">Diffie–Hellman key exchange</a> are based on arithmetic operations modulo a large number, and for these cryptosystems, the increased speed afforded by Montgomery multiplication can be important in practice.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>
<h2 id="modular-arithmetic-and-montgomery-form">Modular arithmetic and Montgomery form</h2>

<p>Let <em>N</em> denote a positive integer modulus. The <a href="ring_(mathematics)" title="wikilink">ring</a> <strong>Z</strong>/<em>N</em><strong>Z</strong> consists of residue classes modulo <em>N</em>, that is, sets of the form:</p>

<p>

<math display="block" id="Montgomery_modular_multiplication:1">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mi>a</mi>
     <mo>+</mo>
     <mrow>
      <mi>k</mi>
      <mi>N</mi>
     </mrow>
    </mrow>
    <mo>:</mo>
    <mrow>
     <mi>k</mi>
     <mo>∈</mo>
     <mi>𝐙</mi>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">conditional-set</csymbol>
    <apply>
     <plus></plus>
     <ci>a</ci>
     <apply>
      <times></times>
      <ci>k</ci>
      <ci>N</ci>
     </apply>
    </apply>
    <apply>
     <in></in>
     <ci>k</ci>
     <ci>𝐙</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{a+kN\colon k\in\mathbf{Z}\},
  </annotation>
 </semantics>
</math>

 where <em>a</em> is some fixed integer. Each residue class is a set of integers such that the difference of any two integers in the set is divisible by <em>N</em> (and the residue class is maximal with respect to that property; integers aren't left out of the residue class unless they would violate the divisibility condition). The residue class corresponding to <em>a</em> is denoted 

<math display="inline" id="Montgomery_modular_multiplication:2">
 <semantics>
  <mover accent="true">
   <mi>a</mi>
   <mo stretchy="false">¯</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-¯</ci>
    <ci>a</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bar{a}
  </annotation>
 </semantics>
</math>

. Equality of residue classes is called congruence and is denoted:</p>

<p>

<math display="block" id="Montgomery_modular_multiplication:3">
 <semantics>
  <mrow>
   <mrow>
    <mover accent="true">
     <mi>a</mi>
     <mo stretchy="false">¯</mo>
    </mover>
    <mo>≡</mo>
    <mrow>
     <mover accent="true">
      <mi>b</mi>
      <mo stretchy="false">¯</mo>
     </mover>
     <mspace width="veryverythickmathspace">
     </mspace>
     <mrow>
      <mo lspace="8.1pt" stretchy="false">(</mo>
      <mrow>
       <mo>mod</mo>
       <mi>N</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <ci>normal-¯</ci>
     <ci>a</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <apply>
      <ci>normal-¯</ci>
      <ci>b</ci>
     </apply>
     <apply>
      <ci>pmod</ci>
      <ci>N</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bar{a}\equiv\bar{b}\;\;(\mathop{{\rm mod}}N).
  </annotation>
 </semantics>
</math>

 Storing an entire residue class on a computer is impossible because the residue class has infinitely many elements. Instead, residue classes are stored as representatives. Conventionally, these representatives are the integers <em>a</em> for which . If <em>a</em> is an integer, then the representative of 

<math display="inline" id="Montgomery_modular_multiplication:4">
 <semantics>
  <mover accent="true">
   <mi>a</mi>
   <mo stretchy="false">¯</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-¯</ci>
    <ci>a</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bar{a}
  </annotation>
 </semantics>
</math>

 is written . When writing congruences, it's common to identify an integer with the residue class it represents. With this convention, the above equality is written 

<math display="inline" id="Montgomery_modular_multiplication:5">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo>≡</mo>
   <mrow>
    <mi>b</mi>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mrow>
     <mo lspace="8.1pt" stretchy="false">(</mo>
     <mrow>
      <mo>mod</mo>
      <mi>N</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <ci>a</ci>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <ci>b</ci>
     <apply>
      <ci>pmod</ci>
      <ci>N</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a\equiv b\;\;(\mathop{{\rm mod}}N)
  </annotation>
 </semantics>
</math>

.</p>

<p>Arithmetic on residue classes is done by first performing integer arithmetic on their representatives. The output of the integer operation determines a residue class, and the output of the modular operation is determined by computing the residue class's representative. For example, if , then the sum of the residue classes 

<math display="inline" id="Montgomery_modular_multiplication:6">
 <semantics>
  <mover accent="true">
   <mn>7</mn>
   <mo>¯</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-¯</ci>
    <cn type="integer">7</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \overline{7}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Montgomery_modular_multiplication:7">
 <semantics>
  <mover accent="true">
   <mn>15</mn>
   <mo>¯</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-¯</ci>
    <cn type="integer">15</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \overline{15}
  </annotation>
 </semantics>
</math>

 is computed by finding the integer sum , then determining , the integer between 0 and 16 whose difference with 22 is a multiple of 17. In this case, that integer is 5, so 

<math display="inline" id="Montgomery_modular_multiplication:8">
 <semantics>
  <mrow>
   <mrow>
    <mover accent="true">
     <mn>7</mn>
     <mo>¯</mo>
    </mover>
    <mo>+</mo>
    <mover accent="true">
     <mn>15</mn>
     <mo>¯</mo>
    </mover>
   </mrow>
   <mo>≡</mo>
   <mrow>
    <mover accent="true">
     <mn>5</mn>
     <mo>¯</mo>
    </mover>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mrow>
     <mo lspace="8.1pt" stretchy="false">(</mo>
     <mrow>
      <mo>mod</mo>
      <mn>17</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <plus></plus>
     <apply>
      <ci>normal-¯</ci>
      <cn type="integer">7</cn>
     </apply>
     <apply>
      <ci>normal-¯</ci>
      <cn type="integer">15</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <apply>
      <ci>normal-¯</ci>
      <cn type="integer">5</cn>
     </apply>
     <apply>
      <ci>pmod</ci>
      <cn type="integer">17</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \overline{7}+\overline{15}\equiv\overline{5}\;\;(\mathop{{\rm mod}}17)
  </annotation>
 </semantics>
</math>

.</p>

<p>If <em>a</em> and <em>b</em> are integers in the range , then their sum is in the range  and their difference is in the range , so determining the representative in  requires at most one subtraction or addition (respectively) of <em>N</em>. However, the product <em>ab</em> is in the range <mtpl></mtpl>. Storing the intermediate integer product <em>ab</em> requires twice as many bits as either <em>a</em> or <em>b</em>, and efficiently determining the representative in  requires division. Mathematically, the integer between 0 and  that is congruent to <em>ab</em> can be expressed by applying the <a href="division_algorithm" title="wikilink">division algorithm</a>:</p>

<p>

<math display="block" id="Montgomery_modular_multiplication:9">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>a</mi>
     <mi>b</mi>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mi>q</mi>
      <mi>N</mi>
     </mrow>
     <mo>+</mo>
     <mi>r</mi>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>a</ci>
     <ci>b</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>q</ci>
      <ci>N</ci>
     </apply>
     <ci>r</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ab=qN+r,
  </annotation>
 </semantics>
</math>

 where <em>q</em> is the quotient 

<math display="inline" id="Montgomery_modular_multiplication:10">
 <semantics>
  <mrow>
   <mo stretchy="false">⌊</mo>
   <mrow>
    <mrow>
     <mi>a</mi>
     <mi>b</mi>
    </mrow>
    <mo>/</mo>
    <mi>N</mi>
   </mrow>
   <mo stretchy="false">⌋</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <floor></floor>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <ci>a</ci>
      <ci>b</ci>
     </apply>
     <ci>N</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lfloor ab/N\rfloor
  </annotation>
 </semantics>
</math>

 and <em>r</em>, the remainder, is in the interval . The remainder <em>r</em> is . Determining <em>r</em> can be done by computing <em>q</em>, then subtracting <em>qN</em> from <em>ab</em>. For example, the product 

<math display="inline" id="Montgomery_modular_multiplication:11">
 <semantics>
  <mrow>
   <mover accent="true">
    <mn>7</mn>
    <mo>¯</mo>
   </mover>
   <mo>⋅</mo>
   <mover accent="true">
    <mn>15</mn>
    <mo>¯</mo>
   </mover>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-⋅</ci>
    <apply>
     <ci>normal-¯</ci>
     <cn type="integer">7</cn>
    </apply>
    <apply>
     <ci>normal-¯</ci>
     <cn type="integer">15</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \overline{7}\cdot\overline{15}
  </annotation>
 </semantics>
</math>

 is determined by computing 

<math display="inline" id="Montgomery_modular_multiplication:12">
 <semantics>
  <mrow>
   <mrow>
    <mn>7</mn>
    <mo>⋅</mo>
    <mn>15</mn>
   </mrow>
   <mo>=</mo>
   <mn>105</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>normal-⋅</ci>
     <cn type="integer">7</cn>
     <cn type="integer">15</cn>
    </apply>
    <cn type="integer">105</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   7\cdot 15=105
  </annotation>
 </semantics>
</math>

, dividing 

<math display="inline" id="Montgomery_modular_multiplication:13">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">⌊</mo>
    <mrow>
     <mn>105</mn>
     <mo>/</mo>
     <mn>17</mn>
    </mrow>
    <mo stretchy="false">⌋</mo>
   </mrow>
   <mo>=</mo>
   <mn>6</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <floor></floor>
     <apply>
      <divide></divide>
      <cn type="integer">105</cn>
      <cn type="integer">17</cn>
     </apply>
    </apply>
    <cn type="integer">6</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lfloor 105/17\rfloor=6
  </annotation>
 </semantics>
</math>

, and subtracting 

<math display="inline" id="Montgomery_modular_multiplication:14">
 <semantics>
  <mrow>
   <mrow>
    <mn>105</mn>
    <mo>-</mo>
    <mrow>
     <mn>6</mn>
     <mo>⋅</mo>
     <mn>17</mn>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mn>105</mn>
    <mo>-</mo>
    <mn>102</mn>
   </mrow>
   <mo>=</mo>
   <mn>3</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <minus></minus>
      <cn type="integer">105</cn>
      <apply>
       <ci>normal-⋅</ci>
       <cn type="integer">6</cn>
       <cn type="integer">17</cn>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <cn type="integer">105</cn>
      <cn type="integer">102</cn>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="integer">3</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   105-6\cdot 17=105-102=3
  </annotation>
 </semantics>
</math>

.</p>

<p>Because the computation of <em>q</em> requires division, it is undesirably expensive on most computer hardware. Montgomery form is a different way of expressing the elements of the ring in which modular products can be computed without expensive divisions. While divisions are still necessary, they can be done with respect to a different divisor <em>R</em>. This divisor can be chosen to be a whole number of machine words, making division and reduction much cheaper.</p>

<p>The only mathematical requirement on the auxiliary modulus <em>R</em> is that it be a positive integer such that . For computational purposes it is also necessary that division and reduction modulo <em>R</em> be inexpensive, and the modulus is not useful for modular multiplication unless . The <strong>Montgomery form</strong> or <strong>Montgomery representation</strong> of the residue class 

<math display="inline" id="Montgomery_modular_multiplication:15">
 <semantics>
  <mover accent="true">
   <mi>a</mi>
   <mo stretchy="false">¯</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-¯</ci>
    <ci>a</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bar{a}
  </annotation>
 </semantics>
</math>

 with respect to <em>R</em> is , that is, it is the representative of the residue class 

<math display="inline" id="Montgomery_modular_multiplication:16">
 <semantics>
  <mover accent="true">
   <mrow>
    <mi>a</mi>
    <mi>R</mi>
   </mrow>
   <mo>¯</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-¯</ci>
    <apply>
     <times></times>
     <ci>a</ci>
     <ci>R</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \overline{aR}
  </annotation>
 </semantics>
</math>

. For example, suppose that  and that . The Montgomery forms of 3, 5, 7, and 15 are , , , and .</p>

<p>Addition and subtraction in Montgomery form are the same as ordinary modular addition and subtraction because of the distributive law:</p>

<p>

<math display="block" id="Montgomery_modular_multiplication:17">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mi>a</mi>
      <mi>R</mi>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mi>b</mi>
      <mi>R</mi>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>a</mi>
       <mo>+</mo>
       <mi>b</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>R</mi>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>a</ci>
      <ci>R</ci>
     </apply>
     <apply>
      <times></times>
      <ci>b</ci>
      <ci>R</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <plus></plus>
      <ci>a</ci>
      <ci>b</ci>
     </apply>
     <ci>R</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   aR+bR=(a+b)R,
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Montgomery_modular_multiplication:18">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mi>a</mi>
      <mi>R</mi>
     </mrow>
     <mo>-</mo>
     <mrow>
      <mi>b</mi>
      <mi>R</mi>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>a</mi>
       <mo>-</mo>
       <mi>b</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>R</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>a</ci>
      <ci>R</ci>
     </apply>
     <apply>
      <times></times>
      <ci>b</ci>
      <ci>R</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <minus></minus>
      <ci>a</ci>
      <ci>b</ci>
     </apply>
     <ci>R</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   aR-bR=(a-b)R.
  </annotation>
 </semantics>
</math>

 This is a consequence of the fact that, because , multiplication by <em>R</em> is an <a class="uri" href="isomorphism" title="wikilink">isomorphism</a> on the additive group <strong>Z</strong>/<em>N</em><strong>Z</strong>. For example, , which in Montgomery form becomes .</p>

<p>Multiplication in Montgomery form, however, is seemingly more complicated. The usual product of <em>aR</em> and <em>bR</em> does not represent the product of <em>a</em> and <em>b</em> because it has an extra factor of <em>R</em>:</p>

<p>

<math display="block" id="Montgomery_modular_multiplication:19">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mrow>
         <mi>a</mi>
         <mi>R</mi>
        </mrow>
        <mo lspace="2.5pt" rspace="2.5pt">mod</mo>
        <mi>N</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mrow>
         <mi>b</mi>
         <mi>R</mi>
        </mrow>
        <mo lspace="2.5pt" rspace="2.5pt">mod</mo>
        <mi>N</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo lspace="2.5pt" rspace="2.5pt">mod</mo>
     <mi>N</mi>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>a</mi>
        <mi>b</mi>
        <mi>R</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>R</mi>
     </mrow>
     <mo lspace="2.5pt" rspace="2.5pt">mod</mo>
     <mi>N</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="latexml">modulo</csymbol>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="latexml">modulo</csymbol>
       <apply>
        <times></times>
        <ci>a</ci>
        <ci>R</ci>
       </apply>
       <ci>N</ci>
      </apply>
      <apply>
       <csymbol cd="latexml">modulo</csymbol>
       <apply>
        <times></times>
        <ci>b</ci>
        <ci>R</ci>
       </apply>
       <ci>N</ci>
      </apply>
     </apply>
     <ci>N</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">modulo</csymbol>
     <apply>
      <times></times>
      <apply>
       <times></times>
       <ci>a</ci>
       <ci>b</ci>
       <ci>R</ci>
      </apply>
      <ci>R</ci>
     </apply>
     <ci>N</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (aR\bmod N)(bR\bmod N)\bmod N=(abR)R\bmod N.
  </annotation>
 </semantics>
</math>

 Computing products in Montgomery form requires removing the extra factor of <em>R</em>. While division by <em>R</em> is cheap, the intermediate product  is not divisible by <em>R</em> because the modulo operation has destroyed that property. So for instance, the product of the Montgomery forms of 7 and 15 modulo 17 is the product of 3 and 4, which is 12. Since 12 is not divisible by 100, additional effort is required to remove the extra factor of <em>R</em>.</p>

<p>Removing the extra factor of <em>R</em> can be done by multiplying by an integer <em>R</em>′ such that 

<math display="inline" id="Montgomery_modular_multiplication:20">
 <semantics>
  <mrow>
   <mrow>
    <mi>R</mi>
    <msup>
     <mi>R</mi>
     <mo>′</mo>
    </msup>
   </mrow>
   <mo>≡</mo>
   <mrow>
    <mn>1</mn>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mrow>
     <mo lspace="8.1pt" stretchy="false">(</mo>
     <mrow>
      <mo>mod</mo>
      <mi>N</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <times></times>
     <ci>R</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>R</ci>
      <ci>normal-′</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <cn type="integer">1</cn>
     <apply>
      <ci>pmod</ci>
      <ci>N</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   RR^{\prime}\equiv 1\;\;(\mathop{{\rm mod}}N)
  </annotation>
 </semantics>
</math>

, that is, by an <em>R</em>′ whose residue class is the <a href="modular_inverse" title="wikilink">modular inverse</a> of <em>R</em> mod <em>N</em>. Then, working modulo <em>N</em>,</p>

<p>

<math display="block" id="Montgomery_modular_multiplication:21">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <mi>a</mi>
        <mi>R</mi>
       </mrow>
       <mo lspace="2.5pt" rspace="2.5pt">mod</mo>
       <mi>N</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <mi>b</mi>
        <mi>R</mi>
       </mrow>
       <mo lspace="2.5pt" rspace="2.5pt">mod</mo>
       <mi>N</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <msup>
      <mi>R</mi>
      <mo>′</mo>
     </msup>
    </mrow>
    <mo>≡</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>a</mi>
       <mi>R</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>b</mi>
       <mi>R</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <msup>
      <mi>R</mi>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msup>
    </mrow>
    <mo>≡</mo>
    <mrow>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>a</mi>
        <mi>b</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>R</mi>
     </mrow>
     <mspace width="veryverythickmathspace">
     </mspace>
     <mrow>
      <mo lspace="8.1pt" stretchy="false">(</mo>
      <mrow>
       <mo>mod</mo>
       <mi>N</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <equivalent></equivalent>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="latexml">modulo</csymbol>
       <apply>
        <times></times>
        <ci>a</ci>
        <ci>R</ci>
       </apply>
       <ci>N</ci>
      </apply>
      <apply>
       <csymbol cd="latexml">modulo</csymbol>
       <apply>
        <times></times>
        <ci>b</ci>
        <ci>R</ci>
       </apply>
       <ci>N</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>R</ci>
       <ci>normal-′</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <times></times>
       <ci>a</ci>
       <ci>R</ci>
      </apply>
      <apply>
       <times></times>
       <ci>b</ci>
       <ci>R</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>R</ci>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <equivalent></equivalent>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="latexml">annotated</csymbol>
      <apply>
       <times></times>
       <apply>
        <times></times>
        <ci>a</ci>
        <ci>b</ci>
       </apply>
       <ci>R</ci>
      </apply>
      <apply>
       <ci>pmod</ci>
       <ci>N</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (aR\bmod N)(bR\bmod N)R^{\prime}\equiv(aR)(bR)R^{-1}\equiv(ab)R\;\;(\mathop{{%
\rm mod}}N).
  </annotation>
 </semantics>
</math>

 The integer <em>R</em>′ exists because of the assumption that <em>R</em> and <em>N</em> are coprime. It can be constructed using the <a href="extended_Euclidean_algorithm" title="wikilink">extended Euclidean algorithm</a>. The extended Euclidean algorithm efficiently determines integers <em>R</em>′ and <em>N</em>′ that satisfy <a href="Bézout's_identity" title="wikilink">Bézout's identity</a>: , , and:</p>

<p>

<math display="block" id="Montgomery_modular_multiplication:22">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>R</mi>
     <msup>
      <mi>R</mi>
      <mo>′</mo>
     </msup>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mi>N</mi>
     <msup>
      <mi>N</mi>
      <mo>′</mo>
     </msup>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>1.</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>R</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>R</ci>
       <ci>normal-′</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>N</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>N</ci>
       <ci>normal-′</ci>
      </apply>
     </apply>
    </apply>
    <cn type="float">1.</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   RR^{\prime}-NN^{\prime}=1.
  </annotation>
 </semantics>
</math>

 This shows that it is possible to do multiplication in Montgomery form. A straightforward algorithm to multiply numbers in Montgomery form is therefore to multiply , , and  as integers and reduce modulo <em>N</em>.</p>

<p>For example, to multiply 7 and 15 modulo 17 in Montgomery form, compute the product of 3 and 4 to get 12 as above. The extended Euclidean algorithm implies that , so . Multiply 12 by 8 to get 96 and reduce modulo 17 to get 11. This is the Montgomery form of 3, as expected.</p>
<h2 id="the-redc-algorithm">The REDC algorithm</h2>

<p>While the above algorithm is correct, it is slower than multiplication in the standard representation because of the need to multiply by <em>R</em>′ and divide by <em>N</em>. <strong>Montgomery reduction</strong>, also known as REDC, is an algorithm that simultaneously computes the product by <em>R</em>′ and reduces modulo <em>N</em> more quickly than the naive method. The speed is because all computations are done using only reduction and divisions with respect to <em>R</em>, not <em>N</em>:</p>

<p><strong><code>function</code></strong><code> REDC </code><strong><code>is</code></strong><br/>
<code>    </code><strong><code>input:</code></strong><code> Integers </code><em><code>R</code></em><code> and </code><em><code>N</code></em><code> with </code><code>,</code><br/>
<code>           Integer </code><em><code>N</code></em><code>′ in </code><code> such that </code>

<math display="inline" id="Montgomery_modular_multiplication:23">
 <semantics>
  <mrow>
   <mrow>
    <mi>N</mi>
    <msup>
     <mi>N</mi>
     <mo>′</mo>
    </msup>
   </mrow>
   <mo>≡</mo>
   <mrow>
    <mrow>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mrow>
     <mo lspace="8.1pt" stretchy="false">(</mo>
     <mrow>
      <mo>mod</mo>
      <mi>R</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <times></times>
     <ci>N</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>N</ci>
      <ci>normal-′</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <ci>pmod</ci>
      <ci>R</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   NN^{\prime}\equiv-1\;\;(\mathop{{\rm mod}}R)
  </annotation>
 </semantics>
</math>

<code>,</code><br/>
<code>           Integer </code><em><code>T</code></em><code> in the range </code><br/>
<code>    </code><strong><code>output:</code></strong><code> Integer </code><em><code>S</code></em><code> in the range </code><code> such that </code>

<math display="inline" id="Montgomery_modular_multiplication:24">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>≡</mo>
   <mrow>
    <mrow>
     <mi>T</mi>
     <msup>
      <mi>R</mi>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msup>
    </mrow>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mrow>
     <mo lspace="8.1pt" stretchy="false">(</mo>
     <mrow>
      <mo>mod</mo>
      <mi>N</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <ci>S</ci>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <apply>
      <times></times>
      <ci>T</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>R</ci>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <ci>pmod</ci>
      <ci>N</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S\equiv TR^{-1}\;\;(\mathop{{\rm mod}}N)
  </annotation>
 </semantics>
</math>

<br/>
<br/>
<code>    </code><em><code>m</code></em><code> ← ((</code><em><code>T</code></em><code> mod </code><em><code>R</code></em><code>)</code><em><code>N</code></em><code>′) mod </code><em><code>R</code></em><br/>
<code>    </code><em><code>t</code></em><code> ← (T + mN) / R</code><br/>
<code>    </code><strong><code>if</code></strong><code> </code><em><code>t</code></em><code> ≥ </code><em><code>N</code></em><code> </code><strong><code>then</code></strong><br/>
<code>        </code><strong><code>return</code></strong><code> </code><br/>
<code>    </code><strong><code>else</code></strong><br/>
<code>        </code><strong><code>return</code></strong><code> </code><em><code>t</code></em><br/>
<code>    </code><strong><code>end</code> <code>if</code></strong><br/>
<strong><code>end</code> <code>function</code></strong></p>

<p>To see that this algorithm is correct, first observe that <em>m</em> is chosen precisely so that  is divisible by <em>R</em>. A number is divisible by <em>R</em> if and only if it is congruent to zero mod <em>R</em>, and we have:</p>

<p>

<math display="block" id="Montgomery_modular_multiplication:25">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>T</mi>
     <mo>+</mo>
     <mrow>
      <mi>m</mi>
      <mi>N</mi>
     </mrow>
    </mrow>
    <mo>≡</mo>
    <mrow>
     <mi>T</mi>
     <mo>+</mo>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mrow>
           <mo stretchy="false">(</mo>
           <mrow>
            <mi>T</mi>
            <mo lspace="2.5pt" rspace="2.5pt">mod</mo>
            <mi>R</mi>
           </mrow>
           <mo stretchy="false">)</mo>
          </mrow>
          <msup>
           <mi>N</mi>
           <mo>′</mo>
          </msup>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
        <mo lspace="2.5pt" rspace="2.5pt">mod</mo>
        <mi>R</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>N</mi>
     </mrow>
    </mrow>
    <mo>≡</mo>
    <mrow>
     <mi>T</mi>
     <mo>+</mo>
     <mrow>
      <mi>T</mi>
      <msup>
       <mi>N</mi>
       <mo>′</mo>
      </msup>
      <mi>N</mi>
     </mrow>
    </mrow>
    <mo>≡</mo>
    <mrow>
     <mi>T</mi>
     <mo>-</mo>
     <mi>T</mi>
    </mrow>
    <mo>≡</mo>
    <mrow>
     <mn>0</mn>
     <mspace width="veryverythickmathspace">
     </mspace>
     <mrow>
      <mo lspace="8.1pt" stretchy="false">(</mo>
      <mrow>
       <mo>mod</mo>
       <mi>R</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <equivalent></equivalent>
     <apply>
      <plus></plus>
      <ci>T</ci>
      <apply>
       <times></times>
       <ci>m</ci>
       <ci>N</ci>
      </apply>
     </apply>
     <apply>
      <plus></plus>
      <ci>T</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="latexml">modulo</csymbol>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="latexml">modulo</csymbol>
          <ci>T</ci>
          <ci>R</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>N</ci>
          <ci>normal-′</ci>
         </apply>
        </apply>
        <ci>R</ci>
       </apply>
       <ci>N</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <equivalent></equivalent>
     <share href="#.cmml">
     </share>
     <apply>
      <plus></plus>
      <ci>T</ci>
      <apply>
       <times></times>
       <ci>T</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>N</ci>
        <ci>normal-′</ci>
       </apply>
       <ci>N</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <equivalent></equivalent>
     <share href="#.cmml">
     </share>
     <apply>
      <minus></minus>
      <ci>T</ci>
      <ci>T</ci>
     </apply>
    </apply>
    <apply>
     <equivalent></equivalent>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="latexml">annotated</csymbol>
      <cn type="integer">0</cn>
      <apply>
       <ci>pmod</ci>
       <ci>R</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T+mN\equiv T+(((T\bmod R)N^{\prime})\bmod R)N\equiv T+TN^{\prime}N\equiv T-T%
\equiv 0\;\;(\mathop{{\rm mod}}R).
  </annotation>
 </semantics>
</math>

 Therefore <em>t</em> is an integer. Second, the output is either <em>t</em> or , both of which are congruent to <em>t</em> mod <em>N</em>, so prove that the output is congruent to <mtpl></mtpl>, it suffices to prove that <em>t</em> is. Modulo <em>N</em>, <em>t</em> satisfies:</p>

<p>

<math display="block" id="Montgomery_modular_multiplication:26">
 <semantics>
  <mrow>
   <mrow>
    <mi>t</mi>
    <mo>≡</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>T</mi>
       <mo>+</mo>
       <mrow>
        <mi>m</mi>
        <mi>N</mi>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <msup>
      <mi>R</mi>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msup>
    </mrow>
    <mo>≡</mo>
    <mrow>
     <mrow>
      <mi>T</mi>
      <msup>
       <mi>R</mi>
       <mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msup>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>m</mi>
        <msup>
         <mi>R</mi>
         <mrow>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
        </msup>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>N</mi>
     </mrow>
    </mrow>
    <mo>≡</mo>
    <mrow>
     <mrow>
      <mi>T</mi>
      <msup>
       <mi>R</mi>
       <mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msup>
     </mrow>
     <mspace width="veryverythickmathspace">
     </mspace>
     <mrow>
      <mo lspace="8.1pt" stretchy="false">(</mo>
      <mrow>
       <mo>mod</mo>
       <mi>N</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <equivalent></equivalent>
     <ci>t</ci>
     <apply>
      <times></times>
      <apply>
       <plus></plus>
       <ci>T</ci>
       <apply>
        <times></times>
        <ci>m</ci>
        <ci>N</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>R</ci>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <equivalent></equivalent>
     <share href="#.cmml">
     </share>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>T</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>R</ci>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <times></times>
        <ci>m</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>R</ci>
         <apply>
          <minus></minus>
          <cn type="integer">1</cn>
         </apply>
        </apply>
       </apply>
       <ci>N</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <equivalent></equivalent>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="latexml">annotated</csymbol>
      <apply>
       <times></times>
       <ci>T</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>R</ci>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
      <apply>
       <ci>pmod</ci>
       <ci>N</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t\equiv(T+mN)R^{-1}\equiv TR^{-1}+(mR^{-1})N\equiv TR^{-1}\;\;(\mathop{{\rm mod%
}}N).
  </annotation>
 </semantics>
</math>

 Therefore the output has the correct residue class. Third, <em>m</em> is in , and therefore  is between 0 and . Hence <em>t</em> is less than , and because it's an integer, this puts <em>t</em> in the range . Therefore reducing <em>t</em> into the desired range requires at most a single subtraction, so the algorithm's output lies in the correct range.</p>

<p>To use REDC to compute the product of 7 and 15 modulo 17, first convert to Montgomery form and multiply as integers to get 12 as above. Then apply REDC with , , , and . The first step sets <em>m</em> to . The second step sets <em>t</em> to . Notice that  is 1100, a multiple of 100 as expected. <em>t</em> is set to 11, which is less than 17, so the final result is 11, which agrees with the computation of the previous section.</p>

<p>As another example, consider the product  but with . Using the extended Euclidean algorithm, compute , so <em>N</em>′ will be . The Montgomery forms of 7 and 15 are  and , respectively. Their product 28 is the input <em>T</em> to REDC, and since , the assumptions of REDC are satisfied. To run REDC, set <em>m</em> to . Then , so . Because , this is the Montgomery form of .</p>
<h2 id="arithmetic-in-montgomery-form">Arithmetic in Montgomery form</h2>

<p>Many operations of interest modulo <em>N</em> can be expressed equally well in Montgomery form. Addition, subtraction, negation, comparison for equality, multiplication by an integer not in Montgomery form, and greatest common divisors with <em>N</em> may all be done with the standard algorithms. The <a href="Jacobi_symbol" title="wikilink">Jacobi symbol</a> can be calculated as 

<math display="inline" id="Montgomery_modular_multiplication:27">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mfrac>
     <mi>a</mi>
     <mi>N</mi>
    </mfrac>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mfrac>
      <mrow>
       <mi>a</mi>
       <mi>R</mi>
      </mrow>
      <mi>N</mi>
     </mfrac>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>/</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mfrac>
      <mi>R</mi>
      <mi>N</mi>
     </mfrac>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <divide></divide>
     <ci>a</ci>
     <ci>N</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <ci>a</ci>
       <ci>R</ci>
      </apply>
      <ci>N</ci>
     </apply>
     <apply>
      <divide></divide>
      <ci>R</ci>
      <ci>N</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle(\frac{a}{N})=(\frac{aR}{N})/(\frac{R}{N})
  </annotation>
 </semantics>
</math>

 as long as  is stored.</p>

<p>When , most other arithmetic operations can be expressed in terms of REDC. This assumption implies that the product of two representatives mod <em>N</em> is less than <em>RN</em>, the exact hypothesis necessary for REDC to generate correct output. In particular, the product of  and  is . The combined operation of multiplication and REDC is often called <strong>Montgomery multiplication</strong>.</p>

<p>Conversion into Montgomery form is done by computing <mtpl></mtpl>. Conversion out of Montgomery form is done by computing . The modular inverse of  is <mtpl></mtpl>. Modular exponentiation can be done using <a href="exponentiation_by_squaring" title="wikilink">exponentiation by squaring</a> by initializing the initial product to the Montgomery representation of 1, that is, to ), and by replacing the multiply and square steps by Montgomery multiplies.</p>

<p>Performing these operations requires knowing at least <mtpl></mtpl>. The constants  and <mtpl></mtpl> can be generated as <mtpl></mtpl> and as <mtpl></mtpl>. The fundamental operation is to compute REDC of a product. When standalone REDC is needed, it can be computed as REDC of a product with . The only place where a direct reduction modulo <em>N</em> is necessary is in the precomputation of <mtpl></mtpl>.</p>
<h2 id="montgomery-arithmetic-on-multiprecision-integers">Montgomery arithmetic on multiprecision integers</h2>

<p>Most cryptographic applications require numbers that are hundreds or even thousands of bits long. Such numbers are too large to be stored in a single machine word. Typically, the hardware performs multiplication mod some base <em>B</em>, so performing larger multiplications requires combining several small multiplications. The base <em>B</em> is typically 2 for microelectronic applications, 2<sup>8</sup> for 8-bit firmware,<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> or 2<sup>32</sup> or 2<sup>64</sup> for software applications.</p>

<p>The REDC algorithm requires products modulo <em>R</em>, and typically  so that REDC can be used to compute products. However, when <em>R</em> is a power of <em>B</em>, there is a variant of REDC which requires products only of machine word sized integers. Suppose that positive multi-precision integers are stored <a href="little_endian" title="wikilink">little endian</a>, that is, <em>x</em> is stored as an array  such that  for all <em>i</em> and <mtpl> ∑ <em>x</em>[<em>i</em>] <em>B</em><sup><em>i</em></sup>}}</mtpl>. The algorithm begins with a multiprecision integer <em>T</em> and reduces it one word at a time. First an appropriate multiple of <em>N</em> is added to make <em>T</em> divisible by <em>B</em>. Then a multiple of <em>N</em> is added to make <em>T</em> divisible by <em>B</em><sup>2</sup>, and so on. Eventually <em>T</em> is divisible by <em>R</em>, and after division by <em>R</em> the algorithm is in the same place as REDC was after the computation of <em>t</em>.</p>

<p><strong><code>function</code></strong><code> MultiPrecisionREDC </code><strong><code>is</code></strong><br/>
<code>    </code><strong><code>Input:</code></strong><code> Integer </code><em><code>N</code></em><code> with </code><code>, stored as an array of </code><em><code>p</code></em><code> integers,</code><br/>
<code>           Integer </code><mtpl><code> </code><em><code>B</code></em><sup><em><code>r</code></em></sup><code>}}</code></mtpl><code>,</code><br/>
<code>           Integer </code><em><code>N</code></em><code>′ in </code><code> such that </code><code>,</code><br/>
<code>           Integer </code><em><code>T</code></em><code> in the range </code><code>, stored as an array of </code><code> integers.</code><br/>
<br/>
<code>    </code><strong><code>Output:</code></strong><code> Integer </code><em><code>S</code></em><code> in </code><code> such that </code><mtpl></mtpl><code>, stored as an array of </code><em><code>p</code></em><code> integers.</code><br/>
<br/>
<code>    Set </code><br/>
<code>    </code><strong><code>for</code></strong><code> </code><code> </code><strong><code>do</code></strong><br/>
<code>        ''(Make </code><em><code>T</code></em><code> divisible by </code><mtpl></mtpl><code>)''</code><br/>
<br/>
<code>        </code><em><code>c</code></em><code> ← 0</code><br/>
<code>        </code><em><code>m</code></em><code> ← </code><br/>
<code>        </code><strong><code>for</code></strong><code> </code><code> </code><strong><code>do</code></strong><br/>
<code>            </code><em><code>(Add</code> <code>the</code> <code>low</code> <code>word</code> <code>of</code> <code>and</code> <code>the</code> <code>carry</code> <code>from</code> <code>earlier,</code> <code>and</code> <code>find</code> <code>the</code> <code>new</code> <code>carry)</code></em><br/>
<br/>
<code>            </code><em><code>x</code></em><code> ← </code><br/>
<code>            </code><em><code>T</code></em><code>[</code><em><code>i</code></em><code> + </code><em><code>j</code></em><code>] ← </code><br/>
<code>            </code><em><code>c</code></em><code> ← </code><br/>
<code>        </code><strong><code>end</code> <code>for</code></strong><br/>
<code>        </code><strong><code>for</code></strong><code> </code><code> </code><strong><code>do</code></strong><br/>
<code>            </code><em><code>(Continue</code> <code>carrying)</code></em><br/>
<br/>
<code>            </code><em><code>x</code></em><code> ← </code><br/>
<code>            </code><em><code>T</code></em><code>[</code><em><code>i</code></em><code> + </code><em><code>j</code></em><code>] ← </code><br/>
<code>            </code><em><code>c</code></em><code> ← </code><br/>
<code>        </code><strong><code>end</code> <code>for</code></strong><br/>
<code>    </code><strong><code>end</code> <code>for</code></strong><br/>
<br/>
<code>    </code><strong><code>for</code></strong><code> </code><code> </code><strong><code>do</code></strong><br/>
<code>        </code><em><code>S</code></em><code>[</code><em><code>i</code></em><code>] ← </code><em><code>T</code></em><code>[</code><em><code>i</code></em><code> + </code><em><code>r</code></em><code>]</code><br/>
<code>    </code><strong><code>end</code> <code>for</code></strong><br/>
<br/>
<code>    </code><strong><code>if</code></strong><code> </code><code> </code><strong><code>then</code></strong><br/>
<code>        </code><strong><code>return</code></strong><code> </code><br/>
<code>    </code><strong><code>else</code></strong><br/>
<code>        </code><strong><code>return</code></strong><code> </code><br/>
<code>    </code><strong><code>end</code> <code>if</code></strong><br/>
<strong><code>end</code> <code>function</code></strong></p>

<p>The final comparison and subtraction is done by the standard algorithms.</p>

<p>The above algorithm is correct for essentially the same reasons that REDC is correct. Each time through the <em>i</em> loop, <em>m</em> is chosen so that  is divisible by <em>B</em>. Then <em>mNB</em><sup><em>i</em></sup> is added to <em>T</em>. Because this quantity is zero mod <em>N</em>, adding it does not affect the value of . If <em>m</em><sub><em>i</em></sub> denotes the value of <em>m</em> computed in the <em>i</em>th iteration of the loop, then the algorithm sets <em>S</em> to <mtpl></mtpl>. Because MultiPrecisionREDC and REDC produce the same output, this sum is the same as the choice of <em>m</em> that the REDC algorithm would make.</p>

<p>The last word of <em>T</em>, , is used only to hold a carry, and so consequently it is either zero or one. Depending upon the processor, it may be possible to store this word as a carry flag instead of a full-sized word.</p>

<p>It is possible to combine multiprecision multiplication and REDC into a single algorithm. This combined algorithm is usually called <strong>Montgomery multiplication</strong>. Several different implementations are described by Koç, Acar, and Kalinski.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> The algorithm may use as little as  words of storage (plus a carry bit).</p>

<p>As an example, let , , and . Suppose that  and . The Montgomery representations of <em>a</em> and <em>b</em> are  and . Compute . The initial input <em>T</em> to MultiPrecisionREDC will be [6, 4, 8, 5, 6, 7]. The number <em>N</em> will be represented as [7, 9, 9]. The extended Euclidean algorithm says that , so <em>N</em>′ will be 7.</p>

<p><code>i ← 0</code><br/>
<code>m ← </code><br/>
<br/>
<code>j T       c</code><br/>
<code>- ------- -</code><br/>
<code>0 0485670 1    </code><em><code>(After</code> <code>first</code> <code>iteration</code> <code>of</code> <code>first</code> <code>loop)</code></em><br/>
<code>1 0485670 1</code><br/>
<code>2 0485670 1</code><br/>
<code>3 0487670 0    </code><em><code>(After</code> <code>first</code> <code>iteration</code> <code>of</code> <code>second</code> <code>loop)</code></em><br/>
<code>4 0487670 0</code><br/>
<code>5 0487670 0</code><br/>
<code>6 0487670 0</code><br/>
<br/>
<code>i ← 1</code><br/>
<code>m ← </code><br/>
<br/>
<code>j T       c</code><br/>
<code>- ------- -</code><br/>
<code>0 0087670 1    </code><em><code>(After</code> <code>first</code> <code>iteration</code> <code>of</code> <code>first</code> <code>loop)</code></em><br/>
<code>1 0067670 1</code><br/>
<code>2 0067670 1</code><br/>
<code>3 0067470 1    </code><em><code>(After</code> <code>first</code> <code>iteration</code> <code>of</code> <code>second</code> <code>loop)</code></em><br/>
<code>4 0067480 0</code><br/>
<code>5 0067480 0</code><br/>
<br/>
<code>i ← 2</code><br/>
<code>m ← </code><br/>
<br/>
<code>j T       c</code><br/>
<code>- ------- -</code><br/>
<code>0 0007480 1    </code><em><code>(After</code> <code>first</code> <code>iteration</code> <code>of</code> <code>first</code> <code>loop)</code></em><br/>
<code>1 0007480 1</code><br/>
<code>2 0007480 1</code><br/>
<code>3 0007400 1    </code><em><code>(After</code> <code>first</code> <code>iteration</code> <code>of</code> <code>second</code> <code>loop)</code></em><br/>
<code>4 0007401 0</code></p>

<p>Therefore, before the final comparison and subtraction, . The final subtraction yields the number 50. Since the Montgomery representation of  is , this is the expected result.</p>

<p>When working in base 2, determining the correct <em>m</em> at each stage is particularly easy: If the current working bit is even, then <em>m</em> is zero and if it's odd, then <em>m</em> is one. Furthermore, because each step of MultiPrecisionREDC requires knowing only the lowest bit, Montgomery multiplication can be easily combined with a <a href="carry-save_adder" title="wikilink">carry-save adder</a>.</p>
<h2 id="side-channel-attacks">Side channel attacks</h2>

<p>When using it as a part of a cryptographically secure algorithm, unmodified Montgomery reduction is vulnerable to <a href="side_channel_attack" title="wikilink">side channel attacks</a>, where the attacker can learn about the inner workings of the algorithm by studying the differences in time, power-consumption or any other parameter affected by the fact that the algorithm performs very different actions depending on the input. However it is simple to modify the algorithm or the hardware to make it resistant to such attacks.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a><a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>
<h2 id="references">References</h2>

<p>"</p>

<p><a href="Category:Computer_arithmetic" title="wikilink">Category:Computer arithmetic</a> <a href="Category:Cryptographic_algorithms" title="wikilink">Category:Cryptographic algorithms</a> <a href="Category:Modular_arithmetic" title="wikilink">Category:Modular arithmetic</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="Peter_Montgomery_(mathematician)" title="wikilink">Peter Montgomery</a>. <a href=":doi:10.1090/S0025-5718-1985-0777282-X" title="wikilink">Modular Multiplication Without Trial Division</a>, <em><a href="Mathematics_of_Computation" title="wikilink">Math. Computation</a></em>, vol. 44, pp. 519–521, 1985.<a href="#fnref1">↩</a></li>
<li id="fn2">Martin Kochanski, <a href="http://www.nugae.com/encryption/fap4/montgomery.htm">Montgomery Multiplication</a> A colloquial explanation.<a href="#fnref2">↩</a></li>
<li id="fn3"><a href="Alfred_J._Menezes" title="wikilink">Alfred J. Menezes</a>, Paul C. van Oorschot, and <a href="Scott_A._Vanstone" title="wikilink">Scott A. Vanstone</a>. <a href="http://www.cacr.math.uwaterloo.ca/hac/about/chap14.pdf">Handbook of Applied Cryptography</a>. CRC Press, 1996. ISBN 0-8493-8523-7, chapter 14.<a href="#fnref3">↩</a></li>
<li id="fn4"></li>
<li id="fn5">Çetin K. Koç, Tolga Acar, Burton S. Kalinski, Jr., <a href="#fnref5">↩</a></li>
<li id="fn6">Zhe Liu, Johann Großschädl, and Ilya Kizhvatov. <a href="http://www.caad.arch.ethz.ch/noolab/files/external/conferences/IoT2010_proceedings/pdf/WS1/WS1_6.%20seciot2010_submission_12_final_v0.pdf">"Efficient and Side-Channel Resistant RSA Implementation for 8-bit AVR Microcontrollers"</a>.<a href="#fnref6">↩</a></li>
<li id="fn7">Marc Joye and Sung-Ming Yen. <a href="http://cr.yp.to/bib/2003/joye-ladder.pdf">"The Montgomery Powering Ladder"</a>. 2002.<a href="#fnref7">↩</a></li>
</ol>
</section>
</body>
</html>
