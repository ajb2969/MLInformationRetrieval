<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="283">Secure Remote Password protocol</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Secure Remote Password protocol</h1>
<style>
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
<style>
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
</body></html>
<body>
<hr/>

<p>The <strong>Secure Remote Password protocol</strong> (<strong>SRP</strong>) is an augmented <a href="password-authenticated_key_agreement" title="wikilink">password-authenticated key agreement</a> (PAKE) protocol, specifically designed to work around expired patents.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>

<p>Like all PAKE protocols, an eavesdropper or man in the middle cannot obtain enough information to be able to brute force guess a password without further interactions with the parties for each guess. This means that strong security can be obtained using weak passwords. Furthermore, being an augmented PAKE protocol, the server does not store password-equivalent data. This means that an attacker who steals the server data cannot masquerade as the client unless they first perform a brute force search for the password.</p>
<h2 id="overview">Overview</h2>

<p>The SRP protocol has a number of desirable properties: it allows a user to authenticate themselves to a server, it is resistant to <a href="dictionary_attack" title="wikilink">dictionary attacks</a> mounted by an eavesdropper, and it does not require a <a href="trusted_third_party" title="wikilink">trusted third party</a>. It effectively conveys a <a href="zero-knowledge_password_proof" title="wikilink">zero-knowledge password proof</a> from the user to the server. In revision 6 of the protocol only one password can be guessed per connection attempt. One of the interesting properties of the protocol is that even if one or two of the cryptographic primitives it uses are attacked, it is still secure. The SRP protocol has been revised several times, and is currently at revision 6a.</p>

<p>The SRP protocol creates a large private key shared between the two parties in a manner similar to <a href="Diffie–Hellman_key_exchange" title="wikilink">Diffie–Hellman key exchange</a> based on the client side having the user password and the server side having a cryptographic verifier derived from the password. The shared public key is derived from two random numbers, one generated by the client, and the other generated by the server, which are unique to the login attempt. In cases where encrypted communications as well as authentication are required, the SRP protocol is more secure than the alternative <a href="Secure_Shell" title="wikilink">SSH</a> protocol and faster than using Diffie–Hellman key exchange with signed messages. It is also independent of third parties, unlike <a href="Kerberos_(protocol)" title="wikilink">Kerberos</a>. The SRP protocol, version 3 is described in RFC 2945. SRP version 6 is also used for strong password authentication in <a href="Transport_Layer_Security" title="wikilink">SSL/TLS</a><a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> (in <a class="uri" href="TLS-SRP" title="wikilink">TLS-SRP</a>) and other standards such as <a href="Extensible_Authentication_Protocol" title="wikilink">EAP</a><a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> and <a href="Security_Assertion_Markup_Language" title="wikilink">SAML</a>, and is being standardized in <a href="IEEE_P1363" title="wikilink">IEEE P1363</a> and ISO/IEC 11770-4.</p>
<h2 id="protocol">Protocol</h2>

<p>The following notation is used in this description of the protocol, version 6:</p>
<ul>
<li><em>q</em> and <em>N</em> = 2<em>q</em> + 1 are chosen such that both are prime (which makes <em>q</em> a <a href="Sophie_Germain_prime" title="wikilink">Sophie Germain prime</a> and <em>N</em> a <a href="safe_prime" title="wikilink">safe prime</a>). <em>N</em> must be large enough so that computing discrete logarithms modulo <em>N</em> is infeasible.</li>
<li>All arithmetic is performed in the ring of integers modulo <em>N</em>, 

<math display="inline" id="Secure_Remote_Password_protocol:0">
 <semantics>
  <msub>
   <mi>ℤ</mi>
   <mi>N</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ℤ</ci>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle\mathbb{Z}_{N}
  </annotation>
 </semantics>
</math>

. This means that below <em>g</em><sup>x</sup> should be read as <em>g</em><sup>x</sup><em>mod N</em></li>
<li><em>g</em> is a <a href="Multiplicative_group_of_integers_modulo_n#Generators" title="wikilink">generator of the multiplicative group</a>.</li>
<li><em>H</em>() is a <a href="Cryptographic_hash_function" title="wikilink">hash</a> function; e.g., SHA-256.</li>
<li><em>k</em> is a parameter derived by both sides; in SRP-6, <em>k</em> = 3, while in SRP-6a it is derived from <em>N</em> and <em>g</em> : <em>k</em> = <em>H</em>(<em>N</em>, <em>g</em>). It is used to prevent a 2-for-1 guess when an active attacker impersonates the server.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a><a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></li>
<li><em>s</em> is a small <a href="salt_(cryptography)" title="wikilink">salt</a>.</li>
<li><em>I</em> is an identifying username.</li>
<li><em>p</em> is the user's password.</li>
<li><em>v</em> is the host's password verifier, <em>v</em> = <em>g</em><sup>x</sup> where at a minimum <em>x</em> = <em>H</em>(<em>s</em>, <em>p</em>). As <em>x</em> is only computed on the client it is free to choose a stronger algorithm. Usage of <a href="key_derivation_function" title="wikilink">key derivation functions</a> like <a class="uri" href="PBKDF2" title="wikilink">PBKDF2</a> instead of simple hash functions for <a href="password_hashing" title="wikilink">password hashing</a> is highly recommended [citation needed]. An implementation could choose to use <em>x</em> = <em>H</em>(<em>s</em> | <em>I</em> | <em>p</em>) without effecting any steps required of the host. The standard <a href="http://www.ietf.org/rfc/rfc2945.txt">RFC2945</a> defines <em>x</em> = <em>H</em>(<em>s</em> | <em>H</em> ( <em>I</em> | ":" | <em>p</em>) ). Use of <em>I</em> within <em>x</em> avoids a malicious server from being able to learn if <a href="http://crypto.stackexchange.com/a/9430/13860">two users share the same password</a>.</li>
<li><em>a</em> and <em>b</em> are random one time ephemeral keys of the user and host respectively.</li>
<li>| (pipe) denotes concatenation.</li>
</ul>

<p>All other variables are defined in terms of these.</p>

<p>First, to establish a password <em>p</em> with server Steve, client Carol picks a small random <a href="salt_(cryptography)" title="wikilink">salt</a> <em>s</em>, and computes <em>x</em> = <em>H</em>(<em>s</em>, <em>p</em>), <em>v</em> = <em>g</em><sup>x</sup>. Steve stores <em>v</em> and <em>s</em>, indexed by <em>I</em>, as Carol's password verifier and salt. <em>x</em> is discarded because it is equivalent to the plaintext password <em>p</em>. This step is completed before the system is used as part of the user registration with Steve. Note that the salt "s" is shared and exchanged to negotiate a session key later so the value could be chosen by either side but is done by Carol so that she can register "I", "s" and "v" in a single registration request. (Note server Steve should enforce a uniqueness constraint on all "v" to protect against someone stealing his database observing which users have identical passwords.)</p>

<p>Then to perform a proof of password at a later date the following exchange protocol occurs:</p>
<ol>
<li>Carol → Steve: <em>I</em> and <em>A</em> = <em>g</em><sup>a</sup></li>
<li>Steve → Carol: <em>s</em> and <em>B</em> = <em>kv</em> + <em>g</em><sup>b</sup></li>
<li>Both: <em>u</em> = <em>H</em>(<em>A</em>, <em>B</em>)</li>
<li>Carol: <em>S</em><sub>Carol</sub> = (<em>B</em> − <em>kg</em><sup>x</sup>)<sup>(a + ux)</sup> = (<em>kv</em> + <em>g</em><sup>b</sup> − <em>kg</em><sup>x</sup>)<sup>(a + ux)</sup> = (<em>kg</em><sup>x</sup> − <em>kg</em><sup>x</sup> + <em>g</em><sup>b</sup>)<sup>(a + ux)</sup> = (<em>g</em><sup>b</sup>)<sup>(a + ux)</sup></li>
<li>Carol: <em>K</em><sub>Carol</sub> = <em>H</em>(<em>S</em><sub>Carol</sub>)</li>
<li>Steve: <em>S</em><sub>Steve</sub> = (<em>Av</em><sup>u</sup>)<sup>b</sup> = (<em>g</em><sup>a</sup><em>v</em><sup>u</sup>)<sup>b</sup> = [<em>g</em><sup>a</sup>(<em>g</em><sup>x</sup>)<sup>u</sup>]<sup>b</sup> = (<em>g</em><sup>a + ux</sup>)<sup>b</sup> = (<em>g</em><sup>b</sup>)<sup>(a + ux)</sup></li>
<li>Steve: <em>K</em><sub>Steve</sub> = <em>H</em>(<em>S</em><sub>Steve</sub>) = <em>K</em><sub>Carol</sub></li>
</ol>

<p>Now the two parties have a shared, strong session key <em>K</em>. To complete authentication, they need to prove to each other that their keys match. One possible way is as follows:</p>
<ol>
<li>Carol → Steve: <em>M</em><sub>1</sub> = <em>H</em>[<em>H</em>(<em>N</em>) XOR <em>H</em>(<em>g</em>) | <em>H</em>(<em>I</em>) | <em>s</em> | <em>A</em> | <em>B</em> | <em>K</em><sub>Carol</sub>]. Steve verifies <em>M</em><sub>1</sub>.</li>
<li>Steve → Carol: <em>M</em><sub>2</sub> = <em>H</em>(<em>A</em> | <em>M</em><sub>1</sub> | <em>K</em><sub>Steve</sub>). Carol verifies <em>M</em><sub>2</sub>.</li>
</ol>

<p>This method requires guessing more of the shared state to be successful in impersonation than just the key. While most of the additional state is public, private information could safely be added to the inputs to the hash function, like the server private key.</p>

<p>Alternately in a password only proof the calculation of "K" can be skipped and the shared "S" proven with:</p>
<ol>
<li>Carol → Steve: <em>M</em><sub>1</sub> = <em>H</em>(<em>A</em> | <em>B</em> | <em>S</em><sub>Carol</sub>). Steve verifies <em>M</em><sub>1</sub>.</li>
<li>Steve → Carol: <em>M</em><sub>2</sub> = <em>H</em>(<em>A</em> | <em>M</em><sub>1</sub> | <em>S</em><sub>Steve</sub>). Carol verifies <em>M</em><sub>2</sub>.</li>
</ol>

<p>When using SRP to negotiate a shared key "K" which will be immediately used after the negotiation the verification steps of "M"<sub>1</sub> and "M"<sub>2</sub> may be skipped. The server will reject the very first request from the client which it cannot decrypt.</p>

<p>The two parties also employ the following safeguards:</p>
<ol>
<li>Carol will abort if she receives <em>B</em> == <em>0</em> (mod <em>N</em>) or <em>u</em> == <em>0</em>.</li>
<li>Steve will abort if he receives <em>A</em> (mod <em>N</em>) == 0.</li>
<li>Carol must show her proof of <em>K</em> (or "S") first. If Steve detects that Carol's proof is incorrect, he must abort without showing his own proof of <em>K</em> (or "S")</li>
</ol>
<h3 id="implementation-example-in-python">Implementation example in Python</h3>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="co"># An example SRP authentication</span>
<span class="co"># WARNING: Do not use for real cryptographic purposes beyond testing.</span>
<span class="co"># based on http://srp.stanford.edu/design.html</span>
<span class="im">import</span> hashlib
<span class="im">import</span> random

<span class="kw">def</span> global_print(<span class="op">*</span>names):
    x <span class="op">=</span> <span class="kw">lambda</span> s: [<span class="st">"{}"</span>, <span class="st">"0x{:x}"</span>][<span class="bu">hasattr</span>(s, <span class="st">'real'</span>)].<span class="bu">format</span>(s)
    <span class="bu">print</span>(<span class="st">""</span>.join(<span class="st">"{} = {}</span><span class="ch">\n</span><span class="st">"</span>.<span class="bu">format</span>(name, x(<span class="bu">globals</span>()[name])) <span class="cf">for</span> name <span class="op">in</span> names))

<span class="co"># note: str converts as is, str( [1,2,3,4] ) will convert to "[1,2,3,4]" </span>
<span class="kw">def</span> H(<span class="op">*</span>a):  <span class="co"># a one-way hash function</span>
    a <span class="op">=</span> <span class="st">':'</span>.join([<span class="bu">str</span>(a) <span class="cf">for</span> a <span class="op">in</span> a])
    <span class="cf">return</span> <span class="bu">int</span>(hashlib.sha256(a.encode(<span class="st">'ascii'</span>)).hexdigest(), <span class="dv">16</span>)

<span class="kw">def</span> cryptrand(n<span class="op">=</span><span class="dv">1024</span>):
    <span class="cf">return</span> random.SystemRandom().getrandbits(n) <span class="op">%</span> N

<span class="co"># A large safe prime (N = 2q+1, where q is prime)</span>
<span class="co"># All arithmetic is done modulo N</span>
<span class="co"># (generated using "openssl dhparam -text 1024")</span>
N <span class="op">=</span> <span class="st">'''00:c0:37:c3:75:88:b4:32:98:87:e6:1c:2d:a3:32:</span>
<span class="st">       4b:1b:a4:b8:1a:63:f9:74:8f:ed:2d:8a:41:0c:2f:</span>
<span class="st">       c2:1b:12:32:f0:d3:bf:a0:24:27:6c:fd:88:44:81:</span>
<span class="st">       97:aa:e4:86:a6:3b:fc:a7:b8:bf:77:54:df:b3:27:</span>
<span class="st">       c7:20:1f:6f:d1:7f:d7:fd:74:15:8b:d3:1c:e7:72:</span>
<span class="st">       c9:f5:f8:ab:58:45:48:a9:9a:75:9b:5a:2c:05:32:</span>
<span class="st">       16:2b:7b:62:18:e8:f1:42:bc:e2:c3:0d:77:84:68:</span>
<span class="st">       9a:48:3e:09:5e:70:16:18:43:79:13:a8:c3:9c:3d:</span>
<span class="st">       d0:d4:ca:3c:50:0b:88:5f:e3'''</span>
N <span class="op">=</span> <span class="bu">int</span>(<span class="st">''</span>.join(N.split()).replace(<span class="st">':'</span>, <span class="st">''</span>), <span class="dv">16</span>)
g <span class="op">=</span> <span class="dv">2</span>        <span class="co"># A generator modulo N</span>

k <span class="op">=</span> H(N, g)  <span class="co"># Multiplier parameter (k=3 in legacy SRP-6)</span>

<span class="bu">print</span>(<span class="st">"#. H, N, g, and k are known beforehand to both client and server:"</span>)
global_print(<span class="st">"H"</span>, <span class="st">"N"</span>, <span class="st">"g"</span>, <span class="st">"k"</span>)

<span class="bu">print</span>(<span class="st">"0. server stores (I, s, v) in its password database"</span>)

<span class="co"># the server must first generate the password verifier</span>
I <span class="op">=</span> <span class="st">"person"</span>         <span class="co"># Username</span>
p <span class="op">=</span> <span class="st">"password1234"</span>   <span class="co"># Password</span>
s <span class="op">=</span> cryptrand(<span class="dv">64</span>)    <span class="co"># Salt for the user</span>
x <span class="op">=</span> H(s, I, p)       <span class="co"># Private key</span>
v <span class="op">=</span> <span class="bu">pow</span>(g, x, N)     <span class="co"># Password verifier</span>
global_print(<span class="st">"I"</span>, <span class="st">"p"</span>, <span class="st">"s"</span>, <span class="st">"x"</span>, <span class="st">"v"</span>)

<span class="bu">print</span>(<span class="st">"1. client sends username I and public ephemeral value A to the server"</span>)
a <span class="op">=</span> cryptrand()
A <span class="op">=</span> <span class="bu">pow</span>(g, a, N)
global_print(<span class="st">"I"</span>, <span class="st">"A"</span>)  <span class="co"># client-&gt;server (I, A)</span>

<span class="bu">print</span>(<span class="st">"2. server sends user's salt s and public ephemeral value B to client"</span>)
b <span class="op">=</span> cryptrand()
B <span class="op">=</span> (k <span class="op">*</span> v <span class="op">+</span> <span class="bu">pow</span>(g, b, N)) <span class="op">%</span> N
global_print(<span class="st">"s"</span>, <span class="st">"B"</span>)  <span class="co"># server-&gt;client (s, B)</span>

<span class="bu">print</span>(<span class="st">"3. client and server calculate the random scrambling parameter"</span>)
u <span class="op">=</span> H(A, B)  <span class="co"># Random scrambling parameter</span>
global_print(<span class="st">"u"</span>)

<span class="bu">print</span>(<span class="st">"4. client computes session key"</span>)
x <span class="op">=</span> H(s, I, p)
S_c <span class="op">=</span> <span class="bu">pow</span>(B <span class="op">-</span> k <span class="op">*</span> <span class="bu">pow</span>(g, x, N), a <span class="op">+</span> u <span class="op">*</span> x, N)
K_c <span class="op">=</span> H(S_c)
global_print(<span class="st">"S_c"</span>, <span class="st">"K_c"</span>)

<span class="bu">print</span>(<span class="st">"5. server computes session key"</span>)
S_s <span class="op">=</span> <span class="bu">pow</span>(A <span class="op">*</span> <span class="bu">pow</span>(v, u, N), b, N)
K_s <span class="op">=</span> H(S_s)
global_print(<span class="st">"S_s"</span>, <span class="st">"K_s"</span>)

<span class="bu">print</span>(<span class="st">"6. client sends proof of session key to server"</span>)
M_c <span class="op">=</span> H(H(N) <span class="op">^</span> H(g), H(I), s, A, B, K_c)
global_print(<span class="st">"M_c"</span>)
<span class="co"># client-&gt;server (M_c) ; server verifies M_c</span>

<span class="bu">print</span>(<span class="st">"7. server sends proof of session key to client"</span>)
M_s <span class="op">=</span> H(A, M_c, K_s)
global_print(<span class="st">"M_s"</span>)
<span class="co"># server-&gt;client (M_s) ;  client verifies M_s</span></code></pre></div>
<h3 id="implementations">Implementations</h3>
<ul>
<li><a class="uri" href="OpenSSL" title="wikilink">OpenSSL</a> version 1.0.1 or later.</li>
<li><a class="uri" href="TLS-SRP" title="wikilink">TLS-SRP</a> is a set of ciphersuites for <a href="transport_layer_security" title="wikilink">transport layer security</a> that uses SRP.</li>
<li><a href="https://github.com/symeapp/srp-client">srp-client</a> SRP-6a implementation in <a href="JavaScript" title="wikilink">Javascript</a> (compatible with RFC 5054), open source, <a href="Mozilla_Public_License" title="wikilink">MPL</a> licensed.</li>
<li>The <a href="https://clipperz.is/open_source/javascript_crypto_library">JavaScript Crypto Library</a> includes a JavaScript implementation of the SRP protocol, open source, <a href="Berkeley_Software_Distribution" title="wikilink">BSD</a> licensed.</li>
<li><a href="http://www.gnu.org/software/gnu-crypto/">Gnu Crypto</a> provide a <a href="Java_(programming_language)" title="wikilink">Java</a> implementation licensed under the <a href="GNU_General_Public_License" title="wikilink">GNU General Public License</a> with the "library exception", which permits its use as a library in conjunction with non-Free software.</li>
<li><a href="Bouncy_Castle_(cryptography)" title="wikilink">The Legion of the Bouncy Castle</a> provides Java and <a href="C_Sharp_(programming_language)" title="wikilink">C#</a> implementations under the <a href="MIT_License" title="wikilink">MIT License</a>.</li>
<li><a href="http://connect2id.com/products/nimbus-srp">Nimbus SRP</a> is a Java library providing a verifier generator, client and server-side sessions. Includes interfaces for custom password key, client and server evidence message routines. No external dependencies. Released under the <a href="Apache_License" title="wikilink">Apache 2.0 license</a>.</li>
<li><a href="http://code.google.com/p/srplibcpp/">srplibcpp</a> is a C++ implement base on <a href="MIRACL_(software)" title="wikilink">MIRACL</a>.</li>
<li><a href="https://github.com/slechta/DragonSRP/">DragonSRP</a> is a C++ modular implementation currently works with <a class="uri" href="OpenSSL" title="wikilink">OpenSSL</a></li>
<li><a class="uri" href="Json2Ldap" title="wikilink">Json2Ldap</a> provides SRP-6a authentication to <a href="Lightweight_Directory_Access_Protocol" title="wikilink">LDAP</a> directory servers.</li>
<li><a href="http://code.google.com/p/csrp/">csrp</a> SRP-6a implementation in C.</li>
<li><a href="http://search.cpan.org/~mik/Crypt-SRP/">Crypt-SRP</a> SRP-6a implementation in <a class="uri" href="Perl" title="wikilink">Perl</a>.</li>
<li><a href="http://code.google.com/p/pysrp/">pysrp</a> SRP-6a implementation in <a href="Python_(programming_language)" title="wikilink">Python</a> (compatible with <a href="http://code.google.com/p/csrp/">csrp</a>).</li>
<li><a href="http://meteor.com/">Meteor</a> web framework's Accounts system implements SRP for password authentication.</li>
<li><a href="https://github.com/lamikae/srp-rb">srp-rb</a> SRP-6a implementation in <a href="Ruby_(programming_language)" title="wikilink">Ruby</a></li>
<li><a href="https://github.com/RuslanZavacky/srp-6a-demo">srp-6a-demo</a> SRP-6a implementation in <a href="PHP_(programming_language)" title="wikilink">PHP</a> and <a href="JavaScript_(programming_language)" title="wikilink">JavaScript</a></li>
<li><a href="https://bitbucket.org/simon_massey/thinbus-srp-js">thinbus-srp-js</a> SRP-6a implementation in <a href="JavaScript_(programming_language)" title="wikilink">JavaScript</a>. Comes with compatible <a href="Java_(programming_language)" title="wikilink">Java</a> classes which use <a href="http://software.dzhuvinov.com/nimbus-srp.html">Nimbus SRP</a> a demonstration app using <a href="Spring_Security" title="wikilink">Spring Security</a>. There is also a demonstration application performing authentication to a <a href="PHP_(programming_language)" title="wikilink">PHP</a> server. Released under the <a href="Apache_License" title="wikilink">Apache License</a>.</li>
</ul>
<h2 id="references">References</h2>
<references>
</references>
<h2 id="external-links">External links</h2>
<ul>
<li></li>
<li><a href="http://srp.stanford.edu/license.txt">SRP License</a>—BSD like open source.</li>
<li><a href="http://www.google.com/patents/US6539479">US6539479</a> - SRP Patent (expires July 2018)</li>
</ul>
<h3 id="manual-pages">Manual pages</h3>
<ul>
<li><a href="http://ppp.samba.org/pppd.html">pppd(8)</a>: Point-to-Point Protocol Daemon</li>
<li></li>
</ul>
<h3 id="rfcs">RFCs</h3>
<ul>
<li>RFC 2944 - Telnet Authentication: SRP</li>
<li>RFC 2945 - The SRP Authentication and Key Exchange System</li>
<li>RFC 3720 - Internet Small Computer Systems Interface (iSCSI)</li>
<li>RFC 3723 - Securing Block Storage Protocols over IP</li>
<li>RFC 3669 - Guidelines for Working Groups on Intellectual Property Issues</li>
<li>RFC 5054 - Using the Secure Remote Password (SRP) Protocol for TLS Authentication</li>
</ul>
<h3 id="other-links">Other links</h3>
<ul>
<li><a href="http://grouper.ieee.org/groups/1363/">IEEE 1363</a></li>
<li><a href="http://www.pdl.cmu.edu/mailinglists/ips/mail/msg08027.html">SRP Intellectual Property Slides (Dec 2001 - possible deprecated)</a> The EKE patents mentioned expired in 2011 and 2013.</li>
</ul>

<p>"</p>

<p><a href="Category:Key-agreement_protocols" title="wikilink">Category:Key-agreement protocols</a> <a href="Category:Password_authentication" title="wikilink">Category:Password authentication</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"> RFC 5054<a href="#fnref2">↩</a></li>
<li id="fn3"> Draft.<a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
</ol>
</section>
</body>

