<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="250">Duality (optimization)</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Duality (optimization)</h1>
<hr/>

<p>In <a href="mathematical_optimization" title="wikilink">mathematical optimization</a> theory, <strong>duality</strong> means that <a href="optimization_problem" title="wikilink">optimization problems</a> may be viewed from either of two perspectives, the primal problem or the dual problem (the <strong>duality principle</strong>). The solution to the dual problem provides a lower bound to the solution of the primal (minimization) problem.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> However in general the optimal values of the primal and dual problems need not be equal. Their difference is called the <a href="duality_gap" title="wikilink">duality gap</a>. For <a href="convex_optimization" title="wikilink">convex optimization</a> problems, the duality gap is zero under a <a href="constraint_qualification" title="wikilink">constraint qualification</a> condition. Thus, a solution to the dual problem provides a bound on the value of the solution to the primal problem; when the problem is convex and satisfies a constraint qualification, then the value of an optimal solution of the primal problem is given by the dual problem.</p>
<h2 id="dual-problem">Dual problem</h2>

<p>Usually dual problem refers to the <em><a href="Lagrangian_dual_problem" title="wikilink">Lagrangian dual problem</a></em> but other dual problems are used, for example, the <a href="Wolfe_dual_problem" title="wikilink">Wolfe dual problem</a> and the <a href="Fenchel's_duality_theorem" title="wikilink">Fenchel dual problem</a>. The Lagrangian dual problem is obtained by forming the <a href="Lagrange_multiplier" title="wikilink">Lagrangian</a>, using nonnegative <a href="Lagrange_multiplier" title="wikilink">Lagrange multipliers</a> to add the constraints to the objective function, and then solving for some primal variable values that minimize the Lagrangian. This solution gives the primal variables as functions of the Lagrange multipliers, which are called dual variables, so that the new problem is to maximize the objective function with respect to the dual variables under the derived constraints on the dual variables (including at least the nonnegativity).</p>

<p>In general given two <a href="dual_pair" title="wikilink">dual pairs</a> of <a href="separated_space" title="wikilink">separated</a> <a href="locally_convex_space" title="wikilink">locally convex spaces</a> 

<math display="inline" id="Duality_(optimization):0">
 <semantics>
  <mrow>
   <mo>(</mo>
   <mi>X</mi>
   <mo>,</mo>
   <msup>
    <mi>X</mi>
    <mo>*</mo>
   </msup>
   <mo>)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>X</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>X</ci>
     <times></times>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left(X,X^{*}\right)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Duality_(optimization):1">
 <semantics>
  <mrow>
   <mo>(</mo>
   <mi>Y</mi>
   <mo>,</mo>
   <msup>
    <mi>Y</mi>
    <mo>*</mo>
   </msup>
   <mo>)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>Y</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>Y</ci>
     <times></times>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left(Y,Y^{*}\right)
  </annotation>
 </semantics>
</math>

 and the function 

<math display="inline" id="Duality_(optimization):2">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mo>:</mo>
   <mrow>
    <mi>X</mi>
    <mo>→</mo>
    <mrow>
     <mi>ℝ</mi>
     <mo>∪</mo>
     <mrow>
      <mo stretchy="false">{</mo>
      <mrow>
       <mo>+</mo>
       <mi mathvariant="normal">∞</mi>
      </mrow>
      <mo stretchy="false">}</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>f</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>X</ci>
     <apply>
      <union></union>
      <ci>ℝ</ci>
      <set>
       <apply>
        <plus></plus>
        <infinity></infinity>
       </apply>
      </set>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f:X\to\mathbb{R}\cup\{+\infty\}
  </annotation>
 </semantics>
</math>

, we can define the primal problem as finding 

<math display="inline" id="Duality_(optimization):3">
 <semantics>
  <mover accent="true">
   <mi>x</mi>
   <mo stretchy="false">^</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-^</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{x}
  </annotation>
 </semantics>
</math>


 such that 

<math display="inline" id="Duality_(optimization):4">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mover accent="true">
       <mi>x</mi>
       <mo stretchy="false">^</mo>
      </mover>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msub>
      <mo>inf</mo>
      <mrow>
       <mi>x</mi>
       <mo>∈</mo>
       <mi>X</mi>
      </mrow>
     </msub>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <apply>
      <ci>normal-^</ci>
      <ci>x</ci>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">infimum</csymbol>
      <apply>
       <in></in>
       <ci>x</ci>
       <ci>X</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(\hat{x})=\inf_{x\in X}f(x).\,
  </annotation>
 </semantics>
</math>

 In other words, 

<math display="inline" id="Duality_(optimization):5">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mover accent="true">
     <mi>x</mi>
     <mo stretchy="false">^</mo>
    </mover>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <apply>
     <ci>normal-^</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(\hat{x})
  </annotation>
 </semantics>
</math>

 is the <a class="uri" href="infimum" title="wikilink">infimum</a> (greatest lower bound) of the function 

<math display="inline" id="Duality_(optimization):6">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

.</p>

<p>If there are constraint conditions, these can be built into the function 

<math display="inline" id="Duality_(optimization):7">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 by letting 

<math display="inline" id="Duality_(optimization):8">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>f</mi>
    <mo stretchy="false">~</mo>
   </mover>
   <mo>=</mo>
   <mrow>
    <mi>f</mi>
    <mo>+</mo>
    <msub>
     <mi>I</mi>
     <mi>constraints</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>normal-~</ci>
     <ci>f</ci>
    </apply>
    <apply>
     <plus></plus>
     <ci>f</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>I</ci>
      <ci>constraints</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tilde{f}=f+I_{\mathrm{constraints}}
  </annotation>
 </semantics>
</math>


 where 

<math display="inline" id="Duality_(optimization):9">
 <semantics>
  <mi>I</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>I</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I
  </annotation>
 </semantics>
</math>

 is the <a href="Characteristic_function_(convex_analysis)" title="wikilink">indicator function</a>. Then let 

<math display="inline" id="Duality_(optimization):10">
 <semantics>
  <mrow>
   <mi>F</mi>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mi>X</mi>
     <mo>×</mo>
     <mi>Y</mi>
    </mrow>
    <mo>→</mo>
    <mrow>
     <mi>ℝ</mi>
     <mo>∪</mo>
     <mrow>
      <mo stretchy="false">{</mo>
      <mrow>
       <mo>+</mo>
       <mi mathvariant="normal">∞</mi>
      </mrow>
      <mo stretchy="false">}</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>F</ci>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <times></times>
      <ci>X</ci>
      <ci>Y</ci>
     </apply>
     <apply>
      <union></union>
      <ci>ℝ</ci>
      <set>
       <apply>
        <plus></plus>
        <infinity></infinity>
       </apply>
      </set>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F:X\times Y\to\mathbb{R}\cup\{+\infty\}
  </annotation>
 </semantics>
</math>

 be a <a href="perturbation_function" title="wikilink">perturbation function</a> such that 

<math display="inline" id="Duality_(optimization):11">
 <semantics>
  <mrow>
   <mrow>
    <mi>F</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mn>0</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mover accent="true">
     <mi>f</mi>
     <mo stretchy="false">~</mo>
    </mover>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>F</ci>
     <interval closure="open">
      <ci>x</ci>
      <cn type="integer">0</cn>
     </interval>
    </apply>
    <apply>
     <times></times>
     <apply>
      <ci>normal-~</ci>
      <ci>f</ci>
     </apply>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F(x,0)=\tilde{f}(x)
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>

<p>The <a href="duality_gap" title="wikilink">duality gap</a> is the difference of the right and left hand sides of the inequality</p>

<p>

<math display="block" id="Duality_(optimization):12">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <munder>
      <mo movablelimits="false">sup</mo>
      <mrow>
       <msup>
        <mi>y</mi>
        <mo>*</mo>
       </msup>
       <mo>∈</mo>
       <msup>
        <mi>Y</mi>
        <mo>*</mo>
       </msup>
      </mrow>
     </munder>
     <mo>-</mo>
     <mrow>
      <msup>
       <mi>F</mi>
       <mo>*</mo>
      </msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mn>0</mn>
       <mo>,</mo>
       <msup>
        <mi>y</mi>
        <mo>*</mo>
       </msup>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>≤</mo>
    <mrow>
     <munder>
      <mo movablelimits="false">inf</mo>
      <mrow>
       <mi>x</mi>
       <mo>∈</mo>
       <mi>X</mi>
      </mrow>
     </munder>
     <mrow>
      <mi>F</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo>,</mo>
       <mn>0</mn>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">supremum</csymbol>
      <apply>
       <in></in>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>y</ci>
        <times></times>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>Y</ci>
        <times></times>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>F</ci>
       <times></times>
      </apply>
      <interval closure="open">
       <cn type="integer">0</cn>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>y</ci>
        <times></times>
       </apply>
      </interval>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">infimum</csymbol>
      <apply>
       <in></in>
       <ci>x</ci>
       <ci>X</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>F</ci>
      <interval closure="open">
       <ci>x</ci>
       <cn type="integer">0</cn>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sup_{y^{*}\in Y^{*}}-F^{*}(0,y^{*})\leq\inf_{x\in X}F(x,0),\,
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Duality_(optimization):13">
 <semantics>
  <msup>
   <mi>F</mi>
   <mo>*</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>F</ci>
    <times></times>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F^{*}
  </annotation>
 </semantics>
</math>


 is the <a href="convex_conjugate" title="wikilink">convex conjugate</a> in both variables and 

<math display="inline" id="Duality_(optimization):14">
 <semantics>
  <mo>sup</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">supremum</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sup
  </annotation>
 </semantics>
</math>

 denotes the <a class="uri" href="supremum" title="wikilink">supremum</a> (least upper bound).<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a><a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a><a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>
<h3 id="duality-gap">Duality gap</h3>

<p>The duality gap is the difference between the values of any primal solutions and any dual solutions. If 

<math display="inline" id="Duality_(optimization):15">
 <semantics>
  <msup>
   <mi>d</mi>
   <mo>*</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>d</ci>
    <times></times>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d^{*}
  </annotation>
 </semantics>
</math>

 is the optimal dual value and 

<math display="inline" id="Duality_(optimization):16">
 <semantics>
  <msup>
   <mi>p</mi>
   <mo>*</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>p</ci>
    <times></times>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p^{*}
  </annotation>
 </semantics>
</math>

 is the optimal primal value, then the duality gap is equal to 

<math display="inline" id="Duality_(optimization):17">
 <semantics>
  <mrow>
   <msup>
    <mi>p</mi>
    <mo>*</mo>
   </msup>
   <mo>-</mo>
   <msup>
    <mi>d</mi>
    <mo>*</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>p</ci>
     <times></times>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>d</ci>
     <times></times>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p^{*}-d^{*}
  </annotation>
 </semantics>
</math>

. This value is always greater than or equal to 0. The duality gap is zero if and only if <a href="strong_duality" title="wikilink">strong duality</a> holds. Otherwise the gap is strictly positive and <a href="weak_duality" title="wikilink">weak duality</a> holds.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>

<p>In computational optimization, another "duality gap" is often reported, which is the difference in value between any dual solution and the value of a feasible but suboptimal iterate for the primal problem. This alternative "duality gap" quantifies the discrepancy between the value of a current feasible but suboptimal iterate for the primal problem and the value of the dual problem; the value of the dual problem is, under regularity conditions, equal to the value of the <em><a href="convex_relaxation" title="wikilink">convex relaxation</a></em> of the primal problem: The convex relaxation is the problem arising replacing a non-convex feasible set with its closed <a href="convex_hull" title="wikilink">convex hull</a> and with replacing a non-convex function with its convex <a href="lower_semi-continuous" title="wikilink">closure</a>, that is the function that has the <a href="epigraph_(mathematics)" title="wikilink">epigraph</a> that is the closed convex hull of the original primal objective function.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> <a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a><a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a><a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> <a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> <a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> <a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> <a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a> <a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a> <a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a><a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a></p>
<h2 id="the-linear-case">The linear case</h2>

<p><a href="Linear_programming" title="wikilink">Linear programming</a> problems are <a href="optimization_(mathematics)" title="wikilink">optimization</a> problems in which the <a href="objective_function" title="wikilink">objective function</a> and the <a href="Constraint_(mathematics)" title="wikilink">constraints</a> are all <a class="uri" href="linear" title="wikilink">linear</a>. In the primal problem, the objective function is a linear combination of <em>n</em> variables. There are <em>m</em> constraints, each of which places an upper bound on a linear combination of the <em>n</em> variables. The goal is to maximize the value of the objective function subject to the constraints. A <em>solution</em> is a <a href="List_(computing)" title="wikilink">vector</a> (a list) of <em>n</em> values that achieves the maximum value for the objective function.</p>

<p>In the dual problem, the objective function is a linear combination of the <em>m</em> values that are the limits in the <em>m</em> constraints from the primal problem. There are <em>n</em> dual constraints, each of which places a lower bound on a linear combination of <em>m</em> dual variables.</p>
<h3 id="relationship-between-the-primal-problem-and-the-dual-problem">Relationship between the primal problem and the dual problem</h3>

<p>In the linear case, in the primal problem, from each sub-optimal point that satisfies all the constraints, there is a direction or <a href="linear_subspace" title="wikilink">subspace</a> of directions to move that increases the objective function. Moving in any such direction is said to remove slack between the candidate solution and one or more constraints. An <em>infeasible</em> value of the candidate solution is one that exceeds one or more of the constraints.</p>

<p>In the dual problem, the dual vector multiplies the constants that determine the positions of the constraints in the primal. Varying the dual vector in the dual problem is equivalent to revising the upper bounds in the primal problem. The lowest upper bound is sought. That is, the dual vector is minimized in order to remove slack between the candidate positions of the constraints and the actual optimum. An infeasible value of the dual vector is one that is too low. It sets the candidate positions of one or more of the constraints in a position that excludes the actual optimum.</p>

<p>This intuition is made formal by the equations in <a href="Linear_programming#Duality" title="wikilink">Linear programming: Duality</a>.</p>

<p>An interesting example is the shortest path problem. The shortest path problem in a positively weighted graph can be formulated as a special minimum cost flow problem, which is in primal form. And the well-known <a href="Dijkstra's_algorithm" title="wikilink">Dijkstra's algorithm</a> is the primal-dual algorithm that solves the dual form and starts from zeros. Ye <em>et al</em>. pointed out that the popular <a href="A*_algorithm" title="wikilink">A* algorithm</a> is also the primal-dual algorithm that solves the dual form. But it starts from -h, where h &gt; 0 is the consistent heuristic. Hence one explanation that the A* algorithm is more efficient than the Dijkstra's algorithm is that as initial solution, h is better than 0.</p>
<h3 id="economic-interpretation">Economic interpretation</h3>

<p>If we interpret our primal LP problem as a classical "Resource Allocation" problem, its dual can be interpreted as a "Resource Valuation" problem.</p>
<h2 id="the-non-linear-case">The non-linear case</h2>

<p>In <a href="non-linear_programming" title="wikilink">non-linear programming</a>, the constraints are not necessarily linear. Nonetheless, many of the same principles apply.</p>

<p>To ensure that the global maximum of a non-linear problem can be identified easily, the problem formulation often requires that the functions be convex and have compact lower level sets.</p>

<p>This is the significance of the <a href="Karush–Kuhn–Tucker_conditions" title="wikilink">Karush–Kuhn–Tucker conditions</a>. They provide necessary conditions for identifying local optima of non-linear programming problems. There are additional conditions (constraint qualifications) that are necessary so that it will be possible to define the direction to an <em>optimal</em> solution. An optimal solution is one that is a local optimum, but possibly not a global optimum.</p>
<h3 id="the-strong-lagrangian-principle-lagrange-duality">The strong Lagrangian principle: Lagrange duality </h3>

<p>Given a <a href="nonlinear_programming" title="wikilink">nonlinear programming</a> problem in standard form</p>

<p>

<math display="inline" id="Duality_(optimization):18">
 <semantics>
  <mrow>
   <mi>f</mi>
   <msub>
    <mo>;</mo>
    <mn>0</mn>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">f</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-;</ci>
     <cn type="integer">0</cn>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle f;_{0}(x)
  </annotation>
 </semantics>
</math>


</p>

<p>with the domain 

<math display="inline" id="Duality_(optimization):19">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">𝒟</mi>
   <mo>⊂</mo>
   <msup>
    <mi>ℝ</mi>
    <mi>n</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <ci>𝒟</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ℝ</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{D}\subset\mathbb{R}^{n}
  </annotation>
 </semantics>
</math>

 having non-empty interior, the <em>Lagrangian function</em> 

<math display="inline" id="Duality_(optimization):20">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Λ</mi>
   <mo>:</mo>
   <mrow>
    <mrow>
     <msup>
      <mi>ℝ</mi>
      <mi>n</mi>
     </msup>
     <mo>×</mo>
     <msup>
      <mi>ℝ</mi>
      <mi>m</mi>
     </msup>
     <mo>×</mo>
     <msup>
      <mi>ℝ</mi>
      <mi>p</mi>
     </msup>
    </mrow>
    <mo>→</mo>
    <mi>ℝ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>normal-Λ</ci>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>ℝ</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>ℝ</ci>
       <ci>m</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>ℝ</ci>
       <ci>p</ci>
      </apply>
     </apply>
     <ci>ℝ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Lambda:\mathbb{R}^{n}\times\mathbb{R}^{m}\times\mathbb{R}^{p}\to\mathbb{R}
  </annotation>
 </semantics>
</math>

 is defined as</p>

<p>

<math display="block" id="Duality_(optimization):21">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi mathvariant="normal">Λ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mi>λ</mi>
      <mo>,</mo>
      <mi>ν</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <msub>
       <mi>f</mi>
       <mn>0</mn>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mrow>
      <munderover>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mrow>
        <mi>i</mi>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <mi>m</mi>
      </munderover>
      <mrow>
       <msub>
        <mi>λ</mi>
        <mi>i</mi>
       </msub>
       <msub>
        <mi>f</mi>
        <mi>i</mi>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mrow>
      <munderover>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mrow>
        <mi>i</mi>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <mi>p</mi>
      </munderover>
      <mrow>
       <msub>
        <mi>ν</mi>
        <mi>i</mi>
       </msub>
       <msub>
        <mi>h</mi>
        <mi>i</mi>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>normal-Λ</ci>
     <vector>
      <ci>x</ci>
      <ci>λ</ci>
      <ci>ν</ci>
     </vector>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>f</ci>
       <cn type="integer">0</cn>
      </apply>
      <ci>x</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>m</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>λ</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>f</ci>
        <ci>i</ci>
       </apply>
       <ci>x</ci>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>p</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ν</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>h</ci>
        <ci>i</ci>
       </apply>
       <ci>x</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Lambda(x,\lambda,\nu)=f_{0}(x)+\sum_{i=1}^{m}\lambda_{i}f_{i}(x)+\sum_{i=1}^{%
p}\nu_{i}h_{i}(x).
  </annotation>
 </semantics>
</math>

</p>

<p>The vectors 

<math display="inline" id="Duality_(optimization):22">
 <semantics>
  <mi>λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Duality_(optimization):23">
 <semantics>
  <mi>ν</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ν</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \nu
  </annotation>
 </semantics>
</math>

 are called the <em>dual variables</em> or <em>Lagrange multiplier vectors</em> associated with the problem. The <em>Lagrange dual function</em> 

<math display="inline" id="Duality_(optimization):24">
 <semantics>
  <mrow>
   <mi>g</mi>
   <mo>:</mo>
   <mrow>
    <mrow>
     <msup>
      <mi>ℝ</mi>
      <mi>m</mi>
     </msup>
     <mo>×</mo>
     <msup>
      <mi>ℝ</mi>
      <mi>p</mi>
     </msup>
    </mrow>
    <mo>→</mo>
    <mi>ℝ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>g</ci>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>ℝ</ci>
       <ci>m</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>ℝ</ci>
       <ci>p</ci>
      </apply>
     </apply>
     <ci>ℝ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g:\mathbb{R}^{m}\times\mathbb{R}^{p}\to\mathbb{R}
  </annotation>
 </semantics>
</math>

 is defined as</p>

<p>

<math display="block" id="Duality_(optimization):25">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>g</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>λ</mi>
      <mo>,</mo>
      <mi>ν</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <munder>
      <mo movablelimits="false">inf</mo>
      <mrow>
       <mi>x</mi>
       <mo>∈</mo>
       <mi class="ltx_font_mathcaligraphic">𝒟</mi>
      </mrow>
     </munder>
     <mrow>
      <mi mathvariant="normal">Λ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo>,</mo>
       <mi>λ</mi>
       <mo>,</mo>
       <mi>ν</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <munder>
      <mo movablelimits="false">inf</mo>
      <mrow>
       <mi>x</mi>
       <mo>∈</mo>
       <mi class="ltx_font_mathcaligraphic">𝒟</mi>
      </mrow>
     </munder>
     <mrow>
      <mo>(</mo>
      <mrow>
       <mrow>
        <msub>
         <mi>f</mi>
         <mn>0</mn>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>x</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>+</mo>
       <mrow>
        <munderover>
         <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
         <mrow>
          <mi>i</mi>
          <mo>=</mo>
          <mn>1</mn>
         </mrow>
         <mi>m</mi>
        </munderover>
        <mrow>
         <msub>
          <mi>λ</mi>
          <mi>i</mi>
         </msub>
         <msub>
          <mi>f</mi>
          <mi>i</mi>
         </msub>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>x</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
       <mo>+</mo>
       <mrow>
        <munderover>
         <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
         <mrow>
          <mi>i</mi>
          <mo>=</mo>
          <mn>1</mn>
         </mrow>
         <mi>p</mi>
        </munderover>
        <mrow>
         <msub>
          <mi>ν</mi>
          <mi>i</mi>
         </msub>
         <msub>
          <mi>h</mi>
          <mi>i</mi>
         </msub>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>x</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
      </mrow>
      <mo>)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>g</ci>
      <interval closure="open">
       <ci>λ</ci>
       <ci>ν</ci>
      </interval>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <csymbol cd="latexml">infimum</csymbol>
       <apply>
        <in></in>
        <ci>x</ci>
        <ci>𝒟</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>normal-Λ</ci>
       <vector>
        <ci>x</ci>
        <ci>λ</ci>
        <ci>ν</ci>
       </vector>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <csymbol cd="latexml">infimum</csymbol>
       <apply>
        <in></in>
        <ci>x</ci>
        <ci>𝒟</ci>
       </apply>
      </apply>
      <apply>
       <plus></plus>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>f</ci>
         <cn type="integer">0</cn>
        </apply>
        <ci>x</ci>
       </apply>
       <apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <sum></sum>
          <apply>
           <eq></eq>
           <ci>i</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
         <ci>m</ci>
        </apply>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>λ</ci>
          <ci>i</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>f</ci>
          <ci>i</ci>
         </apply>
         <ci>x</ci>
        </apply>
       </apply>
       <apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <sum></sum>
          <apply>
           <eq></eq>
           <ci>i</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
         <ci>p</ci>
        </apply>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>ν</ci>
          <ci>i</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>h</ci>
          <ci>i</ci>
         </apply>
         <ci>x</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g(\lambda,\nu)=\inf_{x\in\mathcal{D}}\Lambda(x,\lambda,\nu)=\inf_{x\in\mathcal%
{D}}\left(f_{0}(x)+\sum_{i=1}^{m}\lambda_{i}f_{i}(x)+\sum_{i=1}^{p}\nu_{i}h_{i%
}(x)\right).
  </annotation>
 </semantics>
</math>

</p>

<p>The dual function <em>g</em> is concave, even when the initial problem is not convex, because it is a point-wise infimum of affine functions. The dual function yields lower bounds on the optimal value 

<math display="inline" id="Duality_(optimization):26">
 <semantics>
  <msup>
   <mi>p</mi>
   <mo>*</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>p</ci>
    <times></times>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p^{*}
  </annotation>
 </semantics>
</math>

 of the initial problem; for any 

<math display="inline" id="Duality_(optimization):27">
 <semantics>
  <mrow>
   <mi>λ</mi>
   <mo>≥</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <ci>λ</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda\geq 0
  </annotation>
 </semantics>
</math>

 and any 

<math display="inline" id="Duality_(optimization):28">
 <semantics>
  <mi>ν</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ν</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \nu
  </annotation>
 </semantics>
</math>

 we have 

<math display="inline" id="Duality_(optimization):29">
 <semantics>
  <mrow>
   <mrow>
    <mi>g</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mo>,</mo>
     <mi>ν</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <msup>
    <mi>p</mi>
    <mo>*</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <times></times>
     <ci>g</ci>
     <interval closure="open">
      <ci>λ</ci>
      <ci>ν</ci>
     </interval>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>p</ci>
     <times></times>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g(\lambda,\nu)\leq p^{*}
  </annotation>
 </semantics>
</math>

.</p>

<p>If a <a href="constraint_qualification" title="wikilink">constraint qualification</a> such as <a href="Slater's_condition" title="wikilink">Slater's condition</a> holds and the original problem is convex, then we have <a href="strong_duality" title="wikilink">strong duality</a>, i.e. 

<math display="inline" id="Duality_(optimization):30">
 <semantics>
  <mrow>
   <msup>
    <mi>d</mi>
    <mo>*</mo>
   </msup>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>max</mi>
      <mrow>
       <mi>λ</mi>
       <mo>≥</mo>
       <mrow>
        <mn>0</mn>
        <mo>,</mo>
        <mi>ν</mi>
       </mrow>
      </mrow>
     </msub>
     <mi>g</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mo>,</mo>
     <mi>ν</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>inf</mo>
    <msub>
     <mi>f</mi>
     <mn>0</mn>
    </msub>
   </mrow>
   <mo>=</mo>
   <msup>
    <mi>p</mi>
    <mo>*</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>d</ci>
      <times></times>
     </apply>
     <apply>
      <times></times>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <max></max>
        <apply>
         <geq></geq>
         <ci>λ</ci>
         <list>
          <cn type="integer">0</cn>
          <ci>ν</ci>
         </list>
        </apply>
       </apply>
       <ci>g</ci>
      </apply>
      <interval closure="open">
       <ci>λ</ci>
       <ci>ν</ci>
      </interval>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="latexml">infimum</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>f</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>p</ci>
      <times></times>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d^{*}=\max_{\lambda\geq 0,\nu}g(\lambda,\nu)=\inf f_{0}=p^{*}
  </annotation>
 </semantics>
</math>

.</p>
<h3 id="convex-problems">Convex problems</h3>

<p>For a convex minimization problem with inequality constraints,</p>

<p>

<math display="inline" id="Duality_(optimization):31">
 <semantics>
  <munder accentunder="true">
   <mo>minimize</mo>
   <mo>𝑥</mo>
  </munder>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>x</ci>
    <ci>minimize</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle\underset{x}{\operatorname{minimize}}
  </annotation>
 </semantics>
</math>


 the Lagrangian dual problem is</p>

<p>

<math display="inline" id="Duality_(optimization):32">
 <semantics>
  <munder accentunder="true">
   <mo>maximize</mo>
   <mo>𝑢</mo>
  </munder>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>u</ci>
    <ci>maximize</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle\underset{u}{\operatorname{maximize}}
  </annotation>
 </semantics>
</math>


 where the objective function is the Lagrange dual function. Provided that the functions 

<math display="inline" id="Duality_(optimization):33">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Duality_(optimization):34">
 <semantics>
  <mrow>
   <msub>
    <mi>g</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">⋯</mi>
   <mo>,</mo>
   <msub>
    <mi>g</mi>
    <mi>m</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>g</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-⋯</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>g</ci>
     <ci>m</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g_{1},\cdots,g_{m}
  </annotation>
 </semantics>
</math>

 are continuously differentiable, the infimum occurs where the gradient is equal to zero. The problem</p>

<p>

<math display="inline" id="Duality_(optimization):35">
 <semantics>
  <munder accentunder="true">
   <mo>maximize</mo>
   <mrow>
    <mi>x</mi>
    <mo>,</mo>
    <mi>u</mi>
   </mrow>
  </munder>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <list>
     <ci>x</ci>
     <ci>u</ci>
    </list>
    <ci>maximize</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle\underset{x,u}{\operatorname{maximize}}
  </annotation>
 </semantics>
</math>


 is called the Wolfe dual problem. This problem may be difficult to deal with computationally, because the objective function is not concave in the joint variables 

<math display="inline" id="Duality_(optimization):36">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>u</mi>
   <mo>,</mo>
   <mi>x</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>u</ci>
    <ci>x</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (u,x)
  </annotation>
 </semantics>
</math>

. Also, the equality constraint 

<math display="inline" id="Duality_(optimization):37">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>∇</mo>
     <mi>f</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>+</mo>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∑</mo>
     <mrow>
      <mi>j</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>m</mi>
    </msubsup>
    <mrow>
     <msub>
      <mi>u</mi>
      <mi>j</mi>
     </msub>
     <mrow>
      <mo>∇</mo>
      <msub>
       <mi>g</mi>
       <mi>j</mi>
      </msub>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <times></times>
     <apply>
      <ci>normal-∇</ci>
      <ci>f</ci>
     </apply>
     <ci>x</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>j</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>m</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>u</ci>
       <ci>j</ci>
      </apply>
      <apply>
       <ci>normal-∇</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>g</ci>
        <ci>j</ci>
       </apply>
      </apply>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \nabla f(x)+\sum_{j=1}^{m}u_{j}\nabla g_{j}(x)
  </annotation>
 </semantics>
</math>

 is nonlinear in general, so the Wolfe dual problem is typically a nonconvex optimization problem. In any case, <a href="weak_duality" title="wikilink">weak duality</a> holds.<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a></p>
<h2 id="history">History</h2>

<p>According to <a href="George_Dantzig" title="wikilink">George Dantzig</a>, the duality theorem for linear optimization was conjectured by <a href="John_von_Neumann" title="wikilink">John von Neumann</a> immediately after Dantzig presented the linear programming problem. Von Neumann noted that he was using information from his <a href="game_theory" title="wikilink">game theory</a>, and conjectured that two person zero sum matrix game was equivalent to linear programming. Rigorous proofs were first published in 1948 by <a href="Albert_W._Tucker" title="wikilink">Albert W. Tucker</a> and his group. (Dantzig's foreword to Nering and Tucker, 1993)</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Duality_(mathematics)" title="wikilink">Duality</a></li>
<li><a href="Relaxation_(approximation)" title="wikilink">Relaxation (approximation)</a></li>
</ul>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<h3 id="books">Books</h3>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
<h3 id="articles">Articles</h3>
<ul>
<li></li>
<li></li>
<li><a href="http://www.civilized.com/files/duality.pdf">Duality in Linear Programming</a> Gary D. Knott</li>
<li></li>
</ul>

<p><a class="uri" href="de:Lagrange-Dualität" title="wikilink">de:Lagrange-Dualität</a>"</p>

<p><a href="Category:Mathematical_optimization" title="wikilink">Category:Mathematical optimization</a> <a href="Category:Linear_programming" title="wikilink">Category:Linear programming</a> <a href="Category:Convex_optimization" title="wikilink">Category:Convex optimization</a> <a href="Category:Mathematical_and_quantitative_methods_(economics)" title="wikilink">Category:Mathematical and quantitative methods (economics)</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
<li id="fn10"><a href="#fnref10">↩</a></li>
<li id="fn11"><a href="#fnref11">↩</a></li>
<li id="fn12"><a href="#fnref12">↩</a></li>
<li id="fn13"><a href="#fnref13">↩</a></li>
<li id="fn14"><a href="#fnref14">↩</a></li>
<li id="fn15"><a href="#fnref15">↩</a></li>
<li id="fn16"><a href="#fnref16">↩</a></li>
<li id="fn17"><a href="#fnref17">↩</a></li>
<li id="fn18"><a href="#fnref18">↩</a></li>
</ol>
</section>
</body>
</html>
