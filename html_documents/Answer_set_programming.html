<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="609">Answer set programming</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Answer set programming</h1>
<style>
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
<style>
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
</body></html>
<body>
<hr/>

<p><strong>Answer set programming</strong> (ASP) is a form of <a href="declarative_programming" title="wikilink">declarative programming</a> oriented towards difficult (primarily <a class="uri" href="NP-hard" title="wikilink">NP-hard</a>) <a href="search_algorithm" title="wikilink">search problems</a>. It is based on the <a href="stable_model_semantics" title="wikilink">stable model</a> (answer set) semantics of <a href="logic_programming" title="wikilink">logic programming</a>. In ASP, search problems are reduced to computing stable models, and <em>answer set solvers</em> — programs for generating stable models—are used to perform search. The computational process employed in the design of many answer set solvers is an enhancement of the <a href="DPLL_algorithm" title="wikilink">DPLL algorithm</a> and, in principle, it always terminates (unlike <a class="uri" href="Prolog" title="wikilink">Prolog</a> query evaluation, which may lead to an <a href="infinite_loop" title="wikilink">infinite loop</a>).</p>

<p>In a more general sense, ASP includes all applications of answer sets to <a href="knowledge_representation" title="wikilink">knowledge representation</a><a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a><a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> and the use of Prolog-style query evaluation for solving problems arising in these applications.</p>
<h2 id="history">History</h2>

<p>The <a href="Automated_planning_and_scheduling" title="wikilink">planning</a> method proposed in 1993 by Dimopoulos, Nebel and Köhler<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> is an early example of answer set programming. Their approach is based on the relationship between plans and stable models.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> Soininen and Niemelä<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> applied what is now known as answer set programming to the problem of product configuration. The use of answer set solvers for search was identified as a new programming paradigm by Marek and Truszczyński in a paper that appeared in a 25-year perspective on the logic programming paradigm published in 1999 <a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> and in [Niemelä 1999].<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> Indeed, the new terminology of "answer set" instead of "stable model" was first proposed by Lifschitz<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> in a paper appearing in the same retrospective volume as the Marek-Truszczynski paper.</p>
<h2 id="answer-set-programming-language-ansprolog">Answer set programming language AnsProlog</h2>

<p><a href="http://www.tcs.hut.fi/Software/smodels/lparse.ps">Lparse</a> is the name of the program that was originally created as grounding tool (front-end) for the answer set solver <a href="http://www.tcs.hut.fi/Software/smodels/">smodels</a>. The language that Lparse accepts is now commonly called AnsProlog*,<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> short for <em>Answer Set Programming in Logic</em>.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> It is now used in the same way in many other answer set solvers, including <a href="http://assat.cs.ust.hk/">assat</a>, <a href="http://www.cs.uni-potsdam.de/clasp/">clasp</a>, <a href="http://www.cs.utexas.edu/users/tag/cmodels/">cmodels</a>, <a href="http://www.tcs.hut.fi/Software/gnt/">gNt</a>, <a href="http://www.cs.uni-potsdam.de/nomore/">nomore++</a> and <a href="http://www.cs.uky.edu/ai/pbmodels/">pbmodels</a>. (<a href="http://www.dbai.tuwien.ac.at/proj/dlv/">dlv</a> is an exception; the syntax of ASP programs written for dlv is somewhat different.)</p>

<p>An AnsProlog program consists of rules of the form</p>
<div class="sourceCode"><pre class="sourceCode prolog"><code class="sourceCode prolog"><span class="dt">&lt;</span>head<span class="er">&gt;</span> <span class="kw">:-</span> <span class="dt">&lt;</span>body<span class="er">&gt;</span> <span class="kw">.</span>
</code></pre></div></body>&gt;


<p>The symbol <code>:-</code> ("if") is dropped if <code><body></body></code> is empty; such rules are called <em>facts</em>. The simplest kind of Lparse rules are <a href="Stable_model_semantics#Programs_with_constraints" title="wikilink">rules with constraints</a>.</p>

<p>One other useful construct included in this language is <em>choice</em>. For instance, the choice rule</p>
<div class="sourceCode"><pre class="sourceCode prolog"><code class="sourceCode prolog"><span class="kw">{</span>p<span class="kw">,</span>q<span class="kw">,</span>r<span class="kw">}.</span></code></pre></div>

<p>says: choose arbitrarily which of the atoms 

<math display="inline" id="Answer_set_programming:0">
<semantics>
<mrow>
<mi>p</mi>
<mo>,</mo>
<mi>q</mi>
<mo>,</mo>
<mi>r</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<list>
<ci>p</ci>
<ci>q</ci>
<ci>r</ci>
</list>
</annotation-xml>
<annotation encoding="application/x-tex">
   p,q,r
  </annotation>
</semantics>
</math>

 to include in the stable model. The lparse program that contains this choice rule and no other rules has 8 stable models—arbitrary subsets of 

<math display="inline" id="Answer_set_programming:1">
<semantics>
<mrow>
<mo stretchy="false">{</mo>
<mi>p</mi>
<mo>,</mo>
<mi>q</mi>
<mo>,</mo>
<mi>r</mi>
<mo stretchy="false">}</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<set>
<ci>p</ci>
<ci>q</ci>
<ci>r</ci>
</set>
</annotation-xml>
<annotation encoding="application/x-tex">
   \{p,q,r\}
  </annotation>
</semantics>
</math>

. The definition of a stable model was generalized to programs with choice rules.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> Choice rules can be treated also as abbreviations for <a href="Stable_model_semantics#Stable_models_of_a_set_of_propositional_formulas" title="wikilink">propositional formulas under the stable model semantics</a>.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> For instance, the choice rule above can be viewed as shorthand for the conjunction of three "<a href="excluded_middle" title="wikilink">excluded middle</a>" formulas:</p>

<p>
<math display="block" id="Answer_set_programming:2">
<semantics>
<mrow>
<mrow>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>p</mi>
<mo>∨</mo>
<mrow>
<mi mathvariant="normal">¬</mi>
<mi>p</mi>
</mrow>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mo>∧</mo>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>q</mi>
<mo>∨</mo>
<mrow>
<mi mathvariant="normal">¬</mi>
<mi>q</mi>
</mrow>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mo>∧</mo>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>r</mi>
<mo>∨</mo>
<mrow>
<mi mathvariant="normal">¬</mi>
<mi>r</mi>
</mrow>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<and></and>
<apply>
<or></or>
<ci>p</ci>
<apply>
<times></times>
<not></not>
<ci>p</ci>
</apply>
</apply>
<apply>
<or></or>
<ci>q</ci>
<apply>
<times></times>
<not></not>
<ci>q</ci>
</apply>
</apply>
<apply>
<or></or>
<ci>r</ci>
<apply>
<times></times>
<not></not>
<ci>r</ci>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   (p\lor\neg p)\land(q\lor\neg q)\land(r\lor\neg r).
  </annotation>
</semantics>
</math>
</p>

<p>The language of lparse allows us also to write "constrained" choice rules, such as</p>
<div class="sourceCode"><pre class="sourceCode prolog"><code class="sourceCode prolog"><span class="dv">1</span><span class="kw">{</span>p<span class="kw">,</span>q<span class="kw">,</span>r<span class="kw">}</span><span class="dv">2</span><span class="kw">.</span></code></pre></div>

<p>This rule says: choose at least 1 of the atoms 

<math display="inline" id="Answer_set_programming:3">
<semantics>
<mrow>
<mi>p</mi>
<mo>,</mo>
<mi>q</mi>
<mo>,</mo>
<mi>r</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<list>
<ci>p</ci>
<ci>q</ci>
<ci>r</ci>
</list>
</annotation-xml>
<annotation encoding="application/x-tex">
   p,q,r
  </annotation>
</semantics>
</math>


, but not more than 2. The meaning of this rule under the stable model semantics is represented by the <a href="propositional_formula" title="wikilink">propositional formula</a></p>

<p>
<math display="block" id="Answer_set_programming:4">
<semantics>
<mrow>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>p</mi>
<mo>∨</mo>
<mrow>
<mi mathvariant="normal">¬</mi>
<mi>p</mi>
</mrow>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mo>∧</mo>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>q</mi>
<mo>∨</mo>
<mrow>
<mi mathvariant="normal">¬</mi>
<mi>q</mi>
</mrow>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mo>∧</mo>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>r</mi>
<mo>∨</mo>
<mrow>
<mi mathvariant="normal">¬</mi>
<mi>r</mi>
</mrow>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<and></and>
<apply>
<or></or>
<ci>p</ci>
<apply>
<times></times>
<not></not>
<ci>p</ci>
</apply>
</apply>
<apply>
<or></or>
<ci>q</ci>
<apply>
<times></times>
<not></not>
<ci>q</ci>
</apply>
</apply>
<apply>
<or></or>
<ci>r</ci>
<apply>
<times></times>
<not></not>
<ci>r</ci>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   (p\lor\neg p)\land(q\lor\neg q)\land(r\lor\neg r)
  </annotation>
</semantics>
</math>
</p>
<dl>
<dd><dl>
<dd>
<math display="inline" id="Answer_set_programming:5">
<semantics>
<mrow>
<mrow>
<mrow>
<mo rspace="4.2pt">∧</mo>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>p</mi>
<mo>∨</mo>
<mi>q</mi>
<mo>∨</mo>
<mi>r</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>∧</mo>
<mrow>
<mi mathvariant="normal">¬</mi>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>p</mi>
<mo>∧</mo>
<mi>q</mi>
<mo>∧</mo>
<mi>r</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<and></and>
<apply>
<and></and>
<apply>
<or></or>
<ci>p</ci>
<ci>q</ci>
<ci>r</ci>
</apply>
</apply>
<apply>
<not></not>
<apply>
<and></and>
<ci>p</ci>
<ci>q</ci>
<ci>r</ci>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \land\,(p\lor q\lor r)\land\neg(p\land q\land r).
  </annotation>
</semantics>
</math>
</dd>
</dl>
</dd>
</dl>

<p>Cardinality bounds can be used in the body of a rule as well, for instance:</p>
<div class="sourceCode"><pre class="sourceCode prolog"><code class="sourceCode prolog"><span class="kw">:-</span> <span class="dv">2</span><span class="kw">{</span>p<span class="kw">,</span>q<span class="kw">,</span>r<span class="kw">}.</span></code></pre></div>

<p>Adding this constraint to an Lparse program eliminates the stable models that contain at least 2 of the atoms 

<math display="inline" id="Answer_set_programming:6">
<semantics>
<mrow>
<mi>p</mi>
<mo>,</mo>
<mi>q</mi>
<mo>,</mo>
<mi>r</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<list>
<ci>p</ci>
<ci>q</ci>
<ci>r</ci>
</list>
</annotation-xml>
<annotation encoding="application/x-tex">
   p,q,r
  </annotation>
</semantics>
</math>

. The meaning of this rule can be represented by the propositional formula</p>
<dl>
<dd><dl>
<dd>
<math display="inline" id="Answer_set_programming:7">
<semantics>
<mrow>
<mrow>
<mi mathvariant="normal">¬</mi>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>p</mi>
<mo>∧</mo>
<mi>q</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mo>∨</mo>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>p</mi>
<mo>∧</mo>
<mi>r</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mo>∨</mo>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>q</mi>
<mo>∧</mo>
<mi>r</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<not></not>
<apply>
<or></or>
<apply>
<and></and>
<ci>p</ci>
<ci>q</ci>
</apply>
<apply>
<and></and>
<ci>p</ci>
<ci>r</ci>
</apply>
<apply>
<and></and>
<ci>q</ci>
<ci>r</ci>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \neg((p\land q)\lor(p\land r)\lor(q\land r)).
  </annotation>
</semantics>
</math>
</dd>
</dl>
</dd>
</dl>

<p>Variables (capitalized, as in <a href="Prolog#Data_types" title="wikilink">Prolog</a>) are used in Lparse to abbreviate collections of rules that follow the same pattern, and also to abbreviate collections of atoms within the same rule. For instance, the Lparse program</p>
<div class="sourceCode"><pre class="sourceCode prolog"><code class="sourceCode prolog">p(a)<span class="kw">.</span> p(b)<span class="kw">.</span> p(c)<span class="kw">.</span>
q(<span class="dt">X</span>) <span class="kw">:-</span> p(<span class="dt">X</span>)<span class="kw">,</span> <span class="dt">X</span><span class="kw">!=</span>a<span class="kw">.</span></code></pre></div>

<p>has the same meaning as</p>
<div class="sourceCode"><pre class="sourceCode prolog"><code class="sourceCode prolog">p(a)<span class="kw">.</span> p(b)<span class="kw">.</span> p(c)<span class="kw">.</span>
q(b)<span class="kw">.</span> q(c)<span class="kw">.</span></code></pre></div>

<p>The program</p>
<div class="sourceCode"><pre class="sourceCode prolog"><code class="sourceCode prolog">p(a)<span class="kw">.</span> p(b)<span class="kw">.</span> p(c)<span class="kw">.</span>
<span class="kw">{</span>q(<span class="dt">X</span>)<span class="kw">:-</span>p(<span class="dt">X</span>)<span class="kw">}</span><span class="dv">2</span><span class="kw">.</span></code></pre></div>

<p>is shorthand for</p>
<div class="sourceCode"><pre class="sourceCode prolog"><code class="sourceCode prolog">p(a)<span class="kw">.</span> p(b)<span class="kw">.</span> p(c)<span class="kw">.</span>
<span class="kw">{</span>q(a)<span class="kw">,</span>q(b)<span class="kw">,</span>q(c)<span class="kw">}</span><span class="dv">2</span><span class="kw">.</span></code></pre></div>

<p>A <em>range</em> is of the form:</p>
<div class="sourceCode"><pre class="sourceCode prolog"><code class="sourceCode prolog"><span class="dt">&lt;</span>predicate<span class="er">&gt;</span>(start..end)
</code></pre></div>&gt;


<p>where start and end are constant valued arithmetic expressions. A range is a notational shortcut that is mainly used to define numerical domains in a compatible way. For example, the fact</p>
<div class="sourceCode"><pre class="sourceCode prolog"><code class="sourceCode prolog">a(<span class="dv">1</span>..<span class="dv">3</span>)<span class="kw">.</span> </code></pre></div>

<p>is a shortcut for</p>
<div class="sourceCode"><pre class="sourceCode prolog"><code class="sourceCode prolog">a(<span class="dv">1</span>)<span class="kw">.</span> a(<span class="dv">2</span>)<span class="kw">.</span> a(<span class="dv">3</span>)<span class="kw">.</span></code></pre></div>

<p>Ranges can also be used in rule bodies with the same semantics.</p>

<p>A <em>conditional literal</em> is of the form:</p>
<div class="sourceCode"><pre class="sourceCode prolog"><code class="sourceCode prolog">p(<span class="dt">X</span>)<span class="fu">:</span>q(<span class="dt">X</span>)</code></pre></div>

<p>If the extension of q is {q(a1); q(a2); ... ; q(aN)}, the above condition is semantically equivalent to writing p(a1), p(a2), ... , p(aN) in the place of the condition. For example</p>
<div class="sourceCode"><pre class="sourceCode prolog"><code class="sourceCode prolog">q(<span class="dv">1</span>..<span class="dv">2</span>)<span class="kw">.</span>
a <span class="kw">:-</span> <span class="dv">1</span> <span class="kw">{</span>p(<span class="dt">X</span>)<span class="fu">:</span>q(<span class="dt">X</span>)<span class="kw">}.</span></code></pre></div>

<p>is a shorthand for</p>
<div class="sourceCode"><pre class="sourceCode prolog"><code class="sourceCode prolog">q(<span class="dv">1</span>)<span class="kw">.</span> q(<span class="dv">2</span>)<span class="kw">.</span>
a <span class="kw">:-</span> <span class="dv">1</span> <span class="kw">{</span>p(<span class="dv">1</span>)<span class="kw">,</span> p(<span class="dv">2</span>)<span class="kw">}.</span></code></pre></div>
<h2 id="generating-stable-models">Generating stable models</h2>

<p>To find a stable model of the Lparse program stored in file <code><filename></filename></code> we use the command</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">%</span> lparse <span class="kw">&lt;</span>filename<span class="kw">&gt;</span> <span class="kw">|</span> <span class="kw">smodels</span>
<span class="kw">&lt;</span>/<span class="kw">filename&gt;</span></code></pre></div>

<p>Option 0 instructs smodels to find <em>all</em> stable models of the program. For instance, if file <code>test</code> contains the rules</p>
<div class="sourceCode"><pre class="sourceCode prolog"><code class="sourceCode prolog"><span class="dv">1</span><span class="kw">{</span>p<span class="kw">,</span>q<span class="kw">,</span>r<span class="kw">}</span><span class="dv">2</span><span class="kw">.</span>
s <span class="kw">:-</span> not p<span class="kw">.</span></code></pre></div>

<p>then the command</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">%</span> lparse test <span class="kw">|</span> <span class="kw">smodels</span> 0</code></pre></div>

<p>produces the output</p>
<pre class="text"><code>Answer: 1
Stable Model: q p 
Answer: 2
Stable Model: p 
Answer: 3
Stable Model: r p 
Answer: 4
Stable Model: q s 
Answer: 5
Stable Model: r s 
Answer: 6
Stable Model: r q s</code></pre>
<h2 id="examples-of-asp-programs">Examples of ASP programs</h2>
<h3 id="graph-coloring">Graph coloring</h3>

<p>An 

<math display="inline" id="Answer_set_programming:8">
<semantics>
<mi>n</mi>
<annotation-xml encoding="MathML-Content">
<ci>n</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   n
  </annotation>
</semantics>
</math>


-<a href="Graph_coloring" title="wikilink">coloring</a> of a <a href="Graph_(mathematics)" title="wikilink">graph</a>
<math display="inline" id="Answer_set_programming:9">
<semantics>
<mi>G</mi>
<annotation-xml encoding="MathML-Content">
<ci>G</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   G
  </annotation>
</semantics>
</math>

 is a function 

<math display="inline" id="Answer_set_programming:10">
<semantics>
<mrow>
<mi>c</mi>
<mi>o</mi>
<mi>l</mi>
<mi>o</mi>
<mi>r</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<ci>c</ci>
<ci>o</ci>
<ci>l</ci>
<ci>o</ci>
<ci>r</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   color
  </annotation>
</semantics>
</math>

 from its set of vertices to 

<math display="inline" id="Answer_set_programming:11">
<semantics>
<mrow>
<mo stretchy="false">{</mo>
<mn>1</mn>
<mo>,</mo>
<mi mathvariant="normal">…</mi>
<mo>,</mo>
<mi>n</mi>
<mo stretchy="false">}</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<set>
<cn type="integer">1</cn>
<ci>normal-…</ci>
<ci>n</ci>
</set>
</annotation-xml>
<annotation encoding="application/x-tex">
   \{1,\dots,n\}
  </annotation>
</semantics>
</math>

 such that 

<math display="inline" id="Answer_set_programming:12">
<semantics>
<mrow>
<mrow>
<mi>c</mi>
<mi>o</mi>
<mi>l</mi>
<mi>o</mi>
<mi>r</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>x</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>≠</mo>
<mrow>
<mi>c</mi>
<mi>o</mi>
<mi>l</mi>
<mi>o</mi>
<mi>r</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>y</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<neq></neq>
<apply>
<times></times>
<ci>c</ci>
<ci>o</ci>
<ci>l</ci>
<ci>o</ci>
<ci>r</ci>
<ci>x</ci>
</apply>
<apply>
<times></times>
<ci>c</ci>
<ci>o</ci>
<ci>l</ci>
<ci>o</ci>
<ci>r</ci>
<ci>y</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   color(x)\neq color(y)
  </annotation>
</semantics>
</math>

 for every pair of adjacent vertices 

<math display="inline" id="Answer_set_programming:13">
<semantics>
<mrow>
<mi>x</mi>
<mo>,</mo>
<mi>y</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<list>
<ci>x</ci>
<ci>y</ci>
</list>
</annotation-xml>
<annotation encoding="application/x-tex">
   x,y
  </annotation>
</semantics>
</math>


. We would like to use ASP to find an 

<math display="inline" id="Answer_set_programming:14">
<semantics>
<mi>n</mi>
<annotation-xml encoding="MathML-Content">
<ci>n</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   n
  </annotation>
</semantics>
</math>

-coloring of a given graph (or determine that it does not exist).</p>

<p>This can be accomplished using the following Lparse program:</p>
<div class="sourceCode"><pre class="sourceCode prolog"><code class="sourceCode prolog">c(<span class="dv">1</span>..n)<span class="kw">.</span>                                           
<span class="dv">1</span> <span class="kw">{</span>color(<span class="dt">X</span><span class="kw">,</span><span class="dt">I</span>) <span class="fu">:</span> c(<span class="dt">I</span>)<span class="kw">}</span> <span class="dv">1</span> <span class="kw">:-</span> v(<span class="dt">X</span>)<span class="kw">.</span>             
<span class="kw">:-</span> color(<span class="dt">X</span><span class="kw">,</span><span class="dt">I</span>)<span class="kw">,</span> color(<span class="dt">Y</span><span class="kw">,</span><span class="dt">I</span>)<span class="kw">,</span> e(<span class="dt">X</span><span class="kw">,</span><span class="dt">Y</span>)<span class="kw">,</span> c(<span class="dt">I</span>)<span class="kw">.</span></code></pre></div>

<p>Line 1 defines the numbers 

<math display="inline" id="Answer_set_programming:15">
<semantics>
<mrow>
<mn>1</mn>
<mo>,</mo>
<mi mathvariant="normal">…</mi>
<mo>,</mo>
<mi>n</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<list>
<cn type="integer">1</cn>
<ci>normal-…</ci>
<ci>n</ci>
</list>
</annotation-xml>
<annotation encoding="application/x-tex">
   1,\dots,n
  </annotation>
</semantics>
</math>

 to be colors. According to the choice rule in Line 2, a unique color 

<math display="inline" id="Answer_set_programming:16">
<semantics>
<mi>i</mi>
<annotation-xml encoding="MathML-Content">
<ci>i</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   i
  </annotation>
</semantics>
</math>

 should be assigned to each vertex 

<math display="inline" id="Answer_set_programming:17">
<semantics>
<mi>x</mi>
<annotation-xml encoding="MathML-Content">
<ci>x</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   x
  </annotation>
</semantics>
</math>

. The constraint in Line 3 prohibits assigning the same color to vertices 

<math display="inline" id="Answer_set_programming:18">
<semantics>
<mi>x</mi>
<annotation-xml encoding="MathML-Content">
<ci>x</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   x
  </annotation>
</semantics>
</math>


 and 

<math display="inline" id="Answer_set_programming:19">
<semantics>
<mi>y</mi>
<annotation-xml encoding="MathML-Content">
<ci>y</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   y
  </annotation>
</semantics>
</math>

 if there is an edge connecting them.</p>

<p>If we combine this file with a definition of 

<math display="inline" id="Answer_set_programming:20">
<semantics>
<mi>G</mi>
<annotation-xml encoding="MathML-Content">
<ci>G</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   G
  </annotation>
</semantics>
</math>

, such as</p>
<div class="sourceCode"><pre class="sourceCode prolog"><code class="sourceCode prolog">v(<span class="dv">1</span>..<span class="dv">100</span>)<span class="kw">.</span> <span class="co">% 1,...,100 are vertices</span>
e(<span class="dv">1</span><span class="kw">,</span><span class="dv">55</span>)<span class="kw">.</span> <span class="co">% there is an edge from 1 to 55</span>
<span class="al">.</span> <span class="al">.</span> <span class="al">.</span></code></pre></div>

<p>and run smodels on it, with the numeric value of 

<math display="inline" id="Answer_set_programming:21">
<semantics>
<mi>n</mi>
<annotation-xml encoding="MathML-Content">
<ci>n</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   n
  </annotation>
</semantics>
</math>

 specified on the command line, then the atoms of the form 

<math display="inline" id="Answer_set_programming:22">
<semantics>
<mrow>
<mi>c</mi>
<mi>o</mi>
<mi>l</mi>
<mi>o</mi>
<mi>r</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi mathvariant="normal">…</mi>
<mo>,</mo>
<mi mathvariant="normal">…</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<ci>c</ci>
<ci>o</ci>
<ci>l</ci>
<ci>o</ci>
<ci>r</ci>
<interval closure="open">
<ci>normal-…</ci>
<ci>normal-…</ci>
</interval>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   color(\dots,\dots)
  </annotation>
</semantics>
</math>

 in the output of smodels will represent an 

<math display="inline" id="Answer_set_programming:23">
<semantics>
<mi>n</mi>
<annotation-xml encoding="MathML-Content">
<ci>n</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   n
  </annotation>
</semantics>
</math>


-coloring of 

<math display="inline" id="Answer_set_programming:24">
<semantics>
<mi>G</mi>
<annotation-xml encoding="MathML-Content">
<ci>G</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   G
  </annotation>
</semantics>
</math>

.</p>

<p>The program in this example illustrates the "generate-and-test" organization that is often found in simple ASP programs. The choice rule describes a set of "potential solutions" — a simple superset of the set of solutions to the given search problem. It is followed by a constraint, which eliminates all potential solutions that are not acceptable. However, the search process employed by smodels and other answer set solvers is not based on <a href="trial_and_error" title="wikilink">trial and error</a>.</p>
<h3 id="large-clique">Large clique</h3>

<p>A <a href="Clique_(graph_theory)" title="wikilink">clique</a> in a graph is a set of pairwise adjacent vertices. The following lparse program finds a clique of size 

<math display="inline" id="Answer_set_programming:25">
<semantics>
<mrow>
<mi></mi>
<mo>≥</mo>
<mi>n</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<geq></geq>
<csymbol cd="latexml">absent</csymbol>
<ci>n</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \geq n
  </annotation>
</semantics>
</math>

 in a given graph, or determines that it does not exist:</p>
<div class="sourceCode"><pre class="sourceCode prolog"><code class="sourceCode prolog">n <span class="kw">{</span>in(<span class="dt">X</span>) <span class="fu">:</span> v(<span class="dt">X</span>)<span class="kw">}.</span>
<span class="kw">:-</span> in(<span class="dt">X</span>)<span class="kw">,</span> in(<span class="dt">Y</span>)<span class="kw">,</span> v(<span class="dt">X</span>)<span class="kw">,</span> v(<span class="dt">Y</span>)<span class="kw">,</span> <span class="dt">X</span><span class="kw">!=</span><span class="dt">Y</span><span class="kw">,</span> not e(<span class="dt">X</span><span class="kw">,</span><span class="dt">Y</span>)<span class="kw">,</span> not e(<span class="dt">Y</span><span class="kw">,</span><span class="dt">X</span>)<span class="kw">.</span></code></pre></div>

<p>This is another example of the generate-and-test organization. The choice rule in Line 1 "generates" all sets consisting of 

<math display="inline" id="Answer_set_programming:26">
<semantics>
<mrow>
<mi></mi>
<mo>≥</mo>
<mi>n</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<geq></geq>
<csymbol cd="latexml">absent</csymbol>
<ci>n</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \geq n
  </annotation>
</semantics>
</math>

 vertices. The constraint in Line 2 "weeds out" the sets that are not cliques.</p>
<h3 id="hamiltonian-cycle">Hamiltonian cycle</h3>

<p>A <a href="Hamiltonian_cycle" title="wikilink">Hamiltonian cycle</a> in a <a href="directed_graph" title="wikilink">directed graph</a> is a <a href="Path_(graph_theory)" title="wikilink">cycle</a> that passes through each vertex of the graph exactly once. The following Lparse program can be used to find a Hamiltonian cycle in a given directed graph if it exists; we assume that 0 is one of the vertices.</p>
<div class="sourceCode"><pre class="sourceCode prolog"><code class="sourceCode prolog"><span class="kw">{</span>in(<span class="dt">X</span><span class="kw">,</span><span class="dt">Y</span>)<span class="kw">}</span> <span class="kw">:-</span> e(<span class="dt">X</span><span class="kw">,</span><span class="dt">Y</span>)<span class="kw">.</span>

<span class="kw">:-</span> <span class="dv">2</span> <span class="kw">{</span>in(<span class="dt">X</span><span class="kw">,</span><span class="dt">Y</span>) <span class="fu">:</span> e(<span class="dt">X</span><span class="kw">,</span><span class="dt">Y</span>)<span class="kw">},</span> v(<span class="dt">X</span>)<span class="kw">.</span>
<span class="kw">:-</span> <span class="dv">2</span> <span class="kw">{</span>in(<span class="dt">X</span><span class="kw">,</span><span class="dt">Y</span>) <span class="fu">:</span> e(<span class="dt">X</span><span class="kw">,</span><span class="dt">Y</span>)<span class="kw">},</span> v(<span class="dt">Y</span>)<span class="kw">.</span>

r(<span class="dt">X</span>) <span class="kw">:-</span> in(<span class="dv">0</span><span class="kw">,</span><span class="dt">X</span>)<span class="kw">,</span> v(<span class="dt">X</span>)<span class="kw">.</span>
r(<span class="dt">Y</span>) <span class="kw">:-</span> r(<span class="dt">X</span>)<span class="kw">,</span> in(<span class="dt">X</span><span class="kw">,</span><span class="dt">Y</span>)<span class="kw">,</span> e(<span class="dt">X</span><span class="kw">,</span><span class="dt">Y</span>)<span class="kw">.</span>

<span class="kw">:-</span> not r(<span class="dt">X</span>)<span class="kw">,</span> v(<span class="dt">X</span>)<span class="kw">.</span></code></pre></div>

<p>The choice rule in Line 1 "generates" all subsets of the set of edges. The three constraints "weed out" the subsets that are not Hamiltonian cycles. The last of them uses the auxiliary predicate 

<math display="inline" id="Answer_set_programming:27">
<semantics>
<mrow>
<mi>r</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>x</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<ci>r</ci>
<ci>x</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   r(x)
  </annotation>
</semantics>
</math>

 ("

<math display="inline" id="Answer_set_programming:28">
<semantics>
<mi>x</mi>
<annotation-xml encoding="MathML-Content">
<ci>x</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   x
  </annotation>
</semantics>
</math>


 is reachable from 0") to prohibit the vertices that do not satisfy this condition. This predicate is defined recursively in Lines 4 and 5.</p>

<p>This program is an example of the more general "generate, define and test" organization: it includes the definition of an auxiliary predicate that helps us eliminate all "bad" potential solutions.</p>
<h3 id="dependency-parsing">Dependency parsing</h3>

<p>In <a href="natural_language_processing" title="wikilink">natural language processing</a>, <a href="parsing" title="wikilink">dependency-based parsing</a> can be formulated as an ASP problem.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> The following code parses the Latin sentence <strong>Puella pulchra in villa linguam latinam discit</strong> "the pretty girl is learning Latin in the villa". The syntax tree is expressed by the <em>arc</em> predicates which represent the dependencies between the words of the sentence. The computed structure is a linearly ordered rooted tree.</p>
<div class="sourceCode"><pre class="sourceCode prolog"><code class="sourceCode prolog"><span class="co">% ********** input sentence **********</span>
word(<span class="dv">1</span><span class="kw">,</span> puella)<span class="kw">.</span> word(<span class="dv">2</span><span class="kw">,</span> pulchra)<span class="kw">.</span> word(<span class="dv">3</span><span class="kw">,</span> in)<span class="kw">.</span> word(<span class="dv">4</span><span class="kw">,</span> villa)<span class="kw">.</span> word(<span class="dv">5</span><span class="kw">,</span> linguam)<span class="kw">.</span> word(<span class="dv">6</span><span class="kw">,</span> latinam)<span class="kw">.</span> word(<span class="dv">7</span><span class="kw">,</span> discit)<span class="kw">.</span>
<span class="co">% ********** lexicon **********</span>
<span class="dv">1</span><span class="kw">{</span> node(<span class="dt">X</span><span class="kw">,</span> attr(pulcher<span class="kw">,</span> a<span class="kw">,</span> fem<span class="kw">,</span> nom<span class="kw">,</span> sg))<span class="kw">;</span>
   node(<span class="dt">X</span><span class="kw">,</span> attr(pulcher<span class="kw">,</span> a<span class="kw">,</span> fem<span class="kw">,</span> nom<span class="kw">,</span> sg)) <span class="kw">}</span><span class="dv">1</span> <span class="kw">:-</span> word(<span class="dt">X</span><span class="kw">,</span> pulchra)<span class="kw">.</span>
node(<span class="dt">X</span><span class="kw">,</span> attr(latinus<span class="kw">,</span> a<span class="kw">,</span> fem<span class="kw">,</span> acc<span class="kw">,</span> sg)) <span class="kw">:-</span> word(<span class="dt">X</span><span class="kw">,</span> latinam)<span class="kw">.</span>
<span class="dv">1</span><span class="kw">{</span> node(<span class="dt">X</span><span class="kw">,</span> attr(puella<span class="kw">,</span> n<span class="kw">,</span> fem<span class="kw">,</span> nom<span class="kw">,</span> sg))<span class="kw">;</span>
   node(<span class="dt">X</span><span class="kw">,</span> attr(puella<span class="kw">,</span> n<span class="kw">,</span> fem<span class="kw">,</span> abl<span class="kw">,</span> sg)) <span class="kw">}</span><span class="dv">1</span> <span class="kw">:-</span> word(<span class="dt">X</span><span class="kw">,</span> puella)<span class="kw">.</span>
<span class="dv">1</span><span class="kw">{</span> node(<span class="dt">X</span><span class="kw">,</span> attr(villa<span class="kw">,</span> n<span class="kw">,</span> fem<span class="kw">,</span> nom<span class="kw">,</span> sg))<span class="kw">;</span>
   node(<span class="dt">X</span><span class="kw">,</span> attr(villa<span class="kw">,</span> n<span class="kw">,</span> fem<span class="kw">,</span> abl<span class="kw">,</span> sg)) <span class="kw">}</span><span class="dv">1</span> <span class="kw">:-</span> word(<span class="dt">X</span><span class="kw">,</span> villa)<span class="kw">.</span>
node(<span class="dt">X</span><span class="kw">,</span> attr(linguam<span class="kw">,</span> n<span class="kw">,</span> fem<span class="kw">,</span> acc<span class="kw">,</span> sg)) <span class="kw">:-</span> word(<span class="dt">X</span><span class="kw">,</span> linguam)<span class="kw">.</span>
node(<span class="dt">X</span><span class="kw">,</span> attr(discere<span class="kw">,</span> v<span class="kw">,</span> pres<span class="kw">,</span> <span class="dv">3</span><span class="kw">,</span> sg)) <span class="kw">:-</span> word(<span class="dt">X</span><span class="kw">,</span> discit)<span class="kw">.</span>
node(<span class="dt">X</span><span class="kw">,</span> attr(in<span class="kw">,</span> p)) <span class="kw">:-</span> word(<span class="dt">X</span><span class="kw">,</span> in)<span class="kw">.</span>
<span class="co">% ********** syntactic rules **********</span>
<span class="dv">0</span><span class="kw">{</span> arc(<span class="dt">X</span><span class="kw">,</span> <span class="dt">Y</span><span class="kw">,</span> subj) <span class="kw">}</span><span class="dv">1</span> <span class="kw">:-</span> node(<span class="dt">X</span><span class="kw">,</span> attr(<span class="dt">_</span><span class="kw">,</span> v<span class="kw">,</span> <span class="dt">_</span><span class="kw">,</span> <span class="dv">3</span><span class="kw">,</span> sg))<span class="kw">,</span> node(<span class="dt">Y</span><span class="kw">,</span> attr(<span class="dt">_</span><span class="kw">,</span> n<span class="kw">,</span> <span class="dt">_</span><span class="kw">,</span> nom<span class="kw">,</span> sg))<span class="kw">.</span>
<span class="dv">0</span><span class="kw">{</span> arc(<span class="dt">X</span><span class="kw">,</span> <span class="dt">Y</span><span class="kw">,</span> dobj) <span class="kw">}</span><span class="dv">1</span> <span class="kw">:-</span> node(<span class="dt">X</span><span class="kw">,</span> attr(<span class="dt">_</span><span class="kw">,</span> v<span class="kw">,</span> <span class="dt">_</span><span class="kw">,</span> <span class="dv">3</span><span class="kw">,</span> sg))<span class="kw">,</span> node(<span class="dt">Y</span><span class="kw">,</span> attr(<span class="dt">_</span><span class="kw">,</span> n<span class="kw">,</span> <span class="dt">_</span><span class="kw">,</span> acc<span class="kw">,</span> sg))<span class="kw">.</span>
<span class="dv">0</span><span class="kw">{</span> arc(<span class="dt">X</span><span class="kw">,</span> <span class="dt">Y</span><span class="kw">,</span> attr) <span class="kw">}</span><span class="dv">1</span> <span class="kw">:-</span> node(<span class="dt">X</span><span class="kw">,</span> attr(<span class="dt">_</span><span class="kw">,</span> n<span class="kw">,</span> <span class="dt">Gender</span><span class="kw">,</span> <span class="dt">Case</span><span class="kw">,</span> <span class="dt">Number</span>))<span class="kw">,</span> node(<span class="dt">Y</span><span class="kw">,</span> attr(<span class="dt">_</span><span class="kw">,</span> a<span class="kw">,</span> <span class="dt">Gender</span><span class="kw">,</span> <span class="dt">Case</span><span class="kw">,</span> <span class="dt">Number</span>))<span class="kw">.</span>
<span class="dv">0</span><span class="kw">{</span> arc(<span class="dt">X</span><span class="kw">,</span> <span class="dt">Y</span><span class="kw">,</span> prep) <span class="kw">}</span><span class="dv">1</span> <span class="kw">:-</span> node(<span class="dt">X</span><span class="kw">,</span> attr(<span class="dt">_</span><span class="kw">,</span> p))<span class="kw">,</span> node(<span class="dt">Y</span><span class="kw">,</span> attr(<span class="dt">_</span><span class="kw">,</span> n<span class="kw">,</span> <span class="dt">_</span><span class="kw">,</span> abl<span class="kw">,</span> <span class="dt">_</span>))<span class="kw">,</span> <span class="dt">X</span> <span class="dt">&lt;</span> <span class="dt">Y</span><span class="kw">.</span>
<span class="dv">0</span><span class="kw">{</span> arc(<span class="dt">X</span><span class="kw">,</span> <span class="dt">Y</span><span class="kw">,</span> adv) <span class="kw">}</span><span class="dv">1</span> <span class="kw">:-</span> node(<span class="dt">X</span><span class="kw">,</span> attr(<span class="dt">_</span><span class="kw">,</span> v<span class="kw">,</span> <span class="dt">_</span><span class="kw">,</span> <span class="dt">_</span><span class="kw">,</span> <span class="dt">_</span>))<span class="kw">,</span> node(<span class="dt">Y</span><span class="kw">,</span> attr(<span class="dt">_</span><span class="kw">,</span> p))<span class="kw">,</span> not leaf(<span class="dt">Y</span>)<span class="kw">.</span>
<span class="co">% ********** guaranteeing the treeness of the graph **********</span>
<span class="dv">1</span><span class="kw">{</span> root(<span class="dt">X</span>)<span class="fu">:</span>node(<span class="dt">X</span><span class="kw">,</span> <span class="dt">_</span>) <span class="kw">}</span><span class="dv">1</span><span class="kw">.</span>
<span class="kw">:-</span> arc(<span class="dt">X</span><span class="kw">,</span> <span class="dt">Z</span><span class="kw">,</span> <span class="dt">_</span>)<span class="kw">,</span> arc(<span class="dt">Y</span><span class="kw">,</span> <span class="dt">Z</span><span class="kw">,</span> <span class="dt">_</span>)<span class="kw">,</span> <span class="dt">X</span> <span class="kw">!=</span> <span class="dt">Y</span><span class="kw">.</span>
<span class="kw">:-</span> arc(<span class="dt">X</span><span class="kw">,</span> <span class="dt">Y</span><span class="kw">,</span> <span class="dt">L1</span>)<span class="kw">,</span> arc(<span class="dt">X</span><span class="kw">,</span> <span class="dt">Y</span><span class="kw">,</span> <span class="dt">L2</span>)<span class="kw">,</span> <span class="dt">L1</span> <span class="kw">!=</span> <span class="dt">L2</span><span class="kw">.</span>
path(<span class="dt">X</span><span class="kw">,</span> <span class="dt">Y</span>) <span class="kw">:-</span> arc(<span class="dt">X</span><span class="kw">,</span> <span class="dt">Y</span><span class="kw">,</span> <span class="dt">_</span>)<span class="kw">.</span>
path(<span class="dt">X</span><span class="kw">,</span> <span class="dt">Z</span>) <span class="kw">:-</span> arc(<span class="dt">X</span><span class="kw">,</span> <span class="dt">Y</span><span class="kw">,</span> <span class="dt">_</span>)<span class="kw">,</span> path(<span class="dt">Y</span><span class="kw">,</span> <span class="dt">Z</span>)<span class="kw">.</span>
<span class="kw">:-</span> path(<span class="dt">X</span><span class="kw">,</span> <span class="dt">X</span>)<span class="kw">.</span>
<span class="kw">:-</span> root(<span class="dt">X</span>)<span class="kw">,</span> node(<span class="dt">Y</span><span class="kw">,</span> <span class="dt">_</span>)<span class="kw">,</span> <span class="dt">X</span> <span class="kw">!=</span> <span class="dt">Y</span><span class="kw">,</span> not path(<span class="dt">X</span><span class="kw">,</span> <span class="dt">Y</span>)<span class="kw">.</span>
leaf(<span class="dt">X</span>) <span class="kw">:-</span> node(<span class="dt">X</span><span class="kw">,</span> <span class="dt">_</span>)<span class="kw">,</span> not arc(<span class="dt">X</span><span class="kw">,</span> <span class="dt">_</span><span class="kw">,</span> <span class="dt">_</span>)<span class="kw">.</span></code></pre></div>
<h2 id="comparison-of-implementations">Comparison of implementations</h2>

<p>Early systems, such as Smodels, used backtracking to find solutions. As the theory and practice of <a href="Boolean_SAT_solver" title="wikilink">Boolean SAT solvers</a> evolved, a number of ASP solvers were built on top of SAT solvers, including ASSAT and Cmodels. These converted ASP formula into SAT propositions, applied the SAT solver, and then converted the solutions back to ASP form. More recent systems, such as Clasp, use a hybrid approach, using conflict-driven algorithms inspired by SAT, without full converting into a boolean-logic form. These approaches allow for significant improvements of performance, often by an order of magnitude, over earlier backtracking algorithms.</p>

<p>The <a href="http://potassco.sourceforge.net/">Potassco</a> project acts as an umbrella for many of the systems below, including <em>clasp</em>, grounding systems (<em>gringo</em>), incremental systems (<em>iclingo</em>), constraint solvers (<em>clingcon</em>), <a href="action_language" title="wikilink">action language</a> to ASP compilers (<em>coala</em>), distributed MPI implementations (<em>claspar</em>), and many others.</p>

<p>Most systems support variables, but only indirectly, by forcing grounding, by using a grounding system such as <em>Lparse</em> or <em>gringo</em> as a front end. The need for grounding can cause a combinatorial explosion of clauses; thus, systems that perform on-the-fly grounding might have an advantage.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">

<p>Platform</p></th>
<th style="text-align: left;">

<p>Features</p></th>
<th style="text-align: left;">

<p>Mechanics</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">

<p>Name</p></td>
<td style="text-align: left;">

<p>OS</p></td>
<td style="text-align: left;">

<p>Licence</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">

<p>|<a href="http://www.info.univ-angers.fr/pub/claire/asperix/">ASPeRiX</a></p></td>
<td style="text-align: left;">

<p><a class="uri" href="Linux" title="wikilink">Linux</a></p></td>
<td style="text-align: left;">

<p><a class="uri" href="GPL" title="wikilink">GPL</a></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">

<p>|<a href="http://assat.cs.ust.hk/">ASSAT</a></p></td>
<td style="text-align: left;">

<p><a href="Solaris_(operating_system)" title="wikilink">Solaris</a></p></td>
<td style="text-align: left;">

<p><a class="uri" href="Freeware" title="wikilink">Freeware</a></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">

<p>|<a href="http://www.cs.uni-potsdam.de/clasp/">Clasp Answer Set Solver</a></p></td>
<td style="text-align: left;">

<p><a class="uri" href="Linux" title="wikilink">Linux</a>, <a href="Mac_OS" title="wikilink">Mac OS</a>, <a href="Microsoft_Windows" title="wikilink">Windows</a></p></td>
<td style="text-align: left;">

<p><a class="uri" href="GPL" title="wikilink">GPL</a></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">

<p>|<a href="http://www.cs.utexas.edu/users/tag/cmodels/">Cmodels</a></p></td>
<td style="text-align: left;">

<p><a class="uri" href="Linux" title="wikilink">Linux</a>, <a href="Solaris_(operating_system)" title="wikilink">Solaris</a></p></td>
<td style="text-align: left;">

<p><a class="uri" href="GPL" title="wikilink">GPL</a></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">

<p>|<a class="uri" href="DLV" title="wikilink">DLV</a></p></td>
<td style="text-align: left;">

<p><a class="uri" href="Linux" title="wikilink">Linux</a>, <a href="Mac_OS" title="wikilink">Mac OS</a>, <a href="Microsoft_Windows" title="wikilink">Windows</a><a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a></p></td>
<td style="text-align: left;">

<p>free for academic and non-commercial educational use, and for non-profit organizations<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">

<p>|<a href="http://www.mat.unical.it/dlv-complex/">DLV-Complex</a></p></td>
<td style="text-align: left;">

<p><a class="uri" href="Linux" title="wikilink">Linux</a>, <a href="Mac_OS" title="wikilink">Mac OS</a>, <a href="Microsoft_Windows" title="wikilink">Windows</a></p></td>
<td style="text-align: left;">

<p><a class="uri" href="Freeware" title="wikilink">Freeware</a></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">

<p>|<a href="http://www.tcs.hut.fi/Software/gnt/">GnT</a></p></td>
<td style="text-align: left;">

<p><a class="uri" href="Linux" title="wikilink">Linux</a></p></td>
<td style="text-align: left;">

<p><a class="uri" href="GPL" title="wikilink">GPL</a></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">

<p>|<a href="http://www.cs.uni-potsdam.de/nomore/">nomore++</a></p></td>
<td style="text-align: left;">

<p><a class="uri" href="Linux" title="wikilink">Linux</a></p></td>
<td style="text-align: left;">

<p><a class="uri" href="GPL" title="wikilink">GPL</a></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">

<p>|<a href="http://www.cs.uni-potsdam.de/platypus/">Platypus</a></p></td>
<td style="text-align: left;">

<p><a class="uri" href="Linux" title="wikilink">Linux</a>, <a href="Solaris_(operating_system)" title="wikilink">Solaris</a>, <a href="Microsoft_Windows" title="wikilink">Windows</a></p></td>
<td style="text-align: left;">

<p><a class="uri" href="GPL" title="wikilink">GPL</a></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">

<p>|<a href="http://www.cs.uky.edu/ai/pbmodels/">Pbmodels</a></p></td>
<td style="text-align: left;">

<p><a class="uri" href="Linux" title="wikilink">Linux</a></p></td>
<td style="text-align: left;">

<p>?</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">

<p>|<a href="http://www.tcs.hut.fi/Software/smodels/">Smodels</a></p></td>
<td style="text-align: left;">

<p><a class="uri" href="Linux" title="wikilink">Linux</a>, <a href="Mac_OS" title="wikilink">Mac OS</a>, <a href="Microsoft_Windows" title="wikilink">Windows</a></p></td>
<td style="text-align: left;">

<p><a class="uri" href="GPL" title="wikilink">GPL</a></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">

<p>|<a href="http://www.nku.edu/~wardj1/Research/smodels_cc.html">Smodels-cc</a></p></td>
<td style="text-align: left;">

<p><a class="uri" href="Linux" title="wikilink">Linux</a></p></td>
<td style="text-align: left;">

<p>?</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">

<p>|<a href="http://www.cs.utexas.edu/users/tag/sup/">Sup</a></p></td>
<td style="text-align: left;">

<p><a class="uri" href="Linux" title="wikilink">Linux</a></p></td>
<td style="text-align: left;">

<p>?</p></td>
</tr>
</tbody>
</table>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Default_logic" title="wikilink">Default logic</a></li>
<li><a href="Logic_programming" title="wikilink">Logic programming</a></li>
<li><a href="Non-monotonic_logic" title="wikilink">Non-monotonic logic</a></li>
<li><a class="uri" href="Prolog" title="wikilink">Prolog</a></li>
<li><a href="Stable_model_semantics" title="wikilink">Stable model semantics</a></li>
</ul>
<h2 id="references">References</h2>
<references>
</references>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://asparagus.cs.uni-potsdam.de/contest/">First ASP System Competition</a></li>
<li><a href="http://www.cs.kuleuven.be/~dtai/events/ASP-competition/index.shtml">Second ASP Competition</a></li>
<li><a href="http://www.mat.unical.it/aspcomp2011/">Third ASP Competition</a></li>
<li><a href="http://www.mat.unical.it/aspcomp2013">Fourth ASP Competition</a></li>
<li><a href="http://www.cs.uni-potsdam.de/platypus/">Platypus</a></li>
<li><a href="http://www.kr.tuwien.ac.at/staff/tkren/deb.html">A variety of answer set solvers packaged for Debian / Ubuntu</a></li>
<li><a href="http://www.cs.uni-potsdam.de/clasp/">Clasp Answer Set Solver</a></li>
</ul>

<p>"</p>

<p><a href="Category:Logic_programming" title="wikilink">Category:Logic programming</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"> <a href="http://www.depts.ttu.edu/cs/research/krlab/pdfs/papers/gel07b.pdf">as PDF</a><a href="#fnref2">↩</a></li>
<li id="fn3"> <a href="ftp://ftp.informatik.uni-freiburg.de/documents/papers/ki/dimopoulos-etal-ecp97.ps.gz">as Postscript</a><a href="#fnref3">↩</a></li>
<li id="fn4"> <a href="http://www.cs.ucla.edu/%7Ezaniolo/papers/iclp95.ps">as Postscript</a><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
<li id="fn8"> In <a href="#fnref8">↩</a></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
<li id="fn10"><a href="#fnref10">↩</a></li>
<li id="fn11"> <a href="http://www.tcs.hut.fi/~ini/papers/nss-lpnmr99-www.ps.gz">as Postscript</a><a href="#fnref11">↩</a></li>
<li id="fn12"> <a href="http://www.cs.utexas.edu/users/vl/papers/weight.ps">as Postscript</a><a href="#fnref12">↩</a></li>
<li id="fn13">[<a class="uri" href="http://loqtek.com/?id=course_pars&amp;sec">http://loqtek.com/?id=course_pars&amp;sec;</a>;=1 Dependency parsing]<a href="#fnref13">↩</a></li>
<li id="fn14"><a href="#fnref14">↩</a></li>
<li id="fn15"></li>
</ol>
</section>
