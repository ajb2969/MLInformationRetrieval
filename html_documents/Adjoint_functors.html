<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1729">Adjoint functors</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Adjoint functors</h1>
<hr/>

<p>In <a class="uri" href="mathematics" title="wikilink">mathematics</a>, specifically <a href="category_theory" title="wikilink">category theory</a>, <strong>adjunction</strong> is a possible relationship between two <a href="functor" title="wikilink">functors</a>.</p>

<p>Adjunction is ubiquitous in mathematics, as it specifies intuitive notions of optimization and efficiency.</p>

<p>In the most concise symmetric definition, an adjunction between categories <em>C</em> and <em>D</em> is a pair of functors,</p>

<p>

<math display="block" id="Adjoint_functors:0">
 <semantics>
  <mrow>
   <mi>F</mi>
   <mo>:</mo>
   <mrow>
    <mi class="ltx_font_mathcaligraphic">𝒟</mi>
    <mo>→</mo>
    <mi class="ltx_font_mathcaligraphic">𝒞</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>F</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>𝒟</ci>
     <ci>𝒞</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F:\mathcal{D}\rightarrow\mathcal{C}
  </annotation>
 </semantics>
</math>

   and   

<math display="inline" id="Adjoint_functors:1">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mo>:</mo>
   <mrow>
    <mi class="ltx_font_mathcaligraphic">𝒞</mi>
    <mo>→</mo>
    <mi class="ltx_font_mathcaligraphic">𝒟</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>G</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>𝒞</ci>
     <ci>𝒟</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G:\mathcal{C}\rightarrow\mathcal{D}
  </annotation>
 </semantics>
</math>

 and a family of <a href="bijection" title="wikilink">bijections</a></p>

<p>

<math display="block" id="Adjoint_functors:2">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>hom</mi>
     <mi class="ltx_font_mathcaligraphic">𝒞</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>F</mi>
      <mi>Y</mi>
     </mrow>
     <mo>,</mo>
     <mi>X</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≅</mo>
   <mrow>
    <msub>
     <mi>hom</mi>
     <mi class="ltx_font_mathcaligraphic">𝒟</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>Y</mi>
     <mo>,</mo>
     <mrow>
      <mi>G</mi>
      <mi>X</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>hom</ci>
      <ci>𝒞</ci>
     </apply>
     <interval closure="open">
      <apply>
       <times></times>
       <ci>F</ci>
       <ci>Y</ci>
      </apply>
      <ci>X</ci>
     </interval>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>hom</ci>
      <ci>𝒟</ci>
     </apply>
     <interval closure="open">
      <ci>Y</ci>
      <apply>
       <times></times>
       <ci>G</ci>
       <ci>X</ci>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{hom}_{\mathcal{C}}(FY,X)\cong\mathrm{hom}_{\mathcal{D}}(Y,GX)
  </annotation>
 </semantics>
</math>

 which is <a href="natural_transformation" title="wikilink">natural</a> in the variables <em>X</em> and <em>Y</em>. The functor <em>F</em> is called a <strong>left adjoint functor</strong>, while <em>G</em> is called a <strong>right adjoint functor</strong>. The relationship “<em>F</em> is left adjoint to <em>G</em>” (or equivalently, “<em>G</em> is right adjoint to <em>F</em>”) is sometimes written</p>

<p>

<math display="block" id="Adjoint_functors:3">
 <semantics>
  <mrow>
   <mrow>
    <mi>F</mi>
    <mo>⊣</mo>
    <mi>G</mi>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">does-not-prove</csymbol>
    <ci>F</ci>
    <ci>G</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F\dashv G.
  </annotation>
 </semantics>
</math>

</p>

<p>This definition and others are made precise below.</p>
<h2 id="introduction">Introduction</h2>

<p>“The slogan is ‘Adjoint functors arise everywhere’.” (Saunders Mac Lane, <em>Categories for the working mathematician</em>)</p>

<p>The <a href="Adjoint_functors#Examples" title="wikilink">long list of examples</a> in this article is only a partial indication of how often an interesting mathematical construction is an adjoint functor. As a result, general theorems about left/right adjoint functors, such as the equivalence of their various definitions or the fact that they respectively preserve <a href="Limit_(category_theory)" title="wikilink">colimits/limits</a> (which are also found in every area of mathematics), can encode the details of many useful and otherwise non-trivial results.</p>
<h3 id="spelling-or-morphology">Spelling (or <a href="morphology_(linguistics)" title="wikilink">morphology</a>)</h3>

<p>One can observe (e.g. in this article), two different <a href="root_(linguistics)" title="wikilink">roots</a> are used: "adjunct" and "adjoint". From Oxford shorter English dictionary, "adjunct" is from Latin, "adjoint" is from French.</p>

<p>In Mac Lane, <em>Categories for the working mathematician,</em> chap. 4, "Adjoints", one can verify the following usage.</p>

<p>

<math display="inline" id="Adjoint_functors:4">
 <semantics>
  <mrow>
   <mi>φ</mi>
   <mo>:</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>hom</mi>
      <mi class="ltx_font_mathcaligraphic">𝒞</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>F</mi>
       <mi>Y</mi>
      </mrow>
      <mo>,</mo>
      <mi>X</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>≅</mo>
    <mrow>
     <msub>
      <mi>hom</mi>
      <mi class="ltx_font_mathcaligraphic">𝒟</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>Y</mi>
      <mo>,</mo>
      <mrow>
       <mi>G</mi>
       <mi>X</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>φ</ci>
    <apply>
     <approx></approx>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>hom</ci>
       <ci>𝒞</ci>
      </apply>
      <interval closure="open">
       <apply>
        <times></times>
        <ci>F</ci>
        <ci>Y</ci>
       </apply>
       <ci>X</ci>
      </interval>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>hom</ci>
       <ci>𝒟</ci>
      </apply>
      <interval closure="open">
       <ci>Y</ci>
       <apply>
        <times></times>
        <ci>G</ci>
        <ci>X</ci>
       </apply>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varphi:\mathrm{hom}_{\mathcal{C}}(FY,X)\cong\mathrm{hom}_{\mathcal{D}}(Y,GX)
  </annotation>
 </semantics>
</math>

</p>

<p>The hom-set bijection 

<math display="inline" id="Adjoint_functors:5">
 <semantics>
  <mi>φ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>φ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varphi
  </annotation>
 </semantics>
</math>

 is an "adjunction".</p>

<p>If 

<math display="inline" id="Adjoint_functors:6">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 an arrow in 

<math display="inline" id="Adjoint_functors:7">
 <semantics>
  <mrow>
   <msub>
    <mi>hom</mi>
    <mi class="ltx_font_mathcaligraphic">𝒞</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>F</mi>
     <mi>Y</mi>
    </mrow>
    <mo>,</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>hom</ci>
     <ci>𝒞</ci>
    </apply>
    <interval closure="open">
     <apply>
      <times></times>
      <ci>F</ci>
      <ci>Y</ci>
     </apply>
     <ci>X</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{hom}_{\mathcal{C}}(FY,X)
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Adjoint_functors:8">
 <semantics>
  <mrow>
   <mi>φ</mi>
   <mi>f</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>φ</ci>
    <ci>f</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varphi f
  </annotation>
 </semantics>
</math>

 is the right "adjunct" of 

<math display="inline" id="Adjoint_functors:9">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 (p. 81).</p>

<p>The functor 

<math display="inline" id="Adjoint_functors:10">
 <semantics>
  <mi>F</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>F</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F
  </annotation>
 </semantics>
</math>

 is left "adjoint" for 

<math display="inline" id="Adjoint_functors:11">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="motivation">Motivation</h2>
<h3 id="solutions-to-optimization-problems">Solutions to optimization problems</h3>

<p>It can be said that an adjoint functor is a way of giving the <em>most efficient</em> solution to some problem via a method which is <em>formulaic</em>. For example, an elementary problem in <a href="ring_theory" title="wikilink">ring theory</a> is how to turn a <a href="Rng_(algebra)" title="wikilink">rng</a> (which is like a ring that might not have a multiplicative identity) into a <a href="ring_(mathematics)" title="wikilink">ring</a>. The <em>most efficient</em> way is to adjoin an element '1' to the rng, adjoin all (and only) the elements which are necessary for satisfying the ring axioms (e.g. <em>r</em>+1 for each <em>r</em> in the ring), and impose no relations in the newly formed ring that are not forced by axioms. Moreover, this construction is <em>formulaic</em> in the sense that it works in essentially the same way for any rng.</p>

<p>This is rather vague, though suggestive, and can be made precise in the language of category theory: a construction is <em>most efficient</em> if it satisfies a <a href="universal_property" title="wikilink">universal property</a>, and is <em>formulaic</em> if it defines a <a class="uri" href="functor" title="wikilink">functor</a>. Universal properties come in two types: initial properties and terminal properties. Since these are <a href="dual_(category_theory)" title="wikilink">dual</a> (opposite) notions, it is only necessary to discuss one of them.</p>

<p>The idea of using an initial property is to set up the problem in terms of some auxiliary category <em>E</em>, and then identify that what we want is to find an <a href="initial_object" title="wikilink">initial object</a> of <em>E</em>. This has an advantage that the <em>optimization</em> — the sense that we are finding the <em>most efficient</em> solution — means something rigorous and is recognisable, rather like the attainment of a <a class="uri" href="supremum" title="wikilink">supremum</a>. The category <em>E</em> is also formulaic in this construction, since it is always the category of elements of the functor to which one is constructing an adjoint. In fact, this latter category is precisely the comma category over the functor in question.</p>

<p>As an example, take the given rng <em>R</em>, and make a category <em>E</em> whose <em>objects</em> are rng homomorphisms <em>R</em> → <em>S</em>, with <em>S</em> a ring having a multiplicative identity. The <em>morphisms</em> in <em>E</em> between <em>R</em> → <em>S<sub>1</sub></em> and <em>R</em> → <em>S<sub>2</sub></em> are <a href="commutative_diagram" title="wikilink">commutative triangles</a> of the form (<em>R</em> → <em>S<sub>1</sub></em>,<em>R</em> → <em>S<sub>2</sub></em>, <em>S<sub>1</sub></em> → <em>S<sub>2</sub></em>) where S<sub>1</sub> → S<sub>2</sub> is a ring map (which preserves the identity). Note that this is precisely the definition of the comma category of <em>R</em> over the inclusion of unitary rings into rng. The existence of a morphism between <em>R</em> → <em>S<sub>1</sub></em> and <em>R</em> → <em>S<sub>2</sub></em> implies that <em>S<sub>1</sub></em> is at least as efficient a solution as <em>S<sub>2</sub></em> to our problem: <em>S<sub>2</sub></em> can have more adjoined elements and/or more relations not imposed by axioms than <em>S<sub>1</sub></em>. Therefore, the assertion that an object <em>R</em> → <em>R*</em> is initial in <em>E</em>, that is, that there is a morphism from it to any other element of <em>E</em>, means that the ring <em>R</em>* is a <em>most efficient</em> solution to our problem.</p>

<p>The two facts that this method of turning rngs into rings is <em>most efficient</em> and <em>formulaic</em> can be expressed simultaneously by saying that it defines an <em>adjoint functor</em>.</p>
<h3 id="symmetry-of-optimization-problems">Symmetry of optimization problems</h3>

<p>Continuing this discussion, suppose we <em>started</em> with the functor <em>F</em>, and posed the following (vague) question: is there a problem to which <em>F</em> is the most efficient solution?</p>

<p>The notion that <em>F</em> is the <em>most efficient solution</em> to the problem posed by <em>G</em> is, in a certain rigorous sense, equivalent to the notion that <em>G</em> poses the <em>most difficult problem</em> that <em>F</em> solves. </p>

<p>This has the intuitive meaning that adjoint functors should occur in pairs, and in fact they do, but this is not trivial from the universal morphism definitions. The equivalent symmetric definitions involving adjunctions and the symmetric language of adjoint functors (we can say either <em>F</em> is left adjoint to <em>G</em> or <em>G</em> is right adjoint to <em>F</em>) have the advantage of making this fact explicit.</p>
<h2 id="formal-definitions">Formal definitions</h2>

<p>There are various definitions for adjoint functors. Their equivalence is elementary but not at all trivial and in fact highly useful. This article provides several such definitions:</p>
<ul>
<li>The definitions via universal morphisms are easy to state, and require minimal verifications when constructing an adjoint functor or proving two functors are adjoint. They are also the most analogous to our intuition involving optimizations.</li>
<li>The definition via counit-unit adjunction is convenient for proofs about functors which are known to be adjoint, because they provide formulas that can be directly manipulated.</li>
<li>The definition via hom-sets makes symmetry the most apparent, and is the reason for using the word <em>adjoint</em>.</li>
</ul>

<p>Adjoint functors arise everywhere, in all areas of mathematics. Their full usefulness lies in that the structure in any of these definitions gives rise to the structures in the others via a long but trivial series of deductions. Thus, switching between them makes implicit use of a great deal of tedious details that would otherwise have to be repeated separately in every subject area. For example, naturality and terminality of the counit can be used to prove that any right adjoint functor preserves limits.</p>
<h3 id="conventions">Conventions</h3>

<p>The theory of adjoints has the terms <em>left</em> and <em>right</em> at its foundation, and there are many components which live in one of two categories <em>C</em> and <em>D</em> which are under consideration. It can therefore be extremely helpful to choose letters in alphabetical order according to whether they live in the "lefthand" category <em>C</em> or the "righthand" category <em>D</em>, and also to write them down in this order whenever possible.</p>

<p>In this article for example, the letters <em>X</em>, <em>F</em>, <em>f</em>, ε will consistently denote things which live in the category <em>C</em>, the letters <em>Y</em>, <em>G</em>, <em>g</em>, η will consistently denote things which live in the category <em>D</em>, and whenever possible such things will be referred to in order from left to right (a functor <em>F</em>:<em>C</em>←<em>D</em> can be thought of as "living" where its outputs are, in <em>C</em>).</p>
<h3 id="universal-morphisms">Universal morphisms</h3>

<p>A functor <em>F</em> : <em>C</em> ← <em>D</em> is a <strong>left adjoint functor</strong> if for each object <em>X</em> in <em>C</em>, there exists a <a href="terminal_morphism" title="wikilink">terminal morphism</a> from <em>F</em> to <em>X</em>. If, for each object <em>X</em> in <em>C</em>, we choose an object <em>G</em><sub>0</sub><em>X</em> of <em>D</em> for which there is a terminal morphism ε<sub><em>X</em></sub> : <em>F</em>(<em>G</em><sub>0</sub><em>X</em>) → <em>X</em> from <em>F</em> to <em>X</em>, then there is a unique functor <em>G</em> : <em>C</em> → <em>D</em> such that <em>GX</em> = <em>G</em><sub>0</sub><em>X</em> and ε<sub><em>Xʹ</em></sub> ∘ <em>FG</em>(<em>f</em>) = <em>f</em> ∘ ε<sub><em>X</em></sub> for <em>f</em> : <em>X</em> → <em>Xʹ</em> a morphism in <em>C</em>; <em>F</em> is then called a '''left adjoint to ''' <em>G</em>.</p>

<p>A functor <em>G</em> : <em>C</em> → <em>D</em> is a <strong>right adjoint functor</strong> if for each object <em>Y</em> in <em>D</em>, there exists an <a href="initial_morphism" title="wikilink">initial morphism</a> from <em>Y</em> to <em>G</em>. If, for each object <em>Y</em> in <em>D</em>, we choose an object <em>F</em><sub>0</sub><em>Y</em> of <em>C</em> and an initial morphism η<sub><em>Y</em></sub> : <em>Y</em> → <em>G</em>(<em>F</em><sub>0</sub><em>Y</em>) from <em>Y</em> to <em>G</em>, then there is a unique functor <em>F</em> : <em>C</em> ← <em>D</em> such that <em>FY</em> = <em>F</em><sub>0</sub><em>Y</em> and <em>GF</em>(<em>g</em>) ∘ η<sub><em>Y</em></sub> = η<sub><em>Yʹ</em></sub> ∘ <em>g</em> for <em>g</em> : <em>Y</em> → <em>Yʹ</em> a morphism in <em>D</em>; <em>G</em> is then called a '''right adjoint to ''' <em>F</em>.</p>

<p>''' ''Remarks: '' '''</p>

<p>It is true, as the terminology implies, that <em>F</em> is <em>left adjoint to G</em> if and only if <em>G</em> is <em>right adjoint to F</em>. This is apparent from the symmetric definitions given below. The definitions via universal morphisms are often useful for establishing that a given functor is left or right adjoint, because they are minimalistic in their requirements. They are also intuitively meaningful in that finding a universal morphism is like solving an optimization problem.</p>
<h3 id="counit-unit-adjunction">Counit-unit adjunction</h3>

<p>A <strong>counit-unit adjunction</strong> between two categories <em>C</em> and <em>D</em> consists of two <a href="functor" title="wikilink">functors</a> <em>F</em> : <em>C</em> ← <em>D</em> and <em>G</em> : <em>C</em> → <em>D</em> and two <a href="natural_transformation" title="wikilink">natural transformations</a></p>

<p>

<math display="inline" id="Adjoint_functors:12">
 <semantics>
  <mi>ε</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ε</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle\varepsilon
  </annotation>
 </semantics>
</math>


 respectively called the <strong>counit</strong> and the <strong>unit</strong> of the adjunction (terminology from <a href="universal_algebra" title="wikilink">universal algebra</a>), such that the compositions</p>

<p>

<math display="block" id="Adjoint_functors:13">
 <semantics>
  <mrow>
   <mi>F</mi>
   <mover accent="true">
    <mo>→</mo>
    <mrow>
     <mpadded lspace="2.8pt" width="+2.8pt">
      <mi>F</mi>
     </mpadded>
     <mpadded width="+2.8pt">
      <mi>η</mi>
     </mpadded>
    </mrow>
   </mover>
   <mrow>
    <mi>F</mi>
    <mi>G</mi>
    <mi>F</mi>
   </mrow>
   <mover accent="true">
    <mo>→</mo>
    <mrow>
     <mpadded lspace="2.8pt" width="+2.8pt">
      <mi>ε</mi>
     </mpadded>
     <mpadded width="+1.7pt">
      <mi>F</mi>
     </mpadded>
    </mrow>
   </mover>
   <mi>F</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <apply>
      <apply>
       <times></times>
       <ci>F</ci>
       <ci>η</ci>
      </apply>
      <ci>normal-→</ci>
     </apply>
     <ci>F</ci>
     <apply>
      <times></times>
      <ci>F</ci>
      <ci>G</ci>
      <ci>F</ci>
     </apply>
    </apply>
    <apply>
     <apply>
      <apply>
       <times></times>
       <ci>ε</ci>
       <ci>F</ci>
      </apply>
      <ci>normal-→</ci>
     </apply>
     <share href="#.cmml">
     </share>
     <ci>F</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F\xrightarrow{\;F\eta\;}FGF\xrightarrow{\;\varepsilon F\,}F
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Adjoint_functors:14">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mover accent="true">
    <mo>→</mo>
    <mrow>
     <mpadded lspace="2.8pt" width="+2.8pt">
      <mi>η</mi>
     </mpadded>
     <mpadded width="+2.8pt">
      <mi>G</mi>
     </mpadded>
    </mrow>
   </mover>
   <mrow>
    <mi>G</mi>
    <mi>F</mi>
    <mi>G</mi>
   </mrow>
   <mover accent="true">
    <mo>→</mo>
    <mrow>
     <mpadded lspace="2.8pt" width="+2.8pt">
      <mi>G</mi>
     </mpadded>
     <mpadded width="+1.7pt">
      <mi>ε</mi>
     </mpadded>
    </mrow>
   </mover>
   <mi>G</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <apply>
      <apply>
       <times></times>
       <ci>η</ci>
       <ci>G</ci>
      </apply>
      <ci>normal-→</ci>
     </apply>
     <ci>G</ci>
     <apply>
      <times></times>
      <ci>G</ci>
      <ci>F</ci>
      <ci>G</ci>
     </apply>
    </apply>
    <apply>
     <apply>
      <apply>
       <times></times>
       <ci>G</ci>
       <ci>ε</ci>
      </apply>
      <ci>normal-→</ci>
     </apply>
     <share href="#.cmml">
     </share>
     <ci>G</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G\xrightarrow{\;\eta G\;}GFG\xrightarrow{\;G\varepsilon\,}G
  </annotation>
 </semantics>
</math>

 are the identity transformations 1<sub><em>F</em></sub> and 1<sub><em>G</em></sub> on <em>F</em> and <em>G</em> respectively.</p>

<p>In this situation we say that ''' <em>F</em> is left adjoint to <em>G</em> ''' and ''' <em>G</em> is right adjoint to <em>F</em> ''', and may indicate this relationship by writing  

<math display="inline" id="Adjoint_functors:15">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>ε</mi>
    <mo>,</mo>
    <mi>η</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>:</mo>
   <mi>F</mi>
   <mo>⊣</mo>
   <mi>G</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-:</ci>
     <interval closure="open">
      <ci>ε</ci>
      <ci>η</ci>
     </interval>
     <ci>F</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">does-not-prove</csymbol>
     <share href="#.cmml">
     </share>
     <ci>G</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\varepsilon,\eta):F\dashv G
  </annotation>
 </semantics>
</math>

 , or simply  

<math display="inline" id="Adjoint_functors:16">
 <semantics>
  <mrow>
   <mi>F</mi>
   <mo>⊣</mo>
   <mi>G</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">does-not-prove</csymbol>
    <ci>F</ci>
    <ci>G</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F\dashv G
  </annotation>
 </semantics>
</math>

 .</p>

<p>In equation form, the above conditions on (ε,η) are the <strong>counit-unit equations</strong></p>

<p>

<math display="inline" id="Adjoint_functors:17">
 <semantics>
  <msub>
   <mn>1</mn>
   <mi>F</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <cn type="integer">1</cn>
    <ci>F</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle 1_{F}
  </annotation>
 </semantics>
</math>


 which mean that for each <em>X</em> in <em>C</em> and each <em>Y</em> in <em>D</em>,</p>

<p>

<math display="inline" id="Adjoint_functors:18">
 <semantics>
  <msub>
   <mn>1</mn>
   <mrow>
    <mi>F</mi>
    <mi>Y</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <cn type="integer">1</cn>
    <apply>
     <times></times>
     <ci>F</ci>
     <ci>Y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle 1_{FY}
  </annotation>
 </semantics>
</math>


.</p>

<p>Note that here 

<math display="inline" id="Adjoint_functors:19">
 <semantics>
  <mn>1</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">1</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1
  </annotation>
 </semantics>
</math>


 denotes identity functors, while above the same symbol was used for identity natural transformations.</p>

<p>These equations are useful in reducing proofs about adjoint functors to algebraic manipulations. They are sometimes called the <em>zig-zag equations</em> because of the appearance of the corresponding <a href="string_diagram" title="wikilink">string diagrams</a>. A way to remember them is to first write down the nonsensical equation 

<math display="inline" id="Adjoint_functors:20">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>=</mo>
   <mrow>
    <mi>ε</mi>
    <mo>∘</mo>
    <mi>η</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <cn type="integer">1</cn>
    <apply>
     <compose></compose>
     <ci>ε</ci>
     <ci>η</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1=\varepsilon\circ\eta
  </annotation>
 </semantics>
</math>

 and then fill in either <em>F</em> or <em>G</em> in one of the two simple ways which make the compositions defined.</p>

<p>Note: The use of the prefix "co" in counit here is not consistent with the terminology of limits and colimits, because a colimit satisfies an <em>initial</em> property whereas the counit morphisms will satisfy <em>terminal</em> properties, and dually. The term <em>unit</em> here is borrowed from the theory of <a href="Monad_(category_theory)" title="wikilink">monads</a> where it looks like the insertion of the identity 1 into a monoid.</p>
<h3 id="hom-set-adjunction">Hom-set adjunction</h3>

<p>A <strong><a class="uri" href="hom-set" title="wikilink">hom-set</a> adjunction</strong> between two categories <em>C</em> and <em>D</em> consists of two <a href="functor" title="wikilink">functors</a> <em>F</em> : <em>C</em> ← <em>D</em> and <em>G</em> : <em>C</em> → <em>D</em> and a <a href="natural_isomorphism" title="wikilink">natural isomorphism</a></p>

<p>

<math display="block" id="Adjoint_functors:21">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Φ</mi>
   <mo>:</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>hom</mi>
      <mi>C</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>F</mi>
       <mo>-</mo>
      </mrow>
      <mo>,</mo>
      <mo>-</mo>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>→</mo>
    <mrow>
     <msub>
      <mi>hom</mi>
      <mi>D</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mo>-</mo>
      <mo>,</mo>
      <mrow>
       <mi>G</mi>
       <mo>-</mo>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>normal-Φ</ci>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>hom</ci>
       <ci>C</ci>
      </apply>
      <interval closure="open">
       <apply>
        <csymbol cd="latexml">limit-from</csymbol>
        <ci>F</ci>
        <minus></minus>
       </apply>
       <minus></minus>
      </interval>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>hom</ci>
       <ci>D</ci>
      </apply>
      <interval closure="open">
       <minus></minus>
       <apply>
        <csymbol cd="latexml">limit-from</csymbol>
        <ci>G</ci>
        <minus></minus>
       </apply>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Phi:\mathrm{hom}_{C}(F-,-)\to\mathrm{hom}_{D}(-,G-)
  </annotation>
 </semantics>
</math>

. This specifies a family of bijections</p>

<p>

<math display="block" id="Adjoint_functors:22">
 <semantics>
  <mrow>
   <msub>
    <mi mathvariant="normal">Φ</mi>
    <mrow>
     <mi>Y</mi>
     <mo>,</mo>
     <mi>X</mi>
    </mrow>
   </msub>
   <mo>:</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>hom</mi>
      <mi>C</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>F</mi>
       <mi>Y</mi>
      </mrow>
      <mo>,</mo>
      <mi>X</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>→</mo>
    <mrow>
     <msub>
      <mi>hom</mi>
      <mi>D</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>Y</mi>
      <mo>,</mo>
      <mrow>
       <mi>G</mi>
       <mi>X</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-Φ</ci>
     <list>
      <ci>Y</ci>
      <ci>X</ci>
     </list>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>hom</ci>
       <ci>C</ci>
      </apply>
      <interval closure="open">
       <apply>
        <times></times>
        <ci>F</ci>
        <ci>Y</ci>
       </apply>
       <ci>X</ci>
      </interval>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>hom</ci>
       <ci>D</ci>
      </apply>
      <interval closure="open">
       <ci>Y</ci>
       <apply>
        <times></times>
        <ci>G</ci>
        <ci>X</ci>
       </apply>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Phi_{Y,X}:\mathrm{hom}_{C}(FY,X)\to\mathrm{hom}_{D}(Y,GX)
  </annotation>
 </semantics>
</math>

. for all objects <em>X</em> in <em>C</em> and <em>Y</em> in <em>D</em>.</p>

<p>In this situation we say that ''' <em>F</em> is left adjoint to <em>G</em> ''' and ''' <em>G</em> is right adjoint to <em>F</em> ''', and may indicate this relationship by writing  

<math display="inline" id="Adjoint_functors:23">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Φ</mi>
   <mo>:</mo>
   <mi>F</mi>
   <mo>⊣</mo>
   <mi>G</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-:</ci>
     <ci>normal-Φ</ci>
     <ci>F</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">does-not-prove</csymbol>
     <share href="#.cmml">
     </share>
     <ci>G</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Phi:F\dashv G
  </annotation>
 </semantics>
</math>

 , or simply  

<math display="inline" id="Adjoint_functors:24">
 <semantics>
  <mrow>
   <mi>F</mi>
   <mo>⊣</mo>
   <mi>G</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">does-not-prove</csymbol>
    <ci>F</ci>
    <ci>G</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F\dashv G
  </annotation>
 </semantics>
</math>


 .</p>

<p>This definition is a logical compromise in that it is somewhat more difficult to satisfy than the universal morphism definitions, and has fewer immediate implications than the counit-unit definition. It is useful because of its obvious symmetry, and as a stepping-stone between the other definitions.</p>

<p>In order to interpret Φ as a <em>natural isomorphism</em>, one must recognize hom<sub><em>C</em></sub>(<em>F</em>–, –) and hom<sub><em>D</em></sub>(–, <em>G</em>–) as functors. In fact, they are both <a href="bifunctor" title="wikilink">bifunctors</a> from <em>D</em><sup>op</sup> × <em>C</em> to <strong>Set</strong> (the <a href="category_of_sets" title="wikilink">category of sets</a>). For details, see the article on <a href="hom_functor" title="wikilink">hom functors</a>. Explicitly, the naturality of Φ means that for all <a href="morphism" title="wikilink">morphisms</a> <em>f</em> : <em>X</em> → <em>X′</em> in <em>C</em> and all morphisms <em>g</em> : ''Y′ '' → <em>Y</em> in <em>D</em> the following diagram <a href="commutative_diagram" title="wikilink">commutes</a>:</p>
<figure><b>(Figure)</b>
<figcaption>Naturality of Φ|400px</figcaption>
</figure>

<p>The vertical arrows in this diagram are those induced by composition with <em>f</em> and <em>g</em>. Formally, Hom(<em>Fg</em>, <em>f</em>) : Hom<sub>C</sub>(<em>FY</em>, <em>X</em>) → Hom<sub>C</sub>(<em>FY′</em>, <em>X′</em>) is given by <em>h</em> → <em>f <small>o</small> h <small>o</small> Fg</em> for each <em>h</em> in Hom<sub>C</sub>(<em>FY</em>, <em>X</em>). Hom(<em>g</em>, <em>Gf</em>) is similar.</p>
<h2 id="adjunctions-in-full">Adjunctions in full</h2>

<p>There are hence numerous functors and natural transformations associated with every adjunction, and only a small portion is sufficient to determine the rest.</p>

<p>An <em>adjunction</em> between categories <em>C</em> and <em>D</em> consists of</p>
<ul>
<li>A <a class="uri" href="functor" title="wikilink">functor</a> <em>F</em> : <em>C</em> ← <em>D</em> called the <strong>left adjoint</strong></li>
<li>A functor <em>G</em> : <em>C</em> → <em>D</em> called the <strong>right adjoint</strong></li>
<li>A <a href="natural_isomorphism" title="wikilink">natural isomorphism</a> Φ : hom<sub><em>C</em></sub>(<em>F</em>–,–) → hom<sub><em>D</em></sub>(–,<em>G</em>–)</li>
<li>A <a href="natural_transformation" title="wikilink">natural transformation</a> ε : <em>FG</em> → 1<sub><em>C</em></sub> called the <strong>counit</strong></li>
<li>A natural transformation η : 1<sub><em>D</em></sub> → <em>GF</em> called the <strong>unit</strong></li>
</ul>

<p>An equivalent formulation, where <em>X</em> denotes any object of <em>C</em> and <em>Y</em> denotes any object of <em>D</em>:</p>

<p>''For every <em>C</em>-morphism <em>f</em> : <em>FY</em> → <em>X</em>, there is a unique <em>D</em>-morphism Φ<sub><em>Y</em>, <em>X</em></sub>(<em>f</em>) = <em>g</em> : <em>Y</em> → <em>GX</em> such that the diagrams below commute, and for every <em>D</em>-morphism <em>g</em> : <em>Y</em> → <em>GX</em>, there is a unique <em>C</em>-morphism Φ<sup>−1</sup><sub><em>Y</em>, <em>X</em></sub>(<em>g</em>) = <em>f</em> : <em>FY</em> → <em>X</em> in <em>C</em> such that the diagrams below commute:''</p>
<figure><b>(Figure)</b>
<figcaption>Adjoint functors sym.svg</figcaption>
</figure>

<p>From this assertion, one can recover that:</p>
<ul>
<li>The transformations ε, η, and Φ are related by the equations</li>
</ul>

<p>

<math display="inline" id="Adjoint_functors:25">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mi mathvariant="normal">Φ</mi>
     <mrow>
      <mi>Y</mi>
      <mo>,</mo>
      <mi>X</mi>
     </mrow>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msubsup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>g</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>f</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>normal-Φ</ci>
       <list>
        <ci>Y</ci>
        <ci>X</ci>
       </list>
      </apply>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>g</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle f=\Phi_{Y,X}^{-1}(g)
  </annotation>
 </semantics>
</math>


</p>
<ul>
<li>The transformations ε, η satisfy the counit-unit equations</li>
</ul>

<p>

<math display="inline" id="Adjoint_functors:26">
 <semantics>
  <msub>
   <mn>1</mn>
   <mrow>
    <mi>F</mi>
    <mi>Y</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <cn type="integer">1</cn>
    <apply>
     <times></times>
     <ci>F</ci>
     <ci>Y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle 1_{FY}
  </annotation>
 </semantics>
</math>


</p>
<ul>
<li>Each pair (<em>GX</em>, ε<sub><em>X</em></sub>) is a <a href="universal_morphism" title="wikilink">terminal morphism</a> from <em>F</em> to <em>X</em> in <em>C</em></li>
<li>Each pair (<em>FY</em>, η<sub><em>Y</em></sub>) is an <a href="universal_morphism" title="wikilink">initial morphism</a> from <em>Y</em> to <em>G</em> in <em>D</em></li>
</ul>

<p>In particular, the equations above allow one to define Φ, ε, and η in terms of any one of the three. However, the adjoint functors <em>F</em> and <em>G</em> alone are in general not sufficient to determine the adjunction. We will demonstrate the equivalence of these situations below.</p>
<h3 id="universal-morphisms-induce-hom-set-adjunction">Universal morphisms induce hom-set adjunction</h3>

<p>Given a right adjoint functor <em>G</em> : <em>C</em> → <em>D</em>; in the sense of initial morphisms, one may construct the induced hom-set adjunction by doing the following steps.</p>
<ul>
<li>Construct a functor <em>F</em> : <em>C</em> ← <em>D</em> and a natural transformation η.
<ul>
<li>For each object <em>Y</em> in <em>D</em>, choose an initial morphism (<em>F</em>(<em>Y</em>), η<sub><em>Y</em></sub>) from <em>Y</em> to <em>G</em>, so we have η<sub><em>Y</em></sub> : <em>Y</em> → <em>G</em>(<em>F</em>(<em>Y</em>)). We have the map of <em>F</em> on objects and the family of morphisms η.</li>
<li>For each <em>f</em> : <em>Y</em><sub>0</sub> → <em>Y</em><sub>1</sub>, as (<em>F</em>(<em>Y</em><sub>0</sub>), η<sub><em>Y</em><sub>0</sub></sub>) is an initial morphism, then factorize η<sub><em>Y</em><sub>1</sub></sub> <small>o</small> <em>f</em> with η<sub><em>Y</em><sub>0</sub></sub> and get <em>F</em>(<em>f</em>) : <em>F</em>(<em>Y</em><sub>0</sub>) → <em>F</em>(<em>Y</em><sub>1</sub>). This is the map of <em>F</em> on morphisms.</li>
<li>The commuting diagram of that factorization implies the commuting diagram of natural transformations, so η : 1<sub><em>D</em></sub> → <em>G</em> <small>o</small> <em>F</em> is a <a href="natural_transformation" title="wikilink">natural transformation</a>.</li>
<li>Uniqueness of that factorization and that <em>G</em> is a functor implies that the map of <em>F</em> on morphisms preserves compositions and identities.</li>
</ul></li>
<li>Construct a natural isomorphism Φ : hom<sub><em>C</em></sub>(<em>F</em>-,-) → hom<sub><em>D</em></sub>(-,<em>G</em>-).
<ul>
<li>For each object <em>X</em> in <em>C</em>, each object <em>Y</em> in <em>D</em>, as (<em>F</em>(<em>Y</em>), η<sub><em>Y</em></sub>) is an initial morphism, then Φ<sub><em>Y</em>, <em>X</em></sub> is a bijection, where Φ<sub><em>Y</em>, <em>X</em></sub>(<em>f</em> : <em>F</em>(<em>Y</em>) → <em>X</em>) = <em>G</em>(<em>f</em>) <small>o</small> η<sub><em>Y</em></sub>.</li>
<li>η is a natural transformation, <em>G</em> is a functor, then for any objects <em>X</em><sub>0</sub>, <em>X</em><sub>1</sub> in <em>C</em>, any objects <em>Y</em><sub>0</sub>, <em>Y</em><sub>1</sub> in <em>D</em>, any <em>x</em> : <em>X</em><sub>0</sub> → <em>X</em><sub>1</sub>, any <em>y</em> : <em>Y</em><sub>1</sub> → <em>Y</em><sub>0</sub>, we have Φ<sub><em>Y</em><sub>1</sub>, <em>X</em><sub>1</sub></sub>(<em>x</em> <small>o</small> <em>f</em> <small>o</small> <em>F</em>(<em>y</em>)) = G(x) <small>o</small> <em>G</em>(<em>f</em>) <small>o</small> <em>G</em>(<em>F</em>(<em>y</em>)) <small>o</small> η<sub><em>Y</em><sub>1</sub></sub> = <em>G</em>(<em>x</em>) <small>o</small> <em>G</em>(<em>f</em>) <small>o</small> η<sub><em>Y</em><sub>0</sub></sub> <small>o</small> <em>y</em> = <em>G</em>(<em>x</em>) <small>o</small> Φ<sub><em>Y</em><sub>0</sub>, <em>X</em><sub>0</sub></sub>(<em>f</em>) <small>o</small> <em>y</em>, and then Φ is natural in both arguments.</li>
</ul></li>
</ul>

<p>A similar argument allows one to construct a hom-set adjunction from the terminal morphisms to a left adjoint functor. (The construction that starts with a right adjoint is slightly more common, since the right adjoint in many adjoint pairs is a trivially defined inclusion or forgetful functor.)</p>
<h3 id="counit-unit-adjunction-induces-hom-set-adjunction">Counit-unit adjunction induces hom-set adjunction</h3>

<p>Given functors <em>F</em> : <em>C</em> ← <em>D</em>, <em>G</em> : <em>C</em> → <em>D</em>, and a counit-unit adjunction (ε, η) : <em>F</em> 

<math display="inline" id="Adjoint_functors:27">
 <semantics>
  <mo>⊣</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">does-not-prove</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \dashv
  </annotation>
 </semantics>
</math>

 <em>G</em>, we can construct a hom-set adjunction by finding the natural transformation Φ : hom<sub><em>C</em></sub>(<em>F</em>-,-) → hom<sub><em>D</em></sub>(-,<em>G</em>-) in the following steps:</p>
<ul>
<li>For each <em>f</em> : <em>FY</em> → <em>X</em> and each <em>g</em> : <em>Y</em> → <em>GX</em>, define</li>
</ul>

<p>

<math display="inline" id="Adjoint_functors:28">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi mathvariant="normal">Φ</mi>
     <mrow>
      <mi>Y</mi>
      <mo>,</mo>
      <mi>X</mi>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>f</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>G</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>f</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>∘</mo>
    <msub>
     <mi>η</mi>
     <mi>Y</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-Φ</ci>
      <list>
       <ci>Y</ci>
       <ci>X</ci>
      </list>
     </apply>
     <ci>f</ci>
    </apply>
    <apply>
     <compose></compose>
     <apply>
      <times></times>
      <ci>G</ci>
      <ci>f</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>η</ci>
      <ci>Y</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle\Phi_{Y,X}(f)=G(f)\circ\eta_{Y}
  </annotation>
 </semantics>
</math>


</p>
<dl>
<dd>The transformations Φ and Ψ are natural because η and ε are natural.
</dd>
</dl>
<ul>
<li>Using, in order, that <em>F</em> is a functor, that ε is natural, and the counit-unit equation 1<sub><em>FY</em></sub> = ε<sub><em>FY</em></sub> <small>o</small> <em>F</em>(η<sub><em>Y</em></sub>), we obtain</li>
</ul>

<p>

<math display="inline" id="Adjoint_functors:29">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Ψ</mi>
   <mi mathvariant="normal">Φ</mi>
   <mi>f</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Ψ</ci>
    <ci>normal-Φ</ci>
    <ci>f</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle\Psi\Phi f
  </annotation>
 </semantics>
</math>


</p>
<dl>
<dd>hence ΨΦ is the identity transformation.
</dd>
</dl>
<ul>
<li>Dually, using that <em>G</em> is a functor, that η is natural, and the counit-unit equation 1<sub><em>GX</em></sub> = <em>G</em>(ε<sub><em>X</em></sub>) <small>o</small> η<sub><em>GX</em></sub>, we obtain</li>
</ul>

<p>

<math display="inline" id="Adjoint_functors:30">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Φ</mi>
   <mi mathvariant="normal">Ψ</mi>
   <mi>g</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Φ</ci>
    <ci>normal-Ψ</ci>
    <ci>g</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle\Phi\Psi g
  </annotation>
 </semantics>
</math>


</p>
<dl>
<dd>hence ΦΨ is the identity transformation. Thus Φ is a natural isomorphism with inverse Φ<sup>−1</sup> = Ψ.
</dd>
</dl>
<h3 id="hom-set-adjunction-induces-all-of-the-above">Hom-set adjunction induces all of the above</h3>

<p>Given functors <em>F</em> : <em>C</em> ← <em>D</em>, <em>G</em> : <em>C</em> → <em>D</em>, and a hom-set adjunction Φ : hom<sub><em>C</em></sub>(<em>F</em>-,-) → hom<sub><em>D</em></sub>(-,<em>G</em>-), we can construct a counit-unit adjunction</p>

<p>

<math display="block" id="Adjoint_functors:31">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>ε</mi>
    <mo>,</mo>
    <mi>η</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>:</mo>
   <mi>F</mi>
   <mo>⊣</mo>
   <mi>G</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-:</ci>
     <interval closure="open">
      <ci>ε</ci>
      <ci>η</ci>
     </interval>
     <ci>F</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">does-not-prove</csymbol>
     <share href="#.cmml">
     </share>
     <ci>G</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\varepsilon,\eta):F\dashv G
  </annotation>
 </semantics>
</math>

 ,</p>

<p>which defines families of initial and terminal morphisms, in the following steps:</p>
<ul>
<li>Let  

<math display="inline" id="Adjoint_functors:32">
 <semantics>
  <mrow>
   <msub>
    <mi>ε</mi>
    <mi>X</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mi mathvariant="normal">Φ</mi>
     <mrow>
      <mrow>
       <mi>G</mi>
       <mi>X</mi>
      </mrow>
      <mo>,</mo>
      <mi>X</mi>
     </mrow>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msubsup>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mn>1</mn>
      <mrow>
       <mi>G</mi>
       <mi>X</mi>
      </mrow>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>∈</mo>
   <mrow>
    <msub>
     <mi>hom</mi>
     <mi>C</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>F</mi>
      <mi>G</mi>
      <mi>X</mi>
     </mrow>
     <mo>,</mo>
     <mi>X</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ε</ci>
      <ci>X</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>normal-Φ</ci>
        <list>
         <apply>
          <times></times>
          <ci>G</ci>
          <ci>X</ci>
         </apply>
         <ci>X</ci>
        </list>
       </apply>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <cn type="integer">1</cn>
       <apply>
        <times></times>
        <ci>G</ci>
        <ci>X</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <in></in>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>hom</ci>
       <ci>C</ci>
      </apply>
      <interval closure="open">
       <apply>
        <times></times>
        <ci>F</ci>
        <ci>G</ci>
        <ci>X</ci>
       </apply>
       <ci>X</ci>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varepsilon_{X}=\Phi_{GX,X}^{-1}(1_{GX})\in\mathrm{hom}_{C}(FGX,X)
  </annotation>
 </semantics>
</math>

  for each <em>X</em> in <em>C</em>, where  

<math display="inline" id="Adjoint_functors:33">
 <semantics>
  <mrow>
   <msub>
    <mn>1</mn>
    <mrow>
     <mi>G</mi>
     <mi>X</mi>
    </mrow>
   </msub>
   <mo>∈</mo>
   <mrow>
    <msub>
     <mi>hom</mi>
     <mi>D</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>G</mi>
      <mi>X</mi>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mi>G</mi>
      <mi>X</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <cn type="integer">1</cn>
     <apply>
      <times></times>
      <ci>G</ci>
      <ci>X</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>hom</ci>
      <ci>D</ci>
     </apply>
     <interval closure="open">
      <apply>
       <times></times>
       <ci>G</ci>
       <ci>X</ci>
      </apply>
      <apply>
       <times></times>
       <ci>G</ci>
       <ci>X</ci>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1_{GX}\in\mathrm{hom}_{D}(GX,GX)
  </annotation>
 </semantics>
</math>

  is the identity morphism.</li>
</ul>
<ul>
<li>Let  

<math display="inline" id="Adjoint_functors:34">
 <semantics>
  <mrow>
   <msub>
    <mi>η</mi>
    <mi>Y</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi mathvariant="normal">Φ</mi>
     <mrow>
      <mi>Y</mi>
      <mo>,</mo>
      <mrow>
       <mi>F</mi>
       <mi>Y</mi>
      </mrow>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mn>1</mn>
      <mrow>
       <mi>F</mi>
       <mi>Y</mi>
      </mrow>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>∈</mo>
   <mrow>
    <msub>
     <mi>hom</mi>
     <mi>D</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>Y</mi>
     <mo>,</mo>
     <mrow>
      <mi>G</mi>
      <mi>F</mi>
      <mi>Y</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>η</ci>
      <ci>Y</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>normal-Φ</ci>
       <list>
        <ci>Y</ci>
        <apply>
         <times></times>
         <ci>F</ci>
         <ci>Y</ci>
        </apply>
       </list>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <cn type="integer">1</cn>
       <apply>
        <times></times>
        <ci>F</ci>
        <ci>Y</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <in></in>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>hom</ci>
       <ci>D</ci>
      </apply>
      <interval closure="open">
       <ci>Y</ci>
       <apply>
        <times></times>
        <ci>G</ci>
        <ci>F</ci>
        <ci>Y</ci>
       </apply>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \eta_{Y}=\Phi_{Y,FY}(1_{FY})\in\mathrm{hom}_{D}(Y,GFY)
  </annotation>
 </semantics>
</math>

  for each <em>Y</em> in <em>D</em>, where  

<math display="inline" id="Adjoint_functors:35">
 <semantics>
  <mrow>
   <msub>
    <mn>1</mn>
    <mrow>
     <mi>F</mi>
     <mi>Y</mi>
    </mrow>
   </msub>
   <mo>∈</mo>
   <mrow>
    <msub>
     <mi>hom</mi>
     <mi>C</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>F</mi>
      <mi>Y</mi>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mi>F</mi>
      <mi>Y</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <cn type="integer">1</cn>
     <apply>
      <times></times>
      <ci>F</ci>
      <ci>Y</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>hom</ci>
      <ci>C</ci>
     </apply>
     <interval closure="open">
      <apply>
       <times></times>
       <ci>F</ci>
       <ci>Y</ci>
      </apply>
      <apply>
       <times></times>
       <ci>F</ci>
       <ci>Y</ci>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1_{FY}\in\mathrm{hom}_{C}(FY,FY)
  </annotation>
 </semantics>
</math>

  is the identity morphism.</li>
</ul>
<ul>
<li>The bijectivity and naturality of Φ imply that each (<em>GX</em>, ε<sub><em>X</em></sub>) is a terminal morphism from <em>F</em> to <em>X</em> in <em>C</em>, and each (<em>FY</em>, η<sub><em>Y</em></sub>) is an initial morphism from <em>Y</em> to <em>G</em> in <em>D</em>.</li>
</ul>
<ul>
<li>The naturality of Φ implies the naturality of ε and η, and the two formulas</li>
</ul>

<p>

<math display="inline" id="Adjoint_functors:36">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi mathvariant="normal">Φ</mi>
     <mrow>
      <mi>Y</mi>
      <mo>,</mo>
      <mi>X</mi>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>f</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>G</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>f</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>∘</mo>
    <msub>
     <mi>η</mi>
     <mi>Y</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-Φ</ci>
      <list>
       <ci>Y</ci>
       <ci>X</ci>
      </list>
     </apply>
     <ci>f</ci>
    </apply>
    <apply>
     <compose></compose>
     <apply>
      <times></times>
      <ci>G</ci>
      <ci>f</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>η</ci>
      <ci>Y</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle\Phi_{Y,X}(f)=G(f)\circ\eta_{Y}
  </annotation>
 </semantics>
</math>


</p>
<dl>
<dd>for each <em>f</em>: <em>FY</em> → <em>X</em> and <em>g</em>: <em>Y</em> → <em>GX</em> (which completely determine Φ).
</dd>
</dl>
<ul>
<li>Substituting <em>FY</em> for <em>X</em> and η<sub><em>Y</em></sub> = Φ<sub><em>Y</em>, <em>FY</em></sub>(1<sub><em>FY</em></sub>) for <em>g</em> in the second formula gives the first counit-unit equation</li>
</ul>

<p>

<math display="block" id="Adjoint_functors:37">
 <semantics>
  <mrow>
   <msub>
    <mn>1</mn>
    <mrow>
     <mi>F</mi>
     <mi>Y</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>ε</mi>
      <mrow>
       <mi>F</mi>
       <mi>Y</mi>
      </mrow>
     </msub>
     <mo>∘</mo>
     <mi>F</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>η</mi>
      <mi>Y</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <cn type="integer">1</cn>
     <apply>
      <times></times>
      <ci>F</ci>
      <ci>Y</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <compose></compose>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ε</ci>
       <apply>
        <times></times>
        <ci>F</ci>
        <ci>Y</ci>
       </apply>
      </apply>
      <ci>F</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>η</ci>
      <ci>Y</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1_{FY}=\varepsilon_{FY}\circ F(\eta_{Y})
  </annotation>
 </semantics>
</math>

,</p>
<dl>
<dd>and substituting <em>GX</em> for <em>Y</em> and ε<sub>X</sub> = Φ<sup>−1</sup><sub><em>GX, X</em></sub>(1<sub><em>GX</em></sub>) for <em>f</em> in the first formula gives the second counit-unit equation
</dd>
<dd>

<math display="inline" id="Adjoint_functors:38">
 <semantics>
  <mrow>
   <msub>
    <mn>1</mn>
    <mrow>
     <mi>G</mi>
     <mi>X</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>G</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>ε</mi>
       <mi>X</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>∘</mo>
    <msub>
     <mi>η</mi>
     <mrow>
      <mi>G</mi>
      <mi>X</mi>
     </mrow>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <cn type="integer">1</cn>
     <apply>
      <times></times>
      <ci>G</ci>
      <ci>X</ci>
     </apply>
    </apply>
    <apply>
     <compose></compose>
     <apply>
      <times></times>
      <ci>G</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ε</ci>
       <ci>X</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>η</ci>
      <apply>
       <times></times>
       <ci>G</ci>
       <ci>X</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1_{GX}=G(\varepsilon_{X})\circ\eta_{GX}
  </annotation>
 </semantics>
</math>

.
</dd>
</dl>
<h2 id="history">History</h2>
<h3 id="ubiquity">Ubiquity</h3>

<p>The idea of an adjoint functor was formulated by <a href="Daniel_Kan" title="wikilink">Daniel Kan</a> in 1958. Like many of the concepts in category theory, it was suggested by the needs of <a href="homological_algebra" title="wikilink">homological algebra</a>, which was at the time devoted to computations. Those faced with giving tidy, systematic presentations of the subject would have noticed relations such as</p>
<dl>
<dd>hom(<em>F</em>(<em>X</em>), <em>Y</em>) = hom(<em>X</em>, <em>G</em>(<em>Y</em>))
</dd>
</dl>

<p>in the category of <a href="abelian_group" title="wikilink">abelian groups</a>, where <em>F</em> was the functor 

<math display="inline" id="Adjoint_functors:39">
 <semantics>
  <mrow>
   <mo>-</mo>
   <mo>⊗</mo>
   <mi>A</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <minus></minus>
    <csymbol cd="latexml">tensor-product</csymbol>
    <csymbol cd="unknown">A</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   -\otimes A
  </annotation>
 </semantics>
</math>

 (i.e. take the <a href="tensor_product" title="wikilink">tensor product</a> with <em>A</em>), and <em>G</em> was the functor hom(<em>A</em>,–).</p>

<p>The use of the <em>equals</em> sign is an <a href="abuse_of_notation" title="wikilink">abuse of notation</a>; those two groups are not really identical but there is a way of identifying them that is <em>natural</em>. It can be seen to be natural on the basis, firstly, that these are two alternative descriptions of the <a href="bilinear_mapping" title="wikilink">bilinear mappings</a> from <em>X</em> × <em>A</em> to <em>Y</em>. That is, however, something particular to the case of tensor product. In category theory the 'naturality' of the bijection is subsumed in the concept of a <a href="natural_isomorphism" title="wikilink">natural isomorphism</a>.</p>

<p>The terminology comes from the <a href="Hilbert_space" title="wikilink">Hilbert space</a> idea of <a href="adjoint_operator" title="wikilink">adjoint operators</a> <em>T</em>, <em>U</em> with 

<math display="inline" id="Adjoint_functors:40">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mrow>
     <mi>T</mi>
     <mi>x</mi>
    </mrow>
    <mo>,</mo>
    <mi>y</mi>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mrow>
     <mi>U</mi>
     <mi>y</mi>
    </mrow>
    <mo stretchy="false">⟩</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <list>
     <apply>
      <times></times>
      <ci>T</ci>
      <ci>x</ci>
     </apply>
     <ci>y</ci>
    </list>
    <list>
     <ci>x</ci>
     <apply>
      <times></times>
      <ci>U</ci>
      <ci>y</ci>
     </apply>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle Tx,y\rangle=\langle x,Uy\rangle
  </annotation>
 </semantics>
</math>

, which is formally similar to the above relation between hom-sets. We say that <em>F</em> is <em>left adjoint</em> to <em>G</em>, and <em>G</em> is <em>right adjoint</em> to <em>F</em>. Note that <em>G</em> may have itself a right adjoint that is quite different from <em>F</em> (see below for an example). The analogy to adjoint maps of Hilbert spaces can be made precise in certain contexts.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>

<p>If one starts looking for these adjoint pairs of functors, they turn out to be very common in <a href="abstract_algebra" title="wikilink">abstract algebra</a>, and elsewhere as well. The example section below provides evidence of this; furthermore, <a href="universal_construction" title="wikilink">universal constructions</a>, which may be more familiar to some, give rise to numerous adjoint pairs of functors.</p>

<p>In accordance with the thinking of <a href="Saunders_Mac_Lane" title="wikilink">Saunders Mac Lane</a>, any idea, such as adjoint functors, that occurs widely enough in mathematics should be studied for its own sake.</p>
<h3 id="problems-formulations">Problems formulations</h3>

<p>Mathematicians do not generally need the full adjoint functor concept. Concepts can be judged according to their use in solving problems, as well as for their use in building theories. The tension between these two motivations was especially great during the 1950s when category theory was initially developed. Enter <a href="Alexander_Grothendieck" title="wikilink">Alexander Grothendieck</a>, who used category theory to take compass bearings in other work — in <a href="functional_analysis" title="wikilink">functional analysis</a>, <a href="homological_algebra" title="wikilink">homological algebra</a> and finally <a href="algebraic_geometry" title="wikilink">algebraic geometry</a>.</p>

<p>It is probably wrong to say that he promoted the adjoint functor concept in isolation: but recognition of the role of adjunction was inherent in Grothendieck's approach. For example, one of his major achievements was the formulation of <a href="Serre_duality" title="wikilink">Serre duality</a> in relative form — loosely, in a continuous family of algebraic varieties. The entire proof turned on the existence of a right adjoint to a certain functor. This is something undeniably abstract, and non-constructive, but also powerful in its own way.</p>
<h3 id="posets">Posets</h3>

<p>Every <a href="partially_ordered_set" title="wikilink">partially ordered set</a> can be viewed as a category (with a single morphism between <em>x</em> and <em>y</em> if and only if <em>x</em> ≤ <em>y</em>). A pair of adjoint functors between two partially ordered sets is called a <a href="Galois_connection" title="wikilink">Galois connection</a> (or, if it is contravariant, an <em>antitone</em> Galois connection). See that article for a number of examples: the case of <a href="Galois_theory" title="wikilink">Galois theory</a> of course is a leading one. Any Galois connection gives rise to <a href="closure_operator" title="wikilink">closure operators</a> and to inverse order-preserving bijections between the corresponding closed elements.</p>

<p>As is the case for Galois groups, the real interest lies often in refining a correspondence to a <a href="Duality_(mathematics)" title="wikilink">duality</a> (i.e. <em>antitone</em> order isomorphism). A treatment of Galois theory along these lines by <a href="Irving_Kaplansky" title="wikilink">Kaplansky</a> was influential in the recognition of the general structure here.</p>

<p>The partial order case collapses the adjunction definitions quite noticeably, but can provide several themes:</p>
<ul>
<li>adjunctions may not be dualities or isomorphisms, but are candidates for upgrading to that status</li>
<li>closure operators may indicate the presence of adjunctions, as corresponding <a href="monad_(category_theory)" title="wikilink">monads</a> (cf. the <a href="Kuratowski_closure_axioms" title="wikilink">Kuratowski closure axioms</a>)</li>
<li>a very general comment of <a href="William_Lawvere" title="wikilink">William Lawvere</a><a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> is that <em>syntax and semantics</em> are adjoint: take <em>C</em> to be the set of all logical theories (axiomatizations), and <em>D</em> the power set of the set of all mathematical structures. For a theory <em>T</em> in <em>C</em>, let <em>F</em>(<em>T</em>) be the set of all structures that satisfy the axioms <em>T</em>; for a set of mathematical structures <em>S</em>, let <em>G</em>(<em>S</em>) be the minimal axiomatization of <em>S</em>. We can then say that <em>F</em>(<em>T</em>) is a subset of <em>S</em> if and only if <em>T</em> logically implies <em>G</em>(<em>S</em>): the "semantics functor" <em>F</em> is left adjoint to the "syntax functor" <em>G</em>.</li>
<li><a href="division_(mathematics)" title="wikilink">division</a> is (in general) the attempt to <em>invert</em> multiplication, but many examples, such as the introduction of <a href="material_conditional" title="wikilink">implication</a> in <a href="propositional_calculus" title="wikilink">propositional logic</a>, or the <a href="ideal_quotient" title="wikilink">ideal quotient</a> for division by <a href="ring_ideal" title="wikilink">ring ideals</a>, can be recognised as the attempt to provide an adjoint.</li>
</ul>

<p>Together these observations provide explanatory value all over mathematics.</p>
<h2 id="examples">Examples</h2>
<h3 id="free-groups">Free groups</h3>

<p>The construction of <a href="free_group" title="wikilink">free groups</a> is a common and illuminating example.</p>

<p>Suppose that <em>F</em> : <strong><a href="category_of_groups" title="wikilink">Grp</a></strong> ← <strong><a href="category_of_sets" title="wikilink">Set</a></strong> is the functor assigning to each set <em>Y</em> the <a href="free_group" title="wikilink">free group</a> generated by the elements of <em>Y</em>, and that <em>G</em> : <strong>Grp</strong> → <strong>Set</strong> is the <a href="forgetful_functor" title="wikilink">forgetful functor</a>, which assigns to each group <em>X</em> its underlying set. Then <em>F</em> is left adjoint to <em>G</em>:</p>

<p><strong>Terminal morphisms.</strong> For each group <em>X</em>, the group <em>FGX</em> is the free group generated freely by <em>GX</em>, the elements of <em>X</em>. Let  

<math display="inline" id="Adjoint_functors:41">
 <semantics>
  <mrow>
   <msub>
    <mi>ε</mi>
    <mi>X</mi>
   </msub>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mi>F</mi>
     <mi>G</mi>
     <mi>X</mi>
    </mrow>
    <mo>→</mo>
    <mi>X</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ε</ci>
     <ci>X</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <times></times>
      <ci>F</ci>
      <ci>G</ci>
      <ci>X</ci>
     </apply>
     <ci>X</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varepsilon_{X}:FGX\to X
  </annotation>
 </semantics>
</math>

  be the group homomorphism which sends the generators of <em>FGX</em> to the elements of <em>X</em> they correspond to, which exists by the universal property of free groups. Then each  

<math display="inline" id="Adjoint_functors:42">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi>G</mi>
    <mi>X</mi>
   </mrow>
   <mo>,</mo>
   <msub>
    <mi>ε</mi>
    <mi>X</mi>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <apply>
     <times></times>
     <ci>G</ci>
     <ci>X</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ε</ci>
     <ci>X</ci>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (GX,\varepsilon_{X})
  </annotation>
 </semantics>
</math>

  is a terminal morphism from <em>F</em> to <em>X</em>, because any group homomorphism from a free group <em>FZ</em> to <em>X</em> will factor through  

<math display="inline" id="Adjoint_functors:43">
 <semantics>
  <mrow>
   <msub>
    <mi>ε</mi>
    <mi>X</mi>
   </msub>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mi>F</mi>
     <mi>G</mi>
     <mi>X</mi>
    </mrow>
    <mo>→</mo>
    <mi>X</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ε</ci>
     <ci>X</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <times></times>
      <ci>F</ci>
      <ci>G</ci>
      <ci>X</ci>
     </apply>
     <ci>X</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varepsilon_{X}:FGX\to X
  </annotation>
 </semantics>
</math>

  via a unique set map from <em>Z</em> to <em>GX</em>. This means that (<em>F</em>,<em>G</em>) is an adjoint pair.</p>

<p><strong>Initial morphisms.</strong> For each set <em>Y</em>, the set <em>GFY</em> is just the underlying set of the free group <em>FY</em> generated by <em>Y</em>. Let  

<math display="inline" id="Adjoint_functors:44">
 <semantics>
  <mrow>
   <msub>
    <mi>η</mi>
    <mi>Y</mi>
   </msub>
   <mo>:</mo>
   <mrow>
    <mi>Y</mi>
    <mo>→</mo>
    <mrow>
     <mi>G</mi>
     <mi>F</mi>
     <mi>Y</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>η</ci>
     <ci>Y</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <ci>Y</ci>
     <apply>
      <times></times>
      <ci>G</ci>
      <ci>F</ci>
      <ci>Y</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \eta_{Y}:Y\to GFY
  </annotation>
 </semantics>
</math>

  be the set map given by "inclusion of generators". Then each  

<math display="inline" id="Adjoint_functors:45">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi>F</mi>
    <mi>Y</mi>
   </mrow>
   <mo>,</mo>
   <msub>
    <mi>η</mi>
    <mi>Y</mi>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <apply>
     <times></times>
     <ci>F</ci>
     <ci>Y</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>η</ci>
     <ci>Y</ci>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (FY,\eta_{Y})
  </annotation>
 </semantics>
</math>

  is an initial morphism from <em>Y</em> to <em>G</em>, because any set map from <em>Y</em> to the underlying set <em>GW</em> of a group will factor through  

<math display="inline" id="Adjoint_functors:46">
 <semantics>
  <mrow>
   <msub>
    <mi>η</mi>
    <mi>Y</mi>
   </msub>
   <mo>:</mo>
   <mrow>
    <mi>Y</mi>
    <mo>→</mo>
    <mrow>
     <mi>G</mi>
     <mi>F</mi>
     <mi>Y</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>η</ci>
     <ci>Y</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <ci>Y</ci>
     <apply>
      <times></times>
      <ci>G</ci>
      <ci>F</ci>
      <ci>Y</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \eta_{Y}:Y\to GFY
  </annotation>
 </semantics>
</math>

  via a unique group homomorphism from <em>FY</em> to <em>W</em>. This also means that (<em>F</em>,<em>G</em>) is an adjoint pair.</p>

<p><strong>Hom-set adjunction.</strong> Maps from the free group <em>FY</em> to a group <em>X</em> correspond precisely to maps from the set <em>Y</em> to the set <em>GX</em>: each homomorphism from <em>FY</em> to <em>X</em> is fully determined by its action on generators. One can verify directly that this correspondence is a natural transformation, which means it is a hom-set adjunction for the pair (<em>F</em>,<em>G</em>).</p>

<p><strong>Counit-unit adjunction.</strong> One can also verify directly that ε and η are natural. Then, a direct verification that they form a counit-unit adjunction  

<math display="inline" id="Adjoint_functors:47">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>ε</mi>
    <mo>,</mo>
    <mi>η</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>:</mo>
   <mi>F</mi>
   <mo>⊣</mo>
   <mi>G</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-:</ci>
     <interval closure="open">
      <ci>ε</ci>
      <ci>η</ci>
     </interval>
     <ci>F</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">does-not-prove</csymbol>
     <share href="#.cmml">
     </share>
     <ci>G</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\varepsilon,\eta):F\dashv G
  </annotation>
 </semantics>
</math>

  is as follows:</p>

<p><strong>The first counit-unit equation</strong>  

<math display="inline" id="Adjoint_functors:48">
 <semantics>
  <mrow>
   <msub>
    <mn>1</mn>
    <mi>F</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <mi>ε</mi>
      <mi>F</mi>
     </mrow>
     <mo>∘</mo>
     <mi>F</mi>
    </mrow>
    <mi>η</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <cn type="integer">1</cn>
     <ci>F</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <compose></compose>
      <apply>
       <times></times>
       <ci>ε</ci>
       <ci>F</ci>
      </apply>
      <ci>F</ci>
     </apply>
     <ci>η</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1_{F}=\varepsilon F\circ F\eta
  </annotation>
 </semantics>
</math>

  says that for each set <em>Y</em> the composition</p>

<p>

<math display="block" id="Adjoint_functors:49">
 <semantics>
  <mrow>
   <mrow>
    <mi>F</mi>
    <mi>Y</mi>
   </mrow>
   <mover accent="true">
    <mo>→</mo>
    <mrow>
     <mpadded lspace="2.8pt" width="+2.8pt">
      <mi>F</mi>
     </mpadded>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>η</mi>
       <mi>Y</mi>
      </msub>
      <mo rspace="5.3pt" stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mover>
   <mrow>
    <mi>F</mi>
    <mi>G</mi>
    <mi>F</mi>
    <mi>Y</mi>
   </mrow>
   <mover accent="true">
    <mo>→</mo>
    <mpadded width="+1.7pt">
     <msub>
      <mpadded lspace="2.8pt" width="+2.8pt">
       <mi>ε</mi>
      </mpadded>
      <mrow>
       <mi>F</mi>
       <mi>Y</mi>
      </mrow>
     </msub>
    </mpadded>
   </mover>
   <mrow>
    <mi>F</mi>
    <mi>Y</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <apply>
      <apply>
       <times></times>
       <ci>F</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>η</ci>
        <ci>Y</ci>
       </apply>
      </apply>
      <ci>normal-→</ci>
     </apply>
     <apply>
      <times></times>
      <ci>F</ci>
      <ci>Y</ci>
     </apply>
     <apply>
      <times></times>
      <ci>F</ci>
      <ci>G</ci>
      <ci>F</ci>
      <ci>Y</ci>
     </apply>
    </apply>
    <apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ε</ci>
       <apply>
        <times></times>
        <ci>F</ci>
        <ci>Y</ci>
       </apply>
      </apply>
      <ci>normal-→</ci>
     </apply>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>F</ci>
      <ci>Y</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   FY\xrightarrow{\;F(\eta_{Y})\;}FGFY\xrightarrow{\;\varepsilon_{FY}\,}FY
  </annotation>
 </semantics>
</math>

 should be the identity. The intermediate group <em>FGFY</em> is the free group generated freely by the words of the free group <em>FY</em>. (Think of these words as placed in parentheses to indicate that they are independent generators.) The arrow  

<math display="inline" id="Adjoint_functors:50">
 <semantics>
  <mrow>
   <mi>F</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>η</mi>
     <mi>Y</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>F</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>η</ci>
     <ci>Y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F(\eta_{Y})
  </annotation>
 </semantics>
</math>

  is the group homomorphism from <em>FY</em> into <em>FGFY</em> sending each generator <em>y</em> of <em>FY</em> to the corresponding word of length one (<em>y</em>) as a generator of <em>FGFY</em>. The arrow  

<math display="inline" id="Adjoint_functors:51">
 <semantics>
  <msub>
   <mi>ε</mi>
   <mrow>
    <mi>F</mi>
    <mi>Y</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ε</ci>
    <apply>
     <times></times>
     <ci>F</ci>
     <ci>Y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varepsilon_{FY}
  </annotation>
 </semantics>
</math>

  is the group homomorphism from <em>FGFY</em> to <em>FY</em> sending each generator to the word of <em>FY</em> it corresponds to (so this map is "dropping parentheses"). The composition of these maps is indeed the identity on <em>FY</em>.</p>

<p><strong>The second counit-unit equation</strong>  

<math display="inline" id="Adjoint_functors:52">
 <semantics>
  <mrow>
   <msub>
    <mn>1</mn>
    <mi>G</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <mi>G</mi>
      <mi>ε</mi>
     </mrow>
     <mo>∘</mo>
     <mi>η</mi>
    </mrow>
    <mi>G</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <cn type="integer">1</cn>
     <ci>G</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <compose></compose>
      <apply>
       <times></times>
       <ci>G</ci>
       <ci>ε</ci>
      </apply>
      <ci>η</ci>
     </apply>
     <ci>G</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1_{G}=G\varepsilon\circ\eta G
  </annotation>
 </semantics>
</math>

  says that for each group <em>X</em> the composition</p>
<dl>
<dd> 

<math display="inline" id="Adjoint_functors:53">
 <semantics>
  <mrow>
   <mrow>
    <mi>G</mi>
    <mi>X</mi>
   </mrow>
   <mover accent="true">
    <mo>→</mo>
    <mpadded width="+2.8pt">
     <msub>
      <mpadded lspace="2.8pt" width="+2.8pt">
       <mi>η</mi>
      </mpadded>
      <mrow>
       <mi>G</mi>
       <mi>X</mi>
      </mrow>
     </msub>
    </mpadded>
   </mover>
   <mrow>
    <mi>G</mi>
    <mi>F</mi>
    <mi>G</mi>
    <mi>X</mi>
   </mrow>
   <mover accent="true">
    <mo>→</mo>
    <mrow>
     <mpadded lspace="2.8pt" width="+2.8pt">
      <mi>G</mi>
     </mpadded>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>ε</mi>
       <mi>X</mi>
      </msub>
      <mo rspace="4.2pt" stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mover>
   <mrow>
    <mi>G</mi>
    <mi>X</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>η</ci>
       <apply>
        <times></times>
        <ci>G</ci>
        <ci>X</ci>
       </apply>
      </apply>
      <ci>normal-→</ci>
     </apply>
     <apply>
      <times></times>
      <ci>G</ci>
      <ci>X</ci>
     </apply>
     <apply>
      <times></times>
      <ci>G</ci>
      <ci>F</ci>
      <ci>G</ci>
      <ci>X</ci>
     </apply>
    </apply>
    <apply>
     <apply>
      <apply>
       <times></times>
       <ci>G</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ε</ci>
        <ci>X</ci>
       </apply>
      </apply>
      <ci>normal-→</ci>
     </apply>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>G</ci>
      <ci>X</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   GX\xrightarrow{\;\eta_{GX}\;}GFGX\xrightarrow{\;G(\varepsilon_{X})\,}GX
  </annotation>
 </semantics>
</math>

 
</dd>
</dl>

<p>should be the identity. The intermediate set <em>GFGX</em> is just the underlying set of <em>FGX</em>. The arrow  

<math display="inline" id="Adjoint_functors:54">
 <semantics>
  <msub>
   <mi>η</mi>
   <mrow>
    <mi>G</mi>
    <mi>X</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>η</ci>
    <apply>
     <times></times>
     <ci>G</ci>
     <ci>X</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \eta_{GX}
  </annotation>
 </semantics>
</math>

  is the "inclusion of generators" set map from the set <em>GX</em> to the set <em>GFGX</em>. The arrow  

<math display="inline" id="Adjoint_functors:55">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>ε</mi>
     <mi>X</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>G</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ε</ci>
     <ci>X</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G(\varepsilon_{X})
  </annotation>
 </semantics>
</math>

  is the set map from <em>GFGX</em> to <em>GX</em> which underlies the group homomorphism sending each generator of <em>FGX</em> to the element of <em>X</em> it corresponds to ("dropping parentheses"). The composition of these maps is indeed the identity on <em>GX</em>.</p>
<h3 id="free-constructions-and-forgetful-functors">Free constructions and forgetful functors</h3>

<p><a href="Free_object" title="wikilink">Free objects</a> are all examples of a left adjoint to a <a href="forgetful_functor" title="wikilink">forgetful functor</a> which assigns to an algebraic object its underlying set. These algebraic <a href="free_functor" title="wikilink">free functors</a> have generally the same description as in the detailed description of the free group situation above.</p>
<h3 id="diagonal-functors-and-limits">Diagonal functors and limits</h3>

<p><a href="Product_(category_theory)" title="wikilink">Products</a>, <a href="Pullback_(category_theory)" title="wikilink">fibred products</a>, <a href="Equalizer_(mathematics)" title="wikilink">equalizers</a>, and <a href="Kernel_(algebra)" title="wikilink">kernels</a> are all examples of the categorical notion of a <a href="limit_(category_theory)" title="wikilink">limit</a>. Any limit functor is right adjoint to a corresponding diagonal functor (provided the category has the type of limits in question), and the counit of the adjunction provides the defining maps from the limit object (i.e. from the diagonal functor on the limit, in the functor category). Below are some specific examples.</p>
<ul>
<li><strong>Products</strong> Let Π : <strong>Grp<sup>2</sup></strong> → <strong>Grp</strong> the functor which assigns to each pair (<em>X</em><sub>1</sub>, <em>X<sub>2</sub></em>) the product group <em>X</em><sub>1</sub>×<em>X</em><sub>2</sub>, and let Δ : <strong>Grp<sup>2</sup></strong> ← <strong>Grp</strong> be the <a href="diagonal_functor" title="wikilink">diagonal functor</a> which assigns to every group <em>X</em> the pair (<em>X</em>, <em>X</em>) in the product category <strong>Grp<sup>2</sup></strong>. The universal property of the product group shows that Π is right-adjoint to Δ. The counit of this adjunction is the defining pair of projection maps from <em>X</em><sub>1</sub>×<em>X</em><sub>2</sub> to <em>X</em><sub>1</sub> and <em>X</em><sub>2</sub> which define the limit, and the unit is the <em>diagonal inclusion</em> of a group X into <em>X</em><sub>1</sub>×<em>X</em><sub>2</sub> (mapping x to (x,x)).</li>
</ul>
<dl>
<dd>The <a href="cartesian_product" title="wikilink">cartesian product</a> of <a href="Set_(mathematics)" title="wikilink">sets</a>, the product of rings, the <a href="product_topology" title="wikilink">product of topological spaces</a> etc. follow the same pattern; it can also be extended in a straightforward manner to more than just two factors. More generally, any type of limit is right adjoint to a diagonal functor.
</dd>
</dl>
<ul>
<li><strong>Kernels.</strong> Consider the category <em>D</em> of homomorphisms of abelian groups. If <em>f</em><sub>1</sub> : <em>A</em><sub>1</sub> → <em>B</em><sub>1</sub> and <em>f</em><sub>2</sub> : <em>A</em><sub>2</sub> → <em>B</em><sub>2</sub> are two objects of <em>D</em>, then a morphism from <em>f</em><sub>1</sub> to <em>f</em><sub>2</sub> is a pair (<em>g</em><sub><em>A</em></sub>, <em>g</em><sub><em>B</em></sub>) of morphisms such that <em>g<sub>B</sub>f</em><sub>1</sub> = <em>f</em><sub>2</sub><em>g<sub>A</sub></em>. Let <em>G</em> : <em>D</em> → <strong>Ab</strong> be the functor which assigns to each homomorphism its <a href="kernel_(algebra)" title="wikilink">kernel</a> and let <em>F</em> : <strong>D</strong> ← <strong>Ab</strong> be the functor which maps the group <em>A</em> to the homomorphism <em>A</em> → 0. Then <em>G</em> is right adjoint to <em>F</em>, which expresses the universal property of kernels. The counit of this adjunction is the defining embedding of a homomorphism's kernel into the homomorphism's domain, and the unit is the morphism identifying a group <em>A</em> with the kernel of the homomorphism <em>A</em> → 0.</li>
</ul>
<dl>
<dd>A suitable variation of this example also shows that the kernel functors for vector spaces and for modules are right adjoints. Analogously, one can show that the cokernel functors for abelian groups, vector spaces and modules are left adjoints.
</dd>
</dl>
<h3 id="colimits-and-diagonal-functors">Colimits and diagonal functors</h3>

<p><a href="Coproduct" title="wikilink">Coproducts</a>, <a href="Pushout_(category_theory)" title="wikilink">fibred coproducts</a>, <a href="coequalizer" title="wikilink">coequalizers</a>, and <a href="cokernel" title="wikilink">cokernels</a> are all examples of the categorical notion of a <a href="limit_(category_theory)" title="wikilink">colimit</a>. Any colimit functor is left adjoint to a corresponding diagonal functor (provided the category has the type of colimits in question), and the unit of the adjunction provides the defining maps into the colimit object. Below are some specific examples.</p>
<ul>
<li><strong>Coproducts.</strong> If <em>F</em> : <strong><a href="category_of_abelian_groups" title="wikilink">Ab</a></strong> ← <strong>Ab<sup>2</sup></strong> assigns to every pair (<em>X</em><sub>1</sub>, <em>X</em><sub>2</sub>) of abelian groups their <a href="Direct_sum_of_groups" title="wikilink">direct sum</a>, and if <em>G</em> : <strong>Ab</strong> → <strong>Ab<sup>2</sup></strong> is the functor which assigns to every abelian group <em>Y</em> the pair (<em>Y</em>, <em>Y</em>), then <em>F</em> is left adjoint to <em>G</em>, again a consequence of the universal property of direct sums. The unit of this adjoint pair is the defining pair of inclusion maps from <em>X</em><sub>1</sub> and <em>X</em><sub>2</sub> into the direct sum, and the counit is the additive map from the direct sum of (<em>X</em>,<em>X</em>) to back to <em>X</em> (sending an element (<em>a</em>,<em>b</em>) of the direct sum to the element <em>a</em>+<em>b</em> of <em>X</em>).</li>
</ul>
<dl>
<dd>Analogous examples are given by the <a href="Direct_sum_of_modules" title="wikilink">direct sum</a> of <a href="vector_space" title="wikilink">vector spaces</a> and <a href="module_(mathematics)" title="wikilink">modules</a>, by the <a href="free_product" title="wikilink">free product</a> of groups and by the disjoint union of sets.
</dd>
</dl>
<h3 id="further-examples">Further examples</h3>
<h4 id="algebra">Algebra</h4>
<ul>
<li><strong>Adjoining an identity to a <a href="Rng_(algebra)" title="wikilink">rng</a>.</strong> This example was discussed in the motivation section above. Given a rng <em>R</em>, a multiplicative identity element can be added by taking <em>R</em>x<strong>Z</strong> and defining a <strong>Z</strong>-bilinear product with (r,0)(0,1) = (0,1)(r,0) = (r,0), (r,0)(s,0) = (rs,0), (0,1)(0,1) = (0,1). This constructs a left adjoint to the functor taking a ring to the underlying rng.</li>
</ul>
<ul>
<li><strong>Ring extensions.</strong> Suppose <em>R</em> and <em>S</em> are rings, and ρ : <em>R</em> → <em>S</em> is a <a href="ring_homomorphism" title="wikilink">ring homomorphism</a>. Then <em>S</em> can be seen as a (left) <em>R</em>-module, and the <a href="tensor_product" title="wikilink">tensor product</a> with <em>S</em> yields a functor <em>F</em> : <em>R</em>-<strong>Mod</strong> → <em>S</em>-<strong>Mod</strong>. Then <em>F</em> is left adjoint to the forgetful functor <em>G</em> : <em>S</em>-<strong>Mod</strong> → <em>R</em>-<strong>Mod</strong>.</li>
</ul>
<ul>
<li><strong><a href="Tensor-hom_adjunction" title="wikilink">Tensor products</a>.</strong> If <em>R</em> is a ring and <em>M</em> is a right <em>R</em> module, then the tensor product with <em>M</em> yields a functor <em>F</em> : <em>R</em>-<strong>Mod</strong> → <strong>Ab</strong>. The functor <em>G</em> : <strong>Ab</strong> → <em>R</em>-<strong>Mod</strong>, defined by <em>G</em>(<em>A</em>) = hom<sub><strong>Z</strong></sub>(<em>M</em>,<em>A</em>) for every abelian group <em>A</em>, is a right adjoint to <em>F</em>.</li>
</ul>
<ul>
<li><strong>From monoids and groups to rings</strong> The <a href="integral_monoid_ring" title="wikilink">integral monoid ring</a> construction gives a functor from <a href="monoid" title="wikilink">monoids</a> to rings. This functor is left adjoint to the functor that associates to a given ring its underlying multiplicative monoid. Similarly, the <a href="integral_group_ring" title="wikilink">integral group ring</a> construction yields a functor from <a href="group_(mathematics)" title="wikilink">groups</a> to rings, left adjoint to the functor that assigns to a given ring its <a href="group_of_units" title="wikilink">group of units</a>. One can also start with a <a href="field_(mathematics)" title="wikilink">field</a> <em>K</em> and consider the category of <em>K</em>-<a href="associative_algebra" title="wikilink">algebras</a> instead of the category of rings, to get the monoid and group rings over <em>K</em>.</li>
</ul>
<ul>
<li><strong>Field of fractions.</strong> Consider the category <strong>Dom</strong><sub>m</sub> of integral domains with injective morphisms. The forgetful functor <strong>Field</strong> → <strong>Dom</strong><sub>m</sub> from fields has a left adjoint - it assigns to every integral domain its <a href="field_of_fractions" title="wikilink">field of fractions</a>.</li>
</ul>
<ul>
<li><strong>Polynomial rings</strong>. Let <strong>Ring</strong><sub>*</sub> be the category of pointed commutative rings with unity (pairs (A,a) where A is a ring, 

<math display="inline" id="Adjoint_functors:56">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo>∈</mo>
   <mi>A</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>a</ci>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a\in A
  </annotation>
 </semantics>
</math>

 and morphisms preserve the distinguished elements). The forgetful functor G:<strong>Ring</strong><sub>*</sub> → <strong>Ring</strong> has a left adjoint - it assigns to every ring R the pair (R[x],x) where R[x] is the <a href="polynomial_ring" title="wikilink">polynomial ring</a> with coefficients from R.</li>
</ul>
<ul>
<li><strong>Abelianization</strong>. Consider the inclusion functor <em>G</em> : <strong>Ab</strong> → <strong>Grp</strong> from the <a href="category_of_abelian_groups" title="wikilink">category of abelian groups</a> to <a href="category_of_groups" title="wikilink">category of groups</a>. It has a left adjoint called <a class="uri" href="abelianization" title="wikilink">abelianization</a> which assigns to every group <em>G</em> the quotient group <em>G</em><sup>ab</sup>=<em>G</em>/[<em>G</em>,<em>G</em>].</li>
</ul>
<ul>
<li><strong>The Grothendieck group</strong>. In <a class="uri" href="K-theory" title="wikilink">K-theory</a>, the point of departure is to observe that the category of <a href="vector_bundle" title="wikilink">vector bundles</a> on a <a href="topological_space" title="wikilink">topological space</a> has a commutative monoid structure under <a href="Direct_sum_of_modules" title="wikilink">direct sum</a>. One may make an <a href="abelian_group" title="wikilink">abelian group</a> out of this monoid, the <a href="Grothendieck_group" title="wikilink">Grothendieck group</a>, by formally adding an additive inverse for each bundle (or equivalence class). Alternatively one can observe that the functor that for each group takes the underlying monoid (ignoring inverses) has a left adjoint. This is a once-for-all construction, in line with the third section discussion above. That is, one can imitate the construction of <a href="negative_number" title="wikilink">negative numbers</a>; but there is the other option of an <a href="existence_theorem" title="wikilink">existence theorem</a>. For the case of finitary algebraic structures, the existence by itself can be referred to <a href="universal_algebra" title="wikilink">universal algebra</a>, or <a href="model_theory" title="wikilink">model theory</a>; naturally there is also a proof adapted to category theory, too.</li>
</ul>
<ul>
<li><strong>Frobenius reciprocity</strong> in the <a href="group_representation" title="wikilink">representation theory of groups</a>: see <a href="induced_representation" title="wikilink">induced representation</a>. This example foreshadowed the general theory by about half a century.</li>
</ul>
<h4 id="topology">Topology</h4>
<ul>
<li><strong>A functor with a left and a right adjoint.</strong> Let <em>G</em> be the functor from <a href="topological_space" title="wikilink">topological spaces</a> to <a href="Set_(mathematics)" title="wikilink">sets</a> that associates to every topological space its underlying set (forgetting the topology, that is). <em>G</em> has a left adjoint <em>F</em>, creating the <a href="discrete_space" title="wikilink">discrete space</a> on a set <em>Y</em>, and a right adjoint <em>H</em> creating the <a href="trivial_topology" title="wikilink">trivial topology</a> on <em>Y</em>.</li>
<li><strong>Suspensions and loop spaces</strong> Given <a href="topological_spaces" title="wikilink">topological spaces</a> <em>X</em> and <em>Y</em>, the space [<em>SX</em>, <em>Y</em>] of <a href="homotopy_classes" title="wikilink">homotopy classes</a> of maps from the <a href="suspension_(topology)" title="wikilink">suspension</a> <em>SX</em> of <em>X</em> to <em>Y</em> is naturally isomorphic to the space [<em>X</em>, Ω<em>Y</em>] of homotopy classes of maps from <em>X</em> to the <a href="loop_space" title="wikilink">loop space</a> Ω<em>Y</em> of <em>Y</em>. This is an important fact in <a href="homotopy_theory" title="wikilink">homotopy theory</a>.</li>
<li><strong>Stone-Čech compactification.</strong> Let <strong>KHaus</strong> be the category of <a href="compact_space" title="wikilink">compact</a> <a href="Hausdorff_space" title="wikilink">Hausdorff spaces</a> and <em>G</em> : <strong>KHaus</strong> → <strong>Top</strong> be the inclusion functor to the category of <a href="topological_spaces" title="wikilink">topological spaces</a>. Then <em>G</em> has a left adjoint <em>F</em> : <strong>Top</strong> → <strong>KHaus</strong>, the <a href="Stone–Čech_compactification" title="wikilink">Stone–Čech compactification</a>. The unit of this adjoint pair yields a <a href="continuous_function_(topology)" title="wikilink">continuous</a> map from every topological space <em>X</em> into its Stone-Čech compactification. This map is an <a class="uri" href="embedding" title="wikilink">embedding</a> (i.e. <a class="uri" href="injective" title="wikilink">injective</a>, continuous and open) if and only if <em>X</em> is a <a href="Tychonoff_space" title="wikilink">Tychonoff space</a>.</li>
<li><strong>Direct and inverse images of sheaves</strong> Every <a href="continuous_map" title="wikilink">continuous map</a> <em>f</em> : <em>X</em> → <em>Y</em> between <a href="topological_space" title="wikilink">topological spaces</a> induces a functor <em>f</em><sub>∗</sub> from the category of <a href="sheaf_(mathematics)" title="wikilink">sheaves</a> (of sets, or abelian groups, or rings...) on <em>X</em> to the corresponding category of sheaves on <em>Y</em>, the <em><a href="direct_image_functor" title="wikilink">direct image functor</a></em>. It also induces a functor <em>f</em><sup>−1</sup> from the category of sheaves of abelian groups on <em>Y</em> to the category of sheaves of abelian groups on <em>X</em>, the <em><a href="inverse_image_functor" title="wikilink">inverse image functor</a></em>. <em>f</em><sup>−1</sup> is left adjoint to <em>f</em><sub>∗</sub>. Here a more subtle point is that the left adjoint for <a href="coherent_sheaf" title="wikilink">coherent sheaves</a> will differ from that for sheaves (of sets).</li>
<li><strong>Soberification.</strong> The article on <a href="Stone_duality" title="wikilink">Stone duality</a> describes an adjunction between the category of topological spaces and the category of <a href="sober_space" title="wikilink">sober spaces</a> that is known as soberification. Notably, the article also contains a detailed description of another adjunction that prepares the way for the famous <a href="duality_(category_theory)" title="wikilink">duality</a> of sober spaces and spatial locales, exploited in <a href="pointless_topology" title="wikilink">pointless topology</a>.</li>
</ul>
<h4 id="category-theory">Category theory</h4>
<ul>
<li><strong>A series of adjunctions.</strong> The functor π<sub>0</sub> which assigns to a category its set of connected components is left-adjoint to the functor <em>D</em> which assigns to a set the discrete category on that set. Moreover, <em>D</em> is left-adjoint to the object functor <em>U</em> which assigns to each category its set of objects, and finally <em>U</em> is left-adjoint to <em>A</em> which assigns to each set the <a href="http://ncatlab.org/nlab/show/indiscrete+category">indiscrete category</a> on that set.</li>
<li><strong>Exponential object</strong>. In a <a href="cartesian_closed_category" title="wikilink">cartesian closed category</a> the endofunctor <em>C</em> → <em>C</em> given by –×<em>A</em> has a right adjoint –<sup><em>A</em></sup>.</li>
</ul>
<h4 id="categorical-logic">Categorical logic</h4>
<ul>
<li><strong>Quantification.</strong> If 

<math display="inline" id="Adjoint_functors:57">
 <semantics>
  <msub>
   <mi>ϕ</mi>
   <mi>Y</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ϕ</ci>
    <ci>Y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi_{Y}
  </annotation>
 </semantics>
</math>

 is a unary predicate expressing some property, then a sufficiently strong set theory may prove the existence of the set 

<math display="inline" id="Adjoint_functors:58">
 <semantics>
  <mrow>
   <mi>Y</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mi>y</mi>
    <mo>∣</mo>
    <mrow>
     <msub>
      <mi>ϕ</mi>
      <mi>Y</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>Y</ci>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <ci>y</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ϕ</ci>
       <ci>Y</ci>
      </apply>
      <ci>y</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y=\{y\mid\phi_{Y}(y)\}
  </annotation>
 </semantics>
</math>

 of terms that fulfill the property. A proper subset 

<math display="inline" id="Adjoint_functors:59">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mo>⊂</mo>
   <mi>Y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <ci>T</ci>
    <ci>Y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T\subset Y
  </annotation>
 </semantics>
</math>

 and the associated injection of 

<math display="inline" id="Adjoint_functors:60">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

 into 

<math display="inline" id="Adjoint_functors:61">
 <semantics>
  <mi>Y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y
  </annotation>
 </semantics>
</math>

 is characterized by a predicate 

<math display="inline" id="Adjoint_functors:62">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>ϕ</mi>
     <mi>T</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>ϕ</mi>
      <mi>Y</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>∧</mo>
    <mrow>
     <mi>φ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ϕ</ci>
      <ci>T</ci>
     </apply>
     <ci>y</ci>
    </apply>
    <apply>
     <and></and>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ϕ</ci>
       <ci>Y</ci>
      </apply>
      <ci>y</ci>
     </apply>
     <apply>
      <times></times>
      <ci>φ</ci>
      <ci>y</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi_{T}(y)=\phi_{Y}(y)\land\varphi(y)
  </annotation>
 </semantics>
</math>

 expressing a strictly more restrictive property.</li>
</ul>
<dl>
<dd>The role of <a href="Quantifier_(logic)" title="wikilink">quantifiers</a> in predicate logics is in forming propositions and also in expressing sophisticated predicates by closing formulas with possibly more variables. For example, consider a predicate 

<math display="inline" id="Adjoint_functors:63">
 <semantics>
  <msub>
   <mi>ψ</mi>
   <mi>f</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ψ</ci>
    <ci>f</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \psi_{f}
  </annotation>
 </semantics>
</math>

 with two open variables of sort 

<math display="inline" id="Adjoint_functors:64">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Adjoint_functors:65">
 <semantics>
  <mi>Y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y
  </annotation>
 </semantics>
</math>

. Using a quantifier to close 

<math display="inline" id="Adjoint_functors:66">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

, we can form the set

<p>

<math display="block" id="Adjoint_functors:67">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mrow>
    <mi>y</mi>
    <mo>∈</mo>
    <mi>Y</mi>
   </mrow>
   <mo>∣</mo>
   <mrow>
    <mrow>
     <mo>∃</mo>
     <mi>x</mi>
    </mrow>
    <mo rspace="4.2pt">.</mo>
    <mrow>
     <mrow>
      <msub>
       <mi>ψ</mi>
       <mi>f</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo>,</mo>
       <mi>y</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>∧</mo>
     <mrow>
      <msub>
       <mi>ϕ</mi>
       <mi>S</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">conditional-set</csymbol>
    <apply>
     <in></in>
     <ci>y</ci>
     <ci>Y</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">formulae-sequence</csymbol>
     <apply>
      <exists></exists>
      <ci>x</ci>
     </apply>
     <apply>
      <and></and>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ψ</ci>
        <ci>f</ci>
       </apply>
       <interval closure="open">
        <ci>x</ci>
        <ci>y</ci>
       </interval>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ϕ</ci>
        <ci>S</ci>
       </apply>
       <ci>x</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{y\in Y\mid\exists x.\,\psi_{f}(x,y)\land\phi_{S}(x)\}
  </annotation>
 </semantics>
</math>

</p>
</dd>
<dd>of all elements 

<math display="inline" id="Adjoint_functors:68">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

 of 

<math display="inline" id="Adjoint_functors:69">
 <semantics>
  <mi>Y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y
  </annotation>
 </semantics>
</math>

 for which there is an 

<math display="inline" id="Adjoint_functors:70">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 to which it is 

<math display="inline" id="Adjoint_functors:71">
 <semantics>
  <msub>
   <mi>ψ</mi>
   <mi>f</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ψ</ci>
    <ci>f</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \psi_{f}
  </annotation>
 </semantics>
</math>

-related, and which itself is characterized by the property 

<math display="inline" id="Adjoint_functors:72">
 <semantics>
  <msub>
   <mi>ϕ</mi>
   <mi>S</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ϕ</ci>
    <ci>S</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi_{S}
  </annotation>
 </semantics>
</math>

. Set theoretic operations like the intersection 

<math display="inline" id="Adjoint_functors:73">
 <semantics>
  <mo>∩</mo>
  <annotation-xml encoding="MathML-Content">
   <intersect></intersect>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \cap
  </annotation>
 </semantics>
</math>

 of two sets directly corresponds to the conjunction 

<math display="inline" id="Adjoint_functors:74">
 <semantics>
  <mo>∧</mo>
  <annotation-xml encoding="MathML-Content">
   <and></and>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \land
  </annotation>
 </semantics>
</math>

 of predicates. In <a href="categorical_logic" title="wikilink">categorical logic</a>, a subfield of <a href="topos_theory" title="wikilink">topos theory</a>, quantifiers are identified with adjoints to the pullback functor. Such a realization can be seen in analogy to the discussion of propositional logic using set theory but, interestingly, the general definition make for a richer range of logics.
</dd>
</dl>
<dl>
<dd>So consider an object 

<math display="inline" id="Adjoint_functors:75">
 <semantics>
  <mi>Y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y
  </annotation>
 </semantics>
</math>

 in a category with pullbacks. Any morphism 

<math display="inline" id="Adjoint_functors:76">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mo>:</mo>
   <mrow>
    <mi>X</mi>
    <mo>→</mo>
    <mi>Y</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>f</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>X</ci>
     <ci>Y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f:X\to Y
  </annotation>
 </semantics>
</math>

 induces a functor

<p>

<math display="block" id="Adjoint_functors:77">
 <semantics>
  <mrow>
   <msup>
    <mi>f</mi>
    <mo>*</mo>
   </msup>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mtext>Sub</mtext>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>Y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>⟶</mo>
    <mrow>
     <mtext>Sub</mtext>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>X</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>f</ci>
     <times></times>
    </apply>
    <apply>
     <ci>normal-⟶</ci>
     <apply>
      <times></times>
      <mtext>Sub</mtext>
      <ci>Y</ci>
     </apply>
     <apply>
      <times></times>
      <mtext>Sub</mtext>
      <ci>X</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f^{*}:\text{Sub}(Y)\longrightarrow\text{Sub}(X)
  </annotation>
 </semantics>
</math>

</p>
</dd>
<dd>on the category that is the preorder of subobjects. It maps subobjects 

<math display="inline" id="Adjoint_functors:78">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

 of 

<math display="inline" id="Adjoint_functors:79">
 <semantics>
  <mi>Y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y
  </annotation>
 </semantics>
</math>

 (technically: monomorphism classes of 

<math display="inline" id="Adjoint_functors:80">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mo>→</mo>
   <mi>Y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>T</ci>
    <ci>Y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T\to Y
  </annotation>
 </semantics>
</math>

) to the pullback 

<math display="inline" id="Adjoint_functors:81">
 <semantics>
  <mrow>
   <mi>X</mi>
   <msub>
    <mo>×</mo>
    <mi>Y</mi>
   </msub>
   <mi>T</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <times></times>
     <ci>Y</ci>
    </apply>
    <ci>X</ci>
    <ci>T</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X\times_{Y}T
  </annotation>
 </semantics>
</math>

. If this functor has a left- or right adjoint, they are called 

<math display="inline" id="Adjoint_functors:82">
 <semantics>
  <msub>
   <mo>∃</mo>
   <mi>f</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <exists></exists>
    <ci>f</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \exists_{f}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Adjoint_functors:83">
 <semantics>
  <msub>
   <mo>∀</mo>
   <mi>f</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <ci>f</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall_{f}
  </annotation>
 </semantics>
</math>

, respectively.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> They both map from 

<math display="inline" id="Adjoint_functors:84">
 <semantics>
  <mrow>
   <mtext>Sub</mtext>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <mtext>Sub</mtext>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{Sub}(X)
  </annotation>
 </semantics>
</math>

 back to 

<math display="inline" id="Adjoint_functors:85">
 <semantics>
  <mrow>
   <mtext>Sub</mtext>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>Y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <mtext>Sub</mtext>
    <ci>Y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{Sub}(Y)
  </annotation>
 </semantics>
</math>

. Very roughly, given a domain 

<math display="inline" id="Adjoint_functors:86">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>⊂</mo>
   <mi>X</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <ci>S</ci>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S\subset X
  </annotation>
 </semantics>
</math>

 to quantify a relation expressed via 

<math display="inline" id="Adjoint_functors:87">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 over, the functor/quantifier closes 

<math display="inline" id="Adjoint_functors:88">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

 in 

<math display="inline" id="Adjoint_functors:89">
 <semantics>
  <mrow>
   <mi>X</mi>
   <msub>
    <mo>×</mo>
    <mi>Y</mi>
   </msub>
   <mi>T</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <times></times>
     <ci>Y</ci>
    </apply>
    <ci>X</ci>
    <ci>T</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X\times_{Y}T
  </annotation>
 </semantics>
</math>

 and returns the thereby specified subset of 

<math display="inline" id="Adjoint_functors:90">
 <semantics>
  <mi>Y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y
  </annotation>
 </semantics>
</math>

.
</dd>
</dl>
<dl>
<dd><strong>Example</strong>: In 

<math display="inline" id="Adjoint_functors:91">
 <semantics>
  <mo>Set</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>Set</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{Set}
  </annotation>
 </semantics>
</math>

, the category of sets and functions, the canonical subobjects are the subset (or rather their canonical injections). The pullback 

<math display="inline" id="Adjoint_functors:92">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>f</mi>
     <mo>*</mo>
    </msup>
    <mi>T</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>X</mi>
    <msub>
     <mo>×</mo>
     <mi>Y</mi>
    </msub>
    <mi>T</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>f</ci>
      <times></times>
     </apply>
     <ci>T</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <times></times>
      <ci>Y</ci>
     </apply>
     <ci>X</ci>
     <ci>T</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f^{*}T=X\times_{Y}T
  </annotation>
 </semantics>
</math>

 of an injection of a subset 

<math display="inline" id="Adjoint_functors:93">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

 into 

<math display="inline" id="Adjoint_functors:94">
 <semantics>
  <mi>Y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y
  </annotation>
 </semantics>
</math>

 along 

<math display="inline" id="Adjoint_functors:95">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 is characterized as the largest set which knows all about 

<math display="inline" id="Adjoint_functors:96">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 and the injection of 

<math display="inline" id="Adjoint_functors:97">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

 into 

<math display="inline" id="Adjoint_functors:98">
 <semantics>
  <mi>Y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y
  </annotation>
 </semantics>
</math>

. It therefore turns out to be (in bijection with) the inverse image 

<math display="inline" id="Adjoint_functors:99">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>f</mi>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>T</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>⊆</mo>
   <mi>X</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>f</ci>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>T</ci>
     </apply>
    </apply>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f^{-1}[T]\subseteq X
  </annotation>
 </semantics>
</math>

.
</dd>
<dd>For 

<math display="inline" id="Adjoint_functors:100">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>⊆</mo>
   <mi>X</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <ci>S</ci>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S\subseteq X
  </annotation>
 </semantics>
</math>

, let us figure out the left adjoinet, which is defined via

<p>:<math>{\operatorname{Hom}}(\exists_f S,T)</math></p>
</dd>
</dl>

<p>\cong {\operatorname{Hom}}(S,f^{*}T),</p>
<dl>
<dd>which here just means

<p>:<math>\exists_f S\subseteq T</math></p>
</dd>
</dl>

<p>\leftrightarrow S\subseteq f^{-1}[T].</p>
<dl>
<dd>Consider 

<math display="inline" id="Adjoint_functors:101">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>S</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>⊆</mo>
   <mi>T</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <apply>
     <times></times>
     <ci>f</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>S</ci>
     </apply>
    </apply>
    <ci>T</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f[S]\subseteq T
  </annotation>
 </semantics>
</math>

. We see 

<math display="inline" id="Adjoint_functors:102">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>⊆</mo>
   <mrow>
    <msup>
     <mi>f</mi>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">[</mo>
       <mi>S</mi>
       <mo stretchy="false">]</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>⊆</mo>
   <mrow>
    <msup>
     <mi>f</mi>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>T</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <subset></subset>
     <ci>S</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>f</ci>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <times></times>
        <ci>f</ci>
        <apply>
         <csymbol cd="latexml">delimited-[]</csymbol>
         <ci>S</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <subset></subset>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>f</ci>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <ci>T</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S\subseteq f^{-1}[f[S]]\subseteq f^{-1}[T]
  </annotation>
 </semantics>
</math>

. Conversely, If for an 

<math display="inline" id="Adjoint_functors:103">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>∈</mo>
   <mi>S</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>x</ci>
    <ci>S</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\in S
  </annotation>
 </semantics>
</math>

 we also have 

<math display="inline" id="Adjoint_functors:104">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>∈</mo>
   <mrow>
    <msup>
     <mi>f</mi>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>T</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>x</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>f</ci>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>T</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\in f^{-1}[T]
  </annotation>
 </semantics>
</math>

, then clearly 

<math display="inline" id="Adjoint_functors:105">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>∈</mo>
   <mi>T</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>x</ci>
    </apply>
    <ci>T</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x)\in T
  </annotation>
 </semantics>
</math>

. So 

<math display="inline" id="Adjoint_functors:106">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>⊆</mo>
   <mrow>
    <msup>
     <mi>f</mi>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>T</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <ci>S</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>f</ci>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>T</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S\subseteq f^{-1}[T]
  </annotation>
 </semantics>
</math>

 implies 

<math display="inline" id="Adjoint_functors:107">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>S</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>⊆</mo>
   <mi>T</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <apply>
     <times></times>
     <ci>f</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>S</ci>
     </apply>
    </apply>
    <ci>T</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f[S]\subseteq T
  </annotation>
 </semantics>
</math>

. We concude that left adjoint to the inverse image functor 

<math display="inline" id="Adjoint_functors:108">
 <semantics>
  <msup>
   <mi>f</mi>
   <mo>*</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>f</ci>
    <times></times>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f^{*}
  </annotation>
 </semantics>
</math>

 is given by the direct image. Here is a characterization of this result, which matches more the logical interpretation: The image of 

<math display="inline" id="Adjoint_functors:109">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 under 

<math display="inline" id="Adjoint_functors:110">
 <semantics>
  <msub>
   <mo>∃</mo>
   <mi>f</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <exists></exists>
    <ci>f</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \exists_{f}
  </annotation>
 </semantics>
</math>

 is the full set of 

<math display="inline" id="Adjoint_functors:111">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

's, such that 

<math display="inline" id="Adjoint_functors:112">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>f</mi>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mo stretchy="false">{</mo>
      <mi>y</mi>
      <mo stretchy="false">}</mo>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>∩</mo>
   <mi>S</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <intersect></intersect>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>f</ci>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <set>
       <ci>y</ci>
      </set>
     </apply>
    </apply>
    <ci>S</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f^{-1}[\{y\}]\cap S
  </annotation>
 </semantics>
</math>

 is non-empty. This works because it neglects exactly those 

<math display="inline" id="Adjoint_functors:113">
 <semantics>
  <mrow>
   <mi>y</mi>
   <mo>∈</mo>
   <mi>Y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>y</ci>
    <ci>Y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y\in Y
  </annotation>
 </semantics>
</math>

 which are in the complement of 

<math display="inline" id="Adjoint_functors:114">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>S</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>S</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f[S]
  </annotation>
 </semantics>
</math>

. So

<p>:<math></math></p>
</dd>
</dl>

<p>\exists_f S</p>
<h1 id="y-in-y-mid-exists-x-in-f-1y.-x-in-s">\{ y \in Y \mid \exists (x \in f^{-1}[\{y\}]).\, x \in S \; \}</h1>

<p>f[S]. </p>
<dl>
<dd>Put this in analogy to our motivation 

<math display="inline" id="Adjoint_functors:115">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mrow>
    <mi>y</mi>
    <mo>∈</mo>
    <mi>Y</mi>
   </mrow>
   <mo>∣</mo>
   <mrow>
    <mrow>
     <mo>∃</mo>
     <mi>x</mi>
    </mrow>
    <mo rspace="4.2pt">.</mo>
    <mrow>
     <mrow>
      <msub>
       <mi>ψ</mi>
       <mi>f</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo>,</mo>
       <mi>y</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>∧</mo>
     <mrow>
      <msub>
       <mi>ϕ</mi>
       <mi>S</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">conditional-set</csymbol>
    <apply>
     <in></in>
     <ci>y</ci>
     <ci>Y</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">formulae-sequence</csymbol>
     <apply>
      <exists></exists>
      <ci>x</ci>
     </apply>
     <apply>
      <and></and>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ψ</ci>
        <ci>f</ci>
       </apply>
       <interval closure="open">
        <ci>x</ci>
        <ci>y</ci>
       </interval>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ϕ</ci>
        <ci>S</ci>
       </apply>
       <ci>x</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{y\in Y\mid\exists x.\,\psi_{f}(x,y)\land\phi_{S}(x)\}
  </annotation>
 </semantics>
</math>

.
</dd>
<dd>The right adjoint to the inverse image functor is given (without doing the computation here) by

<p>:<math></math></p>
</dd>
</dl>

<p>\forall_f S = \{ y \in Y \mid \forall (x \in f^{-1} [\{y\}]).\, x \in S \; \}. </p>
<dl>
<dd>The subset 

<math display="inline" id="Adjoint_functors:116">
 <semantics>
  <mrow>
   <msub>
    <mo>∀</mo>
    <mi>f</mi>
   </msub>
   <mi>S</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">for-all</csymbol>
     <ci>f</ci>
    </apply>
    <ci>S</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall_{f}S
  </annotation>
 </semantics>
</math>

 of 

<math display="inline" id="Adjoint_functors:117">
 <semantics>
  <mi>Y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y
  </annotation>
 </semantics>
</math>

 is characterized as the full set of 

<math display="inline" id="Adjoint_functors:118">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

's with the property that the inverse image of 

<math display="inline" id="Adjoint_functors:119">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mi>y</mi>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <ci>y</ci>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{y\}
  </annotation>
 </semantics>
</math>

 with respect to 

<math display="inline" id="Adjoint_functors:120">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 is fully contained within 

<math display="inline" id="Adjoint_functors:121">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

. Note how the predicate determining the set is the same as above, except that 

<math display="inline" id="Adjoint_functors:122">
 <semantics>
  <mo>∃</mo>
  <annotation-xml encoding="MathML-Content">
   <exists></exists>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \exists
  </annotation>
 </semantics>
</math>

 is replaced by 

<math display="inline" id="Adjoint_functors:123">
 <semantics>
  <mo>∀</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">for-all</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall
  </annotation>
 </semantics>
</math>

.
</dd>
</dl>
<dl>
<dd><em>See also <a class="uri" href="powerset" title="wikilink">powerset</a>.</em>
</dd>
</dl>
<h2 id="properties">Properties</h2>
<h3 id="existence">Existence</h3>

<p>Not every functor <em>G</em> : <em>C</em> → <em>D</em> admits a left adjoint. If <em>C</em> is a <a href="complete_category" title="wikilink">complete category</a>, then the functors with left adjoints can be characterized by the <strong>adjoint functor theorem</strong> of <a href="Peter_J._Freyd" title="wikilink">Peter J. Freyd</a>: <em>G</em> has a left adjoint if and only if it is <a href="limit_(category_theory)#Preservation_of_limits" title="wikilink">continuous</a> and a certain smallness condition is satisfied: for every object <em>Y</em> of <em>D</em> there exists a family of morphisms</p>
<dl>
<dd><em>f</em><sub><em>i</em></sub> : <em>Y</em> → <em>G</em>(<em>X<sub>i</sub></em>)
</dd>
</dl>

<p>where the indices <em>i</em> come from a <em>set</em> <em>I</em>, not a <em><a href="class_(set_theory)" title="wikilink">proper class</a></em>, such that every morphism</p>
<dl>
<dd><em>h</em> : <em>Y</em> → <em>G</em>(<em>X</em>)
</dd>
</dl>

<p>can be written as</p>
<dl>
<dd><em>h</em> = <em>G</em>(<em>t</em>) o <em>f</em><sub><em>i</em></sub>
</dd>
</dl>

<p>for some <em>i</em> in <em>I</em> and some morphism</p>
<dl>
<dd><em>t</em> : <em>X</em><sub><em>i</em></sub> → <em>X</em> in <em>C</em>.
</dd>
</dl>

<p>An analogous statement characterizes those functors with a right adjoint.</p>
<h3 id="uniqueness">Uniqueness</h3>

<p>If the functor <em>F</em> : <em>C</em> ← <em>D</em> has two right adjoints <em>G</em> and <em>G</em>′, then <em>G</em> and <em>G</em>′ are <a href="natural_transformation" title="wikilink">naturally isomorphic</a>. The same is true for left adjoints.</p>

<p>Conversely, if <em>F</em> is left adjoint to <em>G</em>, and <em>G</em> is naturally isomorphic to <em>G</em>′ then <em>F</em> is also left adjoint to <em>G</em>′. More generally, if 〈<em>F</em>, <em>G</em>, ε, η〉 is an adjunction (with counit-unit (ε,η)) and</p>
<dl>
<dd>σ : <em>F</em> → <em>F</em>′
</dd>
<dd>τ : <em>G</em> → <em>G</em>′
</dd>
</dl>

<p>are natural isomorphisms then 〈<em>F</em>′, <em>G</em>′, ε′, η′〉 is an adjunction where</p>

<p>

<math display="inline" id="Adjoint_functors:124">
 <semantics>
  <msup>
   <mi>η</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>η</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle\eta^{\prime}
  </annotation>
 </semantics>
</math>


 Here 

<math display="inline" id="Adjoint_functors:125">
 <semantics>
  <mo>∘</mo>
  <annotation-xml encoding="MathML-Content">
   <compose></compose>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \circ
  </annotation>
 </semantics>
</math>

 denotes vertical composition of natural transformations, and 

<math display="inline" id="Adjoint_functors:126">
 <semantics>
  <mo>∗</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-∗</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ast
  </annotation>
 </semantics>
</math>

 denotes horizontal composition.</p>
<h3 id="composition">Composition</h3>

<p>Adjunctions can be composed in a natural fashion. Specifically, if 〈<em>F</em>, <em>G</em>, ε, η〉 is an adjunction between <em>C</em> and <em>D</em> and 〈<em>F</em>′, <em>G</em>′, ε′, η′〉 is an adjunction between <em>D</em> and <em>E</em> then the functor</p>

<p>

<math display="block" id="Adjoint_functors:127">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>F</mi>
     <mo>′</mo>
    </msup>
    <mo>∘</mo>
    <mi>F</mi>
   </mrow>
   <mo>:</mo>
   <mrow>
    <mi class="ltx_font_mathcaligraphic">𝒞</mi>
    <mo>←</mo>
    <mi class="ltx_font_mathcaligraphic">ℰ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <compose></compose>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>F</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>F</ci>
    </apply>
    <apply>
     <ci>normal-←</ci>
     <ci>𝒞</ci>
     <ci>ℰ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F^{\prime}\circ F:\mathcal{C}\leftarrow\mathcal{E}
  </annotation>
 </semantics>
</math>

 is left adjoint to</p>

<p>

<math display="block" id="Adjoint_functors:128">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>G</mi>
     <mo>∘</mo>
     <msup>
      <mi>G</mi>
      <mo>′</mo>
     </msup>
    </mrow>
    <mo>:</mo>
    <mrow>
     <mi class="ltx_font_mathcaligraphic">𝒞</mi>
     <mo>→</mo>
     <mi class="ltx_font_mathcaligraphic">ℰ</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <compose></compose>
     <ci>G</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>G</ci>
      <ci>normal-′</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <ci>𝒞</ci>
     <ci>ℰ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G\circ G^{\prime}:\mathcal{C}\to\mathcal{E}.
  </annotation>
 </semantics>
</math>

 More precisely, there is an adjunction between <em>F</em>′ <em>F</em> and <em>G</em> <em>G</em>′ with unit and counit given by the compositions:</p>

<p>

<math display="inline" id="Adjoint_functors:129">
 <semantics>
  <mrow>
   <msub>
    <mn>1</mn>
    <mi class="ltx_font_mathcaligraphic">ℰ</mi>
   </msub>
   <mover accent="true">
    <mo>→</mo>
    <mo>𝜂</mo>
   </mover>
   <mrow>
    <mi>G</mi>
    <mi>F</mi>
   </mrow>
   <mover accent="true">
    <mo>→</mo>
    <mrow>
     <mi>G</mi>
     <msup>
      <mi>η</mi>
      <mo>′</mo>
     </msup>
     <mi>F</mi>
    </mrow>
   </mover>
   <mrow>
    <mi>G</mi>
    <msup>
     <mi>G</mi>
     <mo>′</mo>
    </msup>
    <msup>
     <mi>F</mi>
     <mo>′</mo>
    </msup>
    <mi>F</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <apply>
      <ci>η</ci>
      <ci>normal-→</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <cn type="integer">1</cn>
      <ci>ℰ</ci>
     </apply>
     <apply>
      <times></times>
      <ci>G</ci>
      <ci>F</ci>
     </apply>
    </apply>
    <apply>
     <apply>
      <apply>
       <times></times>
       <ci>G</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>η</ci>
        <ci>normal-′</ci>
       </apply>
       <ci>F</ci>
      </apply>
      <ci>normal-→</ci>
     </apply>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>G</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>G</ci>
       <ci>normal-′</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>F</ci>
       <ci>normal-′</ci>
      </apply>
      <ci>F</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle 1_{\mathcal{E}}\xrightarrow{\eta}GF\xrightarrow{G\eta^{\prime}F}%
GG^{\prime}F^{\prime}F
  </annotation>
 </semantics>
</math>


 This new adjunction is called the <strong>composition</strong> of the two given adjunctions.</p>

<p>One can then form a category whose objects are all <a href="small_category" title="wikilink">small categories</a> and whose morphisms are adjunctions.</p>
<h3 id="limit-preservation">Limit preservation</h3>

<p>The most important property of adjoints is their continuity: every functor that has a left adjoint (and therefore <em>is</em> a right adjoint) is <em>continuous</em> (i.e. commutes with <a href="limit_(category_theory)" title="wikilink">limits</a> in the category theoretical sense); every functor that has a right adjoint (and therefore <em>is</em> a left adjoint) is <em>cocontinuous</em> (i.e. commutes with <a href="limit_(category_theory)" title="wikilink">colimits</a>).</p>

<p>Since many common constructions in mathematics are limits or colimits, this provides a wealth of information. For example:</p>
<ul>
<li>applying a right adjoint functor to a <a href="product_(category_theory)" title="wikilink">product</a> of objects yields the product of the images;</li>
<li>applying a left adjoint functor to a <a class="uri" href="coproduct" title="wikilink">coproduct</a> of objects yields the coproduct of the images;</li>
<li>every right adjoint functor is <a href="left_exact_functor" title="wikilink">left exact</a>;</li>
<li>every left adjoint functor is <a href="right_exact_functor" title="wikilink">right exact</a>.</li>
</ul>
<h3 id="additivity">Additivity</h3>

<p>If <em>C</em> and <em>D</em> are <a href="preadditive_categories" title="wikilink">preadditive categories</a> and <em>F</em> : <em>C</em> ← <em>D</em> is an <a href="additive_functor" title="wikilink">additive functor</a> with a right adjoint <em>G</em> : <em>C</em> → <em>D</em>, then <em>G</em> is also an additive functor and the hom-set bijections</p>

<p>

<math display="block" id="Adjoint_functors:130">
 <semantics>
  <mrow>
   <msub>
    <mi mathvariant="normal">Φ</mi>
    <mrow>
     <mi>Y</mi>
     <mo>,</mo>
     <mi>X</mi>
    </mrow>
   </msub>
   <mo>:</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>hom</mi>
      <mi class="ltx_font_mathcaligraphic">𝒞</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>F</mi>
       <mi>Y</mi>
      </mrow>
      <mo>,</mo>
      <mi>X</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>≅</mo>
    <mrow>
     <msub>
      <mi>hom</mi>
      <mi class="ltx_font_mathcaligraphic">𝒟</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>Y</mi>
      <mo>,</mo>
      <mrow>
       <mi>G</mi>
       <mi>X</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-Φ</ci>
     <list>
      <ci>Y</ci>
      <ci>X</ci>
     </list>
    </apply>
    <apply>
     <approx></approx>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>hom</ci>
       <ci>𝒞</ci>
      </apply>
      <interval closure="open">
       <apply>
        <times></times>
        <ci>F</ci>
        <ci>Y</ci>
       </apply>
       <ci>X</ci>
      </interval>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>hom</ci>
       <ci>𝒟</ci>
      </apply>
      <interval closure="open">
       <ci>Y</ci>
       <apply>
        <times></times>
        <ci>G</ci>
        <ci>X</ci>
       </apply>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Phi_{Y,X}:\mathrm{hom}_{\mathcal{C}}(FY,X)\cong\mathrm{hom}_{\mathcal{D}}(Y,GX)
  </annotation>
 </semantics>
</math>

 are, in fact, isomorphisms of abelian groups. Dually, if <em>G</em> is additive with a left adjoint <em>F</em>, then <em>F</em> is also additive.</p>

<p>Moreover, if both <em>C</em> and <em>D</em> are <a href="additive_categories" title="wikilink">additive categories</a> (i.e. preadditive categories with all finite <a href="biproduct" title="wikilink">biproducts</a>), then any pair of adjoint functors between them are automatically additive.</p>
<h2 id="relationships">Relationships</h2>
<h3 id="universal-constructions">Universal constructions</h3>

<p>As stated earlier, an adjunction between categories <em>C</em> and <em>D</em> gives rise to a family of <a href="universal_morphism" title="wikilink">universal morphisms</a>, one for each object in <em>C</em> and one for each object in <em>D</em>. Conversely, if there exists a universal morphism to a functor <em>G</em> : <em>C</em> → <em>D</em> from every object of <em>D</em>, then <em>G</em> has a left adjoint.</p>

<p>However, universal constructions are more general than adjoint functors: a universal construction is like an optimization problem; it gives rise to an adjoint pair if and only if this problem has a solution for every object of <em>D</em> (equivalently, every object of <em>C</em>).</p>
<h3 id="equivalences-of-categories">Equivalences of categories</h3>

<p>If a functor <em>F</em>: <em>C</em>←<em>D</em> is one half of an <a href="equivalence_of_categories" title="wikilink">equivalence of categories</a> then it is the left adjoint in an adjoint equivalence of categories, i.e. an adjunction whose unit and counit are isomorphisms.</p>

<p>Every adjunction 〈<em>F</em>, <em>G</em>, ε, η〉 extends an equivalence of certain subcategories. Define <em>C</em><sub>1</sub> as the full subcategory of <em>C</em> consisting of those objects <em>X</em> of <em>C</em> for which ε<sub><em>X</em></sub> is an isomorphism, and define <em>D</em><sub>1</sub> as the <a href="full_subcategory" title="wikilink">full subcategory</a> of <em>D</em> consisting of those objects <em>Y</em> of <em>D</em> for which η<sub><em>Y</em></sub> is an isomorphism. Then <em>F</em> and <em>G</em> can be restricted to <em>D</em><sub>1</sub> and <em>C</em><sub>1</sub> and yield inverse equivalences of these subcategories.</p>

<p>In a sense, then, adjoints are "generalized" inverses. Note however that a right inverse of <em>F</em> (i.e. a functor <em>G</em> such that <em>FG</em> is naturally isomorphic to 1<sub><em>D</em></sub>) need not be a right (or left) adjoint of <em>F</em>. Adjoints generalize <em>two-sided</em> inverses.</p>
<h3 id="monads">Monads</h3>

<p>Every adjunction 〈<em>F</em>, <em>G</em>, ε, η〉 gives rise to an associated <a href="monad_(category_theory)" title="wikilink">monad</a> 〈<em>T</em>, η, μ〉 in the category <em>D</em>. The functor</p>

<p>

<math display="block" id="Adjoint_functors:131">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mo>:</mo>
   <mrow>
    <mi class="ltx_font_mathcaligraphic">𝒟</mi>
    <mo>→</mo>
    <mi class="ltx_font_mathcaligraphic">𝒟</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>T</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>𝒟</ci>
     <ci>𝒟</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T:\mathcal{D}\to\mathcal{D}
  </annotation>
 </semantics>
</math>

 is given by <em>T</em> = <em>GF</em>. The unit of the monad</p>

<p>

<math display="block" id="Adjoint_functors:132">
 <semantics>
  <mrow>
   <mi>η</mi>
   <mo>:</mo>
   <mrow>
    <msub>
     <mn>1</mn>
     <mi class="ltx_font_mathcaligraphic">𝒟</mi>
    </msub>
    <mo>→</mo>
    <mi>T</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>η</ci>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <cn type="integer">1</cn>
      <ci>𝒟</ci>
     </apply>
     <ci>T</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \eta:1_{\mathcal{D}}\to T
  </annotation>
 </semantics>
</math>

 is just the unit η of the adjunction and the multiplication transformation</p>

<p>

<math display="block" id="Adjoint_functors:133">
 <semantics>
  <mrow>
   <mi>μ</mi>
   <mo>:</mo>
   <mrow>
    <msup>
     <mi>T</mi>
     <mn>2</mn>
    </msup>
    <mo>→</mo>
    <mpadded width="+1.7pt">
     <mi>T</mi>
    </mpadded>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>μ</ci>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>T</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>T</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu:T^{2}\to T\,
  </annotation>
 </semantics>
</math>

 is given by μ = <em>G</em>ε<em>F</em>. Dually, the triple 〈<em>FG</em>, ε, <em>F</em>η<em>G</em>〉 defines a <a class="uri" href="comonad" title="wikilink">comonad</a> in <em>C</em>.</p>

<p>Every monad arises from some adjunction—in fact, typically from many adjunctions—in the above fashion. Two constructions, called the category of <a href="Eilenberg–Moore_algebra" title="wikilink">Eilenberg–Moore algebras</a> and the <a href="Kleisli_category" title="wikilink">Kleisli category</a> are two extremal solutions to the problem of constructing an adjunction that gives rise to a given monad.</p>
<h2 id="references">References</h2>
<references>
</references>
<ul>
<li></li>
<li></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.youtube.com/view_play_list?p=54B49729E5102248">Adjunctions</a> Seven short lectures on adjunctions.</li>
</ul>

<p>"</p>

<p><a href="Category:Adjoint_functors" title="wikilink"> </a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="http://www.arxiv.org/abs/q-alg/9609018">arXiv.org: John C. Baez <em>Higher-Dimensional Algebra II: 2-Hilbert Spaces</em></a>.<a href="#fnref1">↩</a></li>
<li id="fn2"><a href="William_Lawvere" title="wikilink">William Lawvere</a>, Adjointness in foundations, Dialectica, 1969, <a href="http://www.tac.mta.ca/tac/reprints/articles/16/tr16abs.html">available here</a>. The notation is different nowadays; an easier introduction by Peter Smith <a href="http://www.logicmatters.net/resources/pdfs/Galois.pdf">in these lecture notes</a>, which also attribute the concept to the article cited.<a href="#fnref2">↩</a></li>
<li id="fn3">Saunders Mac Lane, Ieke Moerdijk, (1992) <em>Sheaves in Geometry and Logic</em> Springer-Verlag. ISBN 0-387-97710-4 <em>See page 58</em><a href="#fnref3">↩</a></li>
</ol>
</section>
</body>
</html>
