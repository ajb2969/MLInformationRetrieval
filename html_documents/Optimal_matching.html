<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="856">Optimal matching</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Optimal matching</h1>
<hr/>

<p><strong>Optimal matching</strong> is a sequence analysis method used in <a href="social_science" title="wikilink">social science</a>, to assess the dissimilarity of ordered arrays of tokens that usually represent a time-ordered sequence of socio-economic states two individuals have experienced. Once such distances have been calculated for a set of observations (e.g. individuals in a <a href="cohort_(statistics)" title="wikilink">cohort</a>) classical tools (such as <a href="cluster_analysis" title="wikilink">cluster analysis</a>) can be used. The method was tailored to social sciences<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> from a technique originally introduced to study molecular biology (protein or genetic) sequences (see <a href="sequence_alignment" title="wikilink">sequence alignment</a>). Optimal matching uses the <a href="Needleman-Wunsch_algorithm" title="wikilink">Needleman-Wunsch algorithm</a>.</p>
<h2 id="algorithm">Algorithm</h2>

<p>Let 

<math display="inline" id="Optimal_matching:0">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>s</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>s</mi>
     <mn>2</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>s</mi>
     <mn>3</mn>
    </msub>
    <mo>,</mo>
    <mrow>
     <mi mathvariant="normal">‚Ä¶</mi>
     <msub>
      <mi>s</mi>
      <mi>T</mi>
     </msub>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>S</ci>
    <vector>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>s</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>s</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>s</ci>
      <cn type="integer">3</cn>
     </apply>
     <apply>
      <times></times>
      <ci>normal-‚Ä¶</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>s</ci>
       <ci>T</ci>
      </apply>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S=(s_{1},s_{2},s_{3},\ldots s_{T})
  </annotation>
 </semantics>
</math>

 be a sequence of states 

<math display="inline" id="Optimal_matching:1">
 <semantics>
  <msub>
   <mi>s</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>s</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s_{i}
  </annotation>
 </semantics>
</math>

 belonging to a finite set of possible states. Let us denote 

<math display="inline" id="Optimal_matching:2">
 <semantics>
  <mi>ùêí</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ùêí</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\mathbf{S}}
  </annotation>
 </semantics>
</math>

 the sequence space, i.e. the set of all possible sequences of states.</p>

<p>Optimal matching algorithms work by defining simple operator <a class="uri" href="algebras" title="wikilink">algebras</a> that manipulate sequences, i.e. a set of operators 

<math display="inline" id="Optimal_matching:3">
 <semantics>
  <mrow>
   <msub>
    <mi>a</mi>
    <mi>i</mi>
   </msub>
   <mo>:</mo>
   <mrow>
    <mi>ùêí</mi>
    <mo>‚Üí</mo>
    <mi>ùêí</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <ci>normal-‚Üí</ci>
     <ci>ùêí</ci>
     <ci>ùêí</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{i}:{\mathbf{S}}\rightarrow{\mathbf{S}}
  </annotation>
 </semantics>
</math>

. In the most simple approach, a set composed of only three basic operations to transform sequences is used:</p>
<ul>
<li>one state 

<math display="inline" id="Optimal_matching:4">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

 is inserted in the sequence 

<math display="inline" id="Optimal_matching:5">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mi>a</mi>
     <msup>
      <mi>s</mi>
      <mo>‚Ä≤</mo>
     </msup>
     <mi>Ins</mi>
    </msubsup>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>s</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>s</mi>
      <mn>2</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>s</mi>
      <mn>3</mn>
     </msub>
     <mo>,</mo>
     <mrow>
      <mi mathvariant="normal">‚Ä¶</mi>
      <msub>
       <mi>s</mi>
       <mi>T</mi>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>s</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>s</mi>
     <mn>2</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>s</mi>
     <mn>3</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">‚Ä¶</mi>
    <mo>,</mo>
    <msup>
     <mi>s</mi>
     <mo>‚Ä≤</mo>
    </msup>
    <mo>,</mo>
    <mrow>
     <mi mathvariant="normal">‚Ä¶</mi>
     <msub>
      <mi>s</mi>
      <mi>T</mi>
     </msub>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>a</ci>
       <ci>Ins</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>s</ci>
       <ci>normal-‚Ä≤</ci>
      </apply>
     </apply>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>s</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>s</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>s</ci>
       <cn type="integer">3</cn>
      </apply>
      <apply>
       <times></times>
       <ci>normal-‚Ä¶</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>s</ci>
        <ci>T</ci>
       </apply>
      </apply>
     </vector>
    </apply>
    <vector>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>s</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>s</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>s</ci>
      <cn type="integer">3</cn>
     </apply>
     <ci>normal-‚Ä¶</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>s</ci>
      <ci>normal-‚Ä≤</ci>
     </apply>
     <apply>
      <times></times>
      <ci>normal-‚Ä¶</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>s</ci>
       <ci>T</ci>
      </apply>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a^{\rm Ins}_{s^{\prime}}(s_{1},s_{2},s_{3},\ldots s_{T})=(s_{1},s_{2},s_{3},%
\ldots,s^{\prime},\ldots s_{T})
  </annotation>
 </semantics>
</math>

</li>
<li>one state is deleted from the sequence 

<math display="inline" id="Optimal_matching:6">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mi>a</mi>
     <msub>
      <mi>s</mi>
      <mn>2</mn>
     </msub>
     <mi>Del</mi>
    </msubsup>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>s</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>s</mi>
      <mn>2</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>s</mi>
      <mn>3</mn>
     </msub>
     <mo>,</mo>
     <mrow>
      <mi mathvariant="normal">‚Ä¶</mi>
      <msub>
       <mi>s</mi>
       <mi>T</mi>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>s</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>s</mi>
     <mn>3</mn>
    </msub>
    <mo>,</mo>
    <mrow>
     <mi mathvariant="normal">‚Ä¶</mi>
     <msub>
      <mi>s</mi>
      <mi>T</mi>
     </msub>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>a</ci>
       <ci>Del</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>s</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>s</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>s</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>s</ci>
       <cn type="integer">3</cn>
      </apply>
      <apply>
       <times></times>
       <ci>normal-‚Ä¶</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>s</ci>
        <ci>T</ci>
       </apply>
      </apply>
     </vector>
    </apply>
    <vector>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>s</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>s</ci>
      <cn type="integer">3</cn>
     </apply>
     <apply>
      <times></times>
      <ci>normal-‚Ä¶</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>s</ci>
       <ci>T</ci>
      </apply>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a^{\rm Del}_{s_{2}}(s_{1},s_{2},s_{3},\ldots s_{T})=(s_{1},s_{3},\ldots s_{T})
  </annotation>
 </semantics>
</math>

 and</li>
<li>a state 

<math display="inline" id="Optimal_matching:7">
 <semantics>
  <msub>
   <mi>s</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>s</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s_{1}
  </annotation>
 </semantics>
</math>

 is replaced (substituted) by state 

<math display="inline" id="Optimal_matching:8">
 <semantics>
  <msubsup>
   <mi>s</mi>
   <mn>1</mn>
   <mo>‚Ä≤</mo>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>s</ci>
     <ci>normal-‚Ä≤</ci>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s^{\prime}_{1}
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Optimal_matching:9">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mi>a</mi>
     <mrow>
      <msub>
       <mi>s</mi>
       <mn>1</mn>
      </msub>
      <mo>,</mo>
      <msubsup>
       <mi>s</mi>
       <mn>1</mn>
       <mo>‚Ä≤</mo>
      </msubsup>
     </mrow>
     <mi>Sub</mi>
    </msubsup>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>s</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>s</mi>
      <mn>2</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>s</mi>
      <mn>3</mn>
     </msub>
     <mo>,</mo>
     <mrow>
      <mi mathvariant="normal">‚Ä¶</mi>
      <msub>
       <mi>s</mi>
       <mi>T</mi>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msubsup>
     <mi>s</mi>
     <mn>1</mn>
     <mo>‚Ä≤</mo>
    </msubsup>
    <mo>,</mo>
    <msub>
     <mi>s</mi>
     <mn>2</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>s</mi>
     <mn>3</mn>
    </msub>
    <mo>,</mo>
    <mrow>
     <mi mathvariant="normal">‚Ä¶</mi>
     <msub>
      <mi>s</mi>
      <mi>T</mi>
     </msub>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>a</ci>
       <ci>Sub</ci>
      </apply>
      <list>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>s</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>s</ci>
         <ci>normal-‚Ä≤</ci>
        </apply>
        <cn type="integer">1</cn>
       </apply>
      </list>
     </apply>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>s</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>s</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>s</ci>
       <cn type="integer">3</cn>
      </apply>
      <apply>
       <times></times>
       <ci>normal-‚Ä¶</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>s</ci>
        <ci>T</ci>
       </apply>
      </apply>
     </vector>
    </apply>
    <vector>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>s</ci>
       <ci>normal-‚Ä≤</ci>
      </apply>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>s</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>s</ci>
      <cn type="integer">3</cn>
     </apply>
     <apply>
      <times></times>
      <ci>normal-‚Ä¶</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>s</ci>
       <ci>T</ci>
      </apply>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a^{\rm Sub}_{s_{1},s^{\prime}_{1}}(s_{1},s_{2},s_{3},\ldots s_{T})=(s^{\prime}%
_{1},s_{2},s_{3},\ldots s_{T})
  </annotation>
 </semantics>
</math>

.</li>
</ul>

<p>Imagine now that a <em>cost</em> 

<math display="inline" id="Optimal_matching:10">
 <semantics>
  <mrow>
   <mrow>
    <mi>c</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>a</mi>
      <mi>i</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>‚àà</mo>
   <msubsup>
    <mi>ùêë</mi>
    <mn>0</mn>
    <mo>+</mo>
   </msubsup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <times></times>
     <ci>c</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <ci>i</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ùêë</ci>
      <plus></plus>
     </apply>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c(a_{i})\in{\mathbf{R}}^{+}_{0}
  </annotation>
 </semantics>
</math>

 is associated to each operator. Given two sequences 

<math display="inline" id="Optimal_matching:11">
 <semantics>
  <msub>
   <mi>S</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>S</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{1}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Optimal_matching:12">
 <semantics>
  <msub>
   <mi>S</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>S</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{2}
  </annotation>
 </semantics>
</math>

, the idea is to measure the <em>cost</em> of obtaining 

<math display="inline" id="Optimal_matching:13">
 <semantics>
  <msub>
   <mi>S</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>S</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{2}
  </annotation>
 </semantics>
</math>

 from 

<math display="inline" id="Optimal_matching:14">
 <semantics>
  <msub>
   <mi>S</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>S</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{1}
  </annotation>
 </semantics>
</math>

 using operators from the algebra. Let 

<math display="inline" id="Optimal_matching:15">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>a</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>a</mi>
     <mn>2</mn>
    </msub>
    <mo>,</mo>
    <mrow>
     <mi mathvariant="normal">‚Ä¶</mi>
     <msub>
      <mi>a</mi>
      <mi>n</mi>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>A</ci>
    <list>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <times></times>
      <ci>normal-‚Ä¶</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A={a_{1},a_{2},\ldots a_{n}}
  </annotation>
 </semantics>
</math>

 be a sequence of operators such that the application of all the operators of this sequence 

<math display="inline" id="Optimal_matching:16">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 to the first sequence 

<math display="inline" id="Optimal_matching:17">
 <semantics>
  <msub>
   <mi>S</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>S</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{1}
  </annotation>
 </semantics>
</math>

 gives the second sequence 

<math display="inline" id="Optimal_matching:18">
 <semantics>
  <msub>
   <mi>S</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>S</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{2}
  </annotation>
 </semantics>
</math>

: 

<math display="inline" id="Optimal_matching:19">
 <semantics>
  <mrow>
   <msub>
    <mi>S</mi>
    <mn>2</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>a</mi>
      <mn>1</mn>
     </msub>
     <mo>‚àò</mo>
     <msub>
      <mi>a</mi>
      <mn>2</mn>
     </msub>
     <mo>‚àò</mo>
     <mi mathvariant="normal">‚Ä¶</mi>
     <mo>‚àò</mo>
     <msub>
      <mi>a</mi>
      <mi>n</mi>
     </msub>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>S</mi>
      <mn>1</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>S</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <times></times>
     <apply>
      <compose></compose>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-‚Ä¶</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <ci>n</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>S</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{2}=a_{1}\circ a_{2}\circ\ldots\circ a_{n}(S_{1})
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Optimal_matching:20">
 <semantics>
  <mrow>
   <msub>
    <mi>a</mi>
    <mn>1</mn>
   </msub>
   <mo>‚àò</mo>
   <msub>
    <mi>a</mi>
    <mn>2</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <compose></compose>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{1}\circ a_{2}
  </annotation>
 </semantics>
</math>

 denotes the compound operator. To this set we associate the cost 

<math display="inline" id="Optimal_matching:21">
 <semantics>
  <mrow>
   <mrow>
    <mi>c</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>A</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">‚àë</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>n</mi>
    </msubsup>
    <mrow>
     <mi>c</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>a</mi>
       <mi>i</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>c</ci>
     <ci>A</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>n</ci>
     </apply>
     <apply>
      <times></times>
      <ci>c</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c(A)=\sum_{i=1}^{n}c(a_{i})
  </annotation>
 </semantics>
</math>

, that represents the total cost of the transformation. One should consider at this point that there might exist different such sequences 

<math display="inline" id="Optimal_matching:22">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 that transform 

<math display="inline" id="Optimal_matching:23">
 <semantics>
  <msub>
   <mi>S</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>S</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{1}
  </annotation>
 </semantics>
</math>

 into 

<math display="inline" id="Optimal_matching:24">
 <semantics>
  <msub>
   <mi>S</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>S</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{2}
  </annotation>
 </semantics>
</math>

; a reasonable choice is to select the cheapest of such sequences. We thus call distance<br/>


<math display="inline" id="Optimal_matching:25">
 <semantics>
  <mrow>
   <mrow>
    <mi>d</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>S</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>S</mi>
      <mn>2</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>min</mi>
     <mi>A</mi>
    </msub>
    <mrow>
     <mo>{</mo>
     <mrow>
      <mrow>
       <mi>c</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>A</mi>
        <mo rspace="5.8pt" stretchy="false">)</mo>
       </mrow>
       <mpadded width="+3.3pt">
        <mi>such</mi>
       </mpadded>
       <mpadded width="+3.3pt">
        <mi>that</mi>
       </mpadded>
       <msub>
        <mi>S</mi>
        <mn>2</mn>
       </msub>
      </mrow>
      <mo>=</mo>
      <mrow>
       <mi>A</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>S</mi>
         <mn>1</mn>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo>}</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>d</ci>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>S</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>S</ci>
       <cn type="integer">2</cn>
      </apply>
     </interval>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <min></min>
      <ci>A</ci>
     </apply>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <ci>c</ci>
       <ci>A</ci>
       <ci>such</ci>
       <ci>that</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>S</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>A</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>S</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d(S_{1},S_{2})=\min_{A}\left\{c(A)~{}{\rm such~{}that}~{}S_{2}=A(S_{1})\right\}
  </annotation>
 </semantics>
</math>

<br/>
 that is, the cost of the least expensive set of transformations that turn 

<math display="inline" id="Optimal_matching:26">
 <semantics>
  <msub>
   <mi>S</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>S</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{1}
  </annotation>
 </semantics>
</math>

 into 

<math display="inline" id="Optimal_matching:27">
 <semantics>
  <msub>
   <mi>S</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>S</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{2}
  </annotation>
 </semantics>
</math>

. Notice that 

<math display="inline" id="Optimal_matching:28">
 <semantics>
  <mrow>
   <mi>d</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>S</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>S</mi>
     <mn>2</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>d</ci>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>S</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>S</ci>
      <cn type="integer">2</cn>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d(S_{1},S_{2})
  </annotation>
 </semantics>
</math>

 is by definition nonnegative since it is the sum of positive costs, and trivially 

<math display="inline" id="Optimal_matching:29">
 <semantics>
  <mrow>
   <mrow>
    <mi>d</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>S</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>S</mi>
      <mn>2</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>d</ci>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>S</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>S</ci>
       <cn type="integer">2</cn>
      </apply>
     </interval>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d(S_{1},S_{2})=0
  </annotation>
 </semantics>
</math>

 if and only if 

<math display="inline" id="Optimal_matching:30">
 <semantics>
  <mrow>
   <msub>
    <mi>S</mi>
    <mn>1</mn>
   </msub>
   <mo>=</mo>
   <msub>
    <mi>S</mi>
    <mn>2</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>S</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>S</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{1}=S_{2}
  </annotation>
 </semantics>
</math>

, that is there is no cost. The distance function is <a class="uri" href="symmetric" title="wikilink">symmetric</a> if insertion and deletion costs are equal 

<math display="inline" id="Optimal_matching:31">
 <semantics>
  <mrow>
   <mrow>
    <mi>c</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>a</mi>
      <mi>Ins</mi>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>c</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>a</mi>
      <mi>Del</mi>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>c</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>a</ci>
      <ci>Ins</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>c</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>a</ci>
      <ci>Del</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c(a^{\rm Ins})=c(a^{\rm Del})
  </annotation>
 </semantics>
</math>

; the term <em>indel</em> cost usually refers to the common cost of insertion and deletion.</p>

<p>Considering a set composed of only the three basic operations described above, this proximity measure satisfies the triangular inequality. <a href="transitive_relation" title="wikilink">Transitivity</a> however, depends on the definition of the set of elementary operations.</p>
<h2 id="criticism">Criticism</h2>

<p>Although optimal matching techniques are widely used in sociology and demography, such techniques also have their flaws. As was pointed out by several authors (for example L. L. Wu<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a>), the main problem in the application of optimal matching is to appropriately define the costs 

<math display="inline" id="Optimal_matching:32">
 <semantics>
  <mrow>
   <mi>c</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>a</mi>
     <mi>i</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>c</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c(a_{i})
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="optimal-matching-in-causal-modelling">Optimal matching in causal modelling</h2>

<p>Optimal matching is also a term used in statistical modelling of <a href="Counterfactual_conditional#Within_empirical_testing" title="wikilink">causal effects</a>. In this context it refers to matching "cases" with "controls", and is completely separate from the sequence-analytic sense.</p>
<h2 id="software">Software</h2>
<ul>
<li><a href="http://www.stat.ruhr-uni-bochum.de/tda.html">TDA</a> is a powerful program, offering access to some of the latest developments in transition data analysis.</li>
<li><a href="http://ideas.repec.org/a/tsj/stataj/v6y2006i4p435-460.html">STATA</a> has implemented a package to run optimal matching analysis.</li>
<li><a href="http://mephisto.unige.ch/traminer/">TraMineR</a> is an open source <a href="R_(programming_language)" title="wikilink">R</a>-package for analysing and visualizing states and events sequences, including optimal matching analysis.</li>
</ul>
<h2 id="references-and-notes">References and notes</h2>
<references>
</references>

<p>"</p>

<p><a href="Category:Data_mining" title="wikilink">Category:Data mining</a> <a href="Category:Statistical_distance_measures" title="wikilink">Category:Statistical distance measures</a> <a href="Category:Methods_in_sociology" title="wikilink">Category:Methods in sociology</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">A. Abbott and A. Tsay, (2000) <em><a href="http://smr.sagepub.com/cgi/content/abstract/29/1/3">Sequence Analysis and Optimal Matching Methods in Sociology: Review and Prospect</a></em> Sociological Methods &amp; Research], Vol. 29, 3-33. <a href="#fnref1">‚Ü©</a></li>
<li id="fn2">L. L. Wu. (2000) <em><a href="http://smr.sagepub.com/cgi/content/refs/29/1/41">Some Comments on "Sequence Analysis and Optimal Matching Methods in Sociology: Review and Prospect"</a></em> Sociological Methods &amp; Research, 29 41-64. <a href="#fnref2">‚Ü©</a></li>
</ol>
</section>
</body>
</html>
