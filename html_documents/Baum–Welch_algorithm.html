<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="748">Baum–Welch algorithm</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Baum–Welch algorithm</h1>
<hr/>

<p>In <a href="electrical_engineering" title="wikilink">electrical engineering</a>, <a href="computer_science" title="wikilink">computer science</a>, <a href="statistical_computing" title="wikilink">statistical computing</a> and <a class="uri" href="bioinformatics" title="wikilink">bioinformatics</a>, the <strong>Baum–Welch algorithm</strong> is used to find the unknown parameters of a <a href="hidden_Markov_model" title="wikilink">hidden Markov model</a> (HMM). It makes use of the <a href="forward-backward_algorithm" title="wikilink">forward-backward algorithm</a> and is named for <a href="Leonard_E._Baum" title="wikilink">Leonard E. Baum</a> and <a href="Lloyd_R._Welch" title="wikilink">Lloyd R. Welch</a>.</p>
<h2 id="history">History</h2>

<p><a href="Hidden_Markov_Models" title="wikilink">Hidden Markov Models</a> (HMMs) and the Baum–Welch algorithm were first described in a series of articles by <a href="Leonard_E._Baum" title="wikilink">Leonard E. Baum</a> and his peers at the Institute for Defense Analysis in the late 1960s.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> One of the first major applications of HMMs was to the field of <a href="speech_processing" title="wikilink">speech processing</a>.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> In the 1980s, HMMs were emerging as a useful tool in the analysis of biological systems and information, and in particular <a href="genomics" title="wikilink">genetic information</a>.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> They have since become an important tool in the probabilistic modeling of genomic sequences.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>
<h2 id="description">Description</h2>

<p>A <a href="Hidden_Markov_Model" title="wikilink">Hidden Markov Model</a> describes the joint probability of a collection of 'hidden' and observed discrete random variables. It relies on the assumption that the 

<math display="inline" id="Baum–Welch_algorithm:0">
 <semantics>
  <msup>
   <mi>i</mi>
   <mrow>
    <mi>t</mi>
    <mi>h</mi>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>i</ci>
    <apply>
     <times></times>
     <ci>t</ci>
     <ci>h</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i^{th}
  </annotation>
 </semantics>
</math>

 hidden variable given the 

<math display="inline" id="Baum–Welch_algorithm:1">
 <semantics>
  <msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>i</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mi>t</mi>
    <mi>h</mi>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <minus></minus>
     <ci>i</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <times></times>
     <ci>t</ci>
     <ci>h</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (i-1)^{th}
  </annotation>
 </semantics>
</math>

 hidden variable is independent of previous hidden variables, and the current observation variables depend only on the current hidden state.<br/>
The Baum–Welch algorithm uses the well known <a href="EM_algorithm" title="wikilink">EM algorithm</a> to find the <a href="maximum_likelihood" title="wikilink">maximum likelihood</a> estimate of the parameters of a hidden Markov model given a set of observed feature vectors.<br/>
Let 

<math display="inline" id="Baum–Welch_algorithm:2">
 <semantics>
  <msub>
   <mi>X</mi>
   <mi>t</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>X</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{t}
  </annotation>
 </semantics>
</math>

 be a discrete hidden random variable with 

<math display="inline" id="Baum–Welch_algorithm:3">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

 possible values. We assume the 

<math display="inline" id="Baum–Welch_algorithm:4">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>X</mi>
     <mi>t</mi>
    </msub>
    <mo stretchy="false">|</mo>
    <msub>
     <mi>X</mi>
     <mrow>
      <mi>t</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <ci>t</ci>
     </apply>
     <ci>normal-|</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <apply>
       <minus></minus>
       <ci>t</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(X_{t}|X_{t-1})
  </annotation>
 </semantics>
</math>

 is independent of time 

<math display="inline" id="Baum–Welch_algorithm:5">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

, which leads to the definition of the time independent stochastic transition matrix</p>

<p>

<math display="block" id="Baum–Welch_algorithm:6">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <msub>
     <mi>a</mi>
     <mrow>
      <mi>i</mi>
      <mi>j</mi>
     </mrow>
    </msub>
    <mo stretchy="false">}</mo>
   </mrow>
   <mo>=</mo>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>X</mi>
     <mi>t</mi>
    </msub>
    <mo>=</mo>
    <mi>j</mi>
    <mo stretchy="false">|</mo>
    <msub>
     <mi>X</mi>
     <mrow>
      <mi>t</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo>=</mo>
    <mi>i</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">A</csymbol>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-{</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <apply>
       <times></times>
       <ci>i</ci>
       <ci>j</ci>
      </apply>
     </apply>
     <ci>normal-}</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <ci>t</ci>
     </apply>
     <eq></eq>
     <csymbol cd="unknown">j</csymbol>
     <ci>normal-|</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <apply>
       <minus></minus>
       <ci>t</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <eq></eq>
     <csymbol cd="unknown">i</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A=\{a_{ij}\}=P(X_{t}=j|X_{t-1}=i)
  </annotation>
 </semantics>
</math>

 .<br/>
The initial state distribution (i.e. when 

<math display="inline" id="Baum–Welch_algorithm:7">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>t</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t=1
  </annotation>
 </semantics>
</math>

) is given by</p>

<p>

<math display="block" id="Baum–Welch_algorithm:8">
 <semantics>
  <mrow>
   <msub>
    <mi>π</mi>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>X</mi>
     <mn>1</mn>
    </msub>
    <mo>=</mo>
    <mi>i</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>π</ci>
     <ci>i</ci>
    </apply>
    <eq></eq>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <cn type="integer">1</cn>
     </apply>
     <eq></eq>
     <csymbol cd="unknown">i</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi_{i}=P(X_{1}=i)
  </annotation>
 </semantics>
</math>

.<br/>
The observation variables 

<math display="inline" id="Baum–Welch_algorithm:9">
 <semantics>
  <msub>
   <mi>Y</mi>
   <mi>t</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>Y</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y_{t}
  </annotation>
 </semantics>
</math>

 can take one of 

<math display="inline" id="Baum–Welch_algorithm:10">
 <semantics>
  <mi>K</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>K</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K
  </annotation>
 </semantics>
</math>

 possible values. The probability of a certain observation at time 

<math display="inline" id="Baum–Welch_algorithm:11">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 for state 

<math display="inline" id="Baum–Welch_algorithm:12">
 <semantics>
  <mi>j</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>j</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   j
  </annotation>
 </semantics>
</math>

 is given by</p>

<p>

<math display="block" id="Baum–Welch_algorithm:13">
 <semantics>
  <mrow>
   <msub>
    <mi>b</mi>
    <mi>j</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>y</mi>
     <mi>t</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>Y</mi>
     <mi>t</mi>
    </msub>
    <mo>=</mo>
    <msub>
     <mi>y</mi>
     <mi>t</mi>
    </msub>
    <mo stretchy="false">|</mo>
    <msub>
     <mi>X</mi>
     <mi>t</mi>
    </msub>
    <mo>=</mo>
    <mi>j</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>b</ci>
     <ci>j</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <ci>t</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Y</ci>
      <ci>t</ci>
     </apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <ci>t</ci>
     </apply>
     <ci>normal-|</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <ci>t</ci>
     </apply>
     <eq></eq>
     <csymbol cd="unknown">j</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b_{j}(y_{t})=P(Y_{t}=y_{t}|X_{t}=j)
  </annotation>
 </semantics>
</math>

.<br/>
Taking into account all the possible values of 

<math display="inline" id="Baum–Welch_algorithm:14">
 <semantics>
  <msub>
   <mi>Y</mi>
   <mi>t</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>Y</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y_{t}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Baum–Welch_algorithm:15">
 <semantics>
  <msub>
   <mi>X</mi>
   <mi>t</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>X</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{t}
  </annotation>
 </semantics>
</math>

 we obtain the 

<math display="inline" id="Baum–Welch_algorithm:16">
 <semantics>
  <mi>K</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>K</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K
  </annotation>
 </semantics>
</math>

 by 

<math display="inline" id="Baum–Welch_algorithm:17">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

 matrix 

<math display="inline" id="Baum–Welch_algorithm:18">
 <semantics>
  <mrow>
   <mi>B</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <msub>
      <mi>b</mi>
      <mi>j</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>y</mi>
       <mi>i</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>B</ci>
    <set>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <ci>j</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B=\{b_{j}(y_{i})\}
  </annotation>
 </semantics>
</math>

.<br/>
An observation sequence is given by 

<math display="inline" id="Baum–Welch_algorithm:19">
 <semantics>
  <mrow>
   <mi>Y</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>Y</mi>
     <mn>1</mn>
    </msub>
    <mo>=</mo>
    <msub>
     <mi>y</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>Y</mi>
     <mn>2</mn>
    </msub>
    <mo>=</mo>
    <msub>
     <mi>y</mi>
     <mn>2</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>Y</mi>
     <mi>T</mi>
    </msub>
    <mo>=</mo>
    <msub>
     <mi>y</mi>
     <mi>T</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">Y</csymbol>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Y</ci>
      <cn type="integer">1</cn>
     </apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Y</ci>
      <cn type="integer">2</cn>
     </apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-,</ci>
     <ci>normal-…</ci>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Y</ci>
      <ci>T</ci>
     </apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <ci>T</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y=(Y_{1}=y_{1},Y_{2}=y_{2},...,Y_{T}=y_{T})
  </annotation>
 </semantics>
</math>

.</p>

<p>Thus we can describe a hidden Markov chain by 

<math display="inline" id="Baum–Welch_algorithm:20">
 <semantics>
  <mrow>
   <mi>θ</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>A</mi>
    <mo>,</mo>
    <mi>B</mi>
    <mo>,</mo>
    <mi>π</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>θ</ci>
    <vector>
     <ci>A</ci>
     <ci>B</ci>
     <ci>π</ci>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta=(A,B,\pi)
  </annotation>
 </semantics>
</math>

. The Baum–Welch algorithm finds a local maximum for 

<math display="inline" id="Baum–Welch_algorithm:21">
 <semantics>
  <mrow>
   <msup>
    <mi>θ</mi>
    <mo>*</mo>
   </msup>
   <mo>=</mo>
   <munder>
    <mrow>
     <mpadded width="+1.7pt">
      <mi>arg</mi>
     </mpadded>
     <mi>max</mi>
    </mrow>
    <mi>θ</mi>
   </munder>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>Y</mi>
    <mo stretchy="false">|</mo>
    <mi>θ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>θ</ci>
     <times></times>
    </apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <times></times>
      <ci>arg</ci>
      <ci>max</ci>
     </apply>
     <ci>θ</ci>
    </apply>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">Y</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">θ</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta^{*}=\operatorname*{arg\,max}_{\theta}P(Y|\theta)
  </annotation>
 </semantics>
</math>

. (i.e. the HMM parameters 

<math display="inline" id="Baum–Welch_algorithm:22">
 <semantics>
  <mi>θ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>θ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta
  </annotation>
 </semantics>
</math>

 that maximise the probability of the observation.)<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>
<h3 id="algorithm">Algorithm</h3>

<p>Set 

<math display="inline" id="Baum–Welch_algorithm:23">
 <semantics>
  <mrow>
   <mi>θ</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>A</mi>
    <mo>,</mo>
    <mi>B</mi>
    <mo>,</mo>
    <mi>π</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>θ</ci>
    <vector>
     <ci>A</ci>
     <ci>B</ci>
     <ci>π</ci>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta=(A,B,\pi)
  </annotation>
 </semantics>
</math>

 with random initial conditions. They can also be set using prior information about the parameters if it is available.</p>
<h4 id="forward-procedure">Forward procedure</h4>

<p>Let 

<math display="inline" id="Baum–Welch_algorithm:24">
 <semantics>
  <mrow>
   <msub>
    <mi>α</mi>
    <mi>i</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>Y</mi>
     <mn>1</mn>
    </msub>
    <mo>=</mo>
    <msub>
     <mi>y</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>Y</mi>
     <mi>t</mi>
    </msub>
    <mo>=</mo>
    <msub>
     <mi>y</mi>
     <mi>t</mi>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>X</mi>
     <mi>t</mi>
    </msub>
    <mo>=</mo>
    <mi>i</mi>
    <mo stretchy="false">|</mo>
    <mi>θ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>α</ci>
     <ci>i</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">t</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Y</ci>
      <cn type="integer">1</cn>
     </apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-,</ci>
     <ci>normal-…</ci>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Y</ci>
      <ci>t</ci>
     </apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <ci>t</ci>
     </apply>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <ci>t</ci>
     </apply>
     <eq></eq>
     <csymbol cd="unknown">i</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">θ</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha_{i}(t)=P(Y_{1}=y_{1},...,Y_{t}=y_{t},X_{t}=i|\theta)
  </annotation>
 </semantics>
</math>

, the probability of seeing the 

<math display="inline" id="Baum–Welch_algorithm:25">
 <semantics>
  <mrow>
   <msub>
    <mi>y</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>y</mi>
    <mn>2</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>y</mi>
    <mi>t</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <ci>t</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{1},y_{2},...,y_{t}
  </annotation>
 </semantics>
</math>

 and being in state 

<math display="inline" id="Baum–Welch_algorithm:26">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

 at time 

<math display="inline" id="Baum–Welch_algorithm:27">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

. This is found recursively:</p>
<ol>
<li>

<math display="inline" id="Baum–Welch_algorithm:28">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>α</mi>
     <mi>i</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>1</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>π</mi>
     <mi>i</mi>
    </msub>
    <msub>
     <mi>b</mi>
     <mi>i</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>y</mi>
      <mn>1</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>α</ci>
      <ci>i</ci>
     </apply>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>π</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>b</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha_{i}(1)=\pi_{i}b_{i}(y_{1})
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="Baum–Welch_algorithm:29">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>α</mi>
     <mi>j</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>t</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>b</mi>
     <mi>j</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>y</mi>
      <mrow>
       <mi>t</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>N</mi>
     </msubsup>
     <mrow>
      <msub>
       <mi>α</mi>
       <mi>i</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <msub>
       <mi>a</mi>
       <mrow>
        <mi>i</mi>
        <mi>j</mi>
       </mrow>
      </msub>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>α</ci>
      <ci>j</ci>
     </apply>
     <apply>
      <plus></plus>
      <ci>t</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>b</ci>
      <ci>j</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <apply>
       <plus></plus>
       <ci>t</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>N</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>α</ci>
        <ci>i</ci>
       </apply>
       <ci>t</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <apply>
         <times></times>
         <ci>i</ci>
         <ci>j</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha_{j}(t+1)=b_{j}(y_{t+1})\sum_{i=1}^{N}\alpha_{i}(t)a_{ij}
  </annotation>
 </semantics>
</math>

</li>
</ol>
<h4 id="backward-procedure">Backward procedure</h4>

<p>Let 

<math display="inline" id="Baum–Welch_algorithm:30">
 <semantics>
  <mrow>
   <msub>
    <mi>β</mi>
    <mi>i</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>Y</mi>
     <mrow>
      <mi>t</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo>=</mo>
    <msub>
     <mi>y</mi>
     <mrow>
      <mi>t</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>Y</mi>
     <mi>T</mi>
    </msub>
    <mo>=</mo>
    <msub>
     <mi>y</mi>
     <mi>T</mi>
    </msub>
    <mo stretchy="false">|</mo>
    <msub>
     <mi>X</mi>
     <mi>t</mi>
    </msub>
    <mo>=</mo>
    <mi>i</mi>
    <mo>,</mo>
    <mi>θ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>β</ci>
     <ci>i</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">t</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Y</ci>
      <apply>
       <plus></plus>
       <ci>t</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <apply>
       <plus></plus>
       <ci>t</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>normal-,</ci>
     <ci>normal-…</ci>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Y</ci>
      <ci>T</ci>
     </apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <ci>T</ci>
     </apply>
     <ci>normal-|</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <ci>t</ci>
     </apply>
     <eq></eq>
     <csymbol cd="unknown">i</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">θ</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta_{i}(t)=P(Y_{t+1}=y_{t+1},...,Y_{T}=y_{T}|X_{t}=i,\theta)
  </annotation>
 </semantics>
</math>

 that is the probability of the ending partial sequence 

<math display="inline" id="Baum–Welch_algorithm:31">
 <semantics>
  <mrow>
   <msub>
    <mi>y</mi>
    <mrow>
     <mi>t</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>y</mi>
    <mi>T</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <apply>
      <plus></plus>
      <ci>t</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <ci>T</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{t+1},...,y_{T}
  </annotation>
 </semantics>
</math>

 given starting state 

<math display="inline" id="Baum–Welch_algorithm:32">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

 at time 

<math display="inline" id="Baum–Welch_algorithm:33">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

. We calculate 

<math display="inline" id="Baum–Welch_algorithm:34">
 <semantics>
  <mrow>
   <msub>
    <mi>β</mi>
    <mi>i</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>β</ci>
     <ci>i</ci>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta_{i}(t)
  </annotation>
 </semantics>
</math>

 as,</p>
<ol>
<li>

<math display="inline" id="Baum–Welch_algorithm:35">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>β</mi>
     <mi>i</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>T</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>β</ci>
      <ci>i</ci>
     </apply>
     <ci>T</ci>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta_{i}(T)=1
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="Baum–Welch_algorithm:36">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>β</mi>
     <mi>i</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∑</mo>
     <mrow>
      <mi>j</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>N</mi>
    </msubsup>
    <mrow>
     <msub>
      <mi>β</mi>
      <mi>j</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>t</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <msub>
      <mi>a</mi>
      <mrow>
       <mi>i</mi>
       <mi>j</mi>
      </mrow>
     </msub>
     <msub>
      <mi>b</mi>
      <mi>j</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>y</mi>
       <mrow>
        <mi>t</mi>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>β</ci>
      <ci>i</ci>
     </apply>
     <ci>t</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>j</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>N</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>β</ci>
       <ci>j</ci>
      </apply>
      <apply>
       <plus></plus>
       <ci>t</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <apply>
        <times></times>
        <ci>i</ci>
        <ci>j</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <ci>j</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <apply>
        <plus></plus>
        <ci>t</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta_{i}(t)=\sum_{j=1}^{N}\beta_{j}(t+1)a_{ij}b_{j}(y_{t+1})
  </annotation>
 </semantics>
</math>

</li>
</ol>
<h4 id="update">Update</h4>

<p>We can now calculate the temporary variables, according to Bayes' theorem:</p>

<p>

<math display="block" id="Baum–Welch_algorithm:37">
 <semantics>
  <mrow>
   <msub>
    <mi>γ</mi>
    <mi>i</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>X</mi>
     <mi>t</mi>
    </msub>
    <mo>=</mo>
    <mi>i</mi>
    <mo stretchy="false">|</mo>
    <mi>Y</mi>
    <mo>,</mo>
    <mi>θ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <msub>
      <mi>α</mi>
      <mi>i</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <msub>
      <mi>β</mi>
      <mi>i</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <mi>j</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>N</mi>
     </msubsup>
     <mrow>
      <msub>
       <mi>α</mi>
       <mi>j</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <msub>
       <mi>β</mi>
       <mi>j</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>γ</ci>
     <ci>i</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">t</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <ci>t</ci>
     </apply>
     <eq></eq>
     <csymbol cd="unknown">i</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">Y</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">θ</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>α</ci>
       <ci>i</ci>
      </apply>
      <ci>t</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>β</ci>
       <ci>i</ci>
      </apply>
      <ci>t</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>j</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>N</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>α</ci>
        <ci>j</ci>
       </apply>
       <ci>t</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>β</ci>
        <ci>j</ci>
       </apply>
       <ci>t</ci>
      </apply>
     </apply>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gamma_{i}(t)=P(X_{t}=i|Y,\theta)=\frac{\alpha_{i}(t)\beta_{i}(t)}{\sum_{j=1}^%
{N}\alpha_{j}(t)\beta_{j}(t)}
  </annotation>
 </semantics>
</math>

 which is the probability of being in state 

<math display="inline" id="Baum–Welch_algorithm:38">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

 at time 

<math display="inline" id="Baum–Welch_algorithm:39">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 given the observed sequence 

<math display="inline" id="Baum–Welch_algorithm:40">
 <semantics>
  <mi>Y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y
  </annotation>
 </semantics>
</math>

 and the parameters 

<math display="inline" id="Baum–Welch_algorithm:41">
 <semantics>
  <mi>θ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>θ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Baum–Welch_algorithm:42">
 <semantics>
  <mrow>
   <msub>
    <mi>ξ</mi>
    <mrow>
     <mi>i</mi>
     <mi>j</mi>
    </mrow>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>X</mi>
     <mi>t</mi>
    </msub>
    <mo>=</mo>
    <mi>i</mi>
    <mo>,</mo>
    <msub>
     <mi>X</mi>
     <mrow>
      <mi>t</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo>=</mo>
    <mi>j</mi>
    <mo stretchy="false">|</mo>
    <mi>Y</mi>
    <mo>,</mo>
    <mi>θ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <msub>
      <mi>α</mi>
      <mi>i</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <msub>
      <mi>a</mi>
      <mrow>
       <mi>i</mi>
       <mi>j</mi>
      </mrow>
     </msub>
     <msub>
      <mi>β</mi>
      <mi>j</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>t</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <msub>
      <mi>b</mi>
      <mi>j</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>y</mi>
       <mrow>
        <mi>t</mi>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <mi>k</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>N</mi>
     </msubsup>
     <mrow>
      <msubsup>
       <mo largeop="true" symmetric="true">∑</mo>
       <mrow>
        <mi>l</mi>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <mi>N</mi>
      </msubsup>
      <mrow>
       <msub>
        <mi>α</mi>
        <mi>k</mi>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>t</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <msub>
        <mi>a</mi>
        <mrow>
         <mi>k</mi>
         <mi>l</mi>
        </mrow>
       </msub>
       <msub>
        <mi>β</mi>
        <mi>l</mi>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>t</mi>
         <mo>+</mo>
         <mn>1</mn>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <msub>
        <mi>b</mi>
        <mi>l</mi>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>y</mi>
         <mrow>
          <mi>t</mi>
          <mo>+</mo>
          <mn>1</mn>
         </mrow>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mfrac>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <msub>
      <mi>α</mi>
      <mi>i</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <msub>
      <mi>a</mi>
      <mrow>
       <mi>i</mi>
       <mi>j</mi>
      </mrow>
     </msub>
     <msub>
      <mi>β</mi>
      <mi>j</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>t</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <msub>
      <mi>b</mi>
      <mi>j</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>y</mi>
       <mrow>
        <mi>t</mi>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <mi>k</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>N</mi>
     </msubsup>
     <mrow>
      <msub>
       <mi>α</mi>
       <mi>k</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <msub>
       <mi>β</mi>
       <mi>k</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ξ</ci>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>j</ci>
     </apply>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">t</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <ci>t</ci>
     </apply>
     <eq></eq>
     <csymbol cd="unknown">i</csymbol>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <apply>
       <plus></plus>
       <ci>t</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <eq></eq>
     <csymbol cd="unknown">j</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">Y</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">θ</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>α</ci>
       <ci>i</ci>
      </apply>
      <ci>t</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <apply>
        <times></times>
        <ci>i</ci>
        <ci>j</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>β</ci>
       <ci>j</ci>
      </apply>
      <apply>
       <plus></plus>
       <ci>t</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <ci>j</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <apply>
        <plus></plus>
        <ci>t</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>k</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>N</ci>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <ci>l</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>N</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>α</ci>
         <ci>k</ci>
        </apply>
        <ci>t</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>a</ci>
         <apply>
          <times></times>
          <ci>k</ci>
          <ci>l</ci>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>β</ci>
         <ci>l</ci>
        </apply>
        <apply>
         <plus></plus>
         <ci>t</ci>
         <cn type="integer">1</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>b</ci>
         <ci>l</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>y</ci>
         <apply>
          <plus></plus>
          <ci>t</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <eq></eq>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>α</ci>
       <ci>i</ci>
      </apply>
      <ci>t</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <apply>
        <times></times>
        <ci>i</ci>
        <ci>j</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>β</ci>
       <ci>j</ci>
      </apply>
      <apply>
       <plus></plus>
       <ci>t</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <ci>j</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <apply>
        <plus></plus>
        <ci>t</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>k</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>N</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>α</ci>
        <ci>k</ci>
       </apply>
       <ci>t</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>β</ci>
        <ci>k</ci>
       </apply>
       <ci>t</ci>
      </apply>
     </apply>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \xi_{ij}(t)=P(X_{t}=i,X_{t+1}=j|Y,\theta)=\frac{\alpha_{i}(t)a_{ij}\beta_{j}(t%
+1)b_{j}(y_{t+1})}{\sum_{k=1}^{N}\sum_{l=1}^{N}\alpha_{k}(t)a_{kl}\beta_{l}(t+%
1)b_{l}(y_{t+1})}=\frac{\alpha_{i}(t)a_{ij}\beta_{j}(t+1)b_{j}(y_{t+1})}{\sum_%
{k=1}^{N}\alpha_{k}(t)\beta_{k}(t)}
  </annotation>
 </semantics>
</math>

 which is the probability of being in state 

<math display="inline" id="Baum–Welch_algorithm:43">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Baum–Welch_algorithm:44">
 <semantics>
  <mi>j</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>j</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   j
  </annotation>
 </semantics>
</math>

 at times 

<math display="inline" id="Baum–Welch_algorithm:45">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Baum–Welch_algorithm:46">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mo>+</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>t</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t+1
  </annotation>
 </semantics>
</math>

 respectively given the observed sequence 

<math display="inline" id="Baum–Welch_algorithm:47">
 <semantics>
  <mi>Y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y
  </annotation>
 </semantics>
</math>

 and parameters 

<math display="inline" id="Baum–Welch_algorithm:48">
 <semantics>
  <mi>θ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>θ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta
  </annotation>
 </semantics>
</math>

.</p>

<p>

<math display="block" id="Baum–Welch_algorithm:49">
 <semantics>
  <mi>θ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>θ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta
  </annotation>
 </semantics>
</math>

 can now be updated:</p>
<ul>
<li>

<math display="inline" id="Baum–Welch_algorithm:50">
 <semantics>
  <mrow>
   <msubsup>
    <mi>π</mi>
    <mi>i</mi>
    <mo>*</mo>
   </msubsup>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>γ</mi>
     <mi>i</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>1</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>π</ci>
      <ci>i</ci>
     </apply>
     <times></times>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>γ</ci>
      <ci>i</ci>
     </apply>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi_{i}^{*}=\gamma_{i}(1)
  </annotation>
 </semantics>
</math>

</li>
</ul>

<p>which is the expected frequency spent in state 

<math display="inline" id="Baum–Welch_algorithm:51">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

 at time 

<math display="inline" id="Baum–Welch_algorithm:52">
 <semantics>
  <mn>1</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">1</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1
  </annotation>
 </semantics>
</math>

.</p>
<ul>
<li>

<math display="inline" id="Baum–Welch_algorithm:53">
 <semantics>
  <mrow>
   <msubsup>
    <mi>a</mi>
    <mrow>
     <mi>i</mi>
     <mi>j</mi>
    </mrow>
    <mo>*</mo>
   </msubsup>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mstyle displaystyle="false">
      <msubsup>
       <mo largeop="true" symmetric="true">∑</mo>
       <mrow>
        <mi>t</mi>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <mrow>
        <mi>T</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msubsup>
     </mstyle>
     <mrow>
      <msub>
       <mi>ξ</mi>
       <mrow>
        <mi>i</mi>
        <mi>j</mi>
       </mrow>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mrow>
     <mstyle displaystyle="false">
      <msubsup>
       <mo largeop="true" symmetric="true">∑</mo>
       <mrow>
        <mi>t</mi>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <mrow>
        <mi>T</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msubsup>
     </mstyle>
     <mrow>
      <msub>
       <mi>γ</mi>
       <mi>i</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <apply>
       <times></times>
       <ci>i</ci>
       <ci>j</ci>
      </apply>
     </apply>
     <times></times>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <sum></sum>
        <apply>
         <minus></minus>
         <ci>T</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <eq></eq>
        <ci>t</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ξ</ci>
        <apply>
         <times></times>
         <ci>i</ci>
         <ci>j</ci>
        </apply>
       </apply>
       <ci>t</ci>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <sum></sum>
        <apply>
         <minus></minus>
         <ci>T</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <eq></eq>
        <ci>t</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>γ</ci>
        <ci>i</ci>
       </apply>
       <ci>t</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{ij}^{*}=\frac{\sum^{T-1}_{t=1}\xi_{ij}(t)}{\sum^{T-1}_{t=1}\gamma_{i}(t)}
  </annotation>
 </semantics>
</math>

</li>
</ul>

<p>which is the expected number of transitions from state i to state j compared to the expected total number of transitions away from state i. To clarify, the number of transitions away from state i does not mean transitions to a different state j, but to any state including itself. This is equivalent to the number of times state i is observed in the sequence from t=1 to t=T-1.</p>
<ul>
<li>

<math display="inline" id="Baum–Welch_algorithm:54">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mi>b</mi>
     <mi>i</mi>
     <mo>*</mo>
    </msubsup>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>v</mi>
      <mi>k</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mstyle displaystyle="false">
      <msubsup>
       <mo largeop="true" symmetric="true">∑</mo>
       <mrow>
        <mi>t</mi>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <mi>T</mi>
      </msubsup>
     </mstyle>
     <mrow>
      <msub>
       <mn>1</mn>
       <mrow>
        <msub>
         <mi>y</mi>
         <mi>t</mi>
        </msub>
        <mo>=</mo>
        <msub>
         <mi>v</mi>
         <mi>k</mi>
        </msub>
       </mrow>
      </msub>
      <msub>
       <mi>γ</mi>
       <mi>i</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mrow>
     <mstyle displaystyle="false">
      <msubsup>
       <mo largeop="true" symmetric="true">∑</mo>
       <mrow>
        <mi>t</mi>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <mi>T</mi>
      </msubsup>
     </mstyle>
     <mrow>
      <msub>
       <mi>γ</mi>
       <mi>i</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <ci>i</ci>
      </apply>
      <times></times>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>v</ci>
      <ci>k</ci>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <sum></sum>
        <ci>T</ci>
       </apply>
       <apply>
        <eq></eq>
        <ci>t</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <cn type="integer">1</cn>
        <apply>
         <eq></eq>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>y</ci>
          <ci>t</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>v</ci>
          <ci>k</ci>
         </apply>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>γ</ci>
        <ci>i</ci>
       </apply>
       <ci>t</ci>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <sum></sum>
        <ci>T</ci>
       </apply>
       <apply>
        <eq></eq>
        <ci>t</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>γ</ci>
        <ci>i</ci>
       </apply>
       <ci>t</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b_{i}^{*}(v_{k})=\frac{\sum^{T}_{t=1}1_{y_{t}=v_{k}}\gamma_{i}(t)}{\sum^{T}_{t%
=1}\gamma_{i}(t)}
  </annotation>
 </semantics>
</math>

</li>
</ul>

<p>where 

<math display="inline" id="Baum–Welch_algorithm:55">
 <semantics>
  <mrow>
   <msub>
    <mn>1</mn>
    <mrow>
     <msub>
      <mi>y</mi>
      <mi>t</mi>
     </msub>
     <mo>=</mo>
     <msub>
      <mi>v</mi>
      <mi>k</mi>
     </msub>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo>{</mo>
    <mtable>
     <mtr>
      <mtd columnalign="left">
       <mrow>
        <mn>1</mn>
        <mo>,</mo>
       </mrow>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mtext>if</mtext>
         <msub>
          <mi>y</mi>
          <mi>t</mi>
         </msub>
        </mrow>
        <mo>=</mo>
        <msub>
         <mi>v</mi>
         <mi>k</mi>
        </msub>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="left">
       <mrow>
        <mn>0</mn>
        <mo>,</mo>
       </mrow>
      </mtd>
      <mtd columnalign="left">
       <mtext>otherwise</mtext>
      </mtd>
     </mtr>
    </mtable>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <cn type="integer">1</cn>
     <apply>
      <eq></eq>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <ci>t</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>v</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">cases</csymbol>
     <cn type="integer">1</cn>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <mtext>if</mtext>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <ci>t</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>v</ci>
       <ci>k</ci>
      </apply>
     </apply>
     <cn type="integer">0</cn>
     <mtext>otherwise</mtext>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1_{y_{t}=v_{k}}=\begin{cases}1,&\text{if }y_{t}=v_{k}\\
0,&\text{otherwise}\\
\end{cases}
  </annotation>
 </semantics>
</math>

 is an indicator function and 

<math display="inline" id="Baum–Welch_algorithm:56">
 <semantics>
  <mrow>
   <msubsup>
    <mi>b</mi>
    <mi>i</mi>
    <mo>*</mo>
   </msubsup>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>v</mi>
     <mi>k</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>b</ci>
      <ci>i</ci>
     </apply>
     <times></times>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>v</ci>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b_{i}^{*}(v_{k})
  </annotation>
 </semantics>
</math>

 is the expected number of times the output observations have been equal to 

<math display="inline" id="Baum–Welch_algorithm:57">
 <semantics>
  <msub>
   <mi>v</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>v</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v_{k}
  </annotation>
 </semantics>
</math>

 while in state 

<math display="inline" id="Baum–Welch_algorithm:58">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

 over the expected total number of times in state 

<math display="inline" id="Baum–Welch_algorithm:59">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

.<br/>
These steps are now repeated iteratively until a desired level of convergence.<br/>
<strong>Note:</strong> It is possible to over-fit a particular data set. That is 

<math display="inline" id="Baum–Welch_algorithm:60">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>Y</mi>
    <mo stretchy="false">|</mo>
    <msub>
     <mi>θ</mi>
     <mrow>
      <mi>f</mi>
      <mi>i</mi>
      <mi>n</mi>
      <mi>a</mi>
      <mi>l</mi>
     </mrow>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>></mo>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>Y</mi>
    <mo stretchy="false">|</mo>
    <msub>
     <mi>θ</mi>
     <mrow>
      <mi>t</mi>
      <mi>r</mi>
      <mi>u</mi>
      <mi>e</mi>
     </mrow>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">Y</csymbol>
     <ci>normal-|</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>θ</ci>
      <apply>
       <times></times>
       <ci>f</ci>
       <ci>i</ci>
       <ci>n</ci>
       <ci>a</ci>
       <ci>l</ci>
      </apply>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <gt></gt>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">Y</csymbol>
     <ci>normal-|</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>θ</ci>
      <apply>
       <times></times>
       <ci>t</ci>
       <ci>r</ci>
       <ci>u</ci>
       <ci>e</ci>
      </apply>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(Y|\theta_{final})>P(Y|\theta_{true})
  </annotation>
 </semantics>
</math>

. The algorithm also does <strong>not</strong> guarantee a global maximum.</p>
<h2 id="example">Example</h2>

<p>Suppose we have a chicken from which we collect eggs at noon everyday. Now whether or not the chicken has laid eggs for collection depends on some unknown factors that are hidden. We can however (for simplicity) assume that there are only two states that determine whether the chicken lays eggs. Now we don't know the state at the initial starting point, we don't know the transition probabilities between the two states and we don't know the probability that the chicken lays an egg given a particular state.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a><a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> To start we first guess the transition and emission matrices.<br/>
</p>
<center>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;"><table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>Transition</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>State 1</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>State 2</p></td>
</tr>
</tbody>
</table></td>
<td style="text-align: left;">
<p>|</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>Emission</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>State 1</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>State 2</p></td>
</tr>
</tbody>
</table></td>
<td style="text-align: left;">
<p>|</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>Initial</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>State 1</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>State 2</p></td>
</tr>
</tbody>
</table></td>
</tr>
</tbody>
</table>
</center>

<p><br/>
We then take set of observations (E = eggs, N = no eggs): NN, NN, NN, NN, NE, EE, EN, NN, NN<br/>
The next step is to estimate a new transition matrix.<br/>
</p>
<center>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>Observed sequence</p></th>
<th style="text-align: left;">
<p>Probability of sequence and state is S1 then S2</p></th>
<th style="text-align: left;">
<p>Highest Probability of observing that sequence</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>NN</p></td>
<td style="text-align: left;">
<p>0.024</p></td>
<td style="text-align: left;">
<p>0.3584 S2,S2</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>NN</p></td>
<td style="text-align: left;">
<p>0.024</p></td>
<td style="text-align: left;">
<p>0.3584 S2,S2</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>NN</p></td>
<td style="text-align: left;">
<p>0.024</p></td>
<td style="text-align: left;">
<p>0.3584 S2,S2</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>NN</p></td>
<td style="text-align: left;">
<p>0.024</p></td>
<td style="text-align: left;">
<p>0.3584 S2,S2</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>NE</p></td>
<td style="text-align: left;">
<p>0.006</p></td>
<td style="text-align: left;">
<p>0.1344 S2,S1</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>EE</p></td>
<td style="text-align: left;">
<p>0.014</p></td>
<td style="text-align: left;">
<p>0.0490 S1,S1</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>EN</p></td>
<td style="text-align: left;">
<p>0.056</p></td>
<td style="text-align: left;">
<p>0.0896 S2,S2</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>NN</p></td>
<td style="text-align: left;">
<p>0.024</p></td>
<td style="text-align: left;">
<p>0.3584 S2,S2</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>NN</p></td>
<td style="text-align: left;">
<p>0.024</p></td>
<td style="text-align: left;">
<p>0.3584 S2,S2</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Total</p></td>
<td style="text-align: left;">
<p>0.22</p></td>
<td style="text-align: left;">
<p>2.4234</p></td>
</tr>
</tbody>
</table>
</center>

<p><br/>
Thus the new estimate for the S1 to S2 transition is now 

<math display="inline" id="Baum–Welch_algorithm:61">
 <semantics>
  <mrow>
   <mfrac>
    <mn>0.22</mn>
    <mn>2.4234</mn>
   </mfrac>
   <mo>=</mo>
   <mn>0.0908</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <divide></divide>
     <cn type="float">0.22</cn>
     <cn type="float">2.4234</cn>
    </apply>
    <cn type="float">0.0908</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{0.22}{2.4234}=0.0908
  </annotation>
 </semantics>
</math>

 (referred to as "Pseudo probabilities" in the following tables). We then calculate the S2 to S1, S2 to S2 and S1 to S1 transition probabilities and normalize so they add to 1. This gives us the updated transition matrix:<br/>
</p>
<center>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;"><table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>Old Transition Matrix</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>State 1</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>State 2</p></td>
</tr>
</tbody>
</table></td>
<td style="text-align: left;">
<p>|</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>New Transition Matrix (Pseudo Probabilities)</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>State 1</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>State 2</p></td>
</tr>
</tbody>
</table></td>
<td style="text-align: left;">
<p>|</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>New Transition Matrix (After Normalization)</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>State 1</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>State 2</p></td>
</tr>
</tbody>
</table></td>
</tr>
</tbody>
</table>
</center>

<p>Next, we want to estimate a new emission matrix,<br/>
</p>
<center>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>Observed Sequence</p></th>
<th style="text-align: left;">
<p>Highest probability of observing that sequence<br/>
 if E is assumed to come from S1</p></th>
<th style="text-align: left;">
<p>Highest Probability of observing that sequence</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>NE</p></td>
<td style="text-align: left;">
<p>0.1344 S2,S1</p></td>
<td style="text-align: left;">
<p>0.1344 S2,S1</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>EE</p></td>
<td style="text-align: left;">
<p>0.0490 S1,S1</p></td>
<td style="text-align: left;">
<p>0.0490 S1,S1</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>EN</p></td>
<td style="text-align: left;">
<p>0.0560 S1,S2</p></td>
<td style="text-align: left;">
<p>0.0896 S2,S2</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Total</p></td>
<td style="text-align: left;">
<p>0.2394</p></td>
<td style="text-align: left;">
<p>0.2730</p></td>
</tr>
</tbody>
</table>
</center>

<p><br/>
The new estimate for the E coming from S1 emission is now 

<math display="inline" id="Baum–Welch_algorithm:62">
 <semantics>
  <mrow>
   <mfrac>
    <mn>0.2394</mn>
    <mn>0.2730</mn>
   </mfrac>
   <mo>=</mo>
   <mn>0.8769</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <divide></divide>
     <cn type="float">0.2394</cn>
     <cn type="float">0.2730</cn>
    </apply>
    <cn type="float">0.8769</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{0.2394}{0.2730}=0.8769
  </annotation>
 </semantics>
</math>

.<br/>
This allows us to calculate the emission matrix as described above in the algorithm, by adding up the probabilities for the respective observed sequences. We then repeat for if N came from S1 and for if N and E came from S2 and normalize.</p>
<center>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;"><table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>Old Emission Matrix</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>State 1</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>State 2</p></td>
</tr>
</tbody>
</table></td>
<td style="text-align: left;">
<p>|</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>New Emission Matrix (Estimates)</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>State 1</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>State 2</p></td>
</tr>
</tbody>
</table></td>
<td style="text-align: left;">
<p>|</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>New Emission Matrix (After Normalization)</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>State 1</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>State 2</p></td>
</tr>
</tbody>
</table></td>
</tr>
</tbody>
</table>
</center>

<p><br/>
To estimate the initial probabilities we assume all sequences start with the hidden state S1 and calculate the highest probability and then repeat for S2. Again we then normalize to give an updated initial vector.<br/>
Finally we repeat these steps until the resulting probabilities converge satisfactorily.</p>
<h2 id="applications">Applications</h2>
<h3 id="speech-recognition">Speech recognition</h3>

<p>Hidden Markov Models were first applied to speech recognition by <a href="James_K._Baker" title="wikilink">James K. Baker</a> in 1975.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> Continuous speech recognition occurs by the following steps, modeled by a HMM. Feature analysis is first undertaken on temporal and/or spectral features of the speech signal. This produces an observation vector. The feature is then compared to all sequences of the speech recognition units. These units could be <a class="uri" href="phonemes" title="wikilink">phonemes</a>, syllables, or whole-word units. A lexicon decoding system is applied to constrain the paths investigated, so only words in the system's lexicon (word dictionary) are investigated. Similar to the lexicon decoding, the system path is further constrained by the rules of grammar and syntax. Finally, semantic analysis is applied and the system outputs the recognized utterance. A limitation of many HMM applications to speech recognition is that the current state only depends on the state at the previous time-step, which is unrealistic for speech as dependencies are often several time-steps in duration.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> The Baum–Welch algorithm also has extensive applications in solving HMMs used in the field of speech synthesis.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a></p>
<h3 id="cryptanalysis">Cryptanalysis</h3>

<p>The Baum–Welch algorithm is often used to estimate the parameters of HMMs in deciphering hidden or noisy information and consequently is often used in <a class="uri" href="cryptanalysis" title="wikilink">cryptanalysis</a>. In data security an observer would like to extract information from a data stream without knowing all the parameters of the transmission. This can involve reverse engineering a <a href="Coding_theory" title="wikilink">channel encoder</a>.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> HMMs and as a consequence the Baum–Welch algorithm have also been used to identify spoken phrases in encrypted VoIP calls.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> In addition HMM cryptanalysis is an important tool for automated investigations of cache-timing data. It allows for the automatic discovery of critical algorithm state, for example key values.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a></p>
<h3 id="applications-in-bioinformatics">Applications in bioinformatics</h3>
<h4 id="finding-genes">Finding genes</h4>
<h5 id="prokaryotic">Prokaryotic</h5>

<p>The <a class="uri" href="GLIMMER" title="wikilink">GLIMMER</a> (Gene Locator and Interpolated Markov ModelER) software was an early <a href="locus_(genetics)" title="wikilink">gene-finding</a> program used for the identification of coding regions in <a class="uri" href="prokaryotic" title="wikilink">prokaryotic</a> DNA.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a><a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a> GLIMMER uses Interpolated Markov Models (IMMs) to identify the <a href="exon" title="wikilink">coding regions</a> and distinguish them from the <a href="introns" title="wikilink">noncoding DNA</a>. The latest release (GLIMMER3) has been shown to have increased <a href="specificity_(statistics)" title="wikilink">specificity</a> and accuracy compared with its predecessors with regard to predicting translation initiation sites, demonstrating an average 99% accuracy in locating 3' locations compared to confirmed genes in prokaryotes.<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a></p>
<h5 id="eukaryotic">Eukaryotic</h5>

<p>The <a class="uri" href="GENSCAN" title="wikilink">GENSCAN</a> webserver is a gene locator capable of analyzing <a class="uri" href="eukaryotic" title="wikilink">eukaryotic</a> sequences up to one million <a class="uri" href="base-pairs" title="wikilink">base-pairs</a> (1 Mbp) long.<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a> GENSCAN utilizes a general inhomogeneous, three periodic, fifth order Markov model of DNA coding regions. Additionally, this model accounts for differences in gene density and structure (such as intron lengths) that occur in different <a href="Isochore_(genetics)" title="wikilink">isochores</a>. While most integrated gene-finding software (at the time of GENSCANs release) assumed input sequences contained exactly one gene, GENSCAN solves a general case where partial, complete, or multiple genes (or even no gene at all) is present.<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a> GENSCAN was shown to exactly predict exon location with 90% accuracy with 80% specificity compared to an annotated database.<a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a></p>
<h4 id="copy-number-variation-detection">Copy-number variation detection</h4>

<p><a href="Copy-number_variation" title="wikilink">Copy-number variations</a> (CNVs) are an abundant form of genome structure variation in humans. A discrete-valued bivariate HMM (dbHMM) was used assigning chromosomal regions to seven distinct states: unaffected regions, deletions, duplications and four transition states. Solving this model using Baum-Welch demonstrated the ability to predict the location of CNV breakpoint to approximately 300 bp from <a href="DNA_microarray" title="wikilink">micro-array experiments</a>.<a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a> This magnitude of resolution enables more precise correlations between different CNVs and <a href="structural_variations" title="wikilink">across populations</a> than previously possible, allowing the study of CNV population frequencies. It also demonstrated a <a href="Mendelian_inheritance" title="wikilink">direct inheritance pattern for a particular CNV</a>.</p>
<h2 id="implementations">Implementations</h2>
<ul>
<li><a href="http://code.google.com/p/jhmm/">jhmm</a> or <a href="https://code.google.com/p/jahmm/">jahmm</a> implementation in <a href="Java_(programming_language)" title="wikilink">Java</a>.</li>
<li><a href="http://rgm2.lab.nig.ac.jp/RGM2/func.php?rd_id=RHmm:HMMFit">HMMFit</a> function in the <a href="http://cran.r-project.org/web/packages/RHmm/index.html">RHmm</a> package for <a href="R_(programming_language)" title="wikilink">R</a>.</li>
<li><a href="http://ghmm.org/">ghmm</a> C library with <a href="Python_(programming_language)" title="wikilink">Python</a> bindings that supports both discrete and continuous emissions.</li>
<li><a href="http://www.mathworks.com.au/help/stats/hmmtrain.html?searchHighlight=baum-welch">hmmtrain</a> in <a class="uri" href="MATLAB" title="wikilink">MATLAB</a></li>
<li><a href="http://accord-framework.net/docs/html/T_Accord_Statistics_Models_Markov_HiddenMarkovModel.htm">Accord.NET</a> in <a href="C_Sharp_(programming_language)" title="wikilink">C#</a></li>
</ul>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Viterbi_algorithm" title="wikilink">Viterbi algorithm</a></li>
<li><a href="Hidden_Markov_model" title="wikilink">Hidden Markov model</a></li>
<li><a href="EM_algorithm" title="wikilink">EM algorithm</a></li>
<li><a href="Maximum_Likelihood" title="wikilink">Maximum Likelihood</a></li>
<li><a href="Speech_Recognition" title="wikilink">Speech Recognition</a></li>
<li><a class="uri" href="Bioinformatics" title="wikilink">Bioinformatics</a></li>
<li><a class="uri" href="Cryptanalysis" title="wikilink">Cryptanalysis</a></li>
</ul>
<h2 id="references">References</h2>
<h2 id="external-links">External links</h2>
<ul>
<li>A comprehensive review of HMM methods and software in bioinformatics - <a href="http://bioinformatics.oxfordjournals.org/content/14/9/755.full.pdf">Profile Hidden Markov Models</a></li>
<li>Early HMM publications by Baum:
<ul>
<li>[<a class="uri" href="http://projecteuclid.org/DPubS?verb=Display&amp;version">http://projecteuclid.org/DPubS?verb=Display&amp;version;</a>;=1.0&amp;service;=UI&amp;handle;=euclid.aoms/1177697196&amp;page;=record A Maximization Technique Occurring in the Statistical Analysis of Probabilistic Functions of Markov Chains]</li>
<li>[<a class="uri" href="http://projecteuclid.org/DPubS?verb=Display&amp;version">http://projecteuclid.org/DPubS?verb=Display&amp;version;</a>;=1.0&amp;service;=UI&amp;handle;=euclid.bams/1183528841&amp;page;=record An inequality with applications to statistical estimation for probabilistic functions of Markov processes and to a model for ecology]</li>
<li>[<a class="uri" href="http://projecteuclid.org/DPubS?verb=Display&amp;version">http://projecteuclid.org/DPubS?verb=Display&amp;version;</a>;=1.0&amp;service;=UI&amp;handle;=euclid.aoms/1177699147&amp;page;=record Statistical Inference for Probabilistic Functions of Finite State Markov Chains]</li>
</ul></li>
<li>The Shannon Lecture by Welch, which speaks to how the algorithm can be implemented efficiently:
<ul>
<li><a href="http://www-rcf.usc.edu/~lototsky/MATH508/Baum-Welch.pdf">Hidden Markov Models and the Baum–Welch Algorithm</a>, IEEE Information Theory Society Newsletter, Dec. 2003.</li>
</ul></li>
<li>An alternative to the Baum–Welch algorithm, the Viterbi Path Counting algorithm:
<ul>
<li>R. I. A. Davis, B. C. Lovell, <a href="http://dl.acm.org/citation.cfm?id=1011682.1011688">"Comparing and evaluating HMM ensemble training algorithms using train and test and condition number criteria"</a>, Pattern Analysis and Applications, vol. 6, no. 4, pp. 327–336, 2003.</li>
</ul></li>
<li><a href="http://www.cs.jhu.edu/~jason/papers/#eisner-2002-tnlp">An Interactive Spreadsheet for Teaching the Forward-Backward Algorithm</a> (spreadsheet and article with step-by-step walkthrough)</li>
<li><a href="http://pandamatak.com/people/anand/771/html/node26.html">Formal derivation of the Baum–Welch algorithm</a></li>
<li><a href="http://www.kanungo.com/software/software.html#umdhmm">Implementation of the Baum–Welch algorithm</a></li>
</ul>

<p>"</p>

<p><a href="Category:Statistical_algorithms" title="wikilink">Category:Statistical algorithms</a> <a href="Category:Bioinformatics_algorithms" title="wikilink">Category:Bioinformatics algorithms</a> <a href="Category:Markov_models" title="wikilink">Category:Markov models</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
<li id="fn10"><a href="#fnref10">↩</a></li>
<li id="fn11"><a href="#fnref11">↩</a></li>
<li id="fn12"><a href="#fnref12">↩</a></li>
<li id="fn13"><a href="#fnref13">↩</a></li>
<li id="fn14"><a href="#fnref14">↩</a></li>
<li id="fn15"><a href="#fnref15">↩</a></li>
<li id="fn16"><a href="#fnref16">↩</a></li>
<li id="fn17"><a href="#fnref17">↩</a></li>
<li id="fn18"><a href="#fnref18">↩</a></li>
<li id="fn19"><a href="#fnref19">↩</a></li>
<li id="fn20"><a href="#fnref20">↩</a></li>
</ol>
</section>
</body>
</html>
