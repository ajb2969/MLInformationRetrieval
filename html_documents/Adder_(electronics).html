<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="829">Adder (electronics)</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Adder (electronics)</h1>
<hr/>

<p>In <a class="uri" href="electronics" title="wikilink">electronics</a>, an <strong>adder</strong> or <strong>summer</strong> is a <a href="digital_circuit" title="wikilink">digital circuit</a> that performs <a class="uri" href="addition" title="wikilink">addition</a> of numbers. In many <a href="computer" title="wikilink">computers</a> and other kinds of processors, adders are used not only in the <a href="arithmetic_logic_unit" title="wikilink">arithmetic logic units</a>, but also in other parts of the processor, where they are used to calculate addresses, table indices, <a href="increment_and_decrement_operators" title="wikilink">increment and decrement operators</a>, and similar operations.</p>

<p>Although adders can be constructed for many numerical representations, such as <a href="binary-coded_decimal" title="wikilink">binary-coded decimal</a> or <a class="uri" href="excess-3" title="wikilink">excess-3</a>, the most common adders operate on <a href="binary_numeral_system" title="wikilink">binary</a> numbers. In cases where <a href="two's_complement" title="wikilink">two's complement</a> or <a href="ones'_complement" title="wikilink">ones' complement</a> is being used to represent negative numbers, it is trivial to modify an adder into an <a class="uri" href="adder–subtractor" title="wikilink">adder–subtractor</a>. Other <a href="signed_number_representations" title="wikilink">signed number representations</a> require a more complex adder.</p>
<h2 id="half-adder">Half adder</h2>

<p> The <strong>half adder</strong> adds two single binary digits <em>A</em> and <em>B</em>. It has two outputs, sum (<em>S</em>) and carry (<em>C</em>). The carry signal represents an overflow into the next digit of a multi-digit addition. The value of the sum is . The simplest half-adder design, pictured on the right, incorporates an <a href="XOR_gate" title="wikilink">XOR gate</a> for <em>S</em> and an <a href="AND_gate" title="wikilink">AND gate</a> for <em>C</em>. With the addition of an OR gate to combine their carry outputs, two half adders can be combined to make a full adder.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> The half adder adds two input bits and generates a carry and sum, which are the two outputs of a half adder. The input <a href="Variable_(computer_science)" title="wikilink">variables</a> of a half adder are called the augend and addend bits. The output variables are the sum and carry. The <a href="truth_table" title="wikilink">truth table</a> for the half adder is:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>Inputs</p></th>
<th style="text-align: left;">
<p>Outputs</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p><em>A</em></p></td>
<td style="text-align: left;">
<p><em>B</em></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>0</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
</tr>
<tr class="even">
</tr>
</tbody>
</table>
<h2 id="full-adder">Full adder</h2>
<figure><b>(Figure)</b>
<figcaption>Schematic symbol for a 1-bit full adder with <em>C</em><sub>in</sub> and <em>C</em><sub>out</sub> drawn on sides of block to emphasize their use in a multi-bit adder</figcaption>
</figure>

<p>A <strong>full adder</strong> adds binary numbers and accounts for values carried in as well as out. A one-bit full adder adds three one-bit numbers, often written as <em>A</em>, <em>B</em>, and <em>C</em><sub>in</sub>; <em>A</em> and <em>B</em> are the operands, and <em>C</em><sub>in</sub> is a bit carried in from the previous less significant stage.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> The full adder is usually a component in a cascade of adders, which add 8, 16, 32, etc. bit binary numbers. The circuit produces a two-bit output, output carry and sum typically represented by the signals <em>C</em><sub>out</sub> and <em>S</em>, where 

<math display="inline" id="Adder_(electronics):0">
 <semantics>
  <mrow>
   <mi>sum</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mn>2</mn>
     <mo>×</mo>
     <msub>
      <mi>C</mi>
      <mrow>
       <mi>o</mi>
       <mi>u</mi>
       <mi>t</mi>
      </mrow>
     </msub>
    </mrow>
    <mo>+</mo>
    <mi>S</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>sum</ci>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>C</ci>
       <apply>
        <times></times>
        <ci>o</ci>
        <ci>u</ci>
        <ci>t</ci>
       </apply>
      </apply>
     </apply>
     <ci>S</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{sum}=2\times C_{out}+S
  </annotation>
 </semantics>
</math>

. The one-bit full adder's <a href="truth_table" title="wikilink">truth table</a> is:</p>
<figure><b>(Figure)</b>
<figcaption>Full-adder logic diagram</figcaption>
</figure>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>Inputs</p></th>
<th style="text-align: left;">
<p>Outputs</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p><em>A</em></p></td>
<td style="text-align: left;">
<p><em>B</em></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>0</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>0</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
</tr>
</tbody>
</table>

<p>A full adder can be implemented in many different ways such as with a custom <a class="uri" href="transistor" title="wikilink">transistor</a>-level circuit or composed of other gates. One example implementation is with 

<math display="inline" id="Adder_(electronics):1">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>=</mo>
   <mrow>
    <mi>A</mi>
    <mo>⊕</mo>
    <mi>B</mi>
    <mo>⊕</mo>
    <msub>
     <mi>C</mi>
     <mrow>
      <mi>i</mi>
      <mi>n</mi>
     </mrow>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>S</ci>
    <apply>
     <csymbol cd="latexml">direct-sum</csymbol>
     <ci>A</ci>
     <ci>B</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>C</ci>
      <apply>
       <times></times>
       <ci>i</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S=A\oplus B\oplus C_{in}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Adder_(electronics):2">
 <semantics>
  <mrow>
   <msub>
    <mi>C</mi>
    <mrow>
     <mi>o</mi>
     <mi>u</mi>
     <mi>t</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>A</mi>
      <mo>⋅</mo>
      <mi>B</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>C</mi>
       <mrow>
        <mi>i</mi>
        <mi>n</mi>
       </mrow>
      </msub>
      <mo>⋅</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>A</mi>
        <mo>⊕</mo>
        <mi>B</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <apply>
      <times></times>
      <ci>o</ci>
      <ci>u</ci>
      <ci>t</ci>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <ci>normal-⋅</ci>
      <ci>A</ci>
      <ci>B</ci>
     </apply>
     <apply>
      <ci>normal-⋅</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>C</ci>
       <apply>
        <times></times>
        <ci>i</ci>
        <ci>n</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="latexml">direct-sum</csymbol>
       <ci>A</ci>
       <ci>B</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{out}=(A\cdot B)+(C_{in}\cdot(A\oplus B))
  </annotation>
 </semantics>
</math>

.</p>

<p>In this implementation, the final <a href="OR_gate" title="wikilink">OR gate</a> before the carry-out output may be replaced by an <a href="XOR_gate" title="wikilink">XOR gate</a> without altering the resulting logic. Using only two types of gates is convenient if the circuit is being implemented using simple IC chips which contain only one gate type per chip.</p>

<p>A full adder can be constructed from two half adders by connecting <em>A</em> and <em>B</em> to the input of one half adder, connecting the sum from that to an input to the second adder, connecting <em>C<sub>i</sub></em> to the other input and OR the two carry outputs. The critical path of a full adder runs through both XOR-gates and ends at the sum bit 

<math display="inline" id="Adder_(electronics):3">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

. Assumed that an XOR-gate takes 3 delays to complete, the delay imposed by the critical path of a full adder is equal to</p>

<p>

<math display="block" id="Adder_(electronics):4">
 <semantics>
  <mrow>
   <msub>
    <mi>T</mi>
    <mrow>
     <mi>F</mi>
     <mi>A</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <mn>2</mn>
    <mo>⋅</mo>
    <msub>
     <mi>T</mi>
     <mrow>
      <mi>X</mi>
      <mi>O</mi>
      <mi>R</mi>
     </mrow>
    </msub>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mn>2</mn>
     <mo>⋅</mo>
     <mn>3</mn>
    </mrow>
    <mi>D</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mn>6</mn>
    <mi>D</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>T</ci>
      <apply>
       <times></times>
       <ci>F</ci>
       <ci>A</ci>
      </apply>
     </apply>
     <apply>
      <ci>normal-⋅</ci>
      <cn type="integer">2</cn>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>T</ci>
       <apply>
        <times></times>
        <ci>X</ci>
        <ci>O</ci>
        <ci>R</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <ci>normal-⋅</ci>
       <cn type="integer">2</cn>
       <cn type="integer">3</cn>
      </apply>
      <ci>D</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <cn type="integer">6</cn>
      <ci>D</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T_{FA}=2\cdot T_{XOR}=2\cdot 3D=6D
  </annotation>
 </semantics>
</math>

 The carry-block subcomponent consists of 2 gates and therefore has a delay of</p>

<p>

<math display="block" id="Adder_(electronics):5">
 <semantics>
  <mrow>
   <msub>
    <mi>T</mi>
    <mi>c</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mn>2</mn>
    <mi>D</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>T</ci>
     <ci>c</ci>
    </apply>
    <apply>
     <times></times>
     <cn type="integer">2</cn>
     <ci>D</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T_{c}=2D
  </annotation>
 </semantics>
</math>

</p>
<h2 id="more-complex-adders">More complex adders</h2>
<h3 id="ripple-carry-adder">Ripple-carry adder</h3>
<figure><b>(Figure)</b>
<figcaption>4-bit adder with logic gates shown</figcaption>
</figure>

<p>It is possible to create a logical circuit using multiple full adders to add <em>N</em>-bit numbers. Each full adder inputs a <em>C<sub>in</sub></em>, which is the <em>C<sub>out</sub></em> of the previous adder. This kind of adder is called a <em>ripple-carry adder</em>, since each carry bit "ripples" to the next full adder. Note that the first (and only the first) full adder may be replaced by a half adder (under the assumption that <em>C<sub>in</sub> = 0</em>).</p>

<p>The layout of a ripple-carry adder is simple, which allows for fast design time (Aahaaan); however, the ripple-carry adder is relatively slow, since each full adder must wait for the carry bit to be calculated from the previous full adder. The <a href="gate_delay" title="wikilink">gate delay</a> can easily be calculated by inspection of the full adder circuit. Each full adder requires three levels of logic. In a 32-bit ripple-carry adder, there are 32 full adders, so the critical path (worst case) delay is 2 (from input to carry in first adder) + 31 * 3 (for carry propagation in later adders) = 95 gate delays. The general equation for the worst-case delay for a <em>n</em>-bit carry-ripple adder is</p>

<p>

<math display="block" id="Adder_(electronics):6">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>T</mi>
     <mrow>
      <mi>C</mi>
      <mi>R</mi>
      <mi>A</mi>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>T</mi>
     <mrow>
      <mi>H</mi>
      <mi>A</mi>
     </mrow>
    </msub>
    <mo>+</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>⋅</mo>
     <msub>
      <mi>T</mi>
      <mi>c</mi>
     </msub>
    </mrow>
    <mo>+</mo>
    <msub>
     <mi>T</mi>
     <mi>s</mi>
    </msub>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>T</mi>
     <mrow>
      <mi>F</mi>
      <mi>A</mi>
     </mrow>
    </msub>
    <mo>+</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>⋅</mo>
     <msub>
      <mi>T</mi>
      <mi>c</mi>
     </msub>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mn>6</mn>
     <mi>D</mi>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>n</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>⋅</mo>
      <mn>2</mn>
     </mrow>
     <mi>D</mi>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>n</mi>
       <mo>+</mo>
       <mn>2</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>⋅</mo>
     <mn>2</mn>
    </mrow>
    <mi>D</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>T</ci>
       <apply>
        <times></times>
        <ci>C</ci>
        <ci>R</ci>
        <ci>A</ci>
       </apply>
      </apply>
      <ci>n</ci>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>T</ci>
       <apply>
        <times></times>
        <ci>H</ci>
        <ci>A</ci>
       </apply>
      </apply>
      <apply>
       <ci>normal-⋅</ci>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>T</ci>
        <ci>c</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>T</ci>
       <ci>s</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>T</ci>
       <apply>
        <times></times>
        <ci>F</ci>
        <ci>A</ci>
       </apply>
      </apply>
      <apply>
       <ci>normal-⋅</ci>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>T</ci>
        <ci>c</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <cn type="integer">6</cn>
       <ci>D</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <ci>normal-⋅</ci>
        <apply>
         <minus></minus>
         <ci>n</ci>
         <cn type="integer">1</cn>
        </apply>
        <cn type="integer">2</cn>
       </apply>
       <ci>D</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <ci>normal-⋅</ci>
       <apply>
        <plus></plus>
        <ci>n</ci>
        <cn type="integer">2</cn>
       </apply>
       <cn type="integer">2</cn>
      </apply>
      <ci>D</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T_{CRA}(n)=T_{HA}+(n-1)\cdot T_{c}+T_{s}=T_{FA}+(n-1)\cdot T_{c}=6D+(n-1)\cdot
2%
D=(n+2)\cdot 2D
  </annotation>
 </semantics>
</math>

 The delay from bit position 0 to the carry-out is a little different:</p>

<p>

<math display="block" id="Adder_(electronics):7">
 <semantics>
  <mrow>
   <msub>
    <mi>T</mi>
    <mrow>
     <mi>C</mi>
     <mi>R</mi>
     <msub>
      <mi>A</mi>
      <mrow>
       <mo stretchy="false">[</mo>
       <mn>0</mn>
       <mo>:</mo>
       <msub>
        <mi>c</mi>
        <mrow>
         <mi>o</mi>
         <mi>u</mi>
         <mi>t</mi>
        </mrow>
       </msub>
       <mo stretchy="false">]</mo>
      </mrow>
     </msub>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>T</mi>
     <mrow>
      <mi>H</mi>
      <mi>A</mi>
     </mrow>
    </msub>
    <mo>+</mo>
    <mrow>
     <mi>n</mi>
     <mo>⋅</mo>
     <msub>
      <mi>T</mi>
      <mi>c</mi>
     </msub>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mn>3</mn>
     <mi>D</mi>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mrow>
      <mi>n</mi>
      <mo>⋅</mo>
      <mn>2</mn>
     </mrow>
     <mi>D</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>T</ci>
      <apply>
       <times></times>
       <ci>C</ci>
       <ci>R</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>A</ci>
        <cerror>
         <csymbol cd="ambiguous">fragments</csymbol>
         <ci>normal-[</ci>
         <cn type="integer">0</cn>
         <ci>normal-:</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>c</ci>
          <apply>
           <times></times>
           <ci>o</ci>
           <ci>u</ci>
           <ci>t</ci>
          </apply>
         </apply>
         <ci>normal-]</ci>
        </cerror>
       </apply>
      </apply>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>T</ci>
       <apply>
        <times></times>
        <ci>H</ci>
        <ci>A</ci>
       </apply>
      </apply>
      <apply>
       <ci>normal-⋅</ci>
       <ci>n</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>T</ci>
        <ci>c</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <cn type="integer">3</cn>
       <ci>D</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <ci>normal-⋅</ci>
        <ci>n</ci>
        <cn type="integer">2</cn>
       </apply>
       <ci>D</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T_{CRA_{[0:c_{out}]}}=T_{HA}+n\cdot T_{c}=3D+n\cdot 2D
  </annotation>
 </semantics>
</math>

 The carry-in must travel through <em>n</em> carry-generator blocks to have an effect on the carry-out</p>

<p>

<math display="block" id="Adder_(electronics):8">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>T</mi>
     <mrow>
      <mi>C</mi>
      <mi>R</mi>
      <msub>
       <mi>A</mi>
       <mrow>
        <mo stretchy="false">[</mo>
        <msub>
         <mi>c</mi>
         <mn>0</mn>
        </msub>
        <mo>:</mo>
        <msub>
         <mi>c</mi>
         <mi>n</mi>
        </msub>
        <mo stretchy="false">]</mo>
       </mrow>
      </msub>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>n</mi>
    <mo>⋅</mo>
    <msub>
     <mi>T</mi>
     <mi>c</mi>
    </msub>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>n</mi>
     <mo>⋅</mo>
     <mn>2</mn>
    </mrow>
    <mi>D</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>T</ci>
       <apply>
        <times></times>
        <ci>C</ci>
        <ci>R</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>A</ci>
         <cerror>
          <csymbol cd="ambiguous">fragments</csymbol>
          <ci>normal-[</ci>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>c</ci>
           <cn type="integer">0</cn>
          </apply>
          <ci>normal-:</ci>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>c</ci>
           <ci>n</ci>
          </apply>
          <ci>normal-]</ci>
         </cerror>
        </apply>
       </apply>
      </apply>
      <ci>n</ci>
     </apply>
     <apply>
      <ci>normal-⋅</ci>
      <ci>n</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>T</ci>
       <ci>c</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <ci>normal-⋅</ci>
       <ci>n</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>D</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T_{CRA_{[c_{0}:c_{n}]}}(n)=n\cdot T_{c}=n\cdot 2D
  </annotation>
 </semantics>
</math>

 A design with alternating carry polarities and optimized <a class="uri" href="AND-OR-Invert" title="wikilink">AND-OR-Invert</a> gates can be about twice as fast.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>

<p>To reduce the computation time, engineers devised faster ways to add two binary numbers by using <a href="carry-lookahead_adder" title="wikilink">carry-lookahead adders</a>. They work by creating two signals (<em>P</em> and <em>G</em>) for each bit position, based on whether a carry is propagated through from a less significant bit position (at least one input is a '1'), generated in that bit position (both inputs are '1'), or killed in that bit position (both inputs are '0'). In most cases, <em>P</em> is simply the sum output of a half adder and <em>G</em> is the carry output of the same adder. After <em>P</em> and <em>G</em> are generated the carries for every bit position are created. Some advanced carry-lookahead architectures are the <a href="Manchester_carry_chain" title="wikilink">Manchester carry chain</a>, <a href="Brent–Kung_adder" title="wikilink">Brent–Kung adder</a>, and the <a href="Kogge–Stone_adder" title="wikilink">Kogge–Stone adder</a>.</p>

<p>Some other multi-bit adder architectures break the adder into blocks. It is possible to vary the length of these blocks based on the <a href="propagation_delay" title="wikilink">propagation delay</a> of the circuits to optimize computation time. These block based adders include the <a href="carry-skip_adder" title="wikilink">carry-skip (or carry-bypass) adder</a> which will determine <em>P</em> and <em>G</em> values for each block rather than each bit, and the <a href="carry_select_adder" title="wikilink">carry select adder</a> which pre-generates the sum and carry values for either possible carry input (0 or 1) to the block, using multiplexers to select the appropriate result <em>when</em> the carry bit is known.</p>

<p>Other adder designs include the <a href="carry-select_adder" title="wikilink">carry-select adder</a>, <a href="conditional_sum_adder" title="wikilink">conditional sum adder</a>, <a href="carry-skip_adder" title="wikilink">carry-skip adder</a>, and <a href="carry-complete_adder" title="wikilink">carry-complete adder</a>.</p>
<h3 id="lookahead-carry-unit">Lookahead carry unit</h3>
<figure><b>(Figure)</b>
<figcaption>A 64-bit adder</figcaption>
</figure>

<p>By combining multiple carry lookahead adders even larger adders can be created. This can be used at multiple levels to make even larger adders. For example, the following adder is a 64-bit adder that uses four 16-bit CLAs with two levels of LCUs.</p>
<h3 id="carry-save-adders">Carry-save adders</h3>

<p>If an adding circuit is to compute the sum of three or more numbers it can be advantageous to not propagate the carry result. Instead, three input adders are used, generating two results: a sum and a carry. The sum and the carry may be fed into two inputs of the subsequent 3-number adder without having to wait for propagation of a carry signal. After all stages of addition, however, a conventional adder (such as the ripple carry or the lookahead) must be used to combine the final sum and carry results.</p>
<h2 id="compressors">3:2 compressors</h2>

<p>We can view a full adder as a <em>3:2 lossy compressor</em>: it sums three one-bit inputs, and returns the result as a single two-bit number; that is, it maps 8 input values to 4 output values. Thus, for example, a binary input of <em>101</em> results in an output of <em>1+0+1=10</em> (decimal number '2'). The carry-out represents bit one of the result, while the sum represents bit zero. Likewise, a half adder can be used as a <em>2:2 lossy compressor</em>, compressing four possible inputs into three possible outputs. </p>

<p>Such compressors can be used to speed up the summation of three or more addends. If the addends are exactly three, the layout is known as the <a href="carry-save_adder" title="wikilink">carry-save adder</a>. If the addends are four or more, more than one layer of compressors is necessary and there are various possible design for the circuit: the most common are <a href="Dadda_tree" title="wikilink">Dadda</a> and <a href="Wallace_tree" title="wikilink">Wallace trees</a>. This kind of circuit is most notably used in multipliers, which is why these circuits are also known as Dadda and Wallace multipliers.</p>
<h2 id="references">References</h2>
<references>
</references>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://conceptselectronics.com/binary-arithmetic/adder/calculator/">Binary adder with visual results</a>, A tool which visually explains how to add two binary numbers submitted by user. Helpful for beginners.</li>
<li><a href="http://www.aoki.ecei.tohoku.ac.jp/arith/mg/algorithm.html">Hardware algorithms for arithmetic modules</a>, includes description of several adder layouts with figures.</li>
<li><a href="http://dev.code.ultimater.net/electronics/8-bit-full-adder-and-subtractor/">8-bit Full Adder and Subtractor</a>, a demonstration of an interactive Full Adder built in JavaScript solely for learning purposes.</li>
<li><a href="http://teahlab.com/Full_Adder/">Interactive Full Adder Simulation</a>, Interactive Full Adder circuit constructed with Teahlab's online circuit simulator.</li>
<li><a href="http://teahlab.com/Half_Adder/">Interactive Half Adder Simulation</a>, Half Adder circuit built with Teahlab's circuit simulator.</li>
<li><a href="http://www.edaplayground.com/s/example/368">4-bit Full Adder Simulation</a> built in Verilog, and the accompanying [<a class="uri" href="http://www.youtube.com/watch?v=bL3ihMA8_Gs&amp;hd">http://www.youtube.com/watch?v=bL3ihMA8_Gs&amp;hd;</a>;=1 Ripple Carry Full Adder Video Tutorial]</li>
</ul>

<p>"</p>

<p><a href="Category:Computer_arithmetic" title="wikilink">Category:Computer arithmetic</a> <a href="Category:Adders_(electronics)" title="wikilink"> </a> <a href="Category:Binary_logic" title="wikilink">Category:Binary logic</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2">M. Morris Mano, <em>Digital Logic and Computer Design</em>, Prentice-Hall 1979, 0-13-214510-3 pp.119-123<a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
</ol>
</section>
</body>
</html>
