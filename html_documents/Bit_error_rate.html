<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1252">Bit error rate</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Bit error rate</h1>
<hr/>

<p>In <a href="digital_transmission" title="wikilink">digital transmission</a>, the number of <strong>bit errors</strong> is the number of received <a href="bit" title="wikilink">bits</a> of a <a href="data_stream" title="wikilink">data stream</a> over a <a href="communication_channel" title="wikilink">communication channel</a> that have been altered due to <a href="noise_(telecommunications)" title="wikilink">noise</a>, <a href="interference_(communication)" title="wikilink">interference</a>, <a class="uri" href="distortion" title="wikilink">distortion</a> or <a href="bit_synchronization" title="wikilink">bit synchronization</a> errors.</p>

<p>The <strong>bit error rate</strong> (<strong>BER</strong>) is the number of bit errors per unit time. The <strong>bit error ratio</strong> (also <strong>BER</strong>) is the number of bit errors divided by the total number of transferred bits during a studied time interval. BER is a unitless performance measure, often expressed as a <a class="uri" href="percentage" title="wikilink">percentage</a>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>

<p>The <strong>bit error probability</strong> <em>p<sub>e</sub></em> is the <a href="expectation_value" title="wikilink">expectation value</a> of the bit error ratio. The bit error ratio can be considered as an approximate estimate of the bit error probability. This estimate is accurate for a long time interval and a high number of bit errors.</p>
<h2 id="example">Example</h2>

<p>As an example, assume this transmitted bit sequence:</p>

<p>0 1 1 0 0 0 1 0 1 1</p>

<p>and the following received bit sequence:</p>

<p>0 <u>0</u> 1 0 <u>1</u> 0 1 0 <u>0</u> 1,</p>

<p>The number of bit errors (the underlined bits) is, in this case, 3. The BER is 3 incorrect bits divided by 10 transferred bits, resulting in a BER of 0.3 or 30%.</p>
<h2 id="packet-error-ratio">Packet error ratio</h2>

<p>The <strong>packet error ratio</strong> (PER) is the number of incorrectly received <a href="network_packet" title="wikilink">data packets</a> divided by the total number of received packets. A packet is declared incorrect if at least one bit is erroneous. The expectation value of the PER is denoted <strong>packet error probability</strong> <em>p<sub>p</sub></em>, which for a data packet length of <em>N</em> bits can be expressed as</p>

<p>

<math display="block" id="Bit_error_rate:0">
 <semantics>
  <mrow>
   <msub>
    <mi>p</mi>
    <mi>p</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mo>-</mo>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mn>1</mn>
       <mo>-</mo>
       <msub>
        <mi>p</mi>
        <mi>e</mi>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>N</mi>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>p</ci>
     <ci>p</ci>
    </apply>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>p</ci>
        <ci>e</ci>
       </apply>
      </apply>
      <ci>N</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{p}=1-(1-p_{e})^{N}
  </annotation>
 </semantics>
</math>

,</p>

<p>assuming that the bit errors are independent of each other. For small bit error probabilities, this is approximately</p>

<p>

<math display="block" id="Bit_error_rate:1">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>p</mi>
     <mi>p</mi>
    </msub>
    <mo>≈</mo>
    <mrow>
     <msub>
      <mi>p</mi>
      <mi>e</mi>
     </msub>
     <mi>N</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>p</ci>
     <ci>p</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>p</ci>
      <ci>e</ci>
     </apply>
     <ci>N</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{p}\approx p_{e}N.
  </annotation>
 </semantics>
</math>

</p>

<p>Similar measurements can be carried out for the transmission of <a href="frame_(networking)" title="wikilink">frames</a>, <a href="block_(data_storage)" title="wikilink">blocks</a>, or <a href="symbol_(data)" title="wikilink">symbols</a>.</p>
<h2 id="factors-affecting-the-ber">Factors affecting the BER</h2>

<p>In a communication system, the receiver side BER may be affected by transmission channel <a href="noise_(telecommunications)" title="wikilink">noise</a>, <a href="interference_(communication)" title="wikilink">interference</a>, <a class="uri" href="distortion" title="wikilink">distortion</a>, <a href="bit_synchronization" title="wikilink">bit synchronization</a> problems, <a class="uri" href="attenuation" title="wikilink">attenuation</a>, wireless <a href="Multipath_propagation" title="wikilink">multipath</a> <a class="uri" href="fading" title="wikilink">fading</a>, etc.</p>

<p>The BER may be improved by choosing a strong signal strength (unless this causes cross-talk and more bit errors), by choosing a slow and robust <a class="uri" href="modulation" title="wikilink">modulation</a> scheme or <a href="line_coding" title="wikilink">line coding</a> scheme, and by applying <a href="channel_coding" title="wikilink">channel coding</a> schemes such as redundant <a href="forward_error_correction" title="wikilink">forward error correction</a> codes.</p>

<p>The <em>transmission BER</em> is the number of detected bits that are incorrect before error correction, divided by the total number of transferred bits (including redundant error codes). The <em>information BER</em>, approximately equal to the <strong>decoding error probability</strong>, is the number of decoded bits that remain incorrect after the error correction, divided by the total number of decoded bits (the useful information). Normally the transmission BER is larger than the information BER. The information BER is affected by the strength of the forward error correction code.</p>
<h2 id="analysis-of-the-ber">Analysis of the BER</h2>

<p>The BER may be evaluated using stochastic (<a href="Monte_Carlo_method" title="wikilink">Monte Carlo</a>) computer simulations. If a simple transmission <a href="channel_model" title="wikilink">channel model</a> and <a href="traffic_generation_model" title="wikilink">data source</a> model is assumed, the BER may also be calculated analytically. An example of such a data source model is the <a href="Bernoulli_distribution" title="wikilink">Bernoulli</a> source.</p>

<p>Examples of simple channel models used in <a href="information_theory" title="wikilink">information theory</a> are:</p>
<ul>
<li><a href="Binary_symmetric_channel" title="wikilink">Binary symmetric channel</a> (used in analysis of decoding error probability in case of <a href="error_burst" title="wikilink">non-bursty bit errors</a> on the transmission channel)</li>
<li><a href="Additive_white_gaussian_noise" title="wikilink">Additive white gaussian noise</a> (AWGN) channel without fading.</li>
</ul>

<p>A worst-case scenario is a completely random channel, where noise totally dominates over the useful signal. This results in a transmission BER of 50% (provided that a <a href="Bernoulli_distribution" title="wikilink">Bernoulli</a> binary data source and a binary symmetrical channel are assumed, see below).</p>

<p> </p>

<p>In a noisy channel, the BER is often expressed as a function of the normalized <a href="carrier-to-noise_ratio" title="wikilink">carrier-to-noise ratio</a> measure denoted <a class="uri" href="Eb/N0" title="wikilink">Eb/N0</a>, (energy per bit to noise power spectral density ratio), or <a class="uri" href="Es/N0" title="wikilink">Es/N0</a> (energy per modulation symbol to noise spectral density).</p>

<p>For example, in the case of <a class="uri" href="QPSK" title="wikilink">QPSK</a> modulation and AWGN channel, the BER as function of the Eb/N0 is given by: 

<math display="inline" id="Bit_error_rate:2">
 <semantics>
  <mrow>
   <mo>BER</mo>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mn>2</mn>
    </mfrac>
    <mrow>
     <mo>erfc</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <msqrt>
       <mrow>
        <msub>
         <mi>E</mi>
         <mi>b</mi>
        </msub>
        <mo>/</mo>
        <msub>
         <mi>N</mi>
         <mn>0</mn>
        </msub>
       </mrow>
      </msqrt>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>BER</ci>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <ci>erfc</ci>
      <apply>
       <root></root>
       <apply>
        <divide></divide>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>E</ci>
         <ci>b</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>N</ci>
         <cn type="integer">0</cn>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{BER}=\frac{1}{2}\operatorname{erfc}(\sqrt{E_{b}/N_{0}})
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>

<p>People usually plot the BER curves to describe the performance of a digital communication system. In optical communication, BER(dB) vs. Received Power(dBm) is usually used; while in wireless communication, BER(dB) vs. SNR(dB) is used.</p>

<p>Measuring the bit error ratio helps people choose the appropriate <a href="forward_error_correction" title="wikilink">forward error correction</a> codes. Since most such codes correct only bit-flips, but not bit-insertions or bit-deletions, the <a href="Hamming_distance" title="wikilink">Hamming distance</a> metric is the appropriate way to measure the number of bit errors. Many FEC coders also continuously measure the current BER.</p>

<p>A more general way of measuring the number of bit errors is the <a href="Levenshtein_distance" title="wikilink">Levenshtein distance</a>. The Levenshtein distance measurement is more appropriate for measuring raw channel performance before <a href="frame_synchronization" title="wikilink">frame synchronization</a>, and when using error correction codes designed to correct bit-insertions and bit-deletions, such as Marker Codes and Watermark Codes.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>
<h2 id="mathematical-draft">Mathematical draft</h2>

<p>The BER is the likelihood of a bit misinterpretation due to electrical noise 

<math display="inline" id="Bit_error_rate:3">
 <semantics>
  <mrow>
   <mi>w</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>w</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w(t)
  </annotation>
 </semantics>
</math>

. Considering a bipolar NRZ transmission, we have</p>

<p>

<math display="inline" id="Bit_error_rate:4">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>A</mi>
    <mo>+</mo>
    <mrow>
     <mi>w</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>t</ci>
    </apply>
    <apply>
     <plus></plus>
     <ci>A</ci>
     <apply>
      <times></times>
      <ci>w</ci>
      <ci>t</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1}(t)=A+w(t)
  </annotation>
 </semantics>
</math>

 for a "1" and 

<math display="inline" id="Bit_error_rate:5">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>x</mi>
     <mn>0</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo>-</mo>
     <mi>A</mi>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>w</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">0</cn>
     </apply>
     <ci>t</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <minus></minus>
      <ci>A</ci>
     </apply>
     <apply>
      <times></times>
      <ci>w</ci>
      <ci>t</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{0}(t)=-A+w(t)
  </annotation>
 </semantics>
</math>

 for a "0". Each of 

<math display="inline" id="Bit_error_rate:6">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mn>1</mn>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1}(t)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Bit_error_rate:7">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mn>0</mn>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">0</cn>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{0}(t)
  </annotation>
 </semantics>
</math>

 has a period of 

<math display="inline" id="Bit_error_rate:8">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

.</p>

<p>Knowing that the noise has a bilateral spectral density 

<math display="inline" id="Bit_error_rate:9">
 <semantics>
  <mfrac>
   <msub>
    <mi>N</mi>
    <mn>0</mn>
   </msub>
   <mn>2</mn>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>N</ci>
     <cn type="integer">0</cn>
    </apply>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{N_{0}}{2}
  </annotation>
 </semantics>
</math>

,</p>

<p>

<math display="inline" id="Bit_error_rate:10">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mn>1</mn>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1}(t)
  </annotation>
 </semantics>
</math>

 is 

<math display="inline" id="Bit_error_rate:11">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">𝒩</mi>
   <mrow>
    <mo>(</mo>
    <mi>A</mi>
    <mo>,</mo>
    <mfrac>
     <msub>
      <mi>N</mi>
      <mn>0</mn>
     </msub>
     <mrow>
      <mn>2</mn>
      <mi>T</mi>
     </mrow>
    </mfrac>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>𝒩</ci>
    <interval closure="open">
     <ci>A</ci>
     <apply>
      <divide></divide>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>N</ci>
       <cn type="integer">0</cn>
      </apply>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>T</ci>
      </apply>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{N}\left(A,\frac{N_{0}}{2T}\right)
  </annotation>
 </semantics>
</math>

</p>

<p>and 

<math display="inline" id="Bit_error_rate:12">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mn>0</mn>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">0</cn>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{0}(t)
  </annotation>
 </semantics>
</math>

 is 

<math display="inline" id="Bit_error_rate:13">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">𝒩</mi>
   <mrow>
    <mo>(</mo>
    <mrow>
     <mo>-</mo>
     <mi>A</mi>
    </mrow>
    <mo>,</mo>
    <mfrac>
     <msub>
      <mi>N</mi>
      <mn>0</mn>
     </msub>
     <mrow>
      <mn>2</mn>
      <mi>T</mi>
     </mrow>
    </mfrac>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>𝒩</ci>
    <interval closure="open">
     <apply>
      <minus></minus>
      <ci>A</ci>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>N</ci>
       <cn type="integer">0</cn>
      </apply>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>T</ci>
      </apply>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{N}\left(-A,\frac{N_{0}}{2T}\right)
  </annotation>
 </semantics>
</math>

.</p>

<p>Returning to BER, we have the likelihood of a bit misinterpretation 

<math display="inline" id="Bit_error_rate:14">
 <semantics>
  <mrow>
   <msub>
    <mi>p</mi>
    <mi>e</mi>
   </msub>
   <mo>=</mo>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>0</mn>
    <mo stretchy="false">|</mo>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
   </mrow>
   <msub>
    <mi>p</mi>
    <mn>1</mn>
   </msub>
   <mo>+</mo>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>1</mn>
    <mo stretchy="false">|</mo>
    <mn>0</mn>
    <mo stretchy="false">)</mo>
   </mrow>
   <msub>
    <mi>p</mi>
    <mn>0</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>p</ci>
     <ci>e</ci>
    </apply>
    <eq></eq>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cn type="integer">0</cn>
     <ci>normal-|</ci>
     <cn type="integer">1</cn>
     <ci>normal-)</ci>
    </cerror>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>p</ci>
     <cn type="integer">1</cn>
    </apply>
    <plus></plus>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cn type="integer">1</cn>
     <ci>normal-|</ci>
     <cn type="integer">0</cn>
     <ci>normal-)</ci>
    </cerror>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>p</ci>
     <cn type="integer">0</cn>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{e}=p(0|1)p_{1}+p(1|0)p_{0}
  </annotation>
 </semantics>
</math>

.</p>

<p>

<math display="inline" id="Bit_error_rate:15">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>1</mn>
    <mo stretchy="false">|</mo>
    <mn>0</mn>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mpadded width="+1.7pt">
    <mn>0.5</mn>
   </mpadded>
   <mo>erfc</mo>
   <mrow>
    <mo>(</mo>
    <mfrac>
     <mrow>
      <mi>A</mi>
      <mo>+</mo>
      <mi>λ</mi>
     </mrow>
     <msqrt>
      <mrow>
       <msub>
        <mi>N</mi>
        <mi>o</mi>
       </msub>
       <mo>/</mo>
       <mi>T</mi>
      </mrow>
     </msqrt>
    </mfrac>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cn type="integer">1</cn>
     <ci>normal-|</ci>
     <cn type="integer">0</cn>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <cn type="float">0.5</cn>
    <ci>erfc</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <divide></divide>
      <apply>
       <plus></plus>
       <ci>A</ci>
       <ci>λ</ci>
      </apply>
      <apply>
       <root></root>
       <apply>
        <divide></divide>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>N</ci>
         <ci>o</ci>
        </apply>
        <ci>T</ci>
       </apply>
      </apply>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(1|0)=0.5\,\operatorname{erfc}\left(\frac{A+\lambda}{\sqrt{N_{o}/T}}\right)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Bit_error_rate:16">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>0</mn>
    <mo stretchy="false">|</mo>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mpadded width="+1.7pt">
    <mn>0.5</mn>
   </mpadded>
   <mo>erfc</mo>
   <mrow>
    <mo>(</mo>
    <mfrac>
     <mrow>
      <mi>A</mi>
      <mo>-</mo>
      <mi>λ</mi>
     </mrow>
     <msqrt>
      <mrow>
       <msub>
        <mi>N</mi>
        <mi>o</mi>
       </msub>
       <mo>/</mo>
       <mi>T</mi>
      </mrow>
     </msqrt>
    </mfrac>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cn type="integer">0</cn>
     <ci>normal-|</ci>
     <cn type="integer">1</cn>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <cn type="float">0.5</cn>
    <ci>erfc</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <divide></divide>
      <apply>
       <minus></minus>
       <ci>A</ci>
       <ci>λ</ci>
      </apply>
      <apply>
       <root></root>
       <apply>
        <divide></divide>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>N</ci>
         <ci>o</ci>
        </apply>
        <ci>T</ci>
       </apply>
      </apply>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(0|1)=0.5\,\operatorname{erfc}\left(\frac{A-\lambda}{\sqrt{N_{o}/T}}\right)
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Bit_error_rate:17">
 <semantics>
  <mi>λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda
  </annotation>
 </semantics>
</math>

 is the threshold of decision, set to 0 when 

<math display="inline" id="Bit_error_rate:18">
 <semantics>
  <mrow>
   <msub>
    <mi>p</mi>
    <mn>1</mn>
   </msub>
   <mo>=</mo>
   <msub>
    <mi>p</mi>
    <mn>0</mn>
   </msub>
   <mo>=</mo>
   <mn>0.5</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>p</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>p</ci>
      <cn type="integer">0</cn>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="float">0.5</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{1}=p_{0}=0.5
  </annotation>
 </semantics>
</math>

.</p>

<p>We can use the average energy of the signal 

<math display="inline" id="Bit_error_rate:19">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>A</mi>
     <mn>2</mn>
    </msup>
    <mi>T</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>E</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>A</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>T</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E=A^{2}T
  </annotation>
 </semantics>
</math>

 to find the final expression :</p>

<p>

<math display="inline" id="Bit_error_rate:20">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>p</mi>
     <mi>e</mi>
    </msub>
    <mo>=</mo>
    <mrow>
     <mpadded width="+1.7pt">
      <mn>0.5</mn>
     </mpadded>
     <mrow>
      <mo>erfc</mo>
      <mrow>
       <mo>(</mo>
       <msqrt>
        <mfrac>
         <mi>E</mi>
         <msub>
          <mi>N</mi>
          <mi>o</mi>
         </msub>
        </mfrac>
       </msqrt>
       <mo>)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>p</ci>
     <ci>e</ci>
    </apply>
    <apply>
     <times></times>
     <cn type="float">0.5</cn>
     <apply>
      <ci>erfc</ci>
      <apply>
       <root></root>
       <apply>
        <divide></divide>
        <ci>E</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>N</ci>
         <ci>o</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{e}=0.5\,\operatorname{erfc}\left(\sqrt{\frac{E}{N_{o}}}\right).
  </annotation>
 </semantics>
</math>

 ±§</p>
<h2 id="bit-error-rate-test">Bit error rate test</h2>

<p><strong>BERT</strong> or <strong>bit error rate test</strong> is a testing method for <a href="Digital_electronics" title="wikilink">digital communication circuits</a> that uses predetermined stress patterns consisting of a sequence of logical ones and zeros generated by a test pattern generator.</p>

<p>A BERT typically consists of a test pattern generator and a receiver that can be set to the same pattern. They can be used in pairs, with one at either end of a transmission link, or singularly at one end with a <a class="uri" href="loopback" title="wikilink">loopback</a> at the remote end. BERTs are typically stand-alone specialised instruments, but can be <a href="personal_computer" title="wikilink">personal computer</a>–based. In use, the number of errors, if any, are counted and presented as a ratio such as 1 in 1,000,000, or 1 in 1e06.</p>
<h3 id="common-types-of-bert-stress-patterns">Common types of BERT stress patterns</h3>
<ul>
<li><strong>PRBS</strong> (<a href="pseudorandom_binary_sequence" title="wikilink">pseudorandom binary sequence</a>) – A pseudorandom binary sequencer of N Bits. These pattern sequences are used to measure <a class="uri" href="jitter" title="wikilink">jitter</a> and eye mask of TX-Data in electrical and optical data links.</li>
<li><strong>QRSS</strong> (quasi random signal source) – A pseudorandom binary sequencer which generates every combination of a 20-bit word, repeats every 1,048,575 words, and suppresses consecutive zeros to no more than 14. It contains high-density sequences, low-density sequences, and sequences that change from low to high and vice versa. This pattern is also the standard pattern used to measure jitter.</li>
<li><strong>3 in 24</strong> – Pattern contains the longest string of consecutive zeros (15) with the lowest ones density (12.5%). This pattern simultaneously stresses minimum ones density and the maximum number of consecutive zeros. The <a href="D4_framing_standard" title="wikilink">D4</a> frame format of 3 in 24 may cause a D4 <a href="Remote_alarm_indication" title="wikilink">yellow alarm</a> for frame circuits depending on the alignment of one bits to a frame.</li>
<li><strong>1:7</strong> – Also referred to as <em>1 in 8</em>. It has only a single one in an eight-bit repeating sequence. This pattern stresses the minimum ones density of 12.5% and should be used when testing facilities set for <a class="uri" href="B8ZS" title="wikilink">B8ZS</a> coding as the 3 in 24 pattern increases to 29.5% when converted to B8ZS.</li>
<li><strong>Min/max</strong> – Pattern rapid sequence changes from low density to high density. Most useful when stressing the repeater’s <a href="Automatic_Line_Build_Out" title="wikilink">ALBO</a> feature.</li>
<li><strong>All ones (or mark)</strong> – A pattern composed of ones only. This pattern causes the repeater to consume the maximum amount of power. If DC to the repeater is regulated properly, the repeater will have no trouble transmitting the long ones sequence. This pattern should be used when measuring span power regulation. An unframed all ones pattern is used to indicate an <a href="Alarm_indication_signal" title="wikilink">AIS</a> (also known as a <em>blue alarm</em>).</li>
<li><strong>All zeros</strong> – A pattern composed of zeros only. It is effective in finding equipment misoptioned for <a href="Alternate_Mark_Inversion" title="wikilink">AMI</a>, such as fiber/radio multiplex low-speed inputs.</li>
<li><strong>Alternating 0s and 1s</strong> - A pattern composed of alternating ones and zeroes.</li>
<li><strong>2 in 8</strong> – Pattern contains a maximum of four consecutive zeros. It will not invoke a B8ZS sequence because eight consecutive zeros are required to cause a B8ZS substitution. The pattern is effective in finding equipment misoptioned for B8ZS.</li>
<li><strong>Bridgetap</strong> - <a href="Bridge_tap" title="wikilink">Bridge taps</a> within a span can be detected by employing a number of test patterns with a variety of ones and zeros densities. This test generates 21 test patterns and runs for 15 minutes. If a signal error occurs, the span may have one or more bridge taps. This pattern is only effective for T1 spans that transmit the signal raw. Modulation used in <a class="uri" href="HDSL" title="wikilink">HDSL</a> spans negates the bridgetap patterns' ability to uncover bridge taps.</li>
<li><strong>Multipat</strong> - This test generates five commonly used test patterns to allow <a href="Digital_Signal_1" title="wikilink">DS1</a> span testing without having to select each test pattern individually. Patterns are: all ones, 1:7, 2 in 8, 3 in 24, and QRSS.</li>
<li><strong>T1-DALY</strong> and <strong>55 OCTET</strong> - Each of these patterns contain fifty-five (55), eight bit octets of data in a sequence that changes rapidly between low and high density. These patterns are used primarily to stress the ALBO and equalizer circuitry but they will also stress timing recovery. 55 OCTET has fifteen (15) consecutive zeroes and can only be used unframed without violating one's density requirements. For framed signals, the T1-DALY pattern should be used. Both patterns will force a B8ZS code in circuits optioned for B8ZS.</li>
</ul>
<h2 id="bit-error-rate-tester">Bit error rate tester</h2>

<p>A bit error rate tester (BERT), also known as a <em>bit error ratio tester</em> or <em>bit error rate test solution</em> (BERTs) is electronic test equipment used to test the quality of signal transmission of single components or complete systems.</p>

<p>The main building blocks of a BERT are:</p>
<ul>
<li><a href="Digital_pattern_generator" title="wikilink">Pattern generator</a>, which transmits a defined test pattern to the <a href="Device_under_test" title="wikilink">DUT</a> or test system</li>
<li>Error detector connected to the DUT or test system, to count the errors generated by the DUT or test system</li>
<li>Clock signal generator to synchronize the pattern generator and the error detector</li>
<li>Digital communication analyser is optional to display the transmitted or received signal</li>
<li>Electrical-optical converter and optical-electrical converter for testing optical communication signals</li>
</ul>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Burst_error" title="wikilink">Burst error</a></li>
<li><a href="Errored_second" title="wikilink">Errored second</a></li>
<li><a href="Viterbi_Error_Rate" title="wikilink">Viterbi Error Rate</a></li>
</ul>
<h2 id="references">References</h2>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.etti.unibw.de/labalive/experiment/qpskber/">QPSK BER for AWGN channel – online experiment</a></li>
</ul>

<p><a class="uri" href="cs:BER" title="wikilink">cs:BER</a>"</p>

<p><a class="uri" href="Category:Ratios" title="wikilink">Category:Ratios</a> <a href="Category:Data_transmission" title="wikilink">Category:Data transmission</a> <a href="Category:Network_performance" title="wikilink">Category:Network performance</a> <a href="Category:Error_measures" title="wikilink">Category:Error measures</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2">Digital Communications, John Proakis, Massoud Salehi, McGraw-Hill Education, Nov 6, 2007<a href="#fnref2">↩</a></li>
<li id="fn3"><a href="http://crypto.com/papers/jbug-Usenix06-final.pdf">"Keyboards and Covert Channels"</a> by Gaurav Shah, Andres Molina, and Matt Blaze (2006?)<a href="#fnref3">↩</a></li>
</ol>
</section>
</body>
</html>
