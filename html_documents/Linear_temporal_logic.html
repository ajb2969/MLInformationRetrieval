<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="419">Linear temporal logic</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Linear temporal logic</h1>
<hr/>

<p>In <a class="uri" href="logic" title="wikilink">logic</a>, <strong>linear temporal logic</strong> or <strong>linear-time temporal logic</strong><a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a><a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> (<strong>LTL</strong>) is a <a href="modal_logic" title="wikilink">modal</a> <a href="temporal_logic" title="wikilink">temporal logic</a> with modalities referring to time. In LTL, one can encode formulae about the future of <a href="path_(graph_theory)" title="wikilink">paths</a>, e.g., a condition will eventually be true, a condition will be true until another fact becomes true, etc. It is a fragment of the more complex <a class="uri" href="CTL*" title="wikilink">CTL*</a>, which additionally allows branching time and quantifiers. Subsequently LTL is sometimes called <em>propositional temporal logic</em>, abbreviated <em>PTL</em>.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> Linear temporal logic (LTL) is a fragment of S1S.</p>

<p>LTL was first proposed for the <a href="formal_verification" title="wikilink">formal verification</a> of computer programs by <a href="Amir_Pnueli" title="wikilink">Amir Pnueli</a> in 1977.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>
<h2 id="syntax">Syntax</h2>

<p>LTL is built up from a finite set of <a href="propositional_variable" title="wikilink">propositional variables</a> <em>AP</em>, the <a href="logical_connective" title="wikilink">logical operators</a> ¬ and ∨, and the <a href="Temporal_logic" title="wikilink">temporal</a> <a href="modal_operator" title="wikilink">modal operators</a> <strong>X</strong> (some literature uses <strong>O</strong> or <strong>N</strong>) and <strong>U</strong>. Formally, the set of LTL formulas over <em>AP</em> is inductively defined as follows:</p>
<ul>
<li>if p ∈ <em>AP</em> then p is an LTL formula;</li>
<li>if ψ and φ are LTL formulas then ¬ψ, φ ∨ ψ, <strong>X</strong> ψ, and φ <strong>U</strong> ψ are LTL formulas.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></li>
</ul>

<p><strong>X</strong> is read as ne<strong>x</strong>t and <strong>U</strong> is read as <strong>u</strong>ntil. Other than these fundamental operators, there are additional logical and temporal operators defined in terms of the fundamental operators to write LTL formulas succinctly. The additional logical operators are ∧, →, ↔, <strong>true</strong>, and <strong>false</strong>. Following are the additional temporal operators.</p>
<ul>
<li><strong>G</strong> for always (<strong>g</strong>lobally)</li>
<li><strong>F</strong> for eventually (in the <strong>f</strong>uture)</li>
<li><strong>R</strong> for <strong>r</strong>elease</li>
<li><strong>W</strong> for <strong>w</strong>eakly until</li>
</ul>
<h2 id="semantics">Semantics</h2>

<p>An LTL formula can be <em><a href="satisfiability" title="wikilink">satisfied</a></em> by an infinite sequence of truth evaluations of variables in <em>AP</em>. These sequences can be viewed as a word on a path of a <a href="Kripke_structure" title="wikilink">Kripke structure</a> (an <a href="ω-language" title="wikilink">ω-word</a> over alphabet 2<sup><em>AP</em></sup>). Let <em>w</em> = a<sub>0</sub>,a<sub>1</sub>,a<sub>2</sub>,... be such an ω-word. Let <em>w</em>(i) = a<sub>i</sub>. Let <em>w</em><sup>i</sup> = a<sub>i</sub>,a<sub>i+1</sub>,..., which is a suffix of <em>w</em>. Formally, the satisfaction relation 

<math display="inline" id="Linear_temporal_logic:0">
 <semantics>
  <mo>⊨</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-⊨</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vDash
  </annotation>
 </semantics>
</math>

 between a word and an LTL formula is defined as follows:</p>
<ul>
<li><em>w</em> 

<math display="inline" id="Linear_temporal_logic:1">
 <semantics>
  <mo>⊨</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-⊨</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vDash
  </annotation>
 </semantics>
</math>

 p if p ∈ <em>w</em>(0)</li>
<li><em>w</em> 

<math display="inline" id="Linear_temporal_logic:2">
 <semantics>
  <mo>⊨</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-⊨</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vDash
  </annotation>
 </semantics>
</math>

 ¬ψ if <em>w</em> 

<math display="inline" id="Linear_temporal_logic:3">
 <semantics>
  <mo>⊭</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-⊭</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \nvDash
  </annotation>
 </semantics>
</math>

 ψ</li>
<li><em>w</em> 

<math display="inline" id="Linear_temporal_logic:4">
 <semantics>
  <mo>⊨</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-⊨</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vDash
  </annotation>
 </semantics>
</math>

 φ ∨ ψ if <em>w</em> 

<math display="inline" id="Linear_temporal_logic:5">
 <semantics>
  <mo>⊨</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-⊨</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vDash
  </annotation>
 </semantics>
</math>

 φ or <em>w</em> 

<math display="inline" id="Linear_temporal_logic:6">
 <semantics>
  <mo>⊨</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-⊨</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vDash
  </annotation>
 </semantics>
</math>

 ψ</li>
<li><em>w</em> 

<math display="inline" id="Linear_temporal_logic:7">
 <semantics>
  <mo>⊨</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-⊨</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vDash
  </annotation>
 </semantics>
</math>

 <strong>X</strong> ψ if <em>w</em><sup>1</sup> 

<math display="inline" id="Linear_temporal_logic:8">
 <semantics>
  <mo>⊨</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-⊨</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vDash
  </annotation>
 </semantics>
</math>

 ψ (in the ne<strong>x</strong>t time step ψ must be true)</li>
<li><em>w</em> 

<math display="inline" id="Linear_temporal_logic:9">
 <semantics>
  <mo>⊨</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-⊨</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vDash
  </annotation>
 </semantics>
</math>

 φ <strong>U</strong> ψ if there exists i ≥ 0 such that <em>w</em><sup>i</sup> 

<math display="inline" id="Linear_temporal_logic:10">
 <semantics>
  <mo>⊨</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-⊨</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vDash
  </annotation>
 </semantics>
</math>

 ψ and for all 0 ≤ k k 

<math display="inline" id="Linear_temporal_logic:11">
 <semantics>
  <mo>⊨</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-⊨</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vDash
  </annotation>
 </semantics>
</math>

 φ (φ must remain true <strong>u</strong>ntil ψ becomes true)</li>
</ul>

<p>We say an ω-word <em>w</em> satisfies LTL formula ψ when <em>w</em> 

<math display="inline" id="Linear_temporal_logic:12">
 <semantics>
  <mo>⊨</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-⊨</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vDash
  </annotation>
 </semantics>
</math>

 ψ. The <a class="uri" href="ω-language" title="wikilink">ω-language</a> <em>L</em>(ψ) defined by ψ is {<em>w</em> | <em>w</em> 

<math display="inline" id="Linear_temporal_logic:13">
 <semantics>
  <mo>⊨</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-⊨</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vDash
  </annotation>
 </semantics>
</math>

 ψ}, which is the set of ω-words that satisfy ψ. A formula ψ is <em>satisfiable</em> if there exist a ω-word <em>w</em> such that <em>w</em> 

<math display="inline" id="Linear_temporal_logic:14">
 <semantics>
  <mo>⊨</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-⊨</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vDash
  </annotation>
 </semantics>
</math>

 ψ. A formula ψ is <em>valid</em> if for each ω-word <em>w</em> over alphabet 2<sup><em>AP</em></sup>, <em>w</em> 

<math display="inline" id="Linear_temporal_logic:15">
 <semantics>
  <mo>⊨</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-⊨</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vDash
  </annotation>
 </semantics>
</math>

 ψ.</p>

<p>The additional logical operators are defined as follows:</p>
<ul>
<li>φ ∧ ψ ≡ ¬(¬φ ∨ ¬ψ)</li>
<li>φ → ψ ≡ ¬φ ∨ ψ</li>
<li>φ ↔ ψ ≡ (φ → ψ) ∧ ( ψ → φ)</li>
<li><strong>true</strong> ≡ p ∨ ¬p, where p ∈ <em>AP</em></li>
<li><strong>false</strong> ≡ ¬<strong>true</strong></li>
</ul>

<p>The additional temporal operators <strong>R</strong>, <strong>F</strong>, and <strong>G</strong> are defined as follows:</p>
<ul>
<li>φ <strong>R</strong> ψ ≡ ¬(¬φ <strong>U</strong> ¬ψ) ( ψ remains true until once φ becomes true. φ may never become true)</li>
<li><strong>F</strong> ψ ≡ <strong>true</strong> <strong>U</strong> ψ (eventually ψ becomes true)</li>
<li><strong>G</strong> ψ ≡ <strong>false</strong> <strong>R</strong> ψ ≡ ¬<strong>F</strong> ¬ψ (ψ always remains true)</li>
</ul>
<dl>
<dt>Weak until</dt>
</dl>

<p>Some authors also define a <em>weak until</em> binary operator, denoted <strong>W</strong>, with semantics similar to that of the until operator but the stop condition is not required to occur (similar to release).<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> It is sometimes useful since both <strong>U</strong> and <strong>R</strong> can be defined in terms of the weak until:</p>
<ul>
<li>φ <strong>W</strong> ψ ≡ (φ <strong>U</strong> ψ) ∨ <strong>G</strong> φ ≡ φ <strong>U</strong> (ψ ∨ <strong>G</strong> φ) ≡ ψ <strong>R</strong> (ψ ∨ φ)</li>
<li>φ <strong>U</strong> ψ ≡ <strong>F</strong>ψ ∧ (φ <strong>W</strong> ψ)</li>
<li>φ <strong>R</strong> ψ ≡ ψ <strong>W</strong> (ψ ∧ φ)</li>
</ul>

<p>The semantics for the temporal operators are pictorially presented as follows.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>Textual</p></th>
<th style="text-align: left;">
<p>Symbolic†</p></th>
<th style="text-align: left;">
<p>Explanation</p></th>
<th style="text-align: left;">
<p>Diagram</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p><a href="Unary_operation" title="wikilink">Unary operators</a>:</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><strong>X</strong> 

<math display="inline" id="Linear_temporal_logic:16">
 <semantics>
  <mi>ϕ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϕ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Linear_temporal_logic:17">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>○</mo>
   <mi>ϕ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-○</ci>
    <csymbol cd="latexml">absent</csymbol>
    <ci>ϕ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bigcirc\phi
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>ne<strong>X</strong>t

<math display="block" id="Linear_temporal_logic:18">
 <semantics>
  <mi>ϕ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϕ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi
  </annotation>
 </semantics>
</math>

 has to hold at the next state.</p></td>
<td style="text-align: left;"><figure><b>(Figure)</b>
<figcaption>LTL next operator</figcaption>
</figure></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><strong>G</strong> 

<math display="inline" id="Linear_temporal_logic:19">
 <semantics>
  <mi>ϕ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϕ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Linear_temporal_logic:20">
 <semantics>
  <mrow>
   <mi mathvariant="normal">□</mi>
   <mi>ϕ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-□</ci>
    <ci>ϕ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Box\phi
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p><strong>G</strong>lobally

<math display="block" id="Linear_temporal_logic:21">
 <semantics>
  <mi>ϕ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϕ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi
  </annotation>
 </semantics>
</math>

 has to hold on the entire subsequent path.</p></td>
<td style="text-align: left;"><figure><b>(Figure)</b>
<figcaption>LTL always operator</figcaption>
</figure></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><strong>F</strong> 

<math display="inline" id="Linear_temporal_logic:22">
 <semantics>
  <mi>ϕ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϕ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Linear_temporal_logic:23">
 <semantics>
  <mrow>
   <mi mathvariant="normal">◇</mi>
   <mi>ϕ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-◇</ci>
    <ci>ϕ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Diamond\phi
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p><strong>F</strong>inally

<math display="block" id="Linear_temporal_logic:24">
 <semantics>
  <mi>ϕ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϕ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi
  </annotation>
 </semantics>
</math>

 eventually has to hold (somewhere on the subsequent path).</p></td>
<td style="text-align: left;"><figure><b>(Figure)</b>
<figcaption>LTL eventually operator</figcaption>
</figure></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><a href="Binary_operator" title="wikilink">Binary operators</a>:</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>

<math display="inline" id="Linear_temporal_logic:25">
 <semantics>
  <mi>ψ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ψ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \psi
  </annotation>
 </semantics>
</math>

 <strong>U</strong> 

<math display="inline" id="Linear_temporal_logic:26">
 <semantics>
  <mi>ϕ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϕ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Linear_temporal_logic:27">
 <semantics>
  <mrow>
   <mpadded width="+2.8pt">
    <mi>ψ</mi>
   </mpadded>
   <mpadded width="+1.7pt">
    <mi class="ltx_font_mathcaligraphic">𝒰</mi>
   </mpadded>
   <mi>ϕ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>ψ</ci>
    <ci>𝒰</ci>
    <ci>ϕ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \psi\;\mathcal{U}\,\phi
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p><strong>U</strong>ntil

<math display="block" id="Linear_temporal_logic:28">
 <semantics>
  <mi>ψ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ψ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \psi
  </annotation>
 </semantics>
</math>

 has to hold <em>at least</em> until 

<math display="inline" id="Linear_temporal_logic:29">
 <semantics>
  <mi>ϕ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϕ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi
  </annotation>
 </semantics>
</math>

, which holds at the current or a future position.</p></td>
<td style="text-align: left;"><figure><b>(Figure)</b>
<figcaption>LTL until operator</figcaption>
</figure></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>

<math display="inline" id="Linear_temporal_logic:30">
 <semantics>
  <mi>ψ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ψ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \psi
  </annotation>
 </semantics>
</math>

 <strong>R</strong> 

<math display="inline" id="Linear_temporal_logic:31">
 <semantics>
  <mi>ϕ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϕ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Linear_temporal_logic:32">
 <semantics>
  <mrow>
   <mpadded width="+2.8pt">
    <mi>ψ</mi>
   </mpadded>
   <mpadded width="+1.7pt">
    <mi class="ltx_font_mathcaligraphic">ℛ</mi>
   </mpadded>
   <mi>ϕ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>ψ</ci>
    <ci>ℛ</ci>
    <ci>ϕ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \psi\;\mathcal{R}\,\phi
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p><strong>R</strong>elease

<math display="block" id="Linear_temporal_logic:33">
 <semantics>
  <mi>ϕ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϕ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi
  </annotation>
 </semantics>
</math>

 has to be true until and including the point where 

<math display="inline" id="Linear_temporal_logic:34">
 <semantics>
  <mi>ψ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ψ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \psi
  </annotation>
 </semantics>
</math>

 first becomes true; if 

<math display="inline" id="Linear_temporal_logic:35">
 <semantics>
  <mi>ψ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ψ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \psi
  </annotation>
 </semantics>
</math>

 never becomes true, 

<math display="inline" id="Linear_temporal_logic:36">
 <semantics>
  <mi>ϕ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϕ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi
  </annotation>
 </semantics>
</math>

 must remain true forever.</p></td>
<td style="text-align: left;">
<p><br/>
</p></td>
</tr>
</tbody>
</table>

<p>†The symbols are used in the literature to denote these operators.</p>
<h2 id="equivalences">Equivalences</h2>

<p>Let Φ, ψ, and ρ be LTL formulas. The following tables list some of the useful equivalences which extend standard equivalences among the usual logical operators.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>Distributivity</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p><strong>X</strong> (Φ ∨ ψ) ≡ (<strong>X</strong> Φ) ∨ (<strong>X</strong> ψ)</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><strong>F</strong> (Φ ∨ ψ) ≡ (<strong>F</strong> Φ) ∨ (<strong>F</strong> ψ)</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>ρ <strong>U</strong> (Φ ∨ ψ) ≡ (ρ <strong>U</strong> Φ) ∨ (ρ <strong>U</strong> ψ)</p></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>Negation propagation</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>¬<strong>X</strong> Φ ≡ <strong>X</strong> ¬Φ</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>¬ (Φ <strong>U</strong> ψ) ≡ (¬Φ <strong>R</strong> ¬ψ)</p></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>Special Temporal properties</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p><strong>F</strong> Φ ≡ <strong>F</strong> <strong>F</strong> Φ</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Φ <strong>U</strong> ψ ≡ ψ ∨ ( Φ ∧ <strong>X</strong>(Φ <strong>U</strong> ψ) )</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><strong>G</strong> Φ ≡ Φ ∧ <strong>X</strong>(<strong>G</strong> Φ)</p></td>
</tr>
</tbody>
</table>
<h2 id="negation-normal-form">Negation normal form</h2>

<p>All the formulas of LTL can be transformed into <em>negation normal form</em>, where</p>
<ul>
<li>all negations appear only in front of the atomic propositions,</li>
<li>only other logical operators <strong>true</strong>, <strong>false</strong>, ∧, and ∨ can appear, and</li>
<li>only the temporal operators <strong>X</strong>, <strong>U</strong>, and <strong>R</strong> can appear.</li>
</ul>

<p>Using the above equivalences for negation propagation, it is possible to derive the normal form. This normal form allows <strong>R</strong>, <strong>true</strong>, <strong>false</strong>, and ∧ to appear in the formula, which are not fundamental operators of LTL. Note that the transformation to the negation normal form does not blow up the size of the formula. This normal form is useful in <a href="Linear_temporal_logic_to_Büchi_automaton" title="wikilink">translation from LTL to Büchi automaton</a>.</p>
<h2 id="relations-with-other-logics">Relations with other logics</h2>

<p>LTL can be shown to be equivalent to the <a href="monadic_first-order_logic_of_order" title="wikilink">monadic first-order logic of order</a>, FO[ or equivalently <a href="star-free_language" title="wikilink">star-free languages</a>.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>

<p><a href="Computation_tree_logic" title="wikilink">Computation tree logic</a> (CTL) and Linear temporal logic (LTL) are both a subset of <a class="uri" href="CTL*" title="wikilink">CTL*</a>, but are not equivalent to each other. For example,</p>
<ul>
<li>No formula in CTL can define the language that is defined by the LTL formula <strong>F</strong>(<strong>G</strong> p).</li>
<li>No formula in LTL can define the language that is defined by the CTL formulas <strong>AG</strong>( p → (<strong>EX</strong>q ∧ <strong>EX</strong>¬q) ) or <strong>AG</strong>(<strong>EF</strong>(P)).</li>
</ul>

<p>However, a subset of CTL* exists that is a proper subset of both CTL and LTL.</p>
<h2 id="applications">Applications</h2>
<dl>
<dt>Automata theoretic Linear temporal logic model checking</dt>
<dd>An important way to model check is to express desired properties (such as the ones described above) using LTL operators and actually check if the model satisfies this property. One technique is to obtain a <a href="Büchi_automaton" title="wikilink">Büchi automaton</a> that is equivalent to the model and another one that is equivalent to the negation of the property (cf. <a href="Linear_temporal_logic_to_Büchi_automaton" title="wikilink">Linear temporal logic to Büchi automaton</a>). The intersection of the two non-deterministic Büchi automata is empty if the model satisfies the property.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a>
</dd>
</dl>
<dl>
<dt>Expressing important properties in formal verification</dt>
<dd>There are two main types of properties that can be expressed using linear temporal logic: <strong><a href="Safety_(distributed_computing)" title="wikilink">safety</a></strong> properties usually state that <em>something bad never happens</em> (<strong>G</strong>

<math display="inline" id="Linear_temporal_logic:37">
 <semantics>
  <mi mathvariant="normal">¬</mi>
  <annotation-xml encoding="MathML-Content">
   <not></not>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg
  </annotation>
 </semantics>
</math>



<math display="inline" id="Linear_temporal_logic:38">
 <semantics>
  <mi>ϕ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϕ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi
  </annotation>
 </semantics>
</math>

), while <strong><a class="uri" href="liveness" title="wikilink">liveness</a></strong> properties state that <em>something good keeps happening</em> (<strong>GF</strong>

<math display="inline" id="Linear_temporal_logic:39">
 <semantics>
  <mi>ψ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ψ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \psi
  </annotation>
 </semantics>
</math>

 or <strong>G</strong>

<math display="inline" id="Linear_temporal_logic:40">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>ϕ</mi>
   <mo>→</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-(</ci>
    <csymbol cd="unknown">ϕ</csymbol>
    <ci>normal-→</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\phi\rightarrow
  </annotation>
 </semantics>
</math>

<strong>F</strong>

<math display="inline" id="Linear_temporal_logic:41">
 <semantics>
  <mrow>
   <mi>ψ</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">ψ</csymbol>
    <ci>normal-)</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \psi)
  </annotation>
 </semantics>
</math>

). More generally: Safety properties are those for which every <a class="uri" href="counterexample" title="wikilink">counterexample</a> has a finite prefix such that, however it is extended to an infinite path, it is still a counterexample. For liveness properties, on the other hand, every finite prefix of a counterexample can be extended to an infinite path that satisfies the formula.
</dd>
</dl>
<dl>
<dt>Specification language</dt>
<dd>One of the applications of linear temporal logic is the specification of <a href="preference" title="wikilink">preferences</a> in the <a href="Planning_Domain_Definition_Language" title="wikilink">Planning Domain Definition Language</a> for the purpose of <a href="preference-based_planning" title="wikilink">preference-based planning</a>.
</dd>
</dl>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Action_language" title="wikilink">Action language</a></li>
</ul>
<h2 id="references">References</h2>
<dl>
<dt>External links</dt>
</dl>
<ul>
<li><a href="http://www.dcs.qmul.ac.uk/~pm/SaR/2004ltl.pdf">A presentation of LTL</a></li>
<li><a href="http://www.cmi.ac.in/~madhavan/papers/pdf/isical97.pdf">Linear-Time Temporal Logic and Büchi Automata</a></li>
<li><a href="http://www.inf.unibz.it/~artale/FM/slide3.pdf">LTL Teaching slides</a> of professor <a href="Alessandro_Artale" title="wikilink">Alessandro Artale</a> at the <a href="Free_University_of_Bozen-Bolzano" title="wikilink">Free University of Bozen-Bolzano</a></li>
<li><a href="http://spot.lip6.fr/wiki/LtlTranslationAlgorithms">LTL to Buchi translation algorithms</a> a genealogy, from the website of <a href="http://spot.lip6.fr/">Spot</a> a library for model-checking.</li>
</ul>

<p>"</p>

<p><a href="Category:1977_works" title="wikilink">Category:1977 works</a> <a href="Category:Temporal_logic" title="wikilink">Category:Temporal logic</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Logic in Computer Science: Modelling and Reasoning about Systems: page 175<a href="#fnref1">↩</a></li>
<li id="fn2"><a href="http://www-step.stanford.edu/tutorial/temporal-logic/temporal-logic.html">Linear-time Temporal Logic</a><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="Amir_Pnueli" title="wikilink">Amir Pnueli</a>, The temporal logic of programs. <em>Proceedings of the 18th Annual Symposium on Foundations of Computer Science (FOCS)</em>, 1977, 46–57. <a href="#fnref4">↩</a></li>
<li id="fn5">Sec. 5.1 of Christel Baier and Joost-Pieter Katoen, Principles of Model Checking, MIT Press [<a class="uri" href="http://mitpress.mit.edu/catalog/item/default.asp?tid=11481&amp;ttype">http://mitpress.mit.edu/catalog/item/default.asp?tid=11481&amp;ttype;</a>;=2]<a href="#fnref5">↩</a></li>
<li id="fn6">Sec. 5.1.5 "Weak Until, Release, and Positive Normal Form" of Principles of Model Checking.<a href="#fnref6">↩</a></li>
<li id="fn7"> <a href="http://www.cs.rice.edu/~vardi/papers/25mc.ps.gz">preprint</a><a href="#fnref7">↩</a></li>
<li id="fn8">Moshe Y. Vardi. <em>An Automata-Theoretic Approach to Linear Temporal Logic.</em> Proceedings of the 8th Banff Higher Order Workshop (Banff'94). Lecture Notes in Computer Science, vol. 1043, pp. 238--266, Springer-Verlag, 1996. ISBN 3-540-60915-6.<a href="#fnref8">↩</a></li>
</ol>
</section>
</body>
</html>
