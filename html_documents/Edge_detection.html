<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="119">Edge detection</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Edge detection</h1>
<hr/>

<p><strong>Edge detection</strong> is the name for a set of mathematical methods which aim at identifying points in a <a href="digital_image" title="wikilink">digital image</a> at which the <a href="luminous_intensity" title="wikilink">image brightness</a> changes sharply or, more formally, has discontinuities. The points at which image brightness changes sharply are typically organized into a set of curved line segments termed <em>edges</em>. The same problem of finding discontinuities in 1D signals is known as <a href="step_detection" title="wikilink">step detection</a> and the problem of finding signal discontinuities over time is known as <a href="change_detection" title="wikilink">change detection</a>. Edge detection is a fundamental tool in <a href="image_processing" title="wikilink">image processing</a>, <a href="machine_vision" title="wikilink">machine vision</a> and <a href="computer_vision" title="wikilink">computer vision</a>, particularly in the areas of <a href="feature_detection_(computer_vision)" title="wikilink">feature detection</a> and <a href="feature_extraction" title="wikilink">feature extraction</a>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>
<h2 id="motivations">Motivations</h2>

<p> The purpose of detecting sharp changes in image brightness is to capture important events and changes in properties of the world. It can be shown that under rather general assumptions for an image formation model, discontinuities in image brightness are likely to correspond to:<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a><a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>
<ul>
<li>discontinuities in depth,</li>
<li>discontinuities in surface orientation,</li>
<li>changes in material properties and</li>
<li>variations in scene illumination.</li>
</ul>

<p>In the ideal case, the result of applying an edge detector to an image may lead to a set of connected curves that indicate the boundaries of objects, the boundaries of surface markings as well as curves that correspond to discontinuities in surface orientation. Thus, applying an edge detection algorithm to an image may significantly reduce the amount of data to be processed and may therefore filter out information that may be regarded as less relevant, while preserving the important structural properties of an image. If the edge detection step is successful, the subsequent task of interpreting the information contents in the original image may therefore be substantially simplified. However, it is not always possible to obtain such ideal edges from real life images of moderate complexity.</p>

<p>Edges extracted from non-trivial images are often hampered by <em>fragmentation</em>, meaning that the edge curves are not connected, missing edge segments as well as <em>false edges</em> not corresponding to interesting phenomena in the image – thus complicating the subsequent task of interpreting the image data.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>

<p>Edge detection is one of the fundamental steps in image processing, image analysis, image pattern recognition, and computer vision techniques.</p>
<h2 id="edge-properties">Edge properties</h2>

<p>The edges extracted from a two-dimensional image of a three-dimensional scene can be classified as either viewpoint dependent or viewpoint independent. A <em>viewpoint independent edge</em> typically reflects inherent properties of the three-dimensional objects, such as surface markings and surface shape. A <em>viewpoint dependent edge</em> may change as the viewpoint changes, and typically reflects the geometry of the scene, such as objects occluding one another.</p>

<p>A typical edge might for instance be the border between a block of red color and a block of yellow. In contrast a <strong><a href="line_(mathematics)" title="wikilink">line</a></strong> (as can be extracted by a <a href="ridge_detection" title="wikilink">ridge detector</a>) can be a small number of pixels of a different color on an otherwise unchanging background. For a line, there may therefore usually be one edge on each side of the line.</p>
<h2 id="a-simple-edge-model">A simple edge model</h2>

<p>Although certain literature has considered the detection of ideal step edges, the edges obtained from natural images are usually not at all ideal step edges. Instead they are normally affected by one or several of the following effects:</p>
<ul>
<li>focal blur caused by a finite <a class="uri" href="depth-of-field" title="wikilink">depth-of-field</a> and finite <a href="point_spread_function" title="wikilink">point spread function</a>.</li>
<li><a href="penumbra" title="wikilink">penumbral blur</a> caused by shadows created by light sources of non-zero radius.</li>
<li><a class="uri" href="shading" title="wikilink">shading</a> at a smooth object</li>
</ul>

<p>A number of researchers have used a Gaussian smoothed step edge (an error function) as the simplest extension of the ideal step edge model for modeling the effects of edge blur in practical applications.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a><a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> Thus, a one-dimensional image 

<math display="inline" id="Edge_detection:0">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 which has exactly one edge placed at 

<math display="inline" id="Edge_detection:1">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>x</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x=0
  </annotation>
 </semantics>
</math>

 may be modeled as:</p>

<p>

<math display="block" id="Edge_detection:2">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mfrac>
       <mrow>
        <msub>
         <mi>I</mi>
         <mi>r</mi>
        </msub>
        <mo>-</mo>
        <msub>
         <mi>I</mi>
         <mi>l</mi>
        </msub>
       </mrow>
       <mn>2</mn>
      </mfrac>
      <mrow>
       <mo>(</mo>
       <mrow>
        <mrow>
         <mo>erf</mo>
         <mrow>
          <mo>(</mo>
          <mfrac>
           <mi>x</mi>
           <mrow>
            <msqrt>
             <mn>2</mn>
            </msqrt>
            <mi>σ</mi>
           </mrow>
          </mfrac>
          <mo>)</mo>
         </mrow>
        </mrow>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
       <mo>)</mo>
      </mrow>
     </mrow>
     <mo>+</mo>
     <msub>
      <mi>I</mi>
      <mi>l</mi>
     </msub>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>I</ci>
         <ci>r</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>I</ci>
         <ci>l</ci>
        </apply>
       </apply>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <plus></plus>
       <apply>
        <ci>erf</ci>
        <apply>
         <divide></divide>
         <ci>x</ci>
         <apply>
          <times></times>
          <apply>
           <root></root>
           <cn type="integer">2</cn>
          </apply>
          <ci>σ</ci>
         </apply>
        </apply>
       </apply>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>I</ci>
      <ci>l</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x)=\frac{I_{r}-I_{l}}{2}\left(\operatorname{erf}\left(\frac{x}{\sqrt{2}%
\sigma}\right)+1\right)+I_{l}.
  </annotation>
 </semantics>
</math>

</p>

<p>At the left side of the edge, the intensity is 

<math display="inline" id="Edge_detection:3">
 <semantics>
  <mrow>
   <msub>
    <mi>I</mi>
    <mi>l</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mo>lim</mo>
     <mrow>
      <mi>x</mi>
      <mo>→</mo>
      <mrow>
       <mo>-</mo>
       <mi mathvariant="normal">∞</mi>
      </mrow>
     </mrow>
    </msub>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>I</ci>
     <ci>l</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <limit></limit>
      <apply>
       <ci>normal-→</ci>
       <ci>x</ci>
       <apply>
        <minus></minus>
        <infinity></infinity>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I_{l}=\lim_{x\rightarrow-\infty}f(x)
  </annotation>
 </semantics>
</math>

, and right of the edge it is 

<math display="inline" id="Edge_detection:4">
 <semantics>
  <mrow>
   <msub>
    <mi>I</mi>
    <mi>r</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mo>lim</mo>
     <mrow>
      <mi>x</mi>
      <mo>→</mo>
      <mi mathvariant="normal">∞</mi>
     </mrow>
    </msub>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>I</ci>
     <ci>r</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <limit></limit>
      <apply>
       <ci>normal-→</ci>
       <ci>x</ci>
       <infinity></infinity>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I_{r}=\lim_{x\rightarrow\infty}f(x)
  </annotation>
 </semantics>
</math>

. The scale parameter 

<math display="inline" id="Edge_detection:5">
 <semantics>
  <mi>σ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma
  </annotation>
 </semantics>
</math>

 is called the blur scale of the edge.</p>
<h2 id="why-edge-detection-is-a-non-trivial-task">Why edge detection is a non-trivial task</h2>

<p>To illustrate why edge detection is not a trivial task, consider the problem of detecting edges in the following one-dimensional signal. Here, we may intuitively say that there should be an edge between the 4th and 5th pixels.</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>5</p></td>
<td style="text-align: left;">
<p>7</p></td>
<td style="text-align: left;">
<p>6</p></td>
<td style="text-align: left;">
<p>4</p></td>
<td style="text-align: left;">
<p>152</p></td>
<td style="text-align: left;">
<p>148</p></td>
<td style="text-align: left;">
<p>149</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>

<p>If the intensity difference were smaller between the 4th and the 5th pixels and if the intensity differences between the adjacent neighboring pixels were higher, it would not be as easy to say that there should be an edge in the corresponding region. Moreover, one could argue that this case is one in which there are several edges.</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>5</p></td>
<td style="text-align: left;">
<p>7</p></td>
<td style="text-align: left;">
<p>6</p></td>
<td style="text-align: left;">
<p>41</p></td>
<td style="text-align: left;">
<p>113</p></td>
<td style="text-align: left;">
<p>148</p></td>
<td style="text-align: left;">
<p>149</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>

<p>Hence, to firmly state a specific threshold on how large the intensity change between two neighbouring pixels must be for us to say that there should be an edge between these pixels is not always simple.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> Indeed, this is one of the reasons why edge detection may be a non-trivial problem unless the objects in the scene are particularly simple and the illumination conditions can be well controlled (see for example, the edges extracted from the image with the girl above).</p>
<h2 id="approaches">Approaches</h2>

<p>There are many methods for edge detection, but most of them can be grouped into two categories, search-based and <a href="Zero_crossing" title="wikilink">zero-crossing</a> based. The search-based methods detect edges by first computing a measure of edge strength, usually a first-order derivative expression such as the gradient magnitude, and then searching for local directional maxima of the gradient magnitude using a computed estimate of the local orientation of the edge, usually the gradient direction. The zero-crossing based methods search for zero crossings in a second-order derivative expression computed from the image in order to find edges, usually the zero-crossings of the <a class="uri" href="Laplacian" title="wikilink">Laplacian</a> or the zero-crossings of a non-linear differential expression. As a pre-processing step to edge detection, a smoothing stage, typically Gaussian smoothing, is almost always applied (see also <a href="noise_reduction" title="wikilink">noise reduction</a>).</p>

<p>The edge detection methods that have been published mainly differ in the types of smoothing filters that are applied and the way the measures of edge strength are computed. As many edge detection methods rely on the computation of image gradients, they also differ in the types of filters used for computing gradient estimates in the x- and y-directions.</p>

<p>A survey of a number of different edge detection methods can be found in (Ziou and Tabbone 1998);<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> see also the encyclopedia articles on edge detection in <em>Encyclopedia of Mathematics</em><a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> and Encyclopedia of Computer Science and Engineering.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a></p>
<h3 id="canny-edge-detection">Canny edge detection</h3>

<p><a href="John_Canny" title="wikilink">John Canny</a> considered the mathematical problem of deriving an optimal smoothing filter given the criteria of detection, localization and minimizing multiple responses to a single edge.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> He showed that the optimal filter given these assumptions is a sum of four exponential terms. He also showed that this filter can be well approximated by first-order derivatives of Gaussians. Canny also introduced the notion of non-maximum suppression, which means that given the presmoothing filters, edge points are defined as points where the gradient magnitude assumes a local maximum in the gradient direction. Looking for the zero crossing of the 2nd derivative along the gradient direction was first proposed by <a class="uri" href="Haralick" title="wikilink">Haralick</a>.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> It took less than two decades to find a modern geometric variational meaning for that operator that links it to the <a href="Marr-Hildreth_algorithm" title="wikilink">Marr–Hildreth</a> (zero crossing of the Laplacian) edge detector. That observation was presented by <a href="Ron_Kimmel" title="wikilink">Ron Kimmel</a> and <a href="Alfred_Bruckstein" title="wikilink">Alfred Bruckstein</a>.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a></p>

<p>Although his work was done in the early days of computer vision, the <a href="Canny_edge_detector" title="wikilink">Canny edge detector</a> (including its variations) is still a state-of-the-art edge detector.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a> Unless the preconditions are particularly suitable, it is hard to find an edge detector that performs significantly better than the Canny edge detector.</p>

<p>The Canny-Deriche detector was derived from similar mathematical criteria as the Canny edge detector, although starting from a discrete viewpoint and then leading to a set of recursive filters for image smoothing instead of <a href="exponential_filter" title="wikilink">exponential filters</a> or Gaussian filters.<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a></p>

<p>The <a href="Edge_detection#Differential_edge_detection" title="wikilink">differential edge detector</a> described below can be seen as a reformulation of Canny's method from the viewpoint of differential invariants computed from a <a href="scale_space_representation" title="wikilink">scale space representation</a> leading to a number of advantages in terms of both theoretical analysis and sub-pixel implementation.</p>
<h3 id="other-first-order-methods">Other first-order methods</h3>

<p>Different gradient operators can be applied to estimate image gradients from the input image or a smoothed version of it. The simplest approach is to use central differences:</p>

<p>

<math display="block" id="Edge_detection:6">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>L</mi>
     <mi>x</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo>-</mo>
     <mrow>
      <mrow>
       <mrow>
        <mn>1</mn>
        <mo>/</mo>
        <mn>2</mn>
       </mrow>
       <mo>⋅</mo>
       <mi>L</mi>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>x</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
       <mo>,</mo>
       <mi>y</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mrow>
      <mn>0</mn>
      <mo>⋅</mo>
      <mi>L</mi>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mi>y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mrow>
      <mrow>
       <mn>1</mn>
       <mo>/</mo>
       <mn>2</mn>
      </mrow>
      <mo>⋅</mo>
      <mi>L</mi>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>x</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
      <mo>,</mo>
      <mi>y</mi>
      <mo rspace="4.2pt" stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>L</ci>
      <ci>x</ci>
     </apply>
     <interval closure="open">
      <ci>x</ci>
      <ci>y</ci>
     </interval>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <apply>
        <ci>normal-⋅</ci>
        <apply>
         <divide></divide>
         <cn type="integer">1</cn>
         <cn type="integer">2</cn>
        </apply>
        <ci>L</ci>
       </apply>
       <interval closure="open">
        <apply>
         <minus></minus>
         <ci>x</ci>
         <cn type="integer">1</cn>
        </apply>
        <ci>y</ci>
       </interval>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <ci>normal-⋅</ci>
       <cn type="integer">0</cn>
       <ci>L</ci>
      </apply>
      <interval closure="open">
       <ci>x</ci>
       <ci>y</ci>
      </interval>
     </apply>
     <apply>
      <times></times>
      <apply>
       <ci>normal-⋅</ci>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <cn type="integer">2</cn>
       </apply>
       <ci>L</ci>
      </apply>
      <interval closure="open">
       <apply>
        <plus></plus>
        <ci>x</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>y</ci>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L_{x}(x,y)=-1/2\cdot L(x-1,y)+0\cdot L(x,y)+1/2\cdot L(x+1,y)\,
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Edge_detection:7">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>L</mi>
      <mi>y</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mi>y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mo>-</mo>
      <mrow>
       <mrow>
        <mrow>
         <mn>1</mn>
         <mo>/</mo>
         <mn>2</mn>
        </mrow>
        <mo>⋅</mo>
        <mi>L</mi>
       </mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo>,</mo>
        <mrow>
         <mi>y</mi>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mrow>
       <mn>0</mn>
       <mo>⋅</mo>
       <mi>L</mi>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo>,</mo>
       <mi>y</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mrow>
       <mrow>
        <mn>1</mn>
        <mo>/</mo>
        <mn>2</mn>
       </mrow>
       <mo>⋅</mo>
       <mi>L</mi>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo>,</mo>
       <mrow>
        <mi>y</mi>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>L</ci>
      <ci>y</ci>
     </apply>
     <interval closure="open">
      <ci>x</ci>
      <ci>y</ci>
     </interval>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <apply>
        <ci>normal-⋅</ci>
        <apply>
         <divide></divide>
         <cn type="integer">1</cn>
         <cn type="integer">2</cn>
        </apply>
        <ci>L</ci>
       </apply>
       <interval closure="open">
        <ci>x</ci>
        <apply>
         <minus></minus>
         <ci>y</ci>
         <cn type="integer">1</cn>
        </apply>
       </interval>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <ci>normal-⋅</ci>
       <cn type="integer">0</cn>
       <ci>L</ci>
      </apply>
      <interval closure="open">
       <ci>x</ci>
       <ci>y</ci>
      </interval>
     </apply>
     <apply>
      <times></times>
      <apply>
       <ci>normal-⋅</ci>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <cn type="integer">2</cn>
       </apply>
       <ci>L</ci>
      </apply>
      <interval closure="open">
       <ci>x</ci>
       <apply>
        <plus></plus>
        <ci>y</ci>
        <cn type="integer">1</cn>
       </apply>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L_{y}(x,y)=-1/2\cdot L(x,y-1)+0\cdot L(x,y)+1/2\cdot L(x,y+1),\,
  </annotation>
 </semantics>
</math>

</p>

<p>corresponding to the application of the following filter masks to the image data:</p>

<p>

<math display="block" id="Edge_detection:8">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>L</mi>
      <mi>x</mi>
     </msub>
     <mo>=</mo>
     <mrow>
      <mrow>
       <mrow>
        <mo>[</mo>
        <mtable displaystyle="true">
         <mtr>
          <mtd columnalign="center">
           <mrow>
            <mo>-</mo>
            <mrow>
             <mn>1</mn>
             <mo>/</mo>
             <mn>2</mn>
            </mrow>
           </mrow>
          </mtd>
          <mtd columnalign="center">
           <mn>0</mn>
          </mtd>
          <mtd columnalign="center">
           <mrow>
            <mn>1</mn>
            <mo>/</mo>
            <mn>2</mn>
           </mrow>
          </mtd>
         </mtr>
        </mtable>
        <mo>]</mo>
       </mrow>
       <mo>*</mo>
       <mi>L</mi>
      </mrow>
      <mtext>and</mtext>
     </mrow>
    </mrow>
    <mrow>
     <msub>
      <mi>L</mi>
      <mi>y</mi>
     </msub>
     <mo>=</mo>
     <mrow>
      <mrow>
       <mo>[</mo>
       <mtable displaystyle="true">
        <mtr>
         <mtd columnalign="center">
          <mrow>
           <mo>+</mo>
           <mrow>
            <mn>1</mn>
            <mo>/</mo>
            <mn>2</mn>
           </mrow>
          </mrow>
         </mtd>
        </mtr>
        <mtr>
         <mtd columnalign="center">
          <mn>0</mn>
         </mtd>
        </mtr>
        <mtr>
         <mtd columnalign="center">
          <mrow>
           <mo>-</mo>
           <mrow>
            <mn>1</mn>
            <mo>/</mo>
            <mn>2</mn>
           </mrow>
          </mrow>
         </mtd>
        </mtr>
       </mtable>
       <mo>]</mo>
      </mrow>
      <mo>*</mo>
      <mi>L</mi>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>L</ci>
      <ci>x</ci>
     </apply>
     <list>
      <apply>
       <times></times>
       <matrix>
        <matrixrow>
         <apply>
          <minus></minus>
          <apply>
           <divide></divide>
           <cn type="integer">1</cn>
           <cn type="integer">2</cn>
          </apply>
         </apply>
         <cn type="integer">0</cn>
         <apply>
          <divide></divide>
          <cn type="integer">1</cn>
          <cn type="integer">2</cn>
         </apply>
        </matrixrow>
       </matrix>
       <ci>L</ci>
      </apply>
      <mtext>and</mtext>
     </list>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>L</ci>
      <ci>y</ci>
     </apply>
     <apply>
      <times></times>
      <matrix>
       <matrixrow>
        <apply>
         <plus></plus>
         <apply>
          <divide></divide>
          <cn type="integer">1</cn>
          <cn type="integer">2</cn>
         </apply>
        </apply>
       </matrixrow>
       <matrixrow>
        <cn type="integer">0</cn>
       </matrixrow>
       <matrixrow>
        <apply>
         <minus></minus>
         <apply>
          <divide></divide>
          <cn type="integer">1</cn>
          <cn type="integer">2</cn>
         </apply>
        </apply>
       </matrixrow>
      </matrix>
      <ci>L</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L_{x}=\begin{bmatrix}-1/2&0&1/2\end{bmatrix}*L\quad\mbox{and}\quad L_{y}=%
\begin{bmatrix}+1/2\\
0\\
-1/2\end{bmatrix}*L.
  </annotation>
 </semantics>
</math>

</p>

<p>The well-known and earlier <a href="Sobel_operator" title="wikilink">Sobel operator</a> is based on the following filters:</p>

<p>

<math display="block" id="Edge_detection:9">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>L</mi>
      <mi>x</mi>
     </msub>
     <mo>=</mo>
     <mrow>
      <mrow>
       <mrow>
        <mo>[</mo>
        <mtable displaystyle="true">
         <mtr>
          <mtd columnalign="center">
           <mrow>
            <mo>-</mo>
            <mn>1</mn>
           </mrow>
          </mtd>
          <mtd columnalign="center">
           <mn>0</mn>
          </mtd>
          <mtd columnalign="center">
           <mrow>
            <mo>+</mo>
            <mn>1</mn>
           </mrow>
          </mtd>
         </mtr>
         <mtr>
          <mtd columnalign="center">
           <mrow>
            <mo>-</mo>
            <mn>2</mn>
           </mrow>
          </mtd>
          <mtd columnalign="center">
           <mn>0</mn>
          </mtd>
          <mtd columnalign="center">
           <mrow>
            <mo>+</mo>
            <mn>2</mn>
           </mrow>
          </mtd>
         </mtr>
         <mtr>
          <mtd columnalign="center">
           <mrow>
            <mo>-</mo>
            <mn>1</mn>
           </mrow>
          </mtd>
          <mtd columnalign="center">
           <mn>0</mn>
          </mtd>
          <mtd columnalign="center">
           <mrow>
            <mo>+</mo>
            <mn>1</mn>
           </mrow>
          </mtd>
         </mtr>
        </mtable>
        <mo>]</mo>
       </mrow>
       <mo>*</mo>
       <mi>L</mi>
      </mrow>
      <mtext>and</mtext>
     </mrow>
    </mrow>
    <mrow>
     <msub>
      <mi>L</mi>
      <mi>y</mi>
     </msub>
     <mo>=</mo>
     <mrow>
      <mrow>
       <mo>[</mo>
       <mtable displaystyle="true">
        <mtr>
         <mtd columnalign="center">
          <mrow>
           <mo>+</mo>
           <mn>1</mn>
          </mrow>
         </mtd>
         <mtd columnalign="center">
          <mrow>
           <mo>+</mo>
           <mn>2</mn>
          </mrow>
         </mtd>
         <mtd columnalign="center">
          <mrow>
           <mo>+</mo>
           <mn>1</mn>
          </mrow>
         </mtd>
        </mtr>
        <mtr>
         <mtd columnalign="center">
          <mn>0</mn>
         </mtd>
         <mtd columnalign="center">
          <mn>0</mn>
         </mtd>
         <mtd columnalign="center">
          <mn>0</mn>
         </mtd>
        </mtr>
        <mtr>
         <mtd columnalign="center">
          <mrow>
           <mo>-</mo>
           <mn>1</mn>
          </mrow>
         </mtd>
         <mtd columnalign="center">
          <mrow>
           <mo>-</mo>
           <mn>2</mn>
          </mrow>
         </mtd>
         <mtd columnalign="center">
          <mrow>
           <mo>-</mo>
           <mn>1</mn>
          </mrow>
         </mtd>
        </mtr>
       </mtable>
       <mo>]</mo>
      </mrow>
      <mo>*</mo>
      <mi>L</mi>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>L</ci>
      <ci>x</ci>
     </apply>
     <list>
      <apply>
       <times></times>
       <matrix>
        <matrixrow>
         <apply>
          <minus></minus>
          <cn type="integer">1</cn>
         </apply>
         <cn type="integer">0</cn>
         <apply>
          <plus></plus>
          <cn type="integer">1</cn>
         </apply>
        </matrixrow>
        <matrixrow>
         <apply>
          <minus></minus>
          <cn type="integer">2</cn>
         </apply>
         <cn type="integer">0</cn>
         <apply>
          <plus></plus>
          <cn type="integer">2</cn>
         </apply>
        </matrixrow>
        <matrixrow>
         <apply>
          <minus></minus>
          <cn type="integer">1</cn>
         </apply>
         <cn type="integer">0</cn>
         <apply>
          <plus></plus>
          <cn type="integer">1</cn>
         </apply>
        </matrixrow>
       </matrix>
       <ci>L</ci>
      </apply>
      <mtext>and</mtext>
     </list>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>L</ci>
      <ci>y</ci>
     </apply>
     <apply>
      <times></times>
      <matrix>
       <matrixrow>
        <apply>
         <plus></plus>
         <cn type="integer">1</cn>
        </apply>
        <apply>
         <plus></plus>
         <cn type="integer">2</cn>
        </apply>
        <apply>
         <plus></plus>
         <cn type="integer">1</cn>
        </apply>
       </matrixrow>
       <matrixrow>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
       </matrixrow>
       <matrixrow>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
        </apply>
        <apply>
         <minus></minus>
         <cn type="integer">2</cn>
        </apply>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
        </apply>
       </matrixrow>
      </matrix>
      <ci>L</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L_{x}=\begin{bmatrix}-1&0&+1\\
-2&0&+2\\
-1&0&+1\end{bmatrix}*L\quad\mbox{and}\quad L_{y}=\begin{bmatrix}+1&+2&+1\\
0&0&0\\
-1&-2&-1\end{bmatrix}*L.
  </annotation>
 </semantics>
</math>

</p>

<p>Given such estimates of first-order <a href="Image_Derivatives" title="wikilink">image derivatives</a>, the gradient magnitude is then computed as:</p>

<p>

<math display="block" id="Edge_detection:10">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">|</mo>
    <mrow>
     <mo>∇</mo>
     <mi>L</mi>
    </mrow>
    <mo stretchy="false">|</mo>
   </mrow>
   <mo>=</mo>
   <msqrt>
    <mrow>
     <msubsup>
      <mi>L</mi>
      <mi>x</mi>
      <mn>2</mn>
     </msubsup>
     <mo>+</mo>
     <msubsup>
      <mi>L</mi>
      <mi>y</mi>
      <mn>2</mn>
     </msubsup>
    </mrow>
   </msqrt>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <abs></abs>
     <apply>
      <ci>normal-∇</ci>
      <ci>L</ci>
     </apply>
    </apply>
    <apply>
     <root></root>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>L</ci>
        <ci>x</ci>
       </apply>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>L</ci>
        <ci>y</ci>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\nabla L|=\sqrt{L_{x}^{2}+L_{y}^{2}}
  </annotation>
 </semantics>
</math>

</p>

<p>while the gradient orientation can be estimated as</p>

<p>

<math display="block" id="Edge_detection:11">
 <semantics>
  <mrow>
   <mrow>
    <mi>θ</mi>
    <mo>=</mo>
    <mrow>
     <mo>atan2</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>L</mi>
       <mi>y</mi>
      </msub>
      <mo>,</mo>
      <msub>
       <mi>L</mi>
       <mi>x</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>θ</ci>
    <apply>
     <ci>atan2</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>L</ci>
      <ci>y</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>L</ci>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta=\operatorname{atan2}(L_{y},L_{x}).
  </annotation>
 </semantics>
</math>

</p>

<p>Other first-order difference operators for estimating image gradient have been proposed in the <a class="uri" href="Prewitt" title="wikilink">Prewitt</a> operator, <a href="Roberts_Cross" title="wikilink">Roberts cross</a> and <a class="uri" href="Frei-Chen" title="wikilink">Frei-Chen</a>.</p>

<p>It is possible to extend filters dimension to avoid the issue of recognizing edge in low SNR image. The cost of this operation is loss in terms of resolution. Examples are Extended Prewitt 7x7 and <a class="uri" href="Abdou" title="wikilink">Abdou</a></p>
<h3 id="thresholding-and-linking">Thresholding and linking</h3>

<p>Once we have computed a measure of edge strength (typically the gradient magnitude), the next stage is to apply a threshold, to decide whether edges are present or not at an image point. The lower the threshold, the more edges will be detected, and the result will be increasingly susceptible to <a href="image_noise" title="wikilink">noise</a> and detecting edges of irrelevant features in the image. Conversely a high threshold may miss subtle edges, or result in fragmented edges.</p>

<p>If the edge thresholding is applied to just the gradient magnitude image, the resulting edges will in general be thick and some type of edge thinning post-processing is necessary. For edges detected with non-maximum suppression however, the edge curves are thin by definition and the edge pixels can be linked into edge polygon by an edge linking (edge tracking) procedure. On a discrete grid, the non-maximum suppression stage can be implemented by estimating the gradient direction using first-order derivatives, then rounding off the gradient direction to multiples of 45 degrees, and finally comparing the values of the gradient magnitude in the estimated gradient direction.</p>

<p>A commonly used approach to handle the problem of appropriate thresholds for thresholding is by using <a href="Adaptive_thresholding" title="wikilink">thresholding</a> with <a class="uri" href="hysteresis" title="wikilink">hysteresis</a>. This method uses multiple thresholds to find edges. We begin by using the upper threshold to find the start of an edge. Once we have a start point, we then trace the path of the edge through the image pixel by pixel, marking an edge whenever we are above the lower threshold. We stop marking our edge only when the value falls below our lower threshold. This approach makes the assumption that edges are likely to be in continuous curves, and allows us to follow a faint section of an edge we have previously seen, without meaning that every noisy pixel in the image is marked down as an edge. Still, however, we have the problem of choosing appropriate thresholding parameters, and suitable thresholding values may vary over the image.</p>
<h3 id="edge-thinning">Edge thinning</h3>

<p>Edge thinning is a technique used to remove the unwanted spurious points on the edges in an image. This technique is employed after the image has been filtered for noise (using median, Gaussian filter etc.), the edge operator has been applied (like the ones described above) to detect the edges and after the edges have been smoothed using an appropriate threshold value. This removes all the unwanted points and if applied carefully, results in one pixel thick edge elements.</p>

<p>Advantages:</p>
<ol>
<li>Sharp and thin edges lead to greater efficiency in object recognition.</li>
<li>If <a href="Hough_transform" title="wikilink">Hough transforms</a> are used to detect lines and ellipses, then thinning could give much better results.</li>
<li>If the edge happens to be the boundary of a region, then thinning could easily give the image parameters like perimeter without much algebra.</li>
</ol>

<p>There are many popular algorithms used to do this, one such is described below:</p>
<ol>
<li>Choose a type of connectivity, like 8, 6 or 4.</li>
<li>8 connectivity is preferred, where all the immediate pixels surrounding a particular pixel are considered.</li>
<li>Remove points from North, south, east and west.</li>
<li>Do this in multiple passes, i.e. after the north pass, use the same semi processed image in the other passes and so on.</li>
<li>Remove a point if:<br/>
The point has no neighbors in the North (if you are in the north pass, and respective directions for other passes).<br/>
The point is not the end of a line.<br/>
The point is isolated.<br/>
Removing the points will not cause to disconnect its neighbors in any way.</li>
<li>Else keep the point.</li>
</ol>

<p>The number of passes across direction should be chosen according to the level of accuracy desired.</p>
<h3 id="second-order-approaches-to-edge-detection">Second-order approaches to edge detection</h3>

<p>Some edge-detection operators are instead based upon second-order derivatives of the intensity. This essentially captures the <a href="Derivative" title="wikilink">rate of change</a> in the intensity gradient. Thus, in the ideal continuous case, detection of zero-crossings in the second derivative captures local maxima in the gradient.</p>

<p>The early <a href="Marr-Hildreth_algorithm" title="wikilink">Marr-Hildreth</a> operator is based on the detection of zero-crossings of the Laplacian operator applied to a Gaussian-smoothed image. It can be shown, however, that this operator will also return false edges corresponding to local minima of the gradient magnitude. Moreover, this operator will give poor localization at curved edges. Hence, this operator is today mainly of historical interest.</p>
<h4 id="differential-edge-detection">Differential edge detection</h4>

<p>A more refined second-order edge detection approach which automatically detects edges with sub-pixel accuracy, uses the following <em>differential approach</em> of detecting zero-crossings of the second-order directional derivative in the gradient direction:</p>

<p>Following the differential geometric way of expressing the requirement of non-maximum suppression proposed by Lindeberg,<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a><a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a> let us introduce at every image point a local coordinate system 

<math display="inline" id="Edge_detection:12">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>u</mi>
   <mo>,</mo>
   <mi>v</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>u</ci>
    <ci>v</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (u,v)
  </annotation>
 </semantics>
</math>

, with the 

<math display="inline" id="Edge_detection:13">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>

-direction parallel to the gradient direction. Assuming that the image has been pre-smoothed by Gaussian smoothing and a <a href="scale_space_representation" title="wikilink">scale space representation</a> 

<math display="inline" id="Edge_detection:14">
 <semantics>
  <mrow>
   <mi>L</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>y</mi>
    <mo>;</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>L</ci>
    <vector>
     <ci>x</ci>
     <ci>y</ci>
     <ci>t</ci>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L(x,y;t)
  </annotation>
 </semantics>
</math>

 at scale 

<math display="inline" id="Edge_detection:15">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 has been computed, we can require that the gradient magnitude of the <a href="scale_space_representation" title="wikilink">scale space representation</a>, which is equal to the first-order directional derivative in the 

<math display="inline" id="Edge_detection:16">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>

-direction 

<math display="inline" id="Edge_detection:17">
 <semantics>
  <msub>
   <mi>L</mi>
   <mi>v</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>L</ci>
    <ci>v</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L_{v}
  </annotation>
 </semantics>
</math>

, should have its first order directional derivative in the 

<math display="inline" id="Edge_detection:18">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>

-direction equal to zero</p>

<p>

<math display="block" id="Edge_detection:19">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mo>∂</mo>
     <mi>v</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>L</mi>
      <mi>v</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <partialdiff></partialdiff>
      <ci>v</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>L</ci>
      <ci>v</ci>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \partial_{v}(L_{v})=0
  </annotation>
 </semantics>
</math>

 while the second-order directional derivative in the 

<math display="inline" id="Edge_detection:20">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>

-direction of 

<math display="inline" id="Edge_detection:21">
 <semantics>
  <msub>
   <mi>L</mi>
   <mi>v</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>L</ci>
    <ci>v</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L_{v}
  </annotation>
 </semantics>
</math>

 should be negative, i.e.,</p>

<p>

<math display="block" id="Edge_detection:22">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mo>∂</mo>
     <mrow>
      <mi>v</mi>
      <mi>v</mi>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>L</mi>
      <mi>v</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mn>0.</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <partialdiff></partialdiff>
      <apply>
       <times></times>
       <ci>v</ci>
       <ci>v</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>L</ci>
      <ci>v</ci>
     </apply>
    </apply>
    <cn type="float">0.</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \partial_{vv}(L_{v})\leq 0.
  </annotation>
 </semantics>
</math>

 Written out as an explicit expression in terms of local partial derivatives 

<math display="inline" id="Edge_detection:23">
 <semantics>
  <msub>
   <mi>L</mi>
   <mi>x</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>L</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L_{x}
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Edge_detection:24">
 <semantics>
  <msub>
   <mi>L</mi>
   <mi>y</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>L</ci>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L_{y}
  </annotation>
 </semantics>
</math>

 ... 

<math display="inline" id="Edge_detection:25">
 <semantics>
  <msub>
   <mi>L</mi>
   <mrow>
    <mi>y</mi>
    <mi>y</mi>
    <mi>y</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>L</ci>
    <apply>
     <times></times>
     <ci>y</ci>
     <ci>y</ci>
     <ci>y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L_{yyy}
  </annotation>
 </semantics>
</math>

, this edge definition can be expressed as the zero-crossing curves of the differential invariant</p>

<p>

<math display="block" id="Edge_detection:26">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msubsup>
      <mi>L</mi>
      <mi>v</mi>
      <mn>2</mn>
     </msubsup>
     <msub>
      <mi>L</mi>
      <mrow>
       <mi>v</mi>
       <mi>v</mi>
      </mrow>
     </msub>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mpadded width="+1.7pt">
       <msubsup>
        <mi>L</mi>
        <mi>x</mi>
        <mn>2</mn>
       </msubsup>
      </mpadded>
      <msub>
       <mi>L</mi>
       <mrow>
        <mi>x</mi>
        <mi>x</mi>
       </mrow>
      </msub>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mpadded width="+1.7pt">
       <mn>2</mn>
      </mpadded>
      <mpadded width="+1.7pt">
       <msub>
        <mi>L</mi>
        <mi>x</mi>
       </msub>
      </mpadded>
      <mpadded width="+1.7pt">
       <msub>
        <mi>L</mi>
        <mi>y</mi>
       </msub>
      </mpadded>
      <msub>
       <mi>L</mi>
       <mrow>
        <mi>x</mi>
        <mi>y</mi>
       </mrow>
      </msub>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mpadded width="+1.7pt">
       <msubsup>
        <mi>L</mi>
        <mi>y</mi>
        <mn>2</mn>
       </msubsup>
      </mpadded>
      <msub>
       <mi>L</mi>
       <mrow>
        <mi>y</mi>
        <mi>y</mi>
       </mrow>
      </msub>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mn>0</mn>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>L</ci>
        <ci>v</ci>
       </apply>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>L</ci>
       <apply>
        <times></times>
        <ci>v</ci>
        <ci>v</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>L</ci>
         <ci>x</ci>
        </apply>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>L</ci>
        <apply>
         <times></times>
         <ci>x</ci>
         <ci>x</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>L</ci>
        <ci>x</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>L</ci>
        <ci>y</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>L</ci>
        <apply>
         <times></times>
         <ci>x</ci>
         <ci>y</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>L</ci>
         <ci>y</ci>
        </apply>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>L</ci>
        <apply>
         <times></times>
         <ci>y</ci>
         <ci>y</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L_{v}^{2}L_{vv}=L_{x}^{2}\,L_{xx}+2\,L_{x}\,L_{y}\,L_{xy}+L_{y}^{2}\,L_{yy}=0,
  </annotation>
 </semantics>
</math>

 that satisfy a sign-condition on the following differential invariant</p>

<p>

<math display="block" id="Edge_detection:27">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mi>L</mi>
     <mi>v</mi>
     <mn>3</mn>
    </msubsup>
    <msub>
     <mi>L</mi>
     <mrow>
      <mi>v</mi>
      <mi>v</mi>
      <mi>v</mi>
     </mrow>
    </msub>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mpadded width="+1.7pt">
      <msubsup>
       <mi>L</mi>
       <mi>x</mi>
       <mn>3</mn>
      </msubsup>
     </mpadded>
     <msub>
      <mi>L</mi>
      <mrow>
       <mi>x</mi>
       <mi>x</mi>
       <mi>x</mi>
      </mrow>
     </msub>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mpadded width="+1.7pt">
      <mn>3</mn>
     </mpadded>
     <mpadded width="+1.7pt">
      <msubsup>
       <mi>L</mi>
       <mi>x</mi>
       <mn>2</mn>
      </msubsup>
     </mpadded>
     <mpadded width="+1.7pt">
      <msub>
       <mi>L</mi>
       <mi>y</mi>
      </msub>
     </mpadded>
     <msub>
      <mi>L</mi>
      <mrow>
       <mi>x</mi>
       <mi>x</mi>
       <mi>y</mi>
      </mrow>
     </msub>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mpadded width="+1.7pt">
      <mn>3</mn>
     </mpadded>
     <mpadded width="+1.7pt">
      <msub>
       <mi>L</mi>
       <mi>x</mi>
      </msub>
     </mpadded>
     <mpadded width="+1.7pt">
      <msubsup>
       <mi>L</mi>
       <mi>y</mi>
       <mn>2</mn>
      </msubsup>
     </mpadded>
     <msub>
      <mi>L</mi>
      <mrow>
       <mi>x</mi>
       <mi>y</mi>
       <mi>y</mi>
      </mrow>
     </msub>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mpadded width="+1.7pt">
      <msubsup>
       <mi>L</mi>
       <mi>y</mi>
       <mn>3</mn>
      </msubsup>
     </mpadded>
     <msub>
      <mi>L</mi>
      <mrow>
       <mi>y</mi>
       <mi>y</mi>
       <mi>y</mi>
      </mrow>
     </msub>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>L</ci>
        <ci>v</ci>
       </apply>
       <cn type="integer">3</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>L</ci>
       <apply>
        <times></times>
        <ci>v</ci>
        <ci>v</ci>
        <ci>v</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>L</ci>
         <ci>x</ci>
        </apply>
        <cn type="integer">3</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>L</ci>
        <apply>
         <times></times>
         <ci>x</ci>
         <ci>x</ci>
         <ci>x</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <cn type="integer">3</cn>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>L</ci>
         <ci>x</ci>
        </apply>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>L</ci>
        <ci>y</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>L</ci>
        <apply>
         <times></times>
         <ci>x</ci>
         <ci>x</ci>
         <ci>y</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <cn type="integer">3</cn>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>L</ci>
        <ci>x</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>L</ci>
         <ci>y</ci>
        </apply>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>L</ci>
        <apply>
         <times></times>
         <ci>x</ci>
         <ci>y</ci>
         <ci>y</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>L</ci>
         <ci>y</ci>
        </apply>
        <cn type="integer">3</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>L</ci>
        <apply>
         <times></times>
         <ci>y</ci>
         <ci>y</ci>
         <ci>y</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L_{v}^{3}L_{vvv}=L_{x}^{3}\,L_{xxx}+3\,L_{x}^{2}\,L_{y}\,L_{xxy}+3\,L_{x}\,L_{%
y}^{2}\,L_{xyy}+L_{y}^{3}\,L_{yyy}\leq 0
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Edge_detection:28">
 <semantics>
  <msub>
   <mi>L</mi>
   <mi>x</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>L</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L_{x}
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Edge_detection:29">
 <semantics>
  <msub>
   <mi>L</mi>
   <mi>y</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>L</ci>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L_{y}
  </annotation>
 </semantics>
</math>

 ... 

<math display="inline" id="Edge_detection:30">
 <semantics>
  <msub>
   <mi>L</mi>
   <mrow>
    <mi>y</mi>
    <mi>y</mi>
    <mi>y</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>L</ci>
    <apply>
     <times></times>
     <ci>y</ci>
     <ci>y</ci>
     <ci>y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L_{yyy}
  </annotation>
 </semantics>
</math>

 denote partial derivatives computed from a <a href="scale_space_representation" title="wikilink">scale space representation</a> 

<math display="inline" id="Edge_detection:31">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

 obtained by smoothing the original image with a Gaussian kernel. In this way, the edges will be automatically obtained as continuous curves with sub-pixel accuracy. Hysteresis thresholding can also be applied to these differential and subpixel edge segments.</p>

<p>In practice, first-order derivative approximations can be computed by central differences as described above, while second-order derivatives can be computed from the <a href="scale_space_representation" title="wikilink">scale space representation</a> 

<math display="inline" id="Edge_detection:32">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

 according to:</p>

<p>

<math display="block" id="Edge_detection:33">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>L</mi>
      <mrow>
       <mi>x</mi>
       <mi>x</mi>
      </mrow>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mi>y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mrow>
       <mi>L</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>x</mi>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
        <mo>,</mo>
        <mi>y</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>-</mo>
      <mrow>
       <mn>2</mn>
       <mi>L</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo>,</mo>
        <mi>y</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mi>L</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>x</mi>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
       <mo>,</mo>
       <mi>y</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>L</ci>
      <apply>
       <times></times>
       <ci>x</ci>
       <ci>x</ci>
      </apply>
     </apply>
     <interval closure="open">
      <ci>x</ci>
      <ci>y</ci>
     </interval>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>L</ci>
       <interval closure="open">
        <apply>
         <minus></minus>
         <ci>x</ci>
         <cn type="integer">1</cn>
        </apply>
        <ci>y</ci>
       </interval>
      </apply>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>L</ci>
       <interval closure="open">
        <ci>x</ci>
        <ci>y</ci>
       </interval>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>L</ci>
      <interval closure="open">
       <apply>
        <plus></plus>
        <ci>x</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>y</ci>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L_{xx}(x,y)=L(x-1,y)-2L(x,y)+L(x+1,y).\,
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Edge_detection:34">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>L</mi>
      <mrow>
       <mi>x</mi>
       <mi>y</mi>
      </mrow>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mi>y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <mrow>
         <mi>L</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <mi>x</mi>
           <mo>-</mo>
           <mn>1</mn>
          </mrow>
          <mo>,</mo>
          <mrow>
           <mi>y</mi>
           <mo>-</mo>
           <mn>1</mn>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>-</mo>
        <mrow>
         <mi>L</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <mi>x</mi>
           <mo>-</mo>
           <mn>1</mn>
          </mrow>
          <mo>,</mo>
          <mrow>
           <mi>y</mi>
           <mo>+</mo>
           <mn>1</mn>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>-</mo>
        <mrow>
         <mi>L</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <mi>x</mi>
           <mo>+</mo>
           <mn>1</mn>
          </mrow>
          <mo>,</mo>
          <mrow>
           <mi>y</mi>
           <mo>-</mo>
           <mn>1</mn>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
       <mo>+</mo>
       <mrow>
        <mi>L</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mi>x</mi>
          <mo>+</mo>
          <mn>1</mn>
         </mrow>
         <mo>,</mo>
         <mrow>
          <mi>y</mi>
          <mo>+</mo>
          <mn>1</mn>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>/</mo>
     <mn>4</mn>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>L</ci>
      <apply>
       <times></times>
       <ci>x</ci>
       <ci>y</ci>
      </apply>
     </apply>
     <interval closure="open">
      <ci>x</ci>
      <ci>y</ci>
     </interval>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <plus></plus>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <ci>L</ci>
        <interval closure="open">
         <apply>
          <minus></minus>
          <ci>x</ci>
          <cn type="integer">1</cn>
         </apply>
         <apply>
          <minus></minus>
          <ci>y</ci>
          <cn type="integer">1</cn>
         </apply>
        </interval>
       </apply>
       <apply>
        <times></times>
        <ci>L</ci>
        <interval closure="open">
         <apply>
          <minus></minus>
          <ci>x</ci>
          <cn type="integer">1</cn>
         </apply>
         <apply>
          <plus></plus>
          <ci>y</ci>
          <cn type="integer">1</cn>
         </apply>
        </interval>
       </apply>
       <apply>
        <times></times>
        <ci>L</ci>
        <interval closure="open">
         <apply>
          <plus></plus>
          <ci>x</ci>
          <cn type="integer">1</cn>
         </apply>
         <apply>
          <minus></minus>
          <ci>y</ci>
          <cn type="integer">1</cn>
         </apply>
        </interval>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>L</ci>
       <interval closure="open">
        <apply>
         <plus></plus>
         <ci>x</ci>
         <cn type="integer">1</cn>
        </apply>
        <apply>
         <plus></plus>
         <ci>y</ci>
         <cn type="integer">1</cn>
        </apply>
       </interval>
      </apply>
     </apply>
     <cn type="integer">4</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L_{xy}(x,y)=(L(x-1,y-1)-L(x-1,y+1)-L(x+1,y-1)+L(x+1,y+1))/4,\,
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Edge_detection:35">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>L</mi>
      <mrow>
       <mi>y</mi>
       <mi>y</mi>
      </mrow>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mi>y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mrow>
       <mi>L</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo>,</mo>
        <mrow>
         <mi>y</mi>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>-</mo>
      <mrow>
       <mn>2</mn>
       <mi>L</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo>,</mo>
        <mi>y</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mi>L</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo>,</mo>
       <mrow>
        <mi>y</mi>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>L</ci>
      <apply>
       <times></times>
       <ci>y</ci>
       <ci>y</ci>
      </apply>
     </apply>
     <interval closure="open">
      <ci>x</ci>
      <ci>y</ci>
     </interval>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>L</ci>
       <interval closure="open">
        <ci>x</ci>
        <apply>
         <minus></minus>
         <ci>y</ci>
         <cn type="integer">1</cn>
        </apply>
       </interval>
      </apply>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>L</ci>
       <interval closure="open">
        <ci>x</ci>
        <ci>y</ci>
       </interval>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>L</ci>
      <interval closure="open">
       <ci>x</ci>
       <apply>
        <plus></plus>
        <ci>y</ci>
        <cn type="integer">1</cn>
       </apply>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L_{yy}(x,y)=L(x,y-1)-2L(x,y)+L(x,y+1).\,
  </annotation>
 </semantics>
</math>

</p>

<p>corresponding to the following filter masks:</p>

<p>

<math display="block" id="Edge_detection:36">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>L</mi>
      <mrow>
       <mi>x</mi>
       <mi>x</mi>
      </mrow>
     </msub>
     <mo>=</mo>
     <mrow>
      <mrow>
       <mrow>
        <mo>[</mo>
        <mtable displaystyle="true">
         <mtr>
          <mtd columnalign="center">
           <mn>1</mn>
          </mtd>
          <mtd columnalign="center">
           <mrow>
            <mo>-</mo>
            <mn>2</mn>
           </mrow>
          </mtd>
          <mtd columnalign="center">
           <mn>1</mn>
          </mtd>
         </mtr>
        </mtable>
        <mo>]</mo>
       </mrow>
       <mo>*</mo>
       <mi>L</mi>
      </mrow>
      <mtext>and</mtext>
     </mrow>
    </mrow>
    <mrow>
     <mrow>
      <msub>
       <mi>L</mi>
       <mrow>
        <mi>x</mi>
        <mi>y</mi>
       </mrow>
      </msub>
      <mo>=</mo>
      <mrow>
       <mrow>
        <mrow>
         <mo>[</mo>
         <mtable displaystyle="true">
          <mtr>
           <mtd columnalign="center">
            <mrow>
             <mo>-</mo>
             <mrow>
              <mn>1</mn>
              <mo>/</mo>
              <mn>4</mn>
             </mrow>
            </mrow>
           </mtd>
           <mtd columnalign="center">
            <mn>0</mn>
           </mtd>
           <mtd columnalign="center">
            <mrow>
             <mn>1</mn>
             <mo>/</mo>
             <mn>4</mn>
            </mrow>
           </mtd>
          </mtr>
          <mtr>
           <mtd columnalign="center">
            <mn>0</mn>
           </mtd>
           <mtd columnalign="center">
            <mn>0</mn>
           </mtd>
           <mtd columnalign="center">
            <mn>0</mn>
           </mtd>
          </mtr>
          <mtr>
           <mtd columnalign="center">
            <mrow>
             <mn>1</mn>
             <mo>/</mo>
             <mn>4</mn>
            </mrow>
           </mtd>
           <mtd columnalign="center">
            <mn>0</mn>
           </mtd>
           <mtd columnalign="center">
            <mrow>
             <mo>-</mo>
             <mrow>
              <mn>1</mn>
              <mo>/</mo>
              <mn>4</mn>
             </mrow>
            </mrow>
           </mtd>
          </mtr>
         </mtable>
         <mo>]</mo>
        </mrow>
        <mo>*</mo>
        <mi>L</mi>
       </mrow>
       <mtext>and</mtext>
      </mrow>
     </mrow>
     <mrow>
      <msub>
       <mi>L</mi>
       <mrow>
        <mi>y</mi>
        <mi>y</mi>
       </mrow>
      </msub>
      <mo>=</mo>
      <mrow>
       <mrow>
        <mo>[</mo>
        <mtable displaystyle="true">
         <mtr>
          <mtd columnalign="center">
           <mn>1</mn>
          </mtd>
         </mtr>
         <mtr>
          <mtd columnalign="center">
           <mrow>
            <mo>-</mo>
            <mn>2</mn>
           </mrow>
          </mtd>
         </mtr>
         <mtr>
          <mtd columnalign="center">
           <mn>1</mn>
          </mtd>
         </mtr>
        </mtable>
        <mo>]</mo>
       </mrow>
       <mo>*</mo>
       <mi>L</mi>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>L</ci>
      <apply>
       <times></times>
       <ci>x</ci>
       <ci>x</ci>
      </apply>
     </apply>
     <list>
      <apply>
       <times></times>
       <matrix>
        <matrixrow>
         <cn type="integer">1</cn>
         <apply>
          <minus></minus>
          <cn type="integer">2</cn>
         </apply>
         <cn type="integer">1</cn>
        </matrixrow>
       </matrix>
       <ci>L</ci>
      </apply>
      <mtext>and</mtext>
     </list>
    </apply>
    <apply>
     <csymbol cd="ambiguous">formulae-sequence</csymbol>
     <apply>
      <eq></eq>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>L</ci>
       <apply>
        <times></times>
        <ci>x</ci>
        <ci>y</ci>
       </apply>
      </apply>
      <list>
       <apply>
        <times></times>
        <matrix>
         <matrixrow>
          <apply>
           <minus></minus>
           <apply>
            <divide></divide>
            <cn type="integer">1</cn>
            <cn type="integer">4</cn>
           </apply>
          </apply>
          <cn type="integer">0</cn>
          <apply>
           <divide></divide>
           <cn type="integer">1</cn>
           <cn type="integer">4</cn>
          </apply>
         </matrixrow>
         <matrixrow>
          <cn type="integer">0</cn>
          <cn type="integer">0</cn>
          <cn type="integer">0</cn>
         </matrixrow>
         <matrixrow>
          <apply>
           <divide></divide>
           <cn type="integer">1</cn>
           <cn type="integer">4</cn>
          </apply>
          <cn type="integer">0</cn>
          <apply>
           <minus></minus>
           <apply>
            <divide></divide>
            <cn type="integer">1</cn>
            <cn type="integer">4</cn>
           </apply>
          </apply>
         </matrixrow>
        </matrix>
        <ci>L</ci>
       </apply>
       <mtext>and</mtext>
      </list>
     </apply>
     <apply>
      <eq></eq>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>L</ci>
       <apply>
        <times></times>
        <ci>y</ci>
        <ci>y</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <matrix>
        <matrixrow>
         <cn type="integer">1</cn>
        </matrixrow>
        <matrixrow>
         <apply>
          <minus></minus>
          <cn type="integer">2</cn>
         </apply>
        </matrixrow>
        <matrixrow>
         <cn type="integer">1</cn>
        </matrixrow>
       </matrix>
       <ci>L</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L_{xx}=\begin{bmatrix}1&-2&1\end{bmatrix}*L\quad\mbox{and}\quad L_{xy}=\begin{%
bmatrix}-1/4&0&1/4\\
0&0&0\\
1/4&0&-1/4\end{bmatrix}*L\quad\mbox{and}\quad L_{yy}=\begin{bmatrix}1\\
-2\\
1\end{bmatrix}*L.
  </annotation>
 </semantics>
</math>

</p>

<p>Higher-order derivatives for the third-order sign condition can be obtained in an analogous fashion.</p>
<h3 id="phase-congruency-based-edge-detection">Phase congruency-based edge detection</h3>

<p>A recent development in edge detection techniques takes a frequency domain approach to finding edge locations. <a href="Phase_congruency" title="wikilink">Phase congruency</a> (also known as phase coherence) methods attempt to find locations in an image where all sinusoids in the frequency domain are in phase. These locations will generally correspond to the location of a perceived edge, regardless of whether the edge is represented by a large change in intensity in the spatial domain. A key benefit of this technique is that it responds strongly to <a href="Mach_bands" title="wikilink">Mach bands</a>, and avoids false positives typically found around <a href="roof_edge" title="wikilink">roof edges</a>. A roof edge, is a discontinuity in the first order derivative of a grey-level profile.<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a class="uri" href="Convolution#Applications" title="wikilink">Convolution#Applications</a></li>
<li><a href="Feature_detection_(computer_vision)" title="wikilink">Feature detection (computer vision)</a> for other low-level feature detectors</li>
<li><a href="Image_Derivatives" title="wikilink">Image derivatives</a></li>
<li><a href="Gabor_filter" title="wikilink">Gabor filter</a></li>
<li><a href="Image_noise_reduction" title="wikilink">Image noise reduction</a></li>
<li><a href="Kirsch_operator" title="wikilink">Kirsch operator</a> for edge detection in the compass directions</li>
<li><a href="Ridge_detection" title="wikilink">Ridge detection</a> for relations between edge detectors and ridge detectors</li>
</ul>
<h2 id="references">References</h2>
<references>
</references>
<h2 id="further-reading">Further reading</h2>
<ul>
<li></li>
<li><a href="http://mrw.interscience.wiley.com/emrw/9780470050118/ecse/article/ecse603/current/abstract">Entry on edge detection in Encyclopedia of Computer Science and Engineering</a></li>
<li><a href="http://edge.kitiyo.com/">Edge Detection using FPGA</a></li>
<li><a href=":doi:10.5201/ipol.2012.gjmr-lsd" title="wikilink">A-contrario line segment detection with code and on-line demonstration</a></li>
<li><a href="http://www.mathworks.com/help/images/detect-edges-in-images.html">Edge detection using MATLAB</a></li>
</ul>

<p>"</p>

<p><a href="Category:Feature_detection_(computer_vision)" title="wikilink">Category:Feature detection (computer vision)</a> <a href="Category:Image_processing" title="wikilink">Category:Image processing</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2">H.G. Barrow and J.M. Tenenbaum (1981) "Interpreting line drawings as three-dimensional surfaces", Artificial Intelligence, vol 17, issues 1-3, pages 75-116.<a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="http://www.nada.kth.se/cvap/abstracts/cvap191.html">T. Lindeberg (1998) "Edge detection and ridge detection with automatic scale selection", International Journal of Computer Vision, 30, 2, pages 117--154.</a><a href="#fnref4">↩</a></li>
<li id="fn5"></li>
<li id="fn6">W. Zhang and F. Bergholm (1997) "Multi-scale blur estimation and edge type classification for scene analysis", International Journal of Computer Vision, vol 24, issue 3, Pages: 219 - 250.<a href="#fnref6">↩</a></li>
<li id="fn7"></li>
<li id="fn8">D. Ziou and S. Tabbone (1998) "Edge detection techniques: An overview", International Journal of Pattern Recognition and Image Analysis, 8(4):537–559, 1998<a href="#fnref8">↩</a></li>
<li id="fn9"></li>
<li id="fn10"><a href="http://mrw.interscience.wiley.com/emrw/9780470050118/ecse/article/ecse603/current/abstract">J. M. Park and Y. Lu (2008) "Edge detection in grayscale, color, and range images", in B. W. Wah (editor) Encyclopedia of Computer Science and Engineering, doi 10.1002/9780470050118.ecse603</a><a href="#fnref10">↩</a></li>
<li id="fn11">J. Canny (1986) "A computational approach to edge detection", IEEE Trans. Pattern Analysis and Machine Intelligence, vol 8, pages 679-714.<a href="#fnref11">↩</a></li>
<li id="fn12">R. Haralick, (1984) "Digital step edges from zero crossing of second directional derivatives", IEEE Trans. on Pattern Analysis and Machine Intelligence, 6(1):58–68.<a href="#fnref12">↩</a></li>
<li id="fn13"><a href="http://www.cs.technion.ac.il/~ron/PAPERS/laplacian_ijcv2003.pdf">R. Kimmel and A.M. Bruckstein (2003) "On regularized Laplacian zero crossings and other optimal edge integrators", <em>International Journal of Computer Vision</em>, 53(3) pages 225-243.</a><a href="#fnref13">↩</a></li>
<li id="fn14">Shapiro L.G. &amp; Stockman G.C. (2001) Computer Vision. London etc.: Prentice Hall, Page 326.<a href="#fnref14">↩</a></li>
<li id="fn15">R. Deriche (1987) <em>Using Canny's criteria to derive an optimal edge detector recursively implemented</em>, Int. J. Computer Vision, vol 1, pages 167–187.<a href="#fnref15">↩</a></li>
<li id="fn16"></li>
<li id="fn17"><a href="http://www.nada.kth.se/~tony/abstracts/Lin93-JMIV.html">T. Lindeberg (1993) "Discrete derivative approximations with scale-space properties: A basis for low-level feature extraction", J. of Mathematical Imaging and Vision, 3(4), pages 349--376.</a><a href="#fnref17">↩</a></li>
<li id="fn18">T. Pajdla and V. Hlavac (1993) "Surface discontinuities in range images," in Proc IEEE 4th Int. Conf. Comput. Vision, pp. 524-528.<a href="#fnref18">↩</a></li>
</ol>
</section>
</body>
</html>
