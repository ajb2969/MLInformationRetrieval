<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1464">Verification-based message-passing algorithms in compressed sensing</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Verification-based message-passing algorithms in compressed sensing</h1>
<hr/>

<p><strong>Verification-based message-passing <a class="uri" href="algorithms" title="wikilink">algorithms</a></strong> (<strong>VB-MPAs</strong>) <strong>in <a href="compressed_sensing" title="wikilink">compressed sensing</a></strong> (<strong>CS</strong>), a branch of <a href="digital_signal_processing" title="wikilink">digital signal processing</a> that deals with measuring <a href="Compressed_sensing" title="wikilink">sparse signals</a>, are some methods to efficiently solve the recovery problem in compressed sensing. One of the main goal in compressed sensing is the recovery process. Generally speaking, recovery process in compressed sensing is a method by which the original signal is estimated using the knowledge of the compressed signal and the measurement matrix.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> Mathematically, the recovery process in Compressed Sensing is finding the sparsest possible solution of an under-determined <a href="system_of_linear_equations" title="wikilink">system of linear equations</a>. Based on the nature of the measurement matrix one can employ different reconstruction methods. If the measurement matrix is also sparse, one efficient way is to use Message Passing Algorithms for signal recovery. Although there are message passing approaches that deals with dense matrices, the nature of those algorithms are to some extent different from the algorithms working on sparse matrices.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a><a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>
<h2 id="overview">Overview</h2>

<p>The main problem in recovery process in CS is to find the sparsest possible solution to the following under-determined system of linear equations 

<math display="inline" id="Verification-based_message-passing_algorithms_in_compressed_sensing:0">
 <semantics>
  <mrow>
   <mrow>
    <mi>A</mi>
    <mi>x</mi>
   </mrow>
   <mo>=</mo>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>A</ci>
     <ci>x</ci>
    </apply>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Ax=y
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Verification-based_message-passing_algorithms_in_compressed_sensing:1">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 is the measurement matrix, 

<math display="inline" id="Verification-based_message-passing_algorithms_in_compressed_sensing:2">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 is the original signal to be recovered and 

<math display="inline" id="Verification-based_message-passing_algorithms_in_compressed_sensing:3">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

 is the compresses known signal. When the matrix 

<math display="inline" id="Verification-based_message-passing_algorithms_in_compressed_sensing:4">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 is sparse, one can represent this matrix by a <a href="bipartite_graph" title="wikilink">bipartite graph</a> 

<math display="inline" id="Verification-based_message-passing_algorithms_in_compressed_sensing:5">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msub>
      <mi>V</mi>
      <mi>l</mi>
     </msub>
     <mo>âˆª</mo>
     <msub>
      <mi>V</mi>
      <mi>r</mi>
     </msub>
    </mrow>
    <mo>,</mo>
    <mi>E</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>G</ci>
    <interval closure="open">
     <apply>
      <union></union>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>V</ci>
       <ci>l</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>V</ci>
       <ci>r</ci>
      </apply>
     </apply>
     <ci>E</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G=(V_{l}\cup V_{r},E)
  </annotation>
 </semantics>
</math>

 for better understanding.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a><a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a><a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a><a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> 

<math display="inline" id="Verification-based_message-passing_algorithms_in_compressed_sensing:6">
 <semantics>
  <msub>
   <mi>V</mi>
   <mi>l</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>V</ci>
    <ci>l</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V_{l}
  </annotation>
 </semantics>
</math>

 is the set of variable nodes in 

<math display="inline" id="Verification-based_message-passing_algorithms_in_compressed_sensing:7">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

 which represents the set of elements of 

<math display="inline" id="Verification-based_message-passing_algorithms_in_compressed_sensing:8">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 and also 

<math display="inline" id="Verification-based_message-passing_algorithms_in_compressed_sensing:9">
 <semantics>
  <msub>
   <mi>V</mi>
   <mi>r</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>V</ci>
    <ci>r</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V_{r}
  </annotation>
 </semantics>
</math>

 is the set of check nodes corresponding to the set of elements of 

<math display="inline" id="Verification-based_message-passing_algorithms_in_compressed_sensing:10">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

. Besides, there is an edge 

<math display="inline" id="Verification-based_message-passing_algorithms_in_compressed_sensing:11">
 <semantics>
  <mrow>
   <mi>e</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>u</mi>
    <mo>,</mo>
    <mi>v</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>e</ci>
    <interval closure="open">
     <ci>u</ci>
     <ci>v</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e=(u,v)
  </annotation>
 </semantics>
</math>

 between 

<math display="inline" id="Verification-based_message-passing_algorithms_in_compressed_sensing:12">
 <semantics>
  <mrow>
   <mi>u</mi>
   <mo>âˆˆ</mo>
   <msub>
    <mi>V</mi>
    <mi>l</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>u</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>V</ci>
     <ci>l</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u\in V_{l}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Verification-based_message-passing_algorithms_in_compressed_sensing:13">
 <semantics>
  <mrow>
   <mi>v</mi>
   <mo>âˆˆ</mo>
   <msub>
    <mi>V</mi>
    <mi>r</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>v</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>V</ci>
     <ci>r</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v\in V_{r}
  </annotation>
 </semantics>
</math>

 if the corresponding elements in 

<math display="inline" id="Verification-based_message-passing_algorithms_in_compressed_sensing:14">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 is non-zero, i.e. 

<math display="inline" id="Verification-based_message-passing_algorithms_in_compressed_sensing:15">
 <semantics>
  <mrow>
   <msub>
    <mi>A</mi>
    <mrow>
     <mi>v</mi>
     <mo>,</mo>
     <mi>u</mi>
    </mrow>
   </msub>
   <mo>â‰ </mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <neq></neq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>A</ci>
     <list>
      <ci>v</ci>
      <ci>u</ci>
     </list>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{v,u}\neq 0
  </annotation>
 </semantics>
</math>

. Moreover, the weight of the edge 

<math display="inline" id="Verification-based_message-passing_algorithms_in_compressed_sensing:16">
 <semantics>
  <mrow>
   <mrow>
    <mi>w</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>e</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msub>
    <mi>A</mi>
    <mrow>
     <mi>v</mi>
     <mo>,</mo>
     <mi>u</mi>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>w</ci>
     <ci>e</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>A</ci>
     <list>
      <ci>v</ci>
      <ci>u</ci>
     </list>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w(e)=A_{v,u}
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> Here is an example of a binary sparse measurement matrix where the weights of the edges are either zero or one.</p>
<figure><b>(Figure)</b>
<figcaption>bi-regular bipartite graph corresponding to the measurement matrix A<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></figcaption>
</figure>

<p>

<math display="inline" id="Verification-based_message-passing_algorithms_in_compressed_sensing:17">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>=</mo>
   <mrow>
    <mo>[</mo>
    <mtable>
     <mtr>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>1</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>1</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>1</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>1</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>1</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>1</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mn>1</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>1</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>1</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mn>1</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>1</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>1</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>1</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>1</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>1</mn>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>1</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>1</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>1</mn>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>1</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>1</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>1</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>1</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>1</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>1</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
     </mtr>
    </mtable>
    <mo>]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>A</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <matrix>
      <matrixrow>
       <cn type="integer">0</cn>
       <cn type="integer">0</cn>
       <cn type="integer">1</cn>
       <cn type="integer">0</cn>
       <cn type="integer">0</cn>
       <cn type="integer">0</cn>
       <cn type="integer">0</cn>
       <cn type="integer">0</cn>
       <cn type="integer">1</cn>
       <cn type="integer">0</cn>
       <cn type="integer">1</cn>
       <cn type="integer">0</cn>
      </matrixrow>
      <matrixrow>
       <cn type="integer">0</cn>
       <cn type="integer">0</cn>
       <cn type="integer">0</cn>
       <cn type="integer">1</cn>
       <cn type="integer">0</cn>
       <cn type="integer">1</cn>
       <cn type="integer">0</cn>
       <cn type="integer">1</cn>
       <cn type="integer">0</cn>
       <cn type="integer">0</cn>
       <cn type="integer">0</cn>
       <cn type="integer">0</cn>
      </matrixrow>
      <matrixrow>
       <cn type="integer">1</cn>
       <cn type="integer">0</cn>
       <cn type="integer">0</cn>
       <cn type="integer">0</cn>
       <cn type="integer">0</cn>
       <cn type="integer">1</cn>
       <cn type="integer">0</cn>
       <cn type="integer">0</cn>
       <cn type="integer">0</cn>
       <cn type="integer">0</cn>
       <cn type="integer">1</cn>
       <cn type="integer">0</cn>
      </matrixrow>
      <matrixrow>
       <cn type="integer">1</cn>
       <cn type="integer">1</cn>
       <cn type="integer">1</cn>
       <cn type="integer">0</cn>
       <cn type="integer">0</cn>
       <cn type="integer">0</cn>
       <cn type="integer">0</cn>
       <cn type="integer">0</cn>
       <cn type="integer">0</cn>
       <cn type="integer">0</cn>
       <cn type="integer">0</cn>
       <cn type="integer">0</cn>
      </matrixrow>
      <matrixrow>
       <cn type="integer">0</cn>
       <cn type="integer">0</cn>
       <cn type="integer">0</cn>
       <cn type="integer">1</cn>
       <cn type="integer">0</cn>
       <cn type="integer">0</cn>
       <cn type="integer">1</cn>
       <cn type="integer">0</cn>
       <cn type="integer">0</cn>
       <cn type="integer">0</cn>
       <cn type="integer">0</cn>
       <cn type="integer">1</cn>
      </matrixrow>
      <matrixrow>
       <cn type="integer">0</cn>
       <cn type="integer">0</cn>
       <cn type="integer">0</cn>
       <cn type="integer">0</cn>
       <cn type="integer">1</cn>
       <cn type="integer">0</cn>
       <cn type="integer">1</cn>
       <cn type="integer">0</cn>
       <cn type="integer">0</cn>
       <cn type="integer">0</cn>
       <cn type="integer">0</cn>
       <cn type="integer">1</cn>
      </matrixrow>
      <matrixrow>
       <cn type="integer">0</cn>
       <cn type="integer">0</cn>
       <cn type="integer">0</cn>
       <cn type="integer">0</cn>
       <cn type="integer">0</cn>
       <cn type="integer">0</cn>
       <cn type="integer">0</cn>
       <cn type="integer">1</cn>
       <cn type="integer">1</cn>
       <cn type="integer">1</cn>
       <cn type="integer">0</cn>
       <cn type="integer">0</cn>
      </matrixrow>
      <matrixrow>
       <cn type="integer">0</cn>
       <cn type="integer">1</cn>
       <cn type="integer">0</cn>
       <cn type="integer">0</cn>
       <cn type="integer">1</cn>
       <cn type="integer">0</cn>
       <cn type="integer">0</cn>
       <cn type="integer">0</cn>
       <cn type="integer">0</cn>
       <cn type="integer">1</cn>
       <cn type="integer">0</cn>
       <cn type="integer">0</cn>
      </matrixrow>
     </matrix>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A=\left[\begin{array}[]{c c c c c c c c c c c c}0&0&1&0&0&0&0&0&1&0&1&0\\
0&0&0&1&0&1&0&1&0&0&0&0\\
1&0&0&0&0&1&0&0&0&0&1&0\\
1&1&1&0&0&0&0&0&0&0&0&0\\
0&0&0&1&0&0&1&0&0&0&0&1\\
0&0&0&0&1&0&1&0&0&0&0&1\\
0&0&0&0&0&0&0&1&1&1&0&0\\
0&1&0&0&1&0&0&0&0&1&0&0\end{array}\right]
  </annotation>
 </semantics>
</math>

</p>

<p>The basic idea behind message passing algorithms in CS is to transmit appropriate messages between variable nodes and check nodes in an <a href="Iterative_method" title="wikilink">iterative manner</a> in order to efficiently find signal 

<math display="inline" id="Verification-based_message-passing_algorithms_in_compressed_sensing:18">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

. These messages are different for variable nodes and check nodes. However, the basic nature of the messages for all variable node and check nodes are the same in all of the verification based message passing algorithms.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> The messages 

<math display="inline" id="Verification-based_message-passing_algorithms_in_compressed_sensing:19">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>Î¼</mi>
     <mi>v</mi>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>v</mi>
      <mi>i</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo rspace="5.8pt">:</mo>
   <mrow>
    <msub>
     <mi>V</mi>
     <mi>l</mi>
    </msub>
    <mo>â†¦</mo>
    <mrow>
     <mi>â„</mi>
     <mo>Ã—</mo>
     <mrow>
      <mo stretchy="false">{</mo>
      <mn>0</mn>
      <mo>,</mo>
      <mn>1</mn>
      <mo stretchy="false">}</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>Î¼</ci>
      <ci>v</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>v</ci>
      <ci>i</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">maps-to</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>V</ci>
      <ci>l</ci>
     </apply>
     <apply>
      <times></times>
      <ci>â„</ci>
      <set>
       <cn type="integer">0</cn>
       <cn type="integer">1</cn>
      </set>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu^{v}(v_{i}):~{}V_{l}\mapsto\mathbb{R}\times\{0,1\}
  </annotation>
 </semantics>
</math>


 emanating from variable node 

<math display="inline" id="Verification-based_message-passing_algorithms_in_compressed_sensing:20">
 <semantics>
  <msub>
   <mi>v</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>v</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v_{i}
  </annotation>
 </semantics>
</math>

 contains the value of the check node and an indicator which shows if the variable node is verified or not. Moreover, the messages 

<math display="inline" id="Verification-based_message-passing_algorithms_in_compressed_sensing:21">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>Î¼</mi>
     <mi>c</mi>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>c</mi>
      <mi>i</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo rspace="5.8pt">:</mo>
   <mrow>
    <msub>
     <mi>V</mi>
     <mi>r</mi>
    </msub>
    <mo>â†¦</mo>
    <mrow>
     <mi>â„</mi>
     <mo>Ã—</mo>
     <msup>
      <mi>â„¤</mi>
      <mo>+</mo>
     </msup>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>Î¼</ci>
      <ci>c</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>c</ci>
      <ci>i</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">maps-to</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>V</ci>
      <ci>r</ci>
     </apply>
     <apply>
      <times></times>
      <ci>â„</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>â„¤</ci>
       <plus></plus>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu^{c}(c_{i}):~{}V_{r}\mapsto\mathbb{R}\times\mathbb{Z}^{+}
  </annotation>
 </semantics>
</math>

 emanating from check node 

<math display="inline" id="Verification-based_message-passing_algorithms_in_compressed_sensing:22">
 <semantics>
  <msub>
   <mi>c</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>c</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{i}
  </annotation>
 </semantics>
</math>

 contains the value of the check node and the remaining degree of the check node in the graph.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a><a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a></p>

<p>In each iteration, every variable node and check node produce a new message to be transmitted to all of its neighbors based on the messages that they have received from their own neighbors. This local property of the message passing algorithms enables them to be implemented as parallel processing algorithms and makes the time complexity of these algorithm so efficient.<ref =="" name="Zhang2009Iterative">F. Zhang and H. D. Pfister, â€œOn the iterative decoding of high-rate LDPC codes with applications in compressed sensing,â€ arXiv preprint arXiv:0903.2232, 2009.</ref></p>
<h2 id="message-passing-rules">Message Passing Rules<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a></h2>

<p>The common rule between all verification based message passing algorithms is the fact that once a variable node become verified then this variable node can be removed from the graph and the algorithm can be executed to solve the rest of the graph. Different verification bases message passing algorithms use different combinations of verification rules.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a></p>

<p>The verification rules are as follows:</p>
<ul>
<li><strong>Zero Check Node (ZCN):</strong><ref =="" name="Zhang2009Iterative"> If there is at least one check node with value zero in the neighborhood of a variable node then this variable node should be verified with value zero</ref></li>
<li><strong>Degree 1 Check Node: (D1CN):</strong><ref =="" name="Zhang2009Iterative"> If there is one or more check nodes with degree 1 in the neighborhood of a variable node, then the variable node should be verified with the value chosen randomly from the value of those degree 1 check nodes.</ref></li>
<li><strong>Equal Check Node: (ECN):</strong><ref =="" name="Zhang2009Iterative"> If there is a single variable node connected to at least two or more check nodes with the same non-zero value then the value of the variable node should be verified with the common value of those check nodes. Besides, every other variable nodes that are partially connected to these check nodes (not all of them) should be verified with value zero.</ref></li>
</ul>

<p>The message passing rules given above are the basic and only rules that should be used in any verification based message passing algorithm. It is shown that these simple rules can efficiently recover the original signal provided that certain conditions are satisfied.<ref =="" name="Zhang2009Iterative"><a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a></ref></p>
<h2 id="algorithms">Algorithms</h2>

<p>There are four algorithms known as VB-MPA's, namely Genie, LM, XH, and SBB.<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a> All of these algorithms use the same strategy for recovery of the original signal; however, they use different combination of the message passing rules to verify variable nodes.</p>
<h3 id="genie-algorithm">Genie Algorithm<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a></h3>

<p>Genie algorithm is the <a href="Benchmark_(computing)" title="wikilink">benchmark</a> in this topic. Firstly, Genie algorithm is assumed to have the knowledge of the <a href="Support_(mathematics)" title="wikilink">support</a> set of the signal, i.e. the set of non-zero elements of the original signal. Using this knowledge, Genie should not care about the zero variable nodes in the graph, and the only task of the Genie algorithm is to recover the values of the non-zero elements of the original signal. Although, Genie does not have any practical aspect, it can be regarded as the benchmark of the problem especially in the sense that this algorithm outperforms other algorithms in this category and one can measure how successful one algorithms is by comparing that to the Genie algorithm.</p>

<p>Since Genie only wants to find the value of the non-zero elements of the signal it is not necessary to employ rules that are responsible for zero valued variable node in this algorithm. Therefore, Genie only uses D1CN as the verification rule.</p>

<p>=== LM Algorithm<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a><ref =="" name="Zhang2009Iterative"> === This algorithm unlike the Genie algorithm does not have any knowledge about the support set of signal, and it uses D1CN and ZCN together to solve the recovery process in CS. In fact, ZCN is the rule that attempts to verify the zero valued variable nodes and D1CN is responsible for non-zero valued variable nodes. This usage of this algorithm is when one does not have non-binary matrix. In such cases, employing the third rule violated the locality nature of the algorithms. This issue will be considered in SBB algorithm.<a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a></ref></p>
<h3 id="xh-algorithm">XH algorithm<a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a></h3>

<p>This algorithm is the same as LM, but it only uses ECN instead of D1CN for the verification of the non-zero variable nodes. If the non-zero elements of the measurement matrix are <a href="Logical_matrix" title="wikilink">binary</a>, then this algorithm cannot be implemented efficiently and the locality of the algorithm will be violated.</p>
<h3 id="sbb-algorithm">SBB Algorithm<a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a><a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a></h3>

<p>The most powerful practical algorithm among all of the verification message passing algorithms is the SBB algorithm that employs all of the verification rules for the recovery of the original signal. In this algorithm, D1CN and ECN aer responsible for the verification of the non-zero elements of the signal and ZCN and ECN will verify zero variable nodes.</p>

<p>The <a href="pseudo_code" title="wikilink">pseudo code</a> of the VB-MPAs is as follows. In the following algorithm 

<math display="inline" id="Verification-based_message-passing_algorithms_in_compressed_sensing:23">
 <semantics>
  <msub>
   <mi>Î¼</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>Î¼</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu_{i}
  </annotation>
 </semantics>
</math>

 represents the 

<math display="inline" id="Verification-based_message-passing_algorithms_in_compressed_sensing:24">
 <semantics>
  <msup>
   <mi>i</mi>
   <mrow>
    <mi>t</mi>
    <mi>h</mi>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>i</ci>
    <apply>
     <times></times>
     <ci>t</ci>
     <ci>h</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i^{th}
  </annotation>
 </semantics>
</math>


 component of the messages emanating from variable and check nodes. 

<math display="inline" id="Verification-based_message-passing_algorithms_in_compressed_sensing:25">
 <semantics>
  <mrow>
   <mi>V</mi>
   <mi>N</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>V</ci>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   VN
  </annotation>
 </semantics>
</math>

 is in fact a variable that keeps the labels of the verified variable nodes. 

<math display="inline" id="Verification-based_message-passing_algorithms_in_compressed_sensing:26">
 <semantics>
  <mrow>
   <mi>V</mi>
   <msup>
    <mi>N</mi>
    <mo>â€²</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>V</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>N</ci>
     <ci>normal-â€²</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   VN^{\prime}
  </annotation>
 </semantics>
</math>

 is also used to keep the set of verified variable nodes in the previous iteration. By using these two variables one can see if there is any progress in the number of verified variable nodes in the algorithm, and if there is no progress then the algorithm will terminate.<a class="footnoteRef" href="#fn23" id="fnref23"><sup>23</sup></a><a class="footnoteRef" href="#fn24" id="fnref24"><sup>24</sup></a></p>

<p><code>1Â Â </code><strong><code>function</code></strong><code>Â VB_MPA(</code><em><code>Measurement</code> <code>Matrix</code> <code>A</code></em><code>,Â </code><em><code>Compressed</code> <code>Vector</code> <code>y</code></em><code>):</code><a class="footnoteRef" href="#fn25" id="fnref25"><sup>25</sup></a><br/>
<code>2Â Â Â Â Â Â </code>

<math display="inline" id="Verification-based_message-passing_algorithms_in_compressed_sensing:27">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>Î¼</mi>
     <mi>c</mi>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>c</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>:=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>y</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>c</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>,</mo>
     <msub>
      <mi>d</mi>
      <mi>c</mi>
     </msub>
     <mo rspace="9.1pt" stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo>âˆ€</mo>
     <mi>c</mi>
    </mrow>
   </mrow>
   <mo>âˆˆ</mo>
   <msub>
    <mi>V</mi>
    <mi>r</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <csymbol cd="latexml">assign</csymbol>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>Î¼</ci>
       <ci>c</ci>
      </apply>
      <ci>c</ci>
     </apply>
     <apply>
      <times></times>
      <interval closure="open">
       <apply>
        <times></times>
        <ci>y</ci>
        <ci>c</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>d</ci>
        <ci>c</ci>
       </apply>
      </interval>
      <apply>
       <csymbol cd="latexml">for-all</csymbol>
       <ci>c</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <in></in>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>V</ci>
      <ci>r</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu^{c}(c):=(y(c),d_{c})~{}~{}\forall c\in V_{r}
  </annotation>
 </semantics>
</math>

<code>Â Â Â Â Â Â Â Â Â Â Â //Â Initializations</code><br/>
<code>3Â Â Â Â Â Â </code>

<math display="inline" id="Verification-based_message-passing_algorithms_in_compressed_sensing:28">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>Î¼</mi>
     <mi>v</mi>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>v</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>:=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>0</mn>
     <mo>,</mo>
     <mn>0</mn>
     <mo rspace="9.1pt" stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo>âˆ€</mo>
     <mi>v</mi>
    </mrow>
   </mrow>
   <mo>âˆˆ</mo>
   <msub>
    <mi>V</mi>
    <mi>l</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <csymbol cd="latexml">assign</csymbol>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>Î¼</ci>
       <ci>v</ci>
      </apply>
      <ci>v</ci>
     </apply>
     <apply>
      <times></times>
      <interval closure="open">
       <cn type="integer">0</cn>
       <cn type="integer">0</cn>
      </interval>
      <apply>
       <csymbol cd="latexml">for-all</csymbol>
       <ci>v</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <in></in>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>V</ci>
      <ci>l</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu^{v}(v):=(0,0)~{}~{}\forall v\in V_{l}
  </annotation>
 </semantics>
</math>

<code>Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â //Â Initializations</code><br/>
<code>4Â Â Â Â Â Â </code>

<math display="inline" id="Verification-based_message-passing_algorithms_in_compressed_sensing:29">
 <semantics>
  <mrow>
   <mrow>
    <mi>V</mi>
    <mi>N</mi>
   </mrow>
   <mo>:=</mo>
   <mi mathvariant="normal">âˆ…</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <apply>
     <times></times>
     <ci>V</ci>
     <ci>N</ci>
    </apply>
    <emptyset></emptyset>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   VN:=\emptyset
  </annotation>
 </semantics>
</math>


<code>Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â //Â Initializations</code><br/>
<code>5Â Â Â Â Â Â </code>

<math display="inline" id="Verification-based_message-passing_algorithms_in_compressed_sensing:30">
 <semantics>
  <mrow>
   <mrow>
    <mi>V</mi>
    <msup>
     <mi>N</mi>
     <mo>â€²</mo>
    </msup>
   </mrow>
   <mo>:=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <apply>
     <times></times>
     <ci>V</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>N</ci>
      <ci>normal-â€²</ci>
     </apply>
    </apply>
    <set>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   VN^{\prime}:=\{-1\}
  </annotation>
 </semantics>
</math>

<code>Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â //Â Initializations</code><br/>
<code>6Â Â Â Â Â Â </code><strong><code>While</code></strong><code>Â </code><strong><code>(</code></strong>

<math display="inline" id="Verification-based_message-passing_algorithms_in_compressed_sensing:31">
 <semantics>
  <mrow>
   <mrow>
    <mi>V</mi>
    <msup>
     <mi>N</mi>
     <mo>â€²</mo>
    </msup>
   </mrow>
   <mo>â‰ </mo>
   <mrow>
    <mi>V</mi>
    <mi>N</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <neq></neq>
    <apply>
     <times></times>
     <ci>V</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>N</ci>
      <ci>normal-â€²</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>V</ci>
     <ci>N</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   VN^{\prime}\neq VN
  </annotation>
 </semantics>
</math>

<strong><code>)</code></strong><code>Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â //Â MainÂ Loop</code><br/>
<code>7Â Â Â Â Â Â Â Â Â Â </code>

<math display="inline" id="Verification-based_message-passing_algorithms_in_compressed_sensing:32">
 <semantics>
  <mrow>
   <mrow>
    <mi>V</mi>
    <msup>
     <mi>N</mi>
     <mo>â€²</mo>
    </msup>
   </mrow>
   <mo>:=</mo>
   <mrow>
    <mi>V</mi>
    <mi>N</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <apply>
     <times></times>
     <ci>V</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>N</ci>
      <ci>normal-â€²</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>V</ci>
     <ci>N</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   VN^{\prime}:=VN
  </annotation>
 </semantics>
</math>

<br/>
<code>9Â Â Â Â Â Â Â Â Â Â /*=============================Â HalfÂ roundÂ 1Â ofÂ roundÂ 1Â ============================Â */Â Â Â Â </code><br/>
<code>10Â Â Â Â Â Â Â Â Â </code><strong><code>for</code></strong><code>Â everyÂ </code>

<math display="inline" id="Verification-based_message-passing_algorithms_in_compressed_sensing:33">
 <semantics>
  <mrow>
   <mi>c</mi>
   <mo>âˆˆ</mo>
   <msub>
    <mi>V</mi>
    <mi>r</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>c</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>V</ci>
     <ci>r</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c\in V_{r}
  </annotation>
 </semantics>
</math>

<br/>
<code>11Â Â Â Â Â Â Â Â Â Â Â Â Â </code>

<math display="inline" id="Verification-based_message-passing_algorithms_in_compressed_sensing:34">
 <semantics>
  <mrow>
   <mrow>
    <mi>v</mi>
    <mi>a</mi>
    <mi>l</mi>
    <mi>u</mi>
    <mi>e</mi>
   </mrow>
   <mo>:=</mo>
   <mrow>
    <mrow>
     <mi>y</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>c</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <msub>
      <mo largeop="true" symmetric="true">âˆ‘</mo>
      <mrow>
       <mi>v</mi>
       <mo>âˆˆ</mo>
       <mrow>
        <mi class="ltx_font_mathcaligraphic">ğ’©</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>c</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
     </msub>
     <mrow>
      <msubsup>
       <mi>Î¼</mi>
       <mn>2</mn>
       <mi>v</mi>
      </msubsup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>v</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <msubsup>
       <mi>Î¼</mi>
       <mn>1</mn>
       <mi>v</mi>
      </msubsup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>v</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>A</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>c</mi>
       <mo>,</mo>
       <mi>v</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <apply>
     <times></times>
     <ci>v</ci>
     <ci>a</ci>
     <ci>l</ci>
     <ci>u</ci>
     <ci>e</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>y</ci>
      <ci>c</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <in></in>
        <ci>v</ci>
        <apply>
         <times></times>
         <ci>ğ’©</ci>
         <ci>c</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>Î¼</ci>
         <cn type="integer">2</cn>
        </apply>
        <ci>v</ci>
       </apply>
       <ci>v</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>Î¼</ci>
         <cn type="integer">1</cn>
        </apply>
        <ci>v</ci>
       </apply>
       <ci>v</ci>
       <ci>A</ci>
       <interval closure="open">
        <ci>c</ci>
        <ci>v</ci>
       </interval>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   value:=y(c)-\sum_{v\in\mathcal{N}(c)}{\mu_{2}^{v}(v)\mu_{1}^{v}(v)A(c,v)}
  </annotation>
 </semantics>
</math>


<br/>
<code>12Â Â Â Â Â Â Â Â Â Â Â Â Â </code>

<math display="inline" id="Verification-based_message-passing_algorithms_in_compressed_sensing:35">
 <semantics>
  <mrow>
   <mrow>
    <mi>d</mi>
    <mi>e</mi>
    <mi>g</mi>
    <mi>r</mi>
    <mi>e</mi>
    <mi>e</mi>
   </mrow>
   <mo>:=</mo>
   <mrow>
    <msub>
     <mi>d</mi>
     <mi>c</mi>
    </msub>
    <mo>-</mo>
    <mrow>
     <msub>
      <mo largeop="true" symmetric="true">âˆ‘</mo>
      <mrow>
       <mi>v</mi>
       <mo>âˆˆ</mo>
       <mrow>
        <mi class="ltx_font_mathcaligraphic">ğ’©</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>c</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
     </msub>
     <mrow>
      <msubsup>
       <mi>Î¼</mi>
       <mn>2</mn>
       <mi>v</mi>
      </msubsup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>v</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <apply>
     <times></times>
     <ci>d</ci>
     <ci>e</ci>
     <ci>g</ci>
     <ci>r</ci>
     <ci>e</ci>
     <ci>e</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>d</ci>
      <ci>c</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <in></in>
        <ci>v</ci>
        <apply>
         <times></times>
         <ci>ğ’©</ci>
         <ci>c</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>Î¼</ci>
         <cn type="integer">2</cn>
        </apply>
        <ci>v</ci>
       </apply>
       <ci>v</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   degree:=d_{c}-\sum_{v\in\mathcal{N}(c)}{\mu_{2}^{v}(v)}
  </annotation>
 </semantics>
</math>

<br/>
<code>13Â Â Â Â Â Â Â Â Â Â Â Â Â </code>

<math display="inline" id="Verification-based_message-passing_algorithms_in_compressed_sensing:36">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>Î¼</mi>
     <mi>c</mi>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>c</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>:=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>v</mi>
     <mi>a</mi>
     <mi>l</mi>
     <mi>u</mi>
     <mi>e</mi>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mi>d</mi>
     <mi>e</mi>
     <mi>g</mi>
     <mi>r</mi>
     <mi>e</mi>
     <mi>e</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>Î¼</ci>
      <ci>c</ci>
     </apply>
     <ci>c</ci>
    </apply>
    <interval closure="open">
     <apply>
      <times></times>
      <ci>v</ci>
      <ci>a</ci>
      <ci>l</ci>
      <ci>u</ci>
      <ci>e</ci>
     </apply>
     <apply>
      <times></times>
      <ci>d</ci>
      <ci>e</ci>
      <ci>g</ci>
      <ci>r</ci>
      <ci>e</ci>
      <ci>e</ci>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu^{c}(c):=(value,degree)
  </annotation>
 </semantics>
</math>

<br/>
<code>14Â Â Â Â Â Â Â Â Â </code><strong><code>end</code> <code>for</code></strong><br/>
<code>15Â Â Â Â Â Â Â Â Â /*=============================Â HalfÂ roundÂ 2Â ofÂ roundÂ 1Â ============================Â */</code><br/>
<code>16Â Â Â Â Â Â Â Â Â </code><strong><code>for</code></strong><code>Â everyÂ </code>

<math display="inline" id="Verification-based_message-passing_algorithms_in_compressed_sensing:37">
 <semantics>
  <mrow>
   <mi>v</mi>
   <mo>âˆˆ</mo>
   <mrow>
    <msub>
     <mi>V</mi>
     <mi>r</mi>
    </msub>
    <mo>âˆ–</mo>
    <mrow>
     <mi>V</mi>
     <mi>N</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>v</ci>
    <apply>
     <setdiff></setdiff>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>V</ci>
      <ci>r</ci>
     </apply>
     <apply>
      <times></times>
      <ci>V</ci>
      <ci>N</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v\in V_{r}\setminus VN
  </annotation>
 </semantics>
</math>

<br/>
<code>17Â Â Â Â Â Â Â Â Â Â Â Â Â </code><strong><code>update_rule</code></strong><code>(v,Algorithm)</code><br/>
<code>18Â Â Â Â Â Â Â Â Â Â Â Â Â </code><strong><code>If</code></strong><code>Â aÂ variableÂ nodeÂ vÂ isÂ verifiedÂ </code><strong><code>then</code></strong><br/>
<code>19Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â addÂ vÂ toÂ VN</code><br/>
<code>20Â Â Â Â Â Â Â Â Â Â Â Â Â </code><strong><code>end</code> <code>if</code></strong><br/>
<code>21Â Â Â Â Â Â Â Â Â </code><strong><code>end</code> <code>for</code></strong><br/>
<code>22Â Â Â Â Â Â Â Â Â /*=============================Â HalfÂ roundÂ 1Â ofÂ roundÂ 2Â ============================Â */</code><br/>
<code>23Â Â Â Â Â Â Â Â Â </code><strong><code>for</code></strong><code>Â everyÂ </code>

<math display="inline" id="Verification-based_message-passing_algorithms_in_compressed_sensing:38">
 <semantics>
  <mrow>
   <mi>c</mi>
   <mo>âˆˆ</mo>
   <msub>
    <mi>V</mi>
    <mi>r</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>c</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>V</ci>
     <ci>r</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c\in V_{r}
  </annotation>
 </semantics>
</math>

<br/>
<code>24Â Â Â Â Â Â Â Â Â Â Â Â Â </code>

<math display="inline" id="Verification-based_message-passing_algorithms_in_compressed_sensing:39">
 <semantics>
  <mrow>
   <mrow>
    <mi>v</mi>
    <mi>a</mi>
    <mi>l</mi>
    <mi>u</mi>
    <mi>e</mi>
   </mrow>
   <mo>:=</mo>
   <mrow>
    <mrow>
     <mi>y</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>c</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <msub>
      <mo largeop="true" symmetric="true">âˆ‘</mo>
      <mrow>
       <mi>v</mi>
       <mo>âˆˆ</mo>
       <mrow>
        <mi class="ltx_font_mathcaligraphic">ğ’©</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>c</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
     </msub>
     <mrow>
      <msubsup>
       <mi>Î¼</mi>
       <mn>2</mn>
       <mi>v</mi>
      </msubsup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>v</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <msubsup>
       <mi>Î¼</mi>
       <mn>1</mn>
       <mi>v</mi>
      </msubsup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>v</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>A</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>c</mi>
       <mo>,</mo>
       <mi>v</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <apply>
     <times></times>
     <ci>v</ci>
     <ci>a</ci>
     <ci>l</ci>
     <ci>u</ci>
     <ci>e</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>y</ci>
      <ci>c</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <in></in>
        <ci>v</ci>
        <apply>
         <times></times>
         <ci>ğ’©</ci>
         <ci>c</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>Î¼</ci>
         <cn type="integer">2</cn>
        </apply>
        <ci>v</ci>
       </apply>
       <ci>v</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>Î¼</ci>
         <cn type="integer">1</cn>
        </apply>
        <ci>v</ci>
       </apply>
       <ci>v</ci>
       <ci>A</ci>
       <interval closure="open">
        <ci>c</ci>
        <ci>v</ci>
       </interval>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   value:=y(c)-\sum_{v\in\mathcal{N}(c)}{\mu_{2}^{v}(v)\mu_{1}^{v}(v)A(c,v)}
  </annotation>
 </semantics>
</math>


<br/>
<code>25Â Â Â Â Â Â Â Â Â Â Â Â Â </code>

<math display="inline" id="Verification-based_message-passing_algorithms_in_compressed_sensing:40">
 <semantics>
  <mrow>
   <mrow>
    <mi>d</mi>
    <mi>e</mi>
    <mi>g</mi>
    <mi>r</mi>
    <mi>e</mi>
    <mi>e</mi>
   </mrow>
   <mo>:=</mo>
   <mrow>
    <msub>
     <mi>d</mi>
     <mi>c</mi>
    </msub>
    <mo>-</mo>
    <mrow>
     <msub>
      <mo largeop="true" symmetric="true">âˆ‘</mo>
      <mrow>
       <mi>v</mi>
       <mo>âˆˆ</mo>
       <mrow>
        <mi class="ltx_font_mathcaligraphic">ğ’©</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>c</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
     </msub>
     <mrow>
      <msubsup>
       <mi>Î¼</mi>
       <mn>2</mn>
       <mi>v</mi>
      </msubsup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>v</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <apply>
     <times></times>
     <ci>d</ci>
     <ci>e</ci>
     <ci>g</ci>
     <ci>r</ci>
     <ci>e</ci>
     <ci>e</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>d</ci>
      <ci>c</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <in></in>
        <ci>v</ci>
        <apply>
         <times></times>
         <ci>ğ’©</ci>
         <ci>c</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>Î¼</ci>
         <cn type="integer">2</cn>
        </apply>
        <ci>v</ci>
       </apply>
       <ci>v</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   degree:=d_{c}-\sum_{v\in\mathcal{N}(c)}{\mu_{2}^{v}(v)}
  </annotation>
 </semantics>
</math>

<br/>
<code>26Â Â Â Â Â Â Â Â Â Â Â Â Â </code>

<math display="inline" id="Verification-based_message-passing_algorithms_in_compressed_sensing:41">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>Î¼</mi>
     <mi>c</mi>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>c</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>:=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>v</mi>
     <mi>a</mi>
     <mi>l</mi>
     <mi>u</mi>
     <mi>e</mi>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mi>d</mi>
     <mi>e</mi>
     <mi>g</mi>
     <mi>r</mi>
     <mi>e</mi>
     <mi>e</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>Î¼</ci>
      <ci>c</ci>
     </apply>
     <ci>c</ci>
    </apply>
    <interval closure="open">
     <apply>
      <times></times>
      <ci>v</ci>
      <ci>a</ci>
      <ci>l</ci>
      <ci>u</ci>
      <ci>e</ci>
     </apply>
     <apply>
      <times></times>
      <ci>d</ci>
      <ci>e</ci>
      <ci>g</ci>
      <ci>r</ci>
      <ci>e</ci>
      <ci>e</ci>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu^{c}(c):=(value,degree)
  </annotation>
 </semantics>
</math>

<br/>
<code>27Â Â Â Â Â Â Â Â Â </code><strong><code>end</code> <code>for</code></strong><br/>
<code>28Â Â Â Â Â Â Â Â Â /*=============================Â HalfÂ roundÂ 2Â ofÂ roundÂ 2Â ============================Â */</code><br/>
<code>29Â Â Â Â Â Â Â Â Â </code><strong><code>for</code></strong><code>Â everyÂ </code>

<math display="inline" id="Verification-based_message-passing_algorithms_in_compressed_sensing:42">
 <semantics>
  <mrow>
   <mi>v</mi>
   <mo>âˆˆ</mo>
   <mrow>
    <msub>
     <mi>V</mi>
     <mi>l</mi>
    </msub>
    <mo>âˆ–</mo>
    <mrow>
     <mi>V</mi>
     <mi>N</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>v</ci>
    <apply>
     <setdiff></setdiff>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>V</ci>
      <ci>l</ci>
     </apply>
     <apply>
      <times></times>
      <ci>V</ci>
      <ci>N</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v\in V_{l}\setminus VN
  </annotation>
 </semantics>
</math>

<br/>
<code>30Â Â Â Â Â Â Â Â Â Â Â Â Â </code><strong><code>if</code></strong><code>Â </code>

<math display="inline" id="Verification-based_message-passing_algorithms_in_compressed_sensing:43">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>âˆƒ</mo>
     <mi>c</mi>
    </mrow>
    <mo>âˆˆ</mo>
    <mrow>
     <mi class="ltx_font_mathcaligraphic">ğ’©</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>v</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo rspace="5.8pt">:</mo>
   <mrow>
    <mrow>
     <msubsup>
      <mi>Î¼</mi>
      <mn>1</mn>
      <mi>c</mi>
     </msubsup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>c</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mn>0</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <in></in>
     <apply>
      <exists></exists>
      <ci>c</ci>
     </apply>
     <apply>
      <times></times>
      <ci>ğ’©</ci>
      <ci>v</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Î¼</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>c</ci>
      </apply>
      <ci>c</ci>
     </apply>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \exists c\in\mathcal{N}(v):~{}\mu_{1}^{c}(c)=0
  </annotation>
 </semantics>
</math>

<code>Â </code><strong><code>then</code></strong><br/>
<code>31Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â </code>

<math display="inline" id="Verification-based_message-passing_algorithms_in_compressed_sensing:44">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>Î¼</mi>
     <mi>v</mi>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>v</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>:=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>Î¼</ci>
      <ci>v</ci>
     </apply>
     <ci>v</ci>
    </apply>
    <interval closure="open">
     <cn type="integer">0</cn>
     <cn type="integer">1</cn>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu^{v}(v):=(0,1)
  </annotation>
 </semantics>
</math>


<br/>
<code>32Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â addÂ vÂ toÂ VN</code><br/>
<code>33Â Â Â Â Â Â Â Â Â Â Â Â Â </code><strong><code>end</code> <code>if</code></strong><br/>
<code>34Â Â Â Â Â Â Â Â Â </code><strong><code>end</code> <code>for</code></strong><br/>
<code>35Â Â Â Â Â </code><strong><code>end</code> <code>while</code></strong><code>Â </code><br/>
<code>36Â Â Â Â Â </code><strong><code>return</code></strong><code>Â </code>

<math display="inline" id="Verification-based_message-passing_algorithms_in_compressed_sensing:45">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mi>Î¼</mi>
     <mn>1</mn>
     <mi>v</mi>
    </msubsup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>v</mi>
     <mo rspace="9.1pt" stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo>âˆ€</mo>
     <mi>v</mi>
    </mrow>
   </mrow>
   <mo>âˆˆ</mo>
   <msub>
    <mi>V</mi>
    <mi>l</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>Î¼</ci>
       <ci>v</ci>
      </apply>
      <cn type="integer">1</cn>
     </apply>
     <ci>v</ci>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <ci>v</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>V</ci>
     <ci>l</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu^{v}_{1}(v)~{}~{}\forall v\in V_{l}
  </annotation>
 </semantics>
</math>

</p>
<figure><b>(Figure)</b>
<figcaption>SBB Algorithm<a class="footnoteRef" href="#fn26" id="fnref26"><sup>26</sup></a></figcaption>
</figure>

<p>In all of the algorithms the messages emanating from check nodes are the same; however, since the verification rules are different for different algorithms the messages produced by variable nodes will be different in each algorithm.<a class="footnoteRef" href="#fn27" id="fnref27"><sup>27</sup></a> The algorithm given above works for all of the VB-MPA's, and different algorithms use different rules in half round 2 of round 1 and 2. For instance, Genie algorithm uses D1CN rule in Half round 2 of round 1, and in fact the half round 2 of round 2 which uses ZCN rule is useless in Genie algorithm. LM algorithm uses D1CN in Half round 2 of round 1 and XH algorithm uses ECN rule in this stage instead of D1CN. SBB algorithm also uses both D1CN and ECN rule in the second half round of round 1. All of these rules can be efficiently implemented in <strong>update_rule</strong> function in the second half round of round 1.</p>
<h2 id="proof-of-correctness">Proof of Correctness</h2>

<p>Although there is no guarantee that these algorithms succeed in all of the cases but we can guarantee that if some of the variable nodes become verified during these algorithms then the values of those variable nodes are correct <a href="almost_surely" title="wikilink">almost surely</a>. In order to show that it is enough to show that all of the verification rules work perfectly and without <a href="False_alarm" title="wikilink">false verification</a>.<a class="footnoteRef" href="#fn28" id="fnref28"><sup>28</sup></a><ref =="" name="Zhang2009Iterative"></ref></p>
<h3 id="correctness-of-zcn">Correctness of ZCN</h3>

<p>The algebraic point of view of ZCN rule is that if in a <a href="system_of_linear_equations" title="wikilink">system of linear equations</a> the right hand side of the equation is zero then <a href="almost_surely" title="wikilink">almost surely</a> all of the unknowns in that equations are zero. This is due to the fact that the original signal is assumed to be <a class="uri" href="sparse" title="wikilink">sparse</a>, besides, we also should have the assumption that the non-zero elements of the signals are chosen form a <a href="continuous_distribution" title="wikilink">continuous distribution</a>. Suppose that there are 

<math display="inline" id="Verification-based_message-passing_algorithms_in_compressed_sensing:46">
 <semantics>
  <mi>d</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>d</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d
  </annotation>
 </semantics>
</math>

 variables in that equation, if some of them in 

<math display="inline" id="Verification-based_message-passing_algorithms_in_compressed_sensing:47">
 <semantics>
  <mrow>
   <mi>d</mi>
   <mo>-</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>d</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d-1
  </annotation>
 </semantics>
</math>

 elements are non-zero then the other 

<math display="inline" id="Verification-based_message-passing_algorithms_in_compressed_sensing:48">
 <semantics>
  <msup>
   <mi>d</mi>
   <mrow>
    <mi>t</mi>
    <mi>h</mi>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>d</ci>
    <apply>
     <times></times>
     <ci>t</ci>
     <ci>h</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d^{th}
  </annotation>
 </semantics>
</math>

 variable node value should have exactly the negative value of the summation of those 

<math display="inline" id="Verification-based_message-passing_algorithms_in_compressed_sensing:49">
 <semantics>
  <mrow>
   <mi>d</mi>
   <mo>-</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>d</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d-1
  </annotation>
 </semantics>
</math>


 variable nodes. If the non-zero elements of the original signal are chosen from a <a href="continuous_distribution" title="wikilink">continuous distribution</a> then the probability of this to occur is zero. Therefore, ZCN rule works perfectly.<a class="footnoteRef" href="#fn29" id="fnref29"><sup>29</sup></a><ref =="" name="Zhang2009Iterative"></ref></p>
<h3 id="correctness-of-d1cn">Correctness of D1CN</h3>

<p>D1CN says that if a variable node is the only unknown variable in an equation then the value of that variable equals the <a href="Sides_of_an_equation" title="wikilink">right hand side of that equation</a>. In fact, an equation with just one unknown variable is a check node with degree one, i.e. a check node with just one unverified variable node in its neighborhood.<a class="footnoteRef" href="#fn30" id="fnref30"><sup>30</sup></a><ref =="" name="Zhang2009Iterative"></ref></p>
<h3 id="correctness-of-ecn">Correctness of ECN</h3>

<p>This rule has two parts, the first part deals with non-zero elements of the signal while the second one is responsible for the zero elements of the original signal. For the first part, it says that if we have two or more equations with the same <a href="Sides_of_an_equation" title="wikilink">right hand side</a>, and if we only have one single <a href="Variable_(mathematics)" title="wikilink">unknown variable</a> 

<math display="inline" id="Verification-based_message-passing_algorithms_in_compressed_sensing:50">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>

 common in all of those equations then the value of this common variable should be the value of the <a href="right_hand_side" title="wikilink">right hand side</a> of those equations. Besides, it says that all other variables in those equations should be zero. Suppose that one of those variables 

<math display="inline" id="Verification-based_message-passing_algorithms_in_compressed_sensing:51">
 <semantics>
  <msup>
   <mi>v</mi>
   <mo>â€²</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>v</ci>
    <ci>normal-â€²</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v^{\prime}
  </annotation>
 </semantics>
</math>

 is not zero, then the <a href="right_hand_side" title="wikilink">right hand side</a> of the equation which contains both 

<math display="inline" id="Verification-based_message-passing_algorithms_in_compressed_sensing:52">
 <semantics>
  <mrow>
   <mi>v</mi>
   <mo>,</mo>
   <msup>
    <mi>v</mi>
    <mo>â€²</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>v</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>v</ci>
     <ci>normal-â€²</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v,v^{\prime}
  </annotation>
 </semantics>
</math>

 should be 

<math display="inline" id="Verification-based_message-passing_algorithms_in_compressed_sensing:53">
 <semantics>
  <mrow>
   <mrow>
    <mi>x</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>v</mi>
      <mo>â€²</mo>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>+</mo>
   <mrow>
    <mi>x</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>v</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <times></times>
     <ci>x</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>v</ci>
      <ci>normal-â€²</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>x</ci>
     <ci>v</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x(v^{\prime})+x(v)
  </annotation>
 </semantics>
</math>

 (For simplicity assume that the <a href="Graph_theory" title="wikilink">edge weights</a> are all 1 or zero). Besides, since we know that 

<math display="inline" id="Verification-based_message-passing_algorithms_in_compressed_sensing:54">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>


 is the only unique variable in all of these equations then there should be one equation 

<math display="inline" id="Verification-based_message-passing_algorithms_in_compressed_sensing:55">
 <semantics>
  <mi>c</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>c</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c
  </annotation>
 </semantics>
</math>

 in which 

<math display="inline" id="Verification-based_message-passing_algorithms_in_compressed_sensing:56">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>

 exists and 

<math display="inline" id="Verification-based_message-passing_algorithms_in_compressed_sensing:57">
 <semantics>
  <msup>
   <mi>v</mi>
   <mo>â€²</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>v</ci>
    <ci>normal-â€²</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v^{\prime}
  </annotation>
 </semantics>
</math>

 does not exists. On the other hand, we know that the <a href="right_hand_side" title="wikilink">right hand side</a> of these equations are the same; therefore, the <a href="right_hand_side" title="wikilink">right hand side</a> of equation 

<math display="inline" id="Verification-based_message-passing_algorithms_in_compressed_sensing:58">
 <semantics>
  <mi>c</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>c</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c
  </annotation>
 </semantics>
</math>

 should also be 

<math display="inline" id="Verification-based_message-passing_algorithms_in_compressed_sensing:59">
 <semantics>
  <mrow>
   <mrow>
    <mi>x</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>v</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>+</mo>
   <mrow>
    <mi>x</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>v</mi>
      <mo>â€²</mo>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <times></times>
     <ci>x</ci>
     <ci>v</ci>
    </apply>
    <apply>
     <times></times>
     <ci>x</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>v</ci>
      <ci>normal-â€²</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x(v)+x(v^{\prime})
  </annotation>
 </semantics>
</math>


. If we remove 

<math display="inline" id="Verification-based_message-passing_algorithms_in_compressed_sensing:60">
 <semantics>
  <msup>
   <mi>v</mi>
   <mo>â€²</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>v</ci>
    <ci>normal-â€²</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v^{\prime}
  </annotation>
 </semantics>
</math>

 from this equation we should have the summation of some unknown variables to be a non-zero value 

<math display="inline" id="Verification-based_message-passing_algorithms_in_compressed_sensing:61">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>v</mi>
     <mo>â€²</mo>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>x</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>v</ci>
     <ci>normal-â€²</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x(v^{\prime})
  </annotation>
 </semantics>
</math>

. Since the non-zero elements of 

<math display="inline" id="Verification-based_message-passing_algorithms_in_compressed_sensing:62">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 are chosen randomly from a <a href="continuous_distribution" title="wikilink">continuous distribution</a> the probability that this summation equals exactly 

<math display="inline" id="Verification-based_message-passing_algorithms_in_compressed_sensing:63">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>v</mi>
     <mo>â€²</mo>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>x</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>v</ci>
     <ci>normal-â€²</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x(v^{\prime})
  </annotation>
 </semantics>
</math>

 is zero. Therefore, <a href="almost_surely" title="wikilink">almost surely</a> the value of 

<math display="inline" id="Verification-based_message-passing_algorithms_in_compressed_sensing:64">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>


 is zero and all other variables in these equations have value zero.<a class="footnoteRef" href="#fn31" id="fnref31"><sup>31</sup></a><ref =="" name="Zhang2009Iterative"><a class="footnoteRef" href="#fn32" id="fnref32"><sup>32</sup></a></ref></p>

<p>There is just one scenario remained for the second part of the ECN rule as most of it has been covered in the first part. This scenario is the one that we have some equations with the same <a href="right_hand_side" title="wikilink">right hand side</a> but there is two or more variable node common in all of those equations. In this case, we can say nothing about those common variable nodes; however, we can say that all the other variable nodes in those equations are zero. The proof of this claim can be achieved by a <a href="change_of_variable" title="wikilink">change of variable</a> in those equations. Suppose that 

<math display="inline" id="Verification-based_message-passing_algorithms_in_compressed_sensing:65">
 <semantics>
  <mrow>
   <msub>
    <mi>v</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>v</mi>
    <mn>2</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">â€¦</mi>
   <mo>,</mo>
   <msub>
    <mi>v</mi>
    <mi>q</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>v</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>v</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>normal-â€¦</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>v</ci>
     <ci>q</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v_{1},v_{2},...,v_{q}
  </annotation>
 </semantics>
</math>

 are the common variable nodes in those equations. If we set 

<math display="inline" id="Verification-based_message-passing_algorithms_in_compressed_sensing:66">
 <semantics>
  <mrow>
   <msup>
    <mi>v</mi>
    <mo>â€²</mo>
   </msup>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>v</mi>
     <mn>1</mn>
    </msub>
    <mo>+</mo>
    <msub>
     <mi>v</mi>
     <mn>2</mn>
    </msub>
    <mo>+</mo>
    <mi mathvariant="normal">â€¦</mi>
    <mo>+</mo>
    <msub>
     <mi>v</mi>
     <mi>q</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>v</ci>
     <ci>normal-â€²</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>v</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>v</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-â€¦</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>v</ci>
      <ci>q</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v^{\prime}=v_{1}+v_{2}+...+v_{q}
  </annotation>
 </semantics>
</math>

 then the problem will be changed to the first part where we only have one common variable node in all of those equations. Therefore, with the same reasoning as in the first part we can see that all other variable nodes that are not common in all of those equations can be verified with value zero almost surelyly]].<a class="footnoteRef" href="#fn33" id="fnref33"><sup>33</sup></a><ref =="" name="Zhang2009Iterative"><a class="footnoteRef" href="#fn34" id="fnref34"><sup>34</sup></a></ref></p>

<p>When the non-zero elements of the measurement matrix are chosen randomly from a <a href="continuous_distribution" title="wikilink">continuous distribution</a>, then it can be shown that if one variable node receives equal messages divided by the <a href="Graph_theory" title="wikilink">edge weights</a> from its neighbors then this variable node is the only unique variable connected to all of those check nodes, therefore, the rule can be applied using a local decision approach, and the variable node can verify itself without further knowledge about the other connections of those check nodes. Moreover, the second part of the ECN rule is not necessary to be implemented as the non-zero verified variable node in the ECN rule will be removed from the <a href="bipartite_graph" title="wikilink">bipartite graph</a> in the next <a class="uri" href="iteration" title="wikilink">iteration</a> and ZCN rule will be enough to verify all the zero valued variable nodes remained from those equations with the same <a href="right_hand_side" title="wikilink">right hand side</a>. All in all, when the non-zero elements of the measurement matrix are chosen form a <a href="continuous_distribution" title="wikilink">continuous distribution</a> then the SBB and XH algorithm that use ECN rule can be implemented efficiently.<a class="footnoteRef" href="#fn35" id="fnref35"><sup>35</sup></a></p>
<h2 id="run-time-analysis"><a href="Analysis_of_algorithms" title="wikilink">Run Time Analysis</a></h2>

<p>Every minor <a href="LOOP_(programming_language)" title="wikilink">loop</a> in the main <a href="LOOP_(programming_language)" title="wikilink">loop</a> of the algorithm can be executed in <a href="Parallel_processing" title="wikilink">parallel processors</a>, if we consider each variable and check node as a separate processor. Therefore, every minor loop in the algorithm can be executed in <a href="Big_O_notation" title="wikilink">constant time 

<math display="inline" id="Verification-based_message-passing_algorithms_in_compressed_sensing:67">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(1)
  </annotation>
 </semantics>
</math>

</a>. Moreover, since the algorithm will terminate when there is no progress in verification of the variable nodes then the if in the worst case in each iteration of the main loop there is only one variable node to be verified, then the maximum number of times that the main loop will be executed is 

<math display="inline" id="Verification-based_message-passing_algorithms_in_compressed_sensing:68">
 <semantics>
  <mrow>
   <mo stretchy="false">|</mo>
   <msub>
    <mi>V</mi>
    <mi>l</mi>
   </msub>
   <mo stretchy="false">|</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <abs></abs>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>V</ci>
     <ci>l</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |V_{l}|
  </annotation>
 </semantics>
</math>

. Therefore, the whole algorithm will be executed in <a href="Big_O_notation" title="wikilink">

<math display="inline" id="Verification-based_message-passing_algorithms_in_compressed_sensing:69">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">|</mo>
     <msub>
      <mi>V</mi>
      <mi>l</mi>
     </msub>
     <mo stretchy="false">|</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <abs></abs>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>V</ci>
      <ci>l</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(|V_{l}|)
  </annotation>
 </semantics>
</math>


 time</a>.<a class="footnoteRef" href="#fn36" id="fnref36"><sup>36</sup></a></p>
<h2 id="references">References</h2>

<p>"</p>

<p><a href="Category:Digital_signal_processing" title="wikilink">Category:Digital signal processing</a> <a href="Category:Distributed_algorithms" title="wikilink">Category:Distributed algorithms</a> <a href="Category:Inter-process_communication" title="wikilink">Category:Inter-process communication</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">D. L. Donoho, A. Javanmard, and A. Montanari, â€œInformation-theoretically optimal compressed sensing via spatial coupling and approximate message passing,â€ in Information Theory Proceedings (ISIT), 2012 IEEE International Symposium on, 2012, pp. 1231â€“1235.<a href="#fnref1">â†©</a></li>
<li id="fn2"></li>
<li id="fn3">Chandar, Venkat, Devavrat Shah, and Gregory W. Wornell. "A simple message-passing algorithm for compressed sensing." Information Theory Proceedings (ISIT), 2010 IEEE International Symposium on. IEEE, 2010.<a href="#fnref3">â†©</a></li>
<li id="fn4"></li>
<li id="fn5"><a href="Piotr_Indyk" title="wikilink">Indyk, Piotr</a>. "Explicit constructions for compressed sensing of sparse signals." Proceedings of the nineteenth annual ACM-SIAM symposium on Discrete algorithms. Society for Industrial and Applied Mathematics, 2008.<a href="#fnref5">â†©</a></li>
<li id="fn6">Gilbert, Anna C., et al. "One sketch for all: fast algorithms for compressed sensing." Proceedings of the thirty-ninth annual ACM symposium on Theory of computing. ACM, 2007.<a href="#fnref6">â†©</a></li>
<li id="fn7">Sarvotham, Shriram, Dror Baron, and Richard G. Baraniuk. "Sudocodes-Fast Measurement and Reconstruction of Sparse Signals." Information Theory, 2006 IEEE International Symposium on. IEEE, 2006.<a href="#fnref7">â†©</a></li>
<li id="fn8">Y. Eftekhari, A. Heidarzadeh, A. H. Banihashemi, and I. Lambadaris, â€œDensity evolution analysis of node-based verification-based algorithms in compressed sensing,â€ Information Theory, IEEE Transactions on, vol. 58, no. 10, pp. 6616â€“6645, 2012.<a href="#fnref8">â†©</a></li>
<li id="fn9"></li>
<li id="fn10"></li>
<li id="fn11"></li>
<li id="fn12"><a href="#fnref12">â†©</a></li>
<li id="fn13">Luby, Michael G., and Michael Mitzenmacher. "Verification-based decoding for packet-based low-density parity-check codes." IEEE Transactions on Information Theory 51.1 (2005): 120-127.<a href="#fnref13">â†©</a></li>
<li id="fn14"></li>
<li id="fn15"></li>
<li id="fn16"></li>
<li id="fn17"></li>
<li id="fn18"></li>
<li id="fn19"></li>
<li id="fn20"></li>
<li id="fn21"></li>
<li id="fn22"></li>
<li id="fn23"></li>
<li id="fn24"></li>
<li id="fn25"></li>
<li id="fn26"></li>
<li id="fn27"></li>
<li id="fn28"></li>
<li id="fn29"></li>
<li id="fn30"></li>
<li id="fn31"></li>
<li id="fn32"></li>
<li id="fn33"></li>
<li id="fn34"></li>
<li id="fn35"></li>
<li id="fn36"></li>
</ol>
</section>
</body>
</html>
