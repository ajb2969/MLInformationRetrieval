<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="894">Rice's theorem</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Rice's theorem</h1>
<hr/>

<p>In <a href="computability_theory" title="wikilink">computability theory</a>, <strong>Rice's theorem</strong> states that, for any non-trivial property of <a href="partial_functions" title="wikilink">partial functions</a>, no general and effective method can <a href="decision_problem" title="wikilink">decide</a> whether an <a class="uri" href="algorithm" title="wikilink">algorithm</a> computes a partial function with that property.</p>

<p>Here, a property of partial functions is called <em>trivial</em> if it holds for all <a href="partial_computable_function" title="wikilink">partial computable functions</a> or for none, and an effective decision method is called <em>general</em> if it decides correctly for every algorithm. The theorem is named after <a href="Henry_Gordon_Rice" title="wikilink">Henry Gordon Rice</a>, and is also known as the <strong>Rice–Myhill–Shapiro theorem</strong> after Rice, <a href="John_Myhill" title="wikilink">John Myhill</a>, and <a href="Norman_Shapiro" title="wikilink">Norman Shapiro</a>.</p>
<h2 id="introduction">Introduction</h2>

<p>Another way of stating Rice's theorem that is more useful in <a href="Computability_theory_(computer_science)" title="wikilink">computability theory</a> follows.</p>

<p>Let <em>S</em> be a set of <a href="Formal_language" title="wikilink">languages</a> that is nontrivial, meaning</p>
<ol>
<li>there exists a Turing machine that recognizes a language in <em>S</em></li>
<li>there exists a Turing machine that recognizes a language not in <em>S</em></li>
</ol>

<p>Then, it is <a href="decision_problem" title="wikilink">undecidable</a> to determine whether the language recognized by an arbitrary <a href="Turing_machine" title="wikilink">Turing machine</a> lies in <em>S</em>.</p>

<p>In practice, this means that there is no machine that can always decide whether the language of a given Turing machine has a particular nontrivial property. Special cases include the undecidability of whether a Turing machine accepts a particular string, whether a Turing machine recognizes a particular recognizable language, and whether the language recognized by a Turing machine could be recognized by a nontrivial simpler machine, such as a <a href="Finite_state_machine" title="wikilink">finite automaton</a>.</p>

<p>It is important to note that Rice's theorem does not say anything about those properties of machines or programs that are not also properties of functions and languages. For example, whether a machine runs for more than 100 steps on some input is a decidable property, even though it is non-trivial. Implementing exactly the same language, two different machines might require a different number of steps to recognize the same input. Similarly, whether a machine has more than 5 states is a decidable property of the machine, as the number of states can simply be counted. Where a property is of the kind that either of the two machines may or may not have it, while still implementing exactly the same language, the property is of the machines and not of the language, and Rice's Theorem does not apply.</p>

<p>Using <a href="Hartley_Rogers,_Jr" title="wikilink">Rogers</a>' characterization of <a href="Roger's_equivalence_theorem" title="wikilink">acceptable programming systems</a>, Rice's Theorem may essentially be generalized from Turing machines to most computer <a href="programming_language" title="wikilink">programming languages</a>: there exists no automatic method that decides with generality non-trivial questions on the behavior of computer programs.</p>

<p>As an example, consider the following variant of the <a href="halting_problem" title="wikilink">halting problem</a>. Let <em>P</em> be the following property of partial functions <strong>F</strong> of one argument: <em>P</em>(<strong>F</strong>) means that <strong>F</strong> is defined for the argument '1'. It is obviously non-trivial, since there are partial functions that are defined at 1, and others that are undefined at 1. The <em>1-halting problem</em> is the problem of deciding of any algorithm whether it defines a function with this property, i.e., whether the algorithm halts on input 1. By Rice's theorem, the 1-halting problem is undecidable. Similarly the question of whether a Turing machine <em>T</em> terminates on an initially empty tape (rather than with an initial word <em>w</em> given as second argument in addition to a description of <em>T</em>, as in the full halting problem) is still undecidable.</p>
<h2 id="formal-statement">Formal statement</h2>

<p>Let 

<math display="inline" id="Rice's_theorem:0">
 <semantics>
  <mrow>
   <mi>ϕ</mi>
   <mo>:</mo>
   <mrow>
    <mi>ℕ</mi>
    <mo>→</mo>
    <msup>
     <mi>𝐏</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>1</mn>
      <mo stretchy="false">)</mo>
     </mrow>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>ϕ</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>ℕ</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>𝐏</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi\colon\mathbb{N}\to\mathbf{P}^{(1)}
  </annotation>
 </semantics>
</math>

 be an <a href="admissible_numbering" title="wikilink">admissible numbering</a> of the <a href="computable_function" title="wikilink">computable functions</a>; a map from the <a href="natural_numbers" title="wikilink">natural numbers</a> to the class 

<math display="inline" id="Rice's_theorem:1">
 <semantics>
  <msup>
   <mi>𝐏</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>𝐏</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{P}^{(1)}
  </annotation>
 </semantics>
</math>

 of unary (partial) computable functions. Denote by 

<math display="inline" id="Rice's_theorem:2">
 <semantics>
  <mrow>
   <msub>
    <mi>ϕ</mi>
    <mi>e</mi>
   </msub>
   <mo>:=</mo>
   <mrow>
    <mi>ϕ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>e</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ϕ</ci>
     <ci>e</ci>
    </apply>
    <apply>
     <times></times>
     <ci>ϕ</ci>
     <ci>e</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi_{e}:=\phi(e)
  </annotation>
 </semantics>
</math>

 the <mtpl></mtpl>th (partial) computable function.</p>

<p>We identify each <em>property</em> that a computable function may have with the subset of 

<math display="inline" id="Rice's_theorem:3">
 <semantics>
  <msup>
   <mi>𝐏</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>𝐏</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{P}^{(1)}
  </annotation>
 </semantics>
</math>

 consisting of the functions with that property. Thus given a set 

<math display="inline" id="Rice's_theorem:4">
 <semantics>
  <mrow>
   <mi>F</mi>
   <mo>⊆</mo>
   <msup>
    <mi>𝐏</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>1</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <ci>F</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>𝐏</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F\subseteq\mathbf{P}^{(1)}
  </annotation>
 </semantics>
</math>

, a computable function 

<math display="inline" id="Rice's_theorem:5">
 <semantics>
  <msub>
   <mi>ϕ</mi>
   <mi>e</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ϕ</ci>
    <ci>e</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi_{e}
  </annotation>
 </semantics>
</math>

 has property <em>F</em> if and only if 

<math display="inline" id="Rice's_theorem:6">
 <semantics>
  <mrow>
   <msub>
    <mi>ϕ</mi>
    <mi>e</mi>
   </msub>
   <mo>∈</mo>
   <mi>F</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ϕ</ci>
     <ci>e</ci>
    </apply>
    <ci>F</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi_{e}\in F
  </annotation>
 </semantics>
</math>

. For each property 

<math display="inline" id="Rice's_theorem:7">
 <semantics>
  <mrow>
   <mi>F</mi>
   <mo>⊆</mo>
   <msup>
    <mi>𝐏</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>1</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <ci>F</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>𝐏</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F\subseteq\mathbf{P}^{(1)}
  </annotation>
 </semantics>
</math>

 there is an associated <a href="decision_problem" title="wikilink">decision problem</a> 

<math display="inline" id="Rice's_theorem:8">
 <semantics>
  <msub>
   <mi>D</mi>
   <mi>F</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>D</ci>
    <ci>F</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D_{F}
  </annotation>
 </semantics>
</math>

 of determining, given <em>e</em>, whether 

<math display="inline" id="Rice's_theorem:9">
 <semantics>
  <mrow>
   <msub>
    <mi>ϕ</mi>
    <mi>e</mi>
   </msub>
   <mo>∈</mo>
   <mi>F</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ϕ</ci>
     <ci>e</ci>
    </apply>
    <ci>F</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi_{e}\in F
  </annotation>
 </semantics>
</math>

.</p>

<p><strong>Rice's theorem</strong> states that the decision problem 

<math display="inline" id="Rice's_theorem:10">
 <semantics>
  <msub>
   <mi>D</mi>
   <mi>F</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>D</ci>
    <ci>F</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D_{F}
  </annotation>
 </semantics>
</math>

 is <a href="recursive_set" title="wikilink">decidable</a> (also called recursive or computable) if and only if 

<math display="inline" id="Rice's_theorem:11">
 <semantics>
  <mrow>
   <mi>F</mi>
   <mo>=</mo>
   <mi mathvariant="normal">∅</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>F</ci>
    <emptyset></emptyset>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F=\emptyset
  </annotation>
 </semantics>
</math>

 or 

<math display="inline" id="Rice's_theorem:12">
 <semantics>
  <mrow>
   <mi>F</mi>
   <mo>=</mo>
   <msup>
    <mi>𝐏</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>1</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>F</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>𝐏</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F=\mathbf{P}^{(1)}
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="examples">Examples</h2>

<p>According to Rice's theorem, if there is at least one computable function in a particular class <em>C</em> of computable functions and another computable function not in <em>C</em> then the problem of deciding whether a particular program computes a function in <em>C</em> is undecidable. For example, Rice's theorem shows that each of the following sets of computable functions is undecidable:</p>
<ul>
<li>The class of computable functions that return <em>0</em> for every input, and its complement.</li>
<li>The class of computable functions that return <em>0</em> for at least one input, and its complement.</li>
<li>The class of computable functions that are constant, and its complement.</li>
<li>The class of indices for computable functions that are total <a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></li>
<li>The class of indices for <a href="recursively_enumerable_set" title="wikilink">recursively enumerable sets</a> that are cofinite</li>
<li>The class of indices for recursively enumerable sets that are recursive</li>
</ul>
<h2 id="proof-by-kleenes-recursion-theorem">Proof by Kleene's recursion theorem</h2>

<p><a href="Kleene's_recursion_theorem#Application_to_quines" title="wikilink">A corollary</a> to <a href="Kleene's_recursion_theorem" title="wikilink">Kleene's recursion theorem</a> states that for every <a href="Gödel_number" title="wikilink">Gödel numbering</a> 

<math display="inline" id="Rice's_theorem:13">
 <semantics>
  <mrow>
   <mi>ϕ</mi>
   <mo>:</mo>
   <mrow>
    <mi>ℕ</mi>
    <mo>→</mo>
    <msup>
     <mi>𝐏</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>1</mn>
      <mo stretchy="false">)</mo>
     </mrow>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>ϕ</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>ℕ</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>𝐏</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi\colon\mathbb{N}\to\mathbf{P}^{(1)}
  </annotation>
 </semantics>
</math>

 of the <a href="computable_function" title="wikilink">computable functions</a> and every computable function 

<math display="inline" id="Rice's_theorem:14">
 <semantics>
  <mrow>
   <mi>Q</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>Q</ci>
    <interval closure="open">
     <ci>x</ci>
     <ci>y</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q(x,y)
  </annotation>
 </semantics>
</math>

, there is an index 

<math display="inline" id="Rice's_theorem:15">
 <semantics>
  <mi>e</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>e</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Rice's_theorem:16">
 <semantics>
  <mrow>
   <msub>
    <mi>ϕ</mi>
    <mi>e</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ϕ</ci>
     <ci>e</ci>
    </apply>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi_{e}(y)
  </annotation>
 </semantics>
</math>

 returns 

<math display="inline" id="Rice's_theorem:17">
 <semantics>
  <mrow>
   <mi>Q</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>e</mi>
    <mo>,</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>Q</ci>
    <interval closure="open">
     <ci>e</ci>
     <ci>y</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q(e,y)
  </annotation>
 </semantics>
</math>

. (In the following, we say that 

<math display="inline" id="Rice's_theorem:18">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x)
  </annotation>
 </semantics>
</math>

 "returns" 

<math display="inline" id="Rice's_theorem:19">
 <semantics>
  <mrow>
   <mi>g</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>g</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g(x)
  </annotation>
 </semantics>
</math>

 if either 

<math display="inline" id="Rice's_theorem:20">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>g</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <ci>g</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x)=g(x)
  </annotation>
 </semantics>
</math>

, or both 

<math display="inline" id="Rice's_theorem:21">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Rice's_theorem:22">
 <semantics>
  <mrow>
   <mi>g</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>g</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g(x)
  </annotation>
 </semantics>
</math>

 are undefined.) Intuitively, 

<math display="inline" id="Rice's_theorem:23">
 <semantics>
  <msub>
   <mi>ϕ</mi>
   <mi>e</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ϕ</ci>
    <ci>e</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi_{e}
  </annotation>
 </semantics>
</math>

 is a <a href="Quine_(computing)" title="wikilink">quine</a>, a function that returns its own source code (Gödel number), except that rather than returning it directly, 

<math display="inline" id="Rice's_theorem:24">
 <semantics>
  <msub>
   <mi>ϕ</mi>
   <mi>e</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ϕ</ci>
    <ci>e</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi_{e}
  </annotation>
 </semantics>
</math>

 passes its Gödel number to 

<math display="inline" id="Rice's_theorem:25">
 <semantics>
  <mi>Q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q
  </annotation>
 </semantics>
</math>

 and returns the result.</p>

<p>Let 

<math display="inline" id="Rice's_theorem:26">
 <semantics>
  <mi>F</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>F</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F
  </annotation>
 </semantics>
</math>

 be a set of computable functions such that 

<math display="inline" id="Rice's_theorem:27">
 <semantics>
  <mrow>
   <mi mathvariant="normal">∅</mi>
   <mo>≠</mo>
   <mi>F</mi>
   <mo>≠</mo>
   <msup>
    <mi>𝐏</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>1</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <neq></neq>
     <emptyset></emptyset>
     <ci>F</ci>
    </apply>
    <apply>
     <neq></neq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>𝐏</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \emptyset\neq F\neq\mathbf{P}^{(1)}
  </annotation>
 </semantics>
</math>

. Then there are computable functions 

<math display="inline" id="Rice's_theorem:28">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mo>∈</mo>
   <mi>F</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>f</ci>
    <ci>F</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f\in F
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Rice's_theorem:29">
 <semantics>
  <mrow>
   <mi>g</mi>
   <mo>∉</mo>
   <mi>F</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <notin></notin>
    <ci>g</ci>
    <ci>F</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g\notin F
  </annotation>
 </semantics>
</math>

. Suppose that the set of indices 

<math display="inline" id="Rice's_theorem:30">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Rice's_theorem:31">
 <semantics>
  <mrow>
   <msub>
    <mi>ϕ</mi>
    <mi>x</mi>
   </msub>
   <mo>∈</mo>
   <mi>F</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ϕ</ci>
     <ci>x</ci>
    </apply>
    <ci>F</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi_{x}\in F
  </annotation>
 </semantics>
</math>

 is decidable; then, there exists a function 

<math display="inline" id="Rice's_theorem:32">
 <semantics>
  <mrow>
   <mi>Q</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>Q</ci>
    <interval closure="open">
     <ci>x</ci>
     <ci>y</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q(x,y)
  </annotation>
 </semantics>
</math>

 that returns 

<math display="inline" id="Rice's_theorem:33">
 <semantics>
  <mrow>
   <mi>g</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>g</ci>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g(y)
  </annotation>
 </semantics>
</math>

 if 

<math display="inline" id="Rice's_theorem:34">
 <semantics>
  <mrow>
   <msub>
    <mi>ϕ</mi>
    <mi>x</mi>
   </msub>
   <mo>∈</mo>
   <mi>F</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ϕ</ci>
     <ci>x</ci>
    </apply>
    <ci>F</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi_{x}\in F
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="Rice's_theorem:35">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(y)
  </annotation>
 </semantics>
</math>

 otherwise. By the corollary to the recursion theorem, there is an index 

<math display="inline" id="Rice's_theorem:36">
 <semantics>
  <mi>e</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>e</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Rice's_theorem:37">
 <semantics>
  <mrow>
   <msub>
    <mi>ϕ</mi>
    <mi>e</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ϕ</ci>
     <ci>e</ci>
    </apply>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi_{e}(y)
  </annotation>
 </semantics>
</math>

 returns 

<math display="inline" id="Rice's_theorem:38">
 <semantics>
  <mrow>
   <mi>Q</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>e</mi>
    <mo>,</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>Q</ci>
    <interval closure="open">
     <ci>e</ci>
     <ci>y</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q(e,y)
  </annotation>
 </semantics>
</math>

. But then, if 

<math display="inline" id="Rice's_theorem:39">
 <semantics>
  <mrow>
   <msub>
    <mi>ϕ</mi>
    <mi>e</mi>
   </msub>
   <mo>∈</mo>
   <mi>F</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ϕ</ci>
     <ci>e</ci>
    </apply>
    <ci>F</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi_{e}\in F
  </annotation>
 </semantics>
</math>

, then 

<math display="inline" id="Rice's_theorem:40">
 <semantics>
  <msub>
   <mi>ϕ</mi>
   <mi>e</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ϕ</ci>
    <ci>e</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi_{e}
  </annotation>
 </semantics>
</math>

 is the same function as 

<math display="inline" id="Rice's_theorem:41">
 <semantics>
  <mi>g</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>g</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g
  </annotation>
 </semantics>
</math>

, and therefore 

<math display="inline" id="Rice's_theorem:42">
 <semantics>
  <mrow>
   <msub>
    <mi>ϕ</mi>
    <mi>e</mi>
   </msub>
   <mo>∉</mo>
   <mi>F</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <notin></notin>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ϕ</ci>
     <ci>e</ci>
    </apply>
    <ci>F</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi_{e}\notin F
  </annotation>
 </semantics>
</math>

; and if 

<math display="inline" id="Rice's_theorem:43">
 <semantics>
  <mrow>
   <msub>
    <mi>ϕ</mi>
    <mi>e</mi>
   </msub>
   <mo>∉</mo>
   <mi>F</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <notin></notin>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ϕ</ci>
     <ci>e</ci>
    </apply>
    <ci>F</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi_{e}\notin F
  </annotation>
 </semantics>
</math>

, then 

<math display="inline" id="Rice's_theorem:44">
 <semantics>
  <msub>
   <mi>ϕ</mi>
   <mi>e</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ϕ</ci>
    <ci>e</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi_{e}
  </annotation>
 </semantics>
</math>

 is 

<math display="inline" id="Rice's_theorem:45">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

, and therefore 

<math display="inline" id="Rice's_theorem:46">
 <semantics>
  <mrow>
   <msub>
    <mi>ϕ</mi>
    <mi>e</mi>
   </msub>
   <mo>∈</mo>
   <mi>F</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ϕ</ci>
     <ci>e</ci>
    </apply>
    <ci>F</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi_{e}\in F
  </annotation>
 </semantics>
</math>

. In both cases, we have a contradiction.</p>
<h2 id="proof-by-reduction-from-the-halting-problem">Proof by reduction from the halting problem</h2>
<h3 id="proof-sketch">Proof sketch</h3>

<p>Suppose, for concreteness, that we have an algorithm for examining a program <em>p</em> and determining infallibly whether <em>p</em> is an implementation of the squaring function, which takes an integer <em>d</em> and returns <em>d</em><sup>2</sup>. The proof works just as well if we have an algorithm for deciding any other nontrivial property of programs, and is given in general below.</p>

<p>The claim is that we can convert our algorithm for identifying squaring programs into one that identifies functions that halt. We will describe an algorithm that takes inputs <em>a</em> and <em>i</em> and determines whether program <em>a</em> halts when given input <em>i</em>.</p>

<p>The algorithm for deciding this is conceptually simple: it constructs (the description of) a new program <em>t</em> taking an argument <em>n</em>, which (1) first executes program <em>a</em> on input <em>i</em> (both <em>a</em> and <em>i</em> being hard-coded into the definition of <em>t</em>), and (2) then returns the square of <em>n</em>. If <em>a</em>(<em>i</em>) runs forever, then <em>t</em> never gets to step (2), regardless of <em>n</em>. Then clearly, <em>t</em> is a function for computing squares if and only if step (1) terminates. Since we've assumed that we can infallibly identify programs for computing squares, we can determine whether <em>t</em>, which depends on <em>a</em> and <em>i</em>, is such a program, and that for every <em>a</em> and <em>i</em>; thus we have obtained a program that decides whether program <em>a</em> halts on input <em>i</em>. Note that our halting-decision algorithm never executes <em>t</em>, but only passes its description to the squaring-identification program, which by assumption always terminates; since the construction of the description of <em>t</em> can also be done in a way that always terminates, the halting-decision cannot fail to halt either.</p>

<p><code> halts (a,i) {</code><br/>
<code>   define t(n) {</code><br/>
<code>     a(i)</code><br/>
<code>     </code><strong><code>return</code></strong><code> n×n</code><br/>
<code>   }</code><br/>
<code>   </code><strong><code>return</code></strong><code> is_a_squaring_function(t)</code><br/>
<code> }</code></p>

<p>This method doesn't depend specifically on being able to recognize functions that compute squares; as long as <em>some</em> program can do what we're trying to recognize, we can add a call to <em>a</em> to obtain our <em>t</em>. We could have had a method for recognizing programs for computing square roots, or programs for computing the monthly payroll, or programs that halt when given the input <code>"Abraxas"</code>, or programs that commit array bounds errors; in each case, we would be able to solve the halting problem similarly.</p>
<h3 id="formal-proof">Formal proof</h3>
<figure><b>(Figure)</b>
<figcaption>If we have an algorithm that decides a non-trivial property, we can construct a Turing machine that decides the halting problem.</figcaption>
</figure>

<p>For the formal proof, algorithms are presumed to define partial functions over <a href="string_(computer_science)" title="wikilink">strings</a> and are themselves represented by strings. The partial function computed by the algorithm represented by a string <em>a</em> is denoted <strong>F</strong><sub><em>a</em></sub>. This proof proceeds by <a href="reductio_ad_absurdum" title="wikilink">reductio ad absurdum</a>: we assume that there is a non-trivial property that is decided by an algorithm, and then show that it follows that we can decide the <a href="halting_problem" title="wikilink">halting problem</a>, which is not possible, and therefore a contradiction.</p>

<p>Let us now assume that <em>P</em>(<em>a</em>) is an algorithm that decides some non-trivial property of <strong>F</strong><sub><em>a</em></sub>. Without loss of generality we may assume that <em>P</em>(<em>no-halt</em>) = "no", with <em>no-halt</em> being the representation of an algorithm that never halts. If this is not true, then this holds for the negation of the property. Since <em>P</em> decides a non-trivial property, it follows that there is a string <em>b</em> that represents an algorithm and <em>P</em>(<em>b</em>) = "yes". We can then define an algorithm <em>H</em>(<em>a</em>, <em>i</em>) as follows:</p>
<dl>
<dd>1. construct a string <em>t</em> that represents an algorithm <em>T</em>(<em>j</em>) such that
<ul>
<li><em>T</em> first simulates the computation of <strong>F</strong><sub><em>a</em></sub>(<em>i</em>)</li>
<li>then <em>T</em> simulates the computation of <strong>F</strong><sub><em>b</em></sub>(<em>j</em>) and returns its result.</li>
</ul>
</dd>
<dd>2. return <em>P</em>(<em>t</em>).
</dd>
</dl>

<p>We can now show that <em>H</em> decides the halting problem:</p>
<ul>
<li>Assume that the algorithm represented by <em>a</em> halts on input <em>i</em>. In this case <strong>F</strong><sub><em>t</em></sub> = <strong>F</strong><sub><em>b</em></sub> and, because <em>P</em>(<em>b</em>) = "yes" and the output of <em>P</em>(<em>x</em>) depends only on <strong>F</strong><sub><em>x</em></sub>, it follows that <em>P</em>(<em>t</em>) = "yes" and, therefore <em>H</em>(<em>a</em>, <em>i</em>) = "yes".</li>
</ul>
<ul>
<li>Assume that the algorithm represented by <em>a</em> does not halt on input <em>i</em>. In this case <strong>F</strong><sub><em>t</em></sub> = <strong>F</strong><sub><em>no-halt</em></sub>, i.e., the partial function that is never defined. Since <em>P</em>(<em>no-halt</em>) = "no" and the output of <em>P</em>(<em>x</em>) depends only on <strong>F</strong><sub><em>x</em></sub>, it follows that <em>P</em>(<em>t</em>) = "no" and, therefore <em>H</em>(<em>a</em>, <em>i</em>) = "no".</li>
</ul>

<p>Since the halting problem is known to be undecidable, this is a contradiction and the assumption that there is an algorithm <em>P</em>(<em>a</em>) that decides a non-trivial property for the function represented by <em>a</em> must be false.</p>
<h2 id="rices-theorem-and-index-sets">Rice's theorem and index sets</h2>

<p>Rice's theorem can be succinctly stated in terms of index sets:</p>
<dl>
<dd><blockquote>

<p>Let 

<math display="inline" id="Rice's_theorem:47">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒞</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒞</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{C}
  </annotation>
 </semantics>
</math>

 be a class of partial recursive functions with <a href="index_set_(recursion_theory)" title="wikilink">index set</a> 

<math display="inline" id="Rice's_theorem:48">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

. Then 

<math display="inline" id="Rice's_theorem:49">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

 is recursive if and only if 

<math display="inline" id="Rice's_theorem:50">
 <semantics>
  <mrow>
   <mi>C</mi>
   <mo>=</mo>
   <mi mathvariant="normal">∅</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>C</ci>
    <emptyset></emptyset>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C=\emptyset
  </annotation>
 </semantics>
</math>

 or 

<math display="inline" id="Rice's_theorem:51">
 <semantics>
  <mrow>
   <mi>C</mi>
   <mo>=</mo>
   <mi>ℕ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>C</ci>
    <ci>ℕ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C=\mathbb{N}
  </annotation>
 </semantics>
</math>

.</p>
</blockquote>
</dd>
</dl>

<p>where 

<math display="inline" id="Rice's_theorem:52">
 <semantics>
  <mi>ℕ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℕ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{N}
  </annotation>
 </semantics>
</math>

 is the set of <a href="natural_numbers" title="wikilink">natural numbers</a>, including <a class="uri" href="zero" title="wikilink">zero</a>.</p>
<h2 id="an-analogue-of-rices-theorem-for-recursive-sets">An analogue of Rice's theorem for recursive sets</h2>

<p>One can regard Rice's theorem as asserting the impossibility of effectively deciding for any <em>recursively enumerable</em> set whether it has a certain nontrivial property.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> In this section, we give an analogue of Rice's theorem for <em>recursive sets,</em> instead of recursively enumerable sets.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> Roughly speaking, the analogue says that if one can effectively determine for any <em>recursive</em> set whether it has a certain property, then finitely many integers determine whether a recursive set has the property. This result is analogous to the original Rice's theorem because both assert that a property is "decidable" only if one can determine whether a set has that property by examining <em>for at most finitely many 

<math display="inline" id="Rice's_theorem:53">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

</em> (for no 

<math display="inline" id="Rice's_theorem:54">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

, for the original theorem), if 

<math display="inline" id="Rice's_theorem:55">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

 belongs to the set.</p>

<p>Let 

<math display="inline" id="Rice's_theorem:56">
 <semantics>
  <mi>W</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>W</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W
  </annotation>
 </semantics>
</math>

 be a class (called a <em>simple game</em> and thought of as a property) of recursive sets. If 

<math display="inline" id="Rice's_theorem:57">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 is a recursive set, then for some 

<math display="inline" id="Rice's_theorem:58">
 <semantics>
  <mi>e</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>e</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e
  </annotation>
 </semantics>
</math>

, computable function 

<math display="inline" id="Rice's_theorem:59">
 <semantics>
  <msub>
   <mi>ϕ</mi>
   <mi>e</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ϕ</ci>
    <ci>e</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi_{e}
  </annotation>
 </semantics>
</math>

 is the characteristic function of 

<math display="inline" id="Rice's_theorem:60">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

. We call 

<math display="inline" id="Rice's_theorem:61">
 <semantics>
  <mi>e</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>e</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e
  </annotation>
 </semantics>
</math>

 a <strong>characteristic index</strong> for 

<math display="inline" id="Rice's_theorem:62">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

. (There are infinitely many such 

<math display="inline" id="Rice's_theorem:63">
 <semantics>
  <mi>e</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>e</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e
  </annotation>
 </semantics>
</math>

.) Let's say the class 

<math display="inline" id="Rice's_theorem:64">
 <semantics>
  <mi>W</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>W</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W
  </annotation>
 </semantics>
</math>

 is <em>computable</em> if there is an algorithm (computable function) that decides for any nonnegative integer 

<math display="inline" id="Rice's_theorem:65">
 <semantics>
  <mi>e</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>e</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e
  </annotation>
 </semantics>
</math>

 (not necessarily a characteristic index),</p>
<ul>
<li>if 

<math display="inline" id="Rice's_theorem:66">
 <semantics>
  <mi>e</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>e</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e
  </annotation>
 </semantics>
</math>

 is a characteristic index for a recursive set belonging to 

<math display="inline" id="Rice's_theorem:67">
 <semantics>
  <mi>W</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>W</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W
  </annotation>
 </semantics>
</math>

, then the algorithm gives "yes";</li>
<li>if 

<math display="inline" id="Rice's_theorem:68">
 <semantics>
  <mi>e</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>e</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e
  </annotation>
 </semantics>
</math>

 is a characteristic index for a recursive set not belonging to 

<math display="inline" id="Rice's_theorem:69">
 <semantics>
  <mi>W</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>W</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W
  </annotation>
 </semantics>
</math>

, then the algorithm gives "no".</li>
</ul>

<p>A set 

<math display="inline" id="Rice's_theorem:70">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>⊆</mo>
   <mi>ℕ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <ci>S</ci>
    <ci>ℕ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S\subseteq\mathbb{N}
  </annotation>
 </semantics>
</math>

 <em>extends</em> a string 

<math display="inline" id="Rice's_theorem:71">
 <semantics>
  <mi>τ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>τ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau
  </annotation>
 </semantics>
</math>

 of 0's and 1's if for any 

<math display="inline" id="Rice's_theorem:72">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo><</mo>
   <mrow>
    <mo stretchy="false">|</mo>
    <mi>τ</mi>
    <mo stretchy="false">|</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <ci>k</ci>
    <apply>
     <abs></abs>
     <ci>τ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k<|\tau|
  </annotation>
 </semantics>
</math>

 (the length of 

<math display="inline" id="Rice's_theorem:73">
 <semantics>
  <mi>τ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>τ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau
  </annotation>
 </semantics>
</math>

), the 

<math display="inline" id="Rice's_theorem:74">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

th element of 

<math display="inline" id="Rice's_theorem:75">
 <semantics>
  <mi>τ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>τ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau
  </annotation>
 </semantics>
</math>

 is 1 if 

<math display="inline" id="Rice's_theorem:76">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>∈</mo>
   <mi>S</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>k</ci>
    <ci>S</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k\in S
  </annotation>
 </semantics>
</math>

; is 0 otherwise. For example, 

<math display="inline" id="Rice's_theorem:77">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mn>1</mn>
    <mo>,</mo>
    <mn>3</mn>
    <mo>,</mo>
    <mn>4</mn>
    <mo>,</mo>
    <mn>7</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>S</ci>
    <set>
     <cn type="integer">1</cn>
     <cn type="integer">3</cn>
     <cn type="integer">4</cn>
     <cn type="integer">7</cn>
     <ci>normal-…</ci>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S=\{1,3,4,7,\ldots\}
  </annotation>
 </semantics>
</math>

 extends string 

<math display="inline" id="Rice's_theorem:78">
 <semantics>
  <mn>01011001</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">01011001</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   01011001
  </annotation>
 </semantics>
</math>

. A string 

<math display="inline" id="Rice's_theorem:79">
 <semantics>
  <mi>τ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>τ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau
  </annotation>
 </semantics>
</math>

 is <em>winning determining</em> if any recursive set extending 

<math display="inline" id="Rice's_theorem:80">
 <semantics>
  <mi>τ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>τ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau
  </annotation>
 </semantics>
</math>

 belongs to 

<math display="inline" id="Rice's_theorem:81">
 <semantics>
  <mi>W</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>W</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W
  </annotation>
 </semantics>
</math>

. A string 

<math display="inline" id="Rice's_theorem:82">
 <semantics>
  <mi>τ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>τ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau
  </annotation>
 </semantics>
</math>

 is <em>losing determining</em> if no recursive set extending 

<math display="inline" id="Rice's_theorem:83">
 <semantics>
  <mi>τ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>τ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau
  </annotation>
 </semantics>
</math>

 belongs to 

<math display="inline" id="Rice's_theorem:84">
 <semantics>
  <mi>W</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>W</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W
  </annotation>
 </semantics>
</math>

.</p>

<p>We can now state the following <strong>analogue of Rice's theorem</strong> (Kreisel, Lacombe, and Shoenﬁeld, 1959,<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> Kumabe and Mihara, 2008<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a>):</p>

<p>A class 

<math display="inline" id="Rice's_theorem:85">
 <semantics>
  <mi>W</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>W</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W
  </annotation>
 </semantics>
</math>

 of recursive sets is computable if and only if there are a recursively enumerable set 

<math display="inline" id="Rice's_theorem:86">
 <semantics>
  <msub>
   <mi>T</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>T</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T_{0}
  </annotation>
 </semantics>
</math>

 of losing determining strings and a recursively enumerable set 

<math display="inline" id="Rice's_theorem:87">
 <semantics>
  <msub>
   <mi>T</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>T</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T_{1}
  </annotation>
 </semantics>
</math>

 of winning determining strings such that any recursive set extends a string in 

<math display="inline" id="Rice's_theorem:88">
 <semantics>
  <mrow>
   <msub>
    <mi>T</mi>
    <mn>0</mn>
   </msub>
   <mo>∪</mo>
   <msub>
    <mi>T</mi>
    <mn>1</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <union></union>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>T</ci>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>T</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T_{0}\cup T_{1}
  </annotation>
 </semantics>
</math>

.</p>

<p>This result has been applied to foundational problems in <a href="computational_social_choice" title="wikilink">computational social choice</a> (more broadly, <a href="algorithmic_game_theory" title="wikilink">algorithmic game theory</a>). For instance, Kumabe and Mihara (2008,<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> 2008<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a>) apply this result to an investigation of the <a href="Nakamura_number" title="wikilink">Nakamura numbers</a> for simple games in <a href="Cooperative_game" title="wikilink">cooperative game theory</a> and <a href="social_choice_theory" title="wikilink">social choice theory</a>.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Gödel's_incompleteness_theorems" title="wikilink">Gödel's incompleteness theorems</a></li>
<li><a href="Halting_Problem" title="wikilink">Halting Problem</a></li>
<li><a href="Rice-Shapiro_theorem" title="wikilink">Rice-Shapiro theorem</a></li>
<li><a href="Recursion_theory" title="wikilink">Recursion theory</a></li>
</ul>
<h2 id="notes">Notes</h2>
<references>
</references>
<h2 id="references">References</h2>
<ul>
<li>

<p>.</p></li>
<li>Rice, H. G. "<a href="http://links.jstor.org/sici?sici=0002-9947%28195303%2974%3A2%3C358%3ACORESA%3E2.0.CO%3B2-N">Classes of Recursively Enumerable Sets and Their Decision Problems</a>." Trans. Amer. Math. Soc. <strong>74</strong>, 358-366, 1953.</li>
<li>

<p>.</p></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Articles_containing_proofs" title="wikilink">Category:Articles containing proofs</a> <a href="Category:Articles_with_inconsistent_citation_formats" title="wikilink">Category:Articles with inconsistent citation formats</a> <a href="Category:Theorems_in_theory_of_computation" title="wikilink">Category:Theorems in theory of computation</a> <a href="Category:Theorems_in_the_foundations_of_mathematics" title="wikilink">Category:Theorems in the foundations of mathematics</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2">A set 

<math display="inline" id="Rice's_theorem:89">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>⊆</mo>
   <mi>ℕ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <ci>S</ci>
    <ci>ℕ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S\subseteq\mathbb{N}
  </annotation>
 </semantics>
</math>

 is <strong><a href="Recursively_enumerable_set" title="wikilink">recursively enumerable</a></strong> if 

<math display="inline" id="Rice's_theorem:90">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>=</mo>
   <msub>
    <mi>W</mi>
    <mi>e</mi>
   </msub>
   <mo>:=</mo>
   <mpadded width="+1.7pt">
    <mtext>dom</mtext>
   </mpadded>
   <msub>
    <mi>ϕ</mi>
    <mi>e</mi>
   </msub>
   <mo>:=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mi>x</mi>
    <mo>:</mo>
    <msub>
     <mi>ϕ</mi>
     <mi>e</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>↓</mo>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">S</csymbol>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>W</ci>
     <ci>e</ci>
    </apply>
    <csymbol cd="latexml">assign</csymbol>
    <mtext>dom</mtext>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ϕ</ci>
     <ci>e</ci>
    </apply>
    <csymbol cd="latexml">assign</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-{</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-:</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ϕ</ci>
      <ci>e</ci>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-↓</ci>
     <ci>normal-}</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S=W_{e}:=\textrm{dom}\,\phi_{e}:=\{x:\phi_{e}(x)\downarrow\}
  </annotation>
 </semantics>
</math>

 for some 

<math display="inline" id="Rice's_theorem:91">
 <semantics>
  <mi>e</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>e</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Rice's_theorem:92">
 <semantics>
  <msub>
   <mi>W</mi>
   <mi>e</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>W</ci>
    <ci>e</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W_{e}
  </annotation>
 </semantics>
</math>

 is the domain 

<math display="inline" id="Rice's_theorem:93">
 <semantics>
  <mrow>
   <mpadded width="+1.7pt">
    <mtext>dom</mtext>
   </mpadded>
   <msub>
    <mi>ϕ</mi>
    <mi>e</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <mtext>dom</mtext>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ϕ</ci>
     <ci>e</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textrm{dom}\,\phi_{e}
  </annotation>
 </semantics>
</math>

 (the set of inputs 

<math display="inline" id="Rice's_theorem:94">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Rice's_theorem:95">
 <semantics>
  <mrow>
   <msub>
    <mi>ϕ</mi>
    <mi>e</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ϕ</ci>
     <ci>e</ci>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi_{e}(x)
  </annotation>
 </semantics>
</math>

 is defined) of 

<math display="inline" id="Rice's_theorem:96">
 <semantics>
  <msub>
   <mi>ϕ</mi>
   <mi>e</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ϕ</ci>
    <ci>e</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi_{e}
  </annotation>
 </semantics>
</math>

. The result for recursively enumerable sets can be obtained from that for (partial) computable functions by considering the class 

<math display="inline" id="Rice's_theorem:97">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <msub>
    <mi>ϕ</mi>
    <mi>e</mi>
   </msub>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mpadded width="+1.7pt">
      <mtext>dom</mtext>
     </mpadded>
     <msub>
      <mi>ϕ</mi>
      <mi>e</mi>
     </msub>
    </mrow>
    <mo>∈</mo>
    <mi>C</mi>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">conditional-set</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ϕ</ci>
     <ci>e</ci>
    </apply>
    <apply>
     <in></in>
     <apply>
      <times></times>
      <mtext>dom</mtext>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ϕ</ci>
       <ci>e</ci>
      </apply>
     </apply>
     <ci>C</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{\phi_{e}:\textrm{dom}\,\phi_{e}\in C\}
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Rice's_theorem:98">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

 is a class of recursively enumerable sets.<a href="#fnref2">↩</a></li>
<li id="fn3">A recursively enumerable set 

<math display="inline" id="Rice's_theorem:99">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>⊆</mo>
   <mi>ℕ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <ci>S</ci>
    <ci>ℕ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S\subseteq\mathbb{N}
  </annotation>
 </semantics>
</math>

 is <strong><a href="Recursive_set" title="wikilink">recursive</a></strong> if its complement is recursively enumerable. Equivalently, 

<math display="inline" id="Rice's_theorem:100">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 is recursive if its characteristic function is computable.<a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
</ol>
</section>
</body>
</html>
