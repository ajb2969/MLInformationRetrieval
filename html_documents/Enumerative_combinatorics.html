<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="893">Enumerative combinatorics</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Enumerative combinatorics</h1>
<hr/>

<p><strong>Enumerative combinatorics</strong> is an area of <a class="uri" href="combinatorics" title="wikilink">combinatorics</a> that deals with the number of ways that certain patterns can be formed. Two examples of this type of problem are counting <a class="uri" href="combinations" title="wikilink">combinations</a> and counting <a class="uri" href="permutations" title="wikilink">permutations</a>. More generally, given an infinite collection of finite sets <em>S</em><sub><em>i</em></sub> indexed by the <a href="natural_number" title="wikilink">natural numbers</a>, enumerative combinatorics seeks to describe a <em>counting function</em> which counts the number of objects in <em>S</em><sub><em>n</em></sub> for each <em>n</em>. Although counting the number of elements in a set is a rather broad <a href="mathematical_problem" title="wikilink">mathematical problem</a>, many of the problems that arise in applications have a relatively simple <a class="uri" href="combinatorial" title="wikilink">combinatorial</a> description. The <a href="twelvefold_way" title="wikilink">twelvefold way</a> provides a unified framework for counting <a class="uri" href="permutations" title="wikilink">permutations</a>, <a class="uri" href="combinations" title="wikilink">combinations</a> and <a href="Partition_of_a_set" title="wikilink">partitions</a>.</p>

<p>The simplest such functions are <em><a href="closed_formula" title="wikilink">closed formulas</a></em>, which can be expressed as a composition of elementary functions such as <a href="factorial" title="wikilink">factorials</a>, powers, and so on. For instance, as shown below, the number of different possible orderings of a deck of <em>n</em> cards is <em>f</em>(<em>n</em>) = <em>n</em>!. The problem of finding a closed formula is known as <a href="algebraic_enumeration" title="wikilink">algebraic enumeration</a>, and frequently involves deriving a <a href="recurrence_relation" title="wikilink">recurrence relation</a> or <a href="generating_function" title="wikilink">generating function</a> and using this to arrive at the desired closed form.</p>

<p>Often, a complicated closed formula yields little insight into the behavior of the counting function as the number of counted objects grows. In these cases, a simple <a href="Asymptotic_analysis" title="wikilink">asymptotic</a> approximation may be preferable. A function 

<math display="inline" id="Enumerative_combinatorics:0">
 <semantics>
  <mrow>
   <mi>g</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>g</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g(n)
  </annotation>
 </semantics>
</math>

 is an asymptotic approximation to 

<math display="inline" id="Enumerative_combinatorics:1">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(n)
  </annotation>
 </semantics>
</math>

 if 

<math display="inline" id="Enumerative_combinatorics:2">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>n</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>/</mo>
     <mi>g</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>→</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <ci>f</ci>
       <ci>n</ci>
      </apply>
      <ci>g</ci>
     </apply>
     <ci>n</ci>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(n)/g(n)\rightarrow 1
  </annotation>
 </semantics>
</math>

 as 

<math display="inline" id="Enumerative_combinatorics:3">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>→</mo>
   <mi mathvariant="normal">∞</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>n</ci>
    <infinity></infinity>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n\rightarrow\infty
  </annotation>
 </semantics>
</math>

. In this case, we write 

<math display="inline" id="Enumerative_combinatorics:4">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>∼</mo>
    <mrow>
     <mi>g</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">similar-to</csymbol>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <times></times>
     <ci>g</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(n)\sim g(n).\,
  </annotation>
 </semantics>
</math>

</p>
<h2 id="generating-functions">Generating functions</h2>

<p>Generating functions are used to describe families of combinatorial objects. Let 

<math display="inline" id="Enumerative_combinatorics:5">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ℱ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℱ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{F}
  </annotation>
 </semantics>
</math>

 denote the family of objects and let <em>F</em>(<em>x</em>) be its generating function. Then:</p>

<p>

<math display="block" id="Enumerative_combinatorics:6">
 <semantics>
  <mrow>
   <mrow>
    <mi>F</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>n</mi>
      <mo>=</mo>
      <mn>0</mn>
     </mrow>
     <mi mathvariant="normal">∞</mi>
    </munderover>
    <mrow>
     <msub>
      <mi>f</mi>
      <mi>n</mi>
     </msub>
     <msup>
      <mi>x</mi>
      <mi>n</mi>
     </msup>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>F</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <sum></sum>
       <infinity></infinity>
      </apply>
      <apply>
       <eq></eq>
       <ci>n</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>f</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F(x)=\sum^{\infty}_{n=0}f_{n}x^{n}
  </annotation>
 </semantics>
</math>

 Where 

<math display="inline" id="Enumerative_combinatorics:7">
 <semantics>
  <msub>
   <mi>f</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>f</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{n}
  </annotation>
 </semantics>
</math>

 denotes the number of combinatorial objects of size <em>n</em>. The number of combinatorial objects of size <em>n</em> is therefore given by the coefficient of 

<math display="inline" id="Enumerative_combinatorics:8">
 <semantics>
  <msup>
   <mi>x</mi>
   <mi>n</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>x</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{n}
  </annotation>
 </semantics>
</math>

. Some common operation on families of combinatorial objects and its effect on the generating function will now be developed. The exponential generating function is also sometimes used. In this case it would have the form:</p>

<p>

<math display="block" id="Enumerative_combinatorics:9">
 <semantics>
  <mrow>
   <mrow>
    <mi>F</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>n</mi>
      <mo>=</mo>
      <mn>0</mn>
     </mrow>
     <mi mathvariant="normal">∞</mi>
    </munderover>
    <mrow>
     <mfrac>
      <msub>
       <mi>f</mi>
       <mi>n</mi>
      </msub>
      <mrow>
       <mi>n</mi>
       <mo lspace="0pt" rspace="3.5pt">!</mo>
      </mrow>
     </mfrac>
     <msup>
      <mi>x</mi>
      <mi>n</mi>
     </msup>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>F</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <sum></sum>
       <infinity></infinity>
      </apply>
      <apply>
       <eq></eq>
       <ci>n</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>f</ci>
        <ci>n</ci>
       </apply>
       <apply>
        <factorial></factorial>
        <ci>n</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F(x)=\sum^{\infty}_{n=0}\frac{f_{n}}{n!}x^{n}
  </annotation>
 </semantics>
</math>

</p>

<p>Once determined, the generating function yields the information given by the previous approaches. In addition, the various natural operations on generating functions such as addition, multiplication, differentiation, etc., have a combinatorial significance; this allows one to extend results from one combinatorial problem in order to solve others.</p>
<h3 id="union">Union</h3>

<p>Given two combinatorial families, 

<math display="inline" id="Enumerative_combinatorics:10">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ℱ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℱ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{F}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Enumerative_combinatorics:11">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒢</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒢</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{G}
  </annotation>
 </semantics>
</math>

 with generating functions <em>F</em>(<em>x</em>) and <em>G</em>(<em>x</em>) respectively, the union of the two families (

<math display="inline" id="Enumerative_combinatorics:12">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">ℱ</mi>
   <mo>∪</mo>
   <mi class="ltx_font_mathcaligraphic">𝒢</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <union></union>
    <ci>ℱ</ci>
    <ci>𝒢</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{F}\cup\mathcal{G}
  </annotation>
 </semantics>
</math>

) has generating function <em>F</em>(<em>x</em>) + <em>G</em>(<em>x</em>).</p>
<h3 id="pairs">Pairs</h3>

<p>For two combinatorial families as above the Cartesian product (pair) of the two families (

<math display="inline" id="Enumerative_combinatorics:13">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">ℱ</mi>
   <mo>×</mo>
   <mi class="ltx_font_mathcaligraphic">𝒢</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>ℱ</ci>
    <ci>𝒢</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{F}\times\mathcal{G}
  </annotation>
 </semantics>
</math>

) has generating function <em>F</em>(<em>x</em>)<em>G</em>(<em>x</em>).</p>
<h3 id="sequences">Sequences</h3>

<p>A sequence generalizes the idea of the pair as defined above. Sequences are arbitrary Cartesian products of a combinatorial object with itself. Formally:</p>

<p>

<math display="block" id="Enumerative_combinatorics:14">
 <semantics>
  <mrow>
   <mrow>
    <mtext>Seq</mtext>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi class="ltx_font_mathcaligraphic">ℱ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mpadded width="+5pt">
     <mi>ϵ</mi>
    </mpadded>
    <mo rspace="7.5pt">∪</mo>
    <mpadded width="+5pt">
     <mi class="ltx_font_mathcaligraphic">ℱ</mi>
    </mpadded>
    <mo rspace="7.5pt">∪</mo>
    <mrow>
     <mi class="ltx_font_mathcaligraphic">ℱ</mi>
     <mo>×</mo>
     <mpadded width="+5pt">
      <mi class="ltx_font_mathcaligraphic">ℱ</mi>
     </mpadded>
    </mrow>
    <mo rspace="7.5pt">∪</mo>
    <mrow>
     <mi class="ltx_font_mathcaligraphic">ℱ</mi>
     <mo>×</mo>
     <mi class="ltx_font_mathcaligraphic">ℱ</mi>
     <mo>×</mo>
     <mpadded width="+5pt">
      <mi class="ltx_font_mathcaligraphic">ℱ</mi>
     </mpadded>
    </mrow>
    <mo rspace="7.5pt">∪</mo>
    <mi mathvariant="normal">⋯</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <mtext>Seq</mtext>
     <ci>ℱ</ci>
    </apply>
    <apply>
     <union></union>
     <ci>ϵ</ci>
     <ci>ℱ</ci>
     <apply>
      <times></times>
      <ci>ℱ</ci>
      <ci>ℱ</ci>
     </apply>
     <apply>
      <times></times>
      <ci>ℱ</ci>
      <ci>ℱ</ci>
      <ci>ℱ</ci>
     </apply>
     <ci>normal-⋯</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mbox{Seq}(\mathcal{F})=\epsilon\ \cup\ \mathcal{F}\ \cup\ \mathcal{F}\times%
\mathcal{F}\ \cup\ \mathcal{F}\times\mathcal{F}\times\mathcal{F}\ \cup\cdots
  </annotation>
 </semantics>
</math>

</p>

<p>To put the above in words: An empty sequence or a sequence of one element or a sequence of two elements or a sequence of three elements, etc. The generating function would be:</p>

<p>

<math display="block" id="Enumerative_combinatorics:15">
 <semantics>
  <mrow>
   <mrow>
    <mn>1</mn>
    <mo>+</mo>
    <mrow>
     <mi>F</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <msup>
     <mrow>
      <mo stretchy="false">[</mo>
      <mrow>
       <mi>F</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">]</mo>
     </mrow>
     <mn>2</mn>
    </msup>
    <mo>+</mo>
    <msup>
     <mrow>
      <mo stretchy="false">[</mo>
      <mrow>
       <mi>F</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">]</mo>
     </mrow>
     <mn>3</mn>
    </msup>
    <mo>+</mo>
    <mi mathvariant="normal">⋯</mi>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mn>1</mn>
    <mrow>
     <mn>1</mn>
     <mo>-</mo>
     <mrow>
      <mi>F</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <cn type="integer">1</cn>
     <apply>
      <times></times>
      <ci>F</ci>
      <ci>x</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <times></times>
        <ci>F</ci>
        <ci>x</ci>
       </apply>
      </apply>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <times></times>
        <ci>F</ci>
        <ci>x</ci>
       </apply>
      </apply>
      <cn type="integer">3</cn>
     </apply>
     <ci>normal-⋯</ci>
    </apply>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
      <apply>
       <times></times>
       <ci>F</ci>
       <ci>x</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1+F(x)+[F(x)]^{2}+[F(x)]^{3}+\cdots=\frac{1}{1-F(x)}
  </annotation>
 </semantics>
</math>

</p>
<h2 id="combinatorial-structures">Combinatorial structures</h2>

<p>The above operations can now be used to enumerate common combinatorial objects including trees (binary and plane), <a href="Dyck_path" title="wikilink">Dyck paths</a> and cycles. A combinatorial structure is composed of atoms. For example, with trees the atoms would be the nodes. The atoms which compose the object can either be labeled or unlabeled. Unlabeled atoms are indistinguishable from each other, while labelled atoms are distinct. Therefore, for a combinatorial object consisting of labeled atoms a new object can be formed by simply swapping two or more atoms.</p>
<h3 id="binary-and-plane-trees">Binary and plane trees</h3>

<p>Binary and plane <a href="tree_(mathematics)" title="wikilink">trees</a> are examples of an unlabeled combinatorial structure. Trees consist of nodes linked by edges in such a way that there are no cycles. There is generally a node called the root, which has no parent node. In Plane trees each node can have an arbitrary number of children. In binary trees, a special case of plane trees, each node can have either two or no children. Let 

<math display="inline" id="Enumerative_combinatorics:16">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒫</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒫</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{P}
  </annotation>
 </semantics>
</math>

 denote the family of all plane trees. Then this family can be recursively defined as follows:</p>

<p>

<math display="block" id="Enumerative_combinatorics:17">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">𝒫</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <mo stretchy="false">{</mo>
      <mo>∙</mo>
      <mo stretchy="false">}</mo>
     </mrow>
     <mo>×</mo>
     <mtext>Seq</mtext>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi class="ltx_font_mathcaligraphic">𝒫</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>𝒫</ci>
    <apply>
     <times></times>
     <apply>
      <times></times>
      <set>
       <ci>normal-∙</ci>
      </set>
      <mtext>Seq</mtext>
     </apply>
     <ci>𝒫</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{P}=\{\bullet\}\times\mbox{Seq}(\mathcal{P})
  </annotation>
 </semantics>
</math>

 In this case 

<math display="inline" id="Enumerative_combinatorics:18">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mo>∙</mo>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <ci>normal-∙</ci>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{\bullet\}
  </annotation>
 </semantics>
</math>

 represents the family of objects consisting of one node. This has generating function <em>x</em>. Let <em>P</em>(<em>x</em>) denote the generating function 

<math display="inline" id="Enumerative_combinatorics:19">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒫</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒫</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{P}
  </annotation>
 </semantics>
</math>

 Putting the above description in words: A plane tree consists of a node to which is attached an arbitrary number of subtrees, each of which is also a plane tree. Using the operation on families of combinatorial structures developed earlier this translates to a recursive generating function:</p>

<p>

<math display="block" id="Enumerative_combinatorics:20">
 <semantics>
  <mrow>
   <mrow>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>x</mi>
    <mfrac>
     <mn>1</mn>
     <mrow>
      <mn>1</mn>
      <mo>-</mo>
      <mrow>
       <mi>P</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </mfrac>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>P</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <ci>x</ci>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
       <apply>
        <times></times>
        <ci>P</ci>
        <ci>x</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(x)=x\frac{1}{1-P(x)}
  </annotation>
 </semantics>
</math>

 After solving for <em>P</em>(<em>x</em>):</p>

<p>

<math display="block" id="Enumerative_combinatorics:21">
 <semantics>
  <mrow>
   <mrow>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mn>1</mn>
     <mo>-</mo>
     <msqrt>
      <mrow>
       <mn>1</mn>
       <mo>-</mo>
       <mrow>
        <mn>4</mn>
        <mi>x</mi>
       </mrow>
      </mrow>
     </msqrt>
    </mrow>
    <mn>2</mn>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>P</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
      <apply>
       <root></root>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
        <apply>
         <times></times>
         <cn type="integer">4</cn>
         <ci>x</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(x)=\frac{1-\sqrt{1-4x}}{2}
  </annotation>
 </semantics>
</math>

</p>

<p>An explicit formula for the number of plane trees of size <em>n</em> can now be determined by extracting the coefficient of <em>x</em><sup><em>n</em></sup>.</p>

<p>

<math display="inline" id="Enumerative_combinatorics:22">
 <semantics>
  <msub>
   <mi>p</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>p</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle p_{n}
  </annotation>
 </semantics>
</math>


</p>

<p>Note: The notation [<em>x</em><sup><em>n</em></sup>] <em>f</em>(<em>x</em>) refers to the coefficient of <em>x</em><sup><em>n</em></sup> in <em>f</em>(<em>x</em>). The series expansion of the square root is based on Newton's generalization of the <a href="Binomial_theorem#Newton's_generalised_binomial_theorem" title="wikilink">binomial theorem</a>. To get from the fourth to fifth line manipulations using the <a href="Binomial_coefficient#Generalization_and_connection_to_the_binomial_series" title="wikilink">generalized binomial coefficient</a> is needed.</p>

<p>The expression on the last line is equal to the (<em>n</em> − 1)<sup>th</sup> <a href="Catalan_number" title="wikilink">Catalan number</a>. Therefore <em>p</em><sub><em>n</em></sub> = <em>c</em><sub><em>n</em>−1</sub>.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Combinatorial_principles" title="wikilink">Combinatorial principles</a></li>
<li><a href="Algebraic_combinatorics" title="wikilink">Algebraic combinatorics</a></li>
<li><a href="Asymptotic_combinatorics" title="wikilink">Asymptotic combinatorics</a></li>
<li><a href="Combinatorial_explosion" title="wikilink">Combinatorial explosion</a></li>
<li><a href="Inclusion-exclusion_principle" title="wikilink">Inclusion-exclusion principle</a></li>
<li><a href="Method_of_distinguished_element" title="wikilink">Method of distinguished element</a></li>
<li><a href="Combinatorial_species" title="wikilink">Combinatorial species</a></li>
<li><a href="Sieve_theory" title="wikilink">Sieve theory</a></li>
<li><a href="Pólya_enumeration_theorem" title="wikilink">Pólya enumeration theorem</a></li>
<li><a href="Burnside's_lemma" title="wikilink">Burnside's lemma</a></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li><a href="Doron_Zeilberger" title="wikilink">Zeilberger, D.</a>, <a href="http://www.math.rutgers.edu/~zeilberg/mamarim/mamarimPDF/enuPCM.pdf">Enumerative and Algebraic Combinatorics</a></li>
<li>Bjorner, A. and <a href="Richard_P._Stanley" title="wikilink">Stanley, R. P.</a>, <a href="http://www-math.mit.edu/~rstan/papers/comb.pdf"><em>A Combinatorial Miscellany</em></a></li>
<li>Graham, R.L., Grötschel M., and Lovász L., eds. (1996). <em>Handbook of Combinatorics</em>, Volumes 1 and 2. Elsevier (North-Holland), Amsterdam, and MIT Press, Cambridge, Mass. ISBN 0-262-07169-X.</li>
<li></li>
<li>Loehr, Nicholas A. (2011). <a href="http://www.math.vt.edu/people/nloehr/bijbook.html">Bijective Combinatorics</a>. <a href="http://www.crcpress.com">CRC Press</a>. ISBN 143984884X, ISBN 978-1439848845.</li>
<li><a href="Richard_P._Stanley" title="wikilink">Stanley, Richard P.</a> (1997, 1999). <a href="http://www-math.mit.edu/~rstan/ec/"><em>Enumerative Combinatorics</em>, Volumes 1 and 2</a>. <a href="Cambridge_University_Press" title="wikilink">Cambridge University Press</a>. ISBN 0-521-55309-1, ISBN 0-521-56069-1.</li>
<li><a href="http://encyclopedia.jrank.org/CLI_COM/COMBINATORIAL_ANALYSIS.html">Combinatorial Analysis</a> – an article in <a href="Encyclopædia_Britannica_Eleventh_Edition" title="wikilink">Encyclopædia Britannica Eleventh Edition</a></li>
<li><a href="John_Riordan_(mathematician)" title="wikilink">Riordan, John</a> (1958). <em>An Introduction to Combinatorial Analysis</em>, Wiley &amp; Sons, New York (republished).</li>
<li>Riordan, John (1968). <em>Combinatorial identities</em>, Wiley &amp; Sons, New York (republished).</li>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Enumerative_combinatorics" title="wikilink">*</a></p>
</body>
</html>
