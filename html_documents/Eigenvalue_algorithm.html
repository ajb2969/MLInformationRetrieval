<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1416">Eigenvalue algorithm</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Eigenvalue algorithm</h1>
<style>
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
<style>
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
</body></html>
<body>
<hr/>

<p>In <a href="numerical_analysis" title="wikilink">numerical analysis</a>, one of the most important problems is designing efficient and <a href="Numerical_stability" title="wikilink">stable</a> <a href="algorithm" title="wikilink">algorithms</a> for finding the <a href="eigenvalue" title="wikilink">eigenvalues</a> of a <a href="Matrix_(mathematics)" title="wikilink">matrix</a>. These <strong>eigenvalue algorithms</strong> may also find <a class="uri" href="eigenvectors" title="wikilink">eigenvectors</a>.</p>
<h2 id="eigenvalues-and-eigenvectors">Eigenvalues and eigenvectors</h2>

<p>Given an 

<math display="inline" id="Eigenvalue_algorithm:0">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mi mathvariant="normal">×</mi>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>n</ci>
    <ci>normal-×</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n×n
  </annotation>
 </semantics>
</math>

 <a href="Square_matrix#Square_matrices" title="wikilink">square matrix</a> 

<math display="inline" id="Eigenvalue_algorithm:1">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 of <a href="Real_number" title="wikilink">real</a> or <a href="Complex_number" title="wikilink">complex</a> numbers, an <em><a class="uri" href="eigenvalue" title="wikilink">eigenvalue</a></em> 

<math display="inline" id="Eigenvalue_algorithm:2">
 <semantics>
  <mi>λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   λ
  </annotation>
 </semantics>
</math>

 and its associated <em><a href="generalized_eigenvector" title="wikilink">generalized eigenvector</a></em> 

<math display="inline" id="Eigenvalue_algorithm:3">
 <semantics>
  <mi>𝐯</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐯</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{v}
  </annotation>
 </semantics>
</math>

 are a pair obeying the relation<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>

<p>

<math display="block" id="Eigenvalue_algorithm:4">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msup>
      <mrow>
       <mo>(</mo>
       <mrow>
        <mi>A</mi>
        <mo>-</mo>
        <mrow>
         <mi>λ</mi>
         <mi>I</mi>
        </mrow>
       </mrow>
       <mo>)</mo>
      </mrow>
      <mi>k</mi>
     </msup>
     <mi>𝕧</mi>
    </mrow>
    <mo>=</mo>
    <mn>0</mn>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <minus></minus>
       <ci>A</ci>
       <apply>
        <times></times>
        <ci>λ</ci>
        <ci>I</ci>
       </apply>
      </apply>
      <ci>k</ci>
     </apply>
     <ci>𝕧</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left(A-\lambda I\right)^{k}{\mathbb{v}}=0,
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Eigenvalue_algorithm:5">
 <semantics>
  <mi>𝐯</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐯</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{v}
  </annotation>
 </semantics>
</math>

 is a nonzero 

<math display="inline" id="Eigenvalue_algorithm:6">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mi mathvariant="normal">×</mi>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>n</ci>
    <ci>normal-×</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n×1
  </annotation>
 </semantics>
</math>

 column vector, 

<math display="inline" id="Eigenvalue_algorithm:7">
 <semantics>
  <mi>I</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>I</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I
  </annotation>
 </semantics>
</math>

 is the 

<math display="inline" id="Eigenvalue_algorithm:8">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mi mathvariant="normal">×</mi>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>n</ci>
    <ci>normal-×</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n×n
  </annotation>
 </semantics>
</math>

 <a href="identity_matrix" title="wikilink">identity matrix</a>, 

<math display="inline" id="Eigenvalue_algorithm:9">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 is a positive integer, and both 

<math display="inline" id="Eigenvalue_algorithm:10">
 <semantics>
  <mi>λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   λ
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Eigenvalue_algorithm:11">
 <semantics>
  <mi>𝐯</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐯</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{v}
  </annotation>
 </semantics>
</math>

 are allowed to be complex even when 

<math display="inline" id="Eigenvalue_algorithm:12">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 is real. When 

<math display="inline" id="Eigenvalue_algorithm:13">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>k</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k=1
  </annotation>
 </semantics>
</math>

, the vector is called simply an <em><a class="uri" href="eigenvector" title="wikilink">eigenvector</a></em>, and the pair is called an <em>eigenpair</em>. In this case, 

<math display="inline" id="Eigenvalue_algorithm:14">
 <semantics>
  <mrow>
   <mrow>
    <mi>A</mi>
    <mi>𝐯</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>λ</mi>
    <mi>𝐯</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>A</ci>
     <ci>𝐯</ci>
    </apply>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>𝐯</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\mathbf{v}=λ\mathbf{v}
  </annotation>
 </semantics>
</math>

. Any eigenvalue 

<math display="inline" id="Eigenvalue_algorithm:15">
 <semantics>
  <mi>λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   λ
  </annotation>
 </semantics>
</math>

 of 

<math display="inline" id="Eigenvalue_algorithm:16">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 has ordinary<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> eigenvectors associated to it, for if 

<math display="inline" id="Eigenvalue_algorithm:17">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 is the smallest integer such that <mtpl></mtpl> for a generalized eigenvector 

<math display="inline" id="Eigenvalue_algorithm:18">
 <semantics>
  <mi>𝐯</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐯</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{v}
  </annotation>
 </semantics>
</math>

, then <mtpl></mtpl> is an ordinary eigenvector. The value 

<math display="inline" id="Eigenvalue_algorithm:19">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 can always be taken as less than or equal to 

<math display="inline" id="Eigenvalue_algorithm:20">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

. In particular, <mtpl></mtpl> for all generalized eigenvectors 

<math display="inline" id="Eigenvalue_algorithm:21">
 <semantics>
  <mi>𝐯</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐯</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{v}
  </annotation>
 </semantics>
</math>

 associated with 

<math display="inline" id="Eigenvalue_algorithm:22">
 <semantics>
  <mrow>
   <mi>λ</mi>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <ci>λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   λ.
  </annotation>
 </semantics>
</math>

</p>

<p>For each eigenvalue 

<math display="inline" id="Eigenvalue_algorithm:23">
 <semantics>
  <mi>λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   λ
  </annotation>
 </semantics>
</math>

 of 

<math display="inline" id="Eigenvalue_algorithm:24">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

, the <a href="kernel_(matrix)" title="wikilink">kernel</a> 

<math display="inline" id="Eigenvalue_algorithm:25">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mi>e</mi>
   <mi>r</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>A</mi>
     <mo>-</mo>
     <mrow>
      <mi>λ</mi>
      <mi>I</mi>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>k</ci>
    <ci>e</ci>
    <ci>r</ci>
    <apply>
     <minus></minus>
     <ci>A</ci>
     <apply>
      <times></times>
      <ci>λ</ci>
      <ci>I</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ker(A-λI)
  </annotation>
 </semantics>
</math>

 consists of all eigenvectors associated with 

<math display="inline" id="Eigenvalue_algorithm:26">
 <semantics>
  <mi>λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   λ
  </annotation>
 </semantics>
</math>

 (along with 0), called the <em><a class="uri" href="eigenspace" title="wikilink">eigenspace</a></em> of 

<math display="inline" id="Eigenvalue_algorithm:27">
 <semantics>
  <mi>λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   λ
  </annotation>
 </semantics>
</math>

, while the vector space <mtpl></mtpl> consists of all generalized eigenvectors, and is called the <em><a href="generalized_eigenspace" title="wikilink">generalized eigenspace</a></em>. The <em><a href="geometric_multiplicity" title="wikilink">geometric multiplicity</a></em> of 

<math display="inline" id="Eigenvalue_algorithm:28">
 <semantics>
  <mi>λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   λ
  </annotation>
 </semantics>
</math>

 is the dimension of its eigenspace. The <em><a href="algebraic_multiplicity" title="wikilink">algebraic multiplicity</a></em> of 

<math display="inline" id="Eigenvalue_algorithm:29">
 <semantics>
  <mi>λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   λ
  </annotation>
 </semantics>
</math>

 is the dimension of its generalized eigenspace. The latter terminology is justified by the equation</p>

<p>

<math display="block" id="Eigenvalue_algorithm:30">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>p</mi>
      <mi>A</mi>
     </msub>
     <mrow>
      <mo>(</mo>
      <mi>z</mi>
      <mo>)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>det</mi>
     <mrow>
      <mo>(</mo>
      <mrow>
       <mrow>
        <mi>z</mi>
        <mi>I</mi>
       </mrow>
       <mo>-</mo>
       <mi>A</mi>
      </mrow>
      <mo>)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∏</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>k</mi>
     </munderover>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>z</mi>
        <mo>-</mo>
        <msub>
         <mi>λ</mi>
         <mi>i</mi>
        </msub>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <msub>
       <mi>α</mi>
       <mi>i</mi>
      </msub>
     </msup>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <ci>A</ci>
      </apply>
      <ci>z</ci>
     </apply>
     <apply>
      <times></times>
      <ci>det</ci>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <ci>z</ci>
        <ci>I</ci>
       </apply>
       <ci>A</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <csymbol cd="latexml">product</csymbol>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>k</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <minus></minus>
        <ci>z</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>λ</ci>
         <ci>i</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>α</ci>
        <ci>i</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{A}\left(z\right)={\rm det}\left(zI-A\right)=\prod_{i=1}^{k}(z-\lambda_{i})^%
{\alpha_{i}},
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Eigenvalue_algorithm:31">
 <semantics>
  <mrow>
   <mi>d</mi>
   <mi>e</mi>
   <mi>t</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>d</ci>
    <ci>e</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   det
  </annotation>
 </semantics>
</math>

 is the <a class="uri" href="determinant" title="wikilink">determinant</a> function, the <mtpl></mtpl> are all the distinct eigenvalues of 

<math display="inline" id="Eigenvalue_algorithm:32">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 and the <mtpl></mtpl> are the corresponding algebraic multiplicities. The function <mtpl></mtpl> is the <em><a href="characteristic_polynomial" title="wikilink">characteristic polynomial</a></em> of 

<math display="inline" id="Eigenvalue_algorithm:33">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

. So the algebraic multiplicity is the multiplicity of the eigenvalue as a <a href="Properties_of_polynomial_roots" title="wikilink">zero</a> of the characteristic polynomial. Since any eigenvector is also a generalized eigenvector, the geometric multiplicity is less than or equal to the algebraic multiplicity. The algebraic multiplicities sum up to 

<math display="inline" id="Eigenvalue_algorithm:34">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

, the degree of the characteristic polynomial. The equation <mtpl></mtpl> is called the <em>characteristic equation</em>, as its roots are exactly the eigenvalues of 

<math display="inline" id="Eigenvalue_algorithm:35">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

. By the <a href="Cayley-Hamilton_theorem" title="wikilink">Cayley-Hamilton theorem</a>, 

<math display="inline" id="Eigenvalue_algorithm:36">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 itself obeys the same equation: <mtpl></mtpl><a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> As a consequence, the columns of the matrix 

<math display="inline" id="Eigenvalue_algorithm:37">
 <semantics>
  <mrow>
   <msub>
    <mo largeop="true" symmetric="true">∏</mo>
    <mrow>
     <mi>i</mi>
     <mo>≠</mo>
     <mi>j</mi>
    </mrow>
   </msub>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>A</mi>
      <mo>-</mo>
      <mrow>
       <msub>
        <mi>λ</mi>
        <mi>i</mi>
       </msub>
       <mi>I</mi>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <msub>
     <mi>α</mi>
     <mi>i</mi>
    </msub>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">product</csymbol>
     <apply>
      <neq></neq>
      <ci>i</ci>
      <ci>j</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <minus></minus>
      <ci>A</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>λ</ci>
        <ci>i</ci>
       </apply>
       <ci>I</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>α</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle\prod_{i\neq j}(A-\lambda_{i}I)^{\alpha_{i}}
  </annotation>
 </semantics>
</math>

 must be either 0 or generalized eigenvectors of the eigenvalue <mtpl></mtpl>, since they are annihilated by 

<math display="inline" id="Eigenvalue_algorithm:38">
 <semantics>
  <mrow>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>A</mi>
      <mo>-</mo>
      <mrow>
       <msub>
        <mi>λ</mi>
        <mi>j</mi>
       </msub>
       <mi>I</mi>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <msub>
     <mi>α</mi>
     <mi>j</mi>
    </msub>
   </msup>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <minus></minus>
     <ci>A</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>λ</ci>
       <ci>j</ci>
      </apply>
      <ci>I</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>α</ci>
     <ci>j</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle(A-\lambda_{j}I)^{\alpha_{j}}.
  </annotation>
 </semantics>
</math>

 In fact, the <a href="column_space" title="wikilink">column space</a> is the generalized eigenspace of <mtpl></mtpl></p>

<p>Any collection of generalized eigenvectors of distinct eigenvalues is linearly independent, so a basis for all of <mtpl></mtpl> can be chosen consisting of generalized eigenvectors. More particularly, this basis <mtpl><strong>v</strong><sub><em>i</em></sub>{{)}}1}}}}</mtpl> can be chosen and organized so that</p>

<p>:* if <mtpl></mtpl> and <mtpl></mtpl> have the same eigenvalue, then so does <mtpl></mtpl> for each 

<math display="inline" id="Eigenvalue_algorithm:39">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 between 

<math display="inline" id="Eigenvalue_algorithm:40">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Eigenvalue_algorithm:41">
 <semantics>
  <mi>j</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>j</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   j
  </annotation>
 </semantics>
</math>

, and</p>

<p>:* if <mtpl></mtpl> is not an ordinary eigenvector, and if <mtpl></mtpl> is its eigenvalue, then <mtpl></mtpl> (in particular, <mtpl></mtpl> must be an ordinary eigenvector). If these basis vectors are placed as the column vectors of a matrix <mtpl> [ <strong>v</strong><sub>1</sub> <strong>v</strong><sub>2</sub> ... <strong>v</strong><sub><em>n</em></sub> ]}}</mtpl>, then 

<math display="inline" id="Eigenvalue_algorithm:42">
 <semantics>
  <mi>V</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>V</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V
  </annotation>
 </semantics>
</math>

 can be used to convert 

<math display="inline" id="Eigenvalue_algorithm:43">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 to its <a href="Jordan_normal_form" title="wikilink">Jordan normal form</a>:</p>

<p>

<math display="block" id="Eigenvalue_algorithm:44">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msup>
      <mi>V</mi>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msup>
     <mi>A</mi>
     <mi>V</mi>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo>[</mo>
     <mtable displaystyle="true">
      <mtr>
       <mtd columnalign="center">
        <msub>
         <mi>λ</mi>
         <mn>1</mn>
        </msub>
       </mtd>
       <mtd columnalign="center">
        <msub>
         <mi>β</mi>
         <mn>1</mn>
        </msub>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mi mathvariant="normal">…</mi>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <msub>
         <mi>λ</mi>
         <mn>2</mn>
        </msub>
       </mtd>
       <mtd columnalign="center">
        <msub>
         <mi>β</mi>
         <mn>2</mn>
        </msub>
       </mtd>
       <mtd columnalign="center">
        <mi mathvariant="normal">…</mi>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <msub>
         <mi>λ</mi>
         <mn>3</mn>
        </msub>
       </mtd>
       <mtd columnalign="center">
        <mi mathvariant="normal">…</mi>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mi mathvariant="normal">⋮</mi>
       </mtd>
       <mtd columnalign="center">
        <mi mathvariant="normal">⋮</mi>
       </mtd>
       <mtd columnalign="center">
        <mi mathvariant="normal">⋮</mi>
       </mtd>
       <mtd columnalign="center">
        <mi mathvariant="normal">⋱</mi>
       </mtd>
       <mtd columnalign="center">
        <mi mathvariant="normal">⋮</mi>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mi mathvariant="normal">…</mi>
       </mtd>
       <mtd columnalign="center">
        <msub>
         <mi>λ</mi>
         <mi>n</mi>
        </msub>
       </mtd>
      </mtr>
     </mtable>
     <mo>]</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>V</ci>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>A</ci>
     <ci>V</ci>
    </apply>
    <matrix>
     <matrixrow>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>λ</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>β</ci>
       <cn type="integer">1</cn>
      </apply>
      <cn type="integer">0</cn>
      <ci>normal-…</ci>
      <cn type="integer">0</cn>
     </matrixrow>
     <matrixrow>
      <cn type="integer">0</cn>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>λ</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>β</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-…</ci>
      <cn type="integer">0</cn>
     </matrixrow>
     <matrixrow>
      <cn type="integer">0</cn>
      <cn type="integer">0</cn>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>λ</ci>
       <cn type="integer">3</cn>
      </apply>
      <ci>normal-…</ci>
      <cn type="integer">0</cn>
     </matrixrow>
     <matrixrow>
      <ci>normal-⋮</ci>
      <ci>normal-⋮</ci>
      <ci>normal-⋮</ci>
      <ci>normal-⋱</ci>
      <ci>normal-⋮</ci>
     </matrixrow>
     <matrixrow>
      <cn type="integer">0</cn>
      <cn type="integer">0</cn>
      <cn type="integer">0</cn>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>λ</ci>
       <ci>n</ci>
      </apply>
     </matrixrow>
    </matrix>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V^{-1}AV=\begin{bmatrix}\lambda_{1}&\beta_{1}&0&\ldots&0\\
0&\lambda_{2}&\beta_{2}&\ldots&0\\
0&0&\lambda_{3}&\ldots&0\\
\vdots&\vdots&\vdots&\ddots&\vdots\\
0&0&0&\ldots&\lambda_{n}\end{bmatrix},
  </annotation>
 </semantics>
</math>

</p>

<p>where the <mtpl></mtpl> are the eigenvalues, <mtpl></mtpl> if <mtpl></mtpl> and <mtpl></mtpl> otherwise.</p>

<p>More generally, if 

<math display="inline" id="Eigenvalue_algorithm:45">
 <semantics>
  <mi>W</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>W</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W
  </annotation>
 </semantics>
</math>

 is any invertible matrix, and 

<math display="inline" id="Eigenvalue_algorithm:46">
 <semantics>
  <mi>λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   λ
  </annotation>
 </semantics>
</math>

 is an eigenvalue of 

<math display="inline" id="Eigenvalue_algorithm:47">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 with generalized eigenvector 

<math display="inline" id="Eigenvalue_algorithm:48">
 <semantics>
  <mi>𝐯</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐯</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{v}
  </annotation>
 </semantics>
</math>

, then <mtpl></mtpl>. Thus 

<math display="inline" id="Eigenvalue_algorithm:49">
 <semantics>
  <mi>λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   λ
  </annotation>
 </semantics>
</math>

 is an eigenvalue of <mtpl></mtpl> with generalized eigenvector <mtpl></mtpl>. That is, <a href="similar_matrices" title="wikilink">similar matrices</a> have the same eigenvalues.</p>
<h3 id="normal-hermitian-and-real-symmetric-matrices">Normal, hermitian, and real-symmetric matrices</h3>

<p>The <a href="conjugate_transpose" title="wikilink">adjoint</a> <mtpl></mtpl> of a complex matrix 

<math display="inline" id="Eigenvalue_algorithm:50">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 is the transpose of the conjugate of 

<math display="inline" id="Eigenvalue_algorithm:51">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

: <mtpl></mtpl>. A square matrix 

<math display="inline" id="Eigenvalue_algorithm:52">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 is called <em><a href="Normal_matrix" title="wikilink">normal</a></em> if it commutes with its adjoint: <mtpl></mtpl>. It is called <em><a href="Hermitian_matrix" title="wikilink">hermitian</a></em> if it is equal to its adjoint: <mtpl></mtpl>. All hermitian matrices are normal. If 

<math display="inline" id="Eigenvalue_algorithm:53">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 has only real elements, then the adjoint is just the transpose, and 

<math display="inline" id="Eigenvalue_algorithm:54">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 is hermitian if and only if it is <a href="symmetric_matrix" title="wikilink">symmetric</a>. When applied to column vectors, the adjoint can be used to define the canonical inner product on <mtpl></mtpl>: <mtpl></mtpl>.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> Normal, hermitian, and real-symmetric matrices have several useful properties:</p>

<p>:* Every generalized eigenvector of a normal matrix is an ordinary eigenvector.</p>

<p>:* Any normal matrix is similar to a diagonal matrix, since its Jordan normal form is diagonal.</p>

<p>:* Eigenvectors of distinct eigenvalues of a normal matrix are orthogonal.</p>

<p>:* For any normal matrix 

<math display="inline" id="Eigenvalue_algorithm:55">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

, <mtpl></mtpl> has an orthonormal basis consisting of eigenvectors of 

<math display="inline" id="Eigenvalue_algorithm:56">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

. The corresponding matrix of eigenvectors is <a href="Unitary_matrix" title="wikilink">unitary</a>.</p>

<p>:* The eigenvalues of a hermitian matrix are real, since <mtpl></mtpl> for a non-zero eigenvector 

<math display="inline" id="Eigenvalue_algorithm:57">
 <semantics>
  <mi>𝐯</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐯</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{v}
  </annotation>
 </semantics>
</math>

.</p>

<p>:* If 

<math display="inline" id="Eigenvalue_algorithm:58">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 is real, there is an orthonormal basis for <mtpl></mtpl> consisting of eigenvectors of 

<math display="inline" id="Eigenvalue_algorithm:59">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 if and only if 

<math display="inline" id="Eigenvalue_algorithm:60">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 is symmetric.</p>

<p>It is possible for a real or complex matrix to have all real eigenvalues without being hermitian. For example, a real <a href="triangular_matrix" title="wikilink">triangular matrix</a> has its eigenvalues along its diagonal, but in general is not symmetric.</p>
<h2 id="condition-number">Condition number</h2>

<p>Any problem of numeric calculation can be viewed as the evaluation of some function ƒ for some input 

<math display="inline" id="Eigenvalue_algorithm:61">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

. The <a href="condition_number" title="wikilink">condition number</a> 

<math display="inline" id="Eigenvalue_algorithm:62">
 <semantics>
  <mrow>
   <mi>κ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>ƒ</mi>
    <mo>,</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>κ</ci>
    <interval closure="open">
     <ci>ƒ</ci>
     <ci>x</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   κ(ƒ,x)
  </annotation>
 </semantics>
</math>

 of the problem is the ratio of the relative error in the function's output to the relative error in the input, and varies with both the function and the input. The condition number describes how error grows during the calculation. Its base-10 logarithm tells how many fewer digits of accuracy exist in the result than existed in the input. The condition number is a best-case scenario. It reflects the instability built into the problem, regardless of how it is solved. No algorithm can ever produce more accurate results than indicated by the condition number, except by chance. However, a poorly designed algorithm may produce significantly worse results. For example, as mentioned below, the problem of finding eigenvalues for normal matrices is always well-conditioned. However, the problem of finding the roots of a polynomial can be <a href="Wilkinson's_polynomial" title="wikilink">very ill-conditioned</a>. Thus eigenvalue algorithms that work by finding the roots of the characteristic polynomial can be ill-conditioned even when the problem is not.</p>

<p>For the problem of solving the linear equation 

<math display="inline" id="Eigenvalue_algorithm:63">
 <semantics>
  <mrow>
   <mrow>
    <mi>A</mi>
    <mi>𝐯</mi>
   </mrow>
   <mo>=</mo>
   <mi>𝐛</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>A</ci>
     <ci>𝐯</ci>
    </apply>
    <ci>𝐛</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\mathbf{v}=\mathbf{b}
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Eigenvalue_algorithm:64">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 is invertible, the condition number <mtpl></mtpl> is given by <mtpl><em>A</em>{{!!}}<sub>op</sub>{{!!}}<em>A</em><sup>−1</sup>{{!!}}<sub>op</sub>}}</mtpl>, where <mtpl> {{!!}}<sub>op</sub>}}</mtpl> is the <a href="operator_norm" title="wikilink">operator norm</a> subordinate to the normal <a href="Norm_(mathematics)#Euclidean_norm" title="wikilink">Euclidean norm</a> on <mtpl></mtpl>. Since this number is independent of 

<math display="inline" id="Eigenvalue_algorithm:65">
 <semantics>
  <mi>𝐛</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐛</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{b}
  </annotation>
 </semantics>
</math>

 and is the same for 

<math display="inline" id="Eigenvalue_algorithm:66">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 and <mtpl></mtpl>, it is usually just called the condition number 

<math display="inline" id="Eigenvalue_algorithm:67">
 <semantics>
  <mrow>
   <mi>κ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>A</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>κ</ci>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   κ(A)
  </annotation>
 </semantics>
</math>

 of the matrix 

<math display="inline" id="Eigenvalue_algorithm:68">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

. This value 

<math display="inline" id="Eigenvalue_algorithm:69">
 <semantics>
  <mrow>
   <mi>κ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>A</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>κ</ci>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   κ(A)
  </annotation>
 </semantics>
</math>

 is also the absolute value of the ratio of the largest eigenvalue of 

<math display="inline" id="Eigenvalue_algorithm:70">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 to its smallest. If 

<math display="inline" id="Eigenvalue_algorithm:71">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 is <a href="Unitary_matrix" title="wikilink">unitary</a>, then <mtpl><em>A</em>{{!!}}<sub>op</sub> = {{!!}}<em>A</em><sup>−1</sup>{{!!}}<sub>op</sub> = 1}}</mtpl>, so 

<math display="inline" id="Eigenvalue_algorithm:72">
 <semantics>
  <mrow>
   <mrow>
    <mi>κ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>A</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>κ</ci>
     <ci>A</ci>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   κ(A)=1
  </annotation>
 </semantics>
</math>

. For general matrices, the operator norm is often difficult to calculate. For this reason, other <a href="matrix_norms" title="wikilink">matrix norms</a> are commonly used to estimate the condition number.</p>

<p>For the eigenvalue problem, <a href="Bauer-Fike_theorem" title="wikilink">Bauer and Fike proved</a> that if 

<math display="inline" id="Eigenvalue_algorithm:73">
 <semantics>
  <mi>λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   λ
  </annotation>
 </semantics>
</math>

 is an eigenvalue for a <a href="Diagonalizable_matrix" title="wikilink">diagonalizable</a> 

<math display="inline" id="Eigenvalue_algorithm:74">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mi mathvariant="normal">×</mi>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>n</ci>
    <ci>normal-×</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n×n
  </annotation>
 </semantics>
</math>

 matrix 

<math display="inline" id="Eigenvalue_algorithm:75">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 with eigenvector matrix 

<math display="inline" id="Eigenvalue_algorithm:76">
 <semantics>
  <mi>V</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>V</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V
  </annotation>
 </semantics>
</math>

, then the absolute error in calculating 

<math display="inline" id="Eigenvalue_algorithm:77">
 <semantics>
  <mi>λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   λ
  </annotation>
 </semantics>
</math>

 is bounded by the product of 

<math display="inline" id="Eigenvalue_algorithm:78">
 <semantics>
  <mrow>
   <mi>κ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>V</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>κ</ci>
    <ci>V</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   κ(V)
  </annotation>
 </semantics>
</math>

 and the absolute error in 

<math display="inline" id="Eigenvalue_algorithm:79">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> <a href="Bauer-Fike_theorem#Corollary" title="wikilink">As a result</a>, the condition number for finding 

<math display="inline" id="Eigenvalue_algorithm:80">
 <semantics>
  <mi>λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   λ
  </annotation>
 </semantics>
</math>

 is <mtpl><em>V</em> {{!!}}<sub>op</sub> {{!!}}<em>V</em> <sup>−1</sup>{{!!}}<sub>op</sub>}}</mtpl>. If 

<math display="inline" id="Eigenvalue_algorithm:81">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 is normal, then 

<math display="inline" id="Eigenvalue_algorithm:82">
 <semantics>
  <mi>V</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>V</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V
  </annotation>
 </semantics>
</math>

 is unitary, and 

<math display="inline" id="Eigenvalue_algorithm:83">
 <semantics>
  <mrow>
   <mrow>
    <mi>κ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mo>,</mo>
     <mi>A</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>κ</ci>
     <interval closure="open">
      <ci>λ</ci>
      <ci>A</ci>
     </interval>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   κ(λ,A)=1
  </annotation>
 </semantics>
</math>

. Thus the eigenvalue problem for all normal matrices is well-conditioned.</p>

<p>The condition number for the problem of finding the eigenspace of a normal matrix 

<math display="inline" id="Eigenvalue_algorithm:84">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 corresponding to an eigenvalue 

<math display="inline" id="Eigenvalue_algorithm:85">
 <semantics>
  <mi>λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   λ
  </annotation>
 </semantics>
</math>

 has been shown to be inversely proportional to the minimum distance between 

<math display="inline" id="Eigenvalue_algorithm:86">
 <semantics>
  <mi>λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   λ
  </annotation>
 </semantics>
</math>

 and the other distinct eigenvalues of 

<math display="inline" id="Eigenvalue_algorithm:87">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> In particular, the eigenspace problem for normal matrices is well-conditioned for isolated eigenvalues. When eigenvalues are not isolated, the best that can be hoped for is to identify the span of all eigenvectors of nearby eigenvalues.</p>
<h2 id="algorithms">Algorithms</h2>

<p>Any monic polynomial is the characteristic polynomial of its <a href="companion_matrix" title="wikilink">companion matrix</a>. Therefore a general algorithm for finding eigenvalues could also be used to find the roots of polynomials. The <a href="Abel-Ruffini_theorem" title="wikilink">Abel-Ruffini theorem</a> shows that any such algorithm for dimensions greater than 4 must either be infinite, or involve functions of greater complexity than elementary arithmetic operations and fractional powers. For this reason algorithms that exactly calculate eigenvalues in a finite number of steps only exist for a few special classes of matrices. For general matrices, algorithms are <a href="Iterative_method" title="wikilink">iterative</a>, producing better approximate solutions with each iteration.</p>

<p>Some algorithms produce every eigenvalue, others will produce a few, or only one. However, even the latter algorithms can be used to find all eigenvalues. Once an eigenvalue 

<math display="inline" id="Eigenvalue_algorithm:88">
 <semantics>
  <mi>λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   λ
  </annotation>
 </semantics>
</math>

 of a matrix 

<math display="inline" id="Eigenvalue_algorithm:89">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 has been identified, it can be used to either direct the algorithm towards a different solution next time, or to reduce the problem to one that no longer has 

<math display="inline" id="Eigenvalue_algorithm:90">
 <semantics>
  <mi>λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   λ
  </annotation>
 </semantics>
</math>

 as a solution.</p>

<p>Redirection is usually accomplished by shifting: replacing 

<math display="inline" id="Eigenvalue_algorithm:91">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 with 

<math display="inline" id="Eigenvalue_algorithm:92">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>-</mo>
   <mrow>
    <mi>μ</mi>
    <mi>I</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>A</ci>
    <apply>
     <times></times>
     <ci>μ</ci>
     <ci>I</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A-μI
  </annotation>
 </semantics>
</math>

 for some constant 

<math display="inline" id="Eigenvalue_algorithm:93">
 <semantics>
  <mi>μ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>μ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   μ
  </annotation>
 </semantics>
</math>

. The eigenvalue found for 

<math display="inline" id="Eigenvalue_algorithm:94">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>-</mo>
   <mrow>
    <mi>μ</mi>
    <mi>I</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>A</ci>
    <apply>
     <times></times>
     <ci>μ</ci>
     <ci>I</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A-μI
  </annotation>
 </semantics>
</math>

 must have 

<math display="inline" id="Eigenvalue_algorithm:95">
 <semantics>
  <mi>μ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>μ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   μ
  </annotation>
 </semantics>
</math>

 added back in to get an eigenvalue for 

<math display="inline" id="Eigenvalue_algorithm:96">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

. For example, for <a href="power_iteration" title="wikilink">power iteration</a>, 

<math display="inline" id="Eigenvalue_algorithm:97">
 <semantics>
  <mrow>
   <mi>μ</mi>
   <mo>=</mo>
   <mi>λ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>μ</ci>
    <ci>λ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   μ=λ
  </annotation>
 </semantics>
</math>

. Power iteration finds the largest eigenvalue in absolute value, so even when 

<math display="inline" id="Eigenvalue_algorithm:98">
 <semantics>
  <mi>λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   λ
  </annotation>
 </semantics>
</math>

 is only an approximate eigenvalue, power iteration is unlikely to find it a second time. Conversely, <a href="inverse_iteration" title="wikilink">inverse iteration</a> based methods find the lowest eigenvalue, so 

<math display="inline" id="Eigenvalue_algorithm:99">
 <semantics>
  <mi>μ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>μ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   μ
  </annotation>
 </semantics>
</math>

 is chosen well away from 

<math display="inline" id="Eigenvalue_algorithm:100">
 <semantics>
  <mi>λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   λ
  </annotation>
 </semantics>
</math>

 and hopefully closer to some other eigenvalue.</p>

<p>Reduction can be accomplished by restricting 

<math display="inline" id="Eigenvalue_algorithm:101">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 to the column space of the matrix 

<math display="inline" id="Eigenvalue_algorithm:102">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>-</mo>
   <mrow>
    <mi>λ</mi>
    <mi>I</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>A</ci>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>I</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A-λI
  </annotation>
 </semantics>
</math>

, which 

<math display="inline" id="Eigenvalue_algorithm:103">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 carries to itself. Since 

<math display="inline" id="Eigenvalue_algorithm:104">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>-</mo>
   <mrow>
    <mi>λ</mi>
    <mi>I</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>A</ci>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>I</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A-λI
  </annotation>
 </semantics>
</math>

 is singular, the column space is of lesser dimension. The eigenvalue algorithm can then be applied to the restricted matrix. This process can be repeated until all eigenvalues are found.</p>

<p>If an eigenvalue algorithm does not produce eigenvectors, a common practice is to use an inverse iteration based algorithm with 

<math display="inline" id="Eigenvalue_algorithm:105">
 <semantics>
  <mi>μ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>μ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   μ
  </annotation>
 </semantics>
</math>

 set to a close approximation to the eigenvalue. This will quickly converge to the eigenvector of the closest eigenvalue to 

<math display="inline" id="Eigenvalue_algorithm:106">
 <semantics>
  <mi>μ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>μ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   μ
  </annotation>
 </semantics>
</math>

. For small matrices, an alternative is to look at the column space of the product of 

<math display="inline" id="Eigenvalue_algorithm:107">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>-</mo>
   <mrow>
    <mi>λ</mi>
    <mi>I</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>A</ci>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>I</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A-λI
  </annotation>
 </semantics>
</math>

 for each of the other eigenvalues 

<math display="inline" id="Eigenvalue_algorithm:108">
 <semantics>
  <mrow>
   <mi>λ</mi>
   <mo>.</mo>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">λ</csymbol>
    <ci>normal-.</ci>
    <ci>normal-.</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   λ{{.}}.
  </annotation>
 </semantics>
</math>

</p>
<h2 id="hessenberg-and-tri-diagonal-matrices">Hessenberg and Tri-diagonal matrices</h2>

<p>Because the eigenvalues of a triangular matrix are its diagonal elements, for general matrices there is no finite method like <a href="gaussian_elimination" title="wikilink">gaussian elimination</a> to convert a matrix to triangular form while preserving eigenvalues. But it is possible to reach something close to triangular. An <a href="Hessenberg_matrix" title="wikilink">upper Hessenberg matrix</a> is a square matrix for which all entries below the <a class="uri" href="subdiagonal" title="wikilink">subdiagonal</a> are zero. A lower Hessenberg matrix is one for which all entries above the <a class="uri" href="superdiagonal" title="wikilink">superdiagonal</a> are zero. Matrices that are both upper and lower Hessenberg are <a href="Tridiagonal_matrix" title="wikilink">tridiagonal</a>. Hessenberg and tridiagonal matrices are the starting points for many eigenvalue algorithms because the zero entries reduce the complexity of the problem. Several methods are commonly used to convert a general matrix into a Hessenberg matrix with the same eigenvalues. If the original matrix was symmetric or hermitian, then the resulting matrix will be tridiagonal.</p>

<p>When only eigenvalues are needed, there is no need to calculate the similarity matrix, as the transformed matrix has the same eigenvalues. If eigenvectors are needed as well, the similarity matrix may be needed to transform the eigenvectors of the Hessenberg matrix back into eigenvectors of the original matrix.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>Method</p></th>
<th style="text-align: left;">
<p>Applies to</p></th>
<th style="text-align: left;">
<p>Produces</p></th>
<th style="text-align: left;">
<p>Cost without similarity matrix</p></th>
<th style="text-align: left;">
<p>Cost with similarity matrix</p></th>
<th style="text-align: left;">
<p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p><a href="Householder_transformation" title="wikilink">Householder transformations</a></p></td>
<td style="text-align: left;">
<p>General</p></td>
<td style="text-align: left;">
<p>Hessenberg</p></td>
<td style="text-align: left;">
<p><mtpl></mtpl><ref name="NumericalRecipes">{{cite book</ref></p></td>
<td style="text-align: left;">
<p>last1 = Press</p></td>
<td style="text-align: left;">
<p>first1 = William H.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><a href="Givens_rotation" title="wikilink">Givens rotations</a></p></td>
<td style="text-align: left;">
<p>General</p></td>
<td style="text-align: left;">
<p>Hessenberg</p></td>
<td style="text-align: left;">
<p><mtpl></mtpl><a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>Apply planar rotations to zero out individual entries. Rotations are ordered so that later ones do not cause zero entries to become non-zero again.</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><a href="Arnoldi_iteration" title="wikilink">Arnoldi iteration</a></p></td>
<td style="text-align: left;">
<p>General</p></td>
<td style="text-align: left;">
<p>Hessenberg</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>Perform Gram–Schmidt orthogonalization on Krylov subspaces.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><a href="Lanczos_algorithm" title="wikilink">Lanczos algorithm</a></p></td>
<td style="text-align: left;">
<p>Hermitian</p></td>
<td style="text-align: left;">
<p>Tridiagonal</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>Arnoldi iteration for hermitian matrices, with shortcuts.</p></td>
</tr>
</tbody>
</table>
<h2 id="iterative-algorithms">Iterative algorithms</h2>

<p>Iterative algorithms solve the eigenvalue problem by producing sequences that converge to the eigenvalues. Some algorithms also produce sequences of vectors that converge to the eigenvectors. Most commonly, the eigenvalue sequences are expressed as sequences of similar matrices which converge to a triangular or diagonal form, allowing the eigenvalues to be read easily. The eigenvector sequences are expressed as the corresponding similarity matrices.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>Method</p></th>
<th style="text-align: left;">
<p>Applies to</p></th>
<th style="text-align: left;">
<p>Produces</p></th>
<th style="text-align: left;">
<p>Cost per step</p></th>
<th style="text-align: left;">
<p>Convergence</p></th>
<th style="text-align: left;">
<p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p><a href="Power_iteration" title="wikilink">Power iteration</a></p></td>
<td style="text-align: left;">
<p>General</p></td>
<td style="text-align: left;">
<p>eigenpair with largest value</p></td>
<td style="text-align: left;">
<p><mtpl></mtpl></p></td>
<td style="text-align: left;">
<p>Linear</p></td>
<td style="text-align: left;">
<p>Repeatedly applies the matrix to an arbitrary starting vector and renormalizes.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><a href="Inverse_iteration" title="wikilink">Inverse iteration</a></p></td>
<td style="text-align: left;">
<p>General</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>Linear</p></td>
<td style="text-align: left;">
<p>Power iteration for <mtpl></mtpl></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><a href="Rayleigh_quotient_iteration" title="wikilink">Rayleigh quotient iteration</a></p></td>
<td style="text-align: left;">
<p>Hermitian</p></td>
<td style="text-align: left;">
<p>eigenpair with value closest to μ</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>Cubic</p></td>
<td style="text-align: left;">
<p>Power iteration for <mtpl></mtpl> where <mtpl></mtpl> for each iteration is the Rayleigh quotient of the previous iteration.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><a href="Preconditioned_Inverse_iteration" title="wikilink">Preconditioned Inverse iteration</a><ref>{{Citation</ref></p></td>
<td style="text-align: left;">
<p>last=Neymeyr</p></td>
<td style="text-align: left;">
<p>first=K.</p></td>
<td style="text-align: left;">
<p>title=A geometric theory for preconditioned inverse iteration IV: On the fastest convergence cases.</p></td>
<td style="text-align: left;">
<p>journal=Linear Algebra Appl.</p></td>
<td style="text-align: left;">
<p>volume=415</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><a href="Bisection_eigenvalue_algorithm" title="wikilink">Bisection method</a></p></td>
<td style="text-align: left;">
<p>Real Symmetric Tridiagonal</p></td>
<td style="text-align: left;">
<p>any eigenvalue</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>linear</p></td>
<td style="text-align: left;">
<p>Uses the <a href="bisection_method" title="wikilink">bisection method</a> to find roots of the characteristic polynomial, supported by the Sturm sequence.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><a href="Laguerre_iteration" title="wikilink">Laguerre iteration</a></p></td>
<td style="text-align: left;">
<p>Real Symmetric Tridiagonal</p></td>
<td style="text-align: left;">
<p>any eigenvalue</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>cubic<ref>{{Citation</ref></p></td>
<td style="text-align: left;">
<p>last1=Li</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><a href="QR_algorithm" title="wikilink">QR algorithm</a></p></td>
<td style="text-align: left;">
<p>Hessenberg</p></td>
<td style="text-align: left;">
<p>all eigenvalues</p></td>
<td style="text-align: left;">
<p><mtpl></mtpl></p></td>
<td style="text-align: left;">
<p>cubic</p></td>
<td style="text-align: left;">
<p>align="left" Factors <em>A</em> = <em>QR</em>, where <em>Q</em> is orthogonal and <em>R</em> is triangular, then applies the next iteration to <em>RQ</em>.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>all eigenpairs</p></td>
<td style="text-align: left;">
<p><mtpl></mtpl></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><a href="Jacobi_eigenvalue_algorithm" title="wikilink">Jacobi eigenvalue algorithm</a></p></td>
<td style="text-align: left;">
<p>Real Symmetric</p></td>
<td style="text-align: left;">
<p>all eigenvalues</p></td>
<td style="text-align: left;">
<p><mtpl></mtpl></p></td>
<td style="text-align: left;">
<p>quadratic</p></td>
<td style="text-align: left;">
<p>Uses Givens rotations to attempt clearing all off-diagonal entries. This fails, but strengthens the diagonal.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><a href="Divide-and-conquer_eigenvalue_algorithm" title="wikilink">Divide-and-conquer</a></p></td>
<td style="text-align: left;">
<p>Hermitian Tridiagonal</p></td>
<td style="text-align: left;">
<p>all eigenvalues</p></td>
<td style="text-align: left;">
<p><mtpl></mtpl></p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>align="left" Divides the matrix into submatrices that are diagonalized then recombined.</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>all eigenpairs</p></td>
<td style="text-align: left;">
<p><mtpl></mtpl></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><a href="Homotopy_method" title="wikilink">Homotopy method</a></p></td>
<td style="text-align: left;">
<p>Real Symmetric Tridiagonal</p></td>
<td style="text-align: left;">
<p>all eigenpairs</p></td>
<td style="text-align: left;">
<p>{{math|<em>O</em>(<em>n</em><sup>2</sup>)<ref>{{Citation</ref></p></td>
<td style="text-align: left;">
<p>last=Chu</p></td>
<td style="text-align: left;">
<p>first=Moody T.</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><a href="Folded_spectrum_method" title="wikilink">Folded spectrum method</a></p></td>
<td style="text-align: left;">
<p>Real Symmetric</p></td>
<td style="text-align: left;">
<p>eigenpair with value closest to μ</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>Preconditioned inverse iteration applied to <mtpl></mtpl></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><a href="MRRR" title="wikilink">MRRR algorithm</a><ref>{{Citation</ref></p></td>
<td style="text-align: left;">
<p>last1=Dhillon</p></td>
<td style="text-align: left;">
<p>first1=Inderjit S.</p></td>
<td style="text-align: left;">
<p>last2=Parlett</p></td>
<td style="text-align: left;">
<p>first2=Beresford N.</p></td>
<td style="text-align: left;">
<p>last3=Vömel</p></td>
</tr>
</tbody>
</table>
<h2 id="direct-calculation">Direct calculation</h2>

<p>While there is no simple algorithm to directly calculate eigenvalues for general matrices, there are numerous special classes of matrices where eigenvalues can be directly calculated. These include:</p>
<h3 id="triangular-matrices">Triangular matrices</h3>

<p>Since the determinant of a <a href="triangular_matrix" title="wikilink">triangular matrix</a> is the product of its diagonal entries, if <em>T</em> is triangular, then  Thus the eigenvalues of <em>T</em> are its diagonal entries.</p>
<h3 id="factorable-polynomial-equations">Factorable polynomial equations</h3>

<p>If 

<math display="inline" id="Eigenvalue_algorithm:109">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 is any polynomial and 

<math display="inline" id="Eigenvalue_algorithm:110">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>p</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>A</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mn>0</mn>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>p</ci>
     <ci>A</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(A)=0,
  </annotation>
 </semantics>
</math>

 then the eigenvalues of 

<math display="inline" id="Eigenvalue_algorithm:111">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 also satisfy the same equation. If 

<math display="inline" id="Eigenvalue_algorithm:112">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 happens to have a known factorization, then the eigenvalues of 

<math display="inline" id="Eigenvalue_algorithm:113">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 lie among its roots.</p>

<p>For example, a <a href="Projection_(linear_algebra)" title="wikilink">projection</a> is a square matrix 

<math display="inline" id="Eigenvalue_algorithm:114">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 satisfying <mtpl></mtpl>. The roots of the corresponding scalar polynomial equation, <mtpl></mtpl>, are 0 and 1. Thus any projection has 0 and 1 for its eigenvalues. The multiplicity of 0 as an eigenvalue is the <a class="uri" href="nullity" title="wikilink">nullity</a> of 

<math display="inline" id="Eigenvalue_algorithm:115">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

, while the multiplicity of 1 is the rank of 

<math display="inline" id="Eigenvalue_algorithm:116">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

.</p>

<p>Another example is a matrix 

<math display="inline" id="Eigenvalue_algorithm:117">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 that satisfies <mtpl></mtpl> for some scalar 

<math display="inline" id="Eigenvalue_algorithm:118">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   α
  </annotation>
 </semantics>
</math>

. The eigenvalues must be 

<math display="inline" id="Eigenvalue_algorithm:119">
 <semantics>
  <mrow>
   <mi mathvariant="normal">±</mi>
   <mi>α</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-±</ci>
    <ci>α</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ±α
  </annotation>
 </semantics>
</math>

. The projection operators</p>

<p>

<math display="block" id="Eigenvalue_algorithm:120">
 <semantics>
  <mrow>
   <msub>
    <mi>P</mi>
    <mo>+</mo>
   </msub>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mn>2</mn>
    </mfrac>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mi>I</mi>
      <mo>+</mo>
      <mfrac>
       <mi>A</mi>
       <mi>α</mi>
      </mfrac>
     </mrow>
     <mo>)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>P</ci>
     <plus></plus>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <plus></plus>
      <ci>I</ci>
      <apply>
       <divide></divide>
       <ci>A</ci>
       <ci>α</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{+}=\frac{1}{2}\left(I+\frac{A}{\alpha}\right)
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Eigenvalue_algorithm:121">
 <semantics>
  <mrow>
   <msub>
    <mi>P</mi>
    <mo>-</mo>
   </msub>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mn>2</mn>
    </mfrac>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mi>I</mi>
      <mo>-</mo>
      <mfrac>
       <mi>A</mi>
       <mi>α</mi>
      </mfrac>
     </mrow>
     <mo>)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>P</ci>
     <minus></minus>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <minus></minus>
      <ci>I</ci>
      <apply>
       <divide></divide>
       <ci>A</ci>
       <ci>α</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{-}=\frac{1}{2}\left(I-\frac{A}{\alpha}\right)
  </annotation>
 </semantics>
</math>

 satisfy</p>

<p>

<math display="block" id="Eigenvalue_algorithm:122">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>A</mi>
     <msub>
      <mi>P</mi>
      <mo>+</mo>
     </msub>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>α</mi>
     <msub>
      <mi>P</mi>
      <mo>+</mo>
     </msub>
    </mrow>
   </mrow>
   <mrow>
    <mrow>
     <mi>A</mi>
     <msub>
      <mi>P</mi>
      <mo>-</mo>
     </msub>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo>-</mo>
     <mrow>
      <mi>α</mi>
      <msub>
       <mi>P</mi>
       <mo>-</mo>
      </msub>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>A</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>P</ci>
       <plus></plus>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>α</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>P</ci>
       <plus></plus>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>A</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>P</ci>
       <minus></minus>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>α</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>P</ci>
        <minus></minus>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   AP_{+}=\alpha P_{+}\quad AP_{-}=-\alpha P_{-}
  </annotation>
 </semantics>
</math>

 and</p>

<p>

<math display="block" id="Eigenvalue_algorithm:123">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>P</mi>
      <mo>+</mo>
     </msub>
     <msub>
      <mi>P</mi>
      <mo>+</mo>
     </msub>
    </mrow>
    <mo>=</mo>
    <msub>
     <mi>P</mi>
     <mo>+</mo>
    </msub>
   </mrow>
   <mrow>
    <mrow>
     <mrow>
      <msub>
       <mi>P</mi>
       <mo>-</mo>
      </msub>
      <msub>
       <mi>P</mi>
       <mo>-</mo>
      </msub>
     </mrow>
     <mo>=</mo>
     <msub>
      <mi>P</mi>
      <mo>-</mo>
     </msub>
    </mrow>
    <mrow>
     <mrow>
      <msub>
       <mi>P</mi>
       <mo>+</mo>
      </msub>
      <msub>
       <mi>P</mi>
       <mo>-</mo>
      </msub>
     </mrow>
     <mo>=</mo>
     <mrow>
      <msub>
       <mi>P</mi>
       <mo>-</mo>
      </msub>
      <msub>
       <mi>P</mi>
       <mo>+</mo>
      </msub>
     </mrow>
     <mo>=</mo>
     <mn>0.</mn>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>P</ci>
       <plus></plus>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>P</ci>
       <plus></plus>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>P</ci>
      <plus></plus>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">formulae-sequence</csymbol>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>P</ci>
        <minus></minus>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>P</ci>
        <minus></minus>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>P</ci>
       <minus></minus>
      </apply>
     </apply>
     <apply>
      <and></and>
      <apply>
       <eq></eq>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>P</ci>
         <plus></plus>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>P</ci>
         <minus></minus>
        </apply>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>P</ci>
         <minus></minus>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>P</ci>
         <plus></plus>
        </apply>
       </apply>
      </apply>
      <apply>
       <eq></eq>
       <share href="#.cmml">
       </share>
       <cn type="float">0.</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{+}P_{+}=P_{+}\quad P_{-}P_{-}=P_{-}\quad P_{+}P_{-}=P_{-}P_{+}=0.
  </annotation>
 </semantics>
</math>

</p>

<p>The <a href="column_space" title="wikilink">column spaces</a> of <mtpl></mtpl> and <mtpl></mtpl> are the eigenspaces of 

<math display="inline" id="Eigenvalue_algorithm:124">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 corresponding to 

<math display="inline" id="Eigenvalue_algorithm:125">
 <semantics>
  <mrow>
   <mo>+</mo>
   <mi>α</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>α</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   +α
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Eigenvalue_algorithm:126">
 <semantics>
  <mrow>
   <mo>-</mo>
   <mi>α</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>α</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   -α
  </annotation>
 </semantics>
</math>

, respectively.</p>
<h3 id="matrices">2×2 matrices</h3>

<p>For dimensions 2 through 4, formulas involving radicals exist that can be used to find the eigenvalues. While a common practice for 2×2 and 3×3 matrices, for 4×4 matrices the increasing complexity of the <a href="Quartic_function#Ferrari's_solution" title="wikilink">root formulas</a> makes this approach less attractive.</p>

<p>For the 2×2 matrix</p>

<p>

<math display="block" id="Eigenvalue_algorithm:127">
 <semantics>
  <mrow>
   <mrow>
    <mi>A</mi>
    <mo>=</mo>
    <mrow>
     <mo>[</mo>
     <mtable displaystyle="true">
      <mtr>
       <mtd columnalign="center">
        <mi>a</mi>
       </mtd>
       <mtd columnalign="center">
        <mi>b</mi>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mi>c</mi>
       </mtd>
       <mtd columnalign="center">
        <mi>d</mi>
       </mtd>
      </mtr>
     </mtable>
     <mo>]</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>A</ci>
    <matrix>
     <matrixrow>
      <ci>a</ci>
      <ci>b</ci>
     </matrixrow>
     <matrixrow>
      <ci>c</ci>
      <ci>d</ci>
     </matrixrow>
    </matrix>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A=\begin{bmatrix}a&b\\
c&d\end{bmatrix},
  </annotation>
 </semantics>
</math>

</p>

<p>the characteristic polynomial is</p>

<p>

<math display="block" id="Eigenvalue_algorithm:128">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>det</mi>
     <mrow>
      <mo>[</mo>
      <mtable displaystyle="true">
       <mtr>
        <mtd columnalign="center">
         <mrow>
          <mi>λ</mi>
          <mo>-</mo>
          <mi>a</mi>
         </mrow>
        </mtd>
        <mtd columnalign="center">
         <mrow>
          <mo>-</mo>
          <mi>b</mi>
         </mrow>
        </mtd>
       </mtr>
       <mtr>
        <mtd columnalign="center">
         <mrow>
          <mo>-</mo>
          <mi>c</mi>
         </mrow>
        </mtd>
        <mtd columnalign="center">
         <mrow>
          <mi>λ</mi>
          <mo>-</mo>
          <mi>d</mi>
         </mrow>
        </mtd>
       </mtr>
      </mtable>
      <mo>]</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mpadded width="+1.7pt">
       <msup>
        <mi>λ</mi>
        <mn>2</mn>
       </msup>
      </mpadded>
      <mo rspace="4.2pt">-</mo>
      <mrow>
       <mrow>
        <mo>(</mo>
        <mrow>
         <mi>a</mi>
         <mo>+</mo>
         <mi>d</mi>
        </mrow>
        <mo>)</mo>
       </mrow>
       <mpadded width="+1.7pt">
        <mi>λ</mi>
       </mpadded>
      </mrow>
     </mrow>
     <mo rspace="4.2pt">+</mo>
     <mrow>
      <mo>(</mo>
      <mrow>
       <mrow>
        <mi>a</mi>
        <mi>d</mi>
       </mrow>
       <mo>-</mo>
       <mrow>
        <mi>b</mi>
        <mi>c</mi>
       </mrow>
      </mrow>
      <mo>)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mpadded width="+1.7pt">
       <msup>
        <mi>λ</mi>
        <mn>2</mn>
       </msup>
      </mpadded>
      <mo rspace="4.2pt">-</mo>
      <mrow>
       <mpadded width="+1.7pt">
        <mi>λ</mi>
       </mpadded>
       <mi>tr</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>A</mi>
        <mo rspace="4.2pt" stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo rspace="4.2pt">+</mo>
     <mrow>
      <mi>det</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>A</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>det</ci>
      <matrix>
       <matrixrow>
        <apply>
         <minus></minus>
         <ci>λ</ci>
         <ci>a</ci>
        </apply>
        <apply>
         <minus></minus>
         <ci>b</ci>
        </apply>
       </matrixrow>
       <matrixrow>
        <apply>
         <minus></minus>
         <ci>c</ci>
        </apply>
        <apply>
         <minus></minus>
         <ci>λ</ci>
         <ci>d</ci>
        </apply>
       </matrixrow>
      </matrix>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>λ</ci>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <times></times>
        <apply>
         <plus></plus>
         <ci>a</ci>
         <ci>d</ci>
        </apply>
        <ci>λ</ci>
       </apply>
      </apply>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <ci>a</ci>
        <ci>d</ci>
       </apply>
       <apply>
        <times></times>
        <ci>b</ci>
        <ci>c</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <plus></plus>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>λ</ci>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <times></times>
        <ci>λ</ci>
        <ci>tr</ci>
        <ci>A</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>det</ci>
       <ci>A</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\rm det}\begin{bmatrix}\lambda-a&-b\\
-c&\lambda-d\end{bmatrix}=\lambda^{2}\,-\,\left(a+d\right)\lambda\,+\,\left(ad%
-bc\right)=\lambda^{2}\,-\,\lambda\,{\rm tr}(A)\,+\,{\rm det}(A).
  </annotation>
 </semantics>
</math>

</p>

<p>Thus the eigenvalues can be found by using the <a href="quadratic_formula" title="wikilink">quadratic formula</a>:</p>

<p>

<math display="block" id="Eigenvalue_algorithm:129">
 <semantics>
  <mrow>
   <mrow>
    <mi>λ</mi>
    <mo>=</mo>
    <mfrac>
     <mrow>
      <mrow>
       <mi>tr</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>A</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>±</mo>
      <msqrt>
       <mrow>
        <mrow>
         <msup>
          <mi>tr</mi>
          <mn>2</mn>
         </msup>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>A</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>-</mo>
        <mrow>
         <mn>4</mn>
         <mi mathvariant="normal">d</mi>
         <mi mathvariant="normal">e</mi>
         <mi mathvariant="normal">t</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>A</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
      </msqrt>
     </mrow>
     <mn>2</mn>
    </mfrac>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>λ</ci>
    <apply>
     <divide></divide>
     <apply>
      <csymbol cd="latexml">plus-or-minus</csymbol>
      <apply>
       <times></times>
       <ci>tr</ci>
       <ci>A</ci>
      </apply>
      <apply>
       <root></root>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>tr</ci>
          <cn type="integer">2</cn>
         </apply>
         <ci>A</ci>
        </apply>
        <apply>
         <times></times>
         <cn type="integer">4</cn>
         <ci>normal-d</ci>
         <ci>normal-e</ci>
         <ci>normal-t</ci>
         <ci>A</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda=\frac{{\rm tr}(A)\pm\sqrt{{\rm tr}^{2}(A)-4{\rm det}(A)}}{2}.
  </annotation>
 </semantics>
</math>

</p>

<p>Defining 

<math display="inline" id="Eigenvalue_algorithm:130">
 <semantics>
  <mrow>
   <mrow>
    <mi>gap</mi>
    <mrow>
     <mo>(</mo>
     <mi>A</mi>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msqrt>
    <mrow>
     <mrow>
      <msup>
       <mi>tr</mi>
       <mn>2</mn>
      </msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>A</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>-</mo>
     <mrow>
      <mn>4</mn>
      <mi mathvariant="normal">d</mi>
      <mi mathvariant="normal">e</mi>
      <mi mathvariant="normal">t</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>A</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </msqrt>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>gap</ci>
     <ci>A</ci>
    </apply>
    <apply>
     <root></root>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>tr</ci>
        <cn type="integer">2</cn>
       </apply>
       <ci>A</ci>
      </apply>
      <apply>
       <times></times>
       <cn type="integer">4</cn>
       <ci>normal-d</ci>
       <ci>normal-e</ci>
       <ci>normal-t</ci>
       <ci>A</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle{\rm gap}\left(A\right)=\sqrt{{\rm tr}^{2}(A)-4{\rm det}(A)}
  </annotation>
 </semantics>
</math>

 to be the distance between the two eigenvalues, it is straightforward to calculate</p>

<p>

<math display="block" id="Eigenvalue_algorithm:131">
 <semantics>
  <mrow>
   <mrow>
    <mfrac>
     <mtext>
      P
                            a
                            r
                            t
                             
                            I
                          
                          λ
                        
                        
                          
                            I
                          
                          λ
     </mtext>
     <mtext>
      P
                            a
                            r
                            t
                             
                            I
                            I
                          
                          a
                        
                        
                          
                            I
                            I
                          
                          a
     </mtext>
    </mfrac>
    <mo>=</mo>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <mn>2</mn>
     </mfrac>
     <mrow>
      <mo>(</mo>
      <mrow>
       <mn>1</mn>
       <mo>±</mo>
       <mfrac>
        <mrow>
         <mi>a</mi>
         <mo>-</mo>
         <mi>d</mi>
        </mrow>
        <mrow>
         <mi>gap</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>A</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mfrac>
      </mrow>
      <mo>)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo rspace="22.5pt">,</mo>
   <mrow>
    <mfrac>
     <mtext>
      P
                            a
                            r
                            t
                             
                            I
                            I
                            I
                          
                          λ
                        
                        
                          
                            I
                            I
                            I
                          
                          λ
     </mtext>
     <mtext>
      P
                            a
                            r
                            t
                             
                            I
                            V
                          
                          b
                        
                        
                          
                            I
                            V
                          
                          b
     </mtext>
    </mfrac>
    <mo>=</mo>
    <mfrac>
     <mrow>
      <mo>±</mo>
      <mi>c</mi>
     </mrow>
     <mrow>
      <mi>gap</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>A</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mfrac>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <divide></divide>
      <mtext>
       P
                            a
                            r
                            t
                             
                            I
                          
                          λ
                        
                        
                          
                            I
                          
                          λ
      </mtext>
      <mtext>
       P
                            a
                            r
                            t
                             
                            I
                            I
                          
                          a
                        
                        
                          
                            I
                            I
                          
                          a
      </mtext>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="latexml">plus-or-minus</csymbol>
       <cn type="integer">1</cn>
       <apply>
        <divide></divide>
        <apply>
         <minus></minus>
         <ci>a</ci>
         <ci>d</ci>
        </apply>
        <apply>
         <times></times>
         <ci>gap</ci>
         <ci>A</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <divide></divide>
      <mtext>
       P
                            a
                            r
                            t
                             
                            I
                            I
                            I
                          
                          λ
                        
                        
                          
                            I
                            I
                            I
                          
                          λ
      </mtext>
      <mtext>
       P
                            a
                            r
                            t
                             
                            I
                            V
                          
                          b
                        
                        
                          
                            I
                            V
                          
                          b
      </mtext>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <csymbol cd="latexml">plus-or-minus</csymbol>
       <ci>c</ci>
      </apply>
      <apply>
       <times></times>
       <ci>gap</ci>
       <ci>A</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{\@@section{part}{Pt1}{I}{Part~I}{{\@tag[][]{I}\lambda}}{{\@tag[][]{Part~%
I}\lambda}}}{\@@section{part}{Pt2}{II}{Part~II}{{\@tag[][]{II}a}}{{\@tag[][]{%
Part~II}a}}}=\frac{1}{2}\left(1\pm\frac{a-d}{{\rm gap}(A)}\right),\qquad\frac{%
\@@section{part}{Pt3}{III}{Part~III}{{\@tag[][]{III}\lambda}}{{\@tag[][]{Part~%
III}\lambda}}}{\@@section{part}{Pt4}{IV}{Part~IV}{{\@tag[][]{IV}b}}{{\@tag[][]%
{Part~IV}b}}}=\frac{\pm c}{{\rm gap}(A)}
  </annotation>
 </semantics>
</math>

</p>

<p>with similar formulas for 

<math display="inline" id="Eigenvalue_algorithm:132">
 <semantics>
  <mi>c</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>c</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Eigenvalue_algorithm:133">
 <semantics>
  <mi>d</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>d</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d
  </annotation>
 </semantics>
</math>

. From this it follows that the calculation is well-conditioned if the eigenvalues are isolated.</p>

<p>Eigenvectors can be found by exploiting the <a href="Cayley-Hamilton_theorem" title="wikilink">Cayley-Hamilton theorem</a>. If <mtpl></mtpl> are the eigenvalues, then <mtpl></mtpl>, so the columns of <mtpl></mtpl> are annihilated by <mtpl></mtpl> and vice versa. Assuming neither matrix is zero, the columns of each must include eigenvectors for the other eigenvalue. (If either matrix is zero, then 

<math display="inline" id="Eigenvalue_algorithm:134">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 is a multiple of the identity and any non-zero vector is an eigenvector.)</p>

<p>For example, suppose</p>

<p>

<math display="block" id="Eigenvalue_algorithm:135">
 <semantics>
  <mrow>
   <mrow>
    <mi>A</mi>
    <mo>=</mo>
    <mrow>
     <mo>[</mo>
     <mtable displaystyle="true">
      <mtr>
       <mtd columnalign="center">
        <mn>4</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>3</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mrow>
         <mo>-</mo>
         <mn>2</mn>
        </mrow>
       </mtd>
       <mtd columnalign="center">
        <mrow>
         <mo>-</mo>
         <mn>3</mn>
        </mrow>
       </mtd>
      </mtr>
     </mtable>
     <mo>]</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>A</ci>
    <matrix>
     <matrixrow>
      <cn type="integer">4</cn>
      <cn type="integer">3</cn>
     </matrixrow>
     <matrixrow>
      <apply>
       <minus></minus>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <minus></minus>
       <cn type="integer">3</cn>
      </apply>
     </matrixrow>
    </matrix>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A=\begin{bmatrix}4&3\\
-2&-3\end{bmatrix},
  </annotation>
 </semantics>
</math>

</p>

<p>then 

<math display="inline" id="Eigenvalue_algorithm:136">
 <semantics>
  <mrow>
   <mrow>
    <mi>t</mi>
    <mi>r</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>A</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mn>4</mn>
    <mo>-</mo>
    <mn>3</mn>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>t</ci>
      <ci>r</ci>
      <ci>A</ci>
     </apply>
     <apply>
      <minus></minus>
      <cn type="integer">4</cn>
      <cn type="integer">3</cn>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   tr(A)=4-3=1
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Eigenvalue_algorithm:137">
 <semantics>
  <mrow>
   <mrow>
    <mi>d</mi>
    <mi>e</mi>
    <mi>t</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>A</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mn>4</mn>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mo>-</mo>
       <mn>3</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mn>3</mn>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mo>-</mo>
       <mn>2</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <mn>6</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>d</ci>
      <ci>e</ci>
      <ci>t</ci>
      <ci>A</ci>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <cn type="integer">4</cn>
       <apply>
        <minus></minus>
        <cn type="integer">3</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <cn type="integer">3</cn>
       <apply>
        <minus></minus>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <minus></minus>
      <cn type="integer">6</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   det(A)=4(-3)-3(-2)=-6
  </annotation>
 </semantics>
</math>

, so the characteristic equation is</p>

<p>

<math display="block" id="Eigenvalue_algorithm:138">
 <semantics>
  <mrow>
   <mrow>
    <mn>0</mn>
    <mo>=</mo>
    <mrow>
     <msup>
      <mi>λ</mi>
      <mn>2</mn>
     </msup>
     <mo>-</mo>
     <mi>λ</mi>
     <mo>-</mo>
     <mn>6</mn>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>λ</mi>
       <mo>-</mo>
       <mn>3</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>λ</mi>
       <mo>+</mo>
       <mn>2</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <cn type="integer">0</cn>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>λ</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>λ</ci>
      <cn type="integer">6</cn>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <minus></minus>
       <ci>λ</ci>
       <cn type="integer">3</cn>
      </apply>
      <apply>
       <plus></plus>
       <ci>λ</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0=\lambda^{2}-\lambda-6=(\lambda-3)(\lambda+2),
  </annotation>
 </semantics>
</math>

</p>

<p>and the eigenvalues are 3 and -2. Now,</p>

<p>

<math display="block" id="Eigenvalue_algorithm:139">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mi>A</mi>
      <mo>-</mo>
      <mrow>
       <mn>3</mn>
       <mi>I</mi>
      </mrow>
     </mrow>
     <mo>=</mo>
     <mrow>
      <mo>[</mo>
      <mtable displaystyle="true">
       <mtr>
        <mtd columnalign="center">
         <mn>1</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>3</mn>
        </mtd>
       </mtr>
       <mtr>
        <mtd columnalign="center">
         <mrow>
          <mo>-</mo>
          <mn>2</mn>
         </mrow>
        </mtd>
        <mtd columnalign="center">
         <mrow>
          <mo>-</mo>
          <mn>6</mn>
         </mrow>
        </mtd>
       </mtr>
      </mtable>
      <mo>]</mo>
     </mrow>
    </mrow>
    <mo rspace="22.5pt">,</mo>
    <mrow>
     <mrow>
      <mi>A</mi>
      <mo>+</mo>
      <mrow>
       <mn>2</mn>
       <mi>I</mi>
      </mrow>
     </mrow>
     <mo>=</mo>
     <mrow>
      <mo>[</mo>
      <mtable displaystyle="true">
       <mtr>
        <mtd columnalign="center">
         <mn>6</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>3</mn>
        </mtd>
       </mtr>
       <mtr>
        <mtd columnalign="center">
         <mrow>
          <mo>-</mo>
          <mn>2</mn>
         </mrow>
        </mtd>
        <mtd columnalign="center">
         <mrow>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
        </mtd>
       </mtr>
      </mtable>
      <mo>]</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <minus></minus>
      <ci>A</ci>
      <apply>
       <times></times>
       <cn type="integer">3</cn>
       <ci>I</ci>
      </apply>
     </apply>
     <matrix>
      <matrixrow>
       <cn type="integer">1</cn>
       <cn type="integer">3</cn>
      </matrixrow>
      <matrixrow>
       <apply>
        <minus></minus>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <minus></minus>
        <cn type="integer">6</cn>
       </apply>
      </matrixrow>
     </matrix>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <plus></plus>
      <ci>A</ci>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>I</ci>
      </apply>
     </apply>
     <matrix>
      <matrixrow>
       <cn type="integer">6</cn>
       <cn type="integer">3</cn>
      </matrixrow>
      <matrixrow>
       <apply>
        <minus></minus>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </matrixrow>
     </matrix>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A-3I=\begin{bmatrix}1&3\\
-2&-6\end{bmatrix},\qquad A+2I=\begin{bmatrix}6&3\\
-2&-1\end{bmatrix}.
  </annotation>
 </semantics>
</math>

</p>

<p>In both matrices, the columns are multiples of each other, so either column can be used. Thus, 

<math display="inline" id="Eigenvalue_algorithm:140">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mn>1</mn>
   <mo>,</mo>
   <mrow>
    <mo>-</mo>
    <mn>2</mn>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <cn type="integer">1</cn>
    <apply>
     <minus></minus>
     <cn type="integer">2</cn>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (1,-2)
  </annotation>
 </semantics>
</math>

 can be taken as an eigenvector associated with the eigenvalue -2, and 

<math display="inline" id="Eigenvalue_algorithm:141">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mn>3</mn>
   <mo>,</mo>
   <mrow>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <cn type="integer">3</cn>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (3,-1)
  </annotation>
 </semantics>
</math>

 as an eigenvector associated with the eigenvalue 3, as can be verified by multiplying them by 

<math display="inline" id="Eigenvalue_algorithm:142">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

.</p>
<h3 id="matrices-1">3×3 matrices</h3>

<p>If 

<math display="inline" id="Eigenvalue_algorithm:143">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 is a 3×3 matrix, then its characteristic equation can be expressed as:</p>

<p>

<math display="block" id="Eigenvalue_algorithm:144">
 <semantics>
  <mrow>
   <mrow>
    <mi>det</mi>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mrow>
       <mi>α</mi>
       <mi>I</mi>
      </mrow>
      <mo>-</mo>
      <mi>A</mi>
     </mrow>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>α</mi>
     <mn>3</mn>
    </msup>
    <mo>-</mo>
    <mrow>
     <msup>
      <mi>α</mi>
      <mn>2</mn>
     </msup>
     <mi>tr</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>A</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mi>α</mi>
     <mfrac>
      <mn>1</mn>
      <mn>2</mn>
     </mfrac>
     <mrow>
      <mo>(</mo>
      <mrow>
       <mrow>
        <mi>tr</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <msup>
          <mi>A</mi>
          <mn>2</mn>
         </msup>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>-</mo>
       <mrow>
        <msup>
         <mi>tr</mi>
         <mn>2</mn>
        </msup>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>A</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
      <mo>)</mo>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mi>det</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>A</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0.</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>det</ci>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <ci>α</ci>
        <ci>I</ci>
       </apply>
       <ci>A</ci>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>α</ci>
       <cn type="integer">3</cn>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>α</ci>
        <cn type="integer">2</cn>
       </apply>
       <ci>tr</ci>
       <ci>A</ci>
      </apply>
      <apply>
       <times></times>
       <ci>α</ci>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <ci>tr</ci>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>A</ci>
          <cn type="integer">2</cn>
         </apply>
        </apply>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>tr</ci>
          <cn type="integer">2</cn>
         </apply>
         <ci>A</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>det</ci>
       <ci>A</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="float">0.</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\rm det}\left(\alpha I-A\right)=\alpha^{3}-\alpha^{2}{\rm tr}(A)-\alpha\frac{%
1}{2}\left({\rm tr}(A^{2})-{\rm tr}^{2}(A)\right)-{\rm det}(A)=0.
  </annotation>
 </semantics>
</math>

</p>

<p>This equation may be solved using the methods of <a href="Cubic_function#Cardano's_method" title="wikilink">Cardano</a> or <a href="Cubic_function#Lagrange's_method" title="wikilink">Lagrange</a>, but an affine change to 

<math display="inline" id="Eigenvalue_algorithm:145">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 will simplify the expression considerably, and lead directly to a <a href="Cubic_function#Trigonometric_(and_hyperbolic)_method" title="wikilink">trigonometric solution</a>. If 

<math display="inline" id="Eigenvalue_algorithm:146">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>p</mi>
     <mi>B</mi>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>q</mi>
     <mi>I</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>A</ci>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>p</ci>
      <ci>B</ci>
     </apply>
     <apply>
      <times></times>
      <ci>q</ci>
      <ci>I</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A=pB+qI
  </annotation>
 </semantics>
</math>

, then 

<math display="inline" id="Eigenvalue_algorithm:147">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Eigenvalue_algorithm:148">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

 have the same eigenvectors, and 

<math display="inline" id="Eigenvalue_algorithm:149">
 <semantics>
  <mi>β</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>β</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   β
  </annotation>
 </semantics>
</math>

 is an eigenvalue of 

<math display="inline" id="Eigenvalue_algorithm:150">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

 if and only if 

<math display="inline" id="Eigenvalue_algorithm:151">
 <semantics>
  <mrow>
   <mi>α</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>p</mi>
     <mi>β</mi>
    </mrow>
    <mo>+</mo>
    <mi>q</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>α</ci>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>p</ci>
      <ci>β</ci>
     </apply>
     <ci>q</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   α=pβ+q
  </annotation>
 </semantics>
</math>

 is an eigenvalue of 

<math display="inline" id="Eigenvalue_algorithm:152">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

. Letting 

<math display="inline" id="Eigenvalue_algorithm:153">
 <semantics>
  <mrow>
   <mi>q</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>tr</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>A</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>/</mo>
    <mn>3</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>q</ci>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <ci>tr</ci>
      <ci>A</ci>
     </apply>
     <cn type="integer">3</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle q={\rm tr}(A)/3
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Eigenvalue_algorithm:154">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mo>=</mo>
   <mrow>
    <mi>tr</mi>
    <msup>
     <mrow>
      <mo>(</mo>
      <mrow>
       <msup>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mi>A</mi>
          <mo>-</mo>
          <mrow>
           <mi>q</mi>
           <mi>I</mi>
          </mrow>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
        <mn>2</mn>
       </msup>
       <mo>/</mo>
       <mn>6</mn>
      </mrow>
      <mo>)</mo>
     </mrow>
     <mrow>
      <mn>1</mn>
      <mo>/</mo>
      <mn>2</mn>
     </mrow>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>p</ci>
    <apply>
     <times></times>
     <ci>tr</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <divide></divide>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <minus></minus>
         <ci>A</ci>
         <apply>
          <times></times>
          <ci>q</ci>
          <ci>I</ci>
         </apply>
        </apply>
        <cn type="integer">2</cn>
       </apply>
       <cn type="integer">6</cn>
      </apply>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle p={\rm tr}\left((A-qI)^{2}/6\right)^{1/2}
  </annotation>
 </semantics>
</math>

, gives</p>

<p>

<math display="block" id="Eigenvalue_algorithm:155">
 <semantics>
  <mrow>
   <mrow>
    <mi>det</mi>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mrow>
       <mi>β</mi>
       <mi>I</mi>
      </mrow>
      <mo>-</mo>
      <mi>B</mi>
     </mrow>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>β</mi>
     <mn>3</mn>
    </msup>
    <mo>-</mo>
    <mrow>
     <mn>3</mn>
     <mi>β</mi>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mi>det</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>B</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0.</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>det</ci>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <ci>β</ci>
        <ci>I</ci>
       </apply>
       <ci>B</ci>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>β</ci>
       <cn type="integer">3</cn>
      </apply>
      <apply>
       <times></times>
       <cn type="integer">3</cn>
       <ci>β</ci>
      </apply>
      <apply>
       <times></times>
       <ci>det</ci>
       <ci>B</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="float">0.</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\rm det}\left(\beta I-B\right)=\beta^{3}-3\beta-{\rm det}(B)=0.
  </annotation>
 </semantics>
</math>

</p>

<p>The substitution 

<math display="inline" id="Eigenvalue_algorithm:156">
 <semantics>
  <mrow>
   <mi>β</mi>
   <mo>=</mo>
   <mrow>
    <mn>2</mn>
    <mi>c</mi>
    <mi>o</mi>
    <mi>s</mi>
    <mi>θ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>β</ci>
    <apply>
     <times></times>
     <cn type="integer">2</cn>
     <ci>c</ci>
     <ci>o</ci>
     <ci>s</ci>
     <ci>θ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   β=2cosθ
  </annotation>
 </semantics>
</math>

 and some simplification using the identity <mtpl></mtpl> reduces the equation to 

<math display="inline" id="Eigenvalue_algorithm:157">
 <semantics>
  <mrow>
   <mrow>
    <mi>c</mi>
    <mi>o</mi>
    <mi>s</mi>
    <mn>3</mn>
    <mi>θ</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>d</mi>
     <mi>e</mi>
     <mi>t</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>B</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>/</mo>
    <mn>2</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>c</ci>
     <ci>o</ci>
     <ci>s</ci>
     <cn type="integer">3</cn>
     <ci>θ</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <ci>d</ci>
      <ci>e</ci>
      <ci>t</ci>
      <ci>B</ci>
     </apply>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   cos3θ=det(B)/2
  </annotation>
 </semantics>
</math>

. Thus</p>

<p>

<math display="block" id="Eigenvalue_algorithm:158">
 <semantics>
  <mrow>
   <mrow>
    <mi>β</mi>
    <mo>=</mo>
    <mrow>
     <mn>2</mn>
     <mi mathvariant="normal">c</mi>
     <mi mathvariant="normal">o</mi>
     <mi mathvariant="normal">s</mi>
     <mrow>
      <mo>(</mo>
      <mrow>
       <mrow>
        <mfrac>
         <mn>1</mn>
         <mn>3</mn>
        </mfrac>
        <mi>arccos</mi>
        <mrow>
         <mo>(</mo>
         <mrow>
          <mrow>
           <mi>det</mi>
           <mrow>
            <mo stretchy="false">(</mo>
            <mi>B</mi>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
          <mo>/</mo>
          <mn>2</mn>
         </mrow>
         <mo>)</mo>
        </mrow>
       </mrow>
       <mo>+</mo>
       <mfrac>
        <mrow>
         <mn>2</mn>
         <mi>k</mi>
         <mi>π</mi>
        </mrow>
        <mn>3</mn>
       </mfrac>
      </mrow>
      <mo>)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo rspace="12.5pt">,</mo>
   <mrow>
    <mi>k</mi>
    <mo>=</mo>
    <mrow>
     <mn>0</mn>
     <mo>,</mo>
     <mn>1</mn>
     <mo>,</mo>
     <mn>2.</mn>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <ci>β</ci>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <ci>normal-c</ci>
      <ci>normal-o</ci>
      <ci>normal-s</ci>
      <apply>
       <plus></plus>
       <apply>
        <times></times>
        <apply>
         <divide></divide>
         <cn type="integer">1</cn>
         <cn type="integer">3</cn>
        </apply>
        <ci>arccos</ci>
        <apply>
         <divide></divide>
         <apply>
          <times></times>
          <ci>det</ci>
          <ci>B</ci>
         </apply>
         <cn type="integer">2</cn>
        </apply>
       </apply>
       <apply>
        <divide></divide>
        <apply>
         <times></times>
         <cn type="integer">2</cn>
         <ci>k</ci>
         <ci>π</ci>
        </apply>
        <cn type="integer">3</cn>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <ci>k</ci>
     <list>
      <cn type="integer">0</cn>
      <cn type="integer">1</cn>
      <cn type="float">2.</cn>
     </list>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta=2{\rm cos}\left(\frac{1}{3}{\rm arccos}\left({\rm det}(B)/2\right)+\frac%
{2k\pi}{3}\right),\quad k=0,1,2.
  </annotation>
 </semantics>
</math>

</p>

<p>If 

<math display="inline" id="Eigenvalue_algorithm:159">
 <semantics>
  <mrow>
   <mi>d</mi>
   <mi>e</mi>
   <mi>t</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>B</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>d</ci>
    <ci>e</ci>
    <ci>t</ci>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   det(B)
  </annotation>
 </semantics>
</math>

 is complex or is greater than 2 in absolute value, the arccosine should be taken along the same branch for all three values of 

<math display="inline" id="Eigenvalue_algorithm:160">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

. This issue doesn't arise when 

<math display="inline" id="Eigenvalue_algorithm:161">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 is real and symmetric, resulting in a simple algorithm:<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></p>
<div class="sourceCode"><pre class="sourceCode matlab"><code class="sourceCode matlab"><span class="co">% Given a real symmetric 3x3 matrix A, compute the eigenvalues</span>

p1 = A(<span class="fl">1</span>,<span class="fl">2</span>)^<span class="fl">2</span> + A(<span class="fl">1</span>,<span class="fl">3</span>)^<span class="fl">2</span> + A(<span class="fl">2</span>,<span class="fl">3</span>)^<span class="fl">2</span>
if (p1 == <span class="fl">0</span>) 
   <span class="co">% A is diagonal.</span>
   eig1 = A(<span class="fl">1</span>,<span class="fl">1</span>)
   eig2 = A(<span class="fl">2</span>,<span class="fl">2</span>)
   eig3 = A(<span class="fl">3</span>,<span class="fl">3</span>)
else
   q = trace(A)/<span class="fl">3</span>
   p2 = (A(<span class="fl">1</span>,<span class="fl">1</span>) - q)^<span class="fl">2</span> + (A(<span class="fl">2</span>,<span class="fl">2</span>) - q)^<span class="fl">2</span> + (A(<span class="fl">3</span>,<span class="fl">3</span>) - q)^<span class="fl">2</span> + <span class="fl">2</span> * p1
   p = sqrt(p2 / <span class="fl">6</span>)
   B = (<span class="fl">1</span> / p) * (A - q * I)       <span class="co">% I is the identity matrix</span>
   r = det(B) / <span class="fl">2</span>

   <span class="co">% In exact arithmetic for a symmetric matrix  -1 &lt;= r &lt;= 1</span>
   <span class="co">% but computation error can leave it slightly outside this range.</span>
   if (r &lt;= -<span class="fl">1</span>) 
      phi = pi / <span class="fl">3</span>
   elseif (r &gt;= <span class="fl">1</span>)
      phi = <span class="fl">0</span>
   else
      phi = acos(r) / <span class="fl">3</span>
   end

   <span class="co">% the eigenvalues satisfy eig3 &lt;= eig2 &lt;= eig1</span>
   eig1 = q + <span class="fl">2</span> * p * cos(phi)
   eig3 = q + <span class="fl">2</span> * p * cos(phi + (<span class="fl">2</span>*pi/<span class="fl">3</span>))
   eig2 = <span class="fl">3</span> * q - eig1 - eig3     <span class="co">% since trace(A) = eig1 + eig2 + eig3</span>
end</code></pre></div>

<p>Once again, the eigenvectors of 

<math display="inline" id="Eigenvalue_algorithm:162">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 can be obtained by recourse to the <a href="Cayley-Hamilton_theorem" title="wikilink">Cayley-Hamilton theorem</a>. If <mtpl></mtpl> are distinct eigenvalues of 

<math display="inline" id="Eigenvalue_algorithm:163">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

, then <mtpl></mtpl>. Thus the columns of the product of any two of these matrices will contain an eigenvector for the third eigenvalue. However, if <mtpl></mtpl>, then <mtpl></mtpl> and <mtpl></mtpl>. Thus the <em>generalized</em> eigenspace of <mtpl></mtpl> is spanned by the columns of <mtpl></mtpl> while the ordinary eigenspace is spanned by the columns of <mtpl></mtpl>. The ordinary eigenspace of <mtpl></mtpl> is spanned by the columns of <mtpl></mtpl>.</p>

<p>For example, let</p>

<p>

<math display="block" id="Eigenvalue_algorithm:164">
 <semantics>
  <mrow>
   <mrow>
    <mi>A</mi>
    <mo>=</mo>
    <mrow>
     <mo>[</mo>
     <mtable displaystyle="true">
      <mtr>
       <mtd columnalign="center">
        <mn>3</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>2</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>6</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>2</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>2</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>5</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mrow>
         <mo>-</mo>
         <mn>2</mn>
        </mrow>
       </mtd>
       <mtd columnalign="center">
        <mrow>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
       </mtd>
       <mtd columnalign="center">
        <mrow>
         <mo>-</mo>
         <mn>4</mn>
        </mrow>
       </mtd>
      </mtr>
     </mtable>
     <mo>]</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>A</ci>
    <matrix>
     <matrixrow>
      <cn type="integer">3</cn>
      <cn type="integer">2</cn>
      <cn type="integer">6</cn>
     </matrixrow>
     <matrixrow>
      <cn type="integer">2</cn>
      <cn type="integer">2</cn>
      <cn type="integer">5</cn>
     </matrixrow>
     <matrixrow>
      <apply>
       <minus></minus>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <minus></minus>
       <cn type="integer">4</cn>
      </apply>
     </matrixrow>
    </matrix>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A=\begin{bmatrix}3&2&6\\
2&2&5\\
-2&-1&-4\end{bmatrix}.
  </annotation>
 </semantics>
</math>

</p>

<p>The characteristic equation is</p>

<p>

<math display="block" id="Eigenvalue_algorithm:165">
 <semantics>
  <mrow>
   <mrow>
    <mn>0</mn>
    <mo>=</mo>
    <mrow>
     <mrow>
      <msup>
       <mi>λ</mi>
       <mn>3</mn>
      </msup>
      <mo>-</mo>
      <msup>
       <mi>λ</mi>
       <mn>2</mn>
      </msup>
      <mo>-</mo>
      <mi>λ</mi>
     </mrow>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>λ</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mn>2</mn>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>λ</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <cn type="integer">0</cn>
     <apply>
      <plus></plus>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>λ</ci>
        <cn type="integer">3</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>λ</ci>
        <cn type="integer">2</cn>
       </apply>
       <ci>λ</ci>
      </apply>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <minus></minus>
        <ci>λ</ci>
        <cn type="integer">1</cn>
       </apply>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <plus></plus>
       <ci>λ</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0=\lambda^{3}-\lambda^{2}-\lambda+1=(\lambda-1)^{2}(\lambda+1),
  </annotation>
 </semantics>
</math>

</p>

<p>with eigenvalues 1 (of multiplicity 2) and -1. Calculating,</p>

<p>

<math display="block" id="Eigenvalue_algorithm:166">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>A</mi>
     <mo>-</mo>
     <mi>I</mi>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo>[</mo>
     <mtable displaystyle="true">
      <mtr>
       <mtd columnalign="center">
        <mn>2</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>2</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>6</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>2</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>5</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mrow>
         <mo>-</mo>
         <mn>2</mn>
        </mrow>
       </mtd>
       <mtd columnalign="center">
        <mrow>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
       </mtd>
       <mtd columnalign="center">
        <mrow>
         <mo>-</mo>
         <mn>5</mn>
        </mrow>
       </mtd>
      </mtr>
     </mtable>
     <mo>]</mo>
    </mrow>
   </mrow>
   <mo rspace="22.5pt">,</mo>
   <mrow>
    <mrow>
     <mi>A</mi>
     <mo>+</mo>
     <mi>I</mi>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo>[</mo>
     <mtable displaystyle="true">
      <mtr>
       <mtd columnalign="center">
        <mn>4</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>2</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>6</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>2</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>3</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>5</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mrow>
         <mo>-</mo>
         <mn>2</mn>
        </mrow>
       </mtd>
       <mtd columnalign="center">
        <mrow>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
       </mtd>
       <mtd columnalign="center">
        <mrow>
         <mo>-</mo>
         <mn>3</mn>
        </mrow>
       </mtd>
      </mtr>
     </mtable>
     <mo>]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <minus></minus>
      <ci>A</ci>
      <ci>I</ci>
     </apply>
     <matrix>
      <matrixrow>
       <cn type="integer">2</cn>
       <cn type="integer">2</cn>
       <cn type="integer">6</cn>
      </matrixrow>
      <matrixrow>
       <cn type="integer">2</cn>
       <cn type="integer">1</cn>
       <cn type="integer">5</cn>
      </matrixrow>
      <matrixrow>
       <apply>
        <minus></minus>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <minus></minus>
        <cn type="integer">5</cn>
       </apply>
      </matrixrow>
     </matrix>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <plus></plus>
      <ci>A</ci>
      <ci>I</ci>
     </apply>
     <matrix>
      <matrixrow>
       <cn type="integer">4</cn>
       <cn type="integer">2</cn>
       <cn type="integer">6</cn>
      </matrixrow>
      <matrixrow>
       <cn type="integer">2</cn>
       <cn type="integer">3</cn>
       <cn type="integer">5</cn>
      </matrixrow>
      <matrixrow>
       <apply>
        <minus></minus>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <minus></minus>
        <cn type="integer">3</cn>
       </apply>
      </matrixrow>
     </matrix>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A-I=\begin{bmatrix}2&2&6\\
2&1&5\\
-2&-1&-5\end{bmatrix},\qquad A+I=\begin{bmatrix}4&2&6\\
2&3&5\\
-2&-1&-3\end{bmatrix}
  </annotation>
 </semantics>
</math>

</p>

<p>and</p>

<p>

<math display="block" id="Eigenvalue_algorithm:167">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>A</mi>
       <mo>-</mo>
       <mi>I</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mn>2</mn>
    </msup>
    <mo>=</mo>
    <mrow>
     <mo>[</mo>
     <mtable displaystyle="true">
      <mtr>
       <mtd columnalign="center">
        <mrow>
         <mo>-</mo>
         <mn>4</mn>
        </mrow>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mrow>
         <mo>-</mo>
         <mn>8</mn>
        </mrow>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mrow>
         <mo>-</mo>
         <mn>4</mn>
        </mrow>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mrow>
         <mo>-</mo>
         <mn>8</mn>
        </mrow>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>4</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>8</mn>
       </mtd>
      </mtr>
     </mtable>
     <mo>]</mo>
    </mrow>
   </mrow>
   <mo rspace="22.5pt">,</mo>
   <mrow>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>A</mi>
       <mo>-</mo>
       <mi>I</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>A</mi>
       <mo>+</mo>
       <mi>I</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo>[</mo>
     <mtable displaystyle="true">
      <mtr>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>4</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>4</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>2</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>2</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mrow>
         <mo>-</mo>
         <mn>2</mn>
        </mrow>
       </mtd>
       <mtd columnalign="center">
        <mrow>
         <mo>-</mo>
         <mn>2</mn>
        </mrow>
       </mtd>
      </mtr>
     </mtable>
     <mo>]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <minus></minus>
       <ci>A</ci>
       <ci>I</ci>
      </apply>
      <cn type="integer">2</cn>
     </apply>
     <matrix>
      <matrixrow>
       <apply>
        <minus></minus>
        <cn type="integer">4</cn>
       </apply>
       <cn type="integer">0</cn>
       <apply>
        <minus></minus>
        <cn type="integer">8</cn>
       </apply>
      </matrixrow>
      <matrixrow>
       <apply>
        <minus></minus>
        <cn type="integer">4</cn>
       </apply>
       <cn type="integer">0</cn>
       <apply>
        <minus></minus>
        <cn type="integer">8</cn>
       </apply>
      </matrixrow>
      <matrixrow>
       <cn type="integer">4</cn>
       <cn type="integer">0</cn>
       <cn type="integer">8</cn>
      </matrixrow>
     </matrix>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <minus></minus>
       <ci>A</ci>
       <ci>I</ci>
      </apply>
      <apply>
       <plus></plus>
       <ci>A</ci>
       <ci>I</ci>
      </apply>
     </apply>
     <matrix>
      <matrixrow>
       <cn type="integer">0</cn>
       <cn type="integer">4</cn>
       <cn type="integer">4</cn>
      </matrixrow>
      <matrixrow>
       <cn type="integer">0</cn>
       <cn type="integer">2</cn>
       <cn type="integer">2</cn>
      </matrixrow>
      <matrixrow>
       <cn type="integer">0</cn>
       <apply>
        <minus></minus>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <minus></minus>
        <cn type="integer">2</cn>
       </apply>
      </matrixrow>
     </matrix>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (A-I)^{2}=\begin{bmatrix}-4&0&-8\\
-4&0&-8\\
4&0&8\end{bmatrix},\qquad(A-I)(A+I)=\begin{bmatrix}0&4&4\\
0&2&2\\
0&-2&-2\end{bmatrix}
  </annotation>
 </semantics>
</math>

</p>

<p>Thus 

<math display="inline" id="Eigenvalue_algorithm:168">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mo>-</mo>
    <mn>4</mn>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mo>-</mo>
    <mn>4</mn>
   </mrow>
   <mo>,</mo>
   <mn>4</mn>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <apply>
     <minus></minus>
     <cn type="integer">4</cn>
    </apply>
    <apply>
     <minus></minus>
     <cn type="integer">4</cn>
    </apply>
    <cn type="integer">4</cn>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (-4,-4,4)
  </annotation>
 </semantics>
</math>

 is an eigenvector for -1, and 

<math display="inline" id="Eigenvalue_algorithm:169">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mn>4</mn>
   <mo>,</mo>
   <mn>2</mn>
   <mo>,</mo>
   <mrow>
    <mo>-</mo>
    <mn>2</mn>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <cn type="integer">4</cn>
    <cn type="integer">2</cn>
    <apply>
     <minus></minus>
     <cn type="integer">2</cn>
    </apply>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (4,2,-2)
  </annotation>
 </semantics>
</math>

 is an eigenvector for 1. 

<math display="inline" id="Eigenvalue_algorithm:170">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mn>2</mn>
   <mo>,</mo>
   <mn>3</mn>
   <mo>,</mo>
   <mrow>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <cn type="integer">2</cn>
    <cn type="integer">3</cn>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
    </apply>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (2,3,-1)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Eigenvalue_algorithm:171">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mn>6</mn>
   <mo>,</mo>
   <mn>5</mn>
   <mo>,</mo>
   <mrow>
    <mo>-</mo>
    <mn>3</mn>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <cn type="integer">6</cn>
    <cn type="integer">5</cn>
    <apply>
     <minus></minus>
     <cn type="integer">3</cn>
    </apply>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (6,5,-3)
  </annotation>
 </semantics>
</math>

 are both generalized eigenvectors associated with 1, either one of which could be combined with 

<math display="inline" id="Eigenvalue_algorithm:172">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mo>-</mo>
    <mn>4</mn>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mo>-</mo>
    <mn>4</mn>
   </mrow>
   <mo>,</mo>
   <mn>4</mn>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <apply>
     <minus></minus>
     <cn type="integer">4</cn>
    </apply>
    <apply>
     <minus></minus>
     <cn type="integer">4</cn>
    </apply>
    <cn type="integer">4</cn>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (-4,-4,4)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Eigenvalue_algorithm:173">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mn>4</mn>
   <mo>,</mo>
   <mn>2</mn>
   <mo>,</mo>
   <mrow>
    <mo>-</mo>
    <mn>2</mn>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <cn type="integer">4</cn>
    <cn type="integer">2</cn>
    <apply>
     <minus></minus>
     <cn type="integer">2</cn>
    </apply>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (4,2,-2)
  </annotation>
 </semantics>
</math>

 to form a basis of generalized eigenvectors of 

<math display="inline" id="Eigenvalue_algorithm:174">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

.In some routine eigenvectors are normalized to one, in such case make sure you normalized by column.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="List_of_numerical_analysis_topics#Eigenvalue_algorithms" title="wikilink">List of eigenvalue algorithms</a></li>
</ul>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<h2 id="further-reading">Further reading</h2>
<ul>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Numerical_linear_algebra" title="wikilink">Category:Numerical linear algebra</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2">The term "ordinary" is used here only to emphasize the distinction between "eigenvector" and "generalized eigenvector".<a href="#fnref2">↩</a></li>
<li id="fn3">where the constant term is multiplied by the identity matrix 

<math display="inline" id="Eigenvalue_algorithm:175">
 <semantics>
  <mi>I</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>I</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I
  </annotation>
 </semantics>
</math>

.<a href="#fnref3">↩</a></li>
<li id="fn4">This ordering of the inner product (with the conjugate-linear position on the left), is preferred by physicists. Algebraists often place the conjugate-linear position on the right: <mtpl></mtpl>.<a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
</ol>
</section>
</body>

