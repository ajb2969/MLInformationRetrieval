<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="822">Top tree</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Top tree</h1>
<hr/>

<p>A <strong>top tree</strong> is a <a href="data_structure" title="wikilink">data structure</a> based on a binary tree for unrooted dynamic <a href="Tree_(data_structure)" title="wikilink">trees</a> that is used mainly for various path-related operations. It allows simple <a href="divide-and-conquer_algorithm" title="wikilink">divide-and-conquer algorithms</a>. It has since been augmented to maintain dynamically various properties of a <a href="Tree_(data_structure)" title="wikilink">tree</a> such as diameter, center and median.</p>

<p>A top tree 

<math display="inline" id="Top_tree:0">
 <semantics>
  <mi mathvariant="normal">ℜ</mi>
  <annotation-xml encoding="MathML-Content">
   <real></real>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Re
  </annotation>
 </semantics>
</math>

 is defined for an <em>underlying tree</em> 

<math display="inline" id="Top_tree:1">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒯</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒯</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{T}
  </annotation>
 </semantics>
</math>

 and a set 

<math display="inline" id="Top_tree:2">
 <semantics>
  <mrow>
   <mo>∂</mo>
   <mi>T</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <partialdiff></partialdiff>
    <ci>T</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \partial{T}
  </annotation>
 </semantics>
</math>

 of at most two vertices called as <a href="#External_Boundary_Vertices" title="wikilink">External Boundary Vertices</a></p>
<figure><b>(Figure)</b>
<figcaption>An image depicting a top tree built on an underlying tree (black nodes)A tree divided into edge clusters and the complete top-tree for it. Filled nodes in the top-tree are path-clusters, while small circle nodes are leaf-clusters. The big circle node is the root. Capital letters denote clusters, non-capital letters are nodes.</figcaption>
</figure>
<h2 id="glossary">Glossary</h2>
<h3 id="boundary-node">Boundary Node</h3>

<p>See <a href="#Boundary_Vertex" title="wikilink">Boundary Vertex</a></p>
<h3 id="boundary-vertex">Boundary Vertex</h3>

<p>A vertex in a connected subtree is a <em>Boundary Vertex</em> if it is connected to a vertex outside the subtree by an edge.</p>
<h4 id="external-boundary-vertices">External Boundary Vertices</h4>

<p>Up to a pair of vertices in the top tree 

<math display="inline" id="Top_tree:3">
 <semantics>
  <mi mathvariant="normal">ℜ</mi>
  <annotation-xml encoding="MathML-Content">
   <real></real>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Re
  </annotation>
 </semantics>
</math>

 can be called as External Boundary Vertices, they can be thought of as Boundary Vertices of the cluster which represents the entire top tree.</p>
<h3 id="cluster">Cluster</h3>

<p>A <em>cluster</em> is a connected subtree with at most two <a href="#Boundary_Vertex" title="wikilink">Boundary Vertices</a>. The set of <a href="#Boundary_Vertex" title="wikilink">Boundary Vertices</a> of a given cluster 

<math display="inline" id="Top_tree:4">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒞</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒞</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{C}
  </annotation>
 </semantics>
</math>

 is denoted as 

<math display="inline" id="Top_tree:5">
 <semantics>
  <mrow>
   <mrow>
    <mo>∂</mo>
    <mi>C</mi>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <partialdiff></partialdiff>
    <ci>C</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \partial{C}.
  </annotation>
 </semantics>
</math>

 With each cluster 

<math display="inline" id="Top_tree:6">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒞</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒞</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{C}
  </annotation>
 </semantics>
</math>

 the user may associate some meta information 

<math display="inline" id="Top_tree:7">
 <semantics>
  <mrow>
   <mrow>
    <mi>I</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi class="ltx_font_mathcaligraphic">𝒞</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>I</ci>
    <ci>𝒞</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I(\mathcal{C}),
  </annotation>
 </semantics>
</math>

 and give methods to maintain it under the various <a href="#Internal_Operations" title="wikilink">internal operations</a>.</p>
<h4 id="path-cluster">Path Cluster</h4>

<p>If 

<math display="inline" id="Top_tree:8">
 <semantics>
  <mrow>
   <mi>π</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi class="ltx_font_mathcaligraphic">𝒞</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>π</ci>
    <ci>𝒞</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi(\mathcal{C})
  </annotation>
 </semantics>
</math>

 contains at least one edge then 

<math display="inline" id="Top_tree:9">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒞</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒞</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{C}
  </annotation>
 </semantics>
</math>

 is called a <em>Path Cluster</em>.</p>
<h4 id="point-cluster">Point Cluster</h4>

<p>See <a href="#Leaf_Cluster" title="wikilink">Leaf Cluster</a></p>
<h4 id="leaf-cluster">Leaf Cluster</h4>

<p>If 

<math display="inline" id="Top_tree:10">
 <semantics>
  <mrow>
   <mi>π</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi class="ltx_font_mathcaligraphic">𝒞</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>π</ci>
    <ci>𝒞</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi(\mathcal{C})
  </annotation>
 </semantics>
</math>

 does not contain any edge i.e. 

<math display="inline" id="Top_tree:11">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒞</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒞</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{C}
  </annotation>
 </semantics>
</math>

 has only one <a href="#Boundary_Vertex" title="wikilink">Boundary Vertex</a> then 

<math display="inline" id="Top_tree:12">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒞</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒞</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{C}
  </annotation>
 </semantics>
</math>

 is called a <em>Leaf Cluster</em>.</p>
<h4 id="edge-cluster">Edge Cluster</h4>

<p>A Cluster containing a single edge is called an <em>Edge Cluster</em>.</p>
<h5 id="leaf-edge-cluster">Leaf Edge Cluster</h5>

<p>A Leaf in the original Cluster is represented by a Cluster with just a single Boundary Vertex and is called a <em>Leaf Edge Cluster</em>.</p>
<h5 id="path-edge-cluster">Path Edge Cluster</h5>

<p>Edge Clusters with two Boundary Nodes are called <em>Path Edge Cluster</em>.</p>
<h3 id="internal-node">Internal Node</h3>

<p>A node in 

<math display="inline" id="Top_tree:13">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒞</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒞</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{C}
  </annotation>
 </semantics>
</math>

 <strong>\</strong> 

<math display="inline" id="Top_tree:14">
 <semantics>
  <mrow>
   <mo>∂</mo>
   <mi>C</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <partialdiff></partialdiff>
    <ci>C</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \partial{C}
  </annotation>
 </semantics>
</math>

 is called an <em>Internal Node</em> of 

<math display="inline" id="Top_tree:15">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">𝒞</mi>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒞</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{C}.
  </annotation>
 </semantics>
</math>

</p>
<h3 id="cluster-path">Cluster Path</h3>

<p>The path between the <a href="#Boundary_Vertex" title="wikilink">Boundary Vertices</a> of 

<math display="inline" id="Top_tree:16">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒞</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒞</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{C}
  </annotation>
 </semantics>
</math>

 is called the <em>cluster path</em> of 

<math display="inline" id="Top_tree:17">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒞</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒞</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{C}
  </annotation>
 </semantics>
</math>

 and it is denoted by 

<math display="inline" id="Top_tree:18">
 <semantics>
  <mrow>
   <mrow>
    <mi>π</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi class="ltx_font_mathcaligraphic">𝒞</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>π</ci>
    <ci>𝒞</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi(\mathcal{C}).
  </annotation>
 </semantics>
</math>

</p>
<h3 id="mergeable-clusters">Mergeable Clusters</h3>

<p>Two Clusters 

<math display="inline" id="Top_tree:19">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒜</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒜</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{A}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Top_tree:20">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ℬ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℬ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{B}
  </annotation>
 </semantics>
</math>

 are <em>Mergeable</em> if 

<math display="inline" id="Top_tree:21">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">𝒜</mi>
   <mo>∩</mo>
   <mi class="ltx_font_mathcaligraphic">ℬ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <intersect></intersect>
    <ci>𝒜</ci>
    <ci>ℬ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{A}\cap\mathcal{B}
  </annotation>
 </semantics>
</math>

 is a singleton set (they have exactly one node in common) and 

<math display="inline" id="Top_tree:22">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">𝒜</mi>
   <mo>∪</mo>
   <mi class="ltx_font_mathcaligraphic">ℬ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <union></union>
    <ci>𝒜</ci>
    <ci>ℬ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{A}\cup\mathcal{B}
  </annotation>
 </semantics>
</math>

 is a Cluster.</p>
<h2 id="introduction">Introduction</h2>

<p><em>Top trees</em> are used for maintaining a Dynamic forest (set of trees) under <a href="#Dynamic_Operations" title="wikilink">link and cut operations.</a></p>

<p>The basic idea is to maintain a balanced <a href="Binary_tree" title="wikilink">Binary tree</a> 

<math display="inline" id="Top_tree:23">
 <semantics>
  <mi mathvariant="normal">ℜ</mi>
  <annotation-xml encoding="MathML-Content">
   <real></real>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Re
  </annotation>
 </semantics>
</math>

 of logarithmic height in the number of nodes in the original tree 

<math display="inline" id="Top_tree:24">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒯</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒯</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{T}
  </annotation>
 </semantics>
</math>

( i.e. in 

<math display="inline" id="Top_tree:25">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">𝒪</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>log</mi>
     <mi>n</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>𝒪</ci>
    <apply>
     <log></log>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{O}(\log n)
  </annotation>
 </semantics>
</math>

 time) ; the <strong>top tree</strong> essentially represents the recursive subdivision of the original tree 

<math display="inline" id="Top_tree:26">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒯</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒯</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{T}
  </annotation>
 </semantics>
</math>

 into <a href="#Cluster" title="wikilink">clusters</a>''.</p>

<p>In general the tree 

<math display="inline" id="Top_tree:27">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒯</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒯</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{T}
  </annotation>
 </semantics>
</math>

 may have weight on its edges.</p>

<p>There is a one to one correspondence with the edges of the original tree 

<math display="inline" id="Top_tree:28">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒯</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒯</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{T}
  </annotation>
 </semantics>
</math>

 and the leaf nodes of the top tree 

<math display="inline" id="Top_tree:29">
 <semantics>
  <mi mathvariant="normal">ℜ</mi>
  <annotation-xml encoding="MathML-Content">
   <real></real>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Re
  </annotation>
 </semantics>
</math>

 and each internal node of 

<math display="inline" id="Top_tree:30">
 <semantics>
  <mi mathvariant="normal">ℜ</mi>
  <annotation-xml encoding="MathML-Content">
   <real></real>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Re
  </annotation>
 </semantics>
</math>

 represents a cluster that is formed due to the union of the clusters that are its children.</p>

<p>The top tree data structure can be initialized in 

<math display="inline" id="Top_tree:31">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">𝒪</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>𝒪</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{O}(n)
  </annotation>
 </semantics>
</math>

 time.</p>

<p>Therefore the top tree 

<math display="inline" id="Top_tree:32">
 <semantics>
  <mi mathvariant="normal">ℜ</mi>
  <annotation-xml encoding="MathML-Content">
   <real></real>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Re
  </annotation>
 </semantics>
</math>

 over (

<math display="inline" id="Top_tree:33">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">𝒯</mi>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒯</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{T},
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Top_tree:34">
 <semantics>
  <mrow>
   <mo>∂</mo>
   <mi>T</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <partialdiff></partialdiff>
    <ci>T</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \partial{T}
  </annotation>
 </semantics>
</math>

) is a binary tree such that</p>
<ul>
<li>The nodes of 

<math display="inline" id="Top_tree:35">
 <semantics>
  <mi mathvariant="normal">ℜ</mi>
  <annotation-xml encoding="MathML-Content">
   <real></real>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Re
  </annotation>
 </semantics>
</math>

 are clusters of (

<math display="inline" id="Top_tree:36">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">𝒯</mi>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒯</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{T},
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Top_tree:37">
 <semantics>
  <mrow>
   <mo>∂</mo>
   <mi>T</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <partialdiff></partialdiff>
    <ci>T</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \partial{T}
  </annotation>
 </semantics>
</math>

 );</li>
<li>The leaves of 

<math display="inline" id="Top_tree:38">
 <semantics>
  <mi mathvariant="normal">ℜ</mi>
  <annotation-xml encoding="MathML-Content">
   <real></real>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Re
  </annotation>
 </semantics>
</math>

 are the edges of 

<math display="inline" id="Top_tree:39">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">𝒯</mi>
   <mo>;</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒯</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{T};
  </annotation>
 </semantics>
</math>

</li>
<li>Sibling clusters are neighbours in the sense that they intersect in a single vertex, and then their parent cluster is their union.</li>
<li>Root of 

<math display="inline" id="Top_tree:40">
 <semantics>
  <mi mathvariant="normal">ℜ</mi>
  <annotation-xml encoding="MathML-Content">
   <real></real>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Re
  </annotation>
 </semantics>
</math>

 is the tree 

<math display="inline" id="Top_tree:41">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒯</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒯</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{T}
  </annotation>
 </semantics>
</math>

 itself, with a set of at most two External Boundary Vertices.</li>
</ul>

<p>A tree with a single vertex has an empty top tree, and one with just an edge is just a single node.</p>

<p>These trees are freely <a href="Augmenting_a_Data_Structure" title="wikilink">augmentable</a> allowing the user a wide variety of flexibility and productivity without going into the details of the internal workings of the data structure, something which is also referred to as the <em>Black Box</em>.</p>
<h2 id="dynamic-operations">Dynamic Operations</h2>

<p>The following three are the user allowable Forest Updates.</p>
<ul>
<li><strong>Link(v, w):</strong> Where 

<math display="inline" id="Top_tree:42">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Top_tree:43">
 <semantics>
  <mi>w</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>w</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w
  </annotation>
 </semantics>
</math>

 are vertices in different trees 

<math display="inline" id="Top_tree:44">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒯</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒯</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{T}
  </annotation>
 </semantics>
</math>

<sub>1</sub> and 

<math display="inline" id="Top_tree:45">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒯</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒯</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{T}
  </annotation>
 </semantics>
</math>

<sub>2</sub>. It returns a single top tree representing 

<math display="inline" id="Top_tree:46">
 <semantics>
  <mi mathvariant="normal">ℜ</mi>
  <annotation-xml encoding="MathML-Content">
   <real></real>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Re
  </annotation>
 </semantics>
</math>

<sub>v</sub>

<math display="inline" id="Top_tree:47">
 <semantics>
  <mo>∪</mo>
  <annotation-xml encoding="MathML-Content">
   <union></union>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \cup
  </annotation>
 </semantics>
</math>



<math display="inline" id="Top_tree:48">
 <semantics>
  <mi mathvariant="normal">ℜ</mi>
  <annotation-xml encoding="MathML-Content">
   <real></real>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Re
  </annotation>
 </semantics>
</math>

<sub>w</sub>

<math display="inline" id="Top_tree:49">
 <semantics>
  <mrow>
   <mo>∪</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>v</mi>
    <mo>,</mo>
    <mi>w</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <union></union>
    <interval closure="open">
     <ci>v</ci>
     <ci>w</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \cup{(v,w)}
  </annotation>
 </semantics>
</math>

</li>
</ul>
<ul>
<li><strong>Cut(v, w)</strong>: Removes the edge 

<math display="inline" id="Top_tree:50">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>v</mi>
   <mo>,</mo>
   <mi>w</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>v</ci>
    <ci>w</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {(v,w)}
  </annotation>
 </semantics>
</math>

 from a tree 

<math display="inline" id="Top_tree:51">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒯</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒯</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{T}
  </annotation>
 </semantics>
</math>

 with top tree 

<math display="inline" id="Top_tree:52">
 <semantics>
  <mrow>
   <mi mathvariant="normal">ℜ</mi>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <real></real>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Re,
  </annotation>
 </semantics>
</math>

 thereby turning it into two trees 

<math display="inline" id="Top_tree:53">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒯</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒯</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{T}
  </annotation>
 </semantics>
</math>

<sub>v</sub> and 

<math display="inline" id="Top_tree:54">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒯</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒯</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{T}
  </annotation>
 </semantics>
</math>

<sub>w</sub> and returning two top trees 

<math display="inline" id="Top_tree:55">
 <semantics>
  <mi mathvariant="normal">ℜ</mi>
  <annotation-xml encoding="MathML-Content">
   <real></real>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Re
  </annotation>
 </semantics>
</math>

<sub>v</sub> and 

<math display="inline" id="Top_tree:56">
 <semantics>
  <mi mathvariant="normal">ℜ</mi>
  <annotation-xml encoding="MathML-Content">
   <real></real>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Re
  </annotation>
 </semantics>
</math>

<sub>w</sub>.</li>
</ul>
<ul>
<li><strong>Expose(S)</strong>: Is called as a subroutine for implementing most of the queries on a top tree. 

<math display="inline" id="Top_tree:57">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 contains at most 2 vertices. It makes original external vertices to be normal vertices and makes vertices from 

<math display="inline" id="Top_tree:58">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 the new External Boundary Vertices of the top tree. If 

<math display="inline" id="Top_tree:59">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 is nonempty it returns the new Root cluster 

<math display="inline" id="Top_tree:60">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒞</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒞</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{C}
  </annotation>
 </semantics>
</math>

 with 

<math display="inline" id="Top_tree:61">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>∂</mo>
     <mi>C</mi>
    </mrow>
    <mo>=</mo>
    <mi>S</mi>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <partialdiff></partialdiff>
     <ci>C</ci>
    </apply>
    <ci>S</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \partial{C}=S.
  </annotation>
 </semantics>
</math>

 <strong>Expose({v,w})</strong> fails if the vertices are from different trees.</li>
</ul>
<h2 id="internal-operations">Internal Operations</h2>

<p>The <a href="#Dynamic_Operations" title="wikilink">Forest updates</a> are all carried out by a sequence of at most 

<math display="inline" id="Top_tree:62">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">𝒪</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>log</mi>
     <mi>n</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>𝒪</ci>
    <apply>
     <log></log>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{O}(\log n)
  </annotation>
 </semantics>
</math>

 Internal Operations, the sequence of which is computed in further 

<math display="inline" id="Top_tree:63">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">𝒪</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>log</mi>
     <mi>n</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>𝒪</ci>
    <apply>
     <log></log>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{O}(\log n)
  </annotation>
 </semantics>
</math>

 time. It may happen that during a tree update, a leaf cluster may change to a path cluster and the converse. Updates to top tree are done exclusively by these internal operations.</p>

<p>The 

<math display="inline" id="Top_tree:64">
 <semantics>
  <mrow>
   <mi>I</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi class="ltx_font_mathcaligraphic">𝒞</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>I</ci>
    <ci>𝒞</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I(\mathcal{C})
  </annotation>
 </semantics>
</math>

 is updated by calling a user defined function associated with each internal operation.</p>
<ul>
<li><strong>Merge</strong>

<math display="inline" id="Top_tree:65">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi class="ltx_font_mathcaligraphic">𝒜</mi>
    <mo>,</mo>
    <mi class="ltx_font_mathcaligraphic">ℬ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>:</mo>
   <mi></mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <interval closure="open">
     <ci>𝒜</ci>
     <ci>ℬ</ci>
    </interval>
    <csymbol cd="latexml">absent</csymbol>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\mathcal{A},\mathcal{B}){:}
  </annotation>
 </semantics>
</math>

 Here 

<math display="inline" id="Top_tree:66">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒜</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒜</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{A}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Top_tree:67">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ℬ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℬ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{B}
  </annotation>
 </semantics>
</math>

 are <em>Mergeable Clusters</em>, it returns 

<math display="inline" id="Top_tree:68">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒞</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒞</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{C}
  </annotation>
 </semantics>
</math>

 as the parent cluster of 

<math display="inline" id="Top_tree:69">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒜</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒜</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{A}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Top_tree:70">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ℬ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℬ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{B}
  </annotation>
 </semantics>
</math>

 and with boundary vertices as the boundary vertices of 

<math display="inline" id="Top_tree:71">
 <semantics>
  <mrow>
   <mrow>
    <mi class="ltx_font_mathcaligraphic">𝒜</mi>
    <mo>∪</mo>
    <mi class="ltx_font_mathcaligraphic">ℬ</mi>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <union></union>
    <ci>𝒜</ci>
    <ci>ℬ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{A}\cup\mathcal{B}.
  </annotation>
 </semantics>
</math>

 Computes 

<math display="inline" id="Top_tree:72">
 <semantics>
  <mrow>
   <mi>I</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi class="ltx_font_mathcaligraphic">𝒞</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>I</ci>
    <ci>𝒞</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I(\mathcal{C})
  </annotation>
 </semantics>
</math>

 using 

<math display="inline" id="Top_tree:73">
 <semantics>
  <mrow>
   <mi>I</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi class="ltx_font_mathcaligraphic">𝒜</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>I</ci>
    <ci>𝒜</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I(\mathcal{A})
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Top_tree:74">
 <semantics>
  <mrow>
   <mrow>
    <mi>I</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi class="ltx_font_mathcaligraphic">ℬ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>I</ci>
    <ci>ℬ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I(\mathcal{B}).
  </annotation>
 </semantics>
</math>

</li>
</ul>
<ul>
<li><strong>Split</strong>

<math display="inline" id="Top_tree:75">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi class="ltx_font_mathcaligraphic">𝒞</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>:</mo>
   <mi></mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>𝒞</ci>
    <csymbol cd="latexml">absent</csymbol>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\mathcal{C}){:}
  </annotation>
 </semantics>
</math>

 Here 

<math display="inline" id="Top_tree:76">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒞</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒞</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{C}
  </annotation>
 </semantics>
</math>

 is the root cluster 

<math display="inline" id="Top_tree:77">
 <semantics>
  <mrow>
   <mrow>
    <mi class="ltx_font_mathcaligraphic">𝒜</mi>
    <mo>∪</mo>
    <mi class="ltx_font_mathcaligraphic">ℬ</mi>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <union></union>
    <ci>𝒜</ci>
    <ci>ℬ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{A}\cup\mathcal{B}.
  </annotation>
 </semantics>
</math>

 It updates 

<math display="inline" id="Top_tree:78">
 <semantics>
  <mrow>
   <mi>I</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi class="ltx_font_mathcaligraphic">𝒜</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>I</ci>
    <ci>𝒜</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I(\mathcal{A})
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Top_tree:79">
 <semantics>
  <mrow>
   <mi>I</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi class="ltx_font_mathcaligraphic">ℬ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>I</ci>
    <ci>ℬ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I(\mathcal{B})
  </annotation>
 </semantics>
</math>

 using 

<math display="inline" id="Top_tree:80">
 <semantics>
  <mrow>
   <mi>I</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi class="ltx_font_mathcaligraphic">𝒞</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>I</ci>
    <ci>𝒞</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I(\mathcal{C})
  </annotation>
 </semantics>
</math>

 and than it deletes the cluster 

<math display="inline" id="Top_tree:81">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒞</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒞</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{C}
  </annotation>
 </semantics>
</math>

 from 

<math display="inline" id="Top_tree:82">
 <semantics>
  <mi mathvariant="normal">ℜ</mi>
  <annotation-xml encoding="MathML-Content">
   <real></real>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Re
  </annotation>
 </semantics>
</math>

.</li>
</ul>

<p>Split is usually implemented using <strong>Clean</strong>

<math display="inline" id="Top_tree:83">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi class="ltx_font_mathcaligraphic">𝒞</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒞</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\mathcal{C})
  </annotation>
 </semantics>
</math>

 method which calls user method for updates of 

<math display="inline" id="Top_tree:84">
 <semantics>
  <mrow>
   <mi>I</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi class="ltx_font_mathcaligraphic">𝒜</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>I</ci>
    <ci>𝒜</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I(\mathcal{A})
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Top_tree:85">
 <semantics>
  <mrow>
   <mi>I</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi class="ltx_font_mathcaligraphic">ℬ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>I</ci>
    <ci>ℬ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I(\mathcal{B})
  </annotation>
 </semantics>
</math>

 using 

<math display="inline" id="Top_tree:86">
 <semantics>
  <mrow>
   <mi>I</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi class="ltx_font_mathcaligraphic">𝒞</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>I</ci>
    <ci>𝒞</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I(\mathcal{C})
  </annotation>
 </semantics>
</math>

 and updates 

<math display="inline" id="Top_tree:87">
 <semantics>
  <mrow>
   <mi>I</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi class="ltx_font_mathcaligraphic">𝒞</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>I</ci>
    <ci>𝒞</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I(\mathcal{C})
  </annotation>
 </semantics>
</math>

 such that it's known there is no pending update needed in its children. Than the 

<math display="inline" id="Top_tree:88">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒞</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒞</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{C}
  </annotation>
 </semantics>
</math>

 is discarded without calling user defined functions. <strong>Clean</strong> is often required for queries without need to <strong>Split</strong>. If Split does not use Clean subroutine, and Clean is required, its effect could be achieved with overhead by combining <strong>Merge</strong> and <strong>Split</strong>.</p>

<p>The next two functions are analogous to the above two and are used for base clusters.</p>
<ul>
<li><strong>Create

<math display="inline" id="Top_tree:89">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>v</mi>
    <mo>,</mo>
    <mi>w</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>:</mo>
   <mi></mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <interval closure="open">
     <ci>v</ci>
     <ci>w</ci>
    </interval>
    <csymbol cd="latexml">absent</csymbol>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (v,w){:}
  </annotation>
 </semantics>
</math>

</strong> Creates a cluster 

<math display="inline" id="Top_tree:90">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒞</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒞</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{C}
  </annotation>
 </semantics>
</math>

 for the edge 

<math display="inline" id="Top_tree:91">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>v</mi>
    <mo>,</mo>
    <mi>w</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>v</ci>
    <ci>w</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (v,w).
  </annotation>
 </semantics>
</math>

 Sets 

<math display="inline" id="Top_tree:92">
 <semantics>
  <mrow>
   <mrow>
    <mo>∂</mo>
    <mi>C</mi>
   </mrow>
   <mo>=</mo>
   <mo>∂</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <partialdiff></partialdiff>
     <ci>C</ci>
    </apply>
    <partialdiff></partialdiff>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \partial{C}=\partial
  </annotation>
 </semantics>
</math>



<math display="inline" id="Top_tree:93">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>v</mi>
    <mo>,</mo>
    <mi>w</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>v</ci>
    <ci>w</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (v,w).
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Top_tree:94">
 <semantics>
  <mrow>
   <mi>I</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi class="ltx_font_mathcaligraphic">𝒞</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>I</ci>
    <ci>𝒞</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I(\mathcal{C})
  </annotation>
 </semantics>
</math>

 is computed from scratch.</li>
</ul>
<ul>
<li><strong>Eradicate

<math display="inline" id="Top_tree:95">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi class="ltx_font_mathcaligraphic">𝒞</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>:</mo>
   <mi></mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>𝒞</ci>
    <csymbol cd="latexml">absent</csymbol>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\mathcal{C}){:}
  </annotation>
 </semantics>
</math>

</strong> 

<math display="inline" id="Top_tree:96">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒞</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒞</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{C}
  </annotation>
 </semantics>
</math>

 is the edge cluster 

<math display="inline" id="Top_tree:97">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>v</mi>
    <mo>,</mo>
    <mi>w</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>v</ci>
    <ci>w</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (v,w).
  </annotation>
 </semantics>
</math>

 User defined function is called to process 

<math display="inline" id="Top_tree:98">
 <semantics>
  <mrow>
   <mi>I</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi class="ltx_font_mathcaligraphic">𝒞</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>I</ci>
    <ci>𝒞</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I(\mathcal{C})
  </annotation>
 </semantics>
</math>

 and than the cluster 

<math display="inline" id="Top_tree:99">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒞</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒞</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{C}
  </annotation>
 </semantics>
</math>

 is deleted from the top tree.</li>
</ul>
<h2 id="non-local-search">Non local search</h2>

<p>User can define <strong>Choose

<math display="inline" id="Top_tree:100">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi class="ltx_font_mathcaligraphic">𝒞</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>:</mo>
   <mi></mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>𝒞</ci>
    <csymbol cd="latexml">absent</csymbol>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\mathcal{C}){:}
  </annotation>
 </semantics>
</math>

</strong> operation which for a root (nonleaf) cluster selects one of its child clusters. The top tree blackbox provides <strong>Search

<math display="inline" id="Top_tree:101">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi class="ltx_font_mathcaligraphic">𝒞</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>:</mo>
   <mi></mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>𝒞</ci>
    <csymbol cd="latexml">absent</csymbol>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\mathcal{C}){:}
  </annotation>
 </semantics>
</math>

</strong> routine, which organizes <strong>Choose</strong> queries and reorganization of the top tree (using the Internal operations) such that it locates the only edge in intersection of all selected clusters. Sometimes the search should be limited to a path. There is a variant of nonlocal search for such purposes. If there are two external boundary vertices in the root cluster 

<math display="inline" id="Top_tree:102">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒞</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒞</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{C}
  </annotation>
 </semantics>
</math>

, the edge is searched only on the path 

<math display="inline" id="Top_tree:103">
 <semantics>
  <mrow>
   <mi>π</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi class="ltx_font_mathcaligraphic">𝒞</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>π</ci>
    <ci>𝒞</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi(\mathcal{C})
  </annotation>
 </semantics>
</math>

. It is sufficient to do following modification: If only one of root cluster children is path cluster, it is selected by default without calling the <strong>Choose</strong> operation.</p>
<h3 id="examples-of-non-local-search">Examples of non local search</h3>

<p>Finding i-th edge on longer path from 

<math display="inline" id="Top_tree:104">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Top_tree:105">
 <semantics>
  <mi>w</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>w</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w
  </annotation>
 </semantics>
</math>

 could be done by <strong>

<math display="inline" id="Top_tree:106">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒞</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒞</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{C}
  </annotation>
 </semantics>
</math>

=Expose({v,w})</strong> followed by <strong>Search(

<math display="inline" id="Top_tree:107">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒞</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒞</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{C}
  </annotation>
 </semantics>
</math>

)</strong> with appropriate <strong>Choose</strong>. To implement the <strong>Choose</strong> we use global variable representing 

<math display="inline" id="Top_tree:108">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>

 and global variable representing 

<math display="inline" id="Top_tree:109">
 <semantics>
  <mrow>
   <mi>i</mi>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i.
  </annotation>
 </semantics>
</math>

 Choose selects the cluster 

<math display="inline" id="Top_tree:110">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒜</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒜</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{A}
  </annotation>
 </semantics>
</math>

 with 

<math display="inline" id="Top_tree:111">
 <semantics>
  <mrow>
   <mi>v</mi>
   <mo>∈</mo>
   <mrow>
    <mo>∂</mo>
    <mi>A</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>v</ci>
    <apply>
     <partialdiff></partialdiff>
     <ci>A</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v\in\partial{A}
  </annotation>
 </semantics>
</math>

 iff length of 

<math display="inline" id="Top_tree:112">
 <semantics>
  <mrow>
   <mi>π</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi class="ltx_font_mathcaligraphic">𝒜</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>π</ci>
    <ci>𝒜</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi(\mathcal{A})
  </annotation>
 </semantics>
</math>

 is at least 

<math display="inline" id="Top_tree:113">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

. To support the operation the length must be maintained in the 

<math display="inline" id="Top_tree:114">
 <semantics>
  <mi>I</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>I</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I
  </annotation>
 </semantics>
</math>

.</p>

<p>Similar task could be formulated for graph with edges with nonunit lengths. In that case the distance could address an edge or a vertex between two edges. We could define Choose such that the edge leading to the vertex is returned in the latter case. There could be defined update increasing all edge lengths along a path by a constant. In such scenario these updates are done in constant time just in root cluster. <strong>Clean</strong> is required to distribute the delayed update to the children. The <strong>Clean</strong> should be called before the <strong>Search</strong> is invoked. To maintain length in 

<math display="inline" id="Top_tree:115">
 <semantics>
  <mi>I</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>I</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I
  </annotation>
 </semantics>
</math>

 would in that case require to maintain unitlength in 

<math display="inline" id="Top_tree:116">
 <semantics>
  <mi>I</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>I</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I
  </annotation>
 </semantics>
</math>

 as well.</p>

<p>Finding center of tree containing vertex 

<math display="inline" id="Top_tree:117">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>

 could be done by finding either bicenter edge or edge with center as one endpoint. The edge could be found by <strong>

<math display="inline" id="Top_tree:118">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒞</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒞</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{C}
  </annotation>
 </semantics>
</math>

=Expose({v})</strong> followed by <strong>Search(

<math display="inline" id="Top_tree:119">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒞</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒞</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{C}
  </annotation>
 </semantics>
</math>

)</strong> with appropriate <strong>Choose</strong>. The choose selects between children 

<math display="inline" id="Top_tree:120">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">𝒜</mi>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒜</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{A},
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Top_tree:121">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ℬ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℬ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{B}
  </annotation>
 </semantics>
</math>

 with 

<math display="inline" id="Top_tree:122">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo>∈</mo>
   <mrow>
    <mrow>
     <mo>∂</mo>
     <mi>A</mi>
    </mrow>
    <mo>∩</mo>
    <mrow>
     <mo>∂</mo>
     <mi>B</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>a</ci>
    <apply>
     <intersect></intersect>
     <apply>
      <partialdiff></partialdiff>
      <ci>A</ci>
     </apply>
     <apply>
      <partialdiff></partialdiff>
      <ci>B</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a\in\partial{A}\cap\partial{B}
  </annotation>
 </semantics>
</math>

 the child with higher maxdistance

<math display="inline" id="Top_tree:123">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>a</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (a)
  </annotation>
 </semantics>
</math>

. To support the operation the maximal distance in the cluster subtree from a boundary vertex should be maintained in the 

<math display="inline" id="Top_tree:124">
 <semantics>
  <mi>I</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>I</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I
  </annotation>
 </semantics>
</math>

. That requires maintenance of the cluster path length as well.</p>
<h2 id="interesting-results-and-applications">Interesting Results and Applications</h2>

<p>A number of interesting applications originally implemented by other methods have been easily implemented using the top tree's interface. Some of them include</p>
<ul>
<li>([SLEATOR AND TARJAN 1983]). We can maintain a dynamic collection of weighted trees in 

<math display="inline" id="Top_tree:125">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">𝒪</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>log</mi>
     <mi>n</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>𝒪</ci>
    <apply>
     <log></log>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{O}(\log n)
  </annotation>
 </semantics>
</math>

 time per link and cut, supporting queries about the maximum edge weight between any two vertices in 

<math display="inline" id="Top_tree:126">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>log</mi>
     <mi>n</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <log></log>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(\log n)
  </annotation>
 </semantics>
</math>

 time.
<ul>
<li>Proof outline: It involves maintaining at each node the maximum weight (max_wt) on its cluster path, if it is a point cluster then max_wt(

<math display="inline" id="Top_tree:127">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒞</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒞</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{C}
  </annotation>
 </semantics>
</math>

) is initialsed as 

<math display="inline" id="Top_tree:128">
 <semantics>
  <mrow>
   <mrow>
    <mo>-</mo>
    <mi mathvariant="normal">∞</mi>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <infinity></infinity>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   -\infty.
  </annotation>
 </semantics>
</math>

 When a cluster is a union of two clusters then it is the maximum value of the two merged clusters. If we have to find the max wt between 

<math display="inline" id="Top_tree:129">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Top_tree:130">
 <semantics>
  <mi>w</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>w</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w
  </annotation>
 </semantics>
</math>

 then we do 

<math display="inline" id="Top_tree:131">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">𝒞</mi>
   <mo>=</mo>
   <mi></mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>𝒞</ci>
    <csymbol cd="latexml">absent</csymbol>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{C}=
  </annotation>
 </semantics>
</math>

 Expose

<math display="inline" id="Top_tree:132">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>v</mi>
    <mo>,</mo>
    <mi>w</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>v</ci>
    <ci>w</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (v,w),
  </annotation>
 </semantics>
</math>

 and report max_wt

<math display="inline" id="Top_tree:133">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi class="ltx_font_mathcaligraphic">𝒞</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒞</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\mathcal{C}).
  </annotation>
 </semantics>
</math>

</li>
</ul></li>
</ul>
<ul>
<li>([SLEATOR AND TARJAN 1983]). In the scenario of the above application we can also add a common weight 

<math display="inline" id="Top_tree:134">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 to all edges on a given path 

<math display="inline" id="Top_tree:135">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>

 · · ·

<math display="inline" id="Top_tree:136">
 <semantics>
  <mi>w</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>w</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w
  </annotation>
 </semantics>
</math>

 in 

<math display="inline" id="Top_tree:137">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">𝒪</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>log</mi>
     <mi>n</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>𝒪</ci>
    <apply>
     <log></log>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{O}(\log n)
  </annotation>
 </semantics>
</math>

 time.
<ul>
<li>Proof outline: We introduce a weight called extra(

<math display="inline" id="Top_tree:138">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒞</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒞</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{C}
  </annotation>
 </semantics>
</math>

) to be added to all the edges in 

<math display="inline" id="Top_tree:139">
 <semantics>
  <mrow>
   <mrow>
    <mi>π</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi class="ltx_font_mathcaligraphic">𝒞</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>π</ci>
    <ci>𝒞</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi(\mathcal{C}).
  </annotation>
 </semantics>
</math>

 Which is maintained appropriately ; split(

<math display="inline" id="Top_tree:140">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒞</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒞</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{C}
  </annotation>
 </semantics>
</math>

) requires that, for each path child 

<math display="inline" id="Top_tree:141">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒜</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒜</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{A}
  </annotation>
 </semantics>
</math>

 of 

<math display="inline" id="Top_tree:142">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">𝒞</mi>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒞</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{C},
  </annotation>
 </semantics>
</math>

 we set max_wt(A) := max_wt(

<math display="inline" id="Top_tree:143">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒜</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒜</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{A}
  </annotation>
 </semantics>
</math>

) + extra(

<math display="inline" id="Top_tree:144">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒞</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒞</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{C}
  </annotation>
 </semantics>
</math>

) and extra(

<math display="inline" id="Top_tree:145">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒜</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒜</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{A}
  </annotation>
 </semantics>
</math>

) := extra(

<math display="inline" id="Top_tree:146">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒜</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒜</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{A}
  </annotation>
 </semantics>
</math>

) + extra(

<math display="inline" id="Top_tree:147">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒞</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒞</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{C}
  </annotation>
 </semantics>
</math>

). For 

<math display="inline" id="Top_tree:148">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒞</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒞</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{C}
  </annotation>
 </semantics>
</math>

 := join(

<math display="inline" id="Top_tree:149">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">𝒜</mi>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒜</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{A},
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Top_tree:150">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ℬ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℬ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{B}
  </annotation>
 </semantics>
</math>

), we set max_wt(

<math display="inline" id="Top_tree:151">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒞</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒞</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{C}
  </annotation>
 </semantics>
</math>

) := max {max_wt(

<math display="inline" id="Top_tree:152">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒜</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒜</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{A}
  </annotation>
 </semantics>
</math>

), max_wt(

<math display="inline" id="Top_tree:153">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ℬ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℬ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{B}
  </annotation>
 </semantics>
</math>

)} and extra(

<math display="inline" id="Top_tree:154">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒞</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒞</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{C}
  </annotation>
 </semantics>
</math>

) := 0. Finally, to find the maximum weight on the path 

<math display="inline" id="Top_tree:155">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>

 · · ·

<math display="inline" id="Top_tree:156">
 <semantics>
  <mrow>
   <mi>w</mi>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <ci>w</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w,
  </annotation>
 </semantics>
</math>

 we set 

<math display="inline" id="Top_tree:157">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒞</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒞</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{C}
  </annotation>
 </semantics>
</math>

 := Expose

<math display="inline" id="Top_tree:158">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>v</mi>
   <mo>,</mo>
   <mi>w</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>v</ci>
    <ci>w</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (v,w)
  </annotation>
 </semantics>
</math>

 and return max_wt(

<math display="inline" id="Top_tree:159">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒞</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒞</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{C}
  </annotation>
 </semantics>
</math>

).</li>
</ul></li>
</ul>
<ul>
<li>([GOLDBERG ET AL. 1991]). We can ask for the maximum weight in the underlying tree containing a given vertex 

<math display="inline" id="Top_tree:160">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>

 in 

<math display="inline" id="Top_tree:161">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">𝒪</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>log</mi>
     <mi>n</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>𝒪</ci>
    <apply>
     <log></log>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{O}(\log n)
  </annotation>
 </semantics>
</math>

 time.
<ul>
<li>Proof outline: This requires maintaining additional information about the maximum weight non cluster path edge in a cluster under the Merge and Split operations.</li>
</ul></li>
</ul>
<ul>
<li>The distance between two vertices 

<math display="inline" id="Top_tree:162">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Top_tree:163">
 <semantics>
  <mi>w</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>w</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w
  </annotation>
 </semantics>
</math>

 can be found in 

<math display="inline" id="Top_tree:164">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">𝒪</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>log</mi>
     <mi>n</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>𝒪</ci>
    <apply>
     <log></log>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{O}(\log n)
  </annotation>
 </semantics>
</math>

 time as length(Expose

<math display="inline" id="Top_tree:165">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>v</mi>
   <mo>,</mo>
   <mi>w</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>v</ci>
    <ci>w</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (v,w)
  </annotation>
 </semantics>
</math>

).
<ul>
<li>Proof outline:We will maintain the length length(

<math display="inline" id="Top_tree:166">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒞</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒞</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{C}
  </annotation>
 </semantics>
</math>

) of the cluster path. The length is maintained as the maximum weight except that, if 

<math display="inline" id="Top_tree:167">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒞</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒞</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{C}
  </annotation>
 </semantics>
</math>

 is created by a join(Merge), length(

<math display="inline" id="Top_tree:168">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒞</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒞</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{C}
  </annotation>
 </semantics>
</math>

) is the sum of lengths stored with its path children.</li>
</ul></li>
</ul>
<ul>
<li>Queries regarding diameter of a tree and its subsequent maintenance takes 

<math display="inline" id="Top_tree:169">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">𝒪</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>log</mi>
     <mi>n</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>𝒪</ci>
    <apply>
     <log></log>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{O}(\log n)
  </annotation>
 </semantics>
</math>

 time.</li>
</ul>
<ul>
<li>The Center and Median can me maintained under Link(Merge) and Cut(Split) operations and queried by non local search in 

<math display="inline" id="Top_tree:170">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">𝒪</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>log</mi>
     <mi>n</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>𝒪</ci>
    <apply>
     <log></log>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{O}(\log n)
  </annotation>
 </semantics>
</math>

 time.</li>
</ul>
<ul>
<li>The graph could be maintained allowing to update the edge set and ask queries on edge 2-connectivity. Amortized complexity of updates is 

<math display="inline" id="Top_tree:171">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msup>
      <mi>log</mi>
      <mn>4</mn>
     </msup>
     <mi>n</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <log></log>
      <cn type="integer">4</cn>
     </apply>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(\log^{4}n)
  </annotation>
 </semantics>
</math>

. Queries could be implemented even faster. The algorithm is not trivial, 

<math display="inline" id="Top_tree:172">
 <semantics>
  <mrow>
   <mi>I</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi class="ltx_font_mathcaligraphic">𝒞</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>I</ci>
    <ci>𝒞</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I(\mathcal{C})
  </annotation>
 </semantics>
</math>

 uses 

<math display="inline" id="Top_tree:173">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Θ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msup>
      <mi>log</mi>
      <mn>2</mn>
     </msup>
     <mi>n</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Θ</ci>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <log></log>
      <cn type="integer">2</cn>
     </apply>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Theta(\log^{2}n)
  </annotation>
 </semantics>
</math>

 space ([HOLM, LICHTENBERG, THORUP 2000]).</li>
</ul>
<ul>
<li>The graph could be maintained allowing to update the edge set and ask queries on vertex 2-connectivity. Amortized complexity of updates is 

<math display="inline" id="Top_tree:174">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msup>
      <mi>log</mi>
      <mn>5</mn>
     </msup>
     <mi>n</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <log></log>
      <cn type="integer">5</cn>
     </apply>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(\log^{5}n)
  </annotation>
 </semantics>
</math>

. Queries could be implemented even faster. The algorithm is not trivial, 

<math display="inline" id="Top_tree:175">
 <semantics>
  <mrow>
   <mi>I</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi class="ltx_font_mathcaligraphic">𝒞</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>I</ci>
    <ci>𝒞</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I(\mathcal{C})
  </annotation>
 </semantics>
</math>

 uses 

<math display="inline" id="Top_tree:176">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Θ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msup>
      <mi>log</mi>
      <mn>2</mn>
     </msup>
     <mi>n</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Θ</ci>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <log></log>
      <cn type="integer">2</cn>
     </apply>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Theta(\log^{2}n)
  </annotation>
 </semantics>
</math>

 space ([HOLM, LICHTENBERG, THORUP 2001]).</li>
</ul>
<ul>
<li>Top trees can be used to compress trees in a way that is never much worse than <a href="Directed_acyclic_graph" title="wikilink">DAG</a> compression, but may be exponentially better. <a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></li>
</ul>
<h2 id="implementation">Implementation</h2>

<p>Top trees have been implemented in a variety of ways, some of them include implementation using a <em>Multilevel Partition</em> (Top-trees and dynamic graph algorithms Jacob Holm and Kristian de Lichtenberg. Technical Report), and even by using <a href="Sleator-Tarjan_s-t_trees" title="wikilink">Sleator-Tarjan s-t trees</a> (typically with amortized time bounds), <a href="Frederickson's_Topology_Trees" title="wikilink">Frederickson's Topology Trees</a> (with worst case time bounds) (Alstrup et al. Maintaining Information in Fully Dynamic Trees with Top Trees).</p>

<p>Amortized implementations are more simple, and with small multiplicative factors in time complexity. On the contrary the worst case implementations allow speeding up queries by switching off unneeded info updates during the query (implemented by <a href="persistent_data_structure" title="wikilink">persistence</a> techniques). After the query is answered the original state of the top tree is used and the query version is discarded.</p>
<h3 id="using-multilevel-partitioning">Using Multilevel Partitioning</h3>

<p>Any partitioning of clusters of a tree 

<math display="inline" id="Top_tree:177">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒯</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒯</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{T}
  </annotation>
 </semantics>
</math>

 can be represented by a Cluster Partition Tree CPT

<math display="inline" id="Top_tree:178">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi class="ltx_font_mathcaligraphic">𝒯</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒯</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\mathcal{T}),
  </annotation>
 </semantics>
</math>

 by replacing each cluster in the tree 

<math display="inline" id="Top_tree:179">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒯</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒯</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{T}
  </annotation>
 </semantics>
</math>

 by an edge. If we use a strategy P for partitioning 

<math display="inline" id="Top_tree:180">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒯</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒯</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{T}
  </annotation>
 </semantics>
</math>

 then the CPT would be CPT<sub>P</sub>

<math display="inline" id="Top_tree:181">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">𝒯</mi>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒯</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{T}.
  </annotation>
 </semantics>
</math>

 This is done recursively till only one edge remains.</p>

<p>We would notice that all the nodes of the corresponding top tree 

<math display="inline" id="Top_tree:182">
 <semantics>
  <mi mathvariant="normal">ℜ</mi>
  <annotation-xml encoding="MathML-Content">
   <real></real>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Re
  </annotation>
 </semantics>
</math>

 are uniquely mapped into the edges of this multilevel partition. There may be some edges in the multilevel partition that do not correspond to any node in the top tree, these are the edges which represent only a single child in the level below it, i.e. a simple cluster. Only the edges that correspond to composite clusters correspond to nodes in the top tree 

<math display="inline" id="Top_tree:183">
 <semantics>
  <mrow>
   <mi mathvariant="normal">ℜ</mi>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <real></real>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Re.
  </annotation>
 </semantics>
</math>

</p>

<p>A partitioning strategy is important while we partition the Tree 

<math display="inline" id="Top_tree:184">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒯</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒯</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{T}
  </annotation>
 </semantics>
</math>

 into clusters. Only a careful strategy ensures that we end up in an 

<math display="inline" id="Top_tree:185">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">𝒪</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>log</mi>
     <mi>n</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>𝒪</ci>
    <apply>
     <log></log>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{O}(\log n)
  </annotation>
 </semantics>
</math>

 height Multilevel Partition ( and therefore the top tree).</p>
<ul>
<li>The number of edges in subsequent levels should decrease by a constant factor.</li>
<li>If a lower level is changed by an update then we should be able to update the one immediately above it using at most a constant number of insertions and deletions.</li>
</ul>

<p>The above partitioning strategy ensures the maintenance of the top tree in 

<math display="inline" id="Top_tree:186">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">𝒪</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>log</mi>
     <mi>n</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>𝒪</ci>
    <apply>
     <log></log>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{O}(\log n)
  </annotation>
 </semantics>
</math>

 time.</p>
<h2 id="references">References</h2>
<ul>
<li>Stephen Alstrup, Jacob Holm, Kristian De Lichtenberg, and <a href="Mikkel_Thorup" title="wikilink">Mikkel Thorup</a>, <em>Maintaining information in fully dynamic trees with top trees</em>, ACM Transactions on Algorithms (TALG), Vol. 1 (2005), 243–264, </li>
<li>Stephen Alstrup, Jacob Holm, Kristian De Lichtenberg, and <a href="Mikkel_Thorup" title="wikilink">Mikkel Thorup</a>, <em>Poly-logarithmic deterministic dynamic algorithms for connectivity, minimum spanning tree, 2-edge, and biconnectivity</em>, Journal of the ACM (JACM), Vol. 48 Issue 4(July 2001), 723–760, </li>
<li><a href="Donald_Knuth" title="wikilink">Donald Knuth</a>. <em>The Art of Computer Programming: Fundamental Algorithms</em>, Third Edition. Addison-Wesley, 1997. ISBN 0-201-89683-4 . Section 2.3: Trees, pp. 308–423.</li>
<li><a href="Thomas_H._Cormen" title="wikilink">Thomas H. Cormen</a>, <a href="Charles_E._Leiserson" title="wikilink">Charles E. Leiserson</a>, <a href="Ronald_L._Rivest" title="wikilink">Ronald L. Rivest</a>, and <a href="Clifford_Stein" title="wikilink">Clifford Stein</a>. <em><a href="Introduction_to_Algorithms" title="wikilink">Introduction to Algorithms</a></em>, Second Edition. MIT Press and McGraw-Hill, 2001. ISBN 0-262-03293-7 . Section 10.4: Representing rooted trees, pp. 214–217. Chapters 12–14 (Binary Search Trees, Red-Black Trees, Augmenting Data Structures), pp. 253–320.</li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://arxiv.org/abs/cs.DS/0310065">Maintaining Information in Fully Dynamic Trees with Top Trees. Alstrup et al</a></li>
<li>[<a class="uri" href="http://portal.acm.org/citation.cfm?id=1070547&amp;dl">http://portal.acm.org/citation.cfm?id=1070547&amp;dl;</a>;=&amp;coll;=&amp;CFID;=15151515&amp;CFTOKEN;=6184618 Self-Adjusting Top Trees. Tarjan and Werneck, Proc. 16th SoDA, 2005]</li>
</ul>

<p>"</p>

<p><a href="Category:Binary_trees" title="wikilink">Category:Binary trees</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Tree Compression with Top Trees. BILLE, GOERTZ, LANDAU, WEIMANN 2013 arXiv:1304.5702 [cs.DS]<a href="#fnref1">↩</a></li>
</ol>
</section>
</body>
</html>
