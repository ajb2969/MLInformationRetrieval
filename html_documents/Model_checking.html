<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="32">Model checking</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Model checking</h1>
<hr/>

<p>In <a href="computer_science" title="wikilink">computer science</a>, <strong>model checking</strong> or <strong>property checking</strong> refers to the following problem: Given a model of a system, exhaustively and automatically check whether this model meets a given specification. Typically, one has hardware or software systems in mind, whereas the specification contains safety requirements such as the absence of <a href="deadlock" title="wikilink">deadlocks</a> and similar critical states that can cause the system to <a href="Crash_(computing)" title="wikilink">crash</a>. Model checking is a technique for automatically verifying correctness properties of <em>finite-state</em> systems.</p>

<p>In order to solve such a problem <a href="algorithm" title="wikilink">algorithmically</a>, both the model of the system and the specification are formulated in some precise mathematical language: To this end, it is formulated as a task in <a class="uri" href="logic" title="wikilink">logic</a>, namely to check whether a given <a href="structure_(mathematical_logic)" title="wikilink">structure</a> satisfies a given logical formula. The concept is general and applies to all kinds of logics and suitable structures. A simple model-checking problem is verifying whether a given formula in the <a href="Propositional_calculus" title="wikilink">propositional logic</a> is satisfied by a given structure.</p>
<h2 id="overview">Overview</h2>

<p>Property checking is used for <a href="Software_verification" title="wikilink">verification</a> instead of <a href="equivalence_checking" title="wikilink">equivalence checking</a> when two descriptions are not functionally equivalent. Particularly, during <a href="Refinement_(computing)" title="wikilink">refinement</a>, the specification is complemented with the details that are <a href="don't_care" title="wikilink">unnecessary</a> in the higher level specification. Yet, there is no need to verify the newly introduced properties against the original specification. It is not even possible. Therefore, the strict bi-directional equivalence check is relaxed to one-way property checking. The implementation or design is regarded a model of the circuit whereas the specifications are properties that the model must satisfy.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>

<p>An important class of model checking methods have been developed for checking models of <a href="computer_hardware" title="wikilink">hardware</a> and <a class="uri" href="software" title="wikilink">software</a> designs where the specification is given by a <a href="temporal_logic" title="wikilink">temporal logic</a> formula. Pioneering work in the model checking of temporal logic formulae was done by <a href="Amir_Pnueli" title="wikilink">Amir Pnueli</a>, who received the 1996 Turing award for "[...] seminal work introducing temporal logic into computing science",<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> and by <a href="E._M._Clarke" title="wikilink">E. M. Clarke</a> and <a href="E._A._Emerson" title="wikilink">E. A. Emerson</a><a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a><a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a><a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> and by J. P. Queille and <a href="J._Sifakis" title="wikilink">J. Sifakis</a>.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> Clarke, Emerson, and Sifakis shared the 2007 <a href="Turing_Award" title="wikilink">Turing Award</a> for their work on model checking.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a><a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></p>

<p>Model checking is most often applied to hardware designs. For software, because of undecidability (see <a href="Computability_theory_(computer_science)" title="wikilink">computability theory</a>) the approach cannot be fully algorithmic; typically it may fail to prove or disprove a given property. In embedded systems hardware designs it is possible to validate (verify against some specified requirements) a specification delivered i.e. by means of UML activity diagrams<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> or control interpreted Petri nets.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a></p>

<p>The structure is usually given as a source code description in an industrial <a href="hardware_description_language" title="wikilink">hardware description language</a> or a special-purpose language. Such a program corresponds to a <a href="finite_state_machine" title="wikilink">finite state machine</a> (FSM), i.e., a <a href="directed_graph" title="wikilink">directed graph</a> consisting of nodes (or <a href="vertex_(graph_theory)" title="wikilink">vertices</a>) and <a href="edge_(graph_theory)" title="wikilink">edges</a>. A set of atomic propositions is associated with each node, typically stating which memory elements are one. The <a href="Node_(computer_science)" title="wikilink">nodes</a> represent states of a system, the edges represent possible transitions which may alter the state, while the atomic propositions represent the basic properties that hold at a point of execution.</p>

<p>Formally, the problem can be stated as follows: given a desired property, expressed as a temporal logic formula <em>p</em>, and a structure <em>M</em> with initial state <em>s</em>, decide if 

<math display="inline" id="Model_checking:0">
 <semantics>
  <mrow>
   <mrow>
    <mi>M</mi>
    <mo>,</mo>
    <mi>s</mi>
   </mrow>
   <mo>⊧</mo>
   <mi>p</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">models</csymbol>
    <list>
     <ci>M</ci>
     <ci>s</ci>
    </list>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M,s\models p
  </annotation>
 </semantics>
</math>

. If M is finite, as it is in hardware, model checking reduces to a graph search.</p>
<h2 id="algorithms">Algorithms</h2>

<p><a href="state_space_enumeration" title="wikilink">state space enumeration</a>, <a href="symbolic_state_space_enumeration" title="wikilink">symbolic state space enumeration</a>, <a href="abstract_interpretation" title="wikilink">abstract interpretation</a>, <a href="symbolic_simulation" title="wikilink">symbolic simulation</a>, <a href="symbolic_trajectory_evaluation" title="wikilink">symbolic trajectory evaluation</a>, <a href="symbolic_execution" title="wikilink">symbolic execution</a></p>
<h3 id="explicit-state-model-checking">Explicit-state model checking</h3>
<h3 id="symbolic-model-checking">Symbolic model checking</h3>

<p>Instead of enumerating reachable states one at a time, the state space can sometimes be traversed much more efficiently by considering large numbers of states at a single step. When such state space traversal is based on representations of states sets and transition relations as formulas, binary decision diagrams or other related data structures, the model-checking method is symbolic.</p>

<p>Historically, the first symbolic methods used <a href="Binary_decision_diagram" title="wikilink">BDDs</a>. After the success of <a href="propositional_satisfiability" title="wikilink">propositional satisfiability</a> in solving the <a href="automated_planning_and_scheduling" title="wikilink">planning</a> problem in <a href="artificial_intelligence" title="wikilink">artificial intelligence</a> (see <a class="uri" href="satplan" title="wikilink">satplan</a>) in 1996, the same approach was generalized to model-checking for the <a href="Linear_Temporal_Logic" title="wikilink">Linear Temporal Logic</a> LTL (the planning problem corresponds to model-checking for safety properties). This method is known as <a href="bounded_model-checking" title="wikilink">bounded model-checking</a>.</p>
<h2 id="tools">Tools</h2>

<p>Model checking tools face a combinatorial blow up of the state-space, commonly known as the <a href="state_explosion_problem" title="wikilink">state explosion problem</a>, that must be addressed to solve most real-world problems. There are several approaches to combat this problem.</p>
<ol>
<li>Symbolic algorithms avoid ever building the graph for the FSM; instead, they represent the graph implicitly using a formula in quantified propositional logic. The use of binary decision diagrams (BDDs) was made popular by the work of Ken McMillan.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a></li>
<li>Bounded model checking algorithms unroll the FSM for a fixed number of steps 

<math display="inline" id="Model_checking:1">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 and check whether a property violation can occur in 

<math display="inline" id="Model_checking:2">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 or fewer steps. This typically involves encoding the restricted model as an instance of <a href="Boolean_satisfiability_problem" title="wikilink">SAT</a>. The process can be repeated with larger and larger values of 

<math display="inline" id="Model_checking:3">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 until all possible violations have been ruled out (cf. <a href="Iterative_deepening_depth-first_search" title="wikilink">Iterative deepening depth-first search</a>).</li>
<li><a href="Partial_order_reduction" title="wikilink">Partial order reduction</a> can be used (on explicitly represented graphs) to reduce the number of independent interleavings of concurrent processes that need to be considered. The basic idea is that if it does not matter, for the kind of things one intends to prove, whether A or B is executed first, then it is a waste of time to consider both the AB and the BA interleavings.</li>
<li><a href="abstract_interpretation" title="wikilink">Abstraction</a> attempts to prove properties on a system by first simplifying it. The simplified system usually does not satisfy exactly the same properties as the original one so that a process of refinement may be necessary. Generally, one requires the abstraction to be <em>sound</em> (the properties proved on the abstraction are true of the original system); however, most often, the abstraction is not <em>complete</em> (not all true properties of the original system are true of the abstraction). An example of abstraction is, on a program, to ignore the values of non boolean variables and to only consider boolean variables and the control flow of the program; such an abstraction, though it may appear coarse, may in fact be sufficient to prove e.g. properties of <a href="mutual_exclusion" title="wikilink">mutual exclusion</a>.</li>
<li>Counterexample guided abstraction refinement (CEGAR) begins checking with a coarse (imprecise) abstraction and iteratively refines it. When a violation (<a class="uri" href="counterexample" title="wikilink">counterexample</a>) is found, the tool analyzes it for feasibility (i.e., is the violation genuine or the result of an incomplete abstraction?). If the violation is feasible, it is reported to the user; if it is not, the proof of infeasibility is used to refine the abstraction and checking begins again.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a></li>
</ol>

<p>Model checking tools were initially developed to reason about the logical correctness of <a href="Discrete_system" title="wikilink">discrete state</a> systems, but have since been extended to deal with real-time and limited forms of <a href="hybrid_system" title="wikilink">hybrid systems</a>.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Binary_decision_diagram" title="wikilink">Binary decision diagram</a></li>
<li><a href="Büchi_automaton" title="wikilink">Büchi automaton</a></li>
<li><a href="Computation_tree_logic" title="wikilink">Computation tree logic</a></li>
<li><a href="Formal_verification" title="wikilink">Formal verification</a></li>
<li><a href="Linear_temporal_logic" title="wikilink">Linear temporal logic</a></li>
<li><a href="Partial_order_reduction" title="wikilink">Partial order reduction</a></li>
</ul>
<h2 id="tools-1">Tools</h2>

<p>For a categorized list of tools see <a href="List_of_model_checking_tools" title="wikilink">here</a>.</p>
<ul>
<li><a href="Algebraic_Petri_Nets_Analyzer" title="wikilink">AlPiNA</a>,<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> AlPiNA stands for Algebraic Petri Nets Analyzer and is a model checker for Algebraic Petri Nets.</li>
<li><a href="BLAST_model_checker" title="wikilink">BLAST</a></li>
<li><a class="uri" href="CADP" title="wikilink">CADP</a> (Construction and Analysis of Distributed Processes) a toolbox for the design of communication protocols and distributed systems</li>
<li><a href="CHESS_model_checker" title="wikilink">CHESS</a></li>
<li><a href="CHIC_(electronics)" title="wikilink">CHIC</a></li>
<li><a class="uri" href="CPAchecker" title="wikilink">CPAchecker</a>, an open-source software model checker for C programs, based on the CPA framework</li>
<li><a class="uri" href="CTML" title="wikilink">CTML</a> (Computation Tree Measurement Language), a quantitative evaluation tool that covers PCTL and some PLTL that can't be expressed in PCTL.</li>
<li><a class="uri" href="ECLAIR" title="wikilink">ECLAIR</a>, a platform for the automatic analysis, verification, testing and transformation of C and C++ programs</li>
<li><a class="uri" href="FDR2" title="wikilink">FDR2</a>, a model checker for verifying real-time systems modeled and specified as <a href="Communicating_sequential_processes" title="wikilink">CSP</a> Processes</li>
<li><a href="ISP_Formal_Verification_Tool" title="wikilink">ISP</a> code level verifier for <a href="Message_Passing_Interface" title="wikilink">MPI</a> programs</li>
<li><a href="Java_Pathfinder" title="wikilink">Java Pathfinder</a> - open source model checker for Java programs</li>
<li><a href="http://www.doc.ic.ac.uk/ltsa/">LTSA</a> - Labelled Transition System Analyser</li>
<li><a class="uri" href="LTSmin" title="wikilink">LTSmin</a> - open source model checker for various specification languages (<a class="uri" href="Promela" title="wikilink">Promela</a>, <a class="uri" href="mCRL2" title="wikilink">mCRL2</a>, <a href="Uppaal_Model_Checker" title="wikilink">UPPAAL</a> language)</li>
<li><a href="Markov_Reward_Model_Checker_(MRMC)" title="wikilink">Markov Reward Model Checker (MRMC)</a></li>
<li><a href="http://babel.ls.fi.upm.es/~fred/McErlang/">McErlang</a>, a model checker for Erlang programs which can be distributed and fault-tolerant.</li>
<li><a class="uri" href="mCRL2" title="wikilink">mCRL2</a> Toolset, <a href="Boost_Software_License" title="wikilink">Boost Software License</a>, Based on <a href="Algebra_of_Communicating_Processes" title="wikilink">ACP</a></li>
<li><a href="http://fmt.cs.utwente.nl/tools/moonwalker">MoonWalker</a> - open source model checker for .NET programs</li>
<li><a class="uri" href="NuSMV" title="wikilink">NuSMV</a>, a new symbolic model checker</li>
<li><a href="https://sourceforge.net/projects/redlib/">ompca</a>, an interactive symbolic simulator with API control for C/C++ programs with OpenMP directives. The tool is built as an application of REDLIB.</li>
<li><a href="PAT_(model_checker)" title="wikilink">PAT</a> - an enhanced simulator, model checker and refinement checker for concurrent and real-time systems</li>
<li><a href="PRISM_(model_checker)" title="wikilink">Prism</a>, a probabilistic symbolic model checker</li>
<li><a href="Rabbit_Model_Checker" title="wikilink">Rabbit</a>, a model checker for timed and hybrid automata</li>
<li><a href="https://sourceforge.net/projects/redlib/">REDLIB</a>, library for the model-checking of communicating timed automatas with BDD-like diagrams. Applications include a TCTL model-checker with timed fairness quantifications, fair simulation checker, and interactive symbolic simulator for C/C++ programs with OpenMP directives. GUI for model editing and symbolic simulation are also available.</li>
<li><a href="Romeo_Model_Checker" title="wikilink">Roméo</a>, an integrated tool environment for modeling, simulation and verification of real-time systems modeled as parametric, time and stopwatch Petri nets</li>
<li><a href="http://www.cs.ucr.edu/~ciardo/SMART/">SMART Model checker</a>, Symbolic Model checking Analyzer for Reliability and Timing</li>
<li><a href="SPIN_model_checker" title="wikilink">SPIN</a> a general tool for verifying the correctness of distributed software models in a rigorous and mostly automated fashion.</li>
<li><a href="http://spot.lip6.fr/">Spot</a> a library to implement the automata-theoretic approach for model checking. Has good translation of <a href="Linear_temporal_logic" title="wikilink">LTL</a> into Büchi automata and also support the linear fragment of <a href="Property_Specification_Language" title="wikilink">PSL</a>. Must be interfaced with custom code that develop the state-space on-the-fly.</li>
<li><a href="TAPAs_model_checker" title="wikilink">TAPAs</a>: tool for the analysis of process algebra.</li>
<li><a href="TAPAAL_Model_Checker" title="wikilink">TAPAAL</a>, an integrated tool environment for modeling, validation and verification of Timed-Arc <a href="Petri_Nets" title="wikilink">Petri Nets</a></li>
<li><a class="uri" href="TLA+" title="wikilink">TLA+</a> model checker by <a href="Leslie_Lamport" title="wikilink">Leslie Lamport</a></li>
<li><a href="Uppaal_Model_Checker" title="wikilink">UPPAAL</a>, an integrated tool environment for modeling, validation and verification of real-time systems modeled as networks of timed automata</li>
<li><a class="uri" href="Vereofy" title="wikilink">Vereofy</a>,<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a> a software model checker for component-based systems for operational correctness</li>
<li><a href="http://homepages.cwi.nl/~mcrl/">μCRL</a>, <a href="GNU_General_Public_License" title="wikilink">GPL</a>, Based on <a href="Algebra_of_Communicating_Processes" title="wikilink">ACP</a></li>
</ul>
<dl>
<dt>Related techniques</dt>
</dl>
<ul>
<li><a href="Abstract_interpretation" title="wikilink">Abstract interpretation</a></li>
<li><a href="Automated_theorem_proving" title="wikilink">Automated theorem proving</a></li>
<li><a href="List_of_model_checking_tools" title="wikilink">Model checking tools</a></li>
<li><a href="Program_analysis_(computer_science)" title="wikilink">Program analysis (computer science)</a></li>
<li><a href="Static_code_analysis" title="wikilink">Static code analysis</a></li>
</ul>
<dl>
<dt>History</dt>
</dl>
<ul>
<li><a href="Edmund_M._Clarke" title="wikilink">E.M. Clarke</a>: <a href="http://www.springerlink.com/content/j335v4472745r366/"><em>The birth of model checking</em></a></li>
<li><a href="E._Allen_Emerson" title="wikilink">E. Allen Emerson</a>: <a href="http://www.model.in.tum.de/um/25/pdf/Emerson.pdf"><em>The Beginning of Model Checking: A Personal Perspective</em></a> (this is also a very good introduction and overview of model checking)</li>
<li>[<a class="uri" href="http://mrw.interscience.wiley.com/emrw/9780470050118/ecse/article/ecse247/current/abstract">http://mrw.interscience.wiley.com/emrw/9780470050118/ecse/article/ecse247/current/abstract</a><em>Model Checking</em>], Doron Peled, Patrizio Pelliccione, Paola Spoletini, Wiley Encyclopedia of Computer Science and Engineering, 2009.</li>
</ul>
<h2 id="references">References</h2>
<h2 id="further-reading">Further reading</h2>
<ul>
<li>[<a class="uri" href="http://mrw.interscience.wiley.com/emrw/9780470050118/ecse/article/ecse247/current/abstract">http://mrw.interscience.wiley.com/emrw/9780470050118/ecse/article/ecse247/current/abstract</a><em>Model Checking</em>], Doron Peled, Patrizio Pelliccione, Paola Spoletini, Wiley Encyclopedia of Computer Science and Engineering, 2009.</li>
<li><em>Model Checking</em>, Edmund M. Clarke, Jr., <a href="Orna_Grumberg" title="wikilink">Orna Grumberg</a> and Doron A. Peled, <a href="MIT_Press" title="wikilink">MIT Press</a>, 1999, ISBN 0-262-03270-8.</li>
<li><em>Systems and Software Verification: Model-Checking Techniques and Tools</em>, B. Berard, M. Bidoit, A. Finkel, F. Laroussinie, A. Petit, L. Petrucci, P. Schnoebelen, ISBN 3-540-41523-8</li>
<li><em>Logic in Computer Science: Modelling and Reasoning About Systems</em>, Michael Huth and Mark Ryan, <a href="Cambridge_University_Press" title="wikilink">Cambridge University Press</a>, 2004. <a href="http://dx.doi.org/10.2277/052154310X">DOI DOI/org</a>.</li>
<li><a href="http://spinroot.com/spin/Doc/Book_extras/"><em>The Spin Model Checker: Primer and Reference Manual</em></a>, <a href="Gerard_J._Holzmann" title="wikilink">Gerard J. Holzmann</a>, Addison-Wesley, ISBN 0-321-22862-6.</li>
<li>Julian Bradfield and Colin Stirling, Modal logics and mu-calculi, <a href="http://homepages.inf.ed.ac.uk/jcb/Research/bradfield-stirling-HPA-mu-intro.ps.gz">Inf.ed.ac.uk</a></li>
<li>Specification Patterns <a href="http://patterns.projects.cis.ksu.edu/documentation/patterns.shtml">KSU.edu</a></li>
<li>Property Pattern Mappings for RAFMC <a href="http://cadp.inria.fr/resources/evaluator/rafmc.html">Inria.fr</a></li>
<li>Radu Mateescu and Mihaela Sighireanu <a href="http://vasy.inria.fr/publications/Mateescu-Sighireanu-03.html">Efficient On-the-Fly Model-Checking for Regular Alternation-Free Mu-Calculus</a>, page 6, Science of Computer Programming 46(3):255-281, 2003</li>
<li>Müller-Olm, M., Schmidt, D.A. and <a href="Bernhard_Steffen_(computer_scientist)" title="wikilink">Steffen, B.</a> <a href="http://people.cis.ksu.edu/~schmidt/papers/sas99.ps.gz"><em>Model checking: a tutorial introduction.</em></a> Proc. 6th Static Analysis Symposium, G. File and A. Cortesi, eds., Springer LNCS 1694, 1999, pp. 330–354.</li>
<li>Baier, C., Katoen, J.: Principles of Model Checking. 2008.</li>
</ul>

<p>"</p>

<p><a href="Category:Model_checking" title="wikilink"> </a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a class="uri" href="http://amturing.acm.org/award_winners/pnueli_4725172.cfm/">http://amturing.acm.org/award_winners/pnueli_4725172.cfm/</a><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4">Edmund M. Clarke, E. Allen Emerson: [<a class="uri" href="http://portal.acm.org/citation.cfm?id=747438&amp;dl">http://portal.acm.org/citation.cfm?id=747438&amp;dl;</a>;= "Design and Synthesis of Synchronization Skeletons Using Branching-Time Temporal Logic"]. Logic of Programs 1981: 52-71.<a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"><a href="http://www.acm.org/press-room/news-releases/turing-award-07/">Press Release: ACM Turing Award Honors Founders of Automatic Verification Technology</a><a href="#fnref7">↩</a></li>
<li id="fn8"><a href="http://usacm.acm.org/usacm/weblog/index.php?p=572"><em>USACM</em>: 2007 Turing Award Winners Announced</a><a href="#fnref8">↩</a></li>
<li id="fn9">I. Grobelna, M. Grobelny, M. Adamski, "Model Checking of UML Activity Diagrams in Logic Controllers Design", Proceedings of the Ninth International Conference on Dependability and Complex Systems DepCoS-RELCOMEX, Advances in Intelligent Systems and Computing Volume 286, Springer International Publishing Switzerland, pp. 233-242, 2014<a href="#fnref9">↩</a></li>
<li id="fn10">I. Grobelna, "Formal verification of embedded logic controller specification with computer deduction in temporal logic", Przeglad Elektrotechniczny, Vol.87, Issue 12a, pp.47-50, 2011<a href="#fnref10">↩</a></li>
<li id="fn11">* <em>Symbolic Model Checking</em>, Kenneth L. McMillan, Kluwer, ISBN 0-7923-9380-5, <a href="http://www.kenmcmil.com/thesis.html">also online</a>.<a href="#fnref11">↩</a></li>
<li id="fn12"><a href="#fnref12">↩</a></li>
<li id="fn13"><a href="http://alpina.unige.ch">alpina.unige.ch</a><a href="#fnref13">↩</a></li>
<li id="fn14"><a href="http://www.vereofy.de">Vereofy.de</a><a href="#fnref14">↩</a></li>
</ol>
</section>
</body>
</html>
