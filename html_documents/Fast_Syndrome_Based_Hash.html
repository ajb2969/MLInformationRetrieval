<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1430">Fast Syndrome Based Hash</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Fast Syndrome Based Hash</h1>
<hr/>

<p>In <a class="uri" href="cryptography" title="wikilink">cryptography</a>, the <strong>Fast Syndrome-based hash Functions (FSB)</strong> are a family of <a href="cryptographic_hash_functions" title="wikilink">cryptographic hash functions</a> introduced in 2003 by Daniel Augot, Matthieu Finiasz, and Nicolas Sendrier. <a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> Unlike most other cryptographic hash functions in use today, FSB can to a certain extent be proven to be secure. More exactly, it can be proven that breaking FSB is at least as difficult as solving a certain <a class="uri" href="NP-complete" title="wikilink">NP-complete</a> problem known as <strong>Regular Syndrome Decoding</strong> so FSB is <a href="Provably_secure_cryptographic_hash_function" title="wikilink">provably secure</a>. Though it is not known whether <a class="uri" href="NP-complete" title="wikilink">NP-complete</a> problems are solvable in <a href="polynomial_time" title="wikilink">polynomial time</a>, it is often assumed that they are not.</p>

<p>Several versions of FSB have been proposed, the latest of which was submitted to the <a href="NIST_hash_function_competition" title="wikilink">SHA-3 cryptography competition</a> but was rejected in the first round. Though all versions of FSB claim provable security, some preliminary versions were eventually broken. <a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> The design of the latest version of FSB has however taken this attack into account and remains secure to all currently known attacks.</p>

<p>As usual, provable security comes at a cost. FSB is slower than traditional hash functions and uses quite a lot of memory, which makes it impractical on memory constrained environments. Furthermore, the compression function used in FSB needs a large output size to guarantee security. This last problem has been solved in recent versions by simply compressing the output by another compression function called <a href="Whirlpool_(cryptography)" title="wikilink">Whirlpool</a>. However, though the authors argue that adding this last compression does not reduce security, it makes a formal security proof impossible. <a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>
<h2 id="description-of-the-hash-function">Description of the hash function</h2>

<p>We start with a compression function 

<math display="inline" id="Fast_Syndrome_Based_Hash:0">
 <semantics>
  <mi>ϕ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϕ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi
  </annotation>
 </semantics>
</math>

 with parameters 

<math display="inline" id="Fast_Syndrome_Based_Hash:1">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>,</mo>
   <mi>r</mi>
   <mo>,</mo>
   <mi>w</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>n</ci>
    <ci>r</ci>
    <ci>w</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {n,r,w}
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Fast_Syndrome_Based_Hash:2">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>></mo>
   <mi>w</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <ci>n</ci>
    <ci>w</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n>w
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Fast_Syndrome_Based_Hash:3">
 <semantics>
  <mrow>
   <mrow>
    <mi>w</mi>
    <mrow>
     <mi>log</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>n</mi>
       <mo>/</mo>
       <mi>w</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>></mo>
   <mi>r</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <apply>
     <times></times>
     <ci>w</ci>
     <apply>
      <log></log>
      <apply>
       <divide></divide>
       <ci>n</ci>
       <ci>w</ci>
      </apply>
     </apply>
    </apply>
    <ci>r</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w\log(n/w)>r
  </annotation>
 </semantics>
</math>

. This function will only work on messages with length 

<math display="inline" id="Fast_Syndrome_Based_Hash:4">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mo>=</mo>
   <mrow>
    <mi>w</mi>
    <mrow>
     <mi>log</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>n</mi>
       <mo>/</mo>
       <mi>w</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>s</ci>
    <apply>
     <times></times>
     <ci>w</ci>
     <apply>
      <log></log>
      <apply>
       <divide></divide>
       <ci>n</ci>
       <ci>w</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s=w\log(n/w)
  </annotation>
 </semantics>
</math>

; 

<math display="inline" id="Fast_Syndrome_Based_Hash:5">
 <semantics>
  <mi>r</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>r</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r
  </annotation>
 </semantics>
</math>

 will be the size of the output. Furthermore, we want 

<math display="inline" id="Fast_Syndrome_Based_Hash:6">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>,</mo>
   <mi>r</mi>
   <mo>,</mo>
   <mi>w</mi>
   <mo>,</mo>
   <mi>s</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>n</ci>
    <ci>r</ci>
    <ci>w</ci>
    <ci>s</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n,r,w,s
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Fast_Syndrome_Based_Hash:7">
 <semantics>
  <mrow>
   <mi>log</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>n</mi>
     <mo>/</mo>
     <mi>w</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <log></log>
    <apply>
     <divide></divide>
     <ci>n</ci>
     <ci>w</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \log(n/w)
  </annotation>
 </semantics>
</math>

 to be natural numbers, where 

<math display="inline" id="Fast_Syndrome_Based_Hash:8">
 <semantics>
  <mi>log</mi>
  <annotation-xml encoding="MathML-Content">
   <log></log>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \log
  </annotation>
 </semantics>
</math>

 denote the <a href="binary_logarithm" title="wikilink">binary logarithm</a>. The reason for 

<math display="inline" id="Fast_Syndrome_Based_Hash:9">
 <semantics>
  <mrow>
   <mrow>
    <mi>w</mi>
    <mo>⋅</mo>
    <mrow>
     <mi>log</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>n</mi>
       <mo>/</mo>
       <mi>w</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>></mo>
   <mi>r</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <apply>
     <ci>normal-⋅</ci>
     <ci>w</ci>
     <apply>
      <log></log>
      <apply>
       <divide></divide>
       <ci>n</ci>
       <ci>w</ci>
      </apply>
     </apply>
    </apply>
    <ci>r</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w\cdot\log(n/w)>r
  </annotation>
 </semantics>
</math>

 is that we want 

<math display="inline" id="Fast_Syndrome_Based_Hash:10">
 <semantics>
  <mi>ϕ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϕ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi
  </annotation>
 </semantics>
</math>

 to be a compression function, so the input must be larger than the output. We will later use the <a href="Merkle-Damgård_construction" title="wikilink">Merkle-Damgård construction</a> to extend the domain to inputs of arbitrary lengths.</p>

<p>The basis of this function consists of a (randomly chosen) binary 

<math display="inline" id="Fast_Syndrome_Based_Hash:11">
 <semantics>
  <mrow>
   <mi>r</mi>
   <mo>×</mo>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>r</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r\times n
  </annotation>
 </semantics>
</math>

 matrix 

<math display="inline" id="Fast_Syndrome_Based_Hash:12">
 <semantics>
  <mi>H</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>H</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H
  </annotation>
 </semantics>
</math>

 which acts on a message of 

<math display="inline" id="Fast_Syndrome_Based_Hash:13">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 bits by <a href="matrix_multiplication" title="wikilink">matrix multiplication</a>. Here we encode the 

<math display="inline" id="Fast_Syndrome_Based_Hash:14">
 <semantics>
  <mrow>
   <mi>w</mi>
   <mrow>
    <mi>log</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>n</mi>
      <mo>/</mo>
      <mi>w</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>w</ci>
    <apply>
     <log></log>
     <apply>
      <divide></divide>
      <ci>n</ci>
      <ci>w</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w\log(n/w)
  </annotation>
 </semantics>
</math>

-bit message as a vector in 

<math display="inline" id="Fast_Syndrome_Based_Hash:15">
 <semantics>
  <msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>𝐅</mi>
     <mn>2</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi>n</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝐅</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\mathbf{F}_{2})^{n}
  </annotation>
 </semantics>
</math>

, the 

<math display="inline" id="Fast_Syndrome_Based_Hash:16">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

-dimensional <a href="vector_space" title="wikilink">vector space</a> over the <a href="field_(mathematics)" title="wikilink">field</a> of two elements, so the output will be a message of 

<math display="inline" id="Fast_Syndrome_Based_Hash:17">
 <semantics>
  <mi>r</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>r</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r
  </annotation>
 </semantics>
</math>

 bits.</p>

<p>For security purposes as well as to get a faster hash speed we want to use only “regular words of weight 

<math display="inline" id="Fast_Syndrome_Based_Hash:18">
 <semantics>
  <mi>w</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>w</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w
  </annotation>
 </semantics>
</math>

” as input for our matrix.</p>
<h3 id="definitions">Definitions</h3>
<ul>
<li>A message is called a <strong>word of weight 

<math display="inline" id="Fast_Syndrome_Based_Hash:19">
 <semantics>
  <mi>w</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>w</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w
  </annotation>
 </semantics>
</math>

 and length 

<math display="inline" id="Fast_Syndrome_Based_Hash:20">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

</strong> if it consists of 

<math display="inline" id="Fast_Syndrome_Based_Hash:21">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 bits and exactly 

<math display="inline" id="Fast_Syndrome_Based_Hash:22">
 <semantics>
  <mi>w</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>w</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w
  </annotation>
 </semantics>
</math>

 of those bits are ones.</li>
<li>A word of weight 

<math display="inline" id="Fast_Syndrome_Based_Hash:23">
 <semantics>
  <mi>w</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>w</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w
  </annotation>
 </semantics>
</math>

 and length 

<math display="inline" id="Fast_Syndrome_Based_Hash:24">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 is called <strong>regular</strong> if in every interval 

<math display="inline" id="Fast_Syndrome_Based_Hash:25">
 <semantics>
  <mrow>
   <mo stretchy="false">[</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>i</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>w</mi>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>i</mi>
    <mi>w</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="closed-open">
    <apply>
     <times></times>
     <apply>
      <minus></minus>
      <ci>i</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>w</ci>
    </apply>
    <apply>
     <times></times>
     <ci>i</ci>
     <ci>w</ci>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [(i-1)w,iw)
  </annotation>
 </semantics>
</math>

 it contains exactly one nonzero entry for all <math>0 . More intuitively, this means that if we chop up the message in <em>w</em> equal parts, then each part contains exactly one nonzero entry.</math></li>
</ul>
<h3 id="the-compression-function">The Compression Function</h3>

<p>There are exactly 

<math display="inline" id="Fast_Syndrome_Based_Hash:26">
 <semantics>
  <msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>n</mi>
     <mo>/</mo>
     <mi>w</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi>w</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <divide></divide>
     <ci>n</ci>
     <ci>w</ci>
    </apply>
    <ci>w</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (n/w)^{w}
  </annotation>
 </semantics>
</math>

 different regular words of weight 

<math display="inline" id="Fast_Syndrome_Based_Hash:27">
 <semantics>
  <mi>w</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>w</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w
  </annotation>
 </semantics>
</math>

 and length 

<math display="inline" id="Fast_Syndrome_Based_Hash:28">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

, so we need exactly 

<math display="inline" id="Fast_Syndrome_Based_Hash:29">
 <semantics>
  <mrow>
   <mrow>
    <mi>log</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>n</mi>
        <mo>/</mo>
        <mi>w</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>w</mi>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>w</mi>
    <mrow>
     <mi>log</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>n</mi>
       <mo>/</mo>
       <mi>w</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>s</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <log></log>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <divide></divide>
        <ci>n</ci>
        <ci>w</ci>
       </apply>
       <ci>w</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>w</ci>
      <apply>
       <log></log>
       <apply>
        <divide></divide>
        <ci>n</ci>
        <ci>w</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <ci>s</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \log((n/w)^{w})=w\log(n/w)=s
  </annotation>
 </semantics>
</math>

 bits of data to encode these regular words. We fix a bijection from the set of bit strings of length 

<math display="inline" id="Fast_Syndrome_Based_Hash:30">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

 to the set of regular words of weight 

<math display="inline" id="Fast_Syndrome_Based_Hash:31">
 <semantics>
  <mi>w</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>w</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w
  </annotation>
 </semantics>
</math>

 and length 

<math display="inline" id="Fast_Syndrome_Based_Hash:32">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 and then the FSB compression function is defined as follows :</p>
<ol>
<li>input: a message of size 

<math display="inline" id="Fast_Syndrome_Based_Hash:33">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

</li>
<li>convert to regular word of length 

<math display="inline" id="Fast_Syndrome_Based_Hash:34">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 and weight 

<math display="inline" id="Fast_Syndrome_Based_Hash:35">
 <semantics>
  <mi>w</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>w</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w
  </annotation>
 </semantics>
</math>

</li>
<li>multiply by the matrix 

<math display="inline" id="Fast_Syndrome_Based_Hash:36">
 <semantics>
  <mi>H</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>H</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H
  </annotation>
 </semantics>
</math>

</li>
<li>output: hash of size 

<math display="inline" id="Fast_Syndrome_Based_Hash:37">
 <semantics>
  <mi>r</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>r</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r
  </annotation>
 </semantics>
</math>

</li>
</ol>

<p>This version is usually called <strong>Syndrome Based Compression</strong>. It is very slow and in practice done in a different and faster way resulting in <strong>Fast Syndrome Based Compression</strong>. We split 

<math display="inline" id="Fast_Syndrome_Based_Hash:38">
 <semantics>
  <mi>H</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>H</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H
  </annotation>
 </semantics>
</math>

 into sub-matrices 

<math display="inline" id="Fast_Syndrome_Based_Hash:39">
 <semantics>
  <msub>
   <mi>H</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>H</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{i}
  </annotation>
 </semantics>
</math>

 of size 

<math display="inline" id="Fast_Syndrome_Based_Hash:40">
 <semantics>
  <mrow>
   <mrow>
    <mi>r</mi>
    <mo>×</mo>
    <mi>n</mi>
   </mrow>
   <mo>/</mo>
   <mi>w</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <times></times>
     <ci>r</ci>
     <ci>n</ci>
    </apply>
    <ci>w</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r\times n/w
  </annotation>
 </semantics>
</math>

 and we fix a bijection from the bit strings of length 

<math display="inline" id="Fast_Syndrome_Based_Hash:41">
 <semantics>
  <mrow>
   <mi>w</mi>
   <mrow>
    <mi>log</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>n</mi>
      <mo>/</mo>
      <mi>w</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>w</ci>
    <apply>
     <log></log>
     <apply>
      <divide></divide>
      <ci>n</ci>
      <ci>w</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w\log(n/w)
  </annotation>
 </semantics>
</math>

 to the set of sequences of 

<math display="inline" id="Fast_Syndrome_Based_Hash:42">
 <semantics>
  <mi>w</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>w</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w
  </annotation>
 </semantics>
</math>

 numbers between 1 and 

<math display="inline" id="Fast_Syndrome_Based_Hash:43">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>/</mo>
   <mi>w</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <ci>n</ci>
    <ci>w</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n/w
  </annotation>
 </semantics>
</math>

. This is equivalent to a bijection to the set of regular words of length 

<math display="inline" id="Fast_Syndrome_Based_Hash:44">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 and weight 

<math display="inline" id="Fast_Syndrome_Based_Hash:45">
 <semantics>
  <mi>w</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>w</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w
  </annotation>
 </semantics>
</math>

, since we can see such a word as a sequence of numbers between 1 and 

<math display="inline" id="Fast_Syndrome_Based_Hash:46">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>/</mo>
   <mi>w</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <ci>n</ci>
    <ci>w</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n/w
  </annotation>
 </semantics>
</math>

. The compression function looks as follows:</p>
<ol>
<li>Input: message of size 

<math display="inline" id="Fast_Syndrome_Based_Hash:47">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

</li>
<li>Convert 

<math display="inline" id="Fast_Syndrome_Based_Hash:48">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

 to a sequence of 

<math display="inline" id="Fast_Syndrome_Based_Hash:49">
 <semantics>
  <mi>w</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>w</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w
  </annotation>
 </semantics>
</math>

 numbers 

<math display="inline" id="Fast_Syndrome_Based_Hash:50">
 <semantics>
  <mrow>
   <msub>
    <mi>s</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>s</mi>
    <mi>w</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>s</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>s</ci>
     <ci>w</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s_{1},\dots,s_{w}
  </annotation>
 </semantics>
</math>

 between 1 and 

<math display="inline" id="Fast_Syndrome_Based_Hash:51">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>/</mo>
   <mi>w</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <ci>n</ci>
    <ci>w</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n/w
  </annotation>
 </semantics>
</math>

</li>
<li>Add the corresponding columns of the matrices 

<math display="inline" id="Fast_Syndrome_Based_Hash:52">
 <semantics>
  <msub>
   <mi>H</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>H</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{i}
  </annotation>
 </semantics>
</math>

 to obtain a binary string a length 

<math display="inline" id="Fast_Syndrome_Based_Hash:53">
 <semantics>
  <mi>r</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>r</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r
  </annotation>
 </semantics>
</math>

</li>
<li>Output: hash of size 

<math display="inline" id="Fast_Syndrome_Based_Hash:54">
 <semantics>
  <mi>r</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>r</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r
  </annotation>
 </semantics>
</math>

</li>
</ol>

<p>We can now use the <a href="Merkle-Damgård_construction" title="wikilink">Merkle-Damgård construction</a> to generalize the compression function to accept inputs of arbitrary lengths.</p>
<h3 id="example-of-the-compression">Example of the compression</h3>

<p><strong>Situation and initialization</strong>: Hash a message 

<math display="inline" id="Fast_Syndrome_Based_Hash:55">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mo>=</mo>
   <mn>010011</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>s</ci>
    <cn type="integer">010011</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s=010011
  </annotation>
 </semantics>
</math>

 using 

<math display="inline" id="Fast_Syndrome_Based_Hash:56">
 <semantics>
  <mrow>
   <mn>4</mn>
   <mo>×</mo>
   <mn>12</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <cn type="integer">4</cn>
    <cn type="integer">12</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   4\times 12
  </annotation>
 </semantics>
</math>

 matrix H<br/>


<math display="inline" id="Fast_Syndrome_Based_Hash:57">
 <semantics>
  <mrow>
   <mi>H</mi>
   <mo>=</mo>
   <mrow>
    <mo>(</mo>
    <mtable>
     <mtr>
      <mtd columnalign="left">
       <mn>1</mn>
      </mtd>
      <mtd columnalign="left">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="left">
       <mn>1</mn>
      </mtd>
      <mtd columnalign="left">
       <mn>1</mn>
      </mtd>
      <mtd></mtd>
      <mtd columnalign="left">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="left">
       <mn>1</mn>
      </mtd>
      <mtd columnalign="left">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="left">
       <mn>0</mn>
      </mtd>
      <mtd></mtd>
      <mtd columnalign="left">
       <mn>1</mn>
      </mtd>
      <mtd columnalign="left">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="left">
       <mn>1</mn>
      </mtd>
      <mtd columnalign="left">
       <mn>1</mn>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="left">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="left">
       <mn>1</mn>
      </mtd>
      <mtd columnalign="left">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="left">
       <mn>0</mn>
      </mtd>
      <mtd></mtd>
      <mtd columnalign="left">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="left">
       <mn>1</mn>
      </mtd>
      <mtd columnalign="left">
       <mn>1</mn>
      </mtd>
      <mtd columnalign="left">
       <mn>1</mn>
      </mtd>
      <mtd></mtd>
      <mtd columnalign="left">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="left">
       <mn>1</mn>
      </mtd>
      <mtd columnalign="left">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="left">
       <mn>0</mn>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="left">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="left">
       <mn>1</mn>
      </mtd>
      <mtd columnalign="left">
       <mn>1</mn>
      </mtd>
      <mtd columnalign="left">
       <mn>1</mn>
      </mtd>
      <mtd></mtd>
      <mtd columnalign="left">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="left">
       <mn>1</mn>
      </mtd>
      <mtd columnalign="left">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="left">
       <mn>0</mn>
      </mtd>
      <mtd></mtd>
      <mtd columnalign="left">
       <mn>1</mn>
      </mtd>
      <mtd columnalign="left">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="left">
       <mn>1</mn>
      </mtd>
      <mtd columnalign="left">
       <mn>0</mn>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="left">
       <mn>1</mn>
      </mtd>
      <mtd columnalign="left">
       <mn>1</mn>
      </mtd>
      <mtd columnalign="left">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="left">
       <mn>0</mn>
      </mtd>
      <mtd></mtd>
      <mtd columnalign="left">
       <mn>1</mn>
      </mtd>
      <mtd columnalign="left">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="left">
       <mn>1</mn>
      </mtd>
      <mtd columnalign="left">
       <mn>1</mn>
      </mtd>
      <mtd></mtd>
      <mtd columnalign="left">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="left">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="left">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="left">
       <mn>1</mn>
      </mtd>
     </mtr>
    </mtable>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>H</ci>
    <matrix>
     <matrixrow>
      <cn type="integer">1</cn>
      <cn type="integer">0</cn>
      <cn type="integer">1</cn>
      <cn type="integer">1</cn>
      <cerror>
       <csymbol cd="ambiguous">missing-subexpression</csymbol>
      </cerror>
      <cn type="integer">0</cn>
      <cn type="integer">1</cn>
      <cn type="integer">0</cn>
      <cn type="integer">0</cn>
      <cerror>
       <csymbol cd="ambiguous">missing-subexpression</csymbol>
      </cerror>
      <cn type="integer">1</cn>
      <cn type="integer">0</cn>
      <cn type="integer">1</cn>
      <cn type="integer">1</cn>
     </matrixrow>
     <matrixrow>
      <cn type="integer">0</cn>
      <cn type="integer">1</cn>
      <cn type="integer">0</cn>
      <cn type="integer">0</cn>
      <cerror>
       <csymbol cd="ambiguous">missing-subexpression</csymbol>
      </cerror>
      <cn type="integer">0</cn>
      <cn type="integer">1</cn>
      <cn type="integer">1</cn>
      <cn type="integer">1</cn>
      <cerror>
       <csymbol cd="ambiguous">missing-subexpression</csymbol>
      </cerror>
      <cn type="integer">0</cn>
      <cn type="integer">1</cn>
      <cn type="integer">0</cn>
      <cn type="integer">0</cn>
     </matrixrow>
     <matrixrow>
      <cn type="integer">0</cn>
      <cn type="integer">1</cn>
      <cn type="integer">1</cn>
      <cn type="integer">1</cn>
      <cerror>
       <csymbol cd="ambiguous">missing-subexpression</csymbol>
      </cerror>
      <cn type="integer">0</cn>
      <cn type="integer">1</cn>
      <cn type="integer">0</cn>
      <cn type="integer">0</cn>
      <cerror>
       <csymbol cd="ambiguous">missing-subexpression</csymbol>
      </cerror>
      <cn type="integer">1</cn>
      <cn type="integer">0</cn>
      <cn type="integer">1</cn>
      <cn type="integer">0</cn>
     </matrixrow>
     <matrixrow>
      <cn type="integer">1</cn>
      <cn type="integer">1</cn>
      <cn type="integer">0</cn>
      <cn type="integer">0</cn>
      <cerror>
       <csymbol cd="ambiguous">missing-subexpression</csymbol>
      </cerror>
      <cn type="integer">1</cn>
      <cn type="integer">0</cn>
      <cn type="integer">1</cn>
      <cn type="integer">1</cn>
      <cerror>
       <csymbol cd="ambiguous">missing-subexpression</csymbol>
      </cerror>
      <cn type="integer">0</cn>
      <cn type="integer">0</cn>
      <cn type="integer">0</cn>
      <cn type="integer">1</cn>
     </matrixrow>
    </matrix>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H=\left(\begin{array}[]{llllcllllcllll}1&0&1&1&&0&1&0&0&&1&0&1&1\\
0&1&0&0&&0&1&1&1&&0&1&0&0\\
0&1&1&1&&0&1&0&0&&1&0&1&0\\
1&1&0&0&&1&0&1&1&&0&0&0&1\end{array}\right)
  </annotation>
 </semantics>
</math>

<br/>
that is separated into 

<math display="inline" id="Fast_Syndrome_Based_Hash:58">
 <semantics>
  <mrow>
   <mi>w</mi>
   <mo>=</mo>
   <mn>3</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>w</ci>
    <cn type="integer">3</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w=3
  </annotation>
 </semantics>
</math>

 sub-blocks 

<math display="inline" id="Fast_Syndrome_Based_Hash:59">
 <semantics>
  <msub>
   <mi>H</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>H</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{1}
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Fast_Syndrome_Based_Hash:60">
 <semantics>
  <msub>
   <mi>H</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>H</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{2}
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Fast_Syndrome_Based_Hash:61">
 <semantics>
  <msub>
   <mi>H</mi>
   <mn>3</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>H</ci>
    <cn type="integer">3</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{3}
  </annotation>
 </semantics>
</math>

.</p>

<p><strong>Algorithm</strong>:</p>
<ol>
<li>We split the input 

<math display="inline" id="Fast_Syndrome_Based_Hash:62">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

 into 

<math display="inline" id="Fast_Syndrome_Based_Hash:63">
 <semantics>
  <mrow>
   <mi>w</mi>
   <mo>=</mo>
   <mn>3</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>w</ci>
    <cn type="integer">3</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w=3
  </annotation>
 </semantics>
</math>

 parts of length 

<math display="inline" id="Fast_Syndrome_Based_Hash:64">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>log</mi>
     <mn>2</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mn>12</mn>
      <mo>/</mo>
      <mn>3</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <log></log>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <divide></divide>
      <cn type="integer">12</cn>
      <cn type="integer">3</cn>
     </apply>
    </apply>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \log_{2}(12/3)=2
  </annotation>
 </semantics>
</math>

 and we get 

<math display="inline" id="Fast_Syndrome_Based_Hash:65">
 <semantics>
  <mrow>
   <msub>
    <mi>s</mi>
    <mn>1</mn>
   </msub>
   <mo>=</mo>
   <mn>01</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>s</ci>
     <cn type="integer">1</cn>
    </apply>
    <cn type="integer">01</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s_{1}=01
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Fast_Syndrome_Based_Hash:66">
 <semantics>
  <mrow>
   <msub>
    <mi>s</mi>
    <mn>2</mn>
   </msub>
   <mo>=</mo>
   <mn>00</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>s</ci>
     <cn type="integer">2</cn>
    </apply>
    <cn type="integer">00</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s_{2}=00
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Fast_Syndrome_Based_Hash:67">
 <semantics>
  <mrow>
   <msub>
    <mi>s</mi>
    <mn>3</mn>
   </msub>
   <mo>=</mo>
   <mn>11</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>s</ci>
     <cn type="integer">3</cn>
    </apply>
    <cn type="integer">11</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s_{3}=11
  </annotation>
 </semantics>
</math>

.</li>
<li>We convert each 

<math display="inline" id="Fast_Syndrome_Based_Hash:68">
 <semantics>
  <msub>
   <mi>s</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>s</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s_{i}
  </annotation>
 </semantics>
</math>

 into an integer and get 

<math display="inline" id="Fast_Syndrome_Based_Hash:69">
 <semantics>
  <mrow>
   <msub>
    <mi>s</mi>
    <mn>1</mn>
   </msub>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>s</ci>
     <cn type="integer">1</cn>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s_{1}=1
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Fast_Syndrome_Based_Hash:70">
 <semantics>
  <mrow>
   <msub>
    <mi>s</mi>
    <mn>2</mn>
   </msub>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>s</ci>
     <cn type="integer">2</cn>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s_{2}=0
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Fast_Syndrome_Based_Hash:71">
 <semantics>
  <mrow>
   <msub>
    <mi>s</mi>
    <mn>3</mn>
   </msub>
   <mo>=</mo>
   <mn>3</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>s</ci>
     <cn type="integer">3</cn>
    </apply>
    <cn type="integer">3</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s_{3}=3
  </annotation>
 </semantics>
</math>

.</li>
<li>From the first sub-matrix 

<math display="inline" id="Fast_Syndrome_Based_Hash:72">
 <semantics>
  <msub>
   <mi>H</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>H</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{1}
  </annotation>
 </semantics>
</math>

, we pick the column 2, from the second sub-matrix 

<math display="inline" id="Fast_Syndrome_Based_Hash:73">
 <semantics>
  <msub>
   <mi>H</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>H</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{2}
  </annotation>
 </semantics>
</math>

 the column 1 and from the third sub-matrix the column 4.</li>
<li>We add the chosen columns and obtain the result 

<math display="inline" id="Fast_Syndrome_Based_Hash:74">
 <semantics>
  <mrow>
   <mi>r</mi>
   <mo>=</mo>
   <mrow>
    <mn>0111</mn>
    <mo>⊕</mo>
    <mn>0001</mn>
    <mo>⊕</mo>
    <mn>1001</mn>
   </mrow>
   <mo>=</mo>
   <mn>1111</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>r</ci>
     <apply>
      <csymbol cd="latexml">direct-sum</csymbol>
      <cn type="integer">0111</cn>
      <cn type="integer">0001</cn>
      <cn type="integer">1001</cn>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="integer">1111</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r=0111\oplus 0001\oplus 1001=1111
  </annotation>
 </semantics>
</math>

.</li>
</ol>
<h2 id="security-proof-of-fsb">Security Proof of FSB</h2>

<p>The <a href="Merkle-Damgård_construction" title="wikilink">Merkle-Damgård construction</a> is proven to base its security only on the security of the used compression function. So we only need to show that the compression function 

<math display="inline" id="Fast_Syndrome_Based_Hash:75">
 <semantics>
  <mi>ϕ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϕ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi
  </annotation>
 </semantics>
</math>

 is secure.</p>

<p>A cryptographic hash function needs to be secure in three different aspects:</p>
<ol>
<li>Pre-image resistance: Given a Hash <em>h</em> it should be hard to find a message <em>m</em> such that Hash(<em>m</em>)=<em>h</em></li>
<li>Second pre-image resistance: Given a message <em>m</em><sub>1</sub> it should be hard to find a message <em>m</em><sub>2</sub> such that Hash(<em>m</em><sub>1</sub>) = Hash(<em>m</em><sub>2</sub>)</li>
<li>Collision resistance: It should be hard to find two different messages <em>m</em><sub>1</sub> and <em>m</em><sub>2</sub> such that Hash(<em>m</em><sub>1</sub>)=Hash(<em>m</em><sub>2</sub>)</li>
</ol>

<p>Note that if an adversary can find a second pre-image, than he can certainly find a collision. This means that if we can prove our system to be collision resistant, it will certainly be second-pre-image resistant.</p>

<p>Usually in cryptography hard means something like “almost certainly beyond the reach of any adversary who must be prevented from breaking the system”. We will however need a more exact meaning of the word hard. We will take hard to mean “The runtime of any algorithm that finds a collision or pre-image will depend exponentially on size of the hash value”. This means that by relatively small additions to the hash size, we can quickly reach high security.</p>
<h3 id="pre-image-resistance-and-regular-syndrome-decoding-rsd">Pre-image resistance and Regular Syndrome Decoding (RSD)</h3>

<p>As said before, the security of FSB depends on a problem called <strong>Regular Syndrome Decoding (RSD)</strong>. Syndrome Decoding is originally a problem from <a href="coding_theory" title="wikilink">coding theory</a> but its NP-Completeness makes it a nice application for cryptography. Regular Syndrome Decoding is a special case of <a href="Decoding_methods" title="wikilink">Syndrome Decoding</a> and is defined as follows:</p>

<p>Definition of RSD: Given 

<math display="inline" id="Fast_Syndrome_Based_Hash:76">
 <semantics>
  <mi>w</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>w</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w
  </annotation>
 </semantics>
</math>

 matrices 

<math display="inline" id="Fast_Syndrome_Based_Hash:77">
 <semantics>
  <msub>
   <mi>H</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>H</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{i}
  </annotation>
 </semantics>
</math>

 of dimension 

<math display="inline" id="Fast_Syndrome_Based_Hash:78">
 <semantics>
  <mrow>
   <mi>r</mi>
   <mo>×</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>n</mi>
     <mo>/</mo>
     <mi>w</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>r</ci>
    <apply>
     <divide></divide>
     <ci>n</ci>
     <ci>w</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r\times(n/w)
  </annotation>
 </semantics>
</math>

 and a bit string 

<math display="inline" id="Fast_Syndrome_Based_Hash:79">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 of length 

<math display="inline" id="Fast_Syndrome_Based_Hash:80">
 <semantics>
  <mi>r</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>r</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r
  </annotation>
 </semantics>
</math>

 such that there exists a set of 

<math display="inline" id="Fast_Syndrome_Based_Hash:81">
 <semantics>
  <mi>w</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>w</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w
  </annotation>
 </semantics>
</math>

 columns, one in each 

<math display="inline" id="Fast_Syndrome_Based_Hash:82">
 <semantics>
  <msub>
   <mi>H</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>H</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{i}
  </annotation>
 </semantics>
</math>

, summing to 

<math display="inline" id="Fast_Syndrome_Based_Hash:83">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

. Find such a set of columns.</p>

<p>This problem has been proven to be <a class="uri" href="NP-Complete" title="wikilink">NP-Complete</a> by a reduction from <a href="3-dimensional_matching" title="wikilink">3-dimensional matching</a>. Again, though it is not known whether there exist <a href="polynomial_time" title="wikilink">polynomial time</a> algorithms for solving NP-Complete problems, none are known and finding one would be a huge discovery.</p>

<p>It is easy to see that finding a pre-image of a given hash 

<math display="inline" id="Fast_Syndrome_Based_Hash:84">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 is exactly equivalent to this problem, so the problem of finding pre-images in FSB must also be NP-Complete.</p>

<p>We still need to prove collision resistance. For this we need another NP-Complete variation of RSD: <strong>2-Regular Null Syndrome Decoding</strong>.</p>
<h3 id="collision-resistance-and-2-regular-null-syndrome-decoding-2-nrsd">Collision resistance and 2-Regular Null Syndrome Decoding (2-NRSD)</h3>

<p>Definition of 2-NRSD: Given 

<math display="inline" id="Fast_Syndrome_Based_Hash:85">
 <semantics>
  <mi>w</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>w</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w
  </annotation>
 </semantics>
</math>

 matrices 

<math display="inline" id="Fast_Syndrome_Based_Hash:86">
 <semantics>
  <msub>
   <mi>H</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>H</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{i}
  </annotation>
 </semantics>
</math>

 of dimension 

<math display="inline" id="Fast_Syndrome_Based_Hash:87">
 <semantics>
  <mrow>
   <mi>r</mi>
   <mo>×</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>n</mi>
     <mo>/</mo>
     <mi>w</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>r</ci>
    <apply>
     <divide></divide>
     <ci>n</ci>
     <ci>w</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r\times(n/w)
  </annotation>
 </semantics>
</math>

 and a bit string 

<math display="inline" id="Fast_Syndrome_Based_Hash:88">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 of length 

<math display="inline" id="Fast_Syndrome_Based_Hash:89">
 <semantics>
  <mi>r</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>r</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r
  </annotation>
 </semantics>
</math>

 such that there exists a set of 

<math display="inline" id="Fast_Syndrome_Based_Hash:90">
 <semantics>
  <msup>
   <mi>w</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>w</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w^{\prime}
  </annotation>
 </semantics>
</math>

 columns, two or zero in each 

<math display="inline" id="Fast_Syndrome_Based_Hash:91">
 <semantics>
  <msub>
   <mi>H</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>H</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{i}
  </annotation>
 </semantics>
</math>

, summing to zero. 

<math display="inline" id="Fast_Syndrome_Based_Hash:92">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mn>0</mn>
    <mo><</mo>
    <msup>
     <mi>w</mi>
     <mo>′</mo>
    </msup>
    <mo><</mo>
    <mrow>
     <mn>2</mn>
     <mi>w</mi>
    </mrow>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <lt></lt>
     <cn type="integer">0</cn>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>w</ci>
      <ci>normal-′</ci>
     </apply>
    </apply>
    <apply>
     <lt></lt>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <ci>w</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (0<w^{\prime}<2w)
  </annotation>
 </semantics>
</math>

. Find such a set of columns.</p>

<p>2-NRSD has also been proven to be <a class="uri" href="NP-Complete" title="wikilink">NP-Complete</a> by a reduction from <a href="3-dimensional_matching" title="wikilink">3-dimensional matching</a>.</p>

<p>Just like RSD is in essence equivalent to finding a regular word 

<math display="inline" id="Fast_Syndrome_Based_Hash:93">
 <semantics>
  <mi>w</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>w</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Fast_Syndrome_Based_Hash:94">
 <semantics>
  <mrow>
   <mrow>
    <mi>H</mi>
    <mi>w</mi>
   </mrow>
   <mo>=</mo>
   <mi>S</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>H</ci>
     <ci>w</ci>
    </apply>
    <ci>S</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Hw=S
  </annotation>
 </semantics>
</math>

, 2-NRSD is equivalent to finding a 2-regular word 

<math display="inline" id="Fast_Syndrome_Based_Hash:95">
 <semantics>
  <msup>
   <mi>w</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>w</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w^{\prime}
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Fast_Syndrome_Based_Hash:96">
 <semantics>
  <mrow>
   <mrow>
    <mi>H</mi>
    <msup>
     <mi>w</mi>
     <mo>′</mo>
    </msup>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>H</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>w</ci>
      <ci>normal-′</ci>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Hw^{\prime}=0
  </annotation>
 </semantics>
</math>

. A 2-regular word of length 

<math display="inline" id="Fast_Syndrome_Based_Hash:97">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 and weight 

<math display="inline" id="Fast_Syndrome_Based_Hash:98">
 <semantics>
  <mi>w</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>w</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w
  </annotation>
 </semantics>
</math>

 is a bit string of length 

<math display="inline" id="Fast_Syndrome_Based_Hash:99">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 such that in every interval 

<math display="inline" id="Fast_Syndrome_Based_Hash:100">
 <semantics>
  <mrow>
   <mo stretchy="false">[</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>i</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>w</mi>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>i</mi>
    <mi>w</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="closed-open">
    <apply>
     <times></times>
     <apply>
      <minus></minus>
      <ci>i</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>w</ci>
    </apply>
    <apply>
     <times></times>
     <ci>i</ci>
     <ci>w</ci>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [(i-1)w,iw)
  </annotation>
 </semantics>
</math>

 exactly two or zero entries are equal to 1. Note that a 2-regular word is just a sum of two regular words.</p>

<p>Suppose that we have found a collision, so we have Hash(<em>m</em><sub>1</sub>) = Hash(<em>m</em><sub>2</sub>) with 

<math display="inline" id="Fast_Syndrome_Based_Hash:101">
 <semantics>
  <mrow>
   <msub>
    <mi>m</mi>
    <mn>1</mn>
   </msub>
   <mo>≠</mo>
   <msub>
    <mi>m</mi>
    <mn>2</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <neq></neq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>m</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>m</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m_{1}\neq m_{2}
  </annotation>
 </semantics>
</math>

. Then we can find two regular words 

<math display="inline" id="Fast_Syndrome_Based_Hash:102">
 <semantics>
  <msub>
   <mi>w</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>w</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w_{1}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Fast_Syndrome_Based_Hash:103">
 <semantics>
  <msub>
   <mi>w</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>w</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w_{2}
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Fast_Syndrome_Based_Hash:104">
 <semantics>
  <mrow>
   <mrow>
    <mi>H</mi>
    <msub>
     <mi>w</mi>
     <mn>1</mn>
    </msub>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>H</mi>
    <msub>
     <mi>w</mi>
     <mn>2</mn>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>H</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>w</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>H</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>w</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Hw_{1}=Hw_{2}
  </annotation>
 </semantics>
</math>

 . We then have 

<math display="inline" id="Fast_Syndrome_Based_Hash:105">
 <semantics>
  <mrow>
   <mrow>
    <mi>H</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>w</mi>
       <mn>1</mn>
      </msub>
      <mo>+</mo>
      <msub>
       <mi>w</mi>
       <mn>2</mn>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>H</mi>
     <msub>
      <mi>w</mi>
      <mn>1</mn>
     </msub>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>H</mi>
     <msub>
      <mi>w</mi>
      <mn>2</mn>
     </msub>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mn>2</mn>
    <mi>H</mi>
    <msub>
     <mi>w</mi>
     <mn>1</mn>
    </msub>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>H</ci>
      <apply>
       <plus></plus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>w</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>w</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>H</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>w</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>H</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>w</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <ci>H</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>w</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H(w_{1}+w_{2})=Hw_{1}+Hw_{2}=2Hw_{1}=0
  </annotation>
 </semantics>
</math>

; 

<math display="inline" id="Fast_Syndrome_Based_Hash:106">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <msub>
     <mi>w</mi>
     <mn>1</mn>
    </msub>
    <mo>+</mo>
    <msub>
     <mi>w</mi>
     <mn>2</mn>
    </msub>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>w</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>w</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (w_{1}+w_{2})
  </annotation>
 </semantics>
</math>

 is a sum of two different regular words and so must be a 2-regular word of which the hash is zero, so we have solved an instance of 2-NRSD. We conclude that finding collisions in FSB is at least as difficult as solving 2-NRSD and so must be NP-Complete.</p>

<p>The latest versions of FSB use the compression function <a href="Whirlpool_(cryptography)" title="wikilink">Whirlpool</a> to further compress the hash output. Though this cannot be proven, the authors argue that this last compression does not reduce security. Note that even if one were able to find collisions in Whirlpool, one would still need to find the collisions pre-images in the original FSB compression function to find a collision in FSB.</p>
<h3 id="examples">Examples</h3>

<p>Solving RSD, we are in the opposite situation as when hashing. Using the same values as in the previous example, we are given 

<math display="inline" id="Fast_Syndrome_Based_Hash:107">
 <semantics>
  <mi>H</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>H</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H
  </annotation>
 </semantics>
</math>

 separated into 

<math display="inline" id="Fast_Syndrome_Based_Hash:108">
 <semantics>
  <mrow>
   <mi>w</mi>
   <mo>=</mo>
   <mn>3</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>w</ci>
    <cn type="integer">3</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w=3
  </annotation>
 </semantics>
</math>

 sub-blocks and a string 

<math display="inline" id="Fast_Syndrome_Based_Hash:109">
 <semantics>
  <mrow>
   <mi>r</mi>
   <mo>=</mo>
   <mn>1111</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>r</ci>
    <cn type="integer">1111</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r=1111
  </annotation>
 </semantics>
</math>

. We are asked to find in each sub-block exactly one column such that they would all sum to 

<math display="inline" id="Fast_Syndrome_Based_Hash:110">
 <semantics>
  <mi>r</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>r</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r
  </annotation>
 </semantics>
</math>

. The expected answer is thus 

<math display="inline" id="Fast_Syndrome_Based_Hash:111">
 <semantics>
  <mrow>
   <msub>
    <mi>s</mi>
    <mn>1</mn>
   </msub>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>s</ci>
     <cn type="integer">1</cn>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s_{1}=1
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Fast_Syndrome_Based_Hash:112">
 <semantics>
  <mrow>
   <msub>
    <mi>s</mi>
    <mn>2</mn>
   </msub>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>s</ci>
     <cn type="integer">2</cn>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s_{2}=0
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Fast_Syndrome_Based_Hash:113">
 <semantics>
  <mrow>
   <msub>
    <mi>s</mi>
    <mn>3</mn>
   </msub>
   <mo>=</mo>
   <mn>3</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>s</ci>
     <cn type="integer">3</cn>
    </apply>
    <cn type="integer">3</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s_{3}=3
  </annotation>
 </semantics>
</math>

. This is known to be hard to compute for large matrices.</p>

<p>In 2-NRSD we want to find in each sub-block not one column, but two or zero such that they would sum up to 0000 (and not to 

<math display="inline" id="Fast_Syndrome_Based_Hash:114">
 <semantics>
  <mi>r</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>r</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r
  </annotation>
 </semantics>
</math>

). In the example, we might use column (counting from 0) 2 and 3 from 

<math display="inline" id="Fast_Syndrome_Based_Hash:115">
 <semantics>
  <msub>
   <mi>H</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>H</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{1}
  </annotation>
 </semantics>
</math>

, no column from 

<math display="inline" id="Fast_Syndrome_Based_Hash:116">
 <semantics>
  <msub>
   <mi>H</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>H</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{2}
  </annotation>
 </semantics>
</math>

 column 0 and 2 from 

<math display="inline" id="Fast_Syndrome_Based_Hash:117">
 <semantics>
  <msub>
   <mi>H</mi>
   <mn>3</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>H</ci>
    <cn type="integer">3</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{3}
  </annotation>
 </semantics>
</math>

. More solutions are possible, for example might use no columns from 

<math display="inline" id="Fast_Syndrome_Based_Hash:118">
 <semantics>
  <msub>
   <mi>H</mi>
   <mn>3</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>H</ci>
    <cn type="integer">3</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{3}
  </annotation>
 </semantics>
</math>

.</p>
<h3 id="linear-cryptanalysis">Linear cryptanalysis</h3>

<p>The <a href="Provably_secure_cryptographic_hash_function" title="wikilink">provable security</a> of FSB means that finding collisions is NP-complete. But the proof is a reduction to a problem with asymptotically hard <a href="worst-case_complexity" title="wikilink">worst-case complexity</a>. This offers only limited security assurance as there still can be an algorithm that easily solves the problem for a subset of the problem space. For example, there exists a <a href="Linear_cryptanalysis" title="wikilink">linearization</a> method that can be used to produce collisions of in a matter of seconds on a desktop PC for early variants of FSB with claimed 2^128 security. It is shown that the hash function offers minimal pre-image or collision resistance when the message space is chosen in a specific way.</p>
<h3 id="practical-security-results">Practical security results</h3>

<p>The following table shows the complexity of the best known attacks against FSB.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>Output size (bits)</p></th>
<th style="text-align: left;">
<p>Complexity of collision search</p></th>
<th style="text-align: left;">
<p>Complexity of inversion</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p><strong>160</strong></p></td>
<td style="text-align: left;">
<p>2<sup>100.3</sup></p></td>
<td style="text-align: left;">
<p>2<sup>163.6</sup></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><strong>224</strong></p></td>
<td style="text-align: left;">
<p>2<sup>135.3</sup></p></td>
<td style="text-align: left;">
<p>2<sup>229.0</sup></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><strong>256</strong></p></td>
<td style="text-align: left;">
<p>2<sup>190.0</sup></p></td>
<td style="text-align: left;">
<p>2<sup>261.0</sup></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><strong>384</strong></p></td>
<td style="text-align: left;">
<p>2<sup>215.5</sup></p></td>
<td style="text-align: left;">
<p>2<sup>391.5</sup></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><strong>512</strong></p></td>
<td style="text-align: left;">
<p>2<sup>285.6</sup></p></td>
<td style="text-align: left;">
<p>2<sup>527.4</sup></p></td>
</tr>
</tbody>
</table>
<h2 id="genesis">Genesis</h2>

<p>FSB is a speed-up version of Syndrom-based hash function (SB). In the case of SB the compression function is very similar to the encoding function of <a href="Niederreiter_cryptosystem" title="wikilink">Niederreiter's version</a> of <a href="McEliece_cryptosystem" title="wikilink">McEliece cryptosystem</a>. Instead of using the parity check matrix of a permuted <a href="Goppa_code" title="wikilink">Goppa code</a>, SB uses a random matrix 

<math display="inline" id="Fast_Syndrome_Based_Hash:119">
 <semantics>
  <mi>H</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>H</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H
  </annotation>
 </semantics>
</math>

. From the security point of view this can only strengthen the system.</p>
<h2 id="other-properties">Other properties</h2>
<ul>
<li>Both the block size of the hash function and the output size are completely scalable.</li>
<li>The speed can be adjusted by adjusting the number of bitwise operations used by FSB per input bit.</li>
<li>The security can be adjusted by adjusting the output size.</li>
<li>Bad instances exist and one must take care when choosing the matrix 

<math display="inline" id="Fast_Syndrome_Based_Hash:120">
 <semantics>
  <mi>H</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>H</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H
  </annotation>
 </semantics>
</math>

.</li>
<li>The matrix used in the compression function may grow large in certain situations. This might be a limitation when trying to use FSB on memory constrained devices. This problem was solved in the related hash function called Improved FSB, which is still <a href="Provably_secure_cryptographic_hash_function" title="wikilink">provably secure</a>, but relies on slightly stronger assumptions.</li>
</ul>
<h2 id="variants">Variants</h2>

<p>In 2007, IFSB was published.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> In 2010, S-FSB was published, which is 30% faster than the original.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>

<p>In 2011, <a href="D.J._Bernstein" title="wikilink">D.J. Bernstein</a> and <a href="Tanja_Lange" title="wikilink">Tanja Lange</a> published RFSB, which is 10x faster than the original FSB-256.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> RFSB was shown to run very fast on the <a href="Spartan_6" title="wikilink">Spartan 6</a> FPGA, reaching throughputs of around 5 Gbit/s.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>
<h2 id="references">References</h2>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www-rocq.inria.fr/secret/CBCrypto/index.php?pg=fsb">FSB website for SHA-3 competition</a></li>
</ul>

<p>"</p>

<p><a href="Category:Cryptographic_hash_functions" title="wikilink">Category:Cryptographic hash functions</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a class="uri" href="https://www.rocq.inria.fr/secret/Matthieu.Finiasz/research/2007/finiasz-gaborit-sendrier-ecrypt-hash-workshop07.pdf">https://www.rocq.inria.fr/secret/Matthieu.Finiasz/research/2007/finiasz-gaborit-sendrier-ecrypt-hash-workshop07.pdf</a><a href="#fnref4">↩</a></li>
<li id="fn5"><a class="uri" href="https://www.informatik.tu-darmstadt.de/fileadmin/user_upload/Group_CASED/Publikationen/2010/S-FSB_An_Improved_Variant_of_the_FSB_Hash_Family.pdf">https://www.informatik.tu-darmstadt.de/fileadmin/user_upload/Group_CASED/Publikationen/2010/S-FSB_An_Improved_Variant_of_the_FSB_Hash_Family.pdf</a><a href="#fnref5">↩</a></li>
<li id="fn6"><a class="uri" href="http://cr.yp.to/codes/rfsb-20110214.pdf">http://cr.yp.to/codes/rfsb-20110214.pdf</a><a href="#fnref6">↩</a></li>
<li id="fn7"><a class="uri" href="https://www.ei.rub.de/media/sh/veroeffentlichungen/2012/12/10/embedded_syndrome-based_hashing.pdf">https://www.ei.rub.de/media/sh/veroeffentlichungen/2012/12/10/embedded_syndrome-based_hashing.pdf</a><a href="#fnref7">↩</a></li>
</ol>
</section>
</body>
</html>
