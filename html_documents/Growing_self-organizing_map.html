<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="754">Growing self-organizing map</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Growing self-organizing map</h1>
<hr/>

<p>A <strong>growing self-organizing map (GSOM)</strong> is a growing variant of the popular <a href="self-organizing_map" title="wikilink">self-organizing map</a> (SOM). The GSOM was developed to address the issue of identifying a suitable map size in the <a href="Self_Organizing_Map" title="wikilink">SOM</a>. It starts with a minimal number of nodes (usually 4) and grows new nodes on the boundary based on a heuristic. By using the value called Spread Factor (SF), the data analyst has the ability to control the growth of the GSOM.</p>

<p>All the starting nodes of the GSOM are boundary nodes, i.e. each node has the freedom to grow in its own direction at the beginning. (Fig. 1) New Nodes are grown from the boundary nodes. Once a node is selected for growing all its free neighboring positions will be grown new nodes. The figure shows the three possible node growth options for a rectangular GSOM.</p>
<figure><b>(Figure)</b>
<figcaption>Node growth options in GSOM: (a) one new node, (b) two new nodes and (c) three new nodes.</figcaption>
</figure>
<h2 id="the-algorithm">The algorithm</h2>

<p>The GSOM process is as follows:</p>
<ol>
<li>Initialization phase:
<ol>
<li>Initialize the weight vectors of the starting nodes (usually four) with random numbers between 0 and 1.</li>
<li>Calculate the growth threshold (

<math display="inline" id="Growing_self-organizing_map:0">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mi>T</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>G</ci>
    <ci>T</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   GT
  </annotation>
 </semantics>
</math>

) for the given data set of dimension 

<math display="inline" id="Growing_self-organizing_map:1">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>

 according to the spread factor (

<math display="inline" id="Growing_self-organizing_map:2">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mi>F</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>S</ci>
    <ci>F</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   SF
  </annotation>
 </semantics>
</math>

) using the formula 

<math display="inline" id="Growing_self-organizing_map:3">
 <semantics>
  <mrow>
   <mrow>
    <mi>G</mi>
    <mi>T</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <mrow>
     <mi>D</mi>
     <mo>×</mo>
     <mrow>
      <mi>ln</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>S</mi>
        <mi>F</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>G</ci>
     <ci>T</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>D</ci>
      <apply>
       <ln></ln>
       <apply>
        <times></times>
        <ci>S</ci>
        <ci>F</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   GT=-D\times\ln(SF)
  </annotation>
 </semantics>
</math>

</li>
</ol></li>
<li>Growing Phase:
<ol>
<li>Present input to the network.</li>
<li>Determine the weight vector that is closest to the input vector mapped to the current feature map (winner), using Euclidean distance (similar to the <a href="Self_Organizing_Map" title="wikilink">SOM</a>). This step can be summarized as: find 

<math display="inline" id="Growing_self-organizing_map:4">
 <semantics>
  <msup>
   <mi>q</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>q</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q^{\prime}
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Growing_self-organizing_map:5">
 <semantics>
  <mrow>
   <mrow>
    <mo>|</mo>
    <mrow>
     <mi>v</mi>
     <mo>-</mo>
     <msub>
      <mi>w</mi>
      <msup>
       <mi>q</mi>
       <mo>′</mo>
      </msup>
     </msub>
    </mrow>
    <mo>|</mo>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mrow>
     <mo>|</mo>
     <mrow>
      <mi>v</mi>
      <mo>-</mo>
      <msub>
       <mi>w</mi>
       <mi>q</mi>
      </msub>
     </mrow>
     <mo>|</mo>
    </mrow>
    <mrow>
     <mo>∀</mo>
     <mi>q</mi>
    </mrow>
   </mrow>
   <mo>∈</mo>
   <mi>ℕ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <apply>
      <abs></abs>
      <apply>
       <minus></minus>
       <ci>v</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>w</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>q</ci>
         <ci>normal-′</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <abs></abs>
       <apply>
        <minus></minus>
        <ci>v</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>w</ci>
         <ci>q</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="latexml">for-all</csymbol>
       <ci>q</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <in></in>
     <share href="#.cmml">
     </share>
     <ci>ℕ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left|v-w_{q^{\prime}}\right|\leq\left|v-w_{q}\right|\forall q\in\mathbb{N}
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Growing_self-organizing_map:6">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Growing_self-organizing_map:7">
 <semantics>
  <mi>w</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>w</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w
  </annotation>
 </semantics>
</math>

 are the input and weight vectors respectively, 

<math display="inline" id="Growing_self-organizing_map:8">
 <semantics>
  <mi>q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q
  </annotation>
 </semantics>
</math>

 is the position vector for nodes and 

<math display="inline" id="Growing_self-organizing_map:9">
 <semantics>
  <mi>ℕ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℕ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{N}
  </annotation>
 </semantics>
</math>

 is the set of natural numbers.</li>
<li>The weight vector adaptation is applied only to the neighborhood of the winner and the winner itself. The neighborhood is a set of neurons around the winner, but in the GSOM the starting neighborhood selected for weight adaptation is smaller compared to the SOM (localized weight adaptation). The amount of adaptation (learning rate) is also reduced exponentially over the iterations. Even within the neighborhood, weights that are closer to the winner are adapted more than those further away. The weight adaptation can be described by 

<math display="inline" id="Growing_self-organizing_map:10">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>w</mi>
     <mi>j</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>k</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>{</mo>
    <mtable>
     <mtr>
      <mtd columnalign="left">
       <mrow>
        <msub>
         <mi>w</mi>
         <mi>j</mi>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>k</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mtext>if</mtext>
         <mi>j</mi>
        </mrow>
        <mo>∉</mo>
        <msub>
         <merror class="ltx_ERROR undefined undefined">
          <mtext>\Nu</mtext>
         </merror>
         <mrow>
          <mi>k</mi>
          <mo>+</mo>
          <mn>1</mn>
         </mrow>
        </msub>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <msub>
          <mi>w</mi>
          <mi>j</mi>
         </msub>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>k</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>+</mo>
        <mrow>
         <mrow>
          <mi>L</mi>
          <mi>R</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>k</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo>×</mo>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <msub>
            <mi>x</mi>
            <mi>k</mi>
           </msub>
           <mo>-</mo>
           <mrow>
            <msub>
             <mi>w</mi>
             <mi>j</mi>
            </msub>
            <mrow>
             <mo stretchy="false">(</mo>
             <mi>k</mi>
             <mo stretchy="false">)</mo>
            </mrow>
           </mrow>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mtext>if</mtext>
         <mi>j</mi>
        </mrow>
        <mo>∈</mo>
        <msub>
         <merror class="ltx_ERROR undefined undefined">
          <mtext>\Nu</mtext>
         </merror>
         <mrow>
          <mi>k</mi>
          <mo>+</mo>
          <mn>1</mn>
         </mrow>
        </msub>
       </mrow>
      </mtd>
     </mtr>
    </mtable>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>w</ci>
      <ci>j</ci>
     </apply>
     <apply>
      <plus></plus>
      <ci>k</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">cases</csymbol>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>w</ci>
       <ci>j</ci>
      </apply>
      <ci>k</ci>
     </apply>
     <apply>
      <notin></notin>
      <apply>
       <times></times>
       <mtext>if</mtext>
       <ci>j</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <mtext>\Nu</mtext>
       <apply>
        <plus></plus>
        <ci>k</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>w</ci>
        <ci>j</ci>
       </apply>
       <ci>k</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <times></times>
        <ci>L</ci>
        <ci>R</ci>
        <ci>k</ci>
       </apply>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>k</ci>
        </apply>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>w</ci>
          <ci>j</ci>
         </apply>
         <ci>k</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <in></in>
      <apply>
       <times></times>
       <mtext>if</mtext>
       <ci>j</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <mtext>\Nu</mtext>
       <apply>
        <plus></plus>
        <ci>k</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w_{j}(k+1)=\begin{cases}w_{j}(k)&\mbox{if}j\notin\Nu_{k+1}\\
w_{j}(k)+LR(k)\times(x_{k}-w_{j}(k))&\mbox{if}j\in\Nu_{k+1}\end{cases}
  </annotation>
 </semantics>
</math>

 where the Learning Rate 

<math display="inline" id="Growing_self-organizing_map:11">
 <semantics>
  <mrow>
   <mi>L</mi>
   <mi>R</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>k</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>L</ci>
    <ci>R</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   LR(k)
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Growing_self-organizing_map:12">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>∈</mo>
   <mi>ℕ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>k</ci>
    <ci>ℕ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k\in\mathbb{N}
  </annotation>
 </semantics>
</math>

 is a sequence of positive parameters converging to zero as 

<math display="inline" id="Growing_self-organizing_map:13">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>→</mo>
   <mi mathvariant="normal">∞</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>k</ci>
    <infinity></infinity>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k\to\infty
  </annotation>
 </semantics>
</math>

. 

<math display="inline" id="Growing_self-organizing_map:14">
 <semantics>
  <mrow>
   <msub>
    <mi>w</mi>
    <mi>j</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>k</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>w</ci>
     <ci>j</ci>
    </apply>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w_{j}(k)
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Growing_self-organizing_map:15">
 <semantics>
  <mrow>
   <msub>
    <mi>w</mi>
    <mi>j</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>k</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>w</ci>
     <ci>j</ci>
    </apply>
    <apply>
     <plus></plus>
     <ci>k</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w_{j}(k+1)
  </annotation>
 </semantics>
</math>

 are the weight vectors of the node 

<math display="inline" id="Growing_self-organizing_map:16">
 <semantics>
  <mi>j</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>j</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   j
  </annotation>
 </semantics>
</math>

 before and after the adaptation and 

<math display="inline" id="Growing_self-organizing_map:17">
 <semantics>
  <msub>
   <merror class="ltx_ERROR undefined undefined">
    <mtext>\Nu</mtext>
   </merror>
   <mrow>
    <mi>k</mi>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <mtext>\Nu</mtext>
    <apply>
     <plus></plus>
     <ci>k</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Nu_{k+1}
  </annotation>
 </semantics>
</math>

 is the neighbourhood of the winning neuron at the 

<math display="inline" id="Growing_self-organizing_map:18">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi>k</mi>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>k</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (k+1)
  </annotation>
 </semantics>
</math>

th iteration. The decreasing value of 

<math display="inline" id="Growing_self-organizing_map:19">
 <semantics>
  <mrow>
   <mi>L</mi>
   <mi>R</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>k</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>L</ci>
    <ci>R</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   LR(k)
  </annotation>
 </semantics>
</math>

 in the GSOM depends on the number of nodes existing in the map at time 

<math display="inline" id="Growing_self-organizing_map:20">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

.</li>
<li>Increase the error value of the winner (error value is the difference between the input vector and the weight vectors).</li>
<li>When 

<math display="inline" id="Growing_self-organizing_map:21">
 <semantics>
  <mrow>
   <mrow>
    <mi>T</mi>
    <msub>
     <mi>E</mi>
     <mi>i</mi>
    </msub>
   </mrow>
   <mo>></mo>
   <mrow>
    <mi>G</mi>
    <mi>T</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <apply>
     <times></times>
     <ci>T</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>E</ci>
      <ci>i</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>G</ci>
     <ci>T</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   TE_{i}>GT
  </annotation>
 </semantics>
</math>

(where 

<math display="inline" id="Growing_self-organizing_map:22">
 <semantics>
  <mrow>
   <mi>T</mi>
   <msub>
    <mi>E</mi>
    <mi>i</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>T</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>E</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   TE_{i}
  </annotation>
 </semantics>
</math>

 is the total error of node 

<math display="inline" id="Growing_self-organizing_map:23">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Growing_self-organizing_map:24">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mi>T</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>G</ci>
    <ci>T</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   GT
  </annotation>
 </semantics>
</math>

 is the growth threshold). Grow nodes if i is a boundary node. Distribute weights to neighbors if 

<math display="inline" id="Growing_self-organizing_map:25">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

 is a non-boundary node.</li>
<li>Initialize the new node weight vectors to match the neighboring node weights.</li>
<li>Initialize the learning rate (

<math display="inline" id="Growing_self-organizing_map:26">
 <semantics>
  <mrow>
   <mi>L</mi>
   <mi>R</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>L</ci>
    <ci>R</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   LR
  </annotation>
 </semantics>
</math>

) to its starting value.</li>
<li>Repeat steps 2 – 7 until all inputs have been presented and node growth is reduced to a minimum level.</li>
</ol></li>
<li>Smoothing phase.
<ol>
<li>Reduce learning rate and fix a small starting neighborhood.</li>
<li>Find winner and adapt the weights of the winner and neighbors in the same way as in growing phase.</li>
</ol></li>
</ol>
<figure><b>(Figure)</b>
<figcaption>Approximation of a spiral with noise by 1D SOM (the upper row) and GSOM (the lower row) with 50 (the first column) and 100 (the second column) nodes. The <a href="Fraction_of_variance_unexplained" title="wikilink">Fraction of variance unexplained</a> is: a) 4.68% (SOM, 50 nodes); b) 1.69% (SOM, 100 nodes); c) 4.20% (GSOM, 50 nodes); d) 2.32% (GSOM, 100 nodes). The initial approximation for SOM was equidistribution of nodes in a segment on the first principal component with the same variance as for the data set. The initial approximation for GSOM was the mean point. <a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></figcaption>
</figure>
<h2 id="applications">Applications</h2>

<p>The GSOM can be used for many preprocessing tasks in <a href="Data_mining" title="wikilink">Data mining</a>, for <a href="Nonlinear_dimensionality_reduction" title="wikilink">Nonlinear dimensionality reduction</a>, for approximation of principal curves and manifolds, for <a href="cluster_analysis" title="wikilink">clustering</a> and <a href="classification_in_machine_learning" title="wikilink">classification</a>. It gives often the better representation of the data geometry than the SOM (see the classical benchmark for principal curves on the left).</p>
<h2 id="references">References</h2>
<h2 id="bibliography">Bibliography</h2>
<ol>
<li>Liu, Y., Weisberg, R.H., and He, R. (2006) Sea surface temperature patterns on the West Florida Shelf using growing hierarchical self-organizing maps. Journal of Atmospheric and Oceanic Technology, 23, 325–338. <a class="uri" href="http://dx.doi.org/10.1175/JTECH1848.1">http://dx.doi.org/10.1175/JTECH1848.1</a></li>
<li>Hsu, A., Tang, S. and Halgamuge, S. K. (2003) An unsupervised hierarchical dynamic self-organizing approach to cancer class discovery and marker gene identification in microarray data. Bioinformatics 19(16): pp 2131-2140</li>
<li>Alahakoon, D., Halgamuge, S. K. and Sirinivasan, B. (2000) Dynamic Self Organizing Maps With Controlled Growth for Knowledge Discovery, IEEE Transactions on Neural Networks, Special Issue on Knowledge Discovery and Data Mining, 11, pp 601-614.</li>
<li>Alahakoon, D., Halgamuge, S. K. and Sirinivasan, B. (1998) A Structure Adapting Feature Map for Optimal Cluster Representation in Proceedings of The 5th International Conference on Neural Information Processing (ICONIP 98), Kitakyushu, Japan, pp 809-812</li>
<li>Alahakoon, D., Halgamuge, S. K. and Sirinivasan, B. (1998) A Self Growing Cluster Development Approach to Data Mining in Proceedings of IEEE International Conference on Systems, Man and Cybernetics, San Diego, USA, pp 2901-2906</li>
<li>Alahakoon, D. and Halgamuge, S. K. (1998) Knowledge Discovery with Supervised and Unsupervised Self Evolving Neural Networks in Proceedings of 5th International Conference on Soft Computing and Information/Intelligent Systems, Fukuoka, Japan, pp 907-910</li>
</ol>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Self-organizing_map" title="wikilink">Self-organizing map</a></li>
<li><a href="Time_Adaptive_Self-Organizing_Map" title="wikilink">Time Adaptive Self-Organizing Map</a></li>
<li><a href="Elastic_map" title="wikilink">Elastic map</a></li>
<li><a href="Artificial_intelligence" title="wikilink">Artificial intelligence</a></li>
<li><a href="Machine_learning" title="wikilink">Machine learning</a></li>
<li><a href="Data_mining" title="wikilink">Data mining</a></li>
<li><a href="Nonlinear_dimensionality_reduction" title="wikilink">Nonlinear dimensionality reduction</a></li>
</ul>

<p>"</p>

<p><a href="Category:Machine_learning_algorithms" title="wikilink">Category:Machine learning algorithms</a> <a href="Category:Artificial_neural_networks" title="wikilink">Category:Artificial neural networks</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">The illustration is prepared using free software: E.M. Mirkes, <a href="http://www.math.le.ac.uk/people/ag153/homepage/PCA_SOM/PCA_SOM.html">Principal Component Analysis and Self-Organizing Maps: applet</a>. University of Leicester, 2011.<a href="#fnref1">↩</a></li>
</ol>
</section>
</body>
</html>
