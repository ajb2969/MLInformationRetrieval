<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1318">Μ-law algorithm</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Μ-law algorithm</h1>
<hr/>
<figure><b>(Figure)</b>
<figcaption>Companding of μ-law and A-law algorithms</figcaption>
</figure>

<p>The <strong>µ-law algorithm</strong> (sometimes written "<a href="Mu_(letter)" title="wikilink">mu</a>-law", often <a href="typographic_approximation" title="wikilink">approximated</a> as "u-law") is a <a class="uri" href="companding" title="wikilink">companding</a> algorithm, primarily used in 8-bit <a class="uri" href="PCM" title="wikilink">PCM</a> <a href="Digital_data" title="wikilink">digital</a> <a class="uri" href="telecommunication" title="wikilink">telecommunication</a> systems in <a href="North_America" title="wikilink">North America</a> and <a class="uri" href="Japan" title="wikilink">Japan</a>. Companding algorithms reduce the <a href="dynamic_range" title="wikilink">dynamic range</a> of an audio <a href="Signal_(electrical_engineering)" title="wikilink">signal</a>. In analog systems, this can increase the <a href="signal-to-noise_ratio" title="wikilink">signal-to-noise ratio</a> (SNR) achieved during transmission; in the digital domain, it can reduce the quantization error (hence increasing signal to quantization noise ratio). These SNR increases can be traded instead for reduced <a href="Bandwidth_(signal_processing)" title="wikilink">bandwidth</a> for equivalent SNR.</p>

<p>It is similar to the <a href="A-law_algorithm" title="wikilink">A-law algorithm</a> used in regions where digital telecommunication signals are carried on E-1 circuits, e.g. Europe.</p>
<h2 id="algorithm-types">Algorithm types</h2>

<p>There are two forms of this algorithm—an analog version, and a quantized digital version.</p>
<h3 id="continuous">Continuous</h3>

<p>For a given input 

<math display="inline" id="Μ-law_algorithm:0">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

, the equation for μ-law encoding is<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>

<p>

<math display="block" id="Μ-law_algorithm:1">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>F</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mo>sgn</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mfrac>
      <mrow>
       <mi>ln</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mn>1</mn>
         <mo>+</mo>
         <mrow>
          <mi>μ</mi>
          <mrow>
           <mo stretchy="false">|</mo>
           <mi>x</mi>
           <mo stretchy="false">|</mo>
          </mrow>
         </mrow>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mrow>
       <mi>ln</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mn>1</mn>
         <mo>+</mo>
         <mi>μ</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mfrac>
    </mrow>
   </mrow>
   <mrow>
    <mrow>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
    <mo>≤</mo>
    <mi>x</mi>
    <mo>≤</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>F</ci>
      <ci>x</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <ci>sgn</ci>
       <ci>x</ci>
      </apply>
      <apply>
       <divide></divide>
       <apply>
        <ln></ln>
        <apply>
         <plus></plus>
         <cn type="integer">1</cn>
         <apply>
          <times></times>
          <ci>μ</ci>
          <apply>
           <abs></abs>
           <ci>x</ci>
          </apply>
         </apply>
        </apply>
       </apply>
       <apply>
        <ln></ln>
        <apply>
         <plus></plus>
         <cn type="integer">1</cn>
         <ci>μ</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <and></and>
     <apply>
      <leq></leq>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
      <ci>x</ci>
     </apply>
     <apply>
      <leq></leq>
      <share href="#.cmml">
      </share>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F(x)=\operatorname{sgn}(x)\frac{\ln(1+\mu|x|)}{\ln(1+\mu)}~{}~{}~{}~{}-1\leq x\leq
1
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Μ-law_algorithm:2">
 <semantics>
  <mrow>
   <mi>μ</mi>
   <mo>=</mo>
   <mn>255</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>μ</ci>
    <cn type="integer">255</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   μ=255
  </annotation>
 </semantics>
</math>

 (8 bits) in the North American and Japanese standards. It is important to note that the <a href="Range_(mathematics)" title="wikilink">range</a> of this function is −1 to 1.</p>

<p>μ-law expansion is then given by the inverse equation:</p>

<p>

<math display="block" id="Μ-law_algorithm:3">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msup>
      <mi>F</mi>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mo>sgn</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>y</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mn>1</mn>
       <mo>/</mo>
       <mi>μ</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msup>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mn>1</mn>
          <mo>+</mo>
          <mi>μ</mi>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
        <mrow>
         <mo stretchy="false">|</mo>
         <mi>y</mi>
         <mo stretchy="false">|</mo>
        </mrow>
       </msup>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mrow>
    <mrow>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
    <mo>≤</mo>
    <mi>y</mi>
    <mo>≤</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>F</ci>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>y</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <ci>sgn</ci>
       <ci>y</ci>
      </apply>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <ci>μ</ci>
      </apply>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <plus></plus>
         <cn type="integer">1</cn>
         <ci>μ</ci>
        </apply>
        <apply>
         <abs></abs>
         <ci>y</ci>
        </apply>
       </apply>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <and></and>
     <apply>
      <leq></leq>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
      <ci>y</ci>
     </apply>
     <apply>
      <leq></leq>
      <share href="#.cmml">
      </share>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F^{-1}(y)=\operatorname{sgn}(y)(1/\mu)((1+\mu)^{|y|}-1)~{}~{}~{}~{}-1\leq y\leq
1
  </annotation>
 </semantics>
</math>

</p>

<p>The equations are culled from <a href="http://www.cisco.com/en/US/tech/tk1077/technologies_tech_note09186a00801149b3.shtml">Cisco's Waveform Coding Techniques</a>.</p>
<h3 id="discrete">Discrete</h3>

<p>This is defined in ITU-T Recommendation <a class="uri" href="G.711" title="wikilink">G.711</a>.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>

<p>G.711 is unclear about how to code the values at the limit of a range (e.g. whether +31 codes to 0xEF or 0xF0). However, G.191 provides example C code for a μ-law encoder which gives the following encoding. Note the difference between the positive and negative ranges, e.g. the negative range corresponding to +30 to +1 is −31 to −2. This is accounted for by the use of <a href="1's_complement" title="wikilink">1's complement</a> (simple bit inversion) rather than <a href="2's_complement" title="wikilink">2's complement</a> to convert a negative value to a positive value during encoding.</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>Quantized μ-law algorithm</p></td>
<td style="text-align: left;">
<p>14 bit Binary Linear input code</p></td>
<td style="text-align: left;">
<p>8 bit Compressed code</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>+8158 to +4063 in 16 intervals of 256</p></td>
<td style="text-align: left;">
<p>0x80 + interval number</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>+4062 to +2015 in 16 intervals of 128</p></td>
<td style="text-align: left;">
<p>0x90 + interval number</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>+2014 to +991 in 16 intervals of 64</p></td>
<td style="text-align: left;">
<p>0xA0 + interval number</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>+990 to +479 in 16 intervals of 32</p></td>
<td style="text-align: left;">
<p>0xB0 + interval number</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>+478 to +223 in 16 intervals of 16</p></td>
<td style="text-align: left;">
<p>0xC0 + interval number</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>+222 to +95 in 16 intervals of 8</p></td>
<td style="text-align: left;">
<p>0xD0 + interval number</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>+94 to +31 in 16 intervals of 4</p></td>
<td style="text-align: left;">
<p>0xE0 + interval number</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>+30 to +1 in 15 intervals of 2</p></td>
<td style="text-align: left;">
<p>0xF0 + interval number</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0xFF</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>−1</p></td>
<td style="text-align: left;">
<p>0x7F</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>−31 to −2 in 15 intervals of 2</p></td>
<td style="text-align: left;">
<p>0x70 + interval number</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>−95 to −32 in 16 intervals of 4</p></td>
<td style="text-align: left;">
<p>0x60 + interval number</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>−223 to −96 in 16 intervals of 8</p></td>
<td style="text-align: left;">
<p>0x50 + interval number</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>−479 to −224 in 16 intervals of 16</p></td>
<td style="text-align: left;">
<p>0x40 + interval number</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>−991 to −480 in 16 intervals of 32</p></td>
<td style="text-align: left;">
<p>0x30 + interval number</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>−2015 to −992 in 16 intervals of 64</p></td>
<td style="text-align: left;">
<p>0x20 + interval number</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>−4063 to −2016 in 16 intervals of 128</p></td>
<td style="text-align: left;">
<p>0x10 + interval number</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>−8159 to −4064 in 16 intervals of 256</p></td>
<td style="text-align: left;">
<p>0x00 + interval number</p></td>
</tr>
</tbody>
</table>
<h2 id="implementation">Implementation</h2>

<p>There are three ways of implementing a μ-law algorithm:</p>
<dl>
<dt>Analog: Use an amplifier with non-linear gain to achieve companding entirely in the analog domain.<br/>
Non-linear ADC: Use an <a href="analog-to-digital_converter" title="wikilink">analog-to-digital converter</a> with quantization levels which are unequally spaced to match the μ-law algorithm.<br/>
Digital: Use the quantized digital version of the μ-law algorithm to convert data once it is in the digital domain.</dt>
</dl>
<h2 id="usage-justification">Usage justification</h2>

<p>This encoding is used because <a href="Speech_communication" title="wikilink">speech</a> has a wide <a href="dynamic_range" title="wikilink">dynamic range</a>. In the analog world, when mixed with a relatively constant background noise source, the finer detail is lost. Given that the precision of the detail is compromised anyway, and assuming that the signal is to be perceived as audio by a human, one can take advantage of the fact that the perceived <a href="acoustic_intensity_level" title="wikilink">acoustic intensity level</a> or <a class="uri" href="loudness" title="wikilink">loudness</a> is logarithmic by compressing the signal using a logarithmic-response operational amplifier (<a href="Weber-Fechner_law" title="wikilink">Weber-Fechner law</a>). In telecommunications circuits, most of the noise is injected on the lines, thus after the compressor, the intended signal is perceived as significantly louder than the static, compared to an un-compressed source. This became a common solution, and thus, prior to common digital usage, the μ-law specification was developed to define an inter-compatible standard.</p>

<p>In digital systems this pre-existing algorithm had the effect of significantly reducing the number of bits needed to encode recognizable human voice. Using μ-law, a sample could be effectively encoded in as few as 8 bits, a sample size that conveniently matched the symbol size of most standard computers.</p>

<p>μ-law encoding effectively reduced the dynamic range of the signal, thereby increasing the <a href="Channel_coding" title="wikilink">coding</a> efficiency while biasing the signal in a way that results in a signal-to-<a class="uri" href="distortion" title="wikilink">distortion</a> ratio that is greater than that obtained by linear encoding for a given number of bits. This is an early form of perceptual audio encoding.</p>

<p> The μ-law algorithm is also used in the <a href="Au_file_format" title="wikilink">.au format</a>, which dates back at least to the <a href="SPARCstation_1" title="wikilink">SPARCstation 1</a> by Sun Microsystems as the native method used by the /dev/audio interface, widely used as a de facto standard for sound on Unix systems. The au format is also used in various common audio <a href="Application_programming_interface" title="wikilink">APIs</a> such as the classes in the sun.audio <a href="Java_package" title="wikilink">Java package</a> in <a href="Java_platform" title="wikilink">Java</a> 1.1 and in some <a href="C_Sharp_(programming_language)" title="wikilink">C#</a> methods.</p>

<p>This plot illustrates how μ-law concentrates sampling in the smaller (softer) values. The abscissa represents the byte values 0-255 and the vertical axis is the 16-bit linear decoded value of μ-law encoding.</p>
<h2 id="comparison-with-a-law">Comparison with A-law</h2>

<p>The µ-law algorithm provides a slightly larger dynamic range than the A-law at the cost of worse proportional distortion for small signals. By convention, A-law is used for an international connection if at least one country uses it.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Audio_level_compression" title="wikilink">Audio level compression</a></li>
<li><a href="Signal_compression_(disambiguation)" title="wikilink">Signal compression (disambiguation)</a></li>
<li><a class="uri" href="G.711" title="wikilink">G.711</a></li>
</ul>
<h2 id="references">References</h2>
<references>
</references>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.cisco.com/en/US/tech/tk1077/technologies_tech_note09186a00801149b3.shtml">Waveform Coding Techniques</a> – details of implementation</li>
<li><a href="http://focus.ti.com/lit/an/spra163a/spra163a.pdf">A-Law and mu-Law Companding Implementations Using the TMS320C54x</a> (<a class="uri" href="PDF" title="wikilink">PDF</a>)</li>
<li><a href="http://focus.ti.com/lit/an/spra634/spra634.pdf">TMS320C6000 μ-Law and A-Law Companding with Software or the McBSP</a> (<a class="uri" href="PDF" title="wikilink">PDF</a>)</li>
<li><a href="http://hazelware.luggle.com/tutorials/mulawcompression.html">A-law and μ-law realisation (in C)</a> (ctrl-a "highlight all" to see linked black-on-black text).</li>
</ul>

<p>"</p>

<p><a href="Category:Audio_codecs" title="wikilink">Category:Audio codecs</a> <a href="Category:ITU-T_recommendations" title="wikilink">Category:ITU-T recommendations</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
</ol>
</section>
</body>
</html>
