<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1196">Boolean-valued model</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Boolean-valued model</h1>
<hr/>

<p>In <a href="mathematical_logic" title="wikilink">mathematical logic</a>, a <strong>Boolean-valued model</strong> is a generalization of the ordinary <a href="Alfred_Tarski" title="wikilink">Tarskian</a> notion of <a href="structure_(mathematical_logic)" title="wikilink">structure</a> from <a href="model_theory" title="wikilink">model theory</a>. In a Boolean-valued model, the <a href="truth_value" title="wikilink">truth values</a> of <a href="proposition" title="wikilink">propositions</a> are not limited to "true" and "false", but instead take values in some fixed <a href="complete_Boolean_algebra" title="wikilink">complete Boolean algebra</a>.</p>

<p>Boolean-valued models were introduced by <a href="Dana_Scott" title="wikilink">Dana Scott</a>, <a href="Robert_M._Solovay" title="wikilink">Robert M. Solovay</a>, and <a href="Petr_Vopěnka" title="wikilink">Petr Vopěnka</a> in the 1960s in order to help understand <a href="Paul_Cohen_(mathematician)" title="wikilink">Paul Cohen</a>'s method of <a href="forcing_(mathematics)" title="wikilink">forcing</a>. They are also related to Heyting algebra semantics in <a href="intuitionistic_logic" title="wikilink">intuitionistic logic</a>.</p>
<h2 id="definition">Definition</h2>

<p>Fix a complete Boolean algebra <em>B</em><a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> and a <a href="first-order_language" title="wikilink">first-order language</a> <em>L</em>; the <a href="signature_(mathematical_logic)" title="wikilink">signature</a> of <em>L</em> will consist of a collection of constant symbols, function symbols, and relation symbols.</p>

<p>A Boolean-valued model for the language <em>L</em> consists of a universe <em>M</em>, which is a set of elements (or <strong><em>names</em></strong>), together with interpretations for the symbols. Specifically, the model must assign to each constant symbol of <em>L</em> an element of <em>M</em>, and to each <em>n</em>-ary function symbol <em>f</em> of <em>L</em> and each <em>n</em>-tuple <a>0,...,a<sub><em>n</em>-1</sub>&gt; of elements of <em>M</em>, the model must assign an element of <em>M</em> to the term <em>f</em>(a<sub>0</sub>,...,a<sub><em>n</em>-1</sub>).</a></p>

<p>Interpretation of the <a href="atomic_formula" title="wikilink">atomic formulas</a> of <em>L</em> is more complicated. To each pair <em>a</em> and <em>b</em> of elements of <em>M</em>, the model must assign a truth value ||<em>a</em>=<em>b</em>|| to the expression <em>a</em>=<em>b</em>; this truth value is taken from the Boolean algebra <em>B</em>. Similarly, for each <em>n</em>-ary relation symbol <em>R</em> of <em>L</em> and each <em>n</em>-tuple <a>0,...,a<sub><em>n</em>-1</sub>&gt; of elements of <em>M</em>, the model must assign an element of <em>B</em> to be the truth value ||<em>R</em>(a<sub>0</sub>,...,a<sub><em>n</em>-1</sub>)||.</a></p>
<h2 id="interpretation-of-other-formulas-and-sentences">Interpretation of other formulas and sentences</h2>

<p>The truth values of the atomic formulas can be used to reconstruct the truth values of more complicated formulas, using the structure of the Boolean algebra. For propositional connectives, this is easy; one simply applies the corresponding Boolean operators to the truth values of the subformulae. For example, if φ(<em>x</em>) and ψ(<em>y</em>,<em>z</em>) are formulas with one and two <a href="free_variable" title="wikilink">free variables</a>, respectively, and if <em>a</em>, <em>b</em>, <em>c</em> are elements of the model's universe to be substituted for <em>x</em>, <em>y</em>, and <em>z</em>, then the truth value of</p>

<p>

<math display="block" id="Boolean-valued_model:0">
 <semantics>
  <mrow>
   <mrow>
    <mi>ϕ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>a</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>∧</mo>
   <mrow>
    <mi>ψ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>b</mi>
     <mo>,</mo>
     <mi>c</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <times></times>
     <ci>ϕ</ci>
     <ci>a</ci>
    </apply>
    <apply>
     <times></times>
     <ci>ψ</ci>
     <interval closure="open">
      <ci>b</ci>
      <ci>c</ci>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi(a)\land\psi(b,c)
  </annotation>
 </semantics>
</math>

 is simply</p>

<p>

<math display="block" id="Boolean-valued_model:1">
 <semantics>
  <mrow>
   <mrow>
    <mo fence="true">||</mo>
    <mrow>
     <mrow>
      <mi>ϕ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>a</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>∧</mo>
     <mrow>
      <mi>ψ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>b</mi>
       <mo>,</mo>
       <mi>c</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo fence="true">||</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo fence="true">||</mo>
     <mrow>
      <mi>ϕ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>a</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo fence="true">||</mo>
    </mrow>
    <mo rspace="7.5pt">∧</mo>
    <mrow>
     <mo fence="true">||</mo>
     <mrow>
      <mi>ψ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>b</mi>
       <mo>,</mo>
       <mi>c</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo fence="true">||</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="latexml">norm</csymbol>
     <apply>
      <and></and>
      <apply>
       <times></times>
       <ci>ϕ</ci>
       <ci>a</ci>
      </apply>
      <apply>
       <times></times>
       <ci>ψ</ci>
       <interval closure="open">
        <ci>b</ci>
        <ci>c</ci>
       </interval>
      </apply>
     </apply>
    </apply>
    <apply>
     <and></and>
     <apply>
      <csymbol cd="latexml">norm</csymbol>
      <apply>
       <times></times>
       <ci>ϕ</ci>
       <ci>a</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">norm</csymbol>
      <apply>
       <times></times>
       <ci>ψ</ci>
       <interval closure="open">
        <ci>b</ci>
        <ci>c</ci>
       </interval>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ||\phi(a)\land\psi(b,c)||=||\phi(a)||\ \land\ ||\psi(b,c)||
  </annotation>
 </semantics>
</math>

</p>

<p>The completeness of the Boolean algebra is required to define truth values for quantified formulas. If φ(<em>x</em>) is a formula with free variable <em>x</em> (and possibly other free variables that are suppressed), then</p>

<p>

<math display="block" id="Boolean-valued_model:2">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo fence="true">||</mo>
     <mrow>
      <mo>∃</mo>
      <mrow>
       <mi>x</mi>
       <mi>ϕ</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo fence="true">||</mo>
    </mrow>
    <mo>=</mo>
    <mrow>
     <munder>
      <mo largeop="true" mathsize="160%" movablelimits="false" stretchy="false" symmetric="true">⋁</mo>
      <mrow>
       <mi>a</mi>
       <mo>∈</mo>
       <mi>M</mi>
      </mrow>
     </munder>
     <mrow>
      <mo fence="true">||</mo>
      <mrow>
       <mi>ϕ</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>a</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo fence="true">||</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="latexml">norm</csymbol>
     <apply>
      <exists></exists>
      <apply>
       <times></times>
       <ci>x</ci>
       <ci>ϕ</ci>
       <ci>x</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <or></or>
      <apply>
       <in></in>
       <ci>a</ci>
       <ci>M</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">norm</csymbol>
      <apply>
       <times></times>
       <ci>ϕ</ci>
       <ci>a</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ||\exists x\phi(x)||=\bigvee_{a\in M}||\phi(a)||,
  </annotation>
 </semantics>
</math>

 where the right-hand side is to be understood as the <a class="uri" href="supremum" title="wikilink">supremum</a> in <em>B</em> of the set of all truth values ||φ(<em>a</em>)|| as <em>a</em> ranges over <em>M</em>.</p>

<p>The truth value of a formula is sometimes referred to as its <a class="uri" href="probability" title="wikilink">probability</a>. However, these are not probabilities in the ordinary sense, because they are not <a href="real_number" title="wikilink">real numbers</a>, but rather elements of the complete Boolean algebra <em>B</em>.</p>
<h2 id="boolean-valued-models-of-set-theory">Boolean-valued models of set theory</h2>

<p>Given a complete Boolean algebra <em>B</em><a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> there is a Boolean-valued model denoted by <em>V<sup>B</sup></em>, which is the Boolean-valued analogue of the <a href="von_Neumann_universe" title="wikilink">von Neumann universe</a> <em>V</em>. (Strictly speaking, <em>V<sup>B</sup></em> is a <a href="proper_class" title="wikilink">proper class</a>, so we need to reinterpret what it means to be a <a href="model_theory" title="wikilink">model</a> appropriately.) Informally, the elements of <em>V<sup>B</sup></em> are "Boolean-valued sets". Given an ordinary set <em>A</em>, every set either is or is not a member; but given a Boolean-valued set, every set has a certain, fixed "probability" of being a member of <em>A</em>. Again, the "probability" is an element of <em>B</em>, not a real number. The concept of Boolean-valued sets resembles, but is not the same as, the notion of a <a href="fuzzy_set" title="wikilink">fuzzy set</a>.</p>

<p>The ("probabilistic") elements of the Boolean-valued set, in turn, are also Boolean-valued sets, whose elements are also Boolean-valued sets, and so on. In order to obtain a non-circular definition of Boolean-valued set, they are defined inductively in a hierarchy similar to the <a href="cumulative_hierarchy" title="wikilink">cumulative hierarchy</a>. For each ordinal α of <em>V</em>, the set <em>V<sup>B</sup><sub>α</sub></em> is defined as follows.</p>
<ul>
<li><em>V</em><sup>B</sup><sub>0</sub> is the empty set.</li>
<li><em>V<sup>B</sup><sub>α+1</sub></em> is the set of all functions from <em>V<sup>B</sup><sub>α</sub></em> to <em>B</em>. (Such a function represents a "probabilistic" <a class="uri" href="subset" title="wikilink">subset</a> of <em>V<sup>B</sup><sub>α</sub></em>; if <em>f</em> is such a function, then for any <em>x</em>∈<em>V<sup>B</sup><sub>α</sub></em>, <em>f</em>(<em>x</em>) is the probability that <em>x</em> is in the set.)</li>
<li>If α is a limit ordinal, <em>V<sup>B</sup><sub>α</sub></em> is the union of <em>V<sup>B</sup><sub>β</sub></em> for β&lt;α</li>
</ul>

<p>The class <em>V<sup>B</sup></em> is defined to be the union of all sets <em>V<sup>B</sup><sub>α</sub></em>.</p>

<p>It is also possible to relativize this entire construction to some transitive model <em>M</em> of <a href="Zermelo-Fraenkel_set_theory" title="wikilink">ZF</a> (or sometimes a fragment thereof). The Boolean-valued model <em>M</em><sup><em>B</em></sup> is obtained by applying the above construction <em>inside</em> <em>M</em>. The restriction to transitive models is not serious, as the <a href="Mostowski_collapse" title="wikilink">Mostowski collapsing theorem</a> implies that every "reasonable" (well-founded, extensional) model is isomorphic to a transitive one. (If the model <em>M</em> is not transitive things get messier, as <em>M</em>'s interpretation of what it means to be a "function" or an "ordinal" may differ from the "external" interpretation.)</p>

<p>Once the elements of <em>V</em><sup>B</sup> have been defined as above, it is necessary to define <em>B</em>-valued relations of equality and membership on <em>V<sup>B</sup></em>. Here a <em>B</em>-valued relation on <em>V<sup>B</sup></em> is a function from <em>V<sup>B</sup></em>×<em>V<sup>B</sup></em> to <em>B</em>. To avoid confusion with the usual equality and membership, these are denoted by ||<em>x</em>=<em>y</em>|| and ||<em>x</em>∈<em>y</em>|| for <em>x</em> and <em>y</em> in <em>V<sup>B</sup></em>. They are defined as follows:</p>
<dl>
<dd>||<em>x</em>∈<em>y</em>|| is defined to be ∑<sub><em>t</em>∈Dom(<em>y</em>)</sub> ||<em>x</em>=<em>t</em>|| ∧ <em>y</em>(<em>t</em>)   ("<em>x</em> is in <em>y</em> if it is equal to something in <em>y</em>").
</dd>
<dd>||<em>x</em>=<em>y</em>|| is defined to be ||<em>x</em>⊆<em>y</em>||∧||y⊆<em>x</em>||   ("<em>x</em> equals <em>y</em> if <em>x</em> and <em>y</em> are both subsets of each other"), where
</dd>
<dd>||<em>x</em>⊆<em>y</em>|| is defined to be ∏<sub><em>t</em>∈Dom(<em>x</em>)</sub> <em>x</em>(<em>t</em>)⇒||<em>t</em>∈<em>y</em>||   ("<em>x</em> is a subset of <em>y</em> if all elements of <em>x</em> are in <em>y</em>")
</dd>
</dl>

<p>The symbols ∑ and ∏ denote the least upper bound and greatest lower bound operations, respectively, in the complete Boolean algebra <em>B</em>. At first sight the definitions above appear to be circular: ||  ∈ || depends on || = ||, which depends on || ⊆ ||, which depends on || ∈ ||. However, a close examination shows that the definition of || ∈ || only depends on || ∈ || for elements of smaller rank, so || ∈ || and ||  = || are well defined functions from <em>V<sup>B</sup></em>×<em>V<sup>B</sup></em> to <em>B</em>.</p>

<p>It can be shown that the <em>B</em>-valued relations || ∈ || and || = || on <em>V<sup>B</sup></em> make <em>V<sup>B</sup></em> into a Boolean-valued model of set theory. Each sentence of first order set theory with no free variables has a truth value in <em>B</em>; it must be shown that the axioms for equality and all the axioms of ZF set theory (written without free variables) have truth value 1 (the largest element of <em>B</em>). This proof is straightforward, but it is long because there are many different axioms that need to be checked.</p>
<h2 id="relationship-to-forcing">Relationship to forcing</h2>

<p>Set theorists use a technique called <a href="forcing_(mathematics)" title="wikilink">forcing</a> to obtain <a href="independence_(mathematical_logic)" title="wikilink">independence results</a> and to construct models of set theory for other purposes. The method was originally developed by <a href="Paul_Cohen_(mathematician)" title="wikilink">Paul Cohen</a> but has been greatly extended since then. In one form, forcing "adds to the universe" a <a href="generic_filter" title="wikilink">generic</a> subset of a <a class="uri" href="poset" title="wikilink">poset</a>, the poset being designed to impose interesting properties on the newly-added object. The wrinkle is that (for interesting posets) it can be proved that there simply <em>is</em> no such generic subset of the poset. There are three usual ways of dealing with this:</p>
<ul>
<li><strong>syntactic forcing</strong> A <em>forcing relation</em> 

<math display="inline" id="Boolean-valued_model:3">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mo>⊩</mo>
   <mi>ϕ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">forces</csymbol>
    <ci>p</ci>
    <ci>ϕ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\Vdash\phi
  </annotation>
 </semantics>
</math>


 is defined between elements <em>p</em> of the poset and formulas φ of the <em>forcing language</em>. This relation is defined syntactically and has no semantics; that is, no model is ever produced. Rather, starting with the assumption that ZFC (or some other axiomatization of set theory) proves the independent statement, one shows that ZFC must also be able to prove a contradiction. However, the forcing is "over <em>V</em>"; that is, it is not necessary to start with a countable transitive model. See Kunen (1980) for an exposition of this method.</li>
<li><strong>countable transitive models</strong> One starts with a <a href="countable_set" title="wikilink">countable</a> <a href="transitive_set" title="wikilink">transitive</a> model <em>M</em> of as much of set theory as is needed for the desired purpose, and that contains the poset. Then there <em>do</em> exist filters on the poset that are generic <em>over M</em>; that is, that meet all dense open subsets of the poset that happen also to be elements of <em>M</em>.</li>
<li><strong>fictional generic objects</strong> Commonly, set theorists will simply <em>pretend</em> that the poset has a subset that is generic over all of <em>V</em>. This generic object, in nontrivial cases, cannot be an element of <em>V</em>, and therefore "does not really exist". (Of course, it is a point of philosophical contention whether <em>any</em> sets "really exist", but that is outside the scope of the current discussion.) Perhaps surprisingly, with a little practice this method is useful and reliable, but it can be philosophically unsatisfying.</li>
</ul>
<h3 id="boolean-valued-models-and-syntactic-forcing">Boolean-valued models and syntactic forcing</h3>

<p>Boolean-valued models can be used to give semantics to syntactic forcing; the price paid is that the semantics is not 2-valued ("true or false"), but assigns truth values from some complete Boolean algebra. Given a forcing poset <em>P</em>, there is a corresponding complete Boolean algebra <em>B</em>, often obtained as the collection of <a href="regular_open_set" title="wikilink">regular open subsets</a> of <em>P</em>, where the <a class="uri" href="topology" title="wikilink">topology</a> on <em>P</em> is generated by <em>cones</em> (sets of the form {<em>q</em>|<em>q</em>≤<em>p</em>}, for fixed <em>p</em>). (Other approaches to constructing <em>B</em> are discussed below.)</p>

<p>Now the order on <em>B</em> (after removing the zero element) can replace <em>P</em> for forcing purposes, and the forcing relation can be interpreted semantically by saying that, for <em>p</em> an element of <em>B</em> and φ a formula of the forcing language,</p>

<p>

<math display="block" id="Boolean-valued_model:4">
 <semantics>
  <mrow>
   <mrow>
    <mi>p</mi>
    <mo>⊩</mo>
    <mi>ϕ</mi>
   </mrow>
   <mo>⇔</mo>
   <mrow>
    <mi>p</mi>
    <mo>≤</mo>
    <mrow>
     <mo fence="true">||</mo>
     <mi>ϕ</mi>
     <mo fence="true">||</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">iff</csymbol>
    <apply>
     <csymbol cd="latexml">forces</csymbol>
     <ci>p</ci>
     <ci>ϕ</ci>
    </apply>
    <apply>
     <leq></leq>
     <ci>p</ci>
     <apply>
      <csymbol cd="latexml">norm</csymbol>
      <ci>ϕ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\Vdash\phi\iff p\leq||\phi||
  </annotation>
 </semantics>
</math>

 where ||φ|| is the truth value of φ in <em>V</em><sup><em>B</em></sup>.</p>

<p>This approach succeeds in assigning a semantics to forcing over <em>V</em> without resorting to fictional generic objects. The disadvantages are that the semantics is not 2-valued, and that the combinatorics of <em>B</em> are often more complicated than those of the underlying poset <em>P</em>.</p>
<h3 id="boolean-valued-models-and-generic-objects-over-countable-transitive-models">Boolean-valued models and generic objects over countable transitive models</h3>

<p>One interpretation of forcing starts with a countable transitive model <em>M</em> of ZF set theory, a partially ordered set <em>P</em>, and a "generic" subset <em>G</em> of <em>P</em>, and constructs a new model of ZF set theory from these objects. (The conditions that the model be countable and transitive simplify some technical problems, but are not essential.) Cohen's construction can be carried out using Boolean-valued models as follows.</p>
<ul>
<li>Construct a complete Boolean algebra <em>B</em> as the complete Boolean algebra "generated by" the poset <em>P</em>.</li>
<li>Construct an ultrafilter <em>U</em> on <em>B</em> (or equivalently a homomorphism from <em>B</em> to the Boolean algebra {true, false}) from the generic subset <em>G</em> of <em>P</em>.</li>
<li>Use the homomorphism from <em>B</em> to {true, false} to turn the Boolean-valued model <em>M<sup>B</sup></em> of the section above into an ordinary model of ZF.</li>
</ul>

<p>We now explain these steps in more detail.</p>

<p>For any poset <em>P</em> there is a complete Boolean algebra <em>B</em> and a map <em>e</em> from <em>P</em> to <em>B</em><sup>+</sup> (the non-zero elements of <em>B</em>) such that the image is dense, <em>e</em>(<em>p</em>)≤<em>e</em>(<em>q</em>) whenever <em>p</em>≤<em>q</em>, and <em>e</em>(<em>p</em>)<em>e</em>(<em>q</em>)=0 whenever <em>p</em> and <em>q</em> are incompatible. This Boolean algebra is unique up to isomorphism. It can be constructed as the algebra of regular open sets in the topological space of <em>P</em> (with underlying set <em>P</em>, and a base given by the sets <em>U</em><sub><em>p</em></sub> of elements <em>q</em> with <em>q</em>≤<em>p</em>).</p>

<p>The map from the poset <em>P</em> to the complete Boolean algebra <em>B</em> is not injective in general. The map is injective if and only if <em>P</em> has the following property: if every <em>r</em>≤<em>p</em> is compatible with <em>q</em>, then <em>p</em>≤<em>q</em>.</p>

<p>The ultrafilter <em>U</em> on <em>B</em> is defined to be the set of elements <em>b</em> of <em>B</em> that are greater than some element of (the image of) <em>G</em>. Given an ultrafilter <em>U</em> on a Boolean algebra, we get a homomorphism to {true, false} by mapping <em>U</em> to true and its complement to false. Conversely, given such a homomorphism, the inverse image of true is an ultrafilter, so ultrafilters are essentially the same as homomorphisms to {true, false}. (Algebraists might prefer to use maximal ideals instead of ultrafilters: the complement of an ultrafilter is a maximal ideal, and conversely the complement of a maximal ideal is an ultrafilter.)</p>

<p>If <em>g</em> is a homomorphism from a Boolean algebra <em>B</em> to a Boolean algebra <em>C</em> and <em>M<sup>B</sup></em> is any <em>B</em>-valued model of ZF (or of any other theory for that matter) we can turn <em>M<sup>B</sup></em> into a <em>C</em> -valued model by applying the homomorphism <em>g</em> to the value of all formulas. In particular if <em>C</em> is {true, false} we get a {true, false}-valued model. This is almost the same as an ordinary model: in fact we get an ordinary model on the set of equivalence classes under || = || of a {true, false}-valued model. So we get an ordinary model of ZF set theory by starting from <em>M</em>, a Boolean algebra <em>B</em>, and an ultrafilter <em>U</em> on <em>B</em>. (The model of ZF constructed like this is not transitive. In practice one applies the <a href="Mostowski_collapse" title="wikilink">Mostowski collapsing theorem</a> to turn this into a transitive model.)</p>

<p>We have seen that forcing can be done using Boolean-valued models, by constructing a Boolean algebra with ultrafilter from a poset with a generic subset. It is also possible to go back the other way: given a Boolean algebra <em>B</em>, we can form a poset <em>P</em> of all the nonzero elements of <em>B</em>, and a generic ultrafilter on <em>B</em> restricts to a generic set on <em>P</em>. So the techniques of forcing and Boolean-valued models are essentially equivalent.</p>
<h2 id="notes">Notes</h2>
<references>
</references>
<h2 id="references">References</h2>
<ul>
<li>Bell, J. L. (1985) <em>Boolean-Valued Models and Independence Proofs in Set Theory</em>, Oxford. ISBN 0-19-853241-5</li>
<li></li>
<li></li>
<li></li>
<li>

<p>Contains an account of Boolean-valued models and applications to Riesz spaces, Banach spaces and algebras.</p></li>
<li>

<p>Contains an account of forcing and Boolean-valued models written for mathematicians who are not set theorists.</p></li>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Model_theory" title="wikilink">Category:Model theory</a> <a href="Category:Boolean_algebra" title="wikilink">Category:Boolean algebra</a> <a href="Category:Forcing_(mathematics)" title="wikilink">Category:Forcing (mathematics)</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><em>B</em> here is assumed to be <em>nondegenerate</em>; that is, 0 and 1 must be distinct elements of <em>B</em>. Authors writing on Boolean-valued models typically take this requirement to be part of the definition of "Boolean algebra", but authors writing on Boolean algebras in general often do not.<a href="#fnref1">↩</a></li>
<li id="fn2"></li>
</ol>
</section>
</body>
</html>
