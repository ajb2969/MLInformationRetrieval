<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1176">Petri net</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Petri net</h1>
<hr/>

<p>A <strong>Petri net</strong> (also known as a <strong>place/transition net</strong> or <strong>P/T net</strong>) is one of several <a class="uri" href="mathematical" title="wikilink">mathematical</a> <a href="modeling_language" title="wikilink">modeling languages</a> for the description of <a href="distributed_systems" title="wikilink">distributed systems</a>. A Petri net is a directed <a href="bipartite_graph" title="wikilink">bipartite graph</a>, in which the nodes represent transitions (i.e. events that may occur, signified by bars) and places (i.e. conditions, signified by circles). The directed arcs describe which places are pre- and/or postconditions for which transitions (signified by arrows). Some sources<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> state that Petri nets were invented in August 1939 by <a href="Carl_Adam_Petri" title="wikilink">Carl Adam Petri</a> — at the age of 13 — for the purpose of describing chemical processes.</p>

<p>Like industry standards such as <a href="Unified_Modeling_Language" title="wikilink">UML</a> <a href="activity_diagram" title="wikilink">activity diagrams</a>, <a class="uri" href="BPMN" title="wikilink">BPMN</a> and <a href="Event-driven_process_chain" title="wikilink">EPCs</a>, Petri nets offer a <a href="diagram" title="wikilink">graphical notation</a> for stepwise processes that include choice, <a class="uri" href="iteration" title="wikilink">iteration</a>, and <a href="Concurrent_computing" title="wikilink">concurrent execution</a>. Unlike these standards, Petri nets have an exact mathematical definition of their execution semantics, with a well-developed mathematical theory for process analysis.</p>
<figure><b>(Figure)</b>
<figcaption>(a) Petri net trajectory example</figcaption>
</figure>
<h2 id="petri-net-basics">Petri net basics</h2>

<p>A Petri net consists of <em>places</em>, <em>transitions</em>, and <em><a href="graph_theory" title="wikilink">arcs</a></em>. Arcs run from a place to a transition or vice versa, never between places or between transitions. The places from which an arc runs to a transition are called the <em>input places</em> of the transition; the places to which arcs run from a transition are called the <em>output places</em> of the transition.</p>

<p>Graphically, places in a Petri net may contain a discrete number of marks called <em>tokens</em>. Any distribution of tokens over the places will represent a configuration of the net called a <em>marking</em>. In an abstract sense relating to a Petri net diagram, a transition of a Petri net may <em>fire</em> if it is <em>enabled</em>, <em>i.e.</em> there are sufficient tokens in all of its input places; when the transition fires, it consumes the required input tokens, and creates tokens in its output places. A firing is atomic, i.e., a single non-interruptible step.</p>

<p>Unless an <em>execution policy</em> is defined, the execution of Petri nets is <a href="Nondeterministic_algorithm" title="wikilink">nondeterministic</a>: when multiple transitions are enabled at the same time, any one of them may fire.</p>

<p>Since firing is nondeterministic, and multiple tokens may be present anywhere in the net (even in the same place), Petri nets are well suited for modeling the <a href="Concurrency_(computer_science)" title="wikilink">concurrent</a> behavior of distributed systems.</p>
<h2 id="formal-definition-and-basic-terminology">Formal definition and basic terminology</h2>

<p>Petri nets are <a href="State_transition_system" title="wikilink">state-transition systems</a> that extend a class of nets called elementary nets.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>

<p><strong>Definition 1.</strong> A <em>net</em> is a triple 

<math display="inline" id="Petri_net:0">
 <semantics>
  <mrow>
   <mi>N</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>P</mi>
    <mo>,</mo>
    <mi>T</mi>
    <mo>,</mo>
    <mi>F</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>N</ci>
    <vector>
     <ci>P</ci>
     <ci>T</ci>
     <ci>F</ci>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N=(P,T,F)
  </annotation>
 </semantics>
</math>

 where:</p>
<ol>
<li>

<math display="inline" id="Petri_net:1">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Petri_net:2">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

 are <em>disjoint</em> finite sets of <em>places</em> and <em>transitions</em>, respectively.</li>
<li>

<math display="inline" id="Petri_net:3">
 <semantics>
  <mrow>
   <mi>F</mi>
   <mo>⊂</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>P</mi>
      <mo>×</mo>
      <mi>T</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∪</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>T</mi>
      <mo>×</mo>
      <mi>P</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <ci>F</ci>
    <apply>
     <union></union>
     <apply>
      <times></times>
      <ci>P</ci>
      <ci>T</ci>
     </apply>
     <apply>
      <times></times>
      <ci>T</ci>
      <ci>P</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F\subset(P\times T)\cup(T\times P)
  </annotation>
 </semantics>
</math>

 is a set of <em>arcs</em> (or flow relations).</li>
</ol>

<p><strong>Definition 2.</strong> Given a net <em>N</em> = (<em>P</em>, <em>T</em>, <em>F</em> ), a <em>configuration</em> is a set <em>C</em> so that <em>C</em> <big>⊆</big> <em>P</em>.</p>

<p> <strong>Definition 3.</strong> An <em>elementary net</em> is a net of the form <em>EN</em> = (<em>N</em>, <em>C</em> ) where:</p>
<ol>
<li><em>N</em> = (<em>P</em>, <em>T</em>, <em>F</em> ) is a net.</li>
<li><em>C</em> is such that <em>C</em> <big>⊆</big> <em>P</em> is a <em>configuration</em>.</li>
</ol>

<p><strong>Definition 4.</strong> A <em>Petri net</em> is a net of the form <em>PN</em> = (<em>N</em>, <em>M</em>, <em>W</em> ), which extends the elementary net so that:</p>
<ol>
<li><em>N</em> = (<em>P</em>, <em>T</em>, <em>F</em> ) is a net.</li>
<li><em>M</em> : <em>P</em> <big>→</big> <em>Z</em> is a place <a class="uri" href="multiset" title="wikilink">multiset</a>, where <em>Z</em> is a countable set. <em>M</em> extends the concept of <em>configuration</em> and is commonly described with reference to Petri net diagrams as a <em>marking</em>.</li>
<li><em>W</em> : <em>F</em> <big>→</big> <em>Z</em> is an arc <a class="uri" href="multiset" title="wikilink">multiset</a>, so that the count (or weight) for each arc is a measure of the arc <em>multiplicity</em>.</li>
</ol>

<p>If a Petri net is equivalent to an elementary net, then <em>Z</em> can be the countable set {0,1} and those elements in <em>P</em> that map to 1 under <em>M</em> form a configuration. Similarly, if a Petri net is not an elementary net, then the <a class="uri" href="multiset" title="wikilink">multiset</a> <em>M</em> can be interpreted as representing a non-singleton set of configurations. In this respect, <em>M</em> extends the concept of configuration for elementary nets to Petri nets.</p>

<p>In the diagram of a Petri net (see top figure right), places are conventionally depicted with circles, transitions with long narrow rectangles and arcs as one-way arrows that show connections of places to transitions or transitions to places. If the diagram were of an elementary net, then those places in a configuration would be conventionally depicted as circles, where each circle encompasses a single dot called a <em>token</em>. In the given diagram of a Petri net (see right), the place circles may encompass more than one token to show the number of times a place appears in a configuration. The configuration of tokens distributed over an entire Petri net diagram is called a <em>marking</em>.</p>

<p>In the top figure (see right), the place <em>p<sub>1</sub></em> is an input place of transition <em>t</em>; whereas, the place <em>p<sub>2</sub></em> is an output place to the same transition. Let <em>PN<sub>0</sub></em> (Fig. top) be a Petri net with a marking configured <em>M<sub>0</sub></em> and <em>PN<sub>1</sub></em> (Fig. bottom) be a Petri net with a marking configured <em>M<sub>1</sub></em>. The configuration of <em>PN<sub>0</sub></em> <em>enable</em> transition <em>t</em> through the property that all input places have sufficient number of tokens (shown in the figures as dots) "equal to or greater" than the multiplicities on their respective arcs to <em>t</em>. Once and only once a transition is enabled will the transition fire. In this example, the <em>firing</em> of transition <em>t</em> generates a map that has the marking configured <em>M<sub>1</sub></em> in the image of <em>M<sub>0</sub></em> and results in Petri net <em>PN<sub>1</sub></em>, seen in the bottom figure. In the diagram, the firing rule for a transition can be characterised by subtracting a number of tokens from its input places equal to the multiplicity of the respective input arcs and accumulating a new number of tokens at the output places equal to the multiplicity of the respective output arcs.</p>

<p><strong>Remark 1.</strong> The precise meaning of "equal to or greater" will depend on the precise algebraic properties of addition being applied on <em>Z</em> in the firing rule, where subtle variations on the algebraic properties can lead to other classes of Petri nets; for example, Algebraic Petri nets.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>

<p>The following formal definition is loosely based on . Many alternative definitions exist.</p>
<h3 id="syntax">Syntax</h3>

<p>A <strong>Petri net graph</strong> (called <em>Petri net</em> by some, but see below) is a 3-<a class="uri" href="tuple" title="wikilink">tuple</a> 

<math display="inline" id="Petri_net:4">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>S</mi>
   <mo>,</mo>
   <mi>T</mi>
   <mo>,</mo>
   <mi>W</mi>
   <mo rspace="0.8pt" stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <ci>S</ci>
    <ci>T</ci>
    <ci>W</ci>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (S,T,W)\!
  </annotation>
 </semantics>
</math>

, where</p>
<ul>
<li><em>S</em> is a <a href="finite_set" title="wikilink">finite set</a> of <em>places</em></li>
<li><em>T</em> is a finite set of <em>transitions</em></li>
<li><em>S</em> and <em>T</em> are <a href="Disjoint_sets" title="wikilink">disjoint</a>, i.e. no object can be both a place and a transition</li>
<li>

<math display="inline" id="Petri_net:5">
 <semantics>
  <mrow>
   <mi>W</mi>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>S</mi>
       <mo>×</mo>
       <mi>T</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>∪</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>T</mi>
       <mo>×</mo>
       <mi>S</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>→</mo>
    <mi>ℕ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>W</ci>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <union></union>
      <apply>
       <times></times>
       <ci>S</ci>
       <ci>T</ci>
      </apply>
      <apply>
       <times></times>
       <ci>T</ci>
       <ci>S</ci>
      </apply>
     </apply>
     <ci>ℕ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W:(S\times T)\cup(T\times S)\to\mathbb{N}
  </annotation>
 </semantics>
</math>

 is a <a class="uri" href="multiset" title="wikilink">multiset</a> of <a href="directed_edge" title="wikilink">arcs</a>, i.e. it assigns to each arc a non-negative integer <em>arc multiplicity</em> (or weight); note that no arc may connect two places or two transitions.</li>
</ul>

<p>The <em>flow relation</em> is the set of arcs

<math display="block" id="Petri_net:6">
 <semantics>
  <mrow>
   <mi>F</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mi>y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo fence="true">∣</mo>
      <mrow>
       <mi>W</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo>,</mo>
        <mi>y</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>></mo>
     </mrow>
     <mn>0</mn>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>F</ci>
    <set>
     <apply>
      <times></times>
      <interval closure="open">
       <ci>x</ci>
       <ci>y</ci>
      </interval>
      <apply>
       <csymbol cd="latexml">ket</csymbol>
       <apply>
        <times></times>
        <ci>W</ci>
        <interval closure="open">
         <ci>x</ci>
         <ci>y</ci>
        </interval>
       </apply>
      </apply>
      <cn type="integer">0</cn>
     </apply>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F=\{(x,y)\mid W(x,y)>0\}
  </annotation>
 </semantics>
</math>

. In many textbooks, arcs can only have multiplicity 1. These texts often define Petri nets using <em>F</em> instead of <em>W</em>. When using this convention, a Petri net graph is a <a href="bipartite_graph" title="wikilink">bipartite</a> <a class="uri" href="multigraph" title="wikilink">multigraph</a> 

<math display="inline" id="Petri_net:7">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi>S</mi>
    <mo>∪</mo>
    <mi>T</mi>
   </mrow>
   <mo>,</mo>
   <mi>F</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <apply>
     <union></union>
     <ci>S</ci>
     <ci>T</ci>
    </apply>
    <ci>F</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (S\cup T,F)
  </annotation>
 </semantics>
</math>

 with node partitions <em>S</em> and <em>T</em>.</p>

<p>The <em>preset</em> of a transition <em>t</em> is the set of its <em>input places</em>

<math display="block" id="Petri_net:8">
 <semantics>
  <mrow>
   <mmultiscripts>
    <mi>t</mi>
    <mprescripts></mprescripts>
    <none></none>
    <mo>∙</mo>
   </mmultiscripts>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mi>s</mi>
     <mo>∈</mo>
     <mi>S</mi>
    </mrow>
    <mo>∣</mo>
    <mrow>
     <mrow>
      <mi>W</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>s</mi>
       <mo>,</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>></mo>
     <mn>0</mn>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>t</ci>
     <ci>normal-∙</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <apply>
      <in></in>
      <ci>s</ci>
      <ci>S</ci>
     </apply>
     <apply>
      <gt></gt>
      <apply>
       <times></times>
       <ci>W</ci>
       <interval closure="open">
        <ci>s</ci>
        <ci>t</ci>
       </interval>
      </apply>
      <cn type="integer">0</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {}^{\bullet}t=\{s\in S\mid W(s,t)>0\}
  </annotation>
 </semantics>
</math>

; its <em>postset</em> is the set of its <em>output places</em>

<math display="block" id="Petri_net:9">
 <semantics>
  <mrow>
   <msup>
    <mi>t</mi>
    <mo>∙</mo>
   </msup>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mi>s</mi>
     <mo>∈</mo>
     <mi>S</mi>
    </mrow>
    <mo>∣</mo>
    <mrow>
     <mrow>
      <mi>W</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo>,</mo>
       <mi>s</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>></mo>
     <mn>0</mn>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>t</ci>
     <ci>normal-∙</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <apply>
      <in></in>
      <ci>s</ci>
      <ci>S</ci>
     </apply>
     <apply>
      <gt></gt>
      <apply>
       <times></times>
       <ci>W</ci>
       <interval closure="open">
        <ci>t</ci>
        <ci>s</ci>
       </interval>
      </apply>
      <cn type="integer">0</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t^{\bullet}=\{s\in S\mid W(t,s)>0\}
  </annotation>
 </semantics>
</math>

. Definitions of pre- and postsets of places are analogous.</p>

<p>A <em>marking</em> of a Petri net (graph) is a multiset of its places, i.e., a mapping 

<math display="inline" id="Petri_net:10">
 <semantics>
  <mrow>
   <mi>M</mi>
   <mo>:</mo>
   <mrow>
    <mi>S</mi>
    <mo>→</mo>
    <mi>ℕ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>M</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>S</ci>
     <ci>ℕ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M:S\to\mathbb{N}
  </annotation>
 </semantics>
</math>

. We say the marking assigns to each place a number of <em>tokens</em>.</p>

<p>A <strong>Petri net</strong> (called <em>marked Petri net</em> by some, see above) is a 4-tuple 

<math display="inline" id="Petri_net:11">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>S</mi>
   <mo>,</mo>
   <mi>T</mi>
   <mo>,</mo>
   <mi>W</mi>
   <mo>,</mo>
   <msub>
    <mi>M</mi>
    <mn>0</mn>
   </msub>
   <mo rspace="0.8pt" stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <ci>S</ci>
    <ci>T</ci>
    <ci>W</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>M</ci>
     <cn type="integer">0</cn>
    </apply>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (S,T,W,M_{0})\!
  </annotation>
 </semantics>
</math>

, where</p>
<ul>
<li>

<math display="inline" id="Petri_net:12">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>S</mi>
   <mo>,</mo>
   <mi>T</mi>
   <mo>,</mo>
   <mi>W</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <ci>S</ci>
    <ci>T</ci>
    <ci>W</ci>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (S,T,W)
  </annotation>
 </semantics>
</math>

 is a Petri net graph;</li>
<li>

<math display="inline" id="Petri_net:13">
 <semantics>
  <msub>
   <mi>M</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>M</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M_{0}
  </annotation>
 </semantics>
</math>

 is the <em>initial marking</em>, a marking of the Petri net graph.</li>
</ul>
<h3 id="execution-semantics">Execution semantics</h3>

<p>In words:</p>
<ul>
<li>firing a transition <em>t</em> in a marking <em>M</em> consumes 

<math display="inline" id="Petri_net:14">
 <semantics>
  <mrow>
   <mi>W</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>s</mi>
    <mo>,</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>W</ci>
    <interval closure="open">
     <ci>s</ci>
     <ci>t</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W(s,t)
  </annotation>
 </semantics>
</math>

 tokens from each of its input places <em>s</em>, and produces 

<math display="inline" id="Petri_net:15">
 <semantics>
  <mrow>
   <mi>W</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo>,</mo>
    <mi>s</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>W</ci>
    <interval closure="open">
     <ci>t</ci>
     <ci>s</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W(t,s)
  </annotation>
 </semantics>
</math>

 tokens in each of its output places <em>s</em></li>
<li>a transition is <em>enabled</em> (it may <em>fire</em>) in <em>M</em> if there are enough tokens in its input places for the consumptions to be possible, i.e. iff 

<math display="inline" id="Petri_net:16">
 <semantics>
  <mrow>
   <mrow>
    <mo>∀</mo>
    <mi>s</mi>
   </mrow>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mi>M</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>s</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>≥</mo>
    <mrow>
     <mi>W</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>s</mi>
      <mo>,</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <csymbol cd="latexml">for-all</csymbol>
     <ci>s</ci>
    </apply>
    <apply>
     <geq></geq>
     <apply>
      <times></times>
      <ci>M</ci>
      <ci>s</ci>
     </apply>
     <apply>
      <times></times>
      <ci>W</ci>
      <interval closure="open">
       <ci>s</ci>
       <ci>t</ci>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall s:M(s)\geq W(s,t)
  </annotation>
 </semantics>
</math>

.</li>
</ul>

<p>We are generally interested in what may happen when transitions may continually fire in arbitrary order.</p>

<p>We say that a marking 

<math display="inline" id="Petri_net:17">
 <semantics>
  <msup>
   <mi>M</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>M</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M^{\prime}
  </annotation>
 </semantics>
</math>

 <em>is reachable from</em> a marking <em>M</em> <em>in one step</em> if 

<math display="inline" id="Petri_net:18">
 <semantics>
  <mrow>
   <mi>M</mi>
   <msub>
    <mo>→</mo>
    <mi>G</mi>
   </msub>
   <msup>
    <mi>M</mi>
    <mo>′</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-→</ci>
     <ci>G</ci>
    </apply>
    <ci>M</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>M</ci>
     <ci>normal-′</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M\to_{G}M^{\prime}
  </annotation>
 </semantics>
</math>

; we say that it <em>is reachable from</em> <em>M</em> if 

<math display="inline" id="Petri_net:19">
 <semantics>
  <mrow>
   <mi>M</mi>
   <mmultiscripts>
    <mo>→</mo>
    <mi>G</mi>
    <none></none>
    <none></none>
    <mo>*</mo>
   </mmultiscripts>
   <msup>
    <mi>M</mi>
    <mo>′</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-→</ci>
      <ci>G</ci>
     </apply>
     <times></times>
    </apply>
    <ci>M</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>M</ci>
     <ci>normal-′</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M{\to_{G}}^{*}M^{\prime}
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Petri_net:20">
 <semantics>
  <mmultiscripts>
   <mo>→</mo>
   <mi>G</mi>
   <none></none>
   <none></none>
   <mo>*</mo>
  </mmultiscripts>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-→</ci>
     <ci>G</ci>
    </apply>
    <times></times>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\to_{G}}^{*}
  </annotation>
 </semantics>
</math>

 is the <a href="reflexive_transitive_closure" title="wikilink">reflexive transitive closure</a> of 

<math display="inline" id="Petri_net:21">
 <semantics>
  <msub>
   <mo>→</mo>
   <mi>G</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>normal-→</ci>
    <ci>G</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \to_{G}
  </annotation>
 </semantics>
</math>

; that is, if it is reachable in 0 or more steps.</p>

<p>For a (marked) Petri net 

<math display="inline" id="Petri_net:22">
 <semantics>
  <mrow>
   <mi>N</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>S</mi>
    <mo>,</mo>
    <mi>T</mi>
    <mo>,</mo>
    <mi>W</mi>
    <mo>,</mo>
    <msub>
     <mi>M</mi>
     <mn>0</mn>
    </msub>
    <mo rspace="0.8pt" stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>N</ci>
    <vector>
     <ci>S</ci>
     <ci>T</ci>
     <ci>W</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>M</ci>
      <cn type="integer">0</cn>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N=(S,T,W,M_{0})\!
  </annotation>
 </semantics>
</math>

, we are interested in the firings that can be performed starting with the initial marking 

<math display="inline" id="Petri_net:23">
 <semantics>
  <msub>
   <mi>M</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>M</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M_{0}
  </annotation>
 </semantics>
</math>

. Its set of <em>reachable markings</em> is the set 

<math display="inline" id="Petri_net:24">
 <semantics>
  <mrow>
   <mrow>
    <mi>R</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>N</mi>
     <mo rspace="7.5pt" stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mpadded width="+5pt">
    <mover>
     <mo movablelimits="false">=</mo>
     <mi>D</mi>
    </mover>
   </mpadded>
   <mrow>
    <mo stretchy="false">{</mo>
    <msup>
     <mi>M</mi>
     <mo>′</mo>
    </msup>
    <mo>∣</mo>
    <mrow>
     <msub>
      <mi>M</mi>
      <mn>0</mn>
     </msub>
     <mmultiscripts>
      <mo>→</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>S</mi>
       <mo>,</mo>
       <mi>T</mi>
       <mo>,</mo>
       <mi>W</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <none></none>
      <none></none>
      <mo>*</mo>
     </mmultiscripts>
     <msup>
      <mi>M</mi>
      <mo>′</mo>
     </msup>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <eq></eq>
     <ci>D</ci>
    </apply>
    <apply>
     <times></times>
     <ci>R</ci>
     <ci>N</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>M</ci>
      <ci>normal-′</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>normal-→</ci>
        <vector>
         <ci>S</ci>
         <ci>T</ci>
         <ci>W</ci>
        </vector>
       </apply>
       <times></times>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>M</ci>
       <cn type="integer">0</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>M</ci>
       <ci>normal-′</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R(N)\ \stackrel{D}{=}\ \{M^{\prime}\mid M_{0}{\to_{(S,T,W)}}^{*}M^{\prime}\}
  </annotation>
 </semantics>
</math>

</p>

<p>The <em>reachability graph</em> of <em>N</em> is the transition relation 

<math display="inline" id="Petri_net:25">
 <semantics>
  <msub>
   <mo>→</mo>
   <mi>G</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>normal-→</ci>
    <ci>G</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \to_{G}
  </annotation>
 </semantics>
</math>

 restricted to its reachable markings 

<math display="inline" id="Petri_net:26">
 <semantics>
  <mrow>
   <mi>R</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>N</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>R</ci>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R(N)
  </annotation>
 </semantics>
</math>

. It is the <a href="state_space" title="wikilink">state space</a> of the net.</p>

<p>A <em>firing sequence</em> for a Petri net with graph <em>G</em> and initial marking 

<math display="inline" id="Petri_net:27">
 <semantics>
  <msub>
   <mi>M</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>M</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M_{0}
  </annotation>
 </semantics>
</math>

 is a sequence of transitions 

<math display="inline" id="Petri_net:28">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>σ</mi>
    <mo stretchy="false">→</mo>
   </mover>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mrow>
     <msub>
      <mi>t</mi>
      <msub>
       <mi>i</mi>
       <mn>1</mn>
      </msub>
     </msub>
     <mi mathvariant="normal">…</mi>
     <msub>
      <mi>t</mi>
      <msub>
       <mi>i</mi>
       <mi>n</mi>
      </msub>
     </msub>
    </mrow>
    <mo stretchy="false">⟩</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>normal-→</ci>
     <ci>σ</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">delimited-⟨⟩</csymbol>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>t</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>t</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>i</ci>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vec{\sigma}=\langle t_{i_{1}}\ldots t_{i_{n}}\rangle
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Petri_net:29">
 <semantics>
  <mrow>
   <msub>
    <mi>M</mi>
    <mn>0</mn>
   </msub>
   <msub>
    <mo>→</mo>
    <mrow>
     <mi>G</mi>
     <mo>,</mo>
     <msub>
      <mi>t</mi>
      <msub>
       <mi>i</mi>
       <mn>1</mn>
      </msub>
     </msub>
    </mrow>
   </msub>
   <mrow>
    <msub>
     <mi>M</mi>
     <mn>1</mn>
    </msub>
    <mo>∧</mo>
    <mi mathvariant="normal">…</mi>
    <mo>∧</mo>
    <msub>
     <mi>M</mi>
     <mrow>
      <mi>n</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msub>
   </mrow>
   <msub>
    <mo>→</mo>
    <mrow>
     <mi>G</mi>
     <mo>,</mo>
     <msub>
      <mi>t</mi>
      <msub>
       <mi>i</mi>
       <mi>n</mi>
      </msub>
     </msub>
    </mrow>
   </msub>
   <msub>
    <mi>M</mi>
    <mi>n</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-→</ci>
      <list>
       <ci>G</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>t</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </list>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>M</ci>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <and></and>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>M</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>M</ci>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-→</ci>
      <list>
       <ci>G</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>t</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>i</ci>
         <ci>n</ci>
        </apply>
       </apply>
      </list>
     </apply>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>M</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M_{0}\to_{G,t_{i_{1}}}M_{1}\wedge\ldots\wedge M_{n-1}\to_{G,t_{i_{n}}}M_{n}
  </annotation>
 </semantics>
</math>

. The set of firing sequences is denoted as 

<math display="inline" id="Petri_net:30">
 <semantics>
  <mrow>
   <mi>L</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>N</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>L</ci>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L(N)
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="variations-on-the-definition">Variations on the definition</h2>

<p>As already remarked, a common variation is to disallow arc multiplicities and replace the <a href="multiset" title="wikilink">bag</a> of arcs <em>W</em> with a simple set, called the <em>flow relation</em>, 

<math display="inline" id="Petri_net:31">
 <semantics>
  <mrow>
   <mi>F</mi>
   <mo>⊆</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>S</mi>
      <mo>×</mo>
      <mi>T</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∪</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>T</mi>
      <mo>×</mo>
      <mi>S</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <ci>F</ci>
    <apply>
     <union></union>
     <apply>
      <times></times>
      <ci>S</ci>
      <ci>T</ci>
     </apply>
     <apply>
      <times></times>
      <ci>T</ci>
      <ci>S</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F\subseteq(S\times T)\cup(T\times S)
  </annotation>
 </semantics>
</math>

. This doesn't limit <a href="expressive_power_(computer_science)" title="wikilink">expressive power</a> as both can represent each other.</p>

<p>Another common variation, e.g. in, Desel and Juhás (2001),<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> is to allow <em>capacities</em> to be defined on places. This is discussed under <em>extensions</em> below.</p>
<h2 id="formulation-in-terms-of-vectors-and-matrices">Formulation in terms of vectors and matrices</h2>

<p>The markings of a Petri net 

<math display="inline" id="Petri_net:32">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>S</mi>
   <mo>,</mo>
   <mi>T</mi>
   <mo>,</mo>
   <mi>W</mi>
   <mo>,</mo>
   <msub>
    <mi>M</mi>
    <mn>0</mn>
   </msub>
   <mo rspace="0.8pt" stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <ci>S</ci>
    <ci>T</ci>
    <ci>W</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>M</ci>
     <cn type="integer">0</cn>
    </apply>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (S,T,W,M_{0})\!
  </annotation>
 </semantics>
</math>

 can be regarded as <a href="Vector_(mathematics)" title="wikilink">vectors</a> of nonnegative integers of length 

<math display="inline" id="Petri_net:33">
 <semantics>
  <mrow>
   <mo stretchy="false">|</mo>
   <mi>S</mi>
   <mo stretchy="false">|</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <abs></abs>
    <ci>S</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |S|
  </annotation>
 </semantics>
</math>

.</p>

<p>Its transition relation can be described as a pair of 

<math display="inline" id="Petri_net:34">
 <semantics>
  <mrow>
   <mo stretchy="false">|</mo>
   <mi>S</mi>
   <mo stretchy="false">|</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <abs></abs>
    <ci>S</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |S|
  </annotation>
 </semantics>
</math>

 by 

<math display="inline" id="Petri_net:35">
 <semantics>
  <mrow>
   <mo stretchy="false">|</mo>
   <mi>T</mi>
   <mo stretchy="false">|</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <abs></abs>
    <ci>T</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |T|
  </annotation>
 </semantics>
</math>

 <a href="matrix_(mathematics)" title="wikilink">matrices</a>:</p>
<ul>
<li>

<math display="inline" id="Petri_net:36">
 <semantics>
  <msup>
   <mi>W</mi>
   <mo>-</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>W</ci>
    <minus></minus>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W^{-}
  </annotation>
 </semantics>
</math>

, defined by 

<math display="inline" id="Petri_net:37">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>∀</mo>
     <mi>s</mi>
    </mrow>
    <mo>,</mo>
    <mi>t</mi>
   </mrow>
   <mo>:</mo>
   <mrow>
    <mrow>
     <msup>
      <mi>W</mi>
      <mo>-</mo>
     </msup>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>s</mi>
      <mo>,</mo>
      <mi>t</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>W</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>s</mi>
      <mo>,</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <list>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <ci>s</ci>
     </apply>
     <ci>t</ci>
    </list>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>W</ci>
       <minus></minus>
      </apply>
      <interval closure="closed">
       <ci>s</ci>
       <ci>t</ci>
      </interval>
     </apply>
     <apply>
      <times></times>
      <ci>W</ci>
      <interval closure="open">
       <ci>s</ci>
       <ci>t</ci>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall s,t:W^{-}[s,t]=W(s,t)
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="Petri_net:38">
 <semantics>
  <msup>
   <mi>W</mi>
   <mo>+</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>W</ci>
    <plus></plus>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W^{+}
  </annotation>
 </semantics>
</math>

, defined by 

<math display="inline" id="Petri_net:39">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mo>∀</mo>
      <mi>s</mi>
     </mrow>
     <mo>,</mo>
     <mi>t</mi>
    </mrow>
    <mo>:</mo>
    <mrow>
     <mrow>
      <msup>
       <mi>W</mi>
       <mo>+</mo>
      </msup>
      <mrow>
       <mo stretchy="false">[</mo>
       <mi>s</mi>
       <mo>,</mo>
       <mi>t</mi>
       <mo stretchy="false">]</mo>
      </mrow>
     </mrow>
     <mo>=</mo>
     <mrow>
      <mi>W</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo>,</mo>
       <mi>s</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <list>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <ci>s</ci>
     </apply>
     <ci>t</ci>
    </list>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>W</ci>
       <plus></plus>
      </apply>
      <interval closure="closed">
       <ci>s</ci>
       <ci>t</ci>
      </interval>
     </apply>
     <apply>
      <times></times>
      <ci>W</ci>
      <interval closure="open">
       <ci>t</ci>
       <ci>s</ci>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall s,t:W^{+}[s,t]=W(t,s).
  </annotation>
 </semantics>
</math>

</li>
</ul>

<p>Then their difference</p>
<ul>
<li>

<math display="inline" id="Petri_net:40">
 <semantics>
  <mrow>
   <msup>
    <mi>W</mi>
    <mi>T</mi>
   </msup>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>W</mi>
     <mo>+</mo>
    </msup>
    <mo>-</mo>
    <msup>
     <mi>W</mi>
     <mo>-</mo>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>W</ci>
     <ci>T</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>W</ci>
      <plus></plus>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>W</ci>
      <minus></minus>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W^{T}=W^{+}-W^{-}
  </annotation>
 </semantics>
</math>

</li>
</ul>

<p>can be used to describe the reachable markings in terms of matrix multiplication, as follows. For any sequence of transitions <em>w</em>, write 

<math display="inline" id="Petri_net:41">
 <semantics>
  <mrow>
   <mi>o</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>w</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>o</ci>
    <ci>w</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   o(w)
  </annotation>
 </semantics>
</math>

 for the vector that maps every transition to its number of occurrences in <em>w</em>. Then, we have</p>
<ul>
<li>

<math display="inline" id="Petri_net:42">
 <semantics>
  <mrow>
   <mi>R</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>N</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mi>M</mi>
    <mo>∣</mo>
    <mo>∃</mo>
    <mi>w</mi>
    <mo>:</mo>
    <mi>M</mi>
    <mo>=</mo>
    <msub>
     <mi>M</mi>
     <mn>0</mn>
    </msub>
    <mo>+</mo>
    <msup>
     <mi>W</mi>
     <mi>T</mi>
    </msup>
    <mo>⋅</mo>
    <mi>o</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>w</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∧</mo>
    <mpadded width="-1.7pt">
     <mi>w</mi>
    </mpadded>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">R</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">N</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-{</ci>
     <csymbol cd="unknown">M</csymbol>
     <ci>normal-∣</ci>
     <exists></exists>
     <csymbol cd="unknown">w</csymbol>
     <ci>normal-:</ci>
     <csymbol cd="unknown">M</csymbol>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>M</ci>
      <cn type="integer">0</cn>
     </apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>W</ci>
      <ci>T</ci>
     </apply>
     <ci>normal-⋅</ci>
     <csymbol cd="unknown">o</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">w</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <and></and>
     <csymbol cd="unknown">w</csymbol>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R(N)=\{M\mid\exists w:M=M_{0}+W^{T}\cdot o(w)\wedge w\!
  </annotation>
 </semantics>
</math>

 is a firing sequence of 

<math display="inline" id="Petri_net:43">
 <semantics>
  <mrow>
   <mi>N</mi>
   <mo rspace="0.8pt" stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">N</csymbol>
    <ci>normal-}</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N\}\!
  </annotation>
 </semantics>
</math>

.</li>
</ul>

<p>Note that it must be required that <em>w</em> is a firing sequence; allowing arbitrary sequences of transitions will generally produce a larger set.</p>

<p> 

<math display="inline" id="Petri_net:44">
 <semantics>
  <mrow>
   <msup>
    <mi>W</mi>
    <mo>+</mo>
   </msup>
   <mo>=</mo>
   <mrow>
    <mo>[</mo>
    <mtable>
     <mtr>
      <mtd columnalign="center">
       <mo>*</mo>
      </mtd>
      <mtd columnalign="center">
       <mrow>
        <mi>t</mi>
        <mn>1</mn>
       </mrow>
      </mtd>
      <mtd columnalign="center">
       <mrow>
        <mi>t</mi>
        <mn>2</mn>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <mi>p</mi>
        <mn>1</mn>
       </mrow>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>1</mn>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <mi>p</mi>
        <mn>2</mn>
       </mrow>
      </mtd>
      <mtd columnalign="center">
       <mn>1</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <mi>p</mi>
        <mn>3</mn>
       </mrow>
      </mtd>
      <mtd columnalign="center">
       <mn>1</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <mi>p</mi>
        <mn>4</mn>
       </mrow>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>1</mn>
      </mtd>
     </mtr>
    </mtable>
    <mo>]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>W</ci>
     <plus></plus>
    </apply>
    <matrix>
     <matrixrow>
      <times></times>
      <apply>
       <times></times>
       <ci>t</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <times></times>
       <ci>t</ci>
       <cn type="integer">2</cn>
      </apply>
     </matrixrow>
     <matrixrow>
      <apply>
       <times></times>
       <ci>p</ci>
       <cn type="integer">1</cn>
      </apply>
      <cn type="integer">0</cn>
      <cn type="integer">1</cn>
     </matrixrow>
     <matrixrow>
      <apply>
       <times></times>
       <ci>p</ci>
       <cn type="integer">2</cn>
      </apply>
      <cn type="integer">1</cn>
      <cn type="integer">0</cn>
     </matrixrow>
     <matrixrow>
      <apply>
       <times></times>
       <ci>p</ci>
       <cn type="integer">3</cn>
      </apply>
      <cn type="integer">1</cn>
      <cn type="integer">0</cn>
     </matrixrow>
     <matrixrow>
      <apply>
       <times></times>
       <ci>p</ci>
       <cn type="integer">4</cn>
      </apply>
      <cn type="integer">0</cn>
      <cn type="integer">1</cn>
     </matrixrow>
    </matrix>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W^{+}=\begin{bmatrix}*&t1&t2\\
p1&0&1\\
p2&1&0\\
p3&1&0\\
p4&0&1\end{bmatrix}
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Petri_net:45">
 <semantics>
  <mrow>
   <msup>
    <mi>W</mi>
    <mo>-</mo>
   </msup>
   <mo>=</mo>
   <mrow>
    <mo>[</mo>
    <mtable>
     <mtr>
      <mtd columnalign="center">
       <mo>*</mo>
      </mtd>
      <mtd columnalign="center">
       <mrow>
        <mi>t</mi>
        <mn>1</mn>
       </mrow>
      </mtd>
      <mtd columnalign="center">
       <mrow>
        <mi>t</mi>
        <mn>2</mn>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <mi>p</mi>
        <mn>1</mn>
       </mrow>
      </mtd>
      <mtd columnalign="center">
       <mn>1</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <mi>p</mi>
        <mn>2</mn>
       </mrow>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>1</mn>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <mi>p</mi>
        <mn>3</mn>
       </mrow>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>1</mn>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <mi>p</mi>
        <mn>4</mn>
       </mrow>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
     </mtr>
    </mtable>
    <mo>]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>W</ci>
     <minus></minus>
    </apply>
    <matrix>
     <matrixrow>
      <times></times>
      <apply>
       <times></times>
       <ci>t</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <times></times>
       <ci>t</ci>
       <cn type="integer">2</cn>
      </apply>
     </matrixrow>
     <matrixrow>
      <apply>
       <times></times>
       <ci>p</ci>
       <cn type="integer">1</cn>
      </apply>
      <cn type="integer">1</cn>
      <cn type="integer">0</cn>
     </matrixrow>
     <matrixrow>
      <apply>
       <times></times>
       <ci>p</ci>
       <cn type="integer">2</cn>
      </apply>
      <cn type="integer">0</cn>
      <cn type="integer">1</cn>
     </matrixrow>
     <matrixrow>
      <apply>
       <times></times>
       <ci>p</ci>
       <cn type="integer">3</cn>
      </apply>
      <cn type="integer">0</cn>
      <cn type="integer">1</cn>
     </matrixrow>
     <matrixrow>
      <apply>
       <times></times>
       <ci>p</ci>
       <cn type="integer">4</cn>
      </apply>
      <cn type="integer">0</cn>
      <cn type="integer">0</cn>
     </matrixrow>
    </matrix>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W^{-}=\begin{bmatrix}*&t1&t2\\
p1&1&0\\
p2&0&1\\
p3&0&1\\
p4&0&0\end{bmatrix}
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Petri_net:46">
 <semantics>
  <mrow>
   <msup>
    <mi>W</mi>
    <mi>T</mi>
   </msup>
   <mo>=</mo>
   <mrow>
    <mo>[</mo>
    <mtable>
     <mtr>
      <mtd columnalign="center">
       <mo>*</mo>
      </mtd>
      <mtd columnalign="center">
       <mrow>
        <mi>t</mi>
        <mn>1</mn>
       </mrow>
      </mtd>
      <mtd columnalign="center">
       <mrow>
        <mi>t</mi>
        <mn>2</mn>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <mi>p</mi>
        <mn>1</mn>
       </mrow>
      </mtd>
      <mtd columnalign="center">
       <mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </mtd>
      <mtd columnalign="center">
       <mn>1</mn>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <mi>p</mi>
        <mn>2</mn>
       </mrow>
      </mtd>
      <mtd columnalign="center">
       <mn>1</mn>
      </mtd>
      <mtd columnalign="center">
       <mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <mi>p</mi>
        <mn>3</mn>
       </mrow>
      </mtd>
      <mtd columnalign="center">
       <mn>1</mn>
      </mtd>
      <mtd columnalign="center">
       <mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <mi>p</mi>
        <mn>4</mn>
       </mrow>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>1</mn>
      </mtd>
     </mtr>
    </mtable>
    <mo>]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>W</ci>
     <ci>T</ci>
    </apply>
    <matrix>
     <matrixrow>
      <times></times>
      <apply>
       <times></times>
       <ci>t</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <times></times>
       <ci>t</ci>
       <cn type="integer">2</cn>
      </apply>
     </matrixrow>
     <matrixrow>
      <apply>
       <times></times>
       <ci>p</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
      <cn type="integer">1</cn>
     </matrixrow>
     <matrixrow>
      <apply>
       <times></times>
       <ci>p</ci>
       <cn type="integer">2</cn>
      </apply>
      <cn type="integer">1</cn>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </matrixrow>
     <matrixrow>
      <apply>
       <times></times>
       <ci>p</ci>
       <cn type="integer">3</cn>
      </apply>
      <cn type="integer">1</cn>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </matrixrow>
     <matrixrow>
      <apply>
       <times></times>
       <ci>p</ci>
       <cn type="integer">4</cn>
      </apply>
      <cn type="integer">0</cn>
      <cn type="integer">1</cn>
     </matrixrow>
    </matrix>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W^{T}=\begin{bmatrix}*&t1&t2\\
p1&-1&1\\
p2&1&-1\\
p3&1&-1\\
p4&0&1\end{bmatrix}
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Petri_net:47">
 <semantics>
  <mrow>
   <msub>
    <mi>M</mi>
    <mn>0</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo>[</mo>
    <mtable>
     <mtr>
      <mtd columnalign="center">
       <mn>1</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>2</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>1</mn>
      </mtd>
     </mtr>
    </mtable>
    <mo>]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>M</ci>
     <cn type="integer">0</cn>
    </apply>
    <matrix>
     <matrixrow>
      <cn type="integer">1</cn>
      <cn type="integer">0</cn>
      <cn type="integer">2</cn>
      <cn type="integer">1</cn>
     </matrixrow>
    </matrix>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M_{0}=\begin{bmatrix}1&0&2&1\end{bmatrix}
  </annotation>
 </semantics>
</math>

</p>
<h2 id="mathematical-properties-of-petri-nets">Mathematical properties of Petri nets</h2>

<p>One thing that makes Petri nets interesting is that they provide a balance between modeling power and analyzability: many things one would like to know about concurrent systems can be automatically determined for Petri nets, although some of those things are very expensive to determine in the general case. Several subclasses of Petri nets have been studied that can still model interesting classes of concurrent systems, while these problems become easier.</p>

<p>An overview of such <a href="decision_problem" title="wikilink">decision problems</a>, with decidability and complexity results for Petri nets and some subclasses, can be found in Esparza and Nielsen (1995).<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>
<h3 id="reachability">Reachability</h3>

<p>The <a href="reachability_problem" title="wikilink">reachability problem</a> for Petri nets is to decide, given a Petri net <em>N</em> and a marking <em>M</em>, whether 

<math display="inline" id="Petri_net:48">
 <semantics>
  <mrow>
   <mi>M</mi>
   <mo>∈</mo>
   <mrow>
    <mi>R</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>N</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>M</ci>
    <apply>
     <times></times>
     <ci>R</ci>
     <ci>N</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M\in R(N)
  </annotation>
 </semantics>
</math>

.</p>

<p>Clearly, this is a matter of walking the reachability graph defined above, until either we reach the requested marking or we know it can no longer be found. This is harder than it may seem at first: the reachability graph is generally infinite, and it is not easy to determine when it is safe to stop.</p>

<p>In fact, this problem was shown to be <a class="uri" href="EXPSPACE" title="wikilink">EXPSPACE</a>-hard<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> years before it was shown to be decidable at all (Mayr, 1981). Papers continue to be published on how to do it efficiently.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>

<p>While reachability seems to be a good tool to find erroneous states, for practical problems the constructed graph usually has far too many states to calculate. To alleviate this problem, <a href="linear_temporal_logic" title="wikilink">linear temporal logic</a> is usually used in conjunction with the <a href="Method_of_analytic_tableaux" title="wikilink">tableau method</a> to prove that such states cannot be reached. LTL uses the <a href="semi-decision_procedure" title="wikilink">semi-decision technique</a> to find if indeed a state can be reached, by finding a set of necessary conditions for the state to be reached then proving that those conditions cannot be satisfied.</p>
<h3 id="liveness">Liveness</h3>
<figure><b>(Figure)</b>
<figcaption>A Petri net in which transition 

<math display="inline" id="Petri_net:49">
 <semantics>
  <msub>
   <mi>t</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>t</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t_{0}
  </annotation>
 </semantics>
</math>

 is dead, while for all 

<math display="inline" id="Petri_net:50">
 <semantics>
  <mrow>
   <mrow>
    <mi>j</mi>
    <mo>></mo>
    <mn>0</mn>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <ci>j</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   j>0,
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Petri_net:51">
 <semantics>
  <msub>
   <mi>t</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>t</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t_{j}
  </annotation>
 </semantics>
</math>

 is 

<math display="inline" id="Petri_net:52">
 <semantics>
  <msub>
   <mi>L</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>L</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L_{j}
  </annotation>
 </semantics>
</math>

-live</figcaption>
</figure>

<p>Petri nets can be described as having different degrees of liveness 

<math display="inline" id="Petri_net:53">
 <semantics>
  <mrow>
   <msub>
    <mi>L</mi>
    <mn>1</mn>
   </msub>
   <mo>-</mo>
   <msub>
    <mi>L</mi>
    <mn>4</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>L</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>L</ci>
     <cn type="integer">4</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L_{1}-L_{4}
  </annotation>
 </semantics>
</math>

. A Petri net 

<math display="inline" id="Petri_net:54">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>N</mi>
   <mo>,</mo>
   <msub>
    <mi>M</mi>
    <mn>0</mn>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>N</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>M</ci>
     <cn type="integer">0</cn>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (N,M_{0})
  </annotation>
 </semantics>
</math>

 is called 

<math display="inline" id="Petri_net:55">
 <semantics>
  <msub>
   <mi>L</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>L</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L_{k}
  </annotation>
 </semantics>
</math>

-live <a href="if_and_only_if" title="wikilink">iff</a> all of its transitions are 

<math display="inline" id="Petri_net:56">
 <semantics>
  <msub>
   <mi>L</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>L</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L_{k}
  </annotation>
 </semantics>
</math>

-live, where a transition is</p>
<ul>
<li><em>dead</em>, if it can never fire, i.e. it is not in any firing sequence in 

<math display="inline" id="Petri_net:57">
 <semantics>
  <mrow>
   <mi>L</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>N</mi>
    <mo>,</mo>
    <msub>
     <mi>M</mi>
     <mn>0</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>L</ci>
    <interval closure="open">
     <ci>N</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>M</ci>
      <cn type="integer">0</cn>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L(N,M_{0})
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="Petri_net:58">
 <semantics>
  <msub>
   <mi>L</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>L</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L_{1}
  </annotation>
 </semantics>
</math>

-live (<em>potentially fireable</em>), iff it may fire, i.e. it is in some firing sequence in 

<math display="inline" id="Petri_net:59">
 <semantics>
  <mrow>
   <mi>L</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>N</mi>
    <mo>,</mo>
    <msub>
     <mi>M</mi>
     <mn>0</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>L</ci>
    <interval closure="open">
     <ci>N</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>M</ci>
      <cn type="integer">0</cn>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L(N,M_{0})
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="Petri_net:60">
 <semantics>
  <msub>
   <mi>L</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>L</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L_{2}
  </annotation>
 </semantics>
</math>

-live iff it can fire arbitrarily often, i.e. if for every positive integer k, it occurs at least k times in some firing sequence in 

<math display="inline" id="Petri_net:61">
 <semantics>
  <mrow>
   <mi>L</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>N</mi>
    <mo>,</mo>
    <msub>
     <mi>M</mi>
     <mn>0</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>L</ci>
    <interval closure="open">
     <ci>N</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>M</ci>
      <cn type="integer">0</cn>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L(N,M_{0})
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="Petri_net:62">
 <semantics>
  <msub>
   <mi>L</mi>
   <mn>3</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>L</ci>
    <cn type="integer">3</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L_{3}
  </annotation>
 </semantics>
</math>

-live iff it can fire infinitely often, i.e. if for every positive integer k, it occurs at least k times in <em>V</em>, for some prefix-closed set of firing sequences 

<math display="inline" id="Petri_net:63">
 <semantics>
  <msub>
   <mi></mi>
   <mrow>
    <mi>V</mi>
    <mo>⊆</mo>
    <mrow>
     <mi>L</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>N</mi>
      <mo>,</mo>
      <msub>
       <mi>M</mi>
       <mn>0</mn>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <subset></subset>
     <ci>V</ci>
     <apply>
      <times></times>
      <ci>L</ci>
      <interval closure="open">
       <ci>N</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>M</ci>
        <cn type="integer">0</cn>
       </apply>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {}_{V\subseteq L(N,M_{0})}
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="Petri_net:64">
 <semantics>
  <msub>
   <mi>L</mi>
   <mn>4</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>L</ci>
    <cn type="integer">4</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L_{4}
  </annotation>
 </semantics>
</math>

-live (<em>live</em>) iff it may always fire, i.e., it is 

<math display="inline" id="Petri_net:65">
 <semantics>
  <msub>
   <mi>L</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>L</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L_{1}
  </annotation>
 </semantics>
</math>

-live in every reachable marking in 

<math display="inline" id="Petri_net:66">
 <semantics>
  <mrow>
   <mi>R</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>N</mi>
    <mo>,</mo>
    <msub>
     <mi>M</mi>
     <mn>0</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>R</ci>
    <interval closure="open">
     <ci>N</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>M</ci>
      <cn type="integer">0</cn>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R(N,M_{0})
  </annotation>
 </semantics>
</math>

</li>
</ul>

<p>Note that these are increasingly stringent requirements

<math display="block" id="Petri_net:67">
 <semantics>
  <msub>
   <mi>L</mi>
   <mrow>
    <mi>j</mi>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>L</ci>
    <apply>
     <plus></plus>
     <ci>j</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L_{j+1}
  </annotation>
 </semantics>
</math>

-liveness implies 

<math display="inline" id="Petri_net:68">
 <semantics>
  <msub>
   <mi>L</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>L</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L_{j}
  </annotation>
 </semantics>
</math>

-liveness, for 

<math display="inline" id="Petri_net:69">
 <semantics>
  <msub>
   <mi></mi>
   <mrow>
    <mi>j</mi>
    <mo>∈</mo>
    <mrow>
     <mn>1</mn>
     <mo>,</mo>
     <mn>2</mn>
     <mo>,</mo>
     <mn>3</mn>
    </mrow>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <in></in>
     <ci>j</ci>
     <list>
      <cn type="integer">1</cn>
      <cn type="integer">2</cn>
      <cn type="integer">3</cn>
     </list>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {}_{j\in{1,2,3}}
  </annotation>
 </semantics>
</math>

.</p>

<p>These definitions are in accordance with Murata's overview,<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> which additionally uses 

<math display="inline" id="Petri_net:70">
 <semantics>
  <msub>
   <mi>L</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>L</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L_{0}
  </annotation>
 </semantics>
</math>

<em>-live</em> as a term for <em>dead</em>.</p>
<h3 id="boundedness">Boundedness</h3>
<figure><b>(Figure)</b>
<figcaption>The reachability graph of <em>N2</em>.</figcaption>
</figure>

<p>A place in a Petri net is called <em>k-bounded</em> if it does not contain more than <em>k</em> tokens in all reachable markings, including the initial marking; it is said to be <em>safe</em> if it is 1-bounded; it is <em><a href="bounded_set" title="wikilink">bounded</a></em> if it is <em>k-bounded</em> for some <em>k</em>.</p>

<p>A (marked) Petri net is called <em>k</em>-bounded, <em>safe</em>, or <em>bounded</em> when all of its places are. A Petri net (graph) is called <em>(structurally) bounded</em> if it is bounded for every possible initial marking.</p>

<p>Note that a Petri net is bounded if and only if its reachability graph is finite.</p>

<p>Boundedness is decidable by looking at <a href="covering_problem" title="wikilink">covering</a>, by constructing the <a href="Richard_Karp" title="wikilink">Karp</a>–Miller Tree.</p>

<p>It can be useful to explicitly impose a bound on places in a given net. This can be used to model limited system resources.</p>

<p>Some definitions of Petri nets explicitly allow this as a syntactic feature.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> Formally, <em>Petri nets with place capacities</em> can be defined as tuples 

<math display="inline" id="Petri_net:71">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>S</mi>
   <mo>,</mo>
   <mi>T</mi>
   <mo>,</mo>
   <mi>W</mi>
   <mo>,</mo>
   <mi>C</mi>
   <mo>,</mo>
   <msub>
    <mi>M</mi>
    <mn>0</mn>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <ci>S</ci>
    <ci>T</ci>
    <ci>W</ci>
    <ci>C</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>M</ci>
     <cn type="integer">0</cn>
    </apply>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (S,T,W,C,M_{0})
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Petri_net:72">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>S</mi>
   <mo>,</mo>
   <mi>T</mi>
   <mo>,</mo>
   <mi>W</mi>
   <mo>,</mo>
   <msub>
    <mi>M</mi>
    <mn>0</mn>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <ci>S</ci>
    <ci>T</ci>
    <ci>W</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>M</ci>
     <cn type="integer">0</cn>
    </apply>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (S,T,W,M_{0})
  </annotation>
 </semantics>
</math>

 is a Petri net, 

<math display="inline" id="Petri_net:73">
 <semantics>
  <mrow>
   <mi>C</mi>
   <mo>:</mo>
   <mi>P</mi>
   <mo rspace="0pt">→</mo>
   <mo>∣</mo>
   <mpadded width="-1.7pt">
    <mi>I</mi>
   </mpadded>
   <mi>N</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">C</csymbol>
    <ci>normal-:</ci>
    <csymbol cd="unknown">P</csymbol>
    <ci>normal-→</ci>
    <csymbol cd="latexml">divides</csymbol>
    <csymbol cd="unknown">I</csymbol>
    <csymbol cd="unknown">N</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C:P\rightarrow\!\!\!\shortmid I\!N
  </annotation>
 </semantics>
</math>

 an assignment of capacities to (some or all) places, and the transition relation is the usual one restricted to the markings in which each place with a capacity has at most that many tokens.</p>
<figure><b>(Figure)</b>
<figcaption>An unbounded Petri net, <em>N</em>.</figcaption>
</figure>

<p>For example, if in the net <em>N</em>, both places are assigned capacity 2, we obtain a Petri net with place capacities, say <em>N2</em>; its reachability graph is displayed on the right.</p>
<figure><b>(Figure)</b>
<figcaption>A two-bounded Petri net, obtained by extending <em>N</em> with "counter-places".</figcaption>
</figure>

<p>Alternatively, places can be made bounded by extending the net. To be exact, a place can be made <em>k</em>-bounded by adding a "counter-place" with flow opposite to that of the place, and adding tokens to make the total in both places <em>k</em>.</p>
<h2 id="discrete-continuous-and-hybrid-petri-nets">Discrete, continuous, and hybrid Petri nets</h2>

<p>As well as for discrete events, there are Petri nets for continuous and hybrid discrete-continuous processes that are useful in discrete, continuous and hybrid <a href="control_theory" title="wikilink">control theory</a>,<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> and related to discrete, continuous and hybrid <a href="automata_theory" title="wikilink">automata</a>.</p>
<h2 id="extensions">Extensions</h2>

<p>There are many extensions to Petri nets. Some of them are completely backwards-compatible (e.g. coloured Petri nets) with the original Petri net, some add properties that cannot be modelled in the original Petri net formalism (e.g. timed Petri nets). Although backwards-compatible models do not extend the computational power of Petri nets, they may have more succinct representations and may be more convenient for modeling.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> Extensions that cannot be transformed into Petri nets are sometimes very powerful, but usually lack the full range of mathematical tools available to analyse ordinary Petri nets.</p>

<p>The term <a href="high-level_Petri_net" title="wikilink">high-level Petri net</a> is used for many Petri net formalisms that extend the basic P/T net formalism; this includes coloured Petri nets, hierarchical Petri nets such as <a href="Nets_within_Nets" title="wikilink">Nets within Nets</a>, and all other extensions sketched in this section. The term is also used specifically for the type of coloured nets supported by <a href="CPN_Tools" title="wikilink">CPN Tools</a>.</p>

<p>A short list of possible extensions:</p>
<ul>
<li>Additional types of arcs; two common types are:
<ul>
<li>a <em>reset arc</em> does not impose a precondition on firing, and empties the place when the transition fires; this makes reachability undecidable,<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> while some other properties, such as termination, remain decidable;<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a></li>
<li>an <em>inhibitor arc</em> imposes the precondition that the transition may only fire when the place is empty; this allows arbitrary computations on numbers of tokens to be expressed, which makes the formalism <a href="Turing_complete" title="wikilink">Turing complete</a> and implies existence of a universal net.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a></li>
</ul></li>
<li>In a standard Petri net, tokens are indistinguishable. In a <a href="Coloured_Petri_net" title="wikilink">Coloured Petri net</a>, every token has a value.<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a> In popular tools for coloured Petri nets such as <a href="CPN_Tools" title="wikilink">CPN Tools</a>, the values of tokens are typed, and can be tested (using <em>guard</em> expressions) and manipulated with a <a href="functional_programming_language" title="wikilink">functional programming language</a>. A subsidiary of coloured Petri nets are the <a href="well-formed_Petri_net" title="wikilink">well-formed Petri nets</a>, where the arc and guard expressions are restricted to make it easier to analyse the net.</li>
</ul>
<ul>
<li>Another popular extension of Petri nets is hierarchy; this in the form of different views supporting levels of refinement and abstraction was studied by Fehling. Another form of hierarchy is found in so-called object Petri nets or object systems where a Petri net can contain Petri nets as its tokens inducing a hierarchy of nested Petri nets that communicate by synchronisation of transitions on different levels. See<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a> for an informal introduction to object Petri nets.</li>
</ul>
<ul>
<li>A <a href="Vector_addition_system" title="wikilink">vector addition system with states (VASS)</a> is an equivalent formalism to Petri nets. However, it can be superficially viewed as a generalisation of Petri nets. Consider a <a href="finite_state_automaton" title="wikilink">finite state automaton</a> where each transition is labelled by a transition from the Petri net. The Petri net is then synchronised with the finite state automaton, i.e., a transition in the automaton is taken at the same time as the corresponding transition in the Petri net. It is only possible to take a transition in the automaton if the corresponding transition in the Petri net is enabled, and it is only possible to fire a transition in the Petri net if there is a transition from the current state in the automaton labelled by it. (The definition of VASS is usually formulated slightly differently.)</li>
</ul>
<ul>
<li><a href="Prioritised_Petri_net" title="wikilink">Prioritised Petri nets</a> add priorities to transitions, whereby a transition cannot fire, if a higher-priority transition is enabled (i.e. can fire). Thus, transitions are in priority groups, and e.g. priority group 3 can only fire if all transitions are disabled in groups 1 and 2. Within a priority group, firing is <em>still</em> non-deterministic.</li>
</ul>
<ul>
<li>The non-deterministic property has been a very valuable one, as it lets the user abstract a large number of properties (depending on what the net is used for). In certain cases, however, the need arises to also model the timing, not only the structure of a model. For these cases, <a href="timed_Petri_nets" title="wikilink">timed Petri nets</a> have evolved, where there are transitions that are timed, and possibly transitions which are not timed (if there are, transitions that are not timed have a higher priority than timed ones). A subsidiary of timed Petri nets are the <a href="stochastic_Petri_net" title="wikilink">stochastic Petri nets</a> that add <a href="nondeterministic_time" title="wikilink">nondeterministic time</a> through adjustable randomness of the transitions. The <a href="Exponential_distribution" title="wikilink">exponential random distribution</a> is usually used to 'time' these nets. In this case, the nets' reachability graph can be used as a <a href="Markov_chain" title="wikilink">Markov chain</a>.</li>
</ul>
<ul>
<li><a href="Dualistic_Petri_Nets" title="wikilink">Dualistic Petri Nets</a> (dP-Nets) is a Petri Net extension developed by E. Dawis, et al.<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a> to better represent real-world process. dP-Nets balance the duality of change/no-change, action/passivity, (transformation) time/space, etc., between the bipartite Petri Net constructs of transformation and place resulting in the unique characteristic of <em>transformation marking</em>, i.e., when the transformation is "working" it is marked. This allows for the transformation to fire (or be marked) multiple times representing the real-world behavior of process throughput. Marking of the transformation assumes that transformation time must be greater than zero. A zero transformation time used in many typical Petri Nets may be mathematically appealing but impractical in representing real-world processes. dP-Nets also exploit the power of Petri Nets' hierarchical abstraction to depict <a href="Process_architecture" title="wikilink">Process architecture</a>. Complex process systems are modeled as a series of simpler nets interconnected through various levels of hierarchical abstraction. The process architecture of a packet switch is demonstrated in,<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a> where development requirements are organized around the structure of the designed system. dP-Nets allow any real-world process, such as computer systems, business processes, traffic flow, etc., to be modeled, studied, and improved.</li>
</ul>

<p>There are many more extensions to Petri nets, however, it is important to keep in mind, that as the complexity of the net increases in terms of extended properties, the harder it is to use standard tools to evaluate certain properties of the net. For this reason, it is a good idea to use the most simple net type possible for a given modelling task.</p>
<h2 id="restrictions">Restrictions</h2>
<figure><b>(Figure)</b>
<figcaption>Petri net types graphically</figcaption>
</figure>

<p>Instead of extending the Petri net formalism, we can also look at restricting it, and look at particular types of Petri nets, obtained by restricting the syntax in a particular way. Ordinary Petri nets are the nets where all arc weights are 1. Restricting further, the following types of ordinary Petri nets are commonly used and studied:</p>
<ol>
<li>In a <a href="state_machine" title="wikilink">state machine</a> (SM), every transition has one incoming arc, and one outgoing arc, and all markings have exactly one token. As a consequence, there can <em>not</em> be <em>concurrency</em>, but there can be <em>conflict</em> (i.e. <a href="Indeterminacy_in_concurrent_computation" title="wikilink">nondeterminism</a>). Mathematically

<math display="block" id="Petri_net:74">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>∀</mo>
     <mi>t</mi>
    </mrow>
    <mo>∈</mo>
    <mi>T</mi>
   </mrow>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">|</mo>
     <msup>
      <mi>t</mi>
      <mo>∙</mo>
     </msup>
     <mo stretchy="false">|</mo>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo stretchy="false">|</mo>
     <mmultiscripts>
      <mi>t</mi>
      <mprescripts></mprescripts>
      <none></none>
      <mo>∙</mo>
     </mmultiscripts>
     <mo stretchy="false">|</mo>
    </mrow>
    <mo>=</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <in></in>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <ci>t</ci>
     </apply>
     <ci>T</ci>
    </apply>
    <apply>
     <and></and>
     <apply>
      <eq></eq>
      <apply>
       <abs></abs>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>t</ci>
        <ci>normal-∙</ci>
       </apply>
      </apply>
      <apply>
       <abs></abs>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>t</ci>
        <ci>normal-∙</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <eq></eq>
      <share href="#.cmml">
      </share>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall t\in T:|t^{\bullet}|=|{}^{\bullet}t|=1
  </annotation>
 </semantics>
</math>

</li>
<li>In a <a href="marked_graph" title="wikilink">marked graph</a> (MG), every place has one incoming arc, and one outgoing arc. This means, that there can <em>not</em> be <em>conflict</em>, but there can be <em>concurrency</em>. Mathematically

<math display="block" id="Petri_net:75">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>∀</mo>
     <mi>s</mi>
    </mrow>
    <mo>∈</mo>
    <mi>S</mi>
   </mrow>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">|</mo>
     <msup>
      <mi>s</mi>
      <mo>∙</mo>
     </msup>
     <mo stretchy="false">|</mo>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo stretchy="false">|</mo>
     <mmultiscripts>
      <mi>s</mi>
      <mprescripts></mprescripts>
      <none></none>
      <mo>∙</mo>
     </mmultiscripts>
     <mo stretchy="false">|</mo>
    </mrow>
    <mo>=</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <in></in>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <ci>s</ci>
     </apply>
     <ci>S</ci>
    </apply>
    <apply>
     <and></and>
     <apply>
      <eq></eq>
      <apply>
       <abs></abs>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>s</ci>
        <ci>normal-∙</ci>
       </apply>
      </apply>
      <apply>
       <abs></abs>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>s</ci>
        <ci>normal-∙</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <eq></eq>
      <share href="#.cmml">
      </share>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall s\in S:|s^{\bullet}|=|{}^{\bullet}s|=1
  </annotation>
 </semantics>
</math>

</li>
<li>In a <em>free choice</em> net (FC), - every arc from a place to a transition is either the only arc from that place or the only arc to that transition. I.e. there can be <em>both concurrency and conflict, but not at the same time</em>. Mathematically

<math display="block" id="Petri_net:76">
 <semantics>
  <mrow>
   <mo>∀</mo>
   <mi>s</mi>
   <mo>∈</mo>
   <mi>S</mi>
   <mo>:</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo stretchy="false">|</mo>
    <msup>
     <mi>s</mi>
     <mo>∙</mo>
    </msup>
    <mo stretchy="false">|</mo>
    <mo>≤</mo>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∨</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mmultiscripts>
     <mrow>
      <mo stretchy="false">(</mo>
      <msup>
       <mi>s</mi>
       <mo>∙</mo>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
     <mprescripts></mprescripts>
     <none></none>
     <mo>∙</mo>
    </mmultiscripts>
    <mo>=</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mi>s</mi>
     <mo stretchy="false">}</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">s</csymbol>
    <in></in>
    <csymbol cd="unknown">S</csymbol>
    <ci>normal-:</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <ci>normal-|</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>s</ci>
      <ci>normal-∙</ci>
     </apply>
     <ci>normal-|</ci>
     <leq></leq>
     <cn type="integer">1</cn>
     <ci>normal-)</ci>
    </cerror>
    <or></or>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>s</ci>
        <ci>normal-∙</ci>
       </apply>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-∙</ci>
     </apply>
     <eq></eq>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-{</ci>
      <csymbol cd="unknown">s</csymbol>
      <ci>normal-}</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall s\in S:(|s^{\bullet}|\leq 1)\vee({}^{\bullet}(s^{\bullet})=\{s\})
  </annotation>
 </semantics>
</math>

</li>
<li>Extended free choice (EFC) - a Petri net that can be <em>transformed into an FC</em>.</li>
<li>In an <em>asymmetric choice</em> net (AC), concurrency and conflict (in sum, <em>confusion</em>) may occur, but <em>not symmetrically</em>. Mathematically

<math display="block" id="Petri_net:77">
 <semantics>
  <mrow>
   <mo>∀</mo>
   <msub>
    <mi>s</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>s</mi>
    <mn>2</mn>
   </msub>
   <mo>∈</mo>
   <mi>S</mi>
   <mo>:</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>s</mi>
     <mn>1</mn>
    </msub>
    <mmultiscripts>
     <mo>∩</mo>
     <mprescripts></mprescripts>
     <none></none>
     <mo>∙</mo>
    </mmultiscripts>
    <msub>
     <mi>s</mi>
     <mn>2</mn>
    </msub>
    <mmultiscripts>
     <mo>≠</mo>
     <mprescripts></mprescripts>
     <none></none>
     <mo>∙</mo>
    </mmultiscripts>
    <mi mathvariant="normal">∅</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>s</mi>
      <mn>1</mn>
     </msub>
     <mmultiscripts>
      <mo>⊆</mo>
      <mprescripts></mprescripts>
      <none></none>
      <mo>∙</mo>
     </mmultiscripts>
     <msub>
      <mi>s</mi>
      <mn>2</mn>
     </msub>
     <mmultiscripts>
      <mo stretchy="false">)</mo>
      <mprescripts></mprescripts>
      <none></none>
      <mo>∙</mo>
     </mmultiscripts>
    </mrow>
    <mo>∨</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>s</mi>
      <mn>2</mn>
     </msub>
     <mmultiscripts>
      <mo>⊆</mo>
      <mprescripts></mprescripts>
      <none></none>
      <mo>∙</mo>
     </mmultiscripts>
     <msub>
      <mi>s</mi>
      <mn>1</mn>
     </msub>
     <mmultiscripts>
      <mo stretchy="false">)</mo>
      <mprescripts></mprescripts>
      <none></none>
      <mo>∙</mo>
     </mmultiscripts>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>s</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-,</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>s</ci>
     <cn type="integer">2</cn>
    </apply>
    <in></in>
    <csymbol cd="unknown">S</csymbol>
    <ci>normal-:</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>s</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <intersect></intersect>
      <ci>normal-∙</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>s</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <neq></neq>
      <ci>normal-∙</ci>
     </apply>
     <emptyset></emptyset>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>s</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <subset></subset>
       <ci>normal-∙</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>s</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>normal-)</ci>
       <ci>normal-∙</ci>
      </apply>
     </cerror>
     <or></or>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>s</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <subset></subset>
       <ci>normal-∙</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>s</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>normal-)</ci>
       <ci>normal-∙</ci>
      </apply>
     </cerror>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall s_{1},s_{2}\in S:(s_{1}{}^{\bullet}\cap s_{2}{}^{\bullet}\neq\emptyset%
)\to[(s_{1}{}^{\bullet}\subseteq s_{2}{}^{\bullet})\vee(s_{2}{}^{\bullet}%
\subseteq s_{1}{}^{\bullet})]
  </annotation>
 </semantics>
</math>

</li>
</ol>
<h2 id="workflow-nets">Workflow nets</h2>

<p><a href="Workflow_net" title="wikilink">Workflow nets</a> (WF-nets) are a subclass of Petri nets intending to model the <a class="uri" href="workflow" title="wikilink">workflow</a> of process activities.<a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a> The WF-net transitions are assigned to tasks or activities, and places are assigned to the pre/post conditions. The WF-nets have additional structural and operational requirements, mainly the addition of a single input (source) place with no previous transitions, and output place (sink) with no following transitions. Accordingly start and termination markings can be defined that represent the process status.</p>

<p>WF-nets have the <strong>soundness</strong> property,<a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a> indicating that a process with a start marking of k tokens in its sink place, can reach the termination state marking with k tokens in its sink place (defined as K-sound WF-net). Additionally, all the transitions in the process could fire (i.e., for each transition there is a reachable state in which the transition is enabled). A general sound (G-sound) WF-net is defined as being K-sound for every k&gt;0.<a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a></p>

<p>A directed <strong><a href="Path_(graph_theory)" title="wikilink">path</a></strong> in the Petri net is defined as the sequence of nodes (places and transitions) linked by the directed arcs. An <strong>elementary path</strong> includes every node in the sequence only once.</p>

<p>A <strong>Well-handled</strong> Petri net is a net in which there are no fully distinct elementary paths between a place and a transition (or transition and a place), i.e., if there are two paths between the pair of node then these paths share a node. An acyclic well-handled WF-net is sound (G-sound).<a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a></p>

<p>Extended WF-net is a Petri net that is composed of a WF-net with additional transition t (feedback transition). The sink place is connected as the input place of transition t and the source place as its output place. Firing of the transition causes iteration of the process (Note: the extended WF-net is not a WF-net).<a class="footnoteRef" href="#fn23" id="fnref23"><sup>23</sup></a></p>

<p>WRI (Well-handled with Regular Iteration) WF-net, is an extended acyclic well-handled WF-net. WRI-WF-net can be built as composition of nets, i.e., replacing a transition within a WRI-WF-net with a subnet which is a WRI-WF-net. The result is also WRI-WF-net. WRI-WF-nets are G-sound,<a class="footnoteRef" href="#fn24" id="fnref24"><sup>24</sup></a> therefore by using only WRI-WF-net building blocks, one can get WF-nets that are G-sound by construction.</p>

<p>The <a href="Design_structure_matrix" title="wikilink">Design structure matrix</a> (DSM) can model process relations, and be utilized for process planning. The <strong>DSM-nets</strong> are realization of DSM-based plans into workflow processes by Petri nets, and are equivalent to WRI-WF-nets.<a class="footnoteRef" href="#fn25" id="fnref25"><sup>25</sup></a> The DSM-net construction process ensures the soundness property of the resulting net.</p>
<h2 id="other-models-of-concurrency">Other models of concurrency</h2>

<p>Other ways of modelling concurrent computation have been proposed, including <a href="process_algebra" title="wikilink">process algebra</a>, the <a href="actor_model" title="wikilink">actor model</a>, and <a href="trace_theory" title="wikilink">trace theory</a>.<a class="footnoteRef" href="#fn26" id="fnref26"><sup>26</sup></a> Different models provide tradeoffs of concepts such as <a class="uri" href="compositionality" title="wikilink">compositionality</a>, <a href="Modularity_(programming)" title="wikilink">modularity</a>, and locality.</p>

<p>An approach to relating some of these models of concurrency is proposed in the chapter by Winskel and Nielsen.<a class="footnoteRef" href="#fn27" id="fnref27"><sup>27</sup></a></p>
<h2 id="application-areas">Application areas</h2>
<ul>
<li><a href="Business_Process_Modeling" title="wikilink">Business Process Modeling</a></li>
<li><a href="Concurrent_programming" title="wikilink">Concurrent programming</a></li>
<li><a href="Data_analysis" title="wikilink">Data analysis</a></li>
<li><a href="Diagnosis_(Artificial_intelligence)" title="wikilink">Diagnosis (Artificial intelligence)</a></li>
<li><a href="Sequential_function_chart" title="wikilink">Discrete process control</a></li>
<li><a href="Kahn_process_networks" title="wikilink">Kahn process networks</a></li>
<li><a href="Process_Modeling" title="wikilink">Process Modeling</a></li>
<li><a href="Reliability_engineering" title="wikilink">Reliability engineering</a></li>
<li><a class="uri" href="Simulation" title="wikilink">Simulation</a></li>
<li><a href="Software_design" title="wikilink">Software design</a></li>
<li><a href="Workflow_management_system" title="wikilink">Workflow management systems</a></li>
</ul>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Communicating_finite-state_machine" title="wikilink">Communicating finite-state machine</a></li>
<li><a href="Finite_state_machine" title="wikilink">Finite state machine</a></li>
<li><a href="Kahn_process_networks" title="wikilink">Kahn process networks</a></li>
<li><a href="Petri_Net_Markup_Language" title="wikilink">Petri Net Markup Language</a></li>
<li><a class="uri" href="Petriscript" title="wikilink">Petriscript</a></li>
<li><a href="Process_architecture" title="wikilink">Process architecture</a></li>
</ul>
<h2 id="references">References</h2>
<h2 id="further-reading">Further reading</h2>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.informatik.uni-hamburg.de/TGI/PetriNets/">Petri Nets World</a></li>
<li><a href="http://www.pnml.org">Petri Net Markup Language</a></li>
<li><a href="http://code.google.com/p/jbpt/">Java implementation of Petri nets</a> in the jBPT library (see jbpt-petri module)</li>
<li><a href="http://www.informatik.uni-hamburg.de/TGI/PetriNets/tools/java/Braunl/">Java Petri net simulator</a></li>
<li><a href="http://people.dsv.su.se/~petia/WorkflowTutorial/player.html">Petia Wohed's Flash-based tutorial introduction to Workflow Technology with Petri Nets</a></li>
<li><a href="http://www.informatik.uni-hamburg.de/TGI/PetriNets/tools/quick.html">List of Petri net tools</a></li>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Formal_specification_languages" title="wikilink">Category:Formal specification languages</a> <a href="Category:Models_of_computation" title="wikilink">Category:Models of computation</a> <a href="Category:Concurrency_(computer_science)" title="wikilink">Category:Concurrency (computer science)</a> <a class="uri" href="Category:Diagrams" title="wikilink">Category:Diagrams</a> <a href="Category:Petri_nets" title="wikilink"> </a> <a href="Category:Software_modeling_language" title="wikilink">Category:Software modeling language</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
<li id="fn10"><a href="#fnref10">↩</a></li>
<li id="fn11"><a href="#fnref11">↩</a></li>
<li id="fn12"><a href="#fnref12">↩</a></li>
<li id="fn13"><a href="#fnref13">↩</a></li>
<li id="fn14"><a href="#fnref14">↩</a></li>
<li id="fn15"><a href="#fnref15">↩</a></li>
<li id="fn16"><a class="uri" href="http://llpn.com/OPNs.html">http://llpn.com/OPNs.html</a><a href="#fnref16">↩</a></li>
<li id="fn17"><a href="#fnref17">↩</a></li>
<li id="fn18"><a href="#fnref18">↩</a></li>
<li id="fn19"><a href="#fnref19">↩</a></li>
<li id="fn20"></li>
<li id="fn21"><a href="#fnref21">↩</a></li>
<li id="fn22"><a href="#fnref22">↩</a></li>
<li id="fn23"></li>
<li id="fn24"></li>
<li id="fn25"><a href="#fnref25">↩</a></li>
<li id="fn26"><a href="#fnref26">↩</a></li>
<li id="fn27"><a href="#fnref27">↩</a></li>
</ol>
</section>
</body>
</html>
