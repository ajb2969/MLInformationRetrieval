<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1505">Ordinal optimization</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Ordinal optimization</h1>
<hr>In [[mathematical optimization]], '''ordinal optimization''' is the maximization of functions taking values in
<p><code>a </code><a href="partially_ordered_set" title="wikilink"><code>partially</code> <code>ordered</code> <code>set</code></a><code> ("poset").</code><a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a><a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a><a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a><a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a><code>  Ordinal optimization has applications in the theory of </code><a href="queuing_theory" title="wikilink"><code>queuing</code></a><code> </code><a href="flow_network" title="wikilink"><code>networks</code></a><code>.</code></p>
<h2 id="mathematical-foundations">Mathematical foundations</h2>
<h3 id="definitions">Definitions</h3>

<p>A <strong>partial order</strong> is a <a href="binary_relation" title="wikilink">binary relation</a> "≤" over a <a href="Set_(mathematics)" title="wikilink">set</a> <em>P</em> which is <a href="reflexive_relation" title="wikilink">reflexive</a>, <a href="antisymmetric_relation" title="wikilink">antisymmetric</a>, and <a href="transitive_relation" title="wikilink">transitive</a>, i.e., for all <em>a</em>, <em>b</em>, and <em>c</em> in <em>P</em>, we have that:</p>
<ul>
<li><em>a ≤ a</em> (reflexivity);</li>
<li>if <em>a ≤ b</em> and <em>b ≤ a</em> then <em>a</em> = <em>b</em> (antisymmetry);</li>
<li>if <em>a ≤ b</em> and <em>b ≤ c</em> then <em>a ≤ c</em> (transitivity).</li>
</ul>

<p>In other words, a partial order is an antisymmetric <a class="uri" href="preorder" title="wikilink">preorder</a>.</p>

<p>A set with a partial order is called a <strong>partially ordered set</strong> (also called a <strong>poset</strong>). The term <em>ordered set</em> is sometimes also used for posets, as long as it is clear from the context that no other kinds of orders are meant. In particular, totally ordered sets can also be referred to as "ordered sets", especially in areas where these structures are more common than posets.</p>

<p>For <em>a, b</em> distinct elements of a partially ordered set <em>P</em>, if <em>a ≤ b</em> or <em>b ≤ a</em>, then <em>a</em> and <em>b</em> are <strong>comparable</strong>. Otherwise they are <strong>incomparable</strong>. If every two elements of a poset are comparable, the poset is called a <a href="totally_ordered_set" title="wikilink">totally ordered set</a> or <strong>chain</strong> (e.g. the natural numbers under order). A poset in which every two elements are incomparable is called an <a class="uri" href="antichain" title="wikilink">antichain</a>.</p>
<h3 id="examples">Examples</h3>

<p>Standard examples of posets arising in mathematics include:</p>
<ul>
<li>The <a href="real_number" title="wikilink">real numbers</a> ordered by the standard <em>less-than-or-equal</em> relation ≤ (a totally ordered set as well).</li>
<li>The set of <a href="subset" title="wikilink">subsets</a> of a given set (its <a href="power_set" title="wikilink">power set</a>) ordered by <a href="subset" title="wikilink">inclusion</a></li>
<li>The set of subspaces of a <a href="vector_space" title="wikilink">vector space</a> ordered by inclusion.</li>
<li>For a partially ordered set <em>P</em>, the <a href="sequence_space" title="wikilink">sequence space</a> containing all <a href="sequence" title="wikilink">sequences</a> of elements from <em>P</em>, where sequence <em>a</em> precedes sequence <em>b</em> if every item in <em>a</em> precedes the corresponding item in <em>b</em>. Formally, <big>(<em>a</em><sub><em>n</em></sub>)<sub><em>n</em>∈ℕ</sub> ≤ (<em>b</em><sub><em>n</em></sub>)<sub><em>n</em>∈ℕ</sub></big> if and only if <big><em>a</em><sub><em>n</em></sub> ≤ <em>b</em><sub><em>n</em></sub></big> for all <em>n</em> in ℕ.</li>
<li>For a set <em>X</em> and a partially ordered set <em>P</em>, the <a href="function_space" title="wikilink">function space</a> containing all functions from <em>X</em> to <em>P</em>, where <em>f</em> ≤ <em>g</em> if and only if <em>f</em>(<em>x</em>) ≤ <em>g</em>(<em>x</em>) for all <em>x</em> in <em>X</em>.</li>
<li>The vertex set of a <a href="directed_acyclic_graph" title="wikilink">directed acyclic graph</a> ordered by <a class="uri" href="reachability" title="wikilink">reachability</a>.</li>
<li>The set of <a href="natural_numbers" title="wikilink">natural numbers</a> equipped with the relation of <a class="uri" href="divisibility" title="wikilink">divisibility</a>.</li>
</ul>
<h3 id="extrema">Extrema</h3>

<p>There are several notions of "greatest" and "least" element in a poset <em>P</em>, notably:</p>
<ul>
<li><a href="Greatest_element" title="wikilink">Greatest element</a> and least element: An element <em>g</em> in <em>P</em> is a greatest element if for every element <em>a</em> in <em>P</em>, <em>a</em> ≤ <em>g</em>. An element <em>m</em> in <em>P</em> is a least element if for every element <em>a</em> in <em>P</em>, <em>a</em> ≥ <em>m</em>. A poset can only have one greatest or least element.</li>
<li><a href="Maximal_element" title="wikilink">Maximal elements</a> and minimal elements: An element <em>g</em> in P is a maximal element if there is no element <em>a</em> in <em>P</em> such that <em>a</em> &gt; <em>g</em>. Similarly, an element <em>m</em> in <em>P</em> is a minimal element if there is no element <em>a</em> in P such that <em>a</em> &lt; <em>m</em>. If a poset has a greatest element, it must be the unique maximal element, but otherwise there can be more than one maximal element, and similarly for least elements and minimal elements.</li>
<li><a href="Upper_and_lower_bounds" title="wikilink">Upper and lower bounds</a>: For a subset <em>A</em> of <em>P</em>, an element <em>x</em> in <em>P</em> is an upper bound of <em>A</em> if <em>a</em> ≤ <em>x</em>, for each element <em>a</em> in <em>A</em>. In particular, <em>x</em> need not be in <em>A</em> to be an upper bound of <em>A</em>. Similarly, an element <em>x</em> in <em>P</em> is a lower bound of <em>A</em> if <em>a</em> ≥ <em>x</em>, for each element <em>a</em> in <em>A</em>. A greatest element of <em>P</em> is an upper bound of <em>P</em> itself, and a least element is a lower bound of <em>P</em>.</li>
</ul>

<p>For example, consider the natural numbers, ordered by divisibility: 1 is a least element, as it divides all other elements, but this set does not have a greatest element nor does it have any maximal elements: any <em>g</em> divides 2<em>g</em>, so 2<em>g</em> is greater than <em>g</em> and <em>g</em> cannot be maximal. If instead we consider only the natural numbers that are greater than 1, then the resulting poset does not have a least element, but any <a href="prime_number" title="wikilink">prime number</a> is a minimal element. In this poset, 60 is an upper bound (though not the least upper bound) of {2,3,5} and 2 is a lower bound of {4,6,8,12}.</p>
<h3 id="additional-structure">Additional structure</h3>

<p>In many such cases, the poset has additional structure: For example, the poset can be a <a href="lattice_(order)" title="wikilink">lattice</a> or a <a href="ordered_semigroup" title="wikilink">partially ordered algebraic structure</a>.</p>
<h4 id="lattices">Lattices</h4>

<p>A <a href="Partially_ordered_set" title="wikilink">poset</a> (<em>L</em>, ≤) is a <strong>lattice</strong> if it satisfies the following two axioms.</p>
<dl>
<dt>Existence of binary joins:</dt>
<dd>For any two elements <em>a</em> and <em>b</em> of <em>L</em>, the set {<em>a, b</em>} has a <strong><a href="Join_(mathematics)" title="wikilink">join</a></strong>

<math display="block" id="Ordinal_optimization:0">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo>∨</mo>
   <mi>b</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <or></or>
    <ci>a</ci>
    <ci>b</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a\lor b
  </annotation>
 </semantics>
</math>

 (also known as the least upper bound, or the supremum).
</dd>
<dt>Existence of binary meets:</dt>
<dd>For any two elements <em>a</em> and <em>b</em> of <em>L</em>, the set {<em>a, b</em>} has a <strong><a href="meet_(mathematics)" title="wikilink">meet</a></strong>

<math display="block" id="Ordinal_optimization:1">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo>∧</mo>
   <mi>b</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <ci>a</ci>
    <ci>b</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a\land b
  </annotation>
 </semantics>
</math>

 (also known as the greatest lower bound, or the infimum).
</dd>
</dl>

<p>The join and meet of <em>a</em> and <em>b</em> are denoted by 

<math display="inline" id="Ordinal_optimization:2">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo>∨</mo>
   <mi>b</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <or></or>
    <ci>a</ci>
    <ci>b</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a\lor b
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Ordinal_optimization:3">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo>∧</mo>
   <mi>b</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <ci>a</ci>
    <ci>b</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a\land b
  </annotation>
 </semantics>
</math>

, respectively. This definition makes 

<math display="inline" id="Ordinal_optimization:4">
 <semantics>
  <mo>∨</mo>
  <annotation-xml encoding="MathML-Content">
   <or></or>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lor
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Ordinal_optimization:5">
 <semantics>
  <mo>∧</mo>
  <annotation-xml encoding="MathML-Content">
   <and></and>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \land
  </annotation>
 </semantics>
</math>

 <a href="binary_operation" title="wikilink">binary operations</a>. The first axiom says that <em>L</em> is a <a class="uri" href="join-semilattice" title="wikilink">join-semilattice</a>; the second says that <em>L</em> is a <a class="uri" href="meet-semilattice" title="wikilink">meet-semilattice</a>. Both operations are monotone with respect to the order: <em>a</em><sub>1</sub> ≤ <em>a</em><sub>2</sub> and <em>b</em><sub>1</sub> ≤ <em>b</em><sub>2</sub> implies that a<sub>1</sub>

<math display="inline" id="Ordinal_optimization:6">
 <semantics>
  <mo>∨</mo>
  <annotation-xml encoding="MathML-Content">
   <or></or>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lor
  </annotation>
 </semantics>
</math>

 b<sub>1</sub> ≤ a<sub>2</sub> 

<math display="inline" id="Ordinal_optimization:7">
 <semantics>
  <mo>∨</mo>
  <annotation-xml encoding="MathML-Content">
   <or></or>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lor
  </annotation>
 </semantics>
</math>

 b<sub>2</sub> and a<sub>1</sub>

<math display="inline" id="Ordinal_optimization:8">
 <semantics>
  <mo>∧</mo>
  <annotation-xml encoding="MathML-Content">
   <and></and>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \land
  </annotation>
 </semantics>
</math>

b<sub>1</sub> ≤ a<sub>2</sub>

<math display="inline" id="Ordinal_optimization:9">
 <semantics>
  <mo>∧</mo>
  <annotation-xml encoding="MathML-Content">
   <and></and>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \land
  </annotation>
 </semantics>
</math>

b<sub>2</sub>.</p>

<p>It follows by an <a href="mathematical_induction" title="wikilink">induction</a> argument that every non-empty finite subset of a lattice has a join (supremum) and a meet (infimum). With additional assumptions, further conclusions may be possible; <em>see</em> <a href="Completeness_(order_theory)" title="wikilink">Completeness (order theory)</a> for more discussion of this subject.</p>

<p>A <strong>bounded lattice</strong> has a <a href="greatest_element" title="wikilink">greatest</a> (or maximum) and <a href="least_element" title="wikilink">least</a> (or minimum) element, denoted 1 and 0 by convention (also called <strong>top</strong> and <strong>bottom</strong>). Any lattice can be converted into a bounded lattice by adding a greatest and least element, and every non-empty finite lattice is bounded, by taking the join (resp., meet) of all elements, denoted by 

<math display="inline" id="Ordinal_optimization:10">
 <semantics>
  <mrow>
   <mrow>
    <mo largeop="true" mathsize="160%" stretchy="false" symmetric="true">⋁</mo>
    <mi>A</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>a</mi>
     <mn>1</mn>
    </msub>
    <mo>∨</mo>
    <mi mathvariant="normal">⋯</mi>
    <mo>∨</mo>
    <msub>
     <mi>a</mi>
     <mi>n</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <or></or>
     <ci>A</ci>
    </apply>
    <apply>
     <or></or>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-⋯</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bigvee A=a_{1}\lor\cdots\lor a_{n}
  </annotation>
 </semantics>
</math>

 (resp.

<math display="inline" id="Ordinal_optimization:11">
 <semantics>
  <mrow>
   <mrow>
    <mo largeop="true" mathsize="160%" stretchy="false" symmetric="true">⋀</mo>
    <mi>A</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>a</mi>
     <mn>1</mn>
    </msub>
    <mo>∧</mo>
    <mi mathvariant="normal">⋯</mi>
    <mo>∧</mo>
    <msub>
     <mi>a</mi>
     <mi>n</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <and></and>
     <ci>A</ci>
    </apply>
    <apply>
     <and></and>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-⋯</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bigwedge A=a_{1}\land\cdots\land a_{n}
  </annotation>
 </semantics>
</math>

) where 

<math display="inline" id="Ordinal_optimization:12">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <msub>
     <mi>a</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>a</mi>
     <mi>n</mi>
    </msub>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>A</ci>
    <set>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <ci>n</ci>
     </apply>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A=\{a_{1},\ldots,a_{n}\}
  </annotation>
 </semantics>
</math>

.</p>

<p>A poset is a bounded lattice if and only if every finite set of elements (including the empty set) has a join and a meet. Here, the join of an empty set of elements is defined to be the least element 

<math display="inline" id="Ordinal_optimization:13">
 <semantics>
  <mrow>
   <mrow>
    <mo largeop="true" mathsize="160%" stretchy="false" symmetric="true">⋁</mo>
    <mi mathvariant="normal">∅</mi>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <or></or>
     <emptyset></emptyset>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bigvee\varnothing=0
  </annotation>
 </semantics>
</math>

, and the meet of the empty set is defined to be the greatest element 

<math display="inline" id="Ordinal_optimization:14">
 <semantics>
  <mrow>
   <mrow>
    <mo largeop="true" mathsize="160%" stretchy="false" symmetric="true">⋀</mo>
    <mi mathvariant="normal">∅</mi>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <and></and>
     <emptyset></emptyset>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bigwedge\varnothing=1
  </annotation>
 </semantics>
</math>

. This convention is consistent with the associativity and commutativity of meet and join: the join of a union of finite sets is equal to the join of the joins of the sets, and dually, the meet of a union of finite sets is equal to the meet of the meets of the sets, i.e., for finite subsets <em>A</em> and <em>B</em> of a poset <em>L</em>,</p>

<p>

<math display="block" id="Ordinal_optimization:15">
 <semantics>
  <mrow>
   <mrow>
    <mo largeop="true" mathsize="160%" movablelimits="false" stretchy="false" symmetric="true">⋁</mo>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mi>A</mi>
      <mo>∪</mo>
      <mi>B</mi>
     </mrow>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mo largeop="true" mathsize="160%" movablelimits="false" stretchy="false" symmetric="true">⋁</mo>
      <mi>A</mi>
     </mrow>
     <mo>)</mo>
    </mrow>
    <mo>∨</mo>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mo largeop="true" mathsize="160%" movablelimits="false" stretchy="false" symmetric="true">⋁</mo>
      <mi>B</mi>
     </mrow>
     <mo>)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <or></or>
     <apply>
      <union></union>
      <ci>A</ci>
      <ci>B</ci>
     </apply>
    </apply>
    <apply>
     <or></or>
     <apply>
      <or></or>
      <ci>A</ci>
     </apply>
     <apply>
      <or></or>
      <ci>B</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bigvee\left(A\cup B\right)=\left(\bigvee A\right)\vee\left(\bigvee B\right)
  </annotation>
 </semantics>
</math>

</p>

<p>and</p>

<p>

<math display="block" id="Ordinal_optimization:16">
 <semantics>
  <mrow>
   <mrow>
    <mo largeop="true" mathsize="160%" movablelimits="false" stretchy="false" symmetric="true">⋀</mo>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mi>A</mi>
      <mo>∪</mo>
      <mi>B</mi>
     </mrow>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mo largeop="true" mathsize="160%" movablelimits="false" stretchy="false" symmetric="true">⋀</mo>
      <mi>A</mi>
     </mrow>
     <mo>)</mo>
    </mrow>
    <mo>∧</mo>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mo largeop="true" mathsize="160%" movablelimits="false" stretchy="false" symmetric="true">⋀</mo>
      <mi>B</mi>
     </mrow>
     <mo>)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <and></and>
     <apply>
      <union></union>
      <ci>A</ci>
      <ci>B</ci>
     </apply>
    </apply>
    <apply>
     <and></and>
     <apply>
      <and></and>
      <ci>A</ci>
     </apply>
     <apply>
      <and></and>
      <ci>B</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bigwedge\left(A\cup B\right)=\left(\bigwedge A\right)\wedge\left(\bigwedge B\right)
  </annotation>
 </semantics>
</math>

</p>

<p>hold. Taking <em>B</em> to be the empty set,</p>

<p>

<math display="block" id="Ordinal_optimization:17">
 <semantics>
  <mrow>
   <mrow>
    <mo largeop="true" mathsize="160%" movablelimits="false" stretchy="false" symmetric="true">⋁</mo>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mi>A</mi>
      <mo>∪</mo>
      <mi mathvariant="normal">∅</mi>
     </mrow>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mo largeop="true" mathsize="160%" movablelimits="false" stretchy="false" symmetric="true">⋁</mo>
      <mi>A</mi>
     </mrow>
     <mo>)</mo>
    </mrow>
    <mo>∨</mo>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mo largeop="true" mathsize="160%" movablelimits="false" stretchy="false" symmetric="true">⋁</mo>
      <mi mathvariant="normal">∅</mi>
     </mrow>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mo largeop="true" mathsize="160%" movablelimits="false" stretchy="false" symmetric="true">⋁</mo>
      <mi>A</mi>
     </mrow>
     <mo>)</mo>
    </mrow>
    <mo>∨</mo>
    <mn>0</mn>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo largeop="true" mathsize="160%" movablelimits="false" stretchy="false" symmetric="true">⋁</mo>
    <mi>A</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <or></or>
      <apply>
       <union></union>
       <ci>A</ci>
       <emptyset></emptyset>
      </apply>
     </apply>
     <apply>
      <or></or>
      <apply>
       <or></or>
       <ci>A</ci>
      </apply>
      <apply>
       <or></or>
       <emptyset></emptyset>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <or></or>
      <apply>
       <or></or>
       <ci>A</ci>
      </apply>
      <cn type="integer">0</cn>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <or></or>
      <ci>A</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bigvee\left(A\cup\emptyset\right)=\left(\bigvee A\right)\vee\left(\bigvee%
\emptyset\right)=\left(\bigvee A\right)\vee 0=\bigvee A
  </annotation>
 </semantics>
</math>

</p>

<p>and</p>

<p>

<math display="block" id="Ordinal_optimization:18">
 <semantics>
  <mrow>
   <mrow>
    <mo largeop="true" mathsize="160%" movablelimits="false" stretchy="false" symmetric="true">⋀</mo>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mi>A</mi>
      <mo>∪</mo>
      <mi mathvariant="normal">∅</mi>
     </mrow>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mo largeop="true" mathsize="160%" movablelimits="false" stretchy="false" symmetric="true">⋀</mo>
      <mi>A</mi>
     </mrow>
     <mo>)</mo>
    </mrow>
    <mo>∧</mo>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mo largeop="true" mathsize="160%" movablelimits="false" stretchy="false" symmetric="true">⋀</mo>
      <mi mathvariant="normal">∅</mi>
     </mrow>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mo largeop="true" mathsize="160%" movablelimits="false" stretchy="false" symmetric="true">⋀</mo>
      <mi>A</mi>
     </mrow>
     <mo>)</mo>
    </mrow>
    <mo>∧</mo>
    <mn>1</mn>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo largeop="true" mathsize="160%" movablelimits="false" stretchy="false" symmetric="true">⋀</mo>
    <mi>A</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <and></and>
      <apply>
       <union></union>
       <ci>A</ci>
       <emptyset></emptyset>
      </apply>
     </apply>
     <apply>
      <and></and>
      <apply>
       <and></and>
       <ci>A</ci>
      </apply>
      <apply>
       <and></and>
       <emptyset></emptyset>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <and></and>
      <apply>
       <and></and>
       <ci>A</ci>
      </apply>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <and></and>
      <ci>A</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bigwedge\left(A\cup\emptyset\right)=\left(\bigwedge A\right)\wedge\left(%
\bigwedge\emptyset\right)=\left(\bigwedge A\right)\wedge 1=\bigwedge A
  </annotation>
 </semantics>
</math>

</p>

<p>which is consistent with the fact that 

<math display="inline" id="Ordinal_optimization:19">
 <semantics>
  <mrow>
   <mrow>
    <mi>A</mi>
    <mo>∪</mo>
    <mi mathvariant="normal">∅</mi>
   </mrow>
   <mo>=</mo>
   <mi>A</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <union></union>
     <ci>A</ci>
     <emptyset></emptyset>
    </apply>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\cup\emptyset=A
  </annotation>
 </semantics>
</math>

.</p>
<h4 id="ordered-algebraic-structure">Ordered algebraic structure</h4>

<p>The poset can be a <a href="Ordered_semigroup" title="wikilink">partially ordered algebraic structure</a>.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a><a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a><a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a><a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a><a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a><a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a><a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a></p>

<p>In <a class="uri" href="algebra" title="wikilink">algebra</a>, an <em>ordered semigroup</em> is a <a class="uri" href="semigroup" title="wikilink">semigroup</a> (<em>S</em>,•) together with a <a href="partial_order" title="wikilink">partial order</a> ≤ that is <em>compatible</em> with the semigroup operation, meaning that <em>x</em> ≤ <em>y</em> implies z•x ≤ z•y and x•z ≤ y•z for all <em>x</em>, <em>y</em>, <em>z</em> in <em>S</em>. If S is a <a href="Group_(mathematics)" title="wikilink">group</a> and it is ordered as a semigroup, one obtains the notion of <a href="ordered_group" title="wikilink">ordered group</a>, and similarly if S is a <a class="uri" href="monoid" title="wikilink">monoid</a> it may be called <em>ordered monoid</em>. <a href="Ordered_vector_space" title="wikilink">Partially ordered vector spaces</a> and <a href="Riesz_space" title="wikilink">vector lattices</a> are important in <a href="multiobjective_optimization" title="wikilink">optimization with multiple objectives</a>.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a></p>
<h2 id="ordinal-optimization-in-computer-science-and-statistics">Ordinal optimization in computer science and statistics</h2>

<p>Problems of ordinal optimization arise in many disciplines. <a href="Computer_science" title="wikilink">Computer scientists</a> study <a href="selection_algorithm" title="wikilink">selection algorithms</a>, which are simpler than <a href="sorting_algorithm" title="wikilink">sorting algorithms</a>.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a><a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a></p>

<p><a href="Statistical_decision_theory" title="wikilink">Statistical decision theory</a> studies "selection problems" that require the identification of a "best" subpopulation or of identifying a "near best" subpopulation.<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a><a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a><a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a><a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a><a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a></p>
<h2 id="applications">Applications</h2>

<p>Since the 1960s, the field of ordinal optimization has expanded in theory and in applications. In particular, <a href="antimatroid" title="wikilink">antimatroids</a> and the "<a href="max-plus_algebra" title="wikilink">max-plus algebra</a>" have found application in <a href="flow_network" title="wikilink">network analysis</a> and <a href="queuing_theory" title="wikilink">queuing theory</a>, particularly in queuing networks and <a href="discrete_event_simulation" title="wikilink">discrete-event systems</a>.<a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a><a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a><a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Stochastic_optimization" title="wikilink">Stochastic optimization</a></li>
<li><a href="Computational_complexity_theory" title="wikilink">Computational complexity theory</a></li>
<li><a href="Heuristic_(computer_science)" title="wikilink">Heuristics</a></li>
<li><a href="Level_of_measurement" title="wikilink">Level of measurement</a> ("Ordinal data")</li>
</ul>
<h2 id="references">References</h2>
<h2 id="further-reading">Further reading</h2>
<ul>
<li>Fujishige, Satoru <em>Submodular functions and optimization</em>. Second edition. Annals of Discrete Mathematics, 58. Elsevier B. V., Amsterdam, 2005. xiv+395 pp. ISBN 0-444-52086-4</li>
<li>Gondran, Michel; Minoux, Michel <em>Graphs, dioids and semirings. New models and algorithms</em>. Operations Research/Computer Science Interfaces Series, 41. Springer, New York, 2008. xx+383 pp. ISBN 978-0-387-75449-9</li>
<li>Dietrich, B. L.; Hoffman, A. J. On greedy algorithms, partially ordered sets, and submodular functions. <em>IBM J. Res. Develop.</em> 47 (2003), no. 1, 25–30.</li>
<li>Murota, Kazuo <em>Discrete convex analysis</em>. SIAM Monographs on Discrete Mathematics and Applications. Society for Industrial and Applied Mathematics (SIAM), Philadelphia, PA, 2003. xxii+389 pp. ISBN 0-89871-540-7</li>
<li>Topkis, Donald M. <em>Supermodularity and complementarity</em>. Frontiers of Economic Research. Princeton University Press, Princeton, NJ, 1998. xii+272 pp. ISBN 0-691-03244-0</li>
<li>Singer, Ivan <em>Abstract convex analysis</em>. Canadian Mathematical Society Series of Monographs and Advanced Texts. A Wiley-Interscience Publication. John Wiley &amp; Sons, Inc., New York, 1997. xxii+491 pp. ISBN 0-471-16015-6</li>
<li>Björner, Anders; Ziegler, Günter M. Introduction to greedoids. <em>Matroid applications</em>, 284–357, Encyclopedia Math. Appl., 40, Cambridge Univ. Press, Cambridge, 1992,</li>
<li>Zimmermann, U. <em>Linear and combinatorial optimization in ordered algebraic structures</em>. Ann. Discrete Math. 10 (1981), viii+380 pp.</li>
<li>Cuninghame-Green, Raymond <em>Minimax algebra</em>. Lecture Notes in Economics and Mathematical Systems, 166. Springer-Verlag, Berlin-New York, 1979. xi+258 pp. ISBN 3-540-09113-0</li>
<li></li>
<li></li>
<li></li>
<li><a href="Yu-Chi_Ho" title="wikilink">Ho, Y.C.</a>, Sreenivas, R., Vakili, P.,"Ordinal Optimization of Discrete Event Dynamic Systems", J. of DEDS 2(2), 61-88, (1992).</li>
<li>Allen, Eric, and Marija D. Ilic. <em>Price-Based Commitment Decisions in the Electricity Market</em>. Advances in industrial control. London: Springer, 1999. ISBN 978-1-85233-069-9</li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://people.deas.harvard.edu/~ho/DEDS/OO/Reference/OOReference.html">Annotated bibliography on ordinal optimization</a> by <a href="Yu-Chi_Ho" title="wikilink">Yu-Chi Ho</a></li>
</ul>

<p>"</p>

<p><a href="Category:Mathematical_optimization" title="wikilink">Category:Mathematical optimization</a> <a href="Category:Control_theory" title="wikilink">Category:Control theory</a> <a href="Category:Order_theory" title="wikilink">Category:Order theory</a> <a href="Category:Optimization_of_ordered_sets" title="wikilink">Category:Optimization of ordered sets</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><code>Dietrich,</code> <code>B.</code> <code>L.;</code> <code>Hoffman,</code> <code>A.</code> <code>J.</code> <code>On</code> <code>greedy</code> <code>algorithms,</code> <code>partially</code> <code>ordered</code> <code>sets,</code> <code>and</code> <code>submodular</code> <code>functions.</code> <em><code>IBM</code> <code>J.</code> <code>Res.</code> <code>Develop.</code></em> <code>47</code> <code>(2003),</code> <code>no.</code> <code>1,</code> <code>25–30.</code><a href="#fnref1">↩</a></li>
<li id="fn2"><code>Topkis,</code> <code>Donald</code> <code>M.</code> <em><code>Supermodularity</code> <code>and</code> <code>complementarity</code></em><code>.</code> <code>Frontiers</code> <code>of</code> <code>Economic</code> <code>Research.</code> <code>Princeton</code> <code>University</code> <code>Press,</code> <code>Princeton,</code> <code>NJ,</code> <code>1998.</code> <code>xii+272</code> <code>pp.</code> <code>ISBN</code> <code>0-691-03244-0</code><a href="#fnref2">↩</a></li>
<li id="fn3"><code>Singer,</code> <code>Ivan</code> <em><code>Abstract</code> <code>convex</code> <code>analysis</code></em><code>.</code> <code>Canadian</code> <code>Mathematical</code> <code>Society</code> <code>Series</code> <code>of</code> <code>Monographs</code> <code>and</code> <code>Advanced</code> <code>Texts.</code> <code>A</code> <code>Wiley-Interscience</code> <code>Publication.</code> <code>John</code> <code>Wiley</code> <code>&amp;</code> <code>Sons,</code> <code>Inc.,</code> <code>New</code> <code>York,</code> <code>1997.</code> <code>xxii+491</code> <code>pp.</code> <code>ISBN</code> <code>0-471-16015-6</code><a href="#fnref3">↩</a></li>
<li id="fn4"><code>Björner,</code> <code>Anders;</code> <code>Ziegler,</code> <code>Günter</code> <code>M.</code> <code>Introduction</code> <code>to</code> <code>greedoids.</code> <em><code>Matroid</code> <code>applications</code></em><code>,</code> <code>284–357,</code> <code>Encyclopedia</code> <code>Math.</code> <code>Appl.,</code> <code>40,</code> <code>Cambridge</code> <code>Univ.</code> <code>Press,</code> <code>Cambridge,</code> <code>1992,</code><a href="#fnref4">↩</a></li>
<li id="fn5">Fujishige, Satoru <em>Submodular functions and optimization</em>. Second edition. Annals of Discrete Mathematics, 58. Elsevier B. V., Amsterdam, 2005. xiv+395 pp. ISBN 0-444-52086-4<a href="#fnref5">↩</a></li>
<li id="fn6">Gondran, Michel; Minoux, Michel <em>Graphs, dioids and semirings. New models and algorithms</em>. Operations Research/Computer Science Interfaces Series, 41. Springer, New York, 2008. xx+383 pp. ISBN 978-0-387-75449-9<a href="#fnref6">↩</a></li>
<li id="fn7">Dietrich, B. L.; Hoffman, A. J. On greedy algorithms, partially ordered sets, and submodular functions. <em>IBM J. Res. Develop.</em> 47 (2003), no. 1, 25–30.<a href="#fnref7">↩</a></li>
<li id="fn8">Murota, Kazuo <em>Discrete convex analysis</em>. SIAM Monographs on Discrete Mathematics and Applications. Society for Industrial and Applied Mathematics (SIAM), Philadelphia, PA, 2003. xxii+389 pp. ISBN 0-89871-540-7<a href="#fnref8">↩</a></li>
<li id="fn9">Topkis, Donald M. <em>Supermodularity and complementarity</em>. Frontiers of Economic Research. Princeton University Press, Princeton, NJ, 1998. xii+272 pp. ISBN 0-691-03244-0<a href="#fnref9">↩</a></li>
<li id="fn10">Zimmermann, U. <em>Linear and combinatorial optimization in ordered algebraic structures</em>. Ann. Discrete Math. 10 (1981), viii+380 pp.<a href="#fnref10">↩</a></li>
<li id="fn11">Cuninghame-Green, Raymond <em>Minimax algebra</em>. Lecture Notes in Economics and Mathematical Systems, 166. Springer-Verlag, Berlin-New York, 1979. xi+258 pp. ISBN 3-540-09113-0<a href="#fnref11">↩</a></li>
<li id="fn12"><a href="#fnref12">↩</a></li>
<li id="fn13"><a href="Donald_Knuth" title="wikilink">Donald Knuth</a>. <em><a href="The_Art_of_Computer_Programming" title="wikilink">The Art of Computer Programming</a></em>, Volume 3: <em>Sorting and Searching</em>, Third Edition. Addison-Wesley, 1997. ISBN 0-201-89685-0. Section 5.3.3: Minimum-Comparison Selection, pp.207–219.<a href="#fnref13">↩</a></li>
<li id="fn14"><a href="Thomas_H._Cormen" title="wikilink">Thomas H. Cormen</a>, <a href="Charles_E._Leiserson" title="wikilink">Charles E. Leiserson</a>, <a href="Ronald_L._Rivest" title="wikilink">Ronald L. Rivest</a>, and <a href="Clifford_Stein" title="wikilink">Clifford Stein</a>. <em><a href="Introduction_to_Algorithms" title="wikilink">Introduction to Algorithms</a></em>, Second Edition. MIT Press and McGraw-Hill, 2001. ISBN 0-262-03293-7. Chapter 9: Medians and Order Statistics, pp.183–196. Section 14.1: Dynamic order statistics, pp.302–308.<a href="#fnref14">↩</a></li>
<li id="fn15">Gibbons, Jean Dickinson; <a href="Ingram_Olkin" title="wikilink">Olkin, Ingram</a>, and Sobel, Milton, <em>Selecting and Ordering of Populations</em>, Wiley, (1977). (Republished as a Classic in Applied Mathematics by SIAM.)<a href="#fnref15">↩</a></li>
<li id="fn16"> (Republished as a Classic in Applied Mathematics by SIAM.)<a href="#fnref16">↩</a></li>
<li id="fn17">Santner, Thomas J., and Tamhane, A. C., <em>Design of Experiments: Ranking and Selection</em>, M. Dekker, (1984).<a href="#fnref17">↩</a></li>
<li id="fn18">Robert E. Bechhofer, Thomas J. Santner, David M. Goldsman. <em>Design and Analysis of Experiments for Statistical Selection, Screening, and Multiple Comparisons</em>. John Wiley &amp; Sons, 1995.<a href="#fnref18">↩</a></li>
<li id="fn19">Friedrich Liese, Klaus-J. Miescke. 2008. <em>Statistical Decision Theory: Estimation, Testing, and Selection</em>. Springer Verlag.<a href="#fnref19">↩</a></li>
<li id="fn20"><a href="#fnref20">↩</a></li>
<li id="fn21"><a href="#fnref21">↩</a></li>
<li id="fn22"><a href="#fnref22">↩</a></li>
</ol>
</section>
</hr></body>
</html>
