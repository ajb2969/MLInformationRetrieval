<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="86">Pumping lemma for regular languages</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Pumping lemma for regular languages</h1>
<hr/>

<p>In the theory of <a href="formal_language" title="wikilink">formal languages</a>, the <strong>pumping <a href="Lemma_(mathematics)" title="wikilink">lemma</a> for regular languages</strong> describes an essential property of all <a href="regular_language" title="wikilink">regular languages</a>. Informally, it says that all sufficiently long words in a regular language may be <em>pumped</em> — that is, have a middle section of the word repeated an arbitrary number of times — to produce a new word that also lies within the same language.</p>

<p>Specifically, the pumping lemma says that for any regular language <em>L</em> there exists a constant <em>p</em> such that any word <em>w</em> in <em>L</em> with length at least <em>p</em> can be split into three substrings, <em>w</em> = <em>xyz</em>, where the middle portion <em>y</em> must not be empty, such that the words <em>xz</em>, <em>xyz</em>, <em>xyyz</em>, <em>xyyyz</em>, … constructed by repeating <em>y</em> an arbitrary number of times (including zero times) are still in <em>L</em>. This process of repetition is known as "pumping". Moreover, the pumping lemma guarantees that the length of <em>xy</em> will be at most <em>p</em>, imposing a limit on the ways in which <em>w</em> may be split. Finite languages trivially satisfy the pumping lemma by having <em>p</em> equal to the maximum string length in <em>L</em> plus one.</p>

<p>The pumping lemma is useful for disproving the regularity of a specific language in question. It was first proved by <a href="Dana_Scott" title="wikilink">Dana Scott</a> and <a href="Michael_O._Rabin" title="wikilink">Michael Rabin</a> in 1959,<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> and rediscovered shortly after by <a href="Yehoshua_Bar-Hillel" title="wikilink">Yehoshua Bar-Hillel</a>, <a href="Micha_A._Perles" title="wikilink">Micha A. Perles</a>, and <a href="Eli_Shamir" title="wikilink">Eli Shamir</a> in 1961, as a simplification of their <a href="pumping_lemma_for_context-free_languages" title="wikilink">pumping lemma for context-free languages</a>.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a><a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>
<h2 id="formal-statement">Formal statement</h2>

<p>Let <em>L</em> be a regular language. Then there exists an integer <em>p</em> ≥ 1 depending only on <em>L</em> such that every string <em>w</em> in <em>L</em> of length at least <em>p</em> (<em>p</em> is called the "pumping length"<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a>) can be written as <em>w</em> = <em>xyz</em> (i.e., <em>w</em> can be divided into three substrings), satisfying the following conditions:</p>
<ol>
<li>|<em>y</em>| ≥ 1;</li>
<li>|<em>xy</em>| ≤ <em>p</em></li>
<li>for all <em>i</em> ≥ 0, <em>xy</em><sup>i</sup><em>z</em> ∈ <em>L</em></li>
</ol>

<p><em>y</em> is the substring that can be pumped (removed or repeated any number of times, and the resulting string is always in <em>L</em>). (1) means the loop <em>y</em> to be pumped must be of length at least one; (2) means the loop must occur within the first <em>p</em> characters. |<em>x</em>| must be smaller than <em>p</em> (conclusion of (1) and (2)), apart from that there is no restriction on <em>x</em> and <em>z</em>.</p>

<p>In simple words, for any regular language L, any sufficiently long word w (in L) can be split into 3 parts. i.e. w = xyz , such that all the strings xy<sup>k</sup>z for k≥0 are also in L.</p>

<p>Below is a formal expression of the Pumping Lemma.</p>

<p>

<math display="inline" id="Pumping_lemma_for_regular_languages:0">
 <semantics>
  <mtable>
   <mtr>
    <mtd columnalign="left">
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <mo>∀</mo>
        <mi>L</mi>
       </mrow>
       <mo>⊆</mo>
       <msup>
        <mi mathvariant="normal">Σ</mi>
        <mo>*</mo>
       </msup>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="left">
     <mrow>
      <mo lspace="12.5pt" stretchy="false">(</mo>
      <mtext>regular</mtext>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>L</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>⇒</mo>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="left">
     <mrow>
      <mo lspace="12.5pt" stretchy="false">(</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mo>∃</mo>
       <mi>p</mi>
       <mo>≥</mo>
       <mn>1</mn>
       <mo stretchy="false">)</mo>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mo stretchy="false">(</mo>
        <mo>∀</mo>
        <mi>w</mi>
        <mo>∈</mo>
        <mi>L</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mo stretchy="false">(</mo>
         <mo stretchy="false">|</mo>
         <mi>w</mi>
         <mo stretchy="false">|</mo>
         <mo>≥</mo>
         <mi>p</mi>
         <mo stretchy="false">)</mo>
        </mrow>
        <mo>⇒</mo>
       </mrow>
      </mrow>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="left">
     <mrow>
      <mrow>
       <mrow>
        <mrow>
         <mrow>
          <mo lspace="12.5pt" stretchy="false">(</mo>
          <mrow>
           <mo stretchy="false">(</mo>
           <mo>∃</mo>
           <mi>x</mi>
           <mo>,</mo>
           <mi>y</mi>
           <mo>,</mo>
           <mi>z</mi>
           <mo>∈</mo>
           <msup>
            <mi mathvariant="normal">Σ</mi>
            <mo>*</mo>
           </msup>
           <mo stretchy="false">)</mo>
          </mrow>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>w</mi>
           <mo>=</mo>
           <mi>x</mi>
           <mi>y</mi>
           <mi>z</mi>
           <mo>∧</mo>
           <mrow>
            <mo stretchy="false">(</mo>
            <mo stretchy="false">|</mo>
            <mi>y</mi>
            <mo stretchy="false">|</mo>
            <mo>≥</mo>
            <mn>1</mn>
            <mo>∧</mo>
            <mo stretchy="false">|</mo>
            <mi>x</mi>
            <mi>y</mi>
            <mo stretchy="false">|</mo>
            <mo>≤</mo>
            <mi>p</mi>
            <mo>∧</mo>
            <mrow>
             <mo stretchy="false">(</mo>
             <mo>∀</mo>
             <mi>i</mi>
             <mo>≥</mo>
             <mn>0</mn>
             <mo stretchy="false">)</mo>
            </mrow>
            <mrow>
             <mo stretchy="false">(</mo>
             <mi>x</mi>
             <msup>
              <mi>y</mi>
              <mi>i</mi>
             </msup>
             <mi>z</mi>
             <mo>∈</mo>
             <mi>L</mi>
             <mo stretchy="false">)</mo>
            </mrow>
            <mo stretchy="false">)</mo>
           </mrow>
           <mo stretchy="false">)</mo>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mtd>
   </mtr>
  </mtable>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <apply>
      <subset></subset>
      <apply>
       <csymbol cd="latexml">for-all</csymbol>
       <ci>L</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>normal-Σ</ci>
       <times></times>
      </apply>
     </apply>
    </matrixrow>
    <matrixrow>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <mtext>regular</mtext>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">L</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-⇒</ci>
     </cerror>
    </matrixrow>
    <matrixrow>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <exists></exists>
       <csymbol cd="unknown">p</csymbol>
       <geq></geq>
       <cn type="integer">1</cn>
       <ci>normal-)</ci>
      </cerror>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <csymbol cd="latexml">for-all</csymbol>
        <csymbol cd="unknown">w</csymbol>
        <in></in>
        <csymbol cd="unknown">L</csymbol>
        <ci>normal-)</ci>
       </cerror>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <cerror>
         <csymbol cd="ambiguous">fragments</csymbol>
         <ci>normal-(</ci>
         <ci>normal-|</ci>
         <csymbol cd="unknown">w</csymbol>
         <ci>normal-|</ci>
         <geq></geq>
         <csymbol cd="unknown">p</csymbol>
         <ci>normal-)</ci>
        </cerror>
        <ci>normal-⇒</ci>
       </cerror>
      </cerror>
     </cerror>
    </matrixrow>
    <matrixrow>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <cerror>
         <csymbol cd="ambiguous">fragments</csymbol>
         <cerror>
          <csymbol cd="ambiguous">fragments</csymbol>
          <ci>normal-(</ci>
          <cerror>
           <csymbol cd="ambiguous">fragments</csymbol>
           <ci>normal-(</ci>
           <exists></exists>
           <csymbol cd="unknown">x</csymbol>
           <ci>normal-,</ci>
           <csymbol cd="unknown">y</csymbol>
           <ci>normal-,</ci>
           <csymbol cd="unknown">z</csymbol>
           <in></in>
           <apply>
            <csymbol cd="ambiguous">superscript</csymbol>
            <ci>normal-Σ</ci>
            <times></times>
           </apply>
           <ci>normal-)</ci>
          </cerror>
          <cerror>
           <csymbol cd="ambiguous">fragments</csymbol>
           <ci>normal-(</ci>
           <csymbol cd="unknown">w</csymbol>
           <eq></eq>
           <csymbol cd="unknown">x</csymbol>
           <csymbol cd="unknown">y</csymbol>
           <csymbol cd="unknown">z</csymbol>
           <and></and>
           <cerror>
            <csymbol cd="ambiguous">fragments</csymbol>
            <ci>normal-(</ci>
            <ci>normal-|</ci>
            <csymbol cd="unknown">y</csymbol>
            <ci>normal-|</ci>
            <geq></geq>
            <cn type="integer">1</cn>
            <and></and>
            <ci>normal-|</ci>
            <csymbol cd="unknown">x</csymbol>
            <csymbol cd="unknown">y</csymbol>
            <ci>normal-|</ci>
            <leq></leq>
            <csymbol cd="unknown">p</csymbol>
            <and></and>
            <cerror>
             <csymbol cd="ambiguous">fragments</csymbol>
             <ci>normal-(</ci>
             <csymbol cd="latexml">for-all</csymbol>
             <csymbol cd="unknown">i</csymbol>
             <geq></geq>
             <cn type="integer">0</cn>
             <ci>normal-)</ci>
            </cerror>
            <cerror>
             <csymbol cd="ambiguous">fragments</csymbol>
             <ci>normal-(</ci>
             <csymbol cd="unknown">x</csymbol>
             <apply>
              <csymbol cd="ambiguous">superscript</csymbol>
              <ci>y</ci>
              <ci>i</ci>
             </apply>
             <csymbol cd="unknown">z</csymbol>
             <in></in>
             <csymbol cd="unknown">L</csymbol>
             <ci>normal-)</ci>
            </cerror>
            <ci>normal-)</ci>
           </cerror>
           <ci>normal-)</ci>
          </cerror>
          <ci>normal-)</ci>
         </cerror>
         <ci>normal-)</ci>
        </cerror>
        <ci>normal-)</ci>
       </cerror>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{array}[]{l}(\forall L\subseteq\Sigma^{*})\\
\quad(\mbox{regular}(L)\Rightarrow\\
\quad((\exists p\geq 1)((\forall w\in L)((|w|\geq p)\Rightarrow\\
\quad((\exists x,y,z\in\Sigma^{*})(w=xyz\land(|y|\geq 1\land|xy|\leq p\land(%
\forall i\geq 0)(xy^{i}z\in L))))))))\end{array}
  </annotation>
 </semantics>
</math>

</p>
<h2 id="use-of-lemma">Use of lemma</h2>

<p>The pumping lemma is often used to prove that a particular language is non-regular: a <a href="proof_by_contradiction" title="wikilink">proof by contradiction</a> (of the language's regularity) may consist of exhibiting a word (of the required length) in the language which lacks the property outlined in the pumping lemma.</p>

<p>For example the language <em>L</em> = {<em>a<sup>n</sup>b<sup>n</sup></em> : <em>n</em> ≥ 0} over the alphabet Σ = {<em>a</em>, <em>b</em>} can be shown to be non-regular as follows. Let <em>w</em>, <em>x</em>, <em>y</em>, <em>z</em>, <em>p</em>, and <em>i</em> be as used in the <a href="Pumping_lemma_for_regular_languages#Formal_statement" title="wikilink">formal statement for the pumping lemma</a> above. Let <em>w</em> in <em>L</em> be given by <em>w</em> = <em>a<sup>p</sup>b<sup>p</sup></em>. By the pumping lemma, there must be some decomposition <em>w</em> = <em>xyz</em> with |<em>xy</em>| ≤ <em>p</em> and |<em>y</em>| ≥ 1 such that <em>xy<sup>i</sup>z</em> in L for every <em>i</em> ≥ 0. Using |<em>xy</em>| ≤ <em>p</em>, we know <em>y</em> only consists of instances of <em>a</em>. Moreover, because |<em>y</em>| ≥ 1, it contains at least one instance of the letter <em>a</em>. We now pump <em>y</em> up: <em>xy<sup>2</sup>z</em> has more instances of the letter <em>a</em> than the letter <em>b</em>, since we have added some instances of <em>a</em> without adding instances of <em>b</em>. Therefore <em>xy<sup>2</sup>z</em> is not in <em>L</em>. We have reached a contradiction. Therefore, the assumption that <em>L</em> is regular must be incorrect. Hence <em>L</em> is not regular.</p>

<p>The proof that the <a href="Dyck_language" title="wikilink">language of balanced (i.e., properly nested) parentheses</a> is not regular follows the same idea. Given <em>p</em>, there is a string of balanced parentheses that begins with more than <em>p</em> left parentheses, so that <em>y</em> will consist entirely of left parentheses. By repeating <em>y</em>, we can produce a string that does not contain the same number of left and right parentheses, and so they cannot be balanced.</p>
<h2 id="proof-of-the-pumping-lemma">Proof of the pumping lemma</h2>

<p> For every regular language there is a <a href="finite_state_automaton" title="wikilink">finite state automaton</a> (FSA) that accepts the language. The number of states in such an FSA are counted and that count is used as the pumping length <em>p</em>. For a string of length at least <em>p</em>, let <em>q</em><sub>0</sub> be the start state and let <em>q</em><sub>1</sub>, ..., <em>q</em><sub><em>p</em></sub> be the sequence of the next <em>p</em> states visited as the string is emitted. Because the FSA has only <em>p</em> states, within this sequence of <em>p</em> + 1 visited states there must be at least one state that is repeated. Write <em>q</em><sub><em>s</em></sub> for such a state. The transitions that take the machine from the first encounter of state <em>q</em><sub><em>s</em></sub> to the second encounter of state <em>q</em><sub><em>s</em></sub> match some string. This string is called <em>y</em> in the lemma, and since the machine will match a string without the <em>y</em> portion, or with the string <em>y</em> repeated any number of times, the conditions of the lemma are satisfied.</p>

<p>For example, the following image shows an FSA.</p>
<figure><b>(Figure)</b>
<figcaption>An automat accepting the language a(bc)*d.svg</figcaption>
</figure>

<p>The FSA accepts the string: <strong>abcd</strong>. Since this string has a length which is at least as large as the number of states, which is four, the <a href="pigeonhole_principle" title="wikilink">pigeonhole principle</a> indicates that there must be at least one repeated state among the start state and the next four visited states. In this example, only <em>q</em><sub>1</sub> is a repeated state. Since the substring <strong>bc</strong> takes the machine through transitions that start at state <em>q</em><sub>1</sub> and end at state <em>q</em><sub>1</sub>, that portion could be repeated and the FSA would still accept, giving the string <strong>abcbcd</strong>. Alternatively, the <strong>bc</strong> portion could be removed and the FSA would still accept giving the string <strong>ad</strong>. In terms of the pumping lemma, the string <strong>abcd</strong> is broken into an <em>x</em> portion <strong>a</strong>, a <em>y</em> portion <strong>bc</strong> and a <em>z</em> portion <strong>d</strong>.</p>
<h2 id="general-version-of-pumping-lemma-for-regular-languages">General version of pumping lemma for regular languages</h2>

<p>If a language <em>L</em> is regular, then there exists a number <em>p</em> ≥ 1 (the pumping length) such that every string <em>uwv</em> in <em>L</em> with |<em>w</em>| ≥ <em>p</em> can be written in the form</p>
<dl>
<dd><em>uwv</em> = <em>uxyzv</em>
</dd>
</dl>

<p>with strings <em>x</em>, <em>y</em> and <em>z</em> such that |<em>xy</em>| ≤ <em>p</em>, |<em>y</em>| ≥ 1 and</p>
<dl>
<dd><em>uxy<sup>i</sup>zv</em> is in <em>L</em> for every integer <em>i</em> ≥ 0.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a>
</dd>
</dl>

<p>This version can be used to prove many more languages are non-regular, since it imposes stricter requirements on the language.</p>
<h2 id="converse-of-lemma-not-true">Converse of lemma not true</h2>

<p>Note that while the pumping lemma states that all regular languages satisfy the conditions described above, the converse of this statement is not true: a language that satisfies these conditions may still be non-regular. In other words, both the original and the general version of the pumping lemma give a <a href="Necessary_and_sufficient_condition" title="wikilink"><em>necessary</em> but not <em>sufficient</em> condition</a> for a language to be regular.</p>

<p>For example, consider the following language <em>L</em>: 

<math display="inline" id="Pumping_lemma_for_regular_languages:1">
 <semantics>
  <mtable>
   <mtr>
    <mtd columnalign="right">
     <mi>L</mi>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mo>=</mo>
      <mrow>
       <mo stretchy="false">{</mo>
       <mi>u</mi>
       <mi>v</mi>
       <mi>w</mi>
       <mi>x</mi>
       <mi>y</mi>
       <mo>:</mo>
       <mi>u</mi>
       <mo>,</mo>
       <mi>y</mi>
       <mo>∈</mo>
       <msup>
        <mrow>
         <mo stretchy="false">{</mo>
         <mn>0</mn>
         <mo>,</mo>
         <mn>1</mn>
         <mo>,</mo>
         <mn>2</mn>
         <mo>,</mo>
         <mn>3</mn>
         <mo stretchy="false">}</mo>
        </mrow>
        <mo>*</mo>
       </msup>
       <mo>;</mo>
       <mi>v</mi>
       <mo>,</mo>
       <mi>w</mi>
       <mo>,</mo>
       <mi>x</mi>
       <mo>∈</mo>
       <mrow>
        <mo stretchy="false">{</mo>
        <mn>0</mn>
        <mo>,</mo>
        <mn>1</mn>
        <mo>,</mo>
        <mn>2</mn>
        <mo>,</mo>
        <mn>3</mn>
        <mo stretchy="false">}</mo>
       </mrow>
       <mi mathvariant="italic">and</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>v</mi>
        <mo>=</mo>
        <mi>w</mi>
        <mi>v</mi>
        <mo>=</mo>
        <mi>x</mi>
        <mi>x</mi>
        <mo>=</mo>
        <mi>w</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <mo stretchy="false">}</mo>
      </mrow>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd></mtd>
    <mtd columnalign="left">
     <mrow>
      <mo>∪</mo>
      <mrow>
       <mo stretchy="false">{</mo>
       <mi>w</mi>
       <mo>:</mo>
       <mrow>
        <mi>w</mi>
        <mo>∈</mo>
        <mrow>
         <msup>
          <mrow>
           <mo stretchy="false">{</mo>
           <mn>0</mn>
           <mo>,</mo>
           <mn>1</mn>
           <mo>,</mo>
           <mn>2</mn>
           <mo>,</mo>
           <mn>3</mn>
           <mo stretchy="false">}</mo>
          </mrow>
          <mo>*</mo>
         </msup>
         <mi mathvariant="italic">and</mi>
         <mtext>precisely 1/7 of the characters in</mtext>
         <mi>w</mi>
         <mtext>are 3’s</mtext>
        </mrow>
       </mrow>
       <mo stretchy="false">}</mo>
      </mrow>
     </mrow>
    </mtd>
   </mtr>
  </mtable>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <ci>L</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <eq></eq>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-{</ci>
       <csymbol cd="unknown">u</csymbol>
       <csymbol cd="unknown">v</csymbol>
       <csymbol cd="unknown">w</csymbol>
       <csymbol cd="unknown">x</csymbol>
       <csymbol cd="unknown">y</csymbol>
       <ci>normal-:</ci>
       <csymbol cd="unknown">u</csymbol>
       <ci>normal-,</ci>
       <csymbol cd="unknown">y</csymbol>
       <in></in>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <cerror>
         <csymbol cd="ambiguous">fragments</csymbol>
         <ci>normal-{</ci>
         <cn type="integer">0</cn>
         <ci>normal-,</ci>
         <cn type="integer">1</cn>
         <ci>normal-,</ci>
         <cn type="integer">2</cn>
         <ci>normal-,</ci>
         <cn type="integer">3</cn>
         <ci>normal-}</ci>
        </cerror>
        <times></times>
       </apply>
       <ci>normal-;</ci>
       <csymbol cd="unknown">v</csymbol>
       <ci>normal-,</ci>
       <csymbol cd="unknown">w</csymbol>
       <ci>normal-,</ci>
       <csymbol cd="unknown">x</csymbol>
       <in></in>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-{</ci>
        <cn type="integer">0</cn>
        <ci>normal-,</ci>
        <cn type="integer">1</cn>
        <ci>normal-,</ci>
        <cn type="integer">2</cn>
        <ci>normal-,</ci>
        <cn type="integer">3</cn>
        <ci>normal-}</ci>
       </cerror>
       <csymbol cd="unknown">and</csymbol>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <csymbol cd="unknown">v</csymbol>
        <eq></eq>
        <csymbol cd="unknown">w</csymbol>
        <csymbol cd="unknown">v</csymbol>
        <eq></eq>
        <csymbol cd="unknown">x</csymbol>
        <csymbol cd="unknown">x</csymbol>
        <eq></eq>
        <csymbol cd="unknown">w</csymbol>
        <ci>normal-)</ci>
       </cerror>
       <ci>normal-}</ci>
      </cerror>
     </cerror>
    </matrixrow>
    <matrixrow>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <apply>
      <union></union>
      <apply>
       <csymbol cd="latexml">conditional-set</csymbol>
       <ci>w</ci>
       <apply>
        <in></in>
        <ci>w</ci>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <set>
           <cn type="integer">0</cn>
           <cn type="integer">1</cn>
           <cn type="integer">2</cn>
           <cn type="integer">3</cn>
          </set>
          <times></times>
         </apply>
         <ci>italic- and</ci>
         <mtext>precisely 1/7 of the characters in</mtext>
         <ci>w</ci>
         <mtext>are 3’s</mtext>
        </apply>
       </apply>
      </apply>
     </apply>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{aligned}\displaystyle L&\displaystyle=\{uvwxy:u,y\in\{0,1,2,3\}^{*};v,w%
,x\in\{0,1,2,3\}\and(v=wv=xx=w)\}\\
&\displaystyle\cup\{w:w\in\{0,1,2,3\}^{*}\and\text{precisely 1/7 of the %
characters in }w\text{ are 3's}\}\end{aligned}
  </annotation>
 </semantics>
</math>


.</p>

<p>In other words, <em>L</em> contains all strings over the alphabet {0,1,2,3} with a substring of length 3 including a duplicate character, as well as all strings over this alphabet where precisely 1/7 of the string's characters are 3's. This language is not regular but can still be "pumped" with <em>p</em> = 5. Suppose some string <em>s</em> has length at least 5. Then, since the alphabet has only four characters, at least two of the five characters in the string must be duplicates. They are separated by at most three characters.</p>
<ul>
<li>If the duplicate characters are separated by 0 characters, or 1, pump one of the other two characters in the string, which will not affect the substring containing the duplicates.</li>
<li>If the duplicate characters are separated by 2 or 3 characters, pump 2 of the characters separating them. Pumping either down or up results in the creation of a substring of size 3 that contains 2 duplicate characters.</li>
<li>The second condition of <em>L</em> ensures that <em>L</em> is not regular: i.e., there are an infinite number of strings that are in <em>L</em> but cannot be obtained by pumping some smaller string in <em>L</em>.</li>
</ul>

<p>For a practical test that exactly characterizes regular languages, see the <a href="Myhill-Nerode_theorem" title="wikilink">Myhill-Nerode theorem</a>. The typical method for proving that a language is regular is to construct either a <a href="finite_state_machine" title="wikilink">finite state machine</a> or a <a href="regular_expression" title="wikilink">regular expression</a> for the language.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Pumping_lemma_for_context-free_languages" title="wikilink">Pumping lemma for context-free languages</a></li>
<li><a href="Ogden's_lemma" title="wikilink">Ogden's lemma</a></li>
</ul>
<h2 id="notes">Notes</h2>
<references>
</references>
<h2 id="references">References</h2>
<ul>
<li></li>
<li></li>
<li>

<p><em>(See chapter 3.)</em></p></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://weitz.de/pump/">The pumping game</a> (An online game demonstrating the pumping lemma)</li>
</ul>

<p><a href="de:Pumping-Lemma#Reguläre_Sprachen" title="wikilink">de:Pumping-Lemma#Reguläre Sprachen</a>"</p>

<p><a href="Category:Formal_languages" title="wikilink">Category:Formal languages</a> <a class="uri" href="Category:Lemmas" title="wikilink">Category:Lemmas</a> <a href="Category:Automata_theory" title="wikilink">Category:Automata theory</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"> Here: Lemma 8, p.119<a href="#fnref1">↩</a></li>
<li id="fn2">.<a href="#fnref2">↩</a></li>
<li id="fn3"> Here: Sect.4.6, p.166<a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
</ol>
</section>
</body>
</html>
