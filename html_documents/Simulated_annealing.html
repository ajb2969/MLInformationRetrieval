<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="652">Simulated annealing</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Simulated annealing</h1>
<hr/>

<p><strong>Simulated annealing (SA)</strong> is a generic <a href="probabilistic_algorithm" title="wikilink">probabilistic</a> <a class="uri" href="metaheuristic" title="wikilink">metaheuristic</a> for the <a href="global_optimization" title="wikilink">global optimization</a> problem of locating a good approximation to the <a href="global_optimum" title="wikilink">global optimum</a> of a given <a href="function_(mathematics)" title="wikilink">function</a> in a large <a href="Mathematical_optimization#Optimization_problems" title="wikilink">search space</a>. It is often used when the search space is discrete (e.g., all tours that visit a given set of cities). For certain problems, simulated annealing may be more efficient than <a href="brute_force_search" title="wikilink">exhaustive enumeration</a> — provided that the goal is merely to find an acceptably good solution in a fixed amount of time, rather than the best possible solution.</p>

<p>The name and inspiration come from <a href="annealing_(metallurgy)" title="wikilink">annealing in metallurgy</a>, a technique involving heating and controlled cooling of a material to increase the size of its <a href="crystal" title="wikilink">crystals</a> and reduce their <a href="crystallographic_defect" title="wikilink">defects</a>. Both are attributes of the material that depend on its <a href="thermodynamic_free_energy" title="wikilink">thermodynamic free energy</a>. Heating and cooling the material affects both the temperature and the thermodynamic free energy. While the same amount of cooling brings the same amount of decrease in temperature it will bring a bigger or smaller decrease in the thermodynamic free energy depending on the rate that it occurs, with a slower rate producing a bigger decrease.</p>

<p>This notion of slow cooling is implemented in the Simulated Annealing algorithm as a slow decrease in the probability of accepting worse solutions as it explores the solution space. Accepting worse solutions is a fundamental property of metaheuristics because it allows for a more extensive search for the optimal solution.</p>

<p>The method was independently described by Scott Kirkpatrick, C. Daniel Gelatt and Mario P. Vecchi in 1983,<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> and by Vlado Černý in 1985.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> The method is an adaptation of the <a href="Metropolis–Hastings_algorithm" title="wikilink">Metropolis–Hastings algorithm</a>, a <a href="Monte_Carlo_method" title="wikilink">Monte Carlo method</a> to generate sample states of a thermodynamic system, invented by <a href="Marshall_Rosenbluth" title="wikilink">M.N. Rosenbluth</a> and published in a paper by <a href="Nicholas_Metropolis" title="wikilink">N. Metropolis</a> et al. in 1953.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>
<h2 id="overview">Overview</h2>

<p>The <a href="thermodynamic_state" title="wikilink">state</a> of some <a href="physical_system" title="wikilink">physical systems</a>, and the function <em>E</em>(<em>s</em>) to be minimized is analogous to the <a href="internal_energy" title="wikilink">internal energy</a> of the system in that state. The goal is to bring the system, from an arbitrary <em>initial state</em>, to a state with the minimum possible energy.</p>

<p> </p>
<h3 id="the-basic-iteration">The basic iteration</h3>

<p>At each step, the SA heuristic considers some neighbouring state ''s' ''of the current state <em>s</em>, and <a href="probabilistic" title="wikilink">probabilistically</a> decides between moving the system to state ''s' ''or staying in state <em>s</em>. These probabilities ultimately lead the system to move to states of lower energy. Typically this step is repeated until the system reaches a state that is good enough for the application, or until a given computation budget has been exhausted.</p>
<h3 id="the-neighbours-of-a-state">The neighbours of a state</h3>

<p>The neighbours of a state are new states of the problem that are produced after altering a given state in some well-defined way. For example, in the <a href="traveling_salesman_problem" title="wikilink">traveling salesman problem</a> each state is typically defined as a <a class="uri" href="permutation" title="wikilink">permutation</a> of the cities to be visited. The neighbours of a state are the set of permutations that are produced, for example, by reversing the order of any two successive cities. The well-defined way in which the states are altered in order to find neighbouring states is called a "move" and different moves give different sets of neighbouring states. These moves usually result in minimal alterations of the last state, as the previous example depicts, in order to help the algorithm keep the better parts of the solution and change only the worse parts. In the traveling salesman problem, the parts of the solution are the city connections.</p>

<p>Searching for neighbours of a state is fundamental to optimization because the final solution will come after a tour of successive neighbours. Simple <a href="heuristic" title="wikilink">heuristics</a> move by finding best neighbour after best neighbour and stop when they have reached a solution which has no neighbours that are better solutions. The problem with this approach is that the neighbours of a state are not guaranteed to contain any of the existing better solutions which means that failure to find a better solution among them does not guarantee that no better solution exists. This is why the best solution found by such algorithms is called a <a href="local_optimum" title="wikilink">local optimum</a> in contrast with the actual best solution which is called a <a href="global_optimum" title="wikilink">global optimum</a>. Metaheuristics use the neighbours of a solution as a way to explore the solutions space and although they prefer better neighbours they also accept worse neighbours in order to avoid getting stuck in local optima. As a result, if the algorithm is run for an infinite amount of time, the global optimum will be found.</p>
<h3 id="acceptance-probabilities">Acceptance probabilities</h3>

<p>The probability of making the <a href="state_transition" title="wikilink">transition</a> from the current state 

<math display="inline" id="Simulated_annealing:0">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

 to a candidate new state 

<math display="inline" id="Simulated_annealing:1">
 <semantics>
  <msup>
   <mi>s</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>s</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s^{\prime}
  </annotation>
 </semantics>
</math>

 is specified by an <em>acceptance probability function</em> 

<math display="inline" id="Simulated_annealing:2">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>e</mi>
    <mo>,</mo>
    <msup>
     <mi>e</mi>
     <mo>′</mo>
    </msup>
    <mo>,</mo>
    <mi>T</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <vector>
     <ci>e</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>e</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>T</ci>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(e,e^{\prime},T)
  </annotation>
 </semantics>
</math>

, that depends on the energies 

<math display="inline" id="Simulated_annealing:3">
 <semantics>
  <mrow>
   <mi>e</mi>
   <mo>=</mo>
   <mrow>
    <mi>E</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>s</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>e</ci>
    <apply>
     <times></times>
     <ci>E</ci>
     <ci>s</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e=E(s)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Simulated_annealing:4">
 <semantics>
  <mrow>
   <msup>
    <mi>e</mi>
    <mo>′</mo>
   </msup>
   <mo>=</mo>
   <mrow>
    <mi>E</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>s</mi>
      <mo>′</mo>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>e</ci>
     <ci>normal-′</ci>
    </apply>
    <apply>
     <times></times>
     <ci>E</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>s</ci>
      <ci>normal-′</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e^{\prime}=E(s^{\prime})
  </annotation>
 </semantics>
</math>

 of the two states, and on a global time-varying parameter 

<math display="inline" id="Simulated_annealing:5">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

 called the <em>temperature</em>. States with a smaller energy are better than those with a greater energy. The probability function 

<math display="inline" id="Simulated_annealing:6">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 must be positive even when 

<math display="inline" id="Simulated_annealing:7">
 <semantics>
  <msup>
   <mi>e</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>e</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e^{\prime}
  </annotation>
 </semantics>
</math>

 is greater than 

<math display="inline" id="Simulated_annealing:8">
 <semantics>
  <mi>e</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>e</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e
  </annotation>
 </semantics>
</math>

. This feature prevents the method from becoming stuck at a local minimum that is worse than the global one.</p>

<p>When 

<math display="inline" id="Simulated_annealing:9">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

 tends to zero, the probability 

<math display="inline" id="Simulated_annealing:10">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>e</mi>
    <mo>,</mo>
    <msup>
     <mi>e</mi>
     <mo>′</mo>
    </msup>
    <mo>,</mo>
    <mi>T</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <vector>
     <ci>e</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>e</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>T</ci>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(e,e^{\prime},T)
  </annotation>
 </semantics>
</math>

 must tend to zero if 

<math display="inline" id="Simulated_annealing:11">
 <semantics>
  <mrow>
   <msup>
    <mi>e</mi>
    <mo>′</mo>
   </msup>
   <mo>></mo>
   <mi>e</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>e</ci>
     <ci>normal-′</ci>
    </apply>
    <ci>e</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e^{\prime}>e
  </annotation>
 </semantics>
</math>

 and to a positive value otherwise. For sufficiently small values of 

<math display="inline" id="Simulated_annealing:12">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

, the system will then increasingly favor moves that go "downhill" (i.e., to lower energy values), and avoid those that go "uphill." With 

<math display="inline" id="Simulated_annealing:13">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>T</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T=0
  </annotation>
 </semantics>
</math>

 the procedure reduces to the <a href="greedy_algorithm" title="wikilink">greedy algorithm</a>, which makes only the downhill transitions.</p>

<p>In the original description of SA, the probability 

<math display="inline" id="Simulated_annealing:14">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>e</mi>
    <mo>,</mo>
    <msup>
     <mi>e</mi>
     <mo>′</mo>
    </msup>
    <mo>,</mo>
    <mi>T</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <vector>
     <ci>e</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>e</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>T</ci>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(e,e^{\prime},T)
  </annotation>
 </semantics>
</math>

 was equal to 1 when 

<math display="inline" id="Simulated_annealing:15">
 <semantics>
  <mrow>
   <msup>
    <mi>e</mi>
    <mo>′</mo>
   </msup>
   <mo><</mo>
   <mi>e</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>e</ci>
     <ci>normal-′</ci>
    </apply>
    <ci>e</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e^{\prime}<e
  </annotation>
 </semantics>
</math>

 — i.e., the procedure always moved downhill when it found a way to do so, irrespective of the temperature. Many descriptions and implementations of SA still take this condition as part of the method's definition. However, this condition is not essential for the method to work.</p>

<p>The 

<math display="inline" id="Simulated_annealing:16">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 function is usually chosen so that the probability of accepting a move decreases when the difference 

<math display="inline" id="Simulated_annealing:17">
 <semantics>
  <mrow>
   <msup>
    <mi>e</mi>
    <mo>′</mo>
   </msup>
   <mo>-</mo>
   <mi>e</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>e</ci>
     <ci>normal-′</ci>
    </apply>
    <ci>e</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e^{\prime}-e
  </annotation>
 </semantics>
</math>

 increases—that is, small uphill moves are more likely than large ones. However, this requirement is not strictly necessary, provided that the above requirements are met.</p>

<p>Given these properties, the temperature 

<math display="inline" id="Simulated_annealing:18">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

 plays a crucial role in controlling the evolution of the state 

<math display="inline" id="Simulated_annealing:19">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

 of the system with regard to its sensitivity to the variations of system energies. To be precise, for a large 

<math display="inline" id="Simulated_annealing:20">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

, the evolution of 

<math display="inline" id="Simulated_annealing:21">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

 is sensitive to coarser energy variations, while it is sensitive to finer energy variations when 

<math display="inline" id="Simulated_annealing:22">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

 is small.</p>
<h3 id="the-annealing-schedule">The annealing schedule</h3>

<p>The name and inspiration of the algorithm demand an interesting feature related to the temperature variation to be embedded in the operational characteristics of the algorithm. This necessitates a gradual reduction of the temperature as the simulation proceeds. The algorithm starts initially with 

<math display="inline" id="Simulated_annealing:23">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

 set to a high value (or infinity), and then it is decreased at each step following some <em>annealing schedule</em>—which may be specified by the user, but must end with 

<math display="inline" id="Simulated_annealing:24">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>T</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T=0
  </annotation>
 </semantics>
</math>

 towards the end of the allotted time budget. In this way, the system is expected to wander initially towards a broad region of the search space containing good solutions, ignoring small features of the energy function; then drift towards low-energy regions that become narrower and narrower; and finally move downhill according to the <a href="steepest_descent" title="wikilink">steepest descent</a> heuristic.</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;"><figure><b>(Figure)</b>
<figcaption>Fast</figcaption>
</figure></td>
<td style="text-align: left;"><figure><b>(Figure)</b>
<figcaption>Slow</figcaption>
</figure></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Example illustrating the effect of cooling schedule on the performance of simulated annealing. The problem is to rearrange the <a href="pixel" title="wikilink">pixels</a> of an image so as to minimize a certain <a href="potential_energy" title="wikilink">potential energy</a> function, which causes similar <a href="colour" title="wikilink">colours</a> to attract at short range and repel at a slightly larger distance. The elementary moves swap two adjacent pixels. These images were obtained with a fast cooling schedule (left) and a slow cooling schedule (right), producing results similar to <a href="amorphous_solid" title="wikilink">amorphous</a> and <a href="crystalline_solid" title="wikilink">crystalline solids</a>, respectively.</p></td>
</tr>
</tbody>
</table>

<p>For any given finite problem, the probability that the simulated annealing algorithm terminates with a <a href="global_optimum" title="wikilink">global optimal</a> solution approaches 1 as the annealing schedule is extended.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> This theoretical result, however, is not particularly helpful, since the time required to ensure a significant probability of success will usually exceed the time required for a <a href="Brute-force_search" title="wikilink">complete search</a> of the <a href="solution_space" title="wikilink">solution space</a>.</p>
<h2 id="pseudocode">Pseudocode</h2>

<p>The following <a class="uri" href="pseudocode" title="wikilink">pseudocode</a> presents the simulated annealing heuristic as described above. It starts from a state <mtpl></mtpl> and continues to either a maximum of <mtpl></mtpl> steps or until a state with an energy of <mtpl></mtpl> or less is found. In the process, the call 

<math display="inline" id="Simulated_annealing:25">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mi>e</mi>
   <mi>i</mi>
   <mi>g</mi>
   <mi>h</mi>
   <mi>b</mi>
   <mi>o</mi>
   <mi>u</mi>
   <mi>r</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>s</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>n</ci>
    <ci>e</ci>
    <ci>i</ci>
    <ci>g</ci>
    <ci>h</ci>
    <ci>b</ci>
    <ci>o</ci>
    <ci>u</ci>
    <ci>r</ci>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   neighbour(s)
  </annotation>
 </semantics>
</math>

 should generate a randomly chosen neighbour of a given state 

<math display="inline" id="Simulated_annealing:26">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

; the call 

<math display="inline" id="Simulated_annealing:27">
 <semantics>
  <mrow>
   <mi>r</mi>
   <mi>a</mi>
   <mi>n</mi>
   <mi>d</mi>
   <mi>o</mi>
   <mi>m</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>r</ci>
    <ci>a</ci>
    <ci>n</ci>
    <ci>d</ci>
    <ci>o</ci>
    <ci>m</ci>
    <interval closure="open">
     <cn type="integer">0</cn>
     <cn type="integer">1</cn>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   random(0,1)
  </annotation>
 </semantics>
</math>

 should pick and return a value in the range 

<math display="inline" id="Simulated_annealing:28">
 <semantics>
  <mrow>
   <mrow>
    <mn>0</mn>
    <mo>,</mo>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <cn type="integer">0</cn>
     <ci>normal-,</ci>
     <cn type="integer">1</cn>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-)</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0,1))
  </annotation>
 </semantics>
</math>

, <a href="Uniform_distribution_(continuous)" title="wikilink">uniformly at random</a>. The annealing schedule is defined by the call 

<math display="inline" id="Simulated_annealing:29">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mi>e</mi>
   <mi>m</mi>
   <mi>p</mi>
   <mi>e</mi>
   <mi>r</mi>
   <mi>a</mi>
   <mi>t</mi>
   <mi>u</mi>
   <mi>r</mi>
   <mi>e</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>r</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>t</ci>
    <ci>e</ci>
    <ci>m</ci>
    <ci>p</ci>
    <ci>e</ci>
    <ci>r</ci>
    <ci>a</ci>
    <ci>t</ci>
    <ci>u</ci>
    <ci>r</ci>
    <ci>e</ci>
    <ci>r</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   temperature(r)
  </annotation>
 </semantics>
</math>

, which should yield the temperature to use, given the fraction 

<math display="inline" id="Simulated_annealing:30">
 <semantics>
  <mi>r</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>r</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r
  </annotation>
 </semantics>
</math>

 of the time budget that has been expended so far.</p>
<div style="margin-left: 35px; width: 600px">
<ul>
<li>Let <mtpl> <em>s</em><sub>0</sub>}}</mtpl></li>
<li>For 

<math display="inline" id="Simulated_annealing:31">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>k</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k=0
  </annotation>
 </semantics>
</math>

 through <mtpl></mtpl> (exclusive):
<ul>
<li><mtpl></mtpl></li>
<li>Pick a random neighbour, <mtpl></mtpl></li>
<li>If <mtpl></mtpl>, move to the new state:
<ul>
<li><mtpl></mtpl></li>
</ul></li>
</ul></li>
<li>Output: the final state 

<math display="inline" id="Simulated_annealing:32">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

</li>
</ul>
</div>
<h2 id="selecting-the-parameters">Selecting the parameters</h2>

<p>In order to apply the SA method to a specific problem, one must specify the following parameters: the state space, the energy (goal) function <code>E()</code>, the candidate generator procedure <code>neighbour()</code>, the acceptance probability function <code>P()</code>, and the annealing schedule <code>temperature()</code> AND initial temperature <init temp="">. These choices can have a significant impact on the method's effectiveness. Unfortunately, there are no choices of these parameters that will be good for all problems, and there is no general way to find the best choices for a given problem. The following sections give some general guidelines.</init></p>
<h3 id="diameter-of-the-search-graph">Diameter of the search graph</h3>

<p>Simulated annealing may be modeled as a random walk on a <em>search <a href="graph_theory" title="wikilink">graph</a></em>, whose vertices are all possible states, and whose edges are the candidate moves. An essential requirement for the <code>neighbour()</code> function is that it must provide a sufficiently short path on this graph from the initial state to any state which may be the global optimum. (In other words, the <a href="diameter_(graph_theory)" title="wikilink">diameter</a> of the search graph must be small.) In the traveling salesman example above, for instance, the search space for 

<math display="inline" id="Simulated_annealing:33">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>=</mo>
   <mn>20</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>n</ci>
    <cn type="integer">20</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n=20
  </annotation>
 </semantics>
</math>

 cities has <a href="factorial" title="wikilink">

<math display="inline" id="Simulated_annealing:34">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo lspace="0pt" rspace="3.5pt">!</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <factorial></factorial>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n!
  </annotation>
 </semantics>
</math>

</a> = 2,432,902,008,176,640,000 (2.4 <a class="uri" href="quintillion" title="wikilink">quintillion</a>) states; yet the neighbour generator function that swaps two consecutive cities can get from any state (tour) to any other state in at most 

<math display="inline" id="Simulated_annealing:35">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>n</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>/</mo>
    <mn>2</mn>
   </mrow>
   <mo>=</mo>
   <mn>190</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <ci>n</ci>
      <apply>
       <minus></minus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <cn type="integer">2</cn>
    </apply>
    <cn type="integer">190</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n(n-1)/2=190
  </annotation>
 </semantics>
</math>

 steps (this is equivalent to 

<math display="inline" id="Simulated_annealing:36">
 <semantics>
  <mrow>
   <msubsup>
    <mo largeop="true" symmetric="true">∑</mo>
    <mrow>
     <mi>i</mi>
     <mo>=</mo>
     <mn>1</mn>
    </mrow>
    <mrow>
     <mi>n</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msubsup>
   <mi>i</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <eq></eq>
       <ci>i</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{i=1}^{n-1}i
  </annotation>
 </semantics>
</math>

).</p>
<h3 id="transition-probabilities">Transition probabilities</h3>

<p>To investigate the behavior of simulated annealing on a particular problem, it can be useful to consider the <em>transition probabilities</em> that result from the various design choices made in the implementation of the algorithm. For each edge 

<math display="inline" id="Simulated_annealing:37">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>s</mi>
   <mo>,</mo>
   <msup>
    <mi>s</mi>
    <mo>′</mo>
   </msup>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>s</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>s</ci>
     <ci>normal-′</ci>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (s,s^{\prime})
  </annotation>
 </semantics>
</math>

 of the search graph, the transition probability is defined as the probability that the SA algorithm will move to state 

<math display="inline" id="Simulated_annealing:38">
 <semantics>
  <msup>
   <mi>s</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>s</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s^{\prime}
  </annotation>
 </semantics>
</math>

 when its current state is 

<math display="inline" id="Simulated_annealing:39">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

. This probability depends on the current temperature as specified by <code>temp()</code>, on the order in which the candidate moves are generated by the <code>neighbour()</code> function, and on the acceptance probability function <code>P()</code>. (Note that the transition probability is <strong>not</strong> simply 

<math display="inline" id="Simulated_annealing:40">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>e</mi>
    <mo>,</mo>
    <msup>
     <mi>e</mi>
     <mo>′</mo>
    </msup>
    <mo>,</mo>
    <mi>T</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <vector>
     <ci>e</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>e</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>T</ci>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(e,e^{\prime},T)
  </annotation>
 </semantics>
</math>

, because the candidates are tested serially.)</p>
<h3 id="acceptance-probabilities-1">Acceptance probabilities</h3>

<p>The specification of <code>neighbour()</code>, <code>P()</code>, and <code>temperature()</code> is partially redundant. In practice, it's common to use the same acceptance function <code>P()</code> for many problems, and adjust the other two functions according to the specific problem.</p>

<p>In the formulation of the method by Kirkpatrick et al., the acceptance probability function 

<math display="inline" id="Simulated_annealing:41">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>e</mi>
    <mo>,</mo>
    <msup>
     <mi>e</mi>
     <mo>′</mo>
    </msup>
    <mo>,</mo>
    <mi>T</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <vector>
     <ci>e</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>e</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>T</ci>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(e,e^{\prime},T)
  </annotation>
 </semantics>
</math>

 was defined as 1 if 

<math display="inline" id="Simulated_annealing:42">
 <semantics>
  <mrow>
   <msup>
    <mi>e</mi>
    <mo>′</mo>
   </msup>
   <mo><</mo>
   <mi>e</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>e</ci>
     <ci>normal-′</ci>
    </apply>
    <ci>e</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e^{\prime}<e
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="Simulated_annealing:43">
 <semantics>
  <mrow>
   <mi>exp</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo>-</mo>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <msup>
         <mi>e</mi>
         <mo>′</mo>
        </msup>
        <mo>-</mo>
        <mi>e</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>/</mo>
      <mi>T</mi>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <exp></exp>
    <apply>
     <minus></minus>
     <apply>
      <divide></divide>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>e</ci>
        <ci>normal-′</ci>
       </apply>
       <ci>e</ci>
      </apply>
      <ci>T</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \exp(-(e^{\prime}-e)/T)
  </annotation>
 </semantics>
</math>

 otherwise. This formula was superficially justified by analogy with the transitions of a physical system; it corresponds to the <a href="Metropolis-Hastings_algorithm" title="wikilink">Metropolis-Hastings algorithm</a>, in the case where T=1 and the proposal distribution of Metropolis-Hastings is symmetric. However, this acceptance probability is often used for simulated annealing even when the <code>neighbour()</code> function, which is analogous to the proposal distribution in Metropolis-Hastings, is not symmetric, or not probabilistic at all. As a result, the transition probabilities of the simulated annealing algorithm do not correspond to the transitions of the analogous physical system, and the long-term distribution of states at a constant temperature 

<math display="inline" id="Simulated_annealing:44">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

 need not bear any resemblance to the thermodynamic equilibrium distribution over states of that physical system, at any temperature. Nevertheless, most descriptions of SA assume the original acceptance function, which is probably hard-coded in many implementations of SA.</p>
<h3 id="efficient-candidate-generation">Efficient candidate generation</h3>

<p>When choosing the candidate generator <code>neighbour()</code>, one must consider that after a few iterations of the SA algorithm, the current state is expected to have much lower energy than a random state. Therefore, as a general rule, one should skew the generator towards candidate moves where the energy of the destination state 

<math display="inline" id="Simulated_annealing:45">
 <semantics>
  <msup>
   <mi>s</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>s</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s^{\prime}
  </annotation>
 </semantics>
</math>

 is likely to be similar to that of the current state. This <a class="uri" href="heuristic" title="wikilink">heuristic</a> (which is the main principle of the <a href="Metropolis-Hastings_algorithm" title="wikilink">Metropolis-Hastings algorithm</a>) tends to exclude "very good" candidate moves as well as "very bad" ones; however, the former are usually much less common than the latter, so the heuristic is generally quite effective.</p>

<p>In the traveling salesman problem above, for example, swapping two <em>consecutive</em> cities in a low-energy tour is expected to have a modest effect on its energy (length); whereas swapping two <em>arbitrary</em> cities is far more likely to increase its length than to decrease it. Thus, the consecutive-swap neighbour generator is expected to perform better than the arbitrary-swap one, even though the latter could provide a somewhat shorter path to the optimum (with 

<math display="inline" id="Simulated_annealing:46">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>-</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>n</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n-1
  </annotation>
 </semantics>
</math>

 swaps, instead of 

<math display="inline" id="Simulated_annealing:47">
 <semantics>
  <mrow>
   <mrow>
    <mi>n</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>n</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>/</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <times></times>
     <ci>n</ci>
     <apply>
      <minus></minus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n(n-1)/2
  </annotation>
 </semantics>
</math>

).</p>

<p>A more precise statement of the heuristic is that one should try first candidate states 

<math display="inline" id="Simulated_annealing:48">
 <semantics>
  <msup>
   <mi>s</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>s</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s^{\prime}
  </annotation>
 </semantics>
</math>

 for which 

<math display="inline" id="Simulated_annealing:49">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>E</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>s</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mi>E</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msup>
       <mi>s</mi>
       <mo>′</mo>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>,</mo>
    <mi>T</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <vector>
     <apply>
      <times></times>
      <ci>E</ci>
      <ci>s</ci>
     </apply>
     <apply>
      <times></times>
      <ci>E</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>s</ci>
       <ci>normal-′</ci>
      </apply>
     </apply>
     <ci>T</ci>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(E(s),E(s^{\prime}),T)
  </annotation>
 </semantics>
</math>

 is large. For the "standard" acceptance function 

<math display="inline" id="Simulated_annealing:50">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 above, it means that 

<math display="inline" id="Simulated_annealing:51">
 <semantics>
  <mrow>
   <mrow>
    <mi>E</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>s</mi>
      <mo>′</mo>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>-</mo>
   <mrow>
    <mi>E</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>s</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <apply>
     <times></times>
     <ci>E</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>s</ci>
      <ci>normal-′</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>E</ci>
     <ci>s</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E(s^{\prime})-E(s)
  </annotation>
 </semantics>
</math>

 is on the order of 

<math display="inline" id="Simulated_annealing:52">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

 or less. Thus, in the traveling salesman example above, one could use a <code>neighbour()</code> function that swaps two random cities, where the probability of choosing a city pair vanishes as their distance increases beyond 

<math display="inline" id="Simulated_annealing:53">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

.</p>
<h3 id="barrier-avoidance">Barrier avoidance</h3>

<p>When choosing the candidate generator <code>neighbour()</code> one must also try to reduce the number of "deep" local minima — states (or sets of connected states) that have much lower energy than all its neighbouring states. Such "closed <a href="drainage_basin" title="wikilink">catchment</a> basins" of the energy function may trap the SA algorithm with high probability (roughly proportional to the number of states in the basin) and for a very long time (roughly exponential on the energy difference between the surrounding states and the bottom of the basin).</p>

<p>As a rule, it is impossible to design a candidate generator that will satisfy this goal and also prioritize candidates with similar energy. On the other hand, one can often vastly improve the efficiency of SA by relatively simple changes to the generator. In the traveling salesman problem, for instance, it is not hard to exhibit two tours 

<math display="inline" id="Simulated_annealing:54">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Simulated_annealing:55">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

, with nearly equal lengths, such that (1) 

<math display="inline" id="Simulated_annealing:56">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 is optimal, (2) every sequence of city-pair swaps that converts 

<math display="inline" id="Simulated_annealing:57">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Simulated_annealing:58">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

 goes through tours that are much longer than both, and (3) 

<math display="inline" id="Simulated_annealing:59">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 can be transformed into 

<math display="inline" id="Simulated_annealing:60">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

 by flipping (reversing the order of) a set of consecutive cities. In this example, 

<math display="inline" id="Simulated_annealing:61">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Simulated_annealing:62">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

 lie in different "deep basins" if the generator performs only random pair-swaps; but they will be in the same basin if the generator performs random segment-flips.</p>
<h3 id="cooling-schedule">Cooling schedule</h3>

<p>The physical analogy that is used to justify SA assumes that the cooling rate is low enough for the probability distribution of the current state to be near <a href="thermodynamic_equilibrium" title="wikilink">thermodynamic equilibrium</a> at all times. Unfortunately, the <em>relaxation time</em>—the time one must wait for the equilibrium to be restored after a change in temperature—strongly depends on the "topography" of the energy function and on the current temperature. In the SA algorithm, the relaxation time also depends on the candidate generator, in a very complicated way. Note that all these parameters are usually provided as <a href="procedural_parameter" title="wikilink">black box functions</a> to the SA algorithm. Therefore, the ideal cooling rate cannot be determined beforehand, and should be empirically adjusted for each problem. <a href="Adaptive_simulated_annealing" title="wikilink">Adaptive simulated annealing</a> algorithms address this problem by connecting the cooling schedule to the search progress.</p>
<h2 id="restarts">Restarts</h2>

<p>Sometimes it is better to move back to a solution that was significantly better rather than always moving from the current state. This process is called <em>restarting</em> of simulated annealing. To do this we set <code>s</code> and <code>e</code> to <code>sbest</code> and <code>ebest</code> and perhaps restart the annealing schedule. The decision to restart could be based on several criteria. Notable among these include restarting based on a fixed number of steps, based on whether the current energy is too high compared to the best energy obtained so far, restarting randomly, etc.</p>
<h2 id="related-methods">Related methods</h2>
<ul>
<li><a href="Metropolis–Hastings_algorithm" title="wikilink">Interacting Metropolis-Hasting algorithms</a> (a.k.a. <a href="Particle_filter" title="wikilink">Sequential Monte Carlo</a><a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a>) combined simulated annealing moves with an acceptance-rejection of the best fitted individuals equipped with an interacting recycling mechanism.</li>
<li><a href="Quantum_annealing" title="wikilink">Quantum annealing</a> uses "quantum fluctuations" instead of thermal fluctuations to get through high but thin barriers in the target function.</li>
</ul>
<ul>
<li><a href="Stochastic_tunneling" title="wikilink">Stochastic tunneling</a> attempts to overcome the increasing difficulty simulated annealing runs have in escaping from local minima as the temperature decreases, by 'tunneling' through barriers.</li>
</ul>
<ul>
<li><a href="Tabu_search" title="wikilink">Tabu search</a> normally moves to neighbouring states of lower energy, but will take uphill moves when it finds itself stuck in a local minimum; and avoids cycles by keeping a "taboo list" of solutions already seen.</li>
</ul>
<ul>
<li><a href="Dual-phase_evolution" title="wikilink">Dual-phase evolution</a> is a family of algorithms and processes (to which simulated annealing belongs) that mediate between local and global search by exploiting phase changes in the search space.</li>
</ul>
<ul>
<li><a href="Reactive_search_optimization" title="wikilink">Reactive search optimization</a> focuses on combining machine learning with optimization, by adding an internal feedback loop to self-tune the free parameters of an algorithm to the characteristics of the problem, of the instance, and of the local situation around the current solution.</li>
</ul>
<ul>
<li><a href="Stochastic_gradient_descent" title="wikilink">Stochastic gradient descent</a> runs many greedy searches from random initial locations.</li>
</ul>
<ul>
<li><a href="Genetic_algorithms" title="wikilink">Genetic algorithms</a> maintain a pool of solutions rather than just one. New candidate solutions are generated not only by "mutation" (as in SA), but also by "recombination" of two solutions from the pool. Probabilistic criteria, similar to those used in SA, are used to select the candidates for mutation or combination, and for discarding excess solutions from the pool.</li>
</ul>
<ul>
<li><a href="Graduated_optimization" title="wikilink">Graduated optimization</a> digressively "smooths" the target function while optimizing.</li>
</ul>
<ul>
<li><a href="Ant_colony_optimization" title="wikilink">Ant colony optimization</a> (ACO) uses many ants (or agents) to traverse the solution space and find locally productive areas.</li>
</ul>
<ul>
<li>The <a href="cross-entropy_method" title="wikilink">cross-entropy method</a> (CE) generates candidates solutions via a parameterized probability distribution. The parameters are updated via cross-entropy minimization, so as to generate better samples in the next iteration.</li>
</ul>
<ul>
<li><a href="Harmony_search" title="wikilink">Harmony search</a> mimics musicians in improvisation process where each musician plays a note for finding a best harmony all together.</li>
</ul>
<ul>
<li><a href="Stochastic_optimization" title="wikilink">Stochastic optimization</a> is an umbrella set of methods that includes simulated annealing and numerous other approaches.</li>
</ul>
<ul>
<li><a href="Particle_swarm_optimization" title="wikilink">Particle swarm optimization</a> is an algorithm modelled on swarm intelligence that finds a solution to an optimization problem in a search space, or model and predict social behavior in the presence of objectives.</li>
</ul>
<ul>
<li>The Runner-Root Algorithm (RRA) is a meta-heuristic optimization algorithm for solving unimodal and multimodal problems inspired by the runners and roots of plants in nature.</li>
</ul>
<ul>
<li><a href="Intelligent_Water_Drops" title="wikilink">Intelligent Water Drops</a> (IWD) which mimics the behavior of natural water drops to solve optimization problems</li>
</ul>
<ul>
<li><a href="Parallel_tempering" title="wikilink">Parallel tempering</a> is a simulation of model copies at different temperatures (or <a href="Hamiltonian_(quantum_mechanics)" title="wikilink">Hamiltonians</a>) to overcome the potential barriers.</li>
</ul>
<h2 id="see-also">See also</h2>
<h2 id="references">References</h2>
<h2 id="further-reading">Further reading</h2>
<ul>
<li>A. Das and B. K. Chakrabarti (Eds.), <em>Quantum Annealing and Related Optimization Methods,</em> Lecture Note in Physics, Vol. 679, Springer, Heidelberg (2005)</li>
<li></li>
<li></li>
<li></li>
<li>V.Vassilev, A.Prahova: "The Use of Simulated Annealing in the Control of Flexible Manufacturing Systems", International Journal INFORMATION THEORIES &amp; APPLICATIONS, <a href="http://www.foibg.com/ijita/vol01-09/ijita-fv06.htm">VOLUME 6/1999</a></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://yuval.bar-or.org/index.php?item=9">Simulated Annealing visualization</a> A visualization of a simulated annealing solution to the N-Queens puzzle by Yuval Baror.</li>
<li><a href="http://biomath.ugent.be/~brecht/downloads.html">Global optimization algorithms for MATLAB</a></li>
<li><a href="http://www.heatonresearch.com/articles/64/page1.html">Simulated Annealing</a> A Java applet that allows you to experiment with simulated annealing. Source code included.</li>
<li>[<a class="uri" href="http://www.mathworks.com/matlabcentral/fileexchange/loadFile.do?objectId=10548&amp;objectType">http://www.mathworks.com/matlabcentral/fileexchange/loadFile.do?objectId=10548&amp;objectType;</a>;=file "General Simulated Annealing Algorithm"] An open-source MATLAB program for general simulated annealing exercises.</li>
<li><a href="http://en.wikiversity.org/wiki/Simulated_Annealing_Project">Self-Guided Lesson on Simulated Annealing</a> A Wikiversity project.</li>
<li><a href="http://arstechnica.com/science/news/2009/12/uncertainty-hovers-over-claim-googles-using-quantum-computer.ars">Google in superposition of using, not using quantum computer</a> Ars Technica discusses the possibility that the D-Wave computer being used by google may, in fact, be an efficient SA co-processor</li>
<li><a href="http://www.netlib.org/opt/simann.f">Minimizing Multimodal Functions of Continuous Variables with Simulated Annealing</a> A Fortran 77 simulated annealing code.</li>
<li><a href="http://apmonitor.com/me575/index.php/Main/SimulatedAnnealing">Simulated Annealing Tutorial and Code in Python and MATLAB</a></li>
<li>Simulated Annealing in R via <a href="http://stat.ethz.ch/R-manual/R-patched/library/stats/html/optim.html">optim</a> or <a href="http://cran.r-project.org/web/packages/GenSA/">GenSA</a></li>
<li>Simulated Annealing in C++ via cppOpt <a href="https://github.com/I3ck/cppOpt">cppOpt</a> or <a href="https://github.com/I3ck/cppOpt/blob/master/inc/OptSimulatedAnnealing.h">OptSimulatedAnnealing.h</a></li>
</ul>

<p>"</p>

<p><a href="Category:Heuristic_algorithms" title="wikilink">Category:Heuristic algorithms</a> <a href="Category:Optimization_algorithms_and_methods" title="wikilink">Category:Optimization algorithms and methods</a> <a href="Category:Monte_Carlo_methods" title="wikilink">Category:Monte Carlo methods</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
</ol>
</section>
</body>
</html>
