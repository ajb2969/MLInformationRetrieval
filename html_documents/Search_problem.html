<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="704">Search problem</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Search problem</h1>
<hr/>

<p>In <a href="computational_complexity_theory" title="wikilink">computational complexity theory</a> and <a href="computability_theory" title="wikilink">computability theory</a>, a <strong>search problem</strong> is a type of <a href="computational_problem" title="wikilink">computational problem</a> represented by a <a href="binary_relation" title="wikilink">binary relation</a>. If <em>R</em> is a binary relation such that field(<em>R</em>) ⊆ Γ<sup>+</sup> and <em>T</em> is a <a href="Turing_machine" title="wikilink">Turing machine</a>, then <em>T</em> calculates <em>R</em> if:</p>
<ul>
<li>If <em>x</em> is such that there is some <em>y</em> such that <em>R</em>(<em>x</em>, <em>y</em>) then <em>T</em> accepts <em>x</em> with output <em>z</em> such that <em>R</em>(<em>x</em>, <em>z</em>) (there may be multiple <em>y</em>, and <em>T</em> need only find one of them)</li>
<li>If <em>x</em> is such that there is no <em>y</em> such that <em>R</em>(<em>x</em>, <em>y</em>) then <em>T</em> rejects <em>x</em></li>
</ul>

<p>Intuitively, the problem consists in finding structure "y" in object "x". An <a class="uri" href="algorithm" title="wikilink">algorithm</a> is said to solve the problem if at least one corresponding structure exists, and then one occurrence of this structure is outputted; otherwise, the algorithm stops with an appropriate output ("Item not found" or any message of the like).</p>

<p>Such problems occur very frequently in <a href="graph_theory" title="wikilink">graph theory</a>, for example, where searching graphs for structures such as particular <a href="Matching_(graph_theory)" title="wikilink">matching</a>, <a href="clique_(graph_theory)" title="wikilink">cliques</a>, <a href="Independent_set_(graph_theory)" title="wikilink">independent set</a>, etc. are subjects of interest.</p>

<p>Note that the graph of a partial function is a binary relation, and if <em>T</em> calculates a partial function then there is at most one possible output.</p>

<p>A relation <em>R</em> can be viewed as a search problem, and a Turing machine which calculates <em>R</em> is also said to solve it. Every search problem has a corresponding <a href="decision_problem" title="wikilink">decision problem</a>, namely</p>

<p>

<math display="block" id="Search_problem:0">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>L</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>R</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mi>x</mi>
     <mo>∣</mo>
     <mrow>
      <mo>∃</mo>
      <mrow>
       <mi>y</mi>
       <mi>R</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo>,</mo>
        <mi>y</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>L</ci>
     <ci>R</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <ci>x</ci>
     <apply>
      <exists></exists>
      <apply>
       <times></times>
       <ci>y</ci>
       <ci>R</ci>
       <interval closure="open">
        <ci>x</ci>
        <ci>y</ci>
       </interval>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L(R)=\{x\mid\exists yR(x,y)\}.\,
  </annotation>
 </semantics>
</math>

</p>

<p>This definition may be generalized to <em>n</em>-ary relations using any suitable encoding which allows multiple strings to be compressed into one string (for instance by listing them consecutively with a delimiter).</p>
<h2 id="definition">Definition</h2>

<p>A search problem is defined by:<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>
<ul>
<li>A set of <a href="State_(computer_science)" title="wikilink">states</a></li>
<li>A <a href="start_state" title="wikilink">start state</a></li>
<li>A <a href="goal_state" title="wikilink">goal state</a> or goal test</li>
</ul>
<dl>
<dd>a boolean function which tells us whether a given state is a goal state
</dd>
</dl>
<ul>
<li>A <a href="successor_function" title="wikilink">successor function</a></li>
</ul>
<dl>
<dd>a mapping from a state to a set of new states
</dd>
</dl>
<h2 id="objective">Objective</h2>

<p>Find a solution when not given an algorithm to solve a problem, but only a specification of what a solution looks like.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>
<h2 id="search-method">Search method</h2>
<ul>
<li>Generic search algorithm: given a graph, start nodes, and goal nodes, incrementally explore paths from the start nodes.</li>
<li>Maintain a frontier of paths from the start node that have been explored.</li>
<li>As search proceeds, the frontier expands into the unexplored nodes until a goal node is encountered.</li>
<li>The way in which the frontier is expanded defines the search strategy.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></li>
</ul>

<p><code>   Input: a graph,</code><br/>
<code>       a set of start nodes,</code><br/>
<code>       Boolean procedure goal(n) that tests if n is a goal node.</code><br/>
<code>   frontier := {s : s is a start node};</code><br/>
<code>   while frontier is not empty:</code><br/>
<code>       select and remove path </code><n0 ...="" nk=""><code> from frontier;</code><br/>
<code>       if goal(nk)</code><br/>
<code>           return </code><n0 ...="" nk=""><code>;</code><br/>
<code>       for every neighbor n of nk</code><br/>
<code>           add </code><n0 ...="" n="" nk=""><code> to frontier;</code><br/>
<code>   end while</code></n0></n0></n0></p>
<h2 id="references">References</h2>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Decision_problem" title="wikilink">Decision problem</a></li>
<li><a href="Optimization_problem" title="wikilink">Optimization problem</a></li>
<li><a href="Counting_problem_(complexity)" title="wikilink">Counting problem (complexity)</a></li>
<li><a href="Function_problem" title="wikilink">Function problem</a></li>
<li><a href="Search_games" title="wikilink">Search games</a></li>
</ul>

<p>"</p>

<p><a href="Category:Computational_problems" title="wikilink">Category:Computational problems</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
</ol>
</section>
</body>
</html>
