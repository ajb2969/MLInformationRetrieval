<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="311">Damerau–Levenshtein distance</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Damerau–Levenshtein distance</h1>
<hr>In [[information theory]] and [[computer science]], the '''Damerau–Levenshtein distance''' (named after [[Frederick J. Damerau]] and [[Vladimir Levenshtein|Vladimir I. Levenshtein]]<ref>{{cite conference |last1=Brill |first1=Eric |last2=Moore |first2=Robert C. |year=2000 |title=An Improved Error Model for Noisy Channel Spelling Correction |conference=Proceedings of the 38th Annual Meeting on Association for Computational Linguistics |pages=286–293 |doi=10.3115/1075218.1075255 |url=http://acl.ldc.upenn.edu/P/P00/P00-1037.pdf}}</ref><ref name="bard"></ref><ref>{{cite conference |last1=Li |year=2006|title=Exploring distributional similarity based models for query spelling correction |conference=Proceedings of the 21st International Conference on Computational Linguistics and the 44th annual meeting of the Association for Computational Linguistics |pages=1025–1032 |doi=10.3115/1220175.1220304 |url=http://acl.ldc.upenn.edu/P/P0<style>
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
<style>
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
</ref></hr></body></html>
<body>

<p>6/P06-1129.pdf|display-authors=etal}}) is a <a href="Metric_(mathematics)" title="wikilink">distance</a> (<a href="string_metric" title="wikilink">string metric</a>) between two <a href="string_(computer_science)" title="wikilink">strings</a>, i.e., finite sequence of symbols, given by counting the minimum number of operations needed to transform one string into the other, where an operation is defined as an insertion, deletion, or substitution of a single character, or a <a href="transposition_(mathematics)" title="wikilink">transposition</a> of two <strong>adjacent</strong> characters. In his seminal paper,<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> Damerau not only distinguished these four edit operations but also stated that they correspond to more than 80% of all human misspellings. Damerau's paper considered only misspellings that could be corrected with at most one edit operation.</p>

<p>The Damerau–Levenshtein distance differs from the classical <a href="Levenshtein_distance" title="wikilink">Levenshtein distance</a> by including transpositions among its allowable operations. The classical Levenshtein distance only allows insertion, deletion, and substitution operations.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> Modifying this distance by including transpositions of adjacent symbols produces a different distance measure, known as the Damerau–Levenshtein distance.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>

<p>While the original motivation was to measure distance between human misspellings to improve applications such as <a href="spell_checker" title="wikilink">spell checkers</a>, Damerau–Levenshtein distance has also seen uses in biology to measure the variation between <a class="uri" href="DNA" title="wikilink">DNA</a>.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>
<h2 id="definition">Definition</h2>

<p>The Damerau–Levenshtein distance between two strings 

<math display="inline" id="Damerau–Levenshtein_distance:0">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Damerau–Levenshtein_distance:1">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>

 is given by 

<math display="inline" id="Damerau–Levenshtein_distance:2">
 <semantics>
  <mrow>
   <msub>
    <mi>d</mi>
    <mrow>
     <mi>a</mi>
     <mo>,</mo>
     <mi>b</mi>
    </mrow>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">|</mo>
     <mi>a</mi>
     <mo stretchy="false">|</mo>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mo stretchy="false">|</mo>
     <mi>b</mi>
     <mo stretchy="false">|</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>d</ci>
     <list>
      <ci>a</ci>
      <ci>b</ci>
     </list>
    </apply>
    <interval closure="open">
     <apply>
      <abs></abs>
      <ci>a</ci>
     </apply>
     <apply>
      <abs></abs>
      <ci>b</ci>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d_{a,b}(|a|,|b|)
  </annotation>
 </semantics>
</math>

 where:</p>

<p>

<math display="inline" id="Damerau–Levenshtein_distance:3">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mpadded lspace="20pt" width="+20pt">
      <mi>d</mi>
     </mpadded>
     <mrow>
      <mi>a</mi>
      <mo>,</mo>
      <mi>b</mi>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>i</mi>
     <mo>,</mo>
     <mi>j</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>{</mo>
    <mtable>
     <mtr>
      <mtd columnalign="left">
       <mrow>
        <mi>max</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>i</mi>
         <mo>,</mo>
         <mi>j</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mrow>
          <mtext>if</mtext>
          <mrow>
           <mi>min</mi>
           <mrow>
            <mo stretchy="false">(</mo>
            <mi>i</mi>
            <mo>,</mo>
            <mi>j</mi>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
         </mrow>
         <mo>=</mo>
         <mn>0</mn>
        </mrow>
        <mo>,</mo>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="left">
       <mrow>
        <mi>min</mi>
        <mrow>
         <mo>{</mo>
         <mtable>
          <mtr>
           <mtd columnalign="left">
            <mrow>
             <mrow>
              <msub>
               <mi>d</mi>
               <mrow>
                <mi>a</mi>
                <mo>,</mo>
                <mi>b</mi>
               </mrow>
              </msub>
              <mrow>
               <mo stretchy="false">(</mo>
               <mrow>
                <mi>i</mi>
                <mo>-</mo>
                <mn>1</mn>
               </mrow>
               <mo>,</mo>
               <mi>j</mi>
               <mo stretchy="false">)</mo>
              </mrow>
             </mrow>
             <mo>+</mo>
             <mn>1</mn>
            </mrow>
           </mtd>
           <mtd></mtd>
          </mtr>
          <mtr>
           <mtd columnalign="left">
            <mrow>
             <mrow>
              <msub>
               <mi>d</mi>
               <mrow>
                <mi>a</mi>
                <mo>,</mo>
                <mi>b</mi>
               </mrow>
              </msub>
              <mrow>
               <mo stretchy="false">(</mo>
               <mi>i</mi>
               <mo>,</mo>
               <mrow>
                <mi>j</mi>
                <mo>-</mo>
                <mn>1</mn>
               </mrow>
               <mo stretchy="false">)</mo>
              </mrow>
             </mrow>
             <mo>+</mo>
             <mn>1</mn>
            </mrow>
           </mtd>
           <mtd></mtd>
          </mtr>
          <mtr>
           <mtd columnalign="left">
            <mrow>
             <mrow>
              <msub>
               <mi>d</mi>
               <mrow>
                <mi>a</mi>
                <mo>,</mo>
                <mi>b</mi>
               </mrow>
              </msub>
              <mrow>
               <mo stretchy="false">(</mo>
               <mrow>
                <mi>i</mi>
                <mo>-</mo>
                <mn>1</mn>
               </mrow>
               <mo>,</mo>
               <mrow>
                <mi>j</mi>
                <mo>-</mo>
                <mn>1</mn>
               </mrow>
               <mo stretchy="false">)</mo>
              </mrow>
             </mrow>
             <mo>+</mo>
             <msub>
              <mn>1</mn>
              <mrow>
               <mo stretchy="false">(</mo>
               <msub>
                <mi>a</mi>
                <mi>i</mi>
               </msub>
               <mo>≠</mo>
               <msub>
                <mi>b</mi>
                <mi>j</mi>
               </msub>
               <mo stretchy="false">)</mo>
              </mrow>
             </msub>
            </mrow>
           </mtd>
           <mtd></mtd>
          </mtr>
          <mtr>
           <mtd columnalign="left">
            <mrow>
             <mrow>
              <msub>
               <mi>d</mi>
               <mrow>
                <mi>a</mi>
                <mo>,</mo>
                <mi>b</mi>
               </mrow>
              </msub>
              <mrow>
               <mo stretchy="false">(</mo>
               <mrow>
                <mi>i</mi>
                <mo>-</mo>
                <mn>2</mn>
               </mrow>
               <mo>,</mo>
               <mrow>
                <mi>j</mi>
                <mo>-</mo>
                <mn>2</mn>
               </mrow>
               <mo stretchy="false">)</mo>
              </mrow>
             </mrow>
             <mo>+</mo>
             <mn>1</mn>
            </mrow>
           </mtd>
           <mtd></mtd>
          </mtr>
         </mtable>
        </mrow>
       </mrow>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mrow>
          <mtext>if</mtext>
          <mi>i</mi>
         </mrow>
         <mo>,</mo>
         <mi>j</mi>
        </mrow>
        <mo>></mo>
        <mrow>
         <mn>1</mn>
         <mtext>and</mtext>
         <msub>
          <mi>a</mi>
          <mi>i</mi>
         </msub>
        </mrow>
        <mo>=</mo>
        <mrow>
         <msub>
          <mi>b</mi>
          <mrow>
           <mi>j</mi>
           <mo>-</mo>
           <mn>1</mn>
          </mrow>
         </msub>
         <mtext>and</mtext>
         <msub>
          <mi>a</mi>
          <mrow>
           <mi>i</mi>
           <mo>-</mo>
           <mn>1</mn>
          </mrow>
         </msub>
        </mrow>
        <mo>=</mo>
        <msub>
         <mi>b</mi>
         <mi>j</mi>
        </msub>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="left">
       <mrow>
        <mi>min</mi>
        <mrow>
         <mo>{</mo>
         <mtable>
          <mtr>
           <mtd columnalign="left">
            <mrow>
             <mrow>
              <msub>
               <mi>d</mi>
               <mrow>
                <mi>a</mi>
                <mo>,</mo>
                <mi>b</mi>
               </mrow>
              </msub>
              <mrow>
               <mo stretchy="false">(</mo>
               <mrow>
                <mi>i</mi>
                <mo>-</mo>
                <mn>1</mn>
               </mrow>
               <mo>,</mo>
               <mi>j</mi>
               <mo stretchy="false">)</mo>
              </mrow>
             </mrow>
             <mo>+</mo>
             <mn>1</mn>
            </mrow>
           </mtd>
           <mtd></mtd>
          </mtr>
          <mtr>
           <mtd columnalign="left">
            <mrow>
             <mrow>
              <msub>
               <mi>d</mi>
               <mrow>
                <mi>a</mi>
                <mo>,</mo>
                <mi>b</mi>
               </mrow>
              </msub>
              <mrow>
               <mo stretchy="false">(</mo>
               <mi>i</mi>
               <mo>,</mo>
               <mrow>
                <mi>j</mi>
                <mo>-</mo>
                <mn>1</mn>
               </mrow>
               <mo stretchy="false">)</mo>
              </mrow>
             </mrow>
             <mo>+</mo>
             <mn>1</mn>
            </mrow>
           </mtd>
           <mtd></mtd>
          </mtr>
          <mtr>
           <mtd columnalign="left">
            <mrow>
             <mrow>
              <msub>
               <mi>d</mi>
               <mrow>
                <mi>a</mi>
                <mo>,</mo>
                <mi>b</mi>
               </mrow>
              </msub>
              <mrow>
               <mo stretchy="false">(</mo>
               <mrow>
                <mi>i</mi>
                <mo>-</mo>
                <mn>1</mn>
               </mrow>
               <mo>,</mo>
               <mrow>
                <mi>j</mi>
                <mo>-</mo>
                <mn>1</mn>
               </mrow>
               <mo stretchy="false">)</mo>
              </mrow>
             </mrow>
             <mo>+</mo>
             <msub>
              <mn>1</mn>
              <mrow>
               <mo stretchy="false">(</mo>
               <msub>
                <mi>a</mi>
                <mi>i</mi>
               </msub>
               <mo>≠</mo>
               <msub>
                <mi>b</mi>
                <mi>j</mi>
               </msub>
               <mo stretchy="false">)</mo>
              </mrow>
             </msub>
            </mrow>
           </mtd>
           <mtd></mtd>
          </mtr>
         </mtable>
        </mrow>
       </mrow>
      </mtd>
      <mtd columnalign="left">
       <mtext>otherwise.</mtext>
      </mtd>
     </mtr>
    </mtable>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>d</ci>
      <list>
       <ci>a</ci>
       <ci>b</ci>
      </list>
     </apply>
     <interval closure="open">
      <ci>i</ci>
      <ci>j</ci>
     </interval>
    </apply>
    <apply>
     <csymbol cd="latexml">cases</csymbol>
     <apply>
      <max></max>
      <ci>i</ci>
      <ci>j</ci>
     </apply>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <mtext>if</mtext>
       <apply>
        <min></min>
        <ci>i</ci>
        <ci>j</ci>
       </apply>
      </apply>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <min></min>
      <apply>
       <csymbol cd="latexml">cases</csymbol>
       <apply>
        <plus></plus>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>d</ci>
          <list>
           <ci>a</ci>
           <ci>b</ci>
          </list>
         </apply>
         <interval closure="open">
          <apply>
           <minus></minus>
           <ci>i</ci>
           <cn type="integer">1</cn>
          </apply>
          <ci>j</ci>
         </interval>
        </apply>
        <cn type="integer">1</cn>
       </apply>
       <mtext>otherwise</mtext>
       <apply>
        <plus></plus>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>d</ci>
          <list>
           <ci>a</ci>
           <ci>b</ci>
          </list>
         </apply>
         <interval closure="open">
          <ci>i</ci>
          <apply>
           <minus></minus>
           <ci>j</ci>
           <cn type="integer">1</cn>
          </apply>
         </interval>
        </apply>
        <cn type="integer">1</cn>
       </apply>
       <mtext>otherwise</mtext>
       <apply>
        <plus></plus>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>d</ci>
          <list>
           <ci>a</ci>
           <ci>b</ci>
          </list>
         </apply>
         <interval closure="open">
          <apply>
           <minus></minus>
           <ci>i</ci>
           <cn type="integer">1</cn>
          </apply>
          <apply>
           <minus></minus>
           <ci>j</ci>
           <cn type="integer">1</cn>
          </apply>
         </interval>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <cn type="integer">1</cn>
         <cerror>
          <csymbol cd="ambiguous">fragments</csymbol>
          <ci>normal-(</ci>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>a</ci>
           <ci>i</ci>
          </apply>
          <neq></neq>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>b</ci>
           <ci>j</ci>
          </apply>
          <ci>normal-)</ci>
         </cerror>
        </apply>
       </apply>
       <mtext>otherwise</mtext>
       <apply>
        <plus></plus>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>d</ci>
          <list>
           <ci>a</ci>
           <ci>b</ci>
          </list>
         </apply>
         <interval closure="open">
          <apply>
           <minus></minus>
           <ci>i</ci>
           <cn type="integer">2</cn>
          </apply>
          <apply>
           <minus></minus>
           <ci>j</ci>
           <cn type="integer">2</cn>
          </apply>
         </interval>
        </apply>
        <cn type="integer">1</cn>
       </apply>
       <mtext>otherwise</mtext>
      </apply>
     </apply>
     <apply>
      <and></and>
      <apply>
       <gt></gt>
       <list>
        <apply>
         <times></times>
         <mtext>if</mtext>
         <ci>i</ci>
        </apply>
        <ci>j</ci>
       </list>
       <apply>
        <times></times>
        <cn type="integer">1</cn>
        <mtext>and</mtext>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>a</ci>
         <ci>i</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <eq></eq>
       <share href="#.cmml">
       </share>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>b</ci>
         <apply>
          <minus></minus>
          <ci>j</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <mtext>and</mtext>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>a</ci>
         <apply>
          <minus></minus>
          <ci>i</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
       </apply>
      </apply>
      <apply>
       <eq></eq>
       <share href="#.cmml">
       </share>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>b</ci>
        <ci>j</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <min></min>
      <apply>
       <csymbol cd="latexml">cases</csymbol>
       <apply>
        <plus></plus>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>d</ci>
          <list>
           <ci>a</ci>
           <ci>b</ci>
          </list>
         </apply>
         <interval closure="open">
          <apply>
           <minus></minus>
           <ci>i</ci>
           <cn type="integer">1</cn>
          </apply>
          <ci>j</ci>
         </interval>
        </apply>
        <cn type="integer">1</cn>
       </apply>
       <mtext>otherwise</mtext>
       <apply>
        <plus></plus>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>d</ci>
          <list>
           <ci>a</ci>
           <ci>b</ci>
          </list>
         </apply>
         <interval closure="open">
          <ci>i</ci>
          <apply>
           <minus></minus>
           <ci>j</ci>
           <cn type="integer">1</cn>
          </apply>
         </interval>
        </apply>
        <cn type="integer">1</cn>
       </apply>
       <mtext>otherwise</mtext>
       <apply>
        <plus></plus>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>d</ci>
          <list>
           <ci>a</ci>
           <ci>b</ci>
          </list>
         </apply>
         <interval closure="open">
          <apply>
           <minus></minus>
           <ci>i</ci>
           <cn type="integer">1</cn>
          </apply>
          <apply>
           <minus></minus>
           <ci>j</ci>
           <cn type="integer">1</cn>
          </apply>
         </interval>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <cn type="integer">1</cn>
         <cerror>
          <csymbol cd="ambiguous">fragments</csymbol>
          <ci>normal-(</ci>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>a</ci>
           <ci>i</ci>
          </apply>
          <neq></neq>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>b</ci>
           <ci>j</ci>
          </apply>
          <ci>normal-)</ci>
         </cerror>
        </apply>
       </apply>
       <mtext>otherwise</mtext>
      </apply>
     </apply>
     <mtext>otherwise.</mtext>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \qquad d_{a,b}(i,j)=\begin{cases}\max(i,j)&\text{ if}\min(i,j)=0,\\
\min\begin{cases}d_{a,b}(i-1,j)+1\\
d_{a,b}(i,j-1)+1\\
d_{a,b}(i-1,j-1)+1_{(a_{i}\neq b_{j})}\\
d_{a,b}(i-2,j-2)+1\end{cases}&\text{ if }i,j>1\text{ and }a_{i}=b_{j-1}\text{ %
and }a_{i-1}=b_{j}\\
\min\begin{cases}d_{a,b}(i-1,j)+1\\
d_{a,b}(i,j-1)+1\\
d_{a,b}(i-1,j-1)+1_{(a_{i}\neq b_{j})}\end{cases}&\text{ otherwise.}\end{cases}
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Damerau–Levenshtein_distance:4">
 <semantics>
  <msub>
   <mn>1</mn>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>a</mi>
     <mi>i</mi>
    </msub>
    <mo>≠</mo>
    <msub>
     <mi>b</mi>
     <mi>j</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <cn type="integer">1</cn>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <ci>i</ci>
     </apply>
     <neq></neq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>b</ci>
      <ci>j</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1_{(a_{i}\neq b_{j})}
  </annotation>
 </semantics>
</math>

 is the <a href="indicator_function" title="wikilink">indicator function</a> equal to 0 when 

<math display="inline" id="Damerau–Levenshtein_distance:5">
 <semantics>
  <mrow>
   <msub>
    <mi>a</mi>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <msub>
    <mi>b</mi>
    <mi>j</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>b</ci>
     <ci>j</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{i}=b_{j}
  </annotation>
 </semantics>
</math>

 and equal to 1 otherwise.</p>

<p>Each recursive call matches one of the cases covered by the Damerau–Levenshtein distance:</p>
<ul>
<li>

<math display="inline" id="Damerau–Levenshtein_distance:6">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>d</mi>
     <mrow>
      <mi>a</mi>
      <mo>,</mo>
      <mi>b</mi>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>i</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
     <mo>,</mo>
     <mi>j</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>+</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>d</ci>
      <list>
       <ci>a</ci>
       <ci>b</ci>
      </list>
     </apply>
     <interval closure="open">
      <apply>
       <minus></minus>
       <ci>i</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>j</ci>
     </interval>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d_{a,b}(i-1,j)+1
  </annotation>
 </semantics>
</math>

 corresponds to a deletion (from a to b).</li>
<li>

<math display="inline" id="Damerau–Levenshtein_distance:7">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>d</mi>
     <mrow>
      <mi>a</mi>
      <mo>,</mo>
      <mi>b</mi>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>i</mi>
     <mo>,</mo>
     <mrow>
      <mi>j</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>+</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>d</ci>
      <list>
       <ci>a</ci>
       <ci>b</ci>
      </list>
     </apply>
     <interval closure="open">
      <ci>i</ci>
      <apply>
       <minus></minus>
       <ci>j</ci>
       <cn type="integer">1</cn>
      </apply>
     </interval>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d_{a,b}(i,j-1)+1
  </annotation>
 </semantics>
</math>

 corresponds to an insertion (from a to b).</li>
<li>

<math display="inline" id="Damerau–Levenshtein_distance:8">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>d</mi>
     <mrow>
      <mi>a</mi>
      <mo>,</mo>
      <mi>b</mi>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>i</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mi>j</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>+</mo>
   <msub>
    <mn>1</mn>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>a</mi>
      <mi>i</mi>
     </msub>
     <mo>≠</mo>
     <msub>
      <mi>b</mi>
      <mi>j</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>d</ci>
      <list>
       <ci>a</ci>
       <ci>b</ci>
      </list>
     </apply>
     <interval closure="open">
      <apply>
       <minus></minus>
       <ci>i</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <minus></minus>
       <ci>j</ci>
       <cn type="integer">1</cn>
      </apply>
     </interval>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <cn type="integer">1</cn>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <ci>i</ci>
      </apply>
      <neq></neq>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <ci>j</ci>
      </apply>
      <ci>normal-)</ci>
     </cerror>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d_{a,b}(i-1,j-1)+1_{(a_{i}\neq b_{j})}
  </annotation>
 </semantics>
</math>

 corresponds to a match or mismatch, depending on whether the respective symbols are the same.</li>
<li>

<math display="inline" id="Damerau–Levenshtein_distance:9">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>d</mi>
     <mrow>
      <mi>a</mi>
      <mo>,</mo>
      <mi>b</mi>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>i</mi>
      <mo>-</mo>
      <mn>2</mn>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mi>j</mi>
      <mo>-</mo>
      <mn>2</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>+</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>d</ci>
      <list>
       <ci>a</ci>
       <ci>b</ci>
      </list>
     </apply>
     <interval closure="open">
      <apply>
       <minus></minus>
       <ci>i</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <minus></minus>
       <ci>j</ci>
       <cn type="integer">2</cn>
      </apply>
     </interval>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d_{a,b}(i-2,j-2)+1
  </annotation>
 </semantics>
</math>

 corresponds to a <a href="transposition_(mathematics)" title="wikilink">transposition</a> between two successive symbols.</li>
</ul>
<h2 id="algorithm">Algorithm</h2>

<p>Presented here are two algorithms: the first,<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> simpler one, computes what is known as the <a href="optimal_string_alignment" title="wikilink">optimal string alignment</a> (sometimes called the <em>restricted edit distance</em>), while the second one<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> computes the Damerau–Levenshtein distance with adjacent transpositions. Adding transpositions adds significant complexity. The difference between the two algorithms consists in that the <em>optimal string alignment algorithm</em> computes the number of edit operations needed to make the strings equal under the condition that <strong>no substring is edited more than once</strong>, whereas the second one presents no such restriction.</p>

<p>Take for example the edit distance between <strong>CA</strong> and <strong>ABC</strong>. The Damerau–Levenshtein distance LD(<strong>CA</strong>,<strong>ABC</strong>) = 2 because <strong>CA</strong> → <strong>AC</strong> → <strong>ABC</strong>, but the optimal string alignment distance OSA(<strong>CA</strong>,<strong>ABC</strong>) = 3 because if the operation <strong>CA</strong> → <strong>AC</strong> is used, it is not possible to use <strong>AC</strong> → <strong>ABC</strong> because that would require the substring to be edited more than once, which is not allowed in OSA, and therefore the shortest sequence of operations is <strong>CA</strong> → <strong>A</strong> → <strong>AB</strong> → <strong>ABC</strong>. Note that for the optimal string alignment distance, the <a href="triangle_inequality" title="wikilink">triangle inequality</a> does not hold: OSA(<strong>CA</strong>,<strong>AC</strong>) + OSA(<strong>AC</strong>,<strong>ABC</strong>) </p>

<p><code>int OptimalStringAlignmentDistance(char str1[1..lenStr1], char str2[1..lenStr2])</code><br/>
<code>   // d is a table with lenStr1+1 rows and lenStr2+1 columns</code><br/>
<code>   declare int d[0..lenStr1, 0..lenStr2]</code></p>

<p><code>   // i and j are used to iterate over str1 and str2</code><br/>
<code>   declare int i, j, cost</code></p>

<p><code>   // for loop is inclusive, need table 1 row/column larger than string length</code><br/>
<code>   for i from 0 to lenStr1</code><br/>
<code>       d[i, 0] := i</code><br/>
<code>   for j from 1 to lenStr2</code><br/>
<code>       d[0, j] := j</code></p>

<p><code>   // pseudo-code assumes string indices start at 1, not 0</code><br/>
<code>   // if implemented, make sure to start comparing at 1st letter of strings</code><br/>
<code>   for i from 1 to lenStr1</code><br/>
<code>       for j from 1 to lenStr2</code><br/>
<code>           if str1[i] = str2[j] then cost := 0</code><br/>
<code>                                else cost := 1</code><br/>
<code>           d[i, j] := minimum(</code><br/>
<code>                                d[i-1, j  ] + 1,     // deletion</code><br/>
<code>                                d[i  , j-1] + 1,     // insertion</code><br/>
<code>                                d[i-1, j-1] + cost   // substitution</code><br/>
<code>                            )</code><br/>
<code>           if(i &gt; 1 and j &gt; 1 and str1[i] = str2[j-1] and str1[i-1] = str2[j]) then</code><br/>
<code>               d[i, j] := minimum(</code><br/>
<code>                                d[i, j],</code><br/>
<code>                                d[i-2, j-2] + cost   // transposition</code><br/>
<code>                             )</code></p>

<p><code>   return d[lenStr1, lenStr2]</code></p>

<p>Basically this is the algorithm to compute <a href="Levenshtein_distance" title="wikilink">Levenshtein distance</a> with one additional recurrence:</p>
<div class="sourceCode"><pre class="sourceCode pascal"><code class="sourceCode pascal">            <span class="kw">if</span>(i &gt; <span class="dv">1</span> <span class="kw">and</span> j &gt; <span class="dv">1</span> <span class="kw">and</span> str1[i] = str2[j<span class="dv">-1</span>] <span class="kw">and</span> str1[i<span class="dv">-1</span>] = str2[j]) <span class="kw">then</span>
                d[i, j] := minimum(
                                 d[i, j],
                                 d[i<span class="dv">-2</span>, j<span class="dv">-2</span>] + cost   <span class="co">// transposition</span>
                              )</code></pre></div>
<h3 id="distance-with-adjacent-transpositions">Distance with adjacent transpositions</h3>

<p>Here is the second algorithm that computes the true Damerau–Levenshtein distance with adjacent transpositions (ActionScript 3.0); this function requires as an additional parameter the size of the alphabet (<em>C</em>), so that all entries of the arrays are in 0..(<em>C</em>−1):</p>
<pre class="actionscript3"><code>static public function damerauLevenshteinDistance(a:Array, b:Array, C:uint):uint
{
    // "infinite" distance is just the max possible distance
    var INF:uint = a.length + b.length;

    // make and initialize the character array indices
    var DA:Array = new Array(C);
    for (var k:uint = 0; k &lt; C; ++k) DA[k]=0;

    // make the distance matrix H[-1..a.length][-1..b.length]
    var H:matrix = new matrix(a.length+2,b.length+2);

    // initialize the left and top edges of H
    H[-1][-1] = INF;
    for (var i:uint = 0; i &lt;= a.length; ++i)
    {
        H[i][-1] = INF;
        H[i][ 0] = i;
    }
    for (var j:uint = 0; j &lt;= b.length; ++j)
    {
        H[-1][j] = INF;
        H[ 0][j] = j;
    }

    // fill in the distance matrix H
    // look at each character in a
    for (var i:uint = 1; i &lt;= a.length; ++i)
    {
        var DB:uint = 0;
        // look at each character in b
        for (var j:uint = 1; j &lt;= b.length; ++j)
        {
            var i1:uint = DA[b[j-1]];
            var j1:uint = DB;
            var cost:uint;
            if (a[i-1] == b[j-1])
               {
                 cost = 0;
                 DB   = j;
               }
            else
               cost = 1;
            H[i][j] = Math.min(    H[i-1 ][j-1 ] + cost,  // substitution
                                   H[i   ][j-1 ] + 1,     // insertion
                                   H[i-1 ][j   ] + 1,     // deletion
                                   H[i1-1][j1-1] + (i-i1-1) + 1 + (j-j1-1));
        }
        DA[a[i-1]] = i;
    }
    return H[a.length][b.length];
}</code></pre>
<dl>
<dd><small><strong>Note</strong>: the algorithm given in the paper uses alphabet 1..C rather than the 0..<em>C</em>−1 used here; the paper indexes arrays: H[−1..|A|,−1..|B|] and DA[1..C]; here DA[0..C−1] is used; the paper seems to be missing the necessary line H[−1,−1] = INF</small>
</dd>
</dl>

<p>To devise a proper algorithm to calculate unrestricted Damerau–Levenshtein distance note that there always exists an optimal sequence of edit operations, where once-transposed letters are never modified afterwards. (This holds as long as the cost of a transposition, 

<math display="inline" id="Damerau–Levenshtein_distance:10">
 <semantics>
  <msub>
   <mi>W</mi>
   <mi>T</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>W</ci>
    <ci>T</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W_{T}
  </annotation>
 </semantics>
</math>

, is at least the average of the cost of an insertion and deletion, i.e., 

<math display="inline" id="Damerau–Levenshtein_distance:11">
 <semantics>
  <mrow>
   <mrow>
    <mn>2</mn>
    <msub>
     <mi>W</mi>
     <mi>T</mi>
    </msub>
   </mrow>
   <mo>≥</mo>
   <mrow>
    <msub>
     <mi>W</mi>
     <mi>I</mi>
    </msub>
    <mo>+</mo>
    <msub>
     <mi>W</mi>
     <mi>D</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <times></times>
     <cn type="integer">2</cn>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>W</ci>
      <ci>T</ci>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>W</ci>
      <ci>I</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>W</ci>
      <ci>D</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2W_{T}\geq W_{I}+W_{D}
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a>) Thus, we need to consider only two symmetric ways of modifying a substring more than once: (1) transpose letters and insert an arbitrary number of characters between them, or (2) delete a sequence of characters and transpose letters that become adjacent after deletion. The straightforward implementation of this idea gives an algorithm of cubic complexity

<math display="block" id="Damerau–Levenshtein_distance:12">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo>(</mo>
    <mrow>
     <mi>M</mi>
     <mo>⋅</mo>
     <mi>N</mi>
     <mo>⋅</mo>
     <mrow>
      <mi>max</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>M</mi>
       <mo>,</mo>
       <mi>N</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <ci>normal-⋅</ci>
     <ci>M</ci>
     <ci>N</ci>
     <apply>
      <max></max>
      <ci>M</ci>
      <ci>N</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O\left(M\cdot N\cdot\max(M,N)\right)
  </annotation>
 </semantics>
</math>

, where <em>M</em> and <em>N</em> are string lengths. Using the ideas of Lowrance and Wagner,<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> this naive algorithm can be improved to be 

<math display="inline" id="Damerau–Levenshtein_distance:13">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo>(</mo>
    <mrow>
     <mi>M</mi>
     <mo>⋅</mo>
     <mi>N</mi>
    </mrow>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <ci>normal-⋅</ci>
     <ci>M</ci>
     <ci>N</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O\left(M\cdot N\right)
  </annotation>
 </semantics>
</math>

 in the worst case.</p>

<p>It is interesting that the <a href="bitap_algorithm" title="wikilink">bitap algorithm</a> can be modified to process transposition. See the information retrieval section of for an example of such an adaptation.</p>
<h2 id="applications">Applications</h2>

<p>Damerau–Levenshtein distance plays an important role in <a href="natural_language_processing" title="wikilink">natural language processing</a>. In natural languages, strings are short and the number of errors (misspellings) rarely exceeds 2. In such circumstances, restricted and real edit distance differ very rarely. Oommen and Loke even mitigated the limitation of the restricted edit distance by introducing <em>generalized transpositions</em>. Nevertheless, one must remember that the restricted edit distance usually does not satisfy the <a href="triangle_inequality" title="wikilink">triangle inequality</a> and, thus, cannot be used with <a href="metric_tree" title="wikilink">metric trees</a>.</p>
<h3 id="dna">DNA</h3>

<p>Since <a class="uri" href="DNA" title="wikilink">DNA</a> frequently undergoes insertions, deletions, substitutions, and transpositions, and each of these operations occurs on approximately the same timescale, the Damerau–Levenshtein distance is an appropriate metric of the variation between two strands of DNA. More common in DNA, protein, and other bioinformatics related alignment tasks is the use of closely related algorithms such as <a href="Needleman–Wunsch_algorithm" title="wikilink">Needleman–Wunsch algorithm</a> or <a href="Smith–Waterman_algorithm" title="wikilink">Smith–Waterman algorithm</a>.</p>
<h3 id="fraud-detection">Fraud detection</h3>

<p>The algorithm can be used with any set of words, like vendor names. Since entry is manual by nature there is a risk of entering a false vendor. A fraudster employee may enter one real vendor such as "Rich Heir Estate Services" versus a false vendor "Rich Hier State Services". The fraudster would then create a false bank account and have the company route checks to the real vendor and false vendor. The Damerau–Levenshtein algorithm will detect the transposed and dropped letter and bring attention of the items to a fraud examiner.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Approximate_string_matching" title="wikilink">Approximate string matching</a></li>
<li><a href="Levenshtein_automata" title="wikilink">Levenshtein automata</a></li>
<li><a class="uri" href="Typosquatting" title="wikilink">Typosquatting</a></li>
</ul>
<h2 id="references">References</h2>
<h2 id="further-reading">Further reading</h2>
<ul>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:String_similarity_measures" title="wikilink">Category:String similarity measures</a> <a href="Category:Information_theory" title="wikilink">Category:Information theory</a> <a href="Category:Dynamic_programming" title="wikilink">Category:Dynamic programming</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3">. The isbn produces two hits: a 2007 work and a 2010 work at World Cat.<a href="#fnref3">↩</a></li>
<li id="fn4">The method used in: <a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"></li>
<li id="fn8"></li>
</ol>
</section>
</body>

